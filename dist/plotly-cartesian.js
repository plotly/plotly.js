/**
* plotly.js (cartesian) v3.0.1
* Copyright 2012-2025, Plotly, Inc.
* All rights reserved.
* Licensed under the MIT license
*/
(
 function(root, factory) {
  if (typeof module === "object" && module.exports) {
   module.exports = factory();
  } else {
   root.moduleName = factory();
  }
} (typeof self !== "undefined" ? self : this, () => {
"use strict";
var Plotly = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/version.js
  var require_version = __commonJS({
    "src/version.js"(exports) {
      "use strict";
      exports.version = "3.0.1";
    }
  });

  // node_modules/native-promise-only/lib/npo.src.js
  var require_npo_src = __commonJS({
    "node_modules/native-promise-only/lib/npo.src.js"(exports, module) {
      (function UMD(name, context, definition) {
        context[name] = context[name] || definition();
        if (typeof module != "undefined" && module.exports) {
          module.exports = context[name];
        } else if (typeof define == "function" && false) {
          define(function $AMD$() {
            return context[name];
          });
        }
      })("Promise", typeof window != "undefined" ? window : exports, function DEF() {
        "use strict";
        var builtInProp, cycle, scheduling_queue, ToString = Object.prototype.toString, timer = typeof setImmediate != "undefined" ? function timer2(fn) {
          return setImmediate(fn);
        } : setTimeout;
        try {
          Object.defineProperty({}, "x", {});
          builtInProp = function builtInProp2(obj, name, val, config) {
            return Object.defineProperty(obj, name, {
              value: val,
              writable: true,
              configurable: config !== false
            });
          };
        } catch (err) {
          builtInProp = function builtInProp2(obj, name, val) {
            obj[name] = val;
            return obj;
          };
        }
        scheduling_queue = /* @__PURE__ */ function Queue() {
          var first, last, item;
          function Item(fn, self2) {
            this.fn = fn;
            this.self = self2;
            this.next = void 0;
          }
          return {
            add: function add(fn, self2) {
              item = new Item(fn, self2);
              if (last) {
                last.next = item;
              } else {
                first = item;
              }
              last = item;
              item = void 0;
            },
            drain: function drain() {
              var f = first;
              first = last = cycle = void 0;
              while (f) {
                f.fn.call(f.self);
                f = f.next;
              }
            }
          };
        }();
        function schedule(fn, self2) {
          scheduling_queue.add(fn, self2);
          if (!cycle) {
            cycle = timer(scheduling_queue.drain);
          }
        }
        function isThenable(o) {
          var _then, o_type = typeof o;
          if (o != null && (o_type == "object" || o_type == "function")) {
            _then = o.then;
          }
          return typeof _then == "function" ? _then : false;
        }
        function notify() {
          for (var i = 0; i < this.chain.length; i++) {
            notifyIsolated(
              this,
              this.state === 1 ? this.chain[i].success : this.chain[i].failure,
              this.chain[i]
            );
          }
          this.chain.length = 0;
        }
        function notifyIsolated(self2, cb, chain) {
          var ret, _then;
          try {
            if (cb === false) {
              chain.reject(self2.msg);
            } else {
              if (cb === true) {
                ret = self2.msg;
              } else {
                ret = cb.call(void 0, self2.msg);
              }
              if (ret === chain.promise) {
                chain.reject(TypeError("Promise-chain cycle"));
              } else if (_then = isThenable(ret)) {
                _then.call(ret, chain.resolve, chain.reject);
              } else {
                chain.resolve(ret);
              }
            }
          } catch (err) {
            chain.reject(err);
          }
        }
        function resolve(msg) {
          var _then, self2 = this;
          if (self2.triggered) {
            return;
          }
          self2.triggered = true;
          if (self2.def) {
            self2 = self2.def;
          }
          try {
            if (_then = isThenable(msg)) {
              schedule(function() {
                var def_wrapper = new MakeDefWrapper(self2);
                try {
                  _then.call(
                    msg,
                    function $resolve$() {
                      resolve.apply(def_wrapper, arguments);
                    },
                    function $reject$() {
                      reject.apply(def_wrapper, arguments);
                    }
                  );
                } catch (err) {
                  reject.call(def_wrapper, err);
                }
              });
            } else {
              self2.msg = msg;
              self2.state = 1;
              if (self2.chain.length > 0) {
                schedule(notify, self2);
              }
            }
          } catch (err) {
            reject.call(new MakeDefWrapper(self2), err);
          }
        }
        function reject(msg) {
          var self2 = this;
          if (self2.triggered) {
            return;
          }
          self2.triggered = true;
          if (self2.def) {
            self2 = self2.def;
          }
          self2.msg = msg;
          self2.state = 2;
          if (self2.chain.length > 0) {
            schedule(notify, self2);
          }
        }
        function iteratePromises(Constructor, arr, resolver, rejecter) {
          for (var idx = 0; idx < arr.length; idx++) {
            (function IIFE(idx2) {
              Constructor.resolve(arr[idx2]).then(
                function $resolver$(msg) {
                  resolver(idx2, msg);
                },
                rejecter
              );
            })(idx);
          }
        }
        function MakeDefWrapper(self2) {
          this.def = self2;
          this.triggered = false;
        }
        function MakeDef(self2) {
          this.promise = self2;
          this.state = 0;
          this.triggered = false;
          this.chain = [];
          this.msg = void 0;
        }
        function Promise2(executor) {
          if (typeof executor != "function") {
            throw TypeError("Not a function");
          }
          if (this.__NPO__ !== 0) {
            throw TypeError("Not a promise");
          }
          this.__NPO__ = 1;
          var def = new MakeDef(this);
          this["then"] = function then(success, failure) {
            var o = {
              success: typeof success == "function" ? success : true,
              failure: typeof failure == "function" ? failure : false
            };
            o.promise = new this.constructor(function extractChain(resolve2, reject2) {
              if (typeof resolve2 != "function" || typeof reject2 != "function") {
                throw TypeError("Not a function");
              }
              o.resolve = resolve2;
              o.reject = reject2;
            });
            def.chain.push(o);
            if (def.state !== 0) {
              schedule(notify, def);
            }
            return o.promise;
          };
          this["catch"] = function $catch$(failure) {
            return this.then(void 0, failure);
          };
          try {
            executor.call(
              void 0,
              function publicResolve(msg) {
                resolve.call(def, msg);
              },
              function publicReject(msg) {
                reject.call(def, msg);
              }
            );
          } catch (err) {
            reject.call(def, err);
          }
        }
        var PromisePrototype = builtInProp(
          {},
          "constructor",
          Promise2,
          /*configurable=*/
          false
        );
        Promise2.prototype = PromisePrototype;
        builtInProp(
          PromisePrototype,
          "__NPO__",
          0,
          /*configurable=*/
          false
        );
        builtInProp(Promise2, "resolve", function Promise$resolve(msg) {
          var Constructor = this;
          if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
            return msg;
          }
          return new Constructor(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            resolve2(msg);
          });
        });
        builtInProp(Promise2, "reject", function Promise$reject(msg) {
          return new this(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            reject2(msg);
          });
        });
        builtInProp(Promise2, "all", function Promise$all(arr) {
          var Constructor = this;
          if (ToString.call(arr) != "[object Array]") {
            return Constructor.reject(TypeError("Not an array"));
          }
          if (arr.length === 0) {
            return Constructor.resolve([]);
          }
          return new Constructor(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            var len = arr.length, msgs = Array(len), count = 0;
            iteratePromises(Constructor, arr, function resolver(idx, msg) {
              msgs[idx] = msg;
              if (++count === len) {
                resolve2(msgs);
              }
            }, reject2);
          });
        });
        builtInProp(Promise2, "race", function Promise$race(arr) {
          var Constructor = this;
          if (ToString.call(arr) != "[object Array]") {
            return Constructor.reject(TypeError("Not an array"));
          }
          return new Constructor(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            iteratePromises(Constructor, arr, function resolver(idx, msg) {
              resolve2(msg);
            }, reject2);
          });
        });
        return Promise2;
      });
    }
  });

  // node_modules/@plotly/d3/d3.js
  var require_d3 = __commonJS({
    "node_modules/@plotly/d3/d3.js"(exports, module) {
      !function() {
        var d3 = {
          version: "3.8.2"
        };
        var d3_arraySlice = [].slice, d3_array = function(list) {
          return d3_arraySlice.call(list);
        };
        var d3_document = self.document;
        function d3_documentElement(node) {
          return node && (node.ownerDocument || node.document || node).documentElement;
        }
        function d3_window(node) {
          return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
        }
        if (d3_document) {
          try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
          } catch (e) {
            d3_array = function(list) {
              var i = list.length, array = new Array(i);
              while (i--) array[i] = list[i];
              return array;
            };
          }
        }
        if (!Date.now) Date.now = function() {
          return +/* @__PURE__ */ new Date();
        };
        if (d3_document) {
          try {
            d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
          } catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function(name, value) {
              d3_element_setAttribute.call(this, name, value + "");
            };
            d3_element_prototype.setAttributeNS = function(space, local, value) {
              d3_element_setAttributeNS.call(this, space, local, value + "");
            };
            d3_style_prototype.setProperty = function(name, value, priority) {
              d3_style_setProperty.call(this, name, value + "", priority);
            };
          }
        }
        d3.ascending = d3_ascending;
        function d3_ascending(a, b) {
          return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }
        d3.descending = function(a, b) {
          return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
        };
        d3.min = function(array, f) {
          var i = -1, n = array.length, a, b;
          if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = array[i]) != null && a > b) a = b;
          } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
          }
          return a;
        };
        d3.max = function(array, f) {
          var i = -1, n = array.length, a, b;
          if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = array[i]) != null && b > a) a = b;
          } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
          }
          return a;
        };
        d3.extent = function(array, f) {
          var i = -1, n = array.length, a, b, c;
          if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
              a = c = b;
              break;
            }
            while (++i < n) if ((b = array[i]) != null) {
              if (a > b) a = b;
              if (c < b) c = b;
            }
          } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = c = b;
              break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
              if (a > b) a = b;
              if (c < b) c = b;
            }
          }
          return [a, c];
        };
        function d3_number(x) {
          return x === null ? NaN : +x;
        }
        function d3_numeric(x) {
          return !isNaN(x);
        }
        d3.sum = function(array, f) {
          var s = 0, n = array.length, a, i = -1;
          if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = +array[i])) s += a;
          } else {
            while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
          }
          return s;
        };
        d3.mean = function(array, f) {
          var s = 0, n = array.length, a, i = -1, j = n;
          if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a;
            else --j;
          } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a;
            else --j;
          }
          if (j) return s / j;
        };
        d3.quantile = function(values, p) {
          var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
          return e ? v + e * (values[h] - v) : v;
        };
        d3.median = function(array, f) {
          var numbers = [], n = array.length, a, i = -1;
          if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
          } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
          }
          if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), 0.5);
        };
        d3.variance = function(array, f) {
          var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
          if (arguments.length === 1) {
            while (++i < n) {
              if (d3_numeric(a = d3_number(array[i]))) {
                d = a - m;
                m += d / ++j;
                s += d * (a - m);
              }
            }
          } else {
            while (++i < n) {
              if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                d = a - m;
                m += d / ++j;
                s += d * (a - m);
              }
            }
          }
          if (j > 1) return s / (j - 1);
        };
        d3.deviation = function() {
          var v = d3.variance.apply(this, arguments);
          return v ? Math.sqrt(v) : v;
        };
        function d3_bisector(compare) {
          return {
            left: function(a, x, lo, hi) {
              if (arguments.length < 3) lo = 0;
              if (arguments.length < 4) hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
              }
              return lo;
            },
            right: function(a, x, lo, hi) {
              if (arguments.length < 3) lo = 0;
              if (arguments.length < 4) hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) > 0) hi = mid;
                else lo = mid + 1;
              }
              return lo;
            }
          };
        }
        var d3_bisect = d3_bisector(d3_ascending);
        d3.bisectLeft = d3_bisect.left;
        d3.bisect = d3.bisectRight = d3_bisect.right;
        d3.bisector = function(f) {
          return d3_bisector(f.length === 1 ? function(d, x) {
            return d3_ascending(f(d), x);
          } : f);
        };
        d3.shuffle = function(array, i0, i1) {
          if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2) i0 = 0;
          }
          var m = i1 - i0, t, i;
          while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
          }
          return array;
        };
        d3.permute = function(array, indexes) {
          var i = indexes.length, permutes = new Array(i);
          while (i--) permutes[i] = array[indexes[i]];
          return permutes;
        };
        d3.pairs = function(array) {
          var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
          while (i < n) pairs[i] = [p0 = p1, p1 = array[++i]];
          return pairs;
        };
        d3.transpose = function(matrix) {
          if (!(n = matrix.length)) return [];
          for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
              row[j] = matrix[j][i];
            }
          }
          return transpose;
        };
        function d3_transposeLength(d) {
          return d.length;
        }
        d3.zip = function() {
          return d3.transpose(arguments);
        };
        d3.keys = function(map) {
          var keys = [];
          for (var key in map) keys.push(key);
          return keys;
        };
        d3.values = function(map) {
          var values = [];
          for (var key in map) values.push(map[key]);
          return values;
        };
        d3.entries = function(map) {
          var entries = [];
          for (var key in map) entries.push({
            key,
            value: map[key]
          });
          return entries;
        };
        d3.merge = function(arrays) {
          var n = arrays.length, m, i = -1, j = 0, merged, array;
          while (++i < n) j += arrays[i].length;
          merged = new Array(j);
          while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
              merged[--j] = array[m];
            }
          }
          return merged;
        };
        var abs = Math.abs;
        d3.range = function(start, stop, step) {
          if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
              stop = start;
              start = 0;
            }
          }
          if ((stop - start) / step === Infinity) throw new Error("infinite range");
          var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
          start *= k, stop *= k, step *= k;
          if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);
          else while ((j = start + step * ++i) < stop) range.push(j / k);
          return range;
        };
        function d3_range_integerScale(x) {
          var k = 1;
          while (x * k % 1) k *= 10;
          return k;
        }
        function d3_class(ctor, properties) {
          for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
              value: properties[key],
              enumerable: false
            });
          }
        }
        d3.map = function(object, f) {
          var map = new d3_Map();
          if (object instanceof d3_Map) {
            object.forEach(function(key2, value) {
              map.set(key2, value);
            });
          } else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1) while (++i < n) map.set(i, object[i]);
            else while (++i < n) map.set(f.call(object, o = object[i], i), o);
          } else {
            for (var key in object) map.set(key, object[key]);
          }
          return map;
        };
        function d3_Map() {
          this._ = /* @__PURE__ */ Object.create(null);
        }
        var d3_map_proto = "__proto__", d3_map_zero = "\0";
        d3_class(d3_Map, {
          has: d3_map_has,
          get: function(key) {
            return this._[d3_map_escape(key)];
          },
          set: function(key, value) {
            return this._[d3_map_escape(key)] = value;
          },
          remove: d3_map_remove,
          keys: d3_map_keys,
          values: function() {
            var values = [];
            for (var key in this._) values.push(this._[key]);
            return values;
          },
          entries: function() {
            var entries = [];
            for (var key in this._) entries.push({
              key: d3_map_unescape(key),
              value: this._[key]
            });
            return entries;
          },
          size: d3_map_size,
          empty: d3_map_empty,
          forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
          }
        });
        function d3_map_escape(key) {
          return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
        }
        function d3_map_unescape(key) {
          return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
        }
        function d3_map_has(key) {
          return d3_map_escape(key) in this._;
        }
        function d3_map_remove(key) {
          return (key = d3_map_escape(key)) in this._ && delete this._[key];
        }
        function d3_map_keys() {
          var keys = [];
          for (var key in this._) keys.push(d3_map_unescape(key));
          return keys;
        }
        function d3_map_size() {
          var size = 0;
          for (var key in this._) ++size;
          return size;
        }
        function d3_map_empty() {
          for (var key in this._) return false;
          return true;
        }
        d3.nest = function() {
          var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
          function map(mapType, array, depth) {
            if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
              if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                values.push(object);
              } else {
                valuesByKey.set(keyValue, [object]);
              }
            }
            if (mapType) {
              object = mapType();
              setter = function(keyValue2, values2) {
                object.set(keyValue2, map(mapType, values2, depth));
              };
            } else {
              object = {};
              setter = function(keyValue2, values2) {
                object[keyValue2] = map(mapType, values2, depth);
              };
            }
            valuesByKey.forEach(setter);
            return object;
          }
          function entries(map2, depth) {
            if (depth >= keys.length) return map2;
            var array = [], sortKey = sortKeys[depth++];
            map2.forEach(function(key, keyMap) {
              array.push({
                key,
                values: entries(keyMap, depth)
              });
            });
            return sortKey ? array.sort(function(a, b) {
              return sortKey(a.key, b.key);
            }) : array;
          }
          nest.map = function(array, mapType) {
            return map(mapType, array, 0);
          };
          nest.entries = function(array) {
            return entries(map(d3.map, array, 0), 0);
          };
          nest.key = function(d) {
            keys.push(d);
            return nest;
          };
          nest.sortKeys = function(order) {
            sortKeys[keys.length - 1] = order;
            return nest;
          };
          nest.sortValues = function(order) {
            sortValues = order;
            return nest;
          };
          nest.rollup = function(f) {
            rollup = f;
            return nest;
          };
          return nest;
        };
        d3.set = function(array) {
          var set = new d3_Set();
          if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
          return set;
        };
        function d3_Set() {
          this._ = /* @__PURE__ */ Object.create(null);
        }
        d3_class(d3_Set, {
          has: d3_map_has,
          add: function(key) {
            this._[d3_map_escape(key += "")] = true;
            return key;
          },
          remove: d3_map_remove,
          values: d3_map_keys,
          size: d3_map_size,
          empty: d3_map_empty,
          forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key));
          }
        });
        d3.behavior = {};
        function d3_identity(d) {
          return d;
        }
        d3.rebind = function(target, source) {
          var i = 1, n = arguments.length, method;
          while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
          return target;
        };
        function d3_rebind(target, source, method) {
          return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
          };
        }
        function d3_vendorSymbol(object, name) {
          if (name in object) return name;
          name = name.charAt(0).toUpperCase() + name.slice(1);
          for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object) return prefixName;
          }
        }
        var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
        function d3_noop() {
        }
        d3.dispatch = function() {
          var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
          while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
          return dispatch;
        };
        function d3_dispatch() {
        }
        d3_dispatch.prototype.on = function(type, listener) {
          var i = type.indexOf("."), name = "";
          if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
          }
          if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
          if (arguments.length === 2) {
            if (listener == null) for (type in this) {
              if (this.hasOwnProperty(type)) this[type].on(name, null);
            }
            return this;
          }
        };
        function d3_dispatch_event(dispatch) {
          var listeners = [], listenerByName = new d3_Map();
          function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n) if (l = z[i].on) l.apply(this, arguments);
            return dispatch;
          }
          event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2) return l && l.on;
            if (l) {
              l.on = null;
              listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
              listenerByName.remove(name);
            }
            if (listener) listeners.push(listenerByName.set(name, {
              on: listener
            }));
            return dispatch;
          };
          return event;
        }
        d3.event = null;
        function d3_eventPreventDefault() {
          d3.event.preventDefault();
        }
        function d3_eventSource() {
          var e = d3.event, s;
          while (s = e.sourceEvent) e = s;
          return e;
        }
        function d3_eventDispatch(target) {
          var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
          while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
          dispatch.of = function(thiz, argumentz) {
            return function(e1) {
              try {
                var e0 = e1.sourceEvent = d3.event;
                e1.target = target;
                d3.event = e1;
                dispatch[e1.type].apply(thiz, argumentz);
              } finally {
                d3.event = e0;
              }
            };
          };
          return dispatch;
        }
        d3.requote = function(s) {
          return s.replace(d3_requote_re, "\\$&");
        };
        var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
        var d3_subclass = {}.__proto__ ? function(object, prototype) {
          object.__proto__ = prototype;
        } : function(object, prototype) {
          for (var property in prototype) object[property] = prototype[property];
        };
        function d3_selection(groups) {
          d3_subclass(groups, d3_selectionPrototype);
          return groups;
        }
        var d3_select = function(s, n) {
          return n.querySelector(s);
        }, d3_selectAll = function(s, n) {
          return n.querySelectorAll(s);
        }, d3_selectMatches = function(n, s) {
          var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
          d3_selectMatches = function(n2, s2) {
            return d3_selectMatcher.call(n2, s2);
          };
          return d3_selectMatches(n, s);
        };
        if (typeof Sizzle === "function") {
          d3_select = function(s, n) {
            return Sizzle(s, n)[0] || null;
          };
          d3_selectAll = Sizzle;
          d3_selectMatches = Sizzle.matchesSelector;
        }
        d3.selection = function() {
          return d3.select(d3_document.documentElement);
        };
        var d3_selectionPrototype = d3.selection.prototype = [];
        d3_selectionPrototype.select = function(selector) {
          var subgroups = [], subgroup, subnode, group, node;
          selector = d3_selection_selector(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_selector(selector) {
          return typeof selector === "function" ? selector : function() {
            return d3_select(selector, this);
          };
        }
        d3_selectionPrototype.selectAll = function(selector) {
          var subgroups = [], subgroup, node;
          selector = d3_selection_selectorAll(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                subgroup.parentNode = node;
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_selectorAll(selector) {
          return typeof selector === "function" ? selector : function() {
            return d3_selectAll(selector, this);
          };
        }
        var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
        var d3_nsPrefix = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: d3_nsXhtml,
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/"
        };
        d3.ns = {
          prefix: d3_nsPrefix,
          qualify: function(name) {
            var i = name.indexOf(":"), prefix = name;
            if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
              space: d3_nsPrefix[prefix],
              local: name
            } : name;
          }
        };
        d3_selectionPrototype.attr = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") {
              var node = this.node();
              name = d3.ns.qualify(name);
              return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name) this.each(d3_selection_attr(value, name[value]));
            return this;
          }
          return this.each(d3_selection_attr(name, value));
        };
        function d3_selection_attr(name, value) {
          name = d3.ns.qualify(name);
          function attrNull() {
            this.removeAttribute(name);
          }
          function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
          }
          function attrConstant() {
            this.setAttribute(name, value);
          }
          function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
          }
          function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttribute(name);
            else this.setAttribute(name, x);
          }
          function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttributeNS(name.space, name.local);
            else this.setAttributeNS(name.space, name.local, x);
          }
          return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
        }
        function d3_collapse(s) {
          return s.trim().replace(/\s+/g, " ");
        }
        d3_selectionPrototype.classed = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") {
              var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
              if (value = node.classList) {
                while (++i < n) if (!value.contains(name[i])) return false;
              } else {
                value = node.getAttribute("class");
                while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
              }
              return true;
            }
            for (value in name) this.each(d3_selection_classed(value, name[value]));
            return this;
          }
          return this.each(d3_selection_classed(name, value));
        };
        function d3_selection_classedRe(name) {
          return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
        }
        function d3_selection_classes(name) {
          return (name + "").trim().split(/^|\s+/);
        }
        function d3_selection_classed(name, value) {
          name = d3_selection_classes(name).map(d3_selection_classedName);
          var n = name.length;
          function classedConstant() {
            var i = -1;
            while (++i < n) name[i](this, value);
          }
          function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n) name[i](this, x);
          }
          return typeof value === "function" ? classedFunction : classedConstant;
        }
        function d3_selection_classedName(name) {
          var re = d3_selection_classedRe(name);
          return function(node, value) {
            if (c = node.classList) return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            if (value) {
              re.lastIndex = 0;
              if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
            } else {
              node.setAttribute("class", d3_collapse(c.replace(re, " ")));
            }
          };
        }
        d3_selectionPrototype.style = function(name, value, priority) {
          var n = arguments.length;
          if (n < 3) {
            if (typeof name !== "string") {
              if (n < 2) value = "";
              for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
              return this;
            }
            if (n < 2) {
              var node = this.node();
              return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = "";
          }
          return this.each(d3_selection_style(name, value, priority));
        };
        function d3_selection_style(name, value, priority) {
          function styleNull() {
            this.style.removeProperty(name);
          }
          function styleConstant() {
            this.style.setProperty(name, value, priority);
          }
          function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.style.removeProperty(name);
            else this.style.setProperty(name, x, priority);
          }
          return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
        }
        d3_selectionPrototype.property = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") return this.node()[name];
            for (value in name) this.each(d3_selection_property(value, name[value]));
            return this;
          }
          return this.each(d3_selection_property(name, value));
        };
        function d3_selection_property(name, value) {
          function propertyNull() {
            delete this[name];
          }
          function propertyConstant() {
            this[name] = value;
          }
          function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null) delete this[name];
            else this[name] = x;
          }
          return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
        }
        d3_selectionPrototype.text = function(value) {
          return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
          } : value == null ? function() {
            this.textContent = "";
          } : function() {
            this.textContent = value;
          }) : this.node().textContent;
        };
        d3_selectionPrototype.html = function(value) {
          return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
          } : value == null ? function() {
            this.innerHTML = "";
          } : function() {
            this.innerHTML = value;
          }) : this.node().innerHTML;
        };
        d3_selectionPrototype.append = function(name) {
          name = d3_selection_creator(name);
          return this.select(function() {
            return this.appendChild(name.apply(this, arguments));
          });
        };
        function d3_selection_creator(name) {
          function create() {
            var document2 = this.ownerDocument, namespace = this.namespaceURI;
            return namespace === d3_nsXhtml && document2.documentElement.namespaceURI === d3_nsXhtml ? document2.createElement(name) : document2.createElementNS(namespace, name);
          }
          function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
          }
          return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
        }
        d3_selectionPrototype.insert = function(name, before) {
          name = d3_selection_creator(name);
          before = d3_selection_selector(before);
          return this.select(function() {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
          });
        };
        d3_selectionPrototype.remove = function() {
          return this.each(d3_selectionRemove);
        };
        function d3_selectionRemove() {
          var parent = this.parentNode;
          if (parent) parent.removeChild(this);
        }
        d3_selectionPrototype.data = function(value, key) {
          var i = -1, n = this.length, group, node;
          if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
              if (node = group[i]) {
                value[i] = node.__data__;
              }
            }
            return value;
          }
          function bind(group2, groupData) {
            var i2, n2 = group2.length, m = groupData.length, n0 = Math.min(n2, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n2), node2, nodeData;
            if (key) {
              var nodeByKeyValue = new d3_Map(), keyValues = new Array(n2), keyValue;
              for (i2 = -1; ++i2 < n2; ) {
                if (node2 = group2[i2]) {
                  if (nodeByKeyValue.has(keyValue = key.call(node2, node2.__data__, i2))) {
                    exitNodes[i2] = node2;
                  } else {
                    nodeByKeyValue.set(keyValue, node2);
                  }
                  keyValues[i2] = keyValue;
                }
              }
              for (i2 = -1; ++i2 < m; ) {
                if (!(node2 = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i2], i2)))) {
                  enterNodes[i2] = d3_selection_dataNode(nodeData);
                } else if (node2 !== true) {
                  updateNodes[i2] = node2;
                  node2.__data__ = nodeData;
                }
                nodeByKeyValue.set(keyValue, true);
              }
              for (i2 = -1; ++i2 < n2; ) {
                if (i2 in keyValues && nodeByKeyValue.get(keyValues[i2]) !== true) {
                  exitNodes[i2] = group2[i2];
                }
              }
            } else {
              for (i2 = -1; ++i2 < n0; ) {
                node2 = group2[i2];
                nodeData = groupData[i2];
                if (node2) {
                  node2.__data__ = nodeData;
                  updateNodes[i2] = node2;
                } else {
                  enterNodes[i2] = d3_selection_dataNode(nodeData);
                }
              }
              for (; i2 < m; ++i2) {
                enterNodes[i2] = d3_selection_dataNode(groupData[i2]);
              }
              for (; i2 < n2; ++i2) {
                exitNodes[i2] = group2[i2];
              }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group2.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
          }
          var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
          if (typeof value === "function") {
            while (++i < n) {
              bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
          } else {
            while (++i < n) {
              bind(group = this[i], value);
            }
          }
          update.enter = function() {
            return enter;
          };
          update.exit = function() {
            return exit;
          };
          return update;
        };
        function d3_selection_dataNode(data) {
          return {
            __data__: data
          };
        }
        d3_selectionPrototype.datum = function(value) {
          return arguments.length ? this.property("__data__", value) : this.property("__data__");
        };
        d3_selectionPrototype.filter = function(filter) {
          var subgroups = [], subgroup, group, node;
          if (typeof filter !== "function") filter = d3_selection_filter(filter);
          for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
              if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                subgroup.push(node);
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_filter(selector) {
          return function() {
            return d3_selectMatches(this, selector);
          };
        }
        d3_selectionPrototype.order = function() {
          for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
              if (node = group[i]) {
                if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                next = node;
              }
            }
          }
          return this;
        };
        d3_selectionPrototype.sort = function(comparator) {
          comparator = d3_selection_sortComparator.apply(this, arguments);
          for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
          return this.order();
        };
        function d3_selection_sortComparator(comparator) {
          if (!arguments.length) comparator = d3_ascending;
          return function(a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
          };
        }
        d3_selectionPrototype.each = function(callback) {
          return d3_selection_each(this, function(node, i, j) {
            callback.call(node, node.__data__, i, j);
          });
        };
        function d3_selection_each(groups, callback) {
          for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
              if (node = group[i]) callback(node, i, j);
            }
          }
          return groups;
        }
        d3_selectionPrototype.call = function(callback) {
          var args = d3_array(arguments);
          callback.apply(args[0] = this, args);
          return this;
        };
        d3_selectionPrototype.empty = function() {
          return !this.node();
        };
        d3_selectionPrototype.node = function() {
          for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
              var node = group[i];
              if (node) return node;
            }
          }
          return null;
        };
        d3_selectionPrototype.size = function() {
          var n = 0;
          d3_selection_each(this, function() {
            ++n;
          });
          return n;
        };
        function d3_selection_enter(selection) {
          d3_subclass(selection, d3_selection_enterPrototype);
          return selection;
        }
        var d3_selection_enterPrototype = [];
        d3.selection.enter = d3_selection_enter;
        d3.selection.enter.prototype = d3_selection_enterPrototype;
        d3_selection_enterPrototype.append = d3_selectionPrototype.append;
        d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
        d3_selection_enterPrototype.node = d3_selectionPrototype.node;
        d3_selection_enterPrototype.call = d3_selectionPrototype.call;
        d3_selection_enterPrototype.size = d3_selectionPrototype.size;
        d3_selection_enterPrototype.select = function(selector) {
          var subgroups = [], subgroup, subnode, upgroup, group, node;
          for (var j = -1, m = this.length; ++j < m; ) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                subnode.__data__ = node.__data__;
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_selection(subgroups);
        };
        d3_selection_enterPrototype.insert = function(name, before) {
          if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
          return d3_selectionPrototype.insert.call(this, name, before);
        };
        function d3_selection_enterInsertBefore(enter) {
          var i0, j0;
          return function(d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0) j0 = j, i0 = 0;
            if (i >= i0) i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n) ;
            return node;
          };
        }
        d3.select = function(node) {
          var group;
          if (typeof node === "string") {
            group = [d3_select(node, d3_document)];
            group.parentNode = d3_document.documentElement;
          } else {
            group = [node];
            group.parentNode = d3_documentElement(node);
          }
          return d3_selection([group]);
        };
        d3.selectAll = function(nodes) {
          var group;
          if (typeof nodes === "string") {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
          } else {
            group = d3_array(nodes);
            group.parentNode = null;
          }
          return d3_selection([group]);
        };
        d3_selectionPrototype.on = function(type, listener, capture) {
          var n = arguments.length;
          if (n < 3) {
            if (typeof type !== "string") {
              if (n < 2) listener = false;
              for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
              return this;
            }
            if (n < 2) return (n = this.node()["__on" + type]) && n._;
            capture = false;
          }
          return this.each(d3_selection_on(type, listener, capture));
        };
        function d3_selection_on(type, listener, capture) {
          var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
          if (i > 0) type = type.slice(0, i);
          var filter = d3_selection_onFilters.get(type);
          if (filter) type = filter, wrap = d3_selection_onFilter;
          function onRemove() {
            var l = this[name];
            if (l) {
              this.removeEventListener(type, l, l.$);
              delete this[name];
            }
          }
          function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
          }
          function removeAll() {
            var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
            for (var name2 in this) {
              if (match = name2.match(re)) {
                var l = this[name2];
                this.removeEventListener(match[1], l, l.$);
                delete this[name2];
              }
            }
          }
          return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
        }
        var d3_selection_onFilters = d3.map({
          mouseenter: "mouseover",
          mouseleave: "mouseout"
        });
        if (d3_document) {
          d3_selection_onFilters.forEach(function(k) {
            if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
          });
        }
        function d3_selection_onListener(listener, argumentz) {
          return function(e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
              listener.apply(this, argumentz);
            } finally {
              d3.event = o;
            }
          };
        }
        function d3_selection_onFilter(listener, argumentz) {
          var l = d3_selection_onListener(listener, argumentz);
          return function(e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
              l.call(target, e);
            }
          };
        }
        var d3_event_dragSelect, d3_event_dragId = 0;
        function d3_event_dragSuppress(node) {
          var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
          if (d3_event_dragSelect == null) {
            d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
          }
          if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none";
          }
          return function(suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
            if (suppressClick) {
              var off = function() {
                w.on(click, null);
              };
              w.on(click, function() {
                d3_eventPreventDefault();
                off();
              }, true);
              setTimeout(off, 0);
            }
          };
        }
        d3.mouse = function(container) {
          return d3_mousePoint(container, d3_eventSource());
        };
        var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
        function d3_mousePoint(container, e) {
          if (e.changedTouches) e = e.changedTouches[0];
          var svg = container.ownerSVGElement || container;
          if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
              var window2 = d3_window(container);
              if (window2.scrollX || window2.scrollY) {
                svg = d3.select("body").append("svg").style({
                  position: "absolute",
                  top: 0,
                  left: 0,
                  margin: 0,
                  padding: 0,
                  border: "none"
                }, "important");
                var ctm = svg[0][0].getScreenCTM();
                d3_mouse_bug44083 = !(ctm.f || ctm.e);
                svg.remove();
              }
            }
            if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY;
            else point.x = e.clientX, point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [point.x, point.y];
          }
          var rect = container.getBoundingClientRect();
          return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
        }
        d3.touch = function(container, touches, identifier) {
          if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
          if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
              return d3_mousePoint(container, touch);
            }
          }
        };
        d3.behavior.drag = function() {
          var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
          function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
          }
          function dragstart(id, position, subject, move, end) {
            return function() {
              var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
              if (origin) {
                dragOffset = origin.apply(that, arguments);
                dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
              } else {
                dragOffset = [0, 0];
              }
              dispatch({
                type: "dragstart"
              });
              function moved() {
                var position1 = position(parent, dragId), dx, dy;
                if (!position1) return;
                dx = position1[0] - position0[0];
                dy = position1[1] - position0[1];
                dragged |= dx | dy;
                position0 = position1;
                dispatch({
                  type: "drag",
                  x: position1[0] + dragOffset[0],
                  y: position1[1] + dragOffset[1],
                  dx,
                  dy
                });
              }
              function ended() {
                if (!position(parent, dragId)) return;
                dragSubject.on(move + dragName, null).on(end + dragName, null);
                dragRestore(dragged);
                dispatch({
                  type: "dragend"
                });
              }
            };
          }
          drag.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return drag;
          };
          return d3.rebind(drag, event, "on");
        };
        function d3_behavior_dragTouchId() {
          return d3.event.changedTouches[0].identifier;
        }
        d3.touches = function(container, touches) {
          if (arguments.length < 2) touches = d3_eventSource().touches;
          return touches ? d3_array(touches).map(function(touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
          }) : [];
        };
        var \u03B5 = 1e-6, \u03B52 = \u03B5 * \u03B5, \u03C0 = Math.PI, \u03C4 = 2 * \u03C0, \u03C4\u03B5 = \u03C4 - \u03B5, half\u03C0 = \u03C0 / 2, d3_radians = \u03C0 / 180, d3_degrees = 180 / \u03C0;
        function d3_sgn(x) {
          return x > 0 ? 1 : x < 0 ? -1 : 0;
        }
        function d3_cross2d(a, b, c) {
          return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
        }
        function d3_acos(x) {
          return x > 1 ? 0 : x < -1 ? \u03C0 : Math.acos(x);
        }
        function d3_asin(x) {
          return x > 1 ? half\u03C0 : x < -1 ? -half\u03C0 : Math.asin(x);
        }
        function d3_sinh(x) {
          return ((x = Math.exp(x)) - 1 / x) / 2;
        }
        function d3_cosh(x) {
          return ((x = Math.exp(x)) + 1 / x) / 2;
        }
        function d3_tanh(x) {
          return ((x = Math.exp(2 * x)) - 1) / (x + 1);
        }
        function d3_haversin(x) {
          return (x = Math.sin(x / 2)) * x;
        }
        var \u03C1 = Math.SQRT2, \u03C12 = 2, \u03C14 = 4;
        d3.interpolateZoom = function(p0, p1) {
          var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
          if (d2 < \u03B52) {
            S = Math.log(w1 / w0) / \u03C1;
            i = function(t) {
              return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(\u03C1 * t * S)];
            };
          } else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + \u03C14 * d2) / (2 * w0 * \u03C12 * d1), b1 = (w1 * w1 - w0 * w0 - \u03C14 * d2) / (2 * w1 * \u03C12 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / \u03C1;
            i = function(t) {
              var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (\u03C12 * d1) * (coshr0 * d3_tanh(\u03C1 * s + r0) - d3_sinh(r0));
              return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(\u03C1 * s + r0)];
            };
          }
          i.duration = S * 1e3;
          return i;
        };
        d3.behavior.zoom = function() {
          var view = {
            x: 0,
            y: 0,
            k: 1
          }, translate0, center0, center, size = [960, 500], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
          if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
              return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
            }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
              return d3.event.wheelDelta;
            }, "mousewheel") : (d3_behavior_zoomDelta = function() {
              return -d3.event.detail;
            }, "MozMousePixelScroll");
          }
          function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
          }
          zoom.event = function(g) {
            g.each(function() {
              var dispatch = event.of(this, arguments), view1 = view;
              if (d3_transitionInheritId) {
                d3.select(this).transition().each("start.zoom", function() {
                  view = this.__chart__ || {
                    x: 0,
                    y: 0,
                    k: 1
                  };
                  zoomstarted(dispatch);
                }).tween("zoom:zoom", function() {
                  var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                  return function(t) {
                    var l = i(t), k = dx / l[2];
                    this.__chart__ = view = {
                      x: cx - l[0] * k,
                      y: cy - l[1] * k,
                      k
                    };
                    zoomed(dispatch);
                  };
                }).each("interrupt.zoom", function() {
                  zoomended(dispatch);
                }).each("end.zoom", function() {
                  zoomended(dispatch);
                });
              } else {
                this.__chart__ = view;
                zoomstarted(dispatch);
                zoomed(dispatch);
                zoomended(dispatch);
              }
            });
          };
          zoom.translate = function(_) {
            if (!arguments.length) return [view.x, view.y];
            view = {
              x: +_[0],
              y: +_[1],
              k: view.k
            };
            rescale();
            return zoom;
          };
          zoom.scale = function(_) {
            if (!arguments.length) return view.k;
            view = {
              x: view.x,
              y: view.y,
              k: null
            };
            scaleTo(+_);
            rescale();
            return zoom;
          };
          zoom.scaleExtent = function(_) {
            if (!arguments.length) return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
            return zoom;
          };
          zoom.center = function(_) {
            if (!arguments.length) return center;
            center = _ && [+_[0], +_[1]];
            return zoom;
          };
          zoom.size = function(_) {
            if (!arguments.length) return size;
            size = _ && [+_[0], +_[1]];
            return zoom;
          };
          zoom.duration = function(_) {
            if (!arguments.length) return duration;
            duration = +_;
            return zoom;
          };
          zoom.x = function(z) {
            if (!arguments.length) return x1;
            x1 = z;
            x0 = z.copy();
            view = {
              x: 0,
              y: 0,
              k: 1
            };
            return zoom;
          };
          zoom.y = function(z) {
            if (!arguments.length) return y1;
            y1 = z;
            y0 = z.copy();
            view = {
              x: 0,
              y: 0,
              k: 1
            };
            return zoom;
          };
          function location(p) {
            return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
          }
          function point(l) {
            return [l[0] * view.k + view.x, l[1] * view.k + view.y];
          }
          function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
          }
          function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
          }
          function zoomTo(that, p, l, k) {
            that.__chart__ = {
              x: view.x,
              y: view.y,
              k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0) that = that.transition().duration(duration);
            that.call(zoom.event);
          }
          function rescale() {
            if (x1) x1.domain(x0.range().map(function(x) {
              return (x - view.x) / view.k;
            }).map(x0.invert));
            if (y1) y1.domain(y0.range().map(function(y) {
              return (y - view.y) / view.k;
            }).map(y0.invert));
          }
          function zoomstarted(dispatch) {
            if (!zooming++) dispatch({
              type: "zoomstart"
            });
          }
          function zoomed(dispatch) {
            rescale();
            dispatch({
              type: "zoom",
              scale: view.k,
              translate: [view.x, view.y]
            });
          }
          function zoomended(dispatch) {
            if (!--zooming) dispatch({
              type: "zoomend"
            }), center0 = null;
          }
          function mousedowned() {
            var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
              dragged = 1;
              translateTo(d3.mouse(that), location0);
              zoomed(dispatch);
            }
            function ended() {
              subject.on(mousemove, null).on(mouseup, null);
              dragRestore(dragged);
              zoomended(dispatch);
            }
          }
          function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
              var touches = d3.touches(that);
              scale0 = view.k;
              touches.forEach(function(t) {
                if (t.identifier in locations0) locations0[t.identifier] = location(t);
              });
              return touches;
            }
            function started() {
              var target = d3.event.target;
              d3.select(target).on(touchmove, moved).on(touchend, ended);
              targets.push(target);
              var changed = d3.event.changedTouches;
              for (var i = 0, n = changed.length; i < n; ++i) {
                locations0[changed[i].identifier] = null;
              }
              var touches = relocate(), now = Date.now();
              if (touches.length === 1) {
                if (now - touchtime < 500) {
                  var p = touches[0];
                  zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                  d3_eventPreventDefault();
                }
                touchtime = now;
              } else if (touches.length > 1) {
                var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                distance0 = dx * dx + dy * dy;
              }
            }
            function moved() {
              var touches = d3.touches(that), p0, l0, p1, l1;
              d3_selection_interrupt.call(that);
              for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                p1 = touches[i];
                if (l1 = locations0[p1.identifier]) {
                  if (l0) break;
                  p0 = p1, l0 = l1;
                }
              }
              if (l1) {
                var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
                l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
                scaleTo(scale1 * scale0);
              }
              touchtime = null;
              translateTo(p0, l0);
              zoomed(dispatch);
            }
            function ended() {
              if (d3.event.touches.length) {
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                  delete locations0[changed[i].identifier];
                }
                for (var identifier in locations0) {
                  return void relocate();
                }
              }
              d3.selectAll(targets).on(zoomName, null);
              subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
              dragRestore();
              zoomended(dispatch);
            }
          }
          function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer) clearTimeout(mousewheelTimer);
            else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function() {
              mousewheelTimer = null;
              zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * 2e-3) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
          }
          function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
          }
          return d3.rebind(zoom, event, "on");
        };
        var d3_behavior_zoomInfinity = [0, Infinity], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
        d3.color = d3_color;
        function d3_color() {
        }
        d3_color.prototype.toString = function() {
          return this.rgb() + "";
        };
        d3.hsl = d3_hsl;
        function d3_hsl(h, s, l) {
          return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
        }
        var d3_hslPrototype = d3_hsl.prototype = new d3_color();
        d3_hslPrototype.brighter = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_hsl(this.h, this.s, this.l / k);
        };
        d3_hslPrototype.darker = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_hsl(this.h, this.s, k * this.l);
        };
        d3_hslPrototype.rgb = function() {
          return d3_hsl_rgb(this.h, this.s, this.l);
        };
        function d3_hsl_rgb(h, s, l) {
          var m1, m2;
          h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
          s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
          l = l < 0 ? 0 : l > 1 ? 1 : l;
          m2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
          m1 = 2 * l - m2;
          function v(h2) {
            if (h2 > 360) h2 -= 360;
            else if (h2 < 0) h2 += 360;
            if (h2 < 60) return m1 + (m2 - m1) * h2 / 60;
            if (h2 < 180) return m2;
            if (h2 < 240) return m1 + (m2 - m1) * (240 - h2) / 60;
            return m1;
          }
          function vv(h2) {
            return Math.round(v(h2) * 255);
          }
          return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
        }
        d3.hcl = d3_hcl;
        function d3_hcl(h, c, l) {
          return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
        }
        var d3_hclPrototype = d3_hcl.prototype = new d3_color();
        d3_hclPrototype.brighter = function(k) {
          return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
        };
        d3_hclPrototype.darker = function(k) {
          return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
        };
        d3_hclPrototype.rgb = function() {
          return d3_hcl_lab(this.h, this.c, this.l).rgb();
        };
        function d3_hcl_lab(h, c, l) {
          if (isNaN(h)) h = 0;
          if (isNaN(c)) c = 0;
          return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
        }
        d3.lab = d3_lab;
        function d3_lab(l, a, b) {
          return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
        }
        var d3_lab_K = 18;
        var d3_lab_X = 0.95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
        var d3_labPrototype = d3_lab.prototype = new d3_color();
        d3_labPrototype.brighter = function(k) {
          return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
        };
        d3_labPrototype.darker = function(k) {
          return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
        };
        d3_labPrototype.rgb = function() {
          return d3_lab_rgb(this.l, this.a, this.b);
        };
        function d3_lab_rgb(l, a, b) {
          var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
          x = d3_lab_xyz(x) * d3_lab_X;
          y = d3_lab_xyz(y) * d3_lab_Y;
          z = d3_lab_xyz(z) * d3_lab_Z;
          return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), d3_xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), d3_xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z));
        }
        function d3_lab_hcl(l, a, b) {
          return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
        }
        function d3_lab_xyz(x) {
          return x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
        }
        function d3_xyz_lab(x) {
          return x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
        }
        function d3_xyz_rgb(r) {
          return Math.round(255 * (r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));
        }
        d3.rgb = d3_rgb;
        function d3_rgb(r, g, b) {
          return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
        }
        function d3_rgbNumber(value) {
          return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
        }
        function d3_rgbString(value) {
          return d3_rgbNumber(value) + "";
        }
        var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
        d3_rgbPrototype.brighter = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          var r = this.r, g = this.g, b = this.b, i = 30;
          if (!r && !g && !b) return new d3_rgb(i, i, i);
          if (r && r < i) r = i;
          if (g && g < i) g = i;
          if (b && b < i) b = i;
          return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
        };
        d3_rgbPrototype.darker = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_rgb(k * this.r, k * this.g, k * this.b);
        };
        d3_rgbPrototype.hsl = function() {
          return d3_rgb_hsl(this.r, this.g, this.b);
        };
        d3_rgbPrototype.toString = function() {
          return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
        };
        function d3_rgb_hex(v) {
          return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
        }
        function d3_rgb_parse(format, rgb, hsl) {
          var r = 0, g = 0, b = 0, m1, m2, color;
          m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
          if (m1) {
            m2 = m1[2].split(",");
            switch (m1[1]) {
              case "hsl": {
                return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
              }
              case "rgb": {
                return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
              }
            }
          }
          if (color = d3_rgb_names.get(format)) {
            return rgb(color.r, color.g, color.b);
          }
          if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
              r = (color & 3840) >> 4;
              r = r >> 4 | r;
              g = color & 240;
              g = g >> 4 | g;
              b = color & 15;
              b = b << 4 | b;
            } else if (format.length === 7) {
              r = (color & 16711680) >> 16;
              g = (color & 65280) >> 8;
              b = color & 255;
            }
          }
          return rgb(r, g, b);
        }
        function d3_rgb_hsl(r, g, b) {
          var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
          if (d) {
            s = l < 0.5 ? d / (max + min) : d / (2 - max - min);
            if (r == max) h = (g - b) / d + (g < b ? 6 : 0);
            else if (g == max) h = (b - r) / d + 2;
            else h = (r - g) / d + 4;
            h *= 60;
          } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
          }
          return new d3_hsl(h, s, l);
        }
        function d3_rgb_lab(r, g, b) {
          r = d3_rgb_xyz(r);
          g = d3_rgb_xyz(g);
          b = d3_rgb_xyz(b);
          var x = d3_xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / d3_lab_X), y = d3_xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / d3_lab_Y), z = d3_xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / d3_lab_Z);
          return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
        }
        function d3_rgb_xyz(r) {
          return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
        }
        function d3_rgb_parseNumber(c) {
          var f = parseFloat(c);
          return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
        }
        var d3_rgb_names = d3.map({
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074
        });
        d3_rgb_names.forEach(function(key, value) {
          d3_rgb_names.set(key, d3_rgbNumber(value));
        });
        function d3_functor(v) {
          return typeof v === "function" ? v : function() {
            return v;
          };
        }
        d3.functor = d3_functor;
        d3.xhr = d3_xhrType(d3_identity);
        function d3_xhrType(response) {
          return function(url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
          };
        }
        function d3_xhr(url, mimeType, response, callback) {
          var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
          if (self.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
          "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
          };
          function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
              try {
                result = response.call(xhr, request);
              } catch (e) {
                dispatch.error.call(xhr, e);
                return;
              }
              dispatch.load.call(xhr, result);
            } else {
              dispatch.error.call(xhr, request);
            }
          }
          request.onprogress = function(event) {
            var o = d3.event;
            d3.event = event;
            try {
              dispatch.progress.call(xhr, request);
            } finally {
              d3.event = o;
            }
          };
          xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) return headers[name];
            if (value == null) delete headers[name];
            else headers[name] = value + "";
            return xhr;
          };
          xhr.mimeType = function(value) {
            if (!arguments.length) return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
          };
          xhr.responseType = function(value) {
            if (!arguments.length) return responseType;
            responseType = value;
            return xhr;
          };
          xhr.response = function(value) {
            response = value;
            return xhr;
          };
          ["get", "post"].forEach(function(method) {
            xhr[method] = function() {
              return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
            };
          });
          xhr.send = function(method, data, callback2) {
            if (arguments.length === 2 && typeof data === "function") callback2 = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
            if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
            if (responseType != null) request.responseType = responseType;
            if (callback2 != null) xhr.on("error", callback2).on("load", function(request2) {
              callback2(null, request2);
            });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
          };
          xhr.abort = function() {
            request.abort();
            return xhr;
          };
          d3.rebind(xhr, dispatch, "on");
          return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
        }
        function d3_xhr_fixCallback(callback) {
          return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
          } : callback;
        }
        function d3_xhrHasResponse(request) {
          var type = request.responseType;
          return type && type !== "text" ? request.response : request.responseText;
        }
        d3.dsv = function(delimiter, mimeType) {
          var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
          function dsv(url, row, callback) {
            if (arguments.length < 3) callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function(_) {
              return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
          }
          function response(request) {
            return dsv.parse(request.responseText);
          }
          function typedResponse(f) {
            return function(request) {
              return dsv.parse(request.responseText, f);
            };
          }
          dsv.parse = function(text, f) {
            var o;
            return dsv.parseRows(text, function(row, i) {
              if (o) return o(row, i - 1);
              var a = function(d) {
                var obj = {};
                var len = row.length;
                for (var k = 0; k < len; ++k) {
                  obj[row[k]] = d[k];
                }
                return obj;
              };
              o = f ? function(row2, i2) {
                return f(a(row2), i2);
              } : a;
            });
          };
          dsv.parseRows = function(text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
              if (I >= N) return EOF;
              if (eol) return eol = false, EOL;
              var j = I;
              if (text.charCodeAt(j) === 34) {
                var i = j;
                while (i++ < N) {
                  if (text.charCodeAt(i) === 34) {
                    if (text.charCodeAt(i + 1) !== 34) break;
                    ++i;
                  }
                }
                I = i + 2;
                var c = text.charCodeAt(i + 1);
                if (c === 13) {
                  eol = true;
                  if (text.charCodeAt(i + 2) === 10) ++I;
                } else if (c === 10) {
                  eol = true;
                }
                return text.slice(j + 1, i).replace(/""/g, '"');
              }
              while (I < N) {
                var c = text.charCodeAt(I++), k = 1;
                if (c === 10) eol = true;
                else if (c === 13) {
                  eol = true;
                  if (text.charCodeAt(I) === 10) ++I, ++k;
                } else if (c !== delimiterCode) continue;
                return text.slice(j, I - k);
              }
              return text.slice(j);
            }
            while ((t = token()) !== EOF) {
              var a = [];
              while (t !== EOL && t !== EOF) {
                a.push(t);
                t = token();
              }
              if (f && (a = f(a, n++)) == null) continue;
              rows.push(a);
            }
            return rows;
          };
          dsv.format = function(rows) {
            if (Array.isArray(rows[0])) return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function(row) {
              for (var field in row) {
                if (!fieldSet.has(field)) {
                  fields.push(fieldSet.add(field));
                }
              }
            });
            return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
              return fields.map(function(field) {
                return formatValue(row[field]);
              }).join(delimiter);
            })).join("\n");
          };
          dsv.formatRows = function(rows) {
            return rows.map(formatRow).join("\n");
          };
          function formatRow(row) {
            return row.map(formatValue).join(delimiter);
          }
          function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
          }
          return dsv;
        };
        d3.csv = d3.dsv(",", "text/csv");
        d3.tsv = d3.dsv("	", "text/tab-separated-values");
        var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
          setTimeout(callback, 17);
        };
        d3.timer = function() {
          d3_timer.apply(this, arguments);
        };
        function d3_timer(callback, delay, then) {
          var n = arguments.length;
          if (n < 2) delay = 0;
          if (n < 3) then = Date.now();
          var time = then + delay, timer = {
            c: callback,
            t: time,
            n: null
          };
          if (d3_timer_queueTail) d3_timer_queueTail.n = timer;
          else d3_timer_queueHead = timer;
          d3_timer_queueTail = timer;
          if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
          }
          return timer;
        }
        function d3_timer_step() {
          var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
          if (delay > 24) {
            if (isFinite(delay)) {
              clearTimeout(d3_timer_timeout);
              d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
          } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
          }
        }
        d3.timer.flush = function() {
          d3_timer_mark();
          d3_timer_sweep();
        };
        function d3_timer_mark() {
          var now = Date.now(), timer = d3_timer_queueHead;
          while (timer) {
            if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
            timer = timer.n;
          }
          return now;
        }
        function d3_timer_sweep() {
          var t0, t1 = d3_timer_queueHead, time = Infinity;
          while (t1) {
            if (t1.c) {
              if (t1.t < time) time = t1.t;
              t1 = (t0 = t1).n;
            } else {
              t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            }
          }
          d3_timer_queueTail = t0;
          return time;
        }
        d3.round = function(x, n) {
          return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
        };
        d3.geom = {};
        function d3_geom_pointX(d) {
          return d[0];
        }
        function d3_geom_pointY(d) {
          return d[1];
        }
        d3.geom.hull = function(vertices) {
          var x = d3_geom_pointX, y = d3_geom_pointY;
          if (arguments.length) return hull(vertices);
          function hull(data) {
            if (data.length < 3) return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
              points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++) flippedPoints.push([points[i][0], -points[i][1]]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
            return polygon;
          }
          hull.x = function(_) {
            return arguments.length ? (x = _, hull) : x;
          };
          hull.y = function(_) {
            return arguments.length ? (y = _, hull) : y;
          };
          return hull;
        };
        function d3_geom_hullUpper(points) {
          var n = points.length, hull = [0, 1], hs = 2;
          for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
            hull[hs++] = i;
          }
          return hull.slice(0, hs);
        }
        function d3_geom_hullOrder(a, b) {
          return a[0] - b[0] || a[1] - b[1];
        }
        d3.geom.polygon = function(coordinates) {
          d3_subclass(coordinates, d3_geom_polygonPrototype);
          return coordinates;
        };
        var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
        d3_geom_polygonPrototype.area = function() {
          var i = -1, n = this.length, a, b = this[n - 1], area = 0;
          while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
          }
          return area * 0.5;
        };
        d3_geom_polygonPrototype.centroid = function(k) {
          var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
          if (!arguments.length) k = -1 / (6 * this.area());
          while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
          }
          return [x * k, y * k];
        };
        d3_geom_polygonPrototype.clip = function(subject) {
          var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
          while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
              d = input[j];
              if (d3_geom_polygonInside(d, a, b)) {
                if (!d3_geom_polygonInside(c, a, b)) {
                  subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                subject.push(d);
              } else if (d3_geom_polygonInside(c, a, b)) {
                subject.push(d3_geom_polygonIntersect(c, d, a, b));
              }
              c = d;
            }
            if (closed) subject.push(subject[0]);
            a = b;
          }
          return subject;
        };
        function d3_geom_polygonInside(p, a, b) {
          return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
        }
        function d3_geom_polygonIntersect(c, d, a, b) {
          var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
          return [x1 + ua * x21, y1 + ua * y21];
        }
        function d3_geom_polygonClosed(coordinates) {
          var a = coordinates[0], b = coordinates[coordinates.length - 1];
          return !(a[0] - b[0] || a[1] - b[1]);
        }
        var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
        function d3_geom_voronoiBeach() {
          d3_geom_voronoiRedBlackNode(this);
          this.edge = this.site = this.circle = null;
        }
        function d3_geom_voronoiCreateBeach(site) {
          var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
          beach.site = site;
          return beach;
        }
        function d3_geom_voronoiDetachBeach(beach) {
          d3_geom_voronoiDetachCircle(beach);
          d3_geom_voronoiBeaches.remove(beach);
          d3_geom_voronoiBeachPool.push(beach);
          d3_geom_voronoiRedBlackNode(beach);
        }
        function d3_geom_voronoiRemoveBeach(beach) {
          var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
            x,
            y
          }, previous = beach.P, next = beach.N, disappearing = [beach];
          d3_geom_voronoiDetachBeach(beach);
          var lArc = previous;
          while (lArc.circle && abs(x - lArc.circle.x) < \u03B5 && abs(y - lArc.circle.cy) < \u03B5) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
          }
          disappearing.unshift(lArc);
          d3_geom_voronoiDetachCircle(lArc);
          var rArc = next;
          while (rArc.circle && abs(x - rArc.circle.x) < \u03B5 && abs(y - rArc.circle.cy) < \u03B5) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
          }
          disappearing.push(rArc);
          d3_geom_voronoiDetachCircle(rArc);
          var nArcs = disappearing.length, iArc;
          for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
          }
          lArc = disappearing[0];
          rArc = disappearing[nArcs - 1];
          rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
        }
        function d3_geom_voronoiAddBeach(site) {
          var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
          while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > \u03B5) node = node.L;
            else {
              dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
              if (dxr > \u03B5) {
                if (!node.R) {
                  lArc = node;
                  break;
                }
                node = node.R;
              } else {
                if (dxl > -\u03B5) {
                  lArc = node.P;
                  rArc = node;
                } else if (dxr > -\u03B5) {
                  lArc = node;
                  rArc = node.N;
                } else {
                  lArc = rArc = node;
                }
                break;
              }
            }
          }
          var newArc = d3_geom_voronoiCreateBeach(site);
          d3_geom_voronoiBeaches.insert(lArc, newArc);
          if (!lArc && !rArc) return;
          if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
          }
          if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
          }
          d3_geom_voronoiDetachCircle(lArc);
          d3_geom_voronoiDetachCircle(rArc);
          var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
            x: (cy * hb - by * hc) / d + ax,
            y: (bx * hc - cx * hb) / d + ay
          };
          d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
          newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
          rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
        }
        function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
          var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
          if (!pby2) return rfocx;
          var lArc = arc.P;
          if (!lArc) return -Infinity;
          site = lArc.site;
          var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
          if (!plby2) return lfocx;
          var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
          if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
          return (rfocx + lfocx) / 2;
        }
        function d3_geom_voronoiRightBreakPoint(arc, directrix) {
          var rArc = arc.N;
          if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
          var site = arc.site;
          return site.y === directrix ? site.x : Infinity;
        }
        function d3_geom_voronoiCell(site) {
          this.site = site;
          this.edges = [];
        }
        d3_geom_voronoiCell.prototype.prepare = function() {
          var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
          while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
          }
          halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
          return halfEdges.length;
        };
        function d3_geom_voronoiCloseCells(extent) {
          var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
          while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare()) continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
              end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
              start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
              if (abs(x3 - x2) > \u03B5 || abs(y3 - y2) > \u03B5) {
                halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < \u03B5 && y1 - y3 > \u03B5 ? {
                  x: x0,
                  y: abs(x2 - x0) < \u03B5 ? y2 : y1
                } : abs(y3 - y1) < \u03B5 && x1 - x3 > \u03B5 ? {
                  x: abs(y2 - y1) < \u03B5 ? x2 : x1,
                  y: y1
                } : abs(x3 - x1) < \u03B5 && y3 - y0 > \u03B5 ? {
                  x: x1,
                  y: abs(x2 - x1) < \u03B5 ? y2 : y0
                } : abs(y3 - y0) < \u03B5 && x3 - x0 > \u03B5 ? {
                  x: abs(y2 - y0) < \u03B5 ? x2 : x0,
                  y: y0
                } : null), cell.site, null));
                ++nHalfEdges;
              }
            }
          }
        }
        function d3_geom_voronoiHalfEdgeOrder(a, b) {
          return b.angle - a.angle;
        }
        function d3_geom_voronoiCircle() {
          d3_geom_voronoiRedBlackNode(this);
          this.x = this.y = this.arc = this.site = this.cy = null;
        }
        function d3_geom_voronoiAttachCircle(arc) {
          var lArc = arc.P, rArc = arc.N;
          if (!lArc || !rArc) return;
          var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
          if (lSite === rSite) return;
          var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
          var d = 2 * (ax * cy - ay * cx);
          if (d >= -\u03B52) return;
          var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
          var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
          circle.arc = arc;
          circle.site = cSite;
          circle.x = x + bx;
          circle.y = cy + Math.sqrt(x * x + y * y);
          circle.cy = cy;
          arc.circle = circle;
          var before = null, node = d3_geom_voronoiCircles._;
          while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
              if (node.L) node = node.L;
              else {
                before = node.P;
                break;
              }
            } else {
              if (node.R) node = node.R;
              else {
                before = node;
                break;
              }
            }
          }
          d3_geom_voronoiCircles.insert(before, circle);
          if (!before) d3_geom_voronoiFirstCircle = circle;
        }
        function d3_geom_voronoiDetachCircle(arc) {
          var circle = arc.circle;
          if (circle) {
            if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
          }
        }
        function d3_geom_clipLine(x0, y0, x1, y1) {
          return function(line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0) return;
            r /= dx;
            if (dx < 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            } else if (dx > 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0) return;
            r /= dx;
            if (dx < 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            } else if (dx > 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0) return;
            r /= dy;
            if (dy < 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            } else if (dy > 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0) return;
            r /= dy;
            if (dy < 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            } else if (dy > 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            }
            if (t0 > 0) line.a = {
              x: ax + t0 * dx,
              y: ay + t0 * dy
            };
            if (t1 < 1) line.b = {
              x: ax + t1 * dx,
              y: ay + t1 * dy
            };
            return line;
          };
        }
        function d3_geom_voronoiClipEdges(extent) {
          var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
          while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < \u03B5 && abs(e.a.y - e.b.y) < \u03B5) {
              e.a = e.b = null;
              edges.splice(i, 1);
            }
          }
        }
        function d3_geom_voronoiConnectEdge(edge, extent) {
          var vb = edge.b;
          if (vb) return true;
          var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
          if (ry === ly) {
            if (fx < x0 || fx >= x1) return;
            if (lx > rx) {
              if (!va) va = {
                x: fx,
                y: y0
              };
              else if (va.y >= y1) return;
              vb = {
                x: fx,
                y: y1
              };
            } else {
              if (!va) va = {
                x: fx,
                y: y1
              };
              else if (va.y < y0) return;
              vb = {
                x: fx,
                y: y0
              };
            }
          } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
              if (lx > rx) {
                if (!va) va = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
                else if (va.y >= y1) return;
                vb = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
              } else {
                if (!va) va = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
                else if (va.y < y0) return;
                vb = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
              }
            } else {
              if (ly < ry) {
                if (!va) va = {
                  x: x0,
                  y: fm * x0 + fb
                };
                else if (va.x >= x1) return;
                vb = {
                  x: x1,
                  y: fm * x1 + fb
                };
              } else {
                if (!va) va = {
                  x: x1,
                  y: fm * x1 + fb
                };
                else if (va.x < x0) return;
                vb = {
                  x: x0,
                  y: fm * x0 + fb
                };
              }
            }
          }
          edge.a = va;
          edge.b = vb;
          return true;
        }
        function d3_geom_voronoiEdge(lSite, rSite) {
          this.l = lSite;
          this.r = rSite;
          this.a = this.b = null;
        }
        function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
          var edge = new d3_geom_voronoiEdge(lSite, rSite);
          d3_geom_voronoiEdges.push(edge);
          if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
          if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
          d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
          d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
          return edge;
        }
        function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
          var edge = new d3_geom_voronoiEdge(lSite, null);
          edge.a = va;
          edge.b = vb;
          d3_geom_voronoiEdges.push(edge);
          return edge;
        }
        function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
          if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
          } else if (edge.l === rSite) {
            edge.b = vertex;
          } else {
            edge.a = vertex;
          }
        }
        function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
          var va = edge.a, vb = edge.b;
          this.edge = edge;
          this.site = lSite;
          this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
        }
        d3_geom_voronoiHalfEdge.prototype = {
          start: function() {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
          },
          end: function() {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
          }
        };
        function d3_geom_voronoiRedBlackTree() {
          this._ = null;
        }
        function d3_geom_voronoiRedBlackNode(node) {
          node.U = node.C = node.L = node.R = node.P = node.N = null;
        }
        d3_geom_voronoiRedBlackTree.prototype = {
          insert: function(after, node) {
            var parent, grandpa, uncle;
            if (after) {
              node.P = after;
              node.N = after.N;
              if (after.N) after.N.P = node;
              after.N = node;
              if (after.R) {
                after = after.R;
                while (after.L) after = after.L;
                after.L = node;
              } else {
                after.R = node;
              }
              parent = after;
            } else if (this._) {
              after = d3_geom_voronoiRedBlackFirst(this._);
              node.P = null;
              node.N = after;
              after.P = after.L = node;
              parent = after;
            } else {
              node.P = node.N = null;
              this._ = node;
              parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
              grandpa = parent.U;
              if (parent === grandpa.L) {
                uncle = grandpa.R;
                if (uncle && uncle.C) {
                  parent.C = uncle.C = false;
                  grandpa.C = true;
                  after = grandpa;
                } else {
                  if (after === parent.R) {
                    d3_geom_voronoiRedBlackRotateLeft(this, parent);
                    after = parent;
                    parent = after.U;
                  }
                  parent.C = false;
                  grandpa.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                }
              } else {
                uncle = grandpa.L;
                if (uncle && uncle.C) {
                  parent.C = uncle.C = false;
                  grandpa.C = true;
                  after = grandpa;
                } else {
                  if (after === parent.L) {
                    d3_geom_voronoiRedBlackRotateRight(this, parent);
                    after = parent;
                    parent = after.U;
                  }
                  parent.C = false;
                  grandpa.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                }
              }
              parent = after.U;
            }
            this._.C = false;
          },
          remove: function(node) {
            if (node.N) node.N.P = node.P;
            if (node.P) node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left) next = right;
            else if (!right) next = left;
            else next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
              if (parent.L === node) parent.L = next;
              else parent.R = next;
            } else {
              this._ = next;
            }
            if (left && right) {
              red = next.C;
              next.C = node.C;
              next.L = left;
              left.U = next;
              if (next !== right) {
                parent = next.U;
                next.U = node.U;
                node = next.R;
                parent.L = node;
                next.R = right;
                right.U = next;
              } else {
                next.U = parent;
                parent = next;
                node = next.R;
              }
            } else {
              red = node.C;
              node = next;
            }
            if (node) node.U = parent;
            if (red) return;
            if (node && node.C) {
              node.C = false;
              return;
            }
            do {
              if (node === this._) break;
              if (node === parent.L) {
                sibling = parent.R;
                if (sibling.C) {
                  sibling.C = false;
                  parent.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  sibling = parent.R;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                  if (!sibling.R || !sibling.R.C) {
                    sibling.L.C = false;
                    sibling.C = true;
                    d3_geom_voronoiRedBlackRotateRight(this, sibling);
                    sibling = parent.R;
                  }
                  sibling.C = parent.C;
                  parent.C = sibling.R.C = false;
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  node = this._;
                  break;
                }
              } else {
                sibling = parent.L;
                if (sibling.C) {
                  sibling.C = false;
                  parent.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  sibling = parent.L;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                  if (!sibling.L || !sibling.L.C) {
                    sibling.R.C = false;
                    sibling.C = true;
                    d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                    sibling = parent.L;
                  }
                  sibling.C = parent.C;
                  parent.C = sibling.L.C = false;
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  node = this._;
                  break;
                }
              }
              sibling.C = true;
              node = parent;
              parent = parent.U;
            } while (!node.C);
            if (node) node.C = false;
          }
        };
        function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
          var p = node, q = node.R, parent = p.U;
          if (parent) {
            if (parent.L === p) parent.L = q;
            else parent.R = q;
          } else {
            tree._ = q;
          }
          q.U = parent;
          p.U = q;
          p.R = q.L;
          if (p.R) p.R.U = p;
          q.L = p;
        }
        function d3_geom_voronoiRedBlackRotateRight(tree, node) {
          var p = node, q = node.L, parent = p.U;
          if (parent) {
            if (parent.L === p) parent.L = q;
            else parent.R = q;
          } else {
            tree._ = q;
          }
          q.U = parent;
          p.U = q;
          p.L = q.R;
          if (p.L) p.L.U = p;
          q.R = p;
        }
        function d3_geom_voronoiRedBlackFirst(node) {
          while (node.L) node = node.L;
          return node;
        }
        function d3_geom_voronoi(sites, bbox) {
          var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
          d3_geom_voronoiEdges = [];
          d3_geom_voronoiCells = new Array(sites.length);
          d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
          d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
          while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
              if (site.x !== x0 || site.y !== y0) {
                d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                d3_geom_voronoiAddBeach(site);
                x0 = site.x, y0 = site.y;
              }
              site = sites.pop();
            } else if (circle) {
              d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
              break;
            }
          }
          if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
          var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
          };
          d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
          return diagram;
        }
        function d3_geom_voronoiVertexOrder(a, b) {
          return b.y - a.y || b.x - a.x;
        }
        d3.geom.voronoi = function(points) {
          var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
          if (points) return voronoi(points);
          function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
              var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
                var s = e.start();
                return [s.x, s.y];
              }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
              polygon.point = data[i];
            });
            return polygons;
          }
          function sites(data) {
            return data.map(function(d, i) {
              return {
                x: Math.round(fx(d, i) / \u03B5) * \u03B5,
                y: Math.round(fy(d, i) / \u03B5) * \u03B5,
                i
              };
            });
          }
          voronoi.links = function(data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
              return edge.l && edge.r;
            }).map(function(edge) {
              return {
                source: data[edge.l.i],
                target: data[edge.r.i]
              };
            });
          };
          voronoi.triangles = function(data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
              var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
              while (++j < m) {
                e0 = e1;
                s0 = s1;
                e1 = edges[j].edge;
                s1 = e1.l === site ? e1.r : e1.l;
                if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                  triangles.push([data[i], data[s0.i], data[s1.i]]);
                }
              }
            });
            return triangles;
          };
          voronoi.x = function(_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
          };
          voronoi.y = function(_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
          };
          voronoi.clipExtent = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
          };
          voronoi.size = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [[0, 0], _]);
          };
          return voronoi;
        };
        var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
        function d3_geom_voronoiTriangleArea(a, b, c) {
          return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
        }
        d3.geom.delaunay = function(vertices) {
          return d3.geom.voronoi().triangles(vertices);
        };
        d3.geom.quadtree = function(points, x1, y1, x2, y2) {
          var x = d3_geom_pointX, y = d3_geom_pointY, compat;
          if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
              y2 = y1;
              x2 = x1;
              y1 = x1 = 0;
            }
            return quadtree(points);
          }
          function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
              x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
              x2_ = y2_ = -(x1_ = y1_ = Infinity);
              xs = [], ys = [];
              n = data.length;
              if (compat) for (i = 0; i < n; ++i) {
                d = data[i];
                if (d.x < x1_) x1_ = d.x;
                if (d.y < y1_) y1_ = d.y;
                if (d.x > x2_) x2_ = d.x;
                if (d.y > y2_) y2_ = d.y;
                xs.push(d.x);
                ys.push(d.y);
              }
              else for (i = 0; i < n; ++i) {
                var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                if (x_ < x1_) x1_ = x_;
                if (y_ < y1_) y1_ = y_;
                if (x_ > x2_) x2_ = x_;
                if (y_ > y2_) y2_ = y_;
                xs.push(x_);
                ys.push(y_);
              }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) y2_ = y1_ + dx;
            else x2_ = x1_ + dy;
            function insert(n2, d2, x3, y3, x12, y12, x22, y22) {
              if (isNaN(x3) || isNaN(y3)) return;
              if (n2.leaf) {
                var nx = n2.x, ny = n2.y;
                if (nx != null) {
                  if (abs(nx - x3) + abs(ny - y3) < 0.01) {
                    insertChild(n2, d2, x3, y3, x12, y12, x22, y22);
                  } else {
                    var nPoint = n2.point;
                    n2.x = n2.y = n2.point = null;
                    insertChild(n2, nPoint, nx, ny, x12, y12, x22, y22);
                    insertChild(n2, d2, x3, y3, x12, y12, x22, y22);
                  }
                } else {
                  n2.x = x3, n2.y = y3, n2.point = d2;
                }
              } else {
                insertChild(n2, d2, x3, y3, x12, y12, x22, y22);
              }
            }
            function insertChild(n2, d2, x3, y3, x12, y12, x22, y22) {
              var xm = (x12 + x22) * 0.5, ym = (y12 + y22) * 0.5, right = x3 >= xm, below = y3 >= ym, i2 = below << 1 | right;
              n2.leaf = false;
              n2 = n2.nodes[i2] || (n2.nodes[i2] = d3_geom_quadtreeNode());
              if (right) x12 = xm;
              else x22 = xm;
              if (below) y12 = ym;
              else y22 = ym;
              insert(n2, d2, x3, y3, x12, y12, x22, y22);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d2) {
              insert(root, d2, +fx(d2, ++i), +fy(d2, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f) {
              d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function(point) {
              return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
              while (++i < n) {
                insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
              }
              --i;
            } else data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
          }
          quadtree.x = function(_) {
            return arguments.length ? (x = _, quadtree) : x;
          };
          quadtree.y = function(_) {
            return arguments.length ? (y = _, quadtree) : y;
          };
          quadtree.extent = function(_) {
            if (!arguments.length) return x1 == null ? null : [[x1, y1], [x2, y2]];
            if (_ == null) x1 = y1 = x2 = y2 = null;
            else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
            return quadtree;
          };
          quadtree.size = function(_) {
            if (!arguments.length) return x1 == null ? null : [x2 - x1, y2 - y1];
            if (_ == null) x1 = y1 = x2 = y2 = null;
            else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            return quadtree;
          };
          return quadtree;
        };
        function d3_geom_quadtreeCompatX(d) {
          return d.x;
        }
        function d3_geom_quadtreeCompatY(d) {
          return d.y;
        }
        function d3_geom_quadtreeNode() {
          return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
          };
        }
        function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
          if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * 0.5, sy = (y1 + y2) * 0.5, children = node.nodes;
            if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
          }
        }
        function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
          var minDistance2 = Infinity, closestPoint;
          (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
            if (point = node.point) {
              var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
              if (distance2 < minDistance2) {
                var distance = Math.sqrt(minDistance2 = distance2);
                x0 = x - distance, y0 = y - distance;
                x3 = x + distance, y3 = y + distance;
                closestPoint = point;
              }
            }
            var children = node.nodes, xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
              if (node = children[i & 3]) switch (i & 3) {
                case 0:
                  find(node, x1, y1, xm, ym);
                  break;
                case 1:
                  find(node, xm, y1, x2, ym);
                  break;
                case 2:
                  find(node, x1, ym, xm, y2);
                  break;
                case 3:
                  find(node, xm, ym, x2, y2);
                  break;
              }
            }
          })(root, x0, y0, x3, y3);
          return closestPoint;
        }
        d3.interpolateRgb = d3_interpolateRgb;
        function d3_interpolateRgb(a, b) {
          a = d3.rgb(a);
          b = d3.rgb(b);
          var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
          return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
          };
        }
        d3.interpolateObject = d3_interpolateObject;
        function d3_interpolateObject(a, b) {
          var i = {}, c = {}, k;
          for (k in a) {
            if (k in b) {
              i[k] = d3_interpolate(a[k], b[k]);
            } else {
              c[k] = a[k];
            }
          }
          for (k in b) {
            if (!(k in a)) {
              c[k] = b[k];
            }
          }
          return function(t) {
            for (k in i) c[k] = i[k](t);
            return c;
          };
        }
        d3.interpolateNumber = d3_interpolateNumber;
        function d3_interpolateNumber(a, b) {
          a = +a, b = +b;
          return function(t) {
            return a * (1 - t) + b * t;
          };
        }
        d3.interpolateString = d3_interpolateString;
        function d3_interpolateString(a, b) {
          var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
          a = a + "", b = b + "";
          while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
              bs = b.slice(bi, bs);
              if (s[i]) s[i] += bs;
              else s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
              if (s[i]) s[i] += bm;
              else s[++i] = bm;
            } else {
              s[++i] = null;
              q.push({
                i,
                x: d3_interpolateNumber(am, bm)
              });
            }
            bi = d3_interpolate_numberB.lastIndex;
          }
          if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i]) s[i] += bs;
            else s[++i] = bs;
          }
          return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
            return b(t) + "";
          }) : function() {
            return b;
          } : (b = q.length, function(t) {
            for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
            return s.join("");
          });
        }
        var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
        d3.interpolate = d3_interpolate;
        function d3_interpolate(a, b) {
          var i = d3.interpolators.length, f;
          while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
          return f;
        }
        d3.interpolators = [function(a, b) {
          var t = typeof b;
          return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
        }];
        d3.interpolateArray = d3_interpolateArray;
        function d3_interpolateArray(a, b) {
          var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
          for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
          for (; i < na; ++i) c[i] = a[i];
          for (; i < nb; ++i) c[i] = b[i];
          return function(t) {
            for (i = 0; i < n0; ++i) c[i] = x[i](t);
            return c;
          };
        }
        var d3_ease_default = function() {
          return d3_identity;
        };
        var d3_ease = d3.map({
          linear: d3_ease_default,
          poly: d3_ease_poly,
          quad: function() {
            return d3_ease_quad;
          },
          cubic: function() {
            return d3_ease_cubic;
          },
          sin: function() {
            return d3_ease_sin;
          },
          exp: function() {
            return d3_ease_exp;
          },
          circle: function() {
            return d3_ease_circle;
          },
          elastic: d3_ease_elastic,
          back: d3_ease_back,
          bounce: function() {
            return d3_ease_bounce;
          }
        });
        var d3_ease_mode = d3.map({
          "in": d3_identity,
          out: d3_ease_reverse,
          "in-out": d3_ease_reflect,
          "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
          }
        });
        d3.ease = function(name) {
          var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
          t = d3_ease.get(t) || d3_ease_default;
          m = d3_ease_mode.get(m) || d3_identity;
          return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
        };
        function d3_ease_clamp(f) {
          return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
          };
        }
        function d3_ease_reverse(f) {
          return function(t) {
            return 1 - f(1 - t);
          };
        }
        function d3_ease_reflect(f) {
          return function(t) {
            return 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
          };
        }
        function d3_ease_quad(t) {
          return t * t;
        }
        function d3_ease_cubic(t) {
          return t * t * t;
        }
        function d3_ease_cubicInOut(t) {
          if (t <= 0) return 0;
          if (t >= 1) return 1;
          var t2 = t * t, t3 = t2 * t;
          return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
        }
        function d3_ease_poly(e) {
          return function(t) {
            return Math.pow(t, e);
          };
        }
        function d3_ease_sin(t) {
          return 1 - Math.cos(t * half\u03C0);
        }
        function d3_ease_exp(t) {
          return Math.pow(2, 10 * (t - 1));
        }
        function d3_ease_circle(t) {
          return 1 - Math.sqrt(1 - t * t);
        }
        function d3_ease_elastic(a, p) {
          var s;
          if (arguments.length < 2) p = 0.45;
          if (arguments.length) s = p / \u03C4 * Math.asin(1 / a);
          else a = 1, s = p / 4;
          return function(t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * \u03C4 / p);
          };
        }
        function d3_ease_back(s) {
          if (!s) s = 1.70158;
          return function(t) {
            return t * t * ((s + 1) * t - s);
          };
        }
        function d3_ease_bounce(t) {
          return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        }
        d3.interpolateHcl = d3_interpolateHcl;
        function d3_interpolateHcl(a, b) {
          a = d3.hcl(a);
          b = d3.hcl(b);
          var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
          if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
          if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;
          else if (bh > 180) bh -= 360;
          else if (bh < -180) bh += 360;
          return function(t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
          };
        }
        d3.interpolateHsl = d3_interpolateHsl;
        function d3_interpolateHsl(a, b) {
          a = d3.hsl(a);
          b = d3.hsl(b);
          var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
          if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
          if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;
          else if (bh > 180) bh -= 360;
          else if (bh < -180) bh += 360;
          return function(t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
          };
        }
        d3.interpolateLab = d3_interpolateLab;
        function d3_interpolateLab(a, b) {
          a = d3.lab(a);
          b = d3.lab(b);
          var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
          return function(t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
          };
        }
        d3.interpolateRound = d3_interpolateRound;
        function d3_interpolateRound(a, b) {
          b -= a;
          return function(t) {
            return Math.round(a + b * t);
          };
        }
        d3.transform = function(string) {
          var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
          return (d3.transform = function(string2) {
            if (string2 != null) {
              g.setAttribute("transform", string2);
              var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
          })(string);
        };
        function d3_transform(m) {
          var r0 = [m.a, m.b], r1 = [m.c, m.d], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
          if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
          }
          this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
          this.translate = [m.e, m.f];
          this.scale = [kx, ky];
          this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
        }
        d3_transform.prototype.toString = function() {
          return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
        };
        function d3_transformDot(a, b) {
          return a[0] * b[0] + a[1] * b[1];
        }
        function d3_transformNormalize(a) {
          var k = Math.sqrt(d3_transformDot(a, a));
          if (k) {
            a[0] /= k;
            a[1] /= k;
          }
          return k;
        }
        function d3_transformCombine(a, b, k) {
          a[0] += k * b[0];
          a[1] += k * b[1];
          return a;
        }
        var d3_transformIdentity = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: 0,
          f: 0
        };
        d3.interpolateTransform = d3_interpolateTransform;
        function d3_interpolateTransformPop(s) {
          return s.length ? s.pop() + "," : "";
        }
        function d3_interpolateTranslate(ta, tb, s, q) {
          if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
            var i = s.push("translate(", null, ",", null, ")");
            q.push({
              i: i - 4,
              x: d3_interpolateNumber(ta[0], tb[0])
            }, {
              i: i - 2,
              x: d3_interpolateNumber(ta[1], tb[1])
            });
          } else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
          }
        }
        function d3_interpolateRotate(ra, rb, s, q) {
          if (ra !== rb) {
            if (ra - rb > 180) rb += 360;
            else if (rb - ra > 180) ra += 360;
            q.push({
              i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
              x: d3_interpolateNumber(ra, rb)
            });
          } else if (rb) {
            s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
          }
        }
        function d3_interpolateSkew(wa, wb, s, q) {
          if (wa !== wb) {
            q.push({
              i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
              x: d3_interpolateNumber(wa, wb)
            });
          } else if (wb) {
            s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
          }
        }
        function d3_interpolateScale(ka, kb, s, q) {
          if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
            var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
            q.push({
              i: i - 4,
              x: d3_interpolateNumber(ka[0], kb[0])
            }, {
              i: i - 2,
              x: d3_interpolateNumber(ka[1], kb[1])
            });
          } else if (kb[0] !== 1 || kb[1] !== 1) {
            s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
          }
        }
        function d3_interpolateTransform(a, b) {
          var s = [], q = [];
          a = d3.transform(a), b = d3.transform(b);
          d3_interpolateTranslate(a.translate, b.translate, s, q);
          d3_interpolateRotate(a.rotate, b.rotate, s, q);
          d3_interpolateSkew(a.skew, b.skew, s, q);
          d3_interpolateScale(a.scale, b.scale, s, q);
          a = b = null;
          return function(t) {
            var i = -1, n = q.length, o;
            while (++i < n) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          };
        }
        function d3_uninterpolateNumber(a, b) {
          b = (b -= a = +a) || 1 / b;
          return function(x) {
            return (x - a) / b;
          };
        }
        function d3_uninterpolateClamp(a, b) {
          b = (b -= a = +a) || 1 / b;
          return function(x) {
            return Math.max(0, Math.min(1, (x - a) / b));
          };
        }
        d3.layout = {};
        d3.layout.bundle = function() {
          return function(links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
            return paths;
          };
        };
        function d3_layout_bundlePath(link) {
          var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [start];
          while (start !== lca) {
            start = start.parent;
            points.push(start);
          }
          var k = points.length;
          while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
          }
          return points;
        }
        function d3_layout_bundleAncestors(node) {
          var ancestors = [], parent = node.parent;
          while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
          }
          ancestors.push(node);
          return ancestors;
        }
        function d3_layout_bundleLeastCommonAncestor(a, b) {
          if (a === b) return a;
          var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
          while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
          }
          return sharedNode;
        }
        d3.layout.chord = function() {
          var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
          function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
              x = 0, j = -1;
              while (++j < n) {
                x += matrix[i][j];
              }
              groupSums.push(x);
              subgroupIndex.push(d3.range(n));
              k += x;
            }
            if (sortGroups) {
              groupIndex.sort(function(a, b) {
                return sortGroups(groupSums[a], groupSums[b]);
              });
            }
            if (sortSubgroups) {
              subgroupIndex.forEach(function(d, i2) {
                d.sort(function(a, b) {
                  return sortSubgroups(matrix[i2][a], matrix[i2][b]);
                });
              });
            }
            k = (\u03C4 - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
              x0 = x, j = -1;
              while (++j < n) {
                var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                subgroups[di + "-" + dj] = {
                  index: di,
                  subindex: dj,
                  startAngle: a0,
                  endAngle: a1,
                  value: v
                };
              }
              groups[di] = {
                index: di,
                startAngle: x0,
                endAngle: x,
                value: groupSums[di]
              };
              x += padding;
            }
            i = -1;
            while (++i < n) {
              j = i - 1;
              while (++j < n) {
                var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                if (source.value || target.value) {
                  chords.push(source.value < target.value ? {
                    source: target,
                    target: source
                  } : {
                    source,
                    target
                  });
                }
              }
            }
            if (sortChords) resort();
          }
          function resort() {
            chords.sort(function(a, b) {
              return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
          }
          chord.matrix = function(x) {
            if (!arguments.length) return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
          };
          chord.padding = function(x) {
            if (!arguments.length) return padding;
            padding = x;
            chords = groups = null;
            return chord;
          };
          chord.sortGroups = function(x) {
            if (!arguments.length) return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
          };
          chord.sortSubgroups = function(x) {
            if (!arguments.length) return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
          };
          chord.sortChords = function(x) {
            if (!arguments.length) return sortChords;
            sortChords = x;
            if (chords) resort();
            return chord;
          };
          chord.chords = function() {
            if (!chords) relayout();
            return chords;
          };
          chord.groups = function() {
            if (!groups) relayout();
            return groups;
          };
          return chord;
        };
        d3.layout.force = function() {
          var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [1, 1], drag, alpha, friction = 0.9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = 0.1, theta2 = 0.64, nodes = [], links = [], distances, strengths, charges;
          function repulse(node) {
            return function(quad, x1, _, x2) {
              if (quad.point !== node) {
                var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                if (dw * dw / theta2 < dn) {
                  if (dn < chargeDistance2) {
                    var k = quad.charge / dn;
                    node.px -= dx * k;
                    node.py -= dy * k;
                  }
                  return true;
                }
                if (quad.point && dn && dn < chargeDistance2) {
                  var k = quad.pointCharge / dn;
                  node.px -= dx * k;
                  node.py -= dy * k;
                }
              }
              return !quad.charge;
            };
          }
          force.tick = function() {
            if ((alpha *= 0.99) < 5e-3) {
              timer = null;
              event.end({
                type: "end",
                alpha: alpha = 0
              });
              return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
              o = links[i];
              s = o.source;
              t = o.target;
              x = t.x - s.x;
              y = t.y - s.y;
              if (l = x * x + y * y) {
                l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                x *= l;
                y *= l;
                t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : 0.5);
                t.y -= y * k;
                s.x += x * (k = 1 - k);
                s.y += y * k;
              }
            }
            if (k = alpha * gravity) {
              x = size[0] / 2;
              y = size[1] / 2;
              i = -1;
              if (k) while (++i < n) {
                o = nodes[i];
                o.x += (x - o.x) * k;
                o.y += (y - o.y) * k;
              }
            }
            if (charge) {
              d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
              i = -1;
              while (++i < n) {
                if (!(o = nodes[i]).fixed) {
                  q.visit(repulse(o));
                }
              }
            }
            i = -1;
            while (++i < n) {
              o = nodes[i];
              if (o.fixed) {
                o.x = o.px;
                o.y = o.py;
              } else {
                o.x -= (o.px - (o.px = o.x)) * friction;
                o.y -= (o.py - (o.py = o.y)) * friction;
              }
            }
            event.tick({
              type: "tick",
              alpha
            });
          };
          force.nodes = function(x) {
            if (!arguments.length) return nodes;
            nodes = x;
            return force;
          };
          force.links = function(x) {
            if (!arguments.length) return links;
            links = x;
            return force;
          };
          force.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return force;
          };
          force.linkDistance = function(x) {
            if (!arguments.length) return linkDistance;
            linkDistance = typeof x === "function" ? x : +x;
            return force;
          };
          force.distance = force.linkDistance;
          force.linkStrength = function(x) {
            if (!arguments.length) return linkStrength;
            linkStrength = typeof x === "function" ? x : +x;
            return force;
          };
          force.friction = function(x) {
            if (!arguments.length) return friction;
            friction = +x;
            return force;
          };
          force.charge = function(x) {
            if (!arguments.length) return charge;
            charge = typeof x === "function" ? x : +x;
            return force;
          };
          force.chargeDistance = function(x) {
            if (!arguments.length) return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
          };
          force.gravity = function(x) {
            if (!arguments.length) return gravity;
            gravity = +x;
            return force;
          };
          force.theta = function(x) {
            if (!arguments.length) return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
          };
          force.alpha = function(x) {
            if (!arguments.length) return alpha;
            x = +x;
            if (alpha) {
              if (x > 0) {
                alpha = x;
              } else {
                timer.c = null, timer.t = NaN, timer = null;
                event.end({
                  type: "end",
                  alpha: alpha = 0
                });
              }
            } else if (x > 0) {
              event.start({
                type: "start",
                alpha: alpha = x
              });
              timer = d3_timer(force.tick);
            }
            return force;
          };
          force.start = function() {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
              (o = nodes[i]).index = i;
              o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
              o = links[i];
              if (typeof o.source == "number") o.source = nodes[o.source];
              if (typeof o.target == "number") o.target = nodes[o.target];
              ++o.source.weight;
              ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
              o = nodes[i];
              if (isNaN(o.x)) o.x = position("x", w);
              if (isNaN(o.y)) o.y = position("y", h);
              if (isNaN(o.px)) o.px = o.x;
              if (isNaN(o.py)) o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i);
            else for (i = 0; i < m; ++i) distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i);
            else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i);
            else for (i = 0; i < n; ++i) charges[i] = charge;
            function position(dimension, size2) {
              if (!neighbors) {
                neighbors = new Array(n);
                for (j = 0; j < n; ++j) {
                  neighbors[j] = [];
                }
                for (j = 0; j < m; ++j) {
                  var o2 = links[j];
                  neighbors[o2.source.index].push(o2.target);
                  neighbors[o2.target.index].push(o2.source);
                }
              }
              var candidates = neighbors[i], j = -1, l = candidates.length, x;
              while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
              return Math.random() * size2;
            }
            return force.resume();
          };
          force.resume = function() {
            return force.alpha(0.1);
          };
          force.stop = function() {
            return force.alpha(0);
          };
          force.drag = function() {
            if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length) return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
          };
          function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
          }
          return d3.rebind(force, event, "on");
        };
        function d3_layout_forceDragstart(d) {
          d.fixed |= 2;
        }
        function d3_layout_forceDragend(d) {
          d.fixed &= ~6;
        }
        function d3_layout_forceMouseover(d) {
          d.fixed |= 4;
          d.px = d.x, d.py = d.y;
        }
        function d3_layout_forceMouseout(d) {
          d.fixed &= ~4;
        }
        function d3_layout_forceAccumulate(quad, alpha, charges) {
          var cx = 0, cy = 0;
          quad.charge = 0;
          if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
              c = nodes[i];
              if (c == null) continue;
              d3_layout_forceAccumulate(c, alpha, charges);
              quad.charge += c.charge;
              cx += c.charge * c.cx;
              cy += c.charge * c.cy;
            }
          }
          if (quad.point) {
            if (!quad.leaf) {
              quad.point.x += Math.random() - 0.5;
              quad.point.y += Math.random() - 0.5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
          }
          quad.cx = cx / quad.charge;
          quad.cy = cy / quad.charge;
        }
        var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
        d3.layout.hierarchy = function() {
          var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
          function hierarchy(root) {
            var stack = [root], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
              nodes.push(node);
              if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                var n, childs, child;
                while (--n >= 0) {
                  stack.push(child = childs[n]);
                  child.parent = node;
                  child.depth = node.depth + 1;
                }
                if (value) node.value = 0;
                node.children = childs;
              } else {
                if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
                delete node.children;
              }
            }
            d3_layout_hierarchyVisitAfter(root, function(node2) {
              var childs2, parent;
              if (sort && (childs2 = node2.children)) childs2.sort(sort);
              if (value && (parent = node2.parent)) parent.value += node2.value;
            });
            return nodes;
          }
          hierarchy.sort = function(x) {
            if (!arguments.length) return sort;
            sort = x;
            return hierarchy;
          };
          hierarchy.children = function(x) {
            if (!arguments.length) return children;
            children = x;
            return hierarchy;
          };
          hierarchy.value = function(x) {
            if (!arguments.length) return value;
            value = x;
            return hierarchy;
          };
          hierarchy.revalue = function(root) {
            if (value) {
              d3_layout_hierarchyVisitBefore(root, function(node) {
                if (node.children) node.value = 0;
              });
              d3_layout_hierarchyVisitAfter(root, function(node) {
                var parent;
                if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
                if (parent = node.parent) parent.value += node.value;
              });
            }
            return root;
          };
          return hierarchy;
        };
        function d3_layout_hierarchyRebind(object, hierarchy) {
          d3.rebind(object, hierarchy, "sort", "children", "value");
          object.nodes = object;
          object.links = d3_layout_hierarchyLinks;
          return object;
        }
        function d3_layout_hierarchyVisitBefore(node, callback) {
          var nodes = [node];
          while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
              var n, children;
              while (--n >= 0) nodes.push(children[n]);
            }
          }
        }
        function d3_layout_hierarchyVisitAfter(node, callback) {
          var nodes = [node], nodes2 = [];
          while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
              var i = -1, n, children;
              while (++i < n) nodes.push(children[i]);
            }
          }
          while ((node = nodes2.pop()) != null) {
            callback(node);
          }
        }
        function d3_layout_hierarchyChildren(d) {
          return d.children;
        }
        function d3_layout_hierarchyValue(d) {
          return d.value;
        }
        function d3_layout_hierarchySort(a, b) {
          return b.value - a.value;
        }
        function d3_layout_hierarchyLinks(nodes) {
          return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
              return {
                source: parent,
                target: child
              };
            });
          }));
        }
        d3.layout.partition = function() {
          var hierarchy = d3.layout.hierarchy(), size = [1, 1];
          function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
              var i = -1, n, c, d;
              dx = node.value ? dx / node.value : 0;
              while (++i < n) {
                position(c = children[i], x, d = c.value * dx, dy);
                x += d;
              }
            }
          }
          function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
              var i = -1, n;
              while (++i < n) d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
          }
          function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
          }
          partition.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return partition;
          };
          return d3_layout_hierarchyRebind(partition, hierarchy);
        };
        d3.layout.pie = function() {
          var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = \u03C4, padAngle = 0;
          function pie(data) {
            var n = data.length, values = data.map(function(d, i) {
              return +value.call(pie, d, i);
            }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
            if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
              return values[j] - values[i];
            } : function(i, j) {
              return sort(data[i], data[j]);
            });
            index.forEach(function(i) {
              arcs[i] = {
                data: data[i],
                value: v = values[i],
                startAngle: a,
                endAngle: a += v * k + pa,
                padAngle: p
              };
            });
            return arcs;
          }
          pie.value = function(_) {
            if (!arguments.length) return value;
            value = _;
            return pie;
          };
          pie.sort = function(_) {
            if (!arguments.length) return sort;
            sort = _;
            return pie;
          };
          pie.startAngle = function(_) {
            if (!arguments.length) return startAngle;
            startAngle = _;
            return pie;
          };
          pie.endAngle = function(_) {
            if (!arguments.length) return endAngle;
            endAngle = _;
            return pie;
          };
          pie.padAngle = function(_) {
            if (!arguments.length) return padAngle;
            padAngle = _;
            return pie;
          };
          return pie;
        };
        var d3_layout_pieSortByValue = {};
        d3.layout.stack = function() {
          var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
          function stack(data, index) {
            if (!(n = data.length)) return data;
            var series = data.map(function(d, i2) {
              return values.call(stack, d, i2);
            });
            var points = series.map(function(d) {
              return d.map(function(v, i2) {
                return [x.call(stack, v, i2), y.call(stack, v, i2)];
              });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i, j, o;
            for (j = 0; j < m; ++j) {
              out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
              for (i = 1; i < n; ++i) {
                out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
              }
            }
            return data;
          }
          stack.values = function(x2) {
            if (!arguments.length) return values;
            values = x2;
            return stack;
          };
          stack.order = function(x2) {
            if (!arguments.length) return order;
            order = typeof x2 === "function" ? x2 : d3_layout_stackOrders.get(x2) || d3_layout_stackOrderDefault;
            return stack;
          };
          stack.offset = function(x2) {
            if (!arguments.length) return offset;
            offset = typeof x2 === "function" ? x2 : d3_layout_stackOffsets.get(x2) || d3_layout_stackOffsetZero;
            return stack;
          };
          stack.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            return stack;
          };
          stack.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            return stack;
          };
          stack.out = function(z) {
            if (!arguments.length) return out;
            out = z;
            return stack;
          };
          return stack;
        };
        function d3_layout_stackX(d) {
          return d.x;
        }
        function d3_layout_stackY(d) {
          return d.y;
        }
        function d3_layout_stackOut(d, y0, y) {
          d.y0 = y0;
          d.y = y;
        }
        var d3_layout_stackOrders = d3.map({
          "inside-out": function(data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
              return max[a] - max[b];
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
              j = index[i];
              if (top < bottom) {
                top += sums[j];
                tops.push(j);
              } else {
                bottom += sums[j];
                bottoms.push(j);
              }
            }
            return bottoms.reverse().concat(tops);
          },
          reverse: function(data) {
            return d3.range(data.length).reverse();
          },
          "default": d3_layout_stackOrderDefault
        });
        var d3_layout_stackOffsets = d3.map({
          silhouette: function(data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
              for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
              if (o > max) max = o;
              sums.push(o);
            }
            for (j = 0; j < m; ++j) {
              y0[j] = (max - sums[j]) / 2;
            }
            return y0;
          },
          wiggle: function(data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
              for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
              for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                  s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                }
                s2 += s3 * data[i][j][1];
              }
              y0[j] = o -= s1 ? s2 / s1 * dx : 0;
              if (o < o0) o0 = o;
            }
            for (j = 0; j < m; ++j) y0[j] -= o0;
            return y0;
          },
          expand: function(data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
              for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
              if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;
              else for (i = 0; i < n; i++) data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j) y0[j] = 0;
            return y0;
          },
          zero: d3_layout_stackOffsetZero
        });
        function d3_layout_stackOrderDefault(data) {
          return d3.range(data.length);
        }
        function d3_layout_stackOffsetZero(data) {
          var j = -1, m = data[0].length, y0 = [];
          while (++j < m) y0[j] = 0;
          return y0;
        }
        function d3_layout_stackMaxIndex(array) {
          var i = 1, j = 0, v = array[0][1], k, n = array.length;
          for (; i < n; ++i) {
            if ((k = array[i][1]) > v) {
              j = i;
              v = k;
            }
          }
          return j;
        }
        function d3_layout_stackReduceSum(d) {
          return d.reduce(d3_layout_stackSum, 0);
        }
        function d3_layout_stackSum(p, d) {
          return p + d[1];
        }
        d3.layout.histogram = function() {
          var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
          function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
              bin = bins[i] = [];
              bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
              bin.y = 0;
            }
            if (m > 0) {
              i = -1;
              while (++i < n) {
                x = values[i];
                if (x >= range[0] && x <= range[1]) {
                  bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                  bin.y += k;
                  bin.push(data[i]);
                }
              }
            }
            return bins;
          }
          histogram.value = function(x) {
            if (!arguments.length) return valuer;
            valuer = x;
            return histogram;
          };
          histogram.range = function(x) {
            if (!arguments.length) return ranger;
            ranger = d3_functor(x);
            return histogram;
          };
          histogram.bins = function(x) {
            if (!arguments.length) return binner;
            binner = typeof x === "number" ? function(range) {
              return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
          };
          histogram.frequency = function(x) {
            if (!arguments.length) return frequency;
            frequency = !!x;
            return histogram;
          };
          return histogram;
        };
        function d3_layout_histogramBinSturges(range, values) {
          return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
        }
        function d3_layout_histogramBinFixed(range, n) {
          var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
          while (++x <= n) f[x] = m * x + b;
          return f;
        }
        function d3_layout_histogramRange(values) {
          return [d3.min(values), d3.max(values)];
        }
        d3.layout.pack = function() {
          var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [1, 1], radius;
          function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
              return radius;
            };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function(d2) {
              d2.r = +r(d2.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
              var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
              d3_layout_hierarchyVisitAfter(root, function(d2) {
                d2.r += dr;
              });
              d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
              d3_layout_hierarchyVisitAfter(root, function(d2) {
                d2.r -= dr;
              });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
          }
          pack.size = function(_) {
            if (!arguments.length) return size;
            size = _;
            return pack;
          };
          pack.radius = function(_) {
            if (!arguments.length) return radius;
            radius = _ == null || typeof _ === "function" ? _ : +_;
            return pack;
          };
          pack.padding = function(_) {
            if (!arguments.length) return padding;
            padding = +_;
            return pack;
          };
          return d3_layout_hierarchyRebind(pack, hierarchy);
        };
        function d3_layout_packSort(a, b) {
          return a.value - b.value;
        }
        function d3_layout_packInsert(a, b) {
          var c = a._pack_next;
          a._pack_next = b;
          b._pack_prev = a;
          b._pack_next = c;
          c._pack_prev = b;
        }
        function d3_layout_packSplice(a, b) {
          a._pack_next = b;
          b._pack_prev = a;
        }
        function d3_layout_packIntersects(a, b) {
          var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
          return 0.999 * dr * dr > dx * dx + dy * dy;
        }
        function d3_layout_packSiblings(node) {
          if (!(nodes = node.children) || !(n = nodes.length)) return;
          var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
          function bound(node2) {
            xMin = Math.min(node2.x - node2.r, xMin);
            xMax = Math.max(node2.x + node2.r, xMax);
            yMin = Math.min(node2.y - node2.r, yMin);
            yMax = Math.max(node2.y + node2.r, yMax);
          }
          nodes.forEach(d3_layout_packLink);
          a = nodes[0];
          a.x = -a.r;
          a.y = 0;
          bound(a);
          if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
              c = nodes[2];
              d3_layout_packPlace(a, b, c);
              bound(c);
              d3_layout_packInsert(a, c);
              a._pack_prev = c;
              d3_layout_packInsert(c, b);
              b = a._pack_next;
              for (i = 3; i < n; i++) {
                d3_layout_packPlace(a, b, c = nodes[i]);
                var isect = 0, s1 = 1, s2 = 1;
                for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                  if (d3_layout_packIntersects(j, c)) {
                    isect = 1;
                    break;
                  }
                }
                if (isect == 1) {
                  for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                    if (d3_layout_packIntersects(k, c)) {
                      break;
                    }
                  }
                }
                if (isect) {
                  if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j);
                  else d3_layout_packSplice(a = k, b);
                  i--;
                } else {
                  d3_layout_packInsert(a, c);
                  b = c;
                  bound(c);
                }
              }
            }
          }
          var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
          for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
          }
          node.r = cr;
          nodes.forEach(d3_layout_packUnlink);
        }
        function d3_layout_packLink(node) {
          node._pack_next = node._pack_prev = node;
        }
        function d3_layout_packUnlink(node) {
          delete node._pack_next;
          delete node._pack_prev;
        }
        function d3_layout_packTransform(node, x, y, k) {
          var children = node.children;
          node.x = x += k * node.x;
          node.y = y += k * node.y;
          node.r *= k;
          if (children) {
            var i = -1, n = children.length;
            while (++i < n) d3_layout_packTransform(children[i], x, y, k);
          }
        }
        function d3_layout_packPlace(a, b, c) {
          var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
          if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = 0.5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
          } else {
            c.x = a.x + db;
            c.y = a.y;
          }
        }
        d3.layout.tree = function() {
          var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = null;
          function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode);
            else {
              var left = root0, right = root0, bottom = root0;
              d3_layout_hierarchyVisitBefore(root0, function(node) {
                if (node.x < left.x) left = node;
                if (node.x > right.x) right = node;
                if (node.depth > bottom.depth) bottom = node;
              });
              var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
              d3_layout_hierarchyVisitBefore(root0, function(node) {
                node.x = (node.x + tx) * kx;
                node.y = node.depth * ky;
              });
            }
            return nodes;
          }
          function wrapTree(root0) {
            var root1 = {
              A: null,
              children: [root0]
            }, queue = [root1], node1;
            while ((node1 = queue.pop()) != null) {
              for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                queue.push((children[i] = child = {
                  _: children[i],
                  parent: node1,
                  children: (child = children[i].children) && child.slice() || [],
                  A: null,
                  a: null,
                  z: 0,
                  m: 0,
                  c: 0,
                  s: 0,
                  t: null,
                  i
                }).a = child);
              }
            }
            return root1.children[0];
          }
          function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
              d3_layout_treeShift(v);
              var midpoint = (children[0].z + children[children.length - 1].z) / 2;
              if (w) {
                v.z = w.z + separation(v._, w._);
                v.m = v.z - midpoint;
              } else {
                v.z = midpoint;
              }
            } else if (w) {
              v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
          }
          function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
          }
          function apportion(v, w, ancestor) {
            if (w) {
              var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
              while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                vom = d3_layout_treeLeft(vom);
                vop = d3_layout_treeRight(vop);
                vop.a = v;
                shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                if (shift > 0) {
                  d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                  sip += shift;
                  sop += shift;
                }
                sim += vim.m;
                sip += vip.m;
                som += vom.m;
                sop += vop.m;
              }
              if (vim && !d3_layout_treeRight(vop)) {
                vop.t = vim;
                vop.m += sim - sop;
              }
              if (vip && !d3_layout_treeLeft(vom)) {
                vom.t = vip;
                vom.m += sip - som;
                ancestor = v;
              }
            }
            return ancestor;
          }
          function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
          }
          tree.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return tree;
          };
          tree.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
          };
          tree.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
          };
          return d3_layout_hierarchyRebind(tree, hierarchy);
        };
        function d3_layout_treeSeparation(a, b) {
          return a.parent == b.parent ? 1 : 2;
        }
        function d3_layout_treeLeft(v) {
          var children = v.children;
          return children.length ? children[0] : v.t;
        }
        function d3_layout_treeRight(v) {
          var children = v.children, n;
          return (n = children.length) ? children[n - 1] : v.t;
        }
        function d3_layout_treeMove(wm, wp, shift) {
          var change = shift / (wp.i - wm.i);
          wp.c -= change;
          wp.s += shift;
          wm.c += change;
          wp.z += shift;
          wp.m += shift;
        }
        function d3_layout_treeShift(v) {
          var shift = 0, change = 0, children = v.children, i = children.length, w;
          while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
          }
        }
        function d3_layout_treeAncestor(vim, v, ancestor) {
          return vim.a.parent === v.parent ? vim.a : ancestor;
        }
        d3.layout.cluster = function() {
          var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = false;
          function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function(node) {
              var children = node.children;
              if (children && children.length) {
                node.x = d3_layout_clusterX(children);
                node.y = d3_layout_clusterY(children);
              } else {
                node.x = previousNode ? x += separation(node, previousNode) : 0;
                node.y = 0;
                previousNode = node;
              }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
              node.x = (node.x - root.x) * size[0];
              node.y = (root.y - node.y) * size[1];
            } : function(node) {
              node.x = (node.x - x0) / (x1 - x0) * size[0];
              node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
          }
          cluster.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return cluster;
          };
          cluster.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
          };
          cluster.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
          };
          return d3_layout_hierarchyRebind(cluster, hierarchy);
        };
        function d3_layout_clusterY(children) {
          return 1 + d3.max(children, function(child) {
            return child.y;
          });
        }
        function d3_layout_clusterX(children) {
          return children.reduce(function(x, child) {
            return x + child.x;
          }, 0) / children.length;
        }
        function d3_layout_clusterLeft(node) {
          var children = node.children;
          return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
        }
        function d3_layout_clusterRight(node) {
          var children = node.children, n;
          return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
        }
        d3.layout.treemap = function() {
          var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [1, 1], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = 0.5 * (1 + Math.sqrt(5));
          function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
              area = (child = children[i]).value * (k < 0 ? 0 : k);
              child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
          }
          function squarify(node) {
            var children = node.children;
            if (children && children.length) {
              var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
              scale(remaining, rect.dx * rect.dy / node.value);
              row.area = 0;
              while ((n = remaining.length) > 0) {
                row.push(child = remaining[n - 1]);
                row.area += child.area;
                if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                  remaining.pop();
                  best = score;
                } else {
                  row.area -= row.pop().area;
                  position(row, u, rect, false);
                  u = Math.min(rect.dx, rect.dy);
                  row.length = row.area = 0;
                  best = Infinity;
                }
              }
              if (row.length) {
                position(row, u, rect, true);
                row.length = row.area = 0;
              }
              children.forEach(squarify);
            }
          }
          function stickify(node) {
            var children = node.children;
            if (children && children.length) {
              var rect = pad(node), remaining = children.slice(), child, row = [];
              scale(remaining, rect.dx * rect.dy / node.value);
              row.area = 0;
              while (child = remaining.pop()) {
                row.push(child);
                row.area += child.area;
                if (child.z != null) {
                  position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                  row.length = row.area = 0;
                }
              }
              children.forEach(stickify);
            }
          }
          function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
              if (!(r = row[i].area)) continue;
              if (r < rmin) rmin = r;
              if (r > rmax) rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
          }
          function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
              if (flush || v > rect.dy) v = rect.dy;
              while (++i < n) {
                o = row[i];
                o.x = x;
                o.y = y;
                o.dy = v;
                x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
              }
              o.z = true;
              o.dx += rect.x + rect.dx - x;
              rect.y += v;
              rect.dy -= v;
            } else {
              if (flush || v > rect.dx) v = rect.dx;
              while (++i < n) {
                o = row[i];
                o.x = x;
                o.y = y;
                o.dx = v;
                y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
              }
              o.z = false;
              o.dy += rect.y + rect.dy - y;
              rect.x += v;
              rect.dx -= v;
            }
          }
          function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = root.y = 0;
            if (root.value) root.dx = size[0], root.dy = size[1];
            else root.dx = root.dy = 0;
            if (stickies) hierarchy.revalue(root);
            scale([root], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) stickies = nodes;
            return nodes;
          }
          treemap.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return treemap;
          };
          treemap.padding = function(x) {
            if (!arguments.length) return padding;
            function padFunction(node) {
              var p = x.call(treemap, node, node.depth);
              return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
            }
            function padConstant(node) {
              return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x], padConstant) : padConstant;
            return treemap;
          };
          treemap.round = function(x) {
            if (!arguments.length) return round != Number;
            round = x ? Math.round : Number;
            return treemap;
          };
          treemap.sticky = function(x) {
            if (!arguments.length) return sticky;
            sticky = x;
            stickies = null;
            return treemap;
          };
          treemap.ratio = function(x) {
            if (!arguments.length) return ratio;
            ratio = x;
            return treemap;
          };
          treemap.mode = function(x) {
            if (!arguments.length) return mode;
            mode = x + "";
            return treemap;
          };
          return d3_layout_hierarchyRebind(treemap, hierarchy);
        };
        function d3_layout_treemapPadNull(node) {
          return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
          };
        }
        function d3_layout_treemapPad(node, padding) {
          var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
          if (dx < 0) {
            x += dx / 2;
            dx = 0;
          }
          if (dy < 0) {
            y += dy / 2;
            dy = 0;
          }
          return {
            x,
            y,
            dx,
            dy
          };
        }
        d3.random = {
          normal: function(mu, sigma) {
            var n = arguments.length;
            if (n < 2) sigma = 1;
            if (n < 1) mu = 0;
            return function() {
              var x, y, r;
              do {
                x = Math.random() * 2 - 1;
                y = Math.random() * 2 - 1;
                r = x * x + y * y;
              } while (!r || r > 1);
              return mu + sigma * x * Math.sqrt(-2 * Math.log(r) / r);
            };
          },
          logNormal: function() {
            var random = d3.random.normal.apply(d3, arguments);
            return function() {
              return Math.exp(random());
            };
          },
          bates: function(m) {
            var random = d3.random.irwinHall(m);
            return function() {
              return random() / m;
            };
          },
          irwinHall: function(m) {
            return function() {
              for (var s = 0, j = 0; j < m; j++) s += Math.random();
              return s;
            };
          }
        };
        d3.scale = {};
        function d3_scaleExtent(domain) {
          var start = domain[0], stop = domain[domain.length - 1];
          return start < stop ? [start, stop] : [stop, start];
        }
        function d3_scaleRange(scale) {
          return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
        }
        function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
          var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
          return function(x) {
            return i(u(x));
          };
        }
        function d3_scale_nice(domain, nice) {
          var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
          if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
          }
          domain[i0] = nice.floor(x0);
          domain[i1] = nice.ceil(x1);
          return domain;
        }
        function d3_scale_niceStep(step) {
          return step ? {
            floor: function(x) {
              return Math.floor(x / step) * step;
            },
            ceil: function(x) {
              return Math.ceil(x / step) * step;
            }
          } : d3_scale_niceIdentity;
        }
        var d3_scale_niceIdentity = {
          floor: d3_identity,
          ceil: d3_identity
        };
        function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
          var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
          if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
          }
          while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
          }
          return function(x) {
            var j2 = d3.bisect(domain, x, 1, k) - 1;
            return i[j2](u[j2](x));
          };
        }
        d3.scale.linear = function() {
          return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
        };
        function d3_scale_linear(domain, range, interpolate, clamp) {
          var output, input;
          function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
          }
          function scale(x) {
            return output(x);
          }
          scale.invert = function(y) {
            return input(y);
          };
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(Number);
            return rescale();
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
          };
          scale.rangeRound = function(x) {
            return scale.range(x).interpolate(d3_interpolateRound);
          };
          scale.clamp = function(x) {
            if (!arguments.length) return clamp;
            clamp = x;
            return rescale();
          };
          scale.interpolate = function(x) {
            if (!arguments.length) return interpolate;
            interpolate = x;
            return rescale();
          };
          scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
          };
          scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
          };
          scale.nice = function(m) {
            d3_scale_linearNice(domain, m);
            return rescale();
          };
          scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, clamp);
          };
          return rescale();
        }
        function d3_scale_linearRebind(scale, linear) {
          return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
        }
        function d3_scale_linearNice(domain, m) {
          d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
          d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
          return domain;
        }
        function d3_scale_linearTickRange(domain, m) {
          if (m == null) m = 10;
          var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
          if (err <= 0.15) step *= 10;
          else if (err <= 0.35) step *= 5;
          else if (err <= 0.75) step *= 2;
          extent[0] = Math.ceil(extent[0] / step) * step;
          extent[1] = Math.floor(extent[1] / step) * step + step * 0.5;
          extent[2] = step;
          return extent;
        }
        function d3_scale_linearTicks(domain, m) {
          return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
        }
        var d3_scale_linearFormatSignificant = {
          s: 1,
          g: 1,
          p: 1,
          r: 1,
          e: 1
        };
        function d3_scale_linearPrecision(value) {
          return -Math.floor(Math.log(value) / Math.LN10 + 0.01);
        }
        function d3_scale_linearFormatPrecision(type, range) {
          var p = d3_scale_linearPrecision(range[2]);
          return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
        }
        d3.scale.log = function() {
          return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
        };
        function d3_scale_log(linear, base, positive, domain) {
          function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
          }
          function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
          }
          function scale(x) {
            return linear(log(x));
          }
          scale.invert = function(x) {
            return pow(linear.invert(x));
          };
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
          };
          scale.base = function(_) {
            if (!arguments.length) return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
          };
          scale.nice = function() {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
          };
          scale.ticks = function() {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
              if (positive) {
                for (; i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
                ticks.push(pow(i));
              } else {
                ticks.push(pow(i));
                for (; i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
              }
              for (i = 0; ticks[i] < u; i++) {
              }
              for (j = ticks.length; ticks[j - 1] > v; j--) {
              }
              ticks = ticks.slice(i, j);
            }
            return ticks;
          };
          scale.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
          };
          return d3_scale_linearRebind(scale, linear);
        }
        var d3_scale_logNiceNegative = {
          floor: function(x) {
            return -Math.ceil(-x);
          },
          ceil: function(x) {
            return -Math.floor(-x);
          }
        };
        d3.scale.pow = function() {
          return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
        };
        function d3_scale_pow(linear, exponent, domain) {
          var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
          function scale(x) {
            return linear(powp(x));
          }
          scale.invert = function(x) {
            return powb(linear.invert(x));
          };
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
          };
          scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
          };
          scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
          };
          scale.nice = function(m) {
            return scale.domain(d3_scale_linearNice(domain, m));
          };
          scale.exponent = function(x) {
            if (!arguments.length) return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
          };
          scale.copy = function() {
            return d3_scale_pow(linear.copy(), exponent, domain);
          };
          return d3_scale_linearRebind(scale, linear);
        }
        function d3_scale_powPow(e) {
          return function(x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
          };
        }
        d3.scale.sqrt = function() {
          return d3.scale.pow().exponent(0.5);
        };
        d3.scale.ordinal = function() {
          return d3_scale_ordinal([], {
            t: "range",
            a: [[]]
          });
        };
        function d3_scale_ordinal(domain, ranger) {
          var index, range, rangeBand;
          function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
          }
          function steps(start, step) {
            return d3.range(domain.length).map(function(i) {
              return start + step * i;
            });
          }
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            rangeBand = 0;
            ranger = {
              t: "range",
              a: arguments
            };
            return scale;
          };
          scale.rangePoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
              t: "rangePoints",
              a: arguments
            };
            return scale;
          };
          scale.rangeRoundPoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
              t: "rangeRoundPoints",
              a: arguments
            };
            return scale;
          };
          scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse) range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
              t: "rangeBands",
              a: arguments
            };
            return scale;
          };
          scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse) range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
              t: "rangeRoundBands",
              a: arguments
            };
            return scale;
          };
          scale.rangeBand = function() {
            return rangeBand;
          };
          scale.rangeExtent = function() {
            return d3_scaleExtent(ranger.a[0]);
          };
          scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
          };
          return scale.domain(domain);
        }
        d3.scale.category10 = function() {
          return d3.scale.ordinal().range(d3_category10);
        };
        d3.scale.category20 = function() {
          return d3.scale.ordinal().range(d3_category20);
        };
        d3.scale.category20b = function() {
          return d3.scale.ordinal().range(d3_category20b);
        };
        d3.scale.category20c = function() {
          return d3.scale.ordinal().range(d3_category20c);
        };
        var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
        var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
        var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
        var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
        d3.scale.quantile = function() {
          return d3_scale_quantile([], []);
        };
        function d3_scale_quantile(domain, range) {
          var thresholds;
          function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
          }
          function scale(x) {
            if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
          }
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
          };
          scale.quantiles = function() {
            return thresholds;
          };
          scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
          };
          scale.copy = function() {
            return d3_scale_quantile(domain, range);
          };
          return rescale();
        }
        d3.scale.quantize = function() {
          return d3_scale_quantize(0, 1, [0, 1]);
        };
        function d3_scale_quantize(x0, x1, range) {
          var kx, i;
          function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
          }
          function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
          }
          scale.domain = function(x) {
            if (!arguments.length) return [x0, x1];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
          };
          scale.invertExtent = function(y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [y, y + 1 / kx];
          };
          scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
          };
          return rescale();
        }
        d3.scale.threshold = function() {
          return d3_scale_threshold([0.5], [0, 1]);
        };
        function d3_scale_threshold(domain, range) {
          function scale(x) {
            if (x <= x) return range[d3.bisect(domain, x)];
          }
          scale.domain = function(_) {
            if (!arguments.length) return domain;
            domain = _;
            return scale;
          };
          scale.range = function(_) {
            if (!arguments.length) return range;
            range = _;
            return scale;
          };
          scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return [domain[y - 1], domain[y]];
          };
          scale.copy = function() {
            return d3_scale_threshold(domain, range);
          };
          return scale;
        }
        d3.scale.identity = function() {
          return d3_scale_identity([0, 1]);
        };
        function d3_scale_identity(domain) {
          function identity(x) {
            return +x;
          }
          identity.invert = identity;
          identity.domain = identity.range = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(identity);
            return identity;
          };
          identity.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
          };
          identity.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
          };
          identity.copy = function() {
            return d3_scale_identity(domain);
          };
          return identity;
        }
        d3.svg = {};
        function d3_zero() {
          return 0;
        }
        d3.svg.arc = function() {
          var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
          function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half\u03C0, a1 = endAngle.apply(this, arguments) - half\u03C0, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
            if (da >= \u03C4\u03B5) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
              rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
              if (!cw) p1 *= -1;
              if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
              if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
              x0 = r1 * Math.cos(a0 + p1);
              y0 = r1 * Math.sin(a0 + p1);
              x1 = r1 * Math.cos(a1 - p1);
              y1 = r1 * Math.sin(a1 - p1);
              var l1 = Math.abs(a1 - a0 - 2 * p1) <= \u03C0 ? 0 : 1;
              if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                var h1 = (a0 + a1) / 2;
                x0 = r1 * Math.cos(h1);
                y0 = r1 * Math.sin(h1);
                x1 = y1 = null;
              }
            } else {
              x0 = y0 = 0;
            }
            if (r0) {
              x2 = r0 * Math.cos(a1 - p0);
              y2 = r0 * Math.sin(a1 - p0);
              x3 = r0 * Math.cos(a0 + p0);
              y3 = r0 * Math.sin(a0 + p0);
              var l0 = Math.abs(a0 - a1 + 2 * p0) <= \u03C0 ? 0 : 1;
              if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                var h0 = (a0 + a1) / 2;
                x2 = r0 * Math.cos(h0);
                y2 = r0 * Math.sin(h0);
                x3 = y3 = null;
              }
            } else {
              x2 = y2 = 0;
            }
            if (da > \u03B5 && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > 1e-3) {
              cr = r0 < r1 ^ cw ? 0 : 1;
              var rc1 = rc, rc0 = rc;
              if (da < \u03C0) {
                var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
              }
              if (x1 != null) {
                var t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
                if (rc === rc1) {
                  path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                } else {
                  path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                }
              } else {
                path.push("M", x0, ",", y0);
              }
              if (x3 != null) {
                var t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
                if (rc === rc0) {
                  path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                } else {
                  path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                }
              } else {
                path.push("L", x2, ",", y2);
              }
            } else {
              path.push("M", x0, ",", y0);
              if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
              path.push("L", x2, ",", y2);
              if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
            }
            path.push("Z");
            return path.join("");
          }
          function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
          }
          arc.innerRadius = function(v) {
            if (!arguments.length) return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
          };
          arc.outerRadius = function(v) {
            if (!arguments.length) return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
          };
          arc.cornerRadius = function(v) {
            if (!arguments.length) return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
          };
          arc.padRadius = function(v) {
            if (!arguments.length) return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
          };
          arc.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return arc;
          };
          arc.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return arc;
          };
          arc.padAngle = function(v) {
            if (!arguments.length) return padAngle;
            padAngle = d3_functor(v);
            return arc;
          };
          arc.centroid = function() {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half\u03C0;
            return [Math.cos(a) * r, Math.sin(a) * r];
          };
          return arc;
        };
        var d3_svg_arcAuto = "auto";
        function d3_svg_arcInnerRadius(d) {
          return d.innerRadius;
        }
        function d3_svg_arcOuterRadius(d) {
          return d.outerRadius;
        }
        function d3_svg_arcStartAngle(d) {
          return d.startAngle;
        }
        function d3_svg_arcEndAngle(d) {
          return d.endAngle;
        }
        function d3_svg_arcPadAngle(d) {
          return d && d.padAngle;
        }
        function d3_svg_arcSweep(x0, y0, x1, y1) {
          return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
        }
        function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
          var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
          if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
          return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
        }
        function d3_true() {
          return true;
        }
        function d3_svg_line(projection) {
          var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = 0.7;
          function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
              segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
              if (defined.call(this, d = data[i], i)) {
                points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
              } else if (points.length) {
                segment();
                points = [];
              }
            }
            if (points.length) segment();
            return segments.length ? segments.join("") : null;
          }
          line.x = function(_) {
            if (!arguments.length) return x;
            x = _;
            return line;
          };
          line.y = function(_) {
            if (!arguments.length) return y;
            y = _;
            return line;
          };
          line.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return line;
          };
          line.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _;
            else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
          };
          line.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return line;
          };
          return line;
        }
        d3.svg.line = function() {
          return d3_svg_line(d3_identity);
        };
        var d3_svg_lineInterpolators = d3.map({
          linear: d3_svg_lineLinear,
          "linear-closed": d3_svg_lineLinearClosed,
          step: d3_svg_lineStep,
          "step-before": d3_svg_lineStepBefore,
          "step-after": d3_svg_lineStepAfter,
          basis: d3_svg_lineBasis,
          "basis-open": d3_svg_lineBasisOpen,
          "basis-closed": d3_svg_lineBasisClosed,
          bundle: d3_svg_lineBundle,
          cardinal: d3_svg_lineCardinal,
          "cardinal-open": d3_svg_lineCardinalOpen,
          "cardinal-closed": d3_svg_lineCardinalClosed,
          monotone: d3_svg_lineMonotone
        });
        d3_svg_lineInterpolators.forEach(function(key, value) {
          value.key = key;
          value.closed = /-closed$/.test(key);
        });
        function d3_svg_lineLinear(points) {
          return points.length > 1 ? points.join("L") : points + "Z";
        }
        function d3_svg_lineLinearClosed(points) {
          return points.join("L") + "Z";
        }
        function d3_svg_lineStep(points) {
          var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
          while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
          if (n > 1) path.push("H", p[0]);
          return path.join("");
        }
        function d3_svg_lineStepBefore(points) {
          var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
          while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
          return path.join("");
        }
        function d3_svg_lineStepAfter(points) {
          var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
          while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
          return path.join("");
        }
        function d3_svg_lineCardinalOpen(points, tension) {
          return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
        }
        function d3_svg_lineCardinalClosed(points, tension) {
          return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
        }
        function d3_svg_lineCardinal(points, tension) {
          return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
        }
        function d3_svg_lineHermite(points, tangents) {
          if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
          }
          var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
          if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
          }
          if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
              p = points[pi];
              t = tangents[i];
              path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
          }
          if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
          }
          return path;
        }
        function d3_svg_lineCardinalTangents(points, tension) {
          var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
          while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
          }
          return tangents;
        }
        function d3_svg_lineBasis(points) {
          if (points.length < 3) return d3_svg_lineLinear(points);
          var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [x0, x0, x0, (pi = points[1])[0]], py = [y0, y0, y0, pi[1]], path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
          points.push(points[n - 1]);
          while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          points.pop();
          path.push("L", pi);
          return path.join("");
        }
        function d3_svg_lineBasisOpen(points) {
          if (points.length < 4) return d3_svg_lineLinear(points);
          var path = [], i = -1, n = points.length, pi, px = [0], py = [0];
          while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
          }
          path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
          --i;
          while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          return path.join("");
        }
        function d3_svg_lineBasisClosed(points) {
          var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
          while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
          }
          path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
          --i;
          while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          return path.join("");
        }
        function d3_svg_lineBundle(points, tension) {
          var n = points.length - 1;
          if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
              p = points[i];
              t = i / n;
              p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
              p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
          }
          return d3_svg_lineBasis(points);
        }
        function d3_svg_lineDot4(a, b) {
          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        }
        var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0], d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0], d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
        function d3_svg_lineBasisBezier(path, x, y) {
          path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
        }
        function d3_svg_lineSlope(p0, p1) {
          return (p1[1] - p0[1]) / (p1[0] - p0[0]);
        }
        function d3_svg_lineFiniteDifferences(points) {
          var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
          while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
          }
          m[i] = d;
          return m;
        }
        function d3_svg_lineMonotoneTangents(points) {
          var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
          while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < \u03B5) {
              m[i] = m[i + 1] = 0;
            } else {
              a = m[i] / d;
              b = m[i + 1] / d;
              s = a * a + b * b;
              if (s > 9) {
                s = d * 3 / Math.sqrt(s);
                m[i] = s * a;
                m[i + 1] = s * b;
              }
            }
          }
          i = -1;
          while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([s || 0, m[i] * s || 0]);
          }
          return tangents;
        }
        function d3_svg_lineMonotone(points) {
          return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
        }
        d3.svg.line.radial = function() {
          var line = d3_svg_line(d3_svg_lineRadial);
          line.radius = line.x, delete line.x;
          line.angle = line.y, delete line.y;
          return line;
        };
        function d3_svg_lineRadial(points) {
          var point, i = -1, n = points.length, r, a;
          while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - half\u03C0;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
          }
          return points;
        }
        function d3_svg_area(projection) {
          var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = 0.7;
          function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
              return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
              return y;
            } : d3_functor(y1), x, y;
            function segment() {
              segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
              if (defined.call(this, d = data[i], i)) {
                points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
                points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
              } else if (points0.length) {
                segment();
                points0 = [];
                points1 = [];
              }
            }
            if (points0.length) segment();
            return segments.length ? segments.join("") : null;
          }
          area.x = function(_) {
            if (!arguments.length) return x1;
            x0 = x1 = _;
            return area;
          };
          area.x0 = function(_) {
            if (!arguments.length) return x0;
            x0 = _;
            return area;
          };
          area.x1 = function(_) {
            if (!arguments.length) return x1;
            x1 = _;
            return area;
          };
          area.y = function(_) {
            if (!arguments.length) return y1;
            y0 = y1 = _;
            return area;
          };
          area.y0 = function(_) {
            if (!arguments.length) return y0;
            y0 = _;
            return area;
          };
          area.y1 = function(_) {
            if (!arguments.length) return y1;
            y1 = _;
            return area;
          };
          area.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return area;
          };
          area.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _;
            else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
          };
          area.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return area;
          };
          return area;
        }
        d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
        d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
        d3.svg.area = function() {
          return d3_svg_area(d3_identity);
        };
        d3.svg.area.radial = function() {
          var area = d3_svg_area(d3_svg_lineRadial);
          area.radius = area.x, delete area.x;
          area.innerRadius = area.x0, delete area.x0;
          area.outerRadius = area.x1, delete area.x1;
          area.angle = area.y, delete area.y;
          area.startAngle = area.y0, delete area.y0;
          area.endAngle = area.y1, delete area.y1;
          return area;
        };
        function d3_source(d) {
          return d.source;
        }
        function d3_target(d) {
          return d.target;
        }
        d3.svg.chord = function() {
          var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
          function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
          }
          function subgroup(self2, f, d, i) {
            var subgroup2 = f.call(self2, d, i), r = radius.call(self2, subgroup2, i), a0 = startAngle.call(self2, subgroup2, i) - half\u03C0, a1 = endAngle.call(self2, subgroup2, i) - half\u03C0;
            return {
              r,
              a0,
              a1,
              p0: [r * Math.cos(a0), r * Math.sin(a0)],
              p1: [r * Math.cos(a1), r * Math.sin(a1)]
            };
          }
          function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
          }
          function arc(r, p, a) {
            return "A" + r + "," + r + " 0 " + +(a > \u03C0) + ",1 " + p;
          }
          function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
          }
          chord.radius = function(v) {
            if (!arguments.length) return radius;
            radius = d3_functor(v);
            return chord;
          };
          chord.source = function(v) {
            if (!arguments.length) return source;
            source = d3_functor(v);
            return chord;
          };
          chord.target = function(v) {
            if (!arguments.length) return target;
            target = d3_functor(v);
            return chord;
          };
          chord.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return chord;
          };
          chord.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return chord;
          };
          return chord;
        };
        function d3_svg_chordRadius(d) {
          return d.radius;
        }
        d3.svg.diagonal = function() {
          var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
          function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [p0, {
              x: p0.x,
              y: m
            }, {
              x: p3.x,
              y: m
            }, p3];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
          }
          diagonal.source = function(x) {
            if (!arguments.length) return source;
            source = d3_functor(x);
            return diagonal;
          };
          diagonal.target = function(x) {
            if (!arguments.length) return target;
            target = d3_functor(x);
            return diagonal;
          };
          diagonal.projection = function(x) {
            if (!arguments.length) return projection;
            projection = x;
            return diagonal;
          };
          return diagonal;
        };
        function d3_svg_diagonalProjection(d) {
          return [d.x, d.y];
        }
        d3.svg.diagonal.radial = function() {
          var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
          diagonal.projection = function(x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
          };
          return diagonal;
        };
        function d3_svg_diagonalRadialProjection(projection) {
          return function() {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - half\u03C0;
            return [r * Math.cos(a), r * Math.sin(a)];
          };
        }
        d3.svg.symbol = function() {
          var type = d3_svg_symbolType, size = d3_svg_symbolSize;
          function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
          }
          symbol.type = function(x) {
            if (!arguments.length) return type;
            type = d3_functor(x);
            return symbol;
          };
          symbol.size = function(x) {
            if (!arguments.length) return size;
            size = d3_functor(x);
            return symbol;
          };
          return symbol;
        };
        function d3_svg_symbolSize() {
          return 64;
        }
        function d3_svg_symbolType() {
          return "circle";
        }
        function d3_svg_symbolCircle(size) {
          var r = Math.sqrt(size / \u03C0);
          return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
        }
        var d3_svg_symbols = d3.map({
          circle: d3_svg_symbolCircle,
          cross: function(size) {
            var r = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
          },
          diamond: function(size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z";
          },
          square: function(size) {
            var r = Math.sqrt(size) / 2;
            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
          },
          "triangle-down": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
          },
          "triangle-up": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
          }
        });
        d3.svg.symbolTypes = d3_svg_symbols.keys();
        var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
        d3_selectionPrototype.transition = function(name) {
          var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
            time: Date.now(),
            ease: d3_ease_cubicInOut,
            delay: 0,
            duration: 250
          };
          for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
              subgroup.push(node);
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_selectionPrototype.interrupt = function(name) {
          return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
        };
        var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
        function d3_selection_interruptNS(ns) {
          return function() {
            var lock, activeId, active;
            if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
              active.timer.c = null;
              active.timer.t = NaN;
              if (--lock.count) delete lock[activeId];
              else delete this[ns];
              lock.active += 0.5;
              active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
          };
        }
        function d3_transition(groups, ns, id) {
          d3_subclass(groups, d3_transitionPrototype);
          groups.namespace = ns;
          groups.id = id;
          return groups;
        }
        var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
        d3_transitionPrototype.call = d3_selectionPrototype.call;
        d3_transitionPrototype.empty = d3_selectionPrototype.empty;
        d3_transitionPrototype.node = d3_selectionPrototype.node;
        d3_transitionPrototype.size = d3_selectionPrototype.size;
        d3.transition = function(selection, name) {
          return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
        };
        d3.transition.prototype = d3_transitionPrototype;
        d3_transitionPrototype.select = function(selector) {
          var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
          selector = d3_selection_selector(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                if ("__data__" in node) subnode.__data__ = node.__data__;
                d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                subgroup.push(subnode);
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_transitionPrototype.selectAll = function(selector) {
          var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
          selector = d3_selection_selectorAll(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                transition = node[ns][id];
                subnodes = selector.call(node, node.__data__, i, j);
                subgroups.push(subgroup = []);
                for (var k = -1, o = subnodes.length; ++k < o; ) {
                  if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                  subgroup.push(subnode);
                }
              }
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_transitionPrototype.filter = function(filter) {
          var subgroups = [], subgroup, group, node;
          if (typeof filter !== "function") filter = d3_selection_filter(filter);
          for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
              if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                subgroup.push(node);
              }
            }
          }
          return d3_transition(subgroups, this.namespace, this.id);
        };
        d3_transitionPrototype.tween = function(name, tween) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
          return d3_selection_each(this, tween == null ? function(node) {
            node[ns][id].tween.remove(name);
          } : function(node) {
            node[ns][id].tween.set(name, tween);
          });
        };
        function d3_transition_tween(groups, name, value, tween) {
          var id = groups.id, ns = groups.namespace;
          return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
          } : (value = tween(value), function(node) {
            node[ns][id].tween.set(name, value);
          }));
        }
        d3_transitionPrototype.attr = function(nameNS, value) {
          if (arguments.length < 2) {
            for (value in nameNS) this.attr(value, nameNS[value]);
            return this;
          }
          var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
          function attrNull() {
            this.removeAttribute(name);
          }
          function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
          }
          function attrTween(b) {
            return b == null ? attrNull : (b += "", function() {
              var a = this.getAttribute(name), i;
              return a !== b && (i = interpolate(a, b), function(t) {
                this.setAttribute(name, i(t));
              });
            });
          }
          function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += "", function() {
              var a = this.getAttributeNS(name.space, name.local), i;
              return a !== b && (i = interpolate(a, b), function(t) {
                this.setAttributeNS(name.space, name.local, i(t));
              });
            });
          }
          return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
        };
        d3_transitionPrototype.attrTween = function(nameNS, tween) {
          var name = d3.ns.qualify(nameNS);
          function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function(t) {
              this.setAttribute(name, f(t));
            };
          }
          function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function(t) {
              this.setAttributeNS(name.space, name.local, f(t));
            };
          }
          return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
        };
        d3_transitionPrototype.style = function(name, value, priority) {
          var n = arguments.length;
          if (n < 3) {
            if (typeof name !== "string") {
              if (n < 2) value = "";
              for (priority in name) this.style(priority, name[priority], value);
              return this;
            }
            priority = "";
          }
          function styleNull() {
            this.style.removeProperty(name);
          }
          function styleString(b) {
            return b == null ? styleNull : (b += "", function() {
              var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
              return a !== b && (i = d3_interpolate(a, b), function(t) {
                this.style.setProperty(name, i(t), priority);
              });
            });
          }
          return d3_transition_tween(this, "style." + name, value, styleString);
        };
        d3_transitionPrototype.styleTween = function(name, tween, priority) {
          if (arguments.length < 3) priority = "";
          function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function(t) {
              this.style.setProperty(name, f(t), priority);
            };
          }
          return this.tween("style." + name, styleTween);
        };
        d3_transitionPrototype.text = function(value) {
          return d3_transition_tween(this, "text", value, d3_transition_text);
        };
        function d3_transition_text(b) {
          if (b == null) b = "";
          return function() {
            this.textContent = b;
          };
        }
        d3_transitionPrototype.remove = function() {
          var ns = this.namespace;
          return this.each("end.transition", function() {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
          });
        };
        d3_transitionPrototype.ease = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].ease;
          if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
          return d3_selection_each(this, function(node) {
            node[ns][id].ease = value;
          });
        };
        d3_transitionPrototype.delay = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].delay;
          return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
          } : (value = +value, function(node) {
            node[ns][id].delay = value;
          }));
        };
        d3_transitionPrototype.duration = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].duration;
          return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
          } : (value = Math.max(1, value), function(node) {
            node[ns][id].duration = value;
          }));
        };
        d3_transitionPrototype.each = function(type, listener) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
              d3_transitionInheritId = id;
              d3_selection_each(this, function(node, i, j) {
                d3_transitionInherit = node[ns][id];
                type.call(node, node.__data__, i, j);
              });
            } finally {
              d3_transitionInherit = inherit;
              d3_transitionInheritId = inheritId;
            }
          } else {
            d3_selection_each(this, function(node) {
              var transition = node[ns][id];
              (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
            });
          }
          return this;
        };
        d3_transitionPrototype.transition = function() {
          var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
          for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
              if (node = group[i]) {
                transition = node[ns][id0];
                d3_transitionNode(node, i, ns, id1, {
                  time: transition.time,
                  ease: transition.ease,
                  delay: transition.delay + transition.duration,
                  duration: transition.duration
                });
              }
              subgroup.push(node);
            }
          }
          return d3_transition(subgroups, ns, id1);
        };
        function d3_transitionNamespace(name) {
          return name == null ? "__transition__" : "__transition_" + name + "__";
        }
        function d3_transitionNode(node, i, ns, id, inherit) {
          var lock = node[ns] || (node[ns] = {
            active: 0,
            count: 0
          }), transition = lock[id], time, timer, duration, ease, tweens;
          function schedule(elapsed) {
            var delay = transition.delay;
            timer.t = delay + time;
            if (delay <= elapsed) return start(elapsed - delay);
            timer.c = start;
          }
          function start(elapsed) {
            var activeId = lock.active, active = lock[activeId];
            if (active) {
              active.timer.c = null;
              active.timer.t = NaN;
              --lock.count;
              delete lock[activeId];
              active.event && active.event.interrupt.call(node, node.__data__, active.index);
            }
            for (var cancelId in lock) {
              if (+cancelId < id) {
                var cancel = lock[cancelId];
                cancel.timer.c = null;
                cancel.timer.t = NaN;
                --lock.count;
                delete lock[cancelId];
              }
            }
            timer.c = tick;
            d3_timer(function() {
              if (timer.c && tick(elapsed || 1)) {
                timer.c = null;
                timer.t = NaN;
              }
              return 1;
            }, 0, time);
            lock.active = id;
            transition.event && transition.event.start.call(node, node.__data__, i);
            tweens = [];
            transition.tween.forEach(function(key, value) {
              if (value = value.call(node, node.__data__, i)) {
                tweens.push(value);
              }
            });
            ease = transition.ease;
            duration = transition.duration;
          }
          function tick(elapsed) {
            var t = elapsed / duration, e = ease(t), n = tweens.length;
            while (n > 0) {
              tweens[--n].call(node, e);
            }
            if (t >= 1) {
              transition.event && transition.event.end.call(node, node.__data__, i);
              if (--lock.count) delete lock[id];
              else delete node[ns];
              return 1;
            }
          }
          if (!transition) {
            time = inherit.time;
            timer = d3_timer(schedule, 0, time);
            transition = lock[id] = {
              tween: new d3_Map(),
              time,
              timer,
              delay: inherit.delay,
              duration: inherit.duration,
              ease: inherit.ease,
              index: i
            };
            inherit = null;
            ++lock.count;
          }
        }
        d3.svg.axis = function() {
          var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [10], tickValues = null, tickFormat_;
          function axis(g) {
            g.each(function() {
              var g2 = d3.select(this);
              var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
              var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g2.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", \u03B5), tickExit = d3.transition(tick.exit()).style("opacity", \u03B5).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
              var range = d3_scaleRange(scale1), path = g2.selectAll(".domain").data([0]), pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
              tickEnter.append("line");
              tickEnter.append("text");
              var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
              if (orient === "bottom" || orient === "top") {
                tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
                text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
              } else {
                tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
                text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
                pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
              }
              lineEnter.attr(y2, sign * innerTickSize);
              textEnter.attr(y1, sign * tickSpacing);
              lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
              textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
              if (scale1.rangeBand) {
                var x = scale1, dx = x.rangeBand() / 2;
                scale0 = scale1 = function(d) {
                  return x(d) + dx;
                };
              } else if (scale0.rangeBand) {
                scale0 = scale1;
              } else {
                tickExit.call(tickTransform, scale1, scale0);
              }
              tickEnter.call(tickTransform, scale0, scale1);
              tickUpdate.call(tickTransform, scale1, scale1);
            });
          }
          axis.scale = function(x) {
            if (!arguments.length) return scale;
            scale = x;
            return axis;
          };
          axis.orient = function(x) {
            if (!arguments.length) return orient;
            orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
            return axis;
          };
          axis.ticks = function() {
            if (!arguments.length) return tickArguments_;
            tickArguments_ = d3_array(arguments);
            return axis;
          };
          axis.tickValues = function(x) {
            if (!arguments.length) return tickValues;
            tickValues = x;
            return axis;
          };
          axis.tickFormat = function(x) {
            if (!arguments.length) return tickFormat_;
            tickFormat_ = x;
            return axis;
          };
          axis.tickSize = function(x) {
            var n = arguments.length;
            if (!n) return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
          };
          axis.innerTickSize = function(x) {
            if (!arguments.length) return innerTickSize;
            innerTickSize = +x;
            return axis;
          };
          axis.outerTickSize = function(x) {
            if (!arguments.length) return outerTickSize;
            outerTickSize = +x;
            return axis;
          };
          axis.tickPadding = function(x) {
            if (!arguments.length) return tickPadding;
            tickPadding = +x;
            return axis;
          };
          axis.tickSubdivide = function() {
            return arguments.length && axis;
          };
          return axis;
        };
        var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
          top: 1,
          right: 1,
          bottom: 1,
          left: 1
        };
        function d3_svg_axisX(selection, x0, x1) {
          selection.attr("transform", function(d) {
            var v0 = x0(d);
            return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
          });
        }
        function d3_svg_axisY(selection, y0, y1) {
          selection.attr("transform", function(d) {
            var v0 = y0(d);
            return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
          });
        }
        d3.svg.brush = function() {
          var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [0, 0], yExtent = [0, 0], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
          function brush(g) {
            g.each(function() {
              var g2 = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
              var background = g2.selectAll(".background").data([0]);
              background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
              g2.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
              var resize = g2.selectAll(".resize").data(resizes, d3_identity);
              resize.exit().remove();
              resize.enter().append("g").attr("class", function(d) {
                return "resize " + d;
              }).style("cursor", function(d) {
                return d3_svg_brushCursor[d];
              }).append("rect").attr("x", function(d) {
                return /[ew]$/.test(d) ? -3 : null;
              }).attr("y", function(d) {
                return /^[ns]/.test(d) ? -3 : null;
              }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
              resize.style("display", brush.empty() ? "none" : null);
              var gUpdate = d3.transition(g2), backgroundUpdate = d3.transition(background), range;
              if (x) {
                range = d3_scaleRange(x);
                backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                redrawX(gUpdate);
              }
              if (y) {
                range = d3_scaleRange(y);
                backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                redrawY(gUpdate);
              }
              redraw(gUpdate);
            });
          }
          brush.event = function(g) {
            g.each(function() {
              var event_ = event.of(this, arguments), extent1 = {
                x: xExtent,
                y: yExtent,
                i: xExtentDomain,
                j: yExtentDomain
              }, extent0 = this.__chart__ || extent1;
              this.__chart__ = extent1;
              if (d3_transitionInheritId) {
                d3.select(this).transition().each("start.brush", function() {
                  xExtentDomain = extent0.i;
                  yExtentDomain = extent0.j;
                  xExtent = extent0.x;
                  yExtent = extent0.y;
                  event_({
                    type: "brushstart"
                  });
                }).tween("brush:brush", function() {
                  var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                  xExtentDomain = yExtentDomain = null;
                  return function(t) {
                    xExtent = extent1.x = xi(t);
                    yExtent = extent1.y = yi(t);
                    event_({
                      type: "brush",
                      mode: "resize"
                    });
                  };
                }).each("end.brush", function() {
                  xExtentDomain = extent1.i;
                  yExtentDomain = extent1.j;
                  event_({
                    type: "brush",
                    mode: "resize"
                  });
                  event_({
                    type: "brushend"
                  });
                });
              } else {
                event_({
                  type: "brushstart"
                });
                event_({
                  type: "brush",
                  mode: "resize"
                });
                event_({
                  type: "brushend"
                });
              }
            });
          };
          function redraw(g) {
            g.selectAll(".resize").attr("transform", function(d) {
              return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
            });
          }
          function redrawX(g) {
            g.select(".extent").attr("x", xExtent[0]);
            g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
          }
          function redrawY(g) {
            g.select(".extent").attr("y", yExtent[0]);
            g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
          }
          function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d3.event.changedTouches) {
              w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
            } else {
              w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
            }
            g.interrupt().selectAll("*").interrupt();
            if (dragging) {
              origin[0] = xExtent[0] - origin[0];
              origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
              var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
              offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
              origin[0] = xExtent[ex];
              origin[1] = yExtent[ey];
            } else if (d3.event.altKey) center = origin.slice();
            g.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d3.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
              type: "brushstart"
            });
            brushmove();
            function keydown() {
              if (d3.event.keyCode == 32) {
                if (!dragging) {
                  center = null;
                  origin[0] -= xExtent[1];
                  origin[1] -= yExtent[1];
                  dragging = 2;
                }
                d3_eventPreventDefault();
              }
            }
            function keyup() {
              if (d3.event.keyCode == 32 && dragging == 2) {
                origin[0] += xExtent[1];
                origin[1] += yExtent[1];
                dragging = 0;
                d3_eventPreventDefault();
              }
            }
            function brushmove() {
              var point = d3.mouse(target), moved = false;
              if (offset) {
                point[0] += offset[0];
                point[1] += offset[1];
              }
              if (!dragging) {
                if (d3.event.altKey) {
                  if (!center) center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                  origin[0] = xExtent[+(point[0] < center[0])];
                  origin[1] = yExtent[+(point[1] < center[1])];
                } else center = null;
              }
              if (resizingX && move1(point, x, 0)) {
                redrawX(g);
                moved = true;
              }
              if (resizingY && move1(point, y, 1)) {
                redrawY(g);
                moved = true;
              }
              if (moved) {
                redraw(g);
                event_({
                  type: "brush",
                  mode: dragging ? "move" : "resize"
                });
              }
            }
            function move1(point, scale, i) {
              var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
              if (dragging) {
                r0 -= position;
                r1 -= size + position;
              }
              min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
              if (dragging) {
                max = (min += position) + size;
              } else {
                if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                if (position < min) {
                  max = min;
                  min = position;
                } else {
                  max = position;
                }
              }
              if (extent[0] != min || extent[1] != max) {
                if (i) yExtentDomain = null;
                else xExtentDomain = null;
                extent[0] = min;
                extent[1] = max;
                return true;
              }
            }
            function brushend() {
              brushmove();
              g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
              d3.select("body").style("cursor", null);
              w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
              dragRestore();
              event_({
                type: "brushend"
              });
            }
          }
          brush.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
          };
          brush.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
          };
          brush.clamp = function(z) {
            if (!arguments.length) return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
            if (x && y) xClamp = !!z[0], yClamp = !!z[1];
            else if (x) xClamp = !!z;
            else if (y) yClamp = !!z;
            return brush;
          };
          brush.extent = function(z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
              if (x) {
                if (xExtentDomain) {
                  x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                } else {
                  x0 = xExtent[0], x1 = xExtent[1];
                  if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                  if (x1 < x0) t = x0, x0 = x1, x1 = t;
                }
              }
              if (y) {
                if (yExtentDomain) {
                  y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                } else {
                  y0 = yExtent[0], y1 = yExtent[1];
                  if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                  if (y1 < y0) t = y0, y0 = y1, y1 = t;
                }
              }
              return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
            }
            if (x) {
              x0 = z[0], x1 = z[1];
              if (y) x0 = x0[0], x1 = x1[0];
              xExtentDomain = [x0, x1];
              if (x.invert) x0 = x(x0), x1 = x(x1);
              if (x1 < x0) t = x0, x0 = x1, x1 = t;
              if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [x0, x1];
            }
            if (y) {
              y0 = z[0], y1 = z[1];
              if (x) y0 = y0[1], y1 = y1[1];
              yExtentDomain = [y0, y1];
              if (y.invert) y0 = y(y0), y1 = y(y1);
              if (y1 < y0) t = y0, y0 = y1, y1 = t;
              if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [y0, y1];
            }
            return brush;
          };
          brush.clear = function() {
            if (!brush.empty()) {
              xExtent = [0, 0], yExtent = [0, 0];
              xExtentDomain = yExtentDomain = null;
            }
            return brush;
          };
          brush.empty = function() {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
          };
          return d3.rebind(brush, event, "on");
        };
        var d3_svg_brushCursor = {
          n: "ns-resize",
          e: "ew-resize",
          s: "ns-resize",
          w: "ew-resize",
          nw: "nwse-resize",
          ne: "nesw-resize",
          se: "nwse-resize",
          sw: "nesw-resize"
        };
        var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
        d3.text = d3_xhrType(function(request) {
          return request.responseText;
        });
        d3.json = function(url, callback) {
          return d3_xhr(url, "application/json", d3_json, callback);
        };
        function d3_json(request) {
          return JSON.parse(request.responseText);
        }
        d3.html = function(url, callback) {
          return d3_xhr(url, "text/html", d3_html, callback);
        };
        function d3_html(request) {
          var range = d3_document.createRange();
          range.selectNode(d3_document.body);
          return range.createContextualFragment(request.responseText);
        }
        d3.xml = d3_xhrType(function(request) {
          return request.responseXML;
        });
        if (typeof define === "function" && false) define(d3);
        else if (typeof module === "object" && module.exports) module.exports = d3;
        else this.d3 = d3;
      }.apply(self);
    }
  });

  // node_modules/d3-time/dist/d3-time.js
  var require_d3_time = __commonJS({
    "node_modules/d3-time/dist/d3-time.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        var t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
        function newInterval(floori, offseti, count, field) {
          function interval(date) {
            return floori(date = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date)), date;
          }
          interval.floor = function(date) {
            return floori(date = /* @__PURE__ */ new Date(+date)), date;
          };
          interval.ceil = function(date) {
            return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
          };
          interval.round = function(date) {
            var d0 = interval(date), d1 = interval.ceil(date);
            return date - d0 < d1 - date ? d0 : d1;
          };
          interval.offset = function(date, step) {
            return offseti(date = /* @__PURE__ */ new Date(+date), step == null ? 1 : Math.floor(step)), date;
          };
          interval.range = function(start, stop, step) {
            var range = [], previous;
            start = interval.ceil(start);
            step = step == null ? 1 : Math.floor(step);
            if (!(start < stop) || !(step > 0)) return range;
            do
              range.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
            while (previous < start && start < stop);
            return range;
          };
          interval.filter = function(test) {
            return newInterval(function(date) {
              if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
            }, function(date, step) {
              if (date >= date) {
                if (step < 0) while (++step <= 0) {
                  while (offseti(date, -1), !test(date)) {
                  }
                }
                else while (--step >= 0) {
                  while (offseti(date, 1), !test(date)) {
                  }
                }
              }
            });
          };
          if (count) {
            interval.count = function(start, end) {
              t0.setTime(+start), t1.setTime(+end);
              floori(t0), floori(t1);
              return Math.floor(count(t0, t1));
            };
            interval.every = function(step) {
              step = Math.floor(step);
              return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) {
                return field(d) % step === 0;
              } : function(d) {
                return interval.count(0, d) % step === 0;
              });
            };
          }
          return interval;
        }
        var millisecond = newInterval(function() {
        }, function(date, step) {
          date.setTime(+date + step);
        }, function(start, end) {
          return end - start;
        });
        millisecond.every = function(k) {
          k = Math.floor(k);
          if (!isFinite(k) || !(k > 0)) return null;
          if (!(k > 1)) return millisecond;
          return newInterval(function(date) {
            date.setTime(Math.floor(date / k) * k);
          }, function(date, step) {
            date.setTime(+date + step * k);
          }, function(start, end) {
            return (end - start) / k;
          });
        };
        var milliseconds = millisecond.range;
        var durationSecond = 1e3;
        var durationMinute = 6e4;
        var durationHour = 36e5;
        var durationDay = 864e5;
        var durationWeek = 6048e5;
        var second = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds());
        }, function(date, step) {
          date.setTime(+date + step * durationSecond);
        }, function(start, end) {
          return (end - start) / durationSecond;
        }, function(date) {
          return date.getUTCSeconds();
        });
        var seconds = second.range;
        var minute = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
        }, function(date, step) {
          date.setTime(+date + step * durationMinute);
        }, function(start, end) {
          return (end - start) / durationMinute;
        }, function(date) {
          return date.getMinutes();
        });
        var minutes = minute.range;
        var hour = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
        }, function(date, step) {
          date.setTime(+date + step * durationHour);
        }, function(start, end) {
          return (end - start) / durationHour;
        }, function(date) {
          return date.getHours();
        });
        var hours = hour.range;
        var day = newInterval(function(date) {
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setDate(date.getDate() + step);
        }, function(start, end) {
          return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
        }, function(date) {
          return date.getDate() - 1;
        });
        var days = day.range;
        function weekday(i) {
          return newInterval(function(date) {
            date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
            date.setHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setDate(date.getDate() + step * 7);
          }, function(start, end) {
            return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
          });
        }
        var sunday = weekday(0);
        var monday = weekday(1);
        var tuesday = weekday(2);
        var wednesday = weekday(3);
        var thursday = weekday(4);
        var friday = weekday(5);
        var saturday = weekday(6);
        var sundays = sunday.range;
        var mondays = monday.range;
        var tuesdays = tuesday.range;
        var wednesdays = wednesday.range;
        var thursdays = thursday.range;
        var fridays = friday.range;
        var saturdays = saturday.range;
        var month = newInterval(function(date) {
          date.setDate(1);
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setMonth(date.getMonth() + step);
        }, function(start, end) {
          return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
        }, function(date) {
          return date.getMonth();
        });
        var months = month.range;
        var year = newInterval(function(date) {
          date.setMonth(0, 1);
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setFullYear(date.getFullYear() + step);
        }, function(start, end) {
          return end.getFullYear() - start.getFullYear();
        }, function(date) {
          return date.getFullYear();
        });
        year.every = function(k) {
          return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
            date.setFullYear(Math.floor(date.getFullYear() / k) * k);
            date.setMonth(0, 1);
            date.setHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setFullYear(date.getFullYear() + step * k);
          });
        };
        var years = year.range;
        var utcMinute = newInterval(function(date) {
          date.setUTCSeconds(0, 0);
        }, function(date, step) {
          date.setTime(+date + step * durationMinute);
        }, function(start, end) {
          return (end - start) / durationMinute;
        }, function(date) {
          return date.getUTCMinutes();
        });
        var utcMinutes = utcMinute.range;
        var utcHour = newInterval(function(date) {
          date.setUTCMinutes(0, 0, 0);
        }, function(date, step) {
          date.setTime(+date + step * durationHour);
        }, function(start, end) {
          return (end - start) / durationHour;
        }, function(date) {
          return date.getUTCHours();
        });
        var utcHours = utcHour.range;
        var utcDay = newInterval(function(date) {
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCDate(date.getUTCDate() + step);
        }, function(start, end) {
          return (end - start) / durationDay;
        }, function(date) {
          return date.getUTCDate() - 1;
        });
        var utcDays = utcDay.range;
        function utcWeekday(i) {
          return newInterval(function(date) {
            date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
            date.setUTCHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setUTCDate(date.getUTCDate() + step * 7);
          }, function(start, end) {
            return (end - start) / durationWeek;
          });
        }
        var utcSunday = utcWeekday(0);
        var utcMonday = utcWeekday(1);
        var utcTuesday = utcWeekday(2);
        var utcWednesday = utcWeekday(3);
        var utcThursday = utcWeekday(4);
        var utcFriday = utcWeekday(5);
        var utcSaturday = utcWeekday(6);
        var utcSundays = utcSunday.range;
        var utcMondays = utcMonday.range;
        var utcTuesdays = utcTuesday.range;
        var utcWednesdays = utcWednesday.range;
        var utcThursdays = utcThursday.range;
        var utcFridays = utcFriday.range;
        var utcSaturdays = utcSaturday.range;
        var utcMonth = newInterval(function(date) {
          date.setUTCDate(1);
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCMonth(date.getUTCMonth() + step);
        }, function(start, end) {
          return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
        }, function(date) {
          return date.getUTCMonth();
        });
        var utcMonths = utcMonth.range;
        var utcYear = newInterval(function(date) {
          date.setUTCMonth(0, 1);
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCFullYear(date.getUTCFullYear() + step);
        }, function(start, end) {
          return end.getUTCFullYear() - start.getUTCFullYear();
        }, function(date) {
          return date.getUTCFullYear();
        });
        utcYear.every = function(k) {
          return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
            date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
            date.setUTCMonth(0, 1);
            date.setUTCHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setUTCFullYear(date.getUTCFullYear() + step * k);
          });
        };
        var utcYears = utcYear.range;
        exports2.timeDay = day;
        exports2.timeDays = days;
        exports2.timeFriday = friday;
        exports2.timeFridays = fridays;
        exports2.timeHour = hour;
        exports2.timeHours = hours;
        exports2.timeInterval = newInterval;
        exports2.timeMillisecond = millisecond;
        exports2.timeMilliseconds = milliseconds;
        exports2.timeMinute = minute;
        exports2.timeMinutes = minutes;
        exports2.timeMonday = monday;
        exports2.timeMondays = mondays;
        exports2.timeMonth = month;
        exports2.timeMonths = months;
        exports2.timeSaturday = saturday;
        exports2.timeSaturdays = saturdays;
        exports2.timeSecond = second;
        exports2.timeSeconds = seconds;
        exports2.timeSunday = sunday;
        exports2.timeSundays = sundays;
        exports2.timeThursday = thursday;
        exports2.timeThursdays = thursdays;
        exports2.timeTuesday = tuesday;
        exports2.timeTuesdays = tuesdays;
        exports2.timeWednesday = wednesday;
        exports2.timeWednesdays = wednesdays;
        exports2.timeWeek = sunday;
        exports2.timeWeeks = sundays;
        exports2.timeYear = year;
        exports2.timeYears = years;
        exports2.utcDay = utcDay;
        exports2.utcDays = utcDays;
        exports2.utcFriday = utcFriday;
        exports2.utcFridays = utcFridays;
        exports2.utcHour = utcHour;
        exports2.utcHours = utcHours;
        exports2.utcMillisecond = millisecond;
        exports2.utcMilliseconds = milliseconds;
        exports2.utcMinute = utcMinute;
        exports2.utcMinutes = utcMinutes;
        exports2.utcMonday = utcMonday;
        exports2.utcMondays = utcMondays;
        exports2.utcMonth = utcMonth;
        exports2.utcMonths = utcMonths;
        exports2.utcSaturday = utcSaturday;
        exports2.utcSaturdays = utcSaturdays;
        exports2.utcSecond = second;
        exports2.utcSeconds = seconds;
        exports2.utcSunday = utcSunday;
        exports2.utcSundays = utcSundays;
        exports2.utcThursday = utcThursday;
        exports2.utcThursdays = utcThursdays;
        exports2.utcTuesday = utcTuesday;
        exports2.utcTuesdays = utcTuesdays;
        exports2.utcWednesday = utcWednesday;
        exports2.utcWednesdays = utcWednesdays;
        exports2.utcWeek = utcSunday;
        exports2.utcWeeks = utcSundays;
        exports2.utcYear = utcYear;
        exports2.utcYears = utcYears;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/d3-time-format/dist/d3-time-format.js
  var require_d3_time_format = __commonJS({
    "node_modules/d3-time-format/dist/d3-time-format.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_time()) : typeof define === "function" && false ? define(["exports", "d3-time"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
      })(exports, function(exports2, d3Time) {
        "use strict";
        function localDate(d) {
          if (0 <= d.y && d.y < 100) {
            var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
            date.setFullYear(d.y);
            return date;
          }
          return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
        }
        function utcDate(d) {
          if (0 <= d.y && d.y < 100) {
            var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
            date.setUTCFullYear(d.y);
            return date;
          }
          return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
        }
        function newDate(y, m, d) {
          return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
        }
        function formatLocale(locale2) {
          var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
          var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
          var formats = {
            "a": formatShortWeekday,
            "A": formatWeekday,
            "b": formatShortMonth,
            "B": formatMonth,
            "c": null,
            "d": formatDayOfMonth,
            "e": formatDayOfMonth,
            "f": formatMicroseconds,
            "H": formatHour24,
            "I": formatHour12,
            "j": formatDayOfYear,
            "L": formatMilliseconds,
            "m": formatMonthNumber,
            "M": formatMinutes,
            "p": formatPeriod,
            "q": formatQuarter,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatSeconds,
            "u": formatWeekdayNumberMonday,
            "U": formatWeekNumberSunday,
            "V": formatWeekNumberISO,
            "w": formatWeekdayNumberSunday,
            "W": formatWeekNumberMonday,
            "x": null,
            "X": null,
            "y": formatYear,
            "Y": formatFullYear,
            "Z": formatZone,
            "%": formatLiteralPercent
          };
          var utcFormats = {
            "a": formatUTCShortWeekday,
            "A": formatUTCWeekday,
            "b": formatUTCShortMonth,
            "B": formatUTCMonth,
            "c": null,
            "d": formatUTCDayOfMonth,
            "e": formatUTCDayOfMonth,
            "f": formatUTCMicroseconds,
            "H": formatUTCHour24,
            "I": formatUTCHour12,
            "j": formatUTCDayOfYear,
            "L": formatUTCMilliseconds,
            "m": formatUTCMonthNumber,
            "M": formatUTCMinutes,
            "p": formatUTCPeriod,
            "q": formatUTCQuarter,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatUTCSeconds,
            "u": formatUTCWeekdayNumberMonday,
            "U": formatUTCWeekNumberSunday,
            "V": formatUTCWeekNumberISO,
            "w": formatUTCWeekdayNumberSunday,
            "W": formatUTCWeekNumberMonday,
            "x": null,
            "X": null,
            "y": formatUTCYear,
            "Y": formatUTCFullYear,
            "Z": formatUTCZone,
            "%": formatLiteralPercent
          };
          var parses = {
            "a": parseShortWeekday,
            "A": parseWeekday,
            "b": parseShortMonth,
            "B": parseMonth,
            "c": parseLocaleDateTime,
            "d": parseDayOfMonth,
            "e": parseDayOfMonth,
            "f": parseMicroseconds,
            "H": parseHour24,
            "I": parseHour24,
            "j": parseDayOfYear,
            "L": parseMilliseconds,
            "m": parseMonthNumber,
            "M": parseMinutes,
            "p": parsePeriod,
            "q": parseQuarter,
            "Q": parseUnixTimestamp,
            "s": parseUnixTimestampSeconds,
            "S": parseSeconds,
            "u": parseWeekdayNumberMonday,
            "U": parseWeekNumberSunday,
            "V": parseWeekNumberISO,
            "w": parseWeekdayNumberSunday,
            "W": parseWeekNumberMonday,
            "x": parseLocaleDate,
            "X": parseLocaleTime,
            "y": parseYear,
            "Y": parseFullYear,
            "Z": parseZone,
            "%": parseLiteralPercent
          };
          formats.x = newFormat(locale_date, formats);
          formats.X = newFormat(locale_time, formats);
          formats.c = newFormat(locale_dateTime, formats);
          utcFormats.x = newFormat(locale_date, utcFormats);
          utcFormats.X = newFormat(locale_time, utcFormats);
          utcFormats.c = newFormat(locale_dateTime, utcFormats);
          function newFormat(specifier, formats2) {
            return function(date) {
              var string = [], i = -1, j = 0, n = specifier.length, c, pad2, format;
              if (!(date instanceof Date)) date = /* @__PURE__ */ new Date(+date);
              while (++i < n) {
                if (specifier.charCodeAt(i) === 37) {
                  string.push(specifier.slice(j, i));
                  if ((pad2 = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
                  else pad2 = c === "e" ? " " : "0";
                  if (format = formats2[c]) c = format(date, pad2);
                  string.push(c);
                  j = i + 1;
                }
              }
              string.push(specifier.slice(j, i));
              return string.join("");
            };
          }
          function newParse(specifier, Z) {
            return function(string) {
              var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
              if (i != string.length) return null;
              if ("Q" in d) return new Date(d.Q);
              if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
              if (Z && !("Z" in d)) d.Z = 0;
              if ("p" in d) d.H = d.H % 12 + d.p * 12;
              if (d.m === void 0) d.m = "q" in d ? d.q : 0;
              if ("V" in d) {
                if (d.V < 1 || d.V > 53) return null;
                if (!("w" in d)) d.w = 1;
                if ("Z" in d) {
                  week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
                  week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
                  week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
                  d.y = week.getUTCFullYear();
                  d.m = week.getUTCMonth();
                  d.d = week.getUTCDate() + (d.w + 6) % 7;
                } else {
                  week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
                  week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
                  week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
                  d.y = week.getFullYear();
                  d.m = week.getMonth();
                  d.d = week.getDate() + (d.w + 6) % 7;
                }
              } else if ("W" in d || "U" in d) {
                if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
                day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
                d.m = 0;
                d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
              }
              if ("Z" in d) {
                d.H += d.Z / 100 | 0;
                d.M += d.Z % 100;
                return utcDate(d);
              }
              return localDate(d);
            };
          }
          function parseSpecifier(d, specifier, string, j) {
            var i = 0, n = specifier.length, m = string.length, c, parse;
            while (i < n) {
              if (j >= m) return -1;
              c = specifier.charCodeAt(i++);
              if (c === 37) {
                c = specifier.charAt(i++);
                parse = parses[c in pads ? specifier.charAt(i++) : c];
                if (!parse || (j = parse(d, string, j)) < 0) return -1;
              } else if (c != string.charCodeAt(j++)) {
                return -1;
              }
            }
            return j;
          }
          function parsePeriod(d, string, i) {
            var n = periodRe.exec(string.slice(i));
            return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseShortWeekday(d, string, i) {
            var n = shortWeekdayRe.exec(string.slice(i));
            return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseWeekday(d, string, i) {
            var n = weekdayRe.exec(string.slice(i));
            return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseShortMonth(d, string, i) {
            var n = shortMonthRe.exec(string.slice(i));
            return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseMonth(d, string, i) {
            var n = monthRe.exec(string.slice(i));
            return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseLocaleDateTime(d, string, i) {
            return parseSpecifier(d, locale_dateTime, string, i);
          }
          function parseLocaleDate(d, string, i) {
            return parseSpecifier(d, locale_date, string, i);
          }
          function parseLocaleTime(d, string, i) {
            return parseSpecifier(d, locale_time, string, i);
          }
          function formatShortWeekday(d) {
            return locale_shortWeekdays[d.getDay()];
          }
          function formatWeekday(d) {
            return locale_weekdays[d.getDay()];
          }
          function formatShortMonth(d) {
            return locale_shortMonths[d.getMonth()];
          }
          function formatMonth(d) {
            return locale_months[d.getMonth()];
          }
          function formatPeriod(d) {
            return locale_periods[+(d.getHours() >= 12)];
          }
          function formatQuarter(d) {
            return 1 + ~~(d.getMonth() / 3);
          }
          function formatUTCShortWeekday(d) {
            return locale_shortWeekdays[d.getUTCDay()];
          }
          function formatUTCWeekday(d) {
            return locale_weekdays[d.getUTCDay()];
          }
          function formatUTCShortMonth(d) {
            return locale_shortMonths[d.getUTCMonth()];
          }
          function formatUTCMonth(d) {
            return locale_months[d.getUTCMonth()];
          }
          function formatUTCPeriod(d) {
            return locale_periods[+(d.getUTCHours() >= 12)];
          }
          function formatUTCQuarter(d) {
            return 1 + ~~(d.getUTCMonth() / 3);
          }
          return {
            format: function(specifier) {
              var f = newFormat(specifier += "", formats);
              f.toString = function() {
                return specifier;
              };
              return f;
            },
            parse: function(specifier) {
              var p = newParse(specifier += "", false);
              p.toString = function() {
                return specifier;
              };
              return p;
            },
            utcFormat: function(specifier) {
              var f = newFormat(specifier += "", utcFormats);
              f.toString = function() {
                return specifier;
              };
              return f;
            },
            utcParse: function(specifier) {
              var p = newParse(specifier += "", true);
              p.toString = function() {
                return specifier;
              };
              return p;
            }
          };
        }
        var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
        function pad(value, fill, width) {
          var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
          return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
        }
        function requote(s) {
          return s.replace(requoteRe, "\\$&");
        }
        function formatRe(names) {
          return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
        }
        function formatLookup(names) {
          var map = {}, i = -1, n = names.length;
          while (++i < n) map[names[i].toLowerCase()] = i;
          return map;
        }
        function parseWeekdayNumberSunday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.w = +n[0], i + n[0].length) : -1;
        }
        function parseWeekdayNumberMonday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.u = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberSunday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.U = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberISO(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.V = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberMonday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.W = +n[0], i + n[0].length) : -1;
        }
        function parseFullYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 4));
          return n ? (d.y = +n[0], i + n[0].length) : -1;
        }
        function parseYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
        }
        function parseZone(d, string, i) {
          var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
          return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
        }
        function parseQuarter(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
        }
        function parseMonthNumber(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
        }
        function parseDayOfMonth(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.d = +n[0], i + n[0].length) : -1;
        }
        function parseDayOfYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 3));
          return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
        }
        function parseHour24(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.H = +n[0], i + n[0].length) : -1;
        }
        function parseMinutes(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.M = +n[0], i + n[0].length) : -1;
        }
        function parseSeconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.S = +n[0], i + n[0].length) : -1;
        }
        function parseMilliseconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 3));
          return n ? (d.L = +n[0], i + n[0].length) : -1;
        }
        function parseMicroseconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 6));
          return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
        }
        function parseLiteralPercent(d, string, i) {
          var n = percentRe.exec(string.slice(i, i + 1));
          return n ? i + n[0].length : -1;
        }
        function parseUnixTimestamp(d, string, i) {
          var n = numberRe.exec(string.slice(i));
          return n ? (d.Q = +n[0], i + n[0].length) : -1;
        }
        function parseUnixTimestampSeconds(d, string, i) {
          var n = numberRe.exec(string.slice(i));
          return n ? (d.s = +n[0], i + n[0].length) : -1;
        }
        function formatDayOfMonth(d, p) {
          return pad(d.getDate(), p, 2);
        }
        function formatHour24(d, p) {
          return pad(d.getHours(), p, 2);
        }
        function formatHour12(d, p) {
          return pad(d.getHours() % 12 || 12, p, 2);
        }
        function formatDayOfYear(d, p) {
          return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
        }
        function formatMilliseconds(d, p) {
          return pad(d.getMilliseconds(), p, 3);
        }
        function formatMicroseconds(d, p) {
          return formatMilliseconds(d, p) + "000";
        }
        function formatMonthNumber(d, p) {
          return pad(d.getMonth() + 1, p, 2);
        }
        function formatMinutes(d, p) {
          return pad(d.getMinutes(), p, 2);
        }
        function formatSeconds(d, p) {
          return pad(d.getSeconds(), p, 2);
        }
        function formatWeekdayNumberMonday(d) {
          var day = d.getDay();
          return day === 0 ? 7 : day;
        }
        function formatWeekNumberSunday(d, p) {
          return pad(d3Time.timeSunday.count(d3Time.timeYear(d) - 1, d), p, 2);
        }
        function formatWeekNumberISO(d, p) {
          var day = d.getDay();
          d = day >= 4 || day === 0 ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
          return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
        }
        function formatWeekdayNumberSunday(d) {
          return d.getDay();
        }
        function formatWeekNumberMonday(d, p) {
          return pad(d3Time.timeMonday.count(d3Time.timeYear(d) - 1, d), p, 2);
        }
        function formatYear(d, p) {
          return pad(d.getFullYear() % 100, p, 2);
        }
        function formatFullYear(d, p) {
          return pad(d.getFullYear() % 1e4, p, 4);
        }
        function formatZone(d) {
          var z = d.getTimezoneOffset();
          return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
        }
        function formatUTCDayOfMonth(d, p) {
          return pad(d.getUTCDate(), p, 2);
        }
        function formatUTCHour24(d, p) {
          return pad(d.getUTCHours(), p, 2);
        }
        function formatUTCHour12(d, p) {
          return pad(d.getUTCHours() % 12 || 12, p, 2);
        }
        function formatUTCDayOfYear(d, p) {
          return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
        }
        function formatUTCMilliseconds(d, p) {
          return pad(d.getUTCMilliseconds(), p, 3);
        }
        function formatUTCMicroseconds(d, p) {
          return formatUTCMilliseconds(d, p) + "000";
        }
        function formatUTCMonthNumber(d, p) {
          return pad(d.getUTCMonth() + 1, p, 2);
        }
        function formatUTCMinutes(d, p) {
          return pad(d.getUTCMinutes(), p, 2);
        }
        function formatUTCSeconds(d, p) {
          return pad(d.getUTCSeconds(), p, 2);
        }
        function formatUTCWeekdayNumberMonday(d) {
          var dow = d.getUTCDay();
          return dow === 0 ? 7 : dow;
        }
        function formatUTCWeekNumberSunday(d, p) {
          return pad(d3Time.utcSunday.count(d3Time.utcYear(d) - 1, d), p, 2);
        }
        function formatUTCWeekNumberISO(d, p) {
          var day = d.getUTCDay();
          d = day >= 4 || day === 0 ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
          return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
        }
        function formatUTCWeekdayNumberSunday(d) {
          return d.getUTCDay();
        }
        function formatUTCWeekNumberMonday(d, p) {
          return pad(d3Time.utcMonday.count(d3Time.utcYear(d) - 1, d), p, 2);
        }
        function formatUTCYear(d, p) {
          return pad(d.getUTCFullYear() % 100, p, 2);
        }
        function formatUTCFullYear(d, p) {
          return pad(d.getUTCFullYear() % 1e4, p, 4);
        }
        function formatUTCZone() {
          return "+0000";
        }
        function formatLiteralPercent() {
          return "%";
        }
        function formatUnixTimestamp(d) {
          return +d;
        }
        function formatUnixTimestampSeconds(d) {
          return Math.floor(+d / 1e3);
        }
        var locale;
        defaultLocale({
          dateTime: "%x, %X",
          date: "%-m/%-d/%Y",
          time: "%-I:%M:%S %p",
          periods: ["AM", "PM"],
          days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        });
        function defaultLocale(definition) {
          locale = formatLocale(definition);
          exports2.timeFormat = locale.format;
          exports2.timeParse = locale.parse;
          exports2.utcFormat = locale.utcFormat;
          exports2.utcParse = locale.utcParse;
          return locale;
        }
        var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
        function formatIsoNative(date) {
          return date.toISOString();
        }
        var formatIso = Date.prototype.toISOString ? formatIsoNative : exports2.utcFormat(isoSpecifier);
        function parseIsoNative(string) {
          var date = new Date(string);
          return isNaN(date) ? null : date;
        }
        var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : exports2.utcParse(isoSpecifier);
        exports2.isoFormat = formatIso;
        exports2.isoParse = parseIso;
        exports2.timeFormatDefaultLocale = defaultLocale;
        exports2.timeFormatLocale = formatLocale;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/d3-format/dist/d3-format.js
  var require_d3_format = __commonJS({
    "node_modules/d3-format/dist/d3-format.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        function formatDecimal(x) {
          return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
        }
        function formatDecimalParts(x, p) {
          if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
          var i, coefficient = x.slice(0, i);
          return [
            coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
            +x.slice(i + 1)
          ];
        }
        function exponent(x) {
          return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
        }
        function formatGroup(grouping, thousands) {
          return function(value, width) {
            var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
            while (i > 0 && g > 0) {
              if (length + g + 1 > width) g = Math.max(1, width - length);
              t.push(value.substring(i -= g, i + g));
              if ((length += g + 1) > width) break;
              g = grouping[j = (j + 1) % grouping.length];
            }
            return t.reverse().join(thousands);
          };
        }
        function formatNumerals(numerals) {
          return function(value) {
            return value.replace(/[0-9]/g, function(i) {
              return numerals[+i];
            });
          };
        }
        var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
        function formatSpecifier(specifier) {
          if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
          var match;
          return new FormatSpecifier({
            fill: match[1],
            align: match[2],
            sign: match[3],
            symbol: match[4],
            zero: match[5],
            width: match[6],
            comma: match[7],
            precision: match[8] && match[8].slice(1),
            trim: match[9],
            type: match[10]
          });
        }
        formatSpecifier.prototype = FormatSpecifier.prototype;
        function FormatSpecifier(specifier) {
          this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
          this.align = specifier.align === void 0 ? ">" : specifier.align + "";
          this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
          this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
          this.zero = !!specifier.zero;
          this.width = specifier.width === void 0 ? void 0 : +specifier.width;
          this.comma = !!specifier.comma;
          this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
          this.trim = !!specifier.trim;
          this.type = specifier.type === void 0 ? "" : specifier.type + "";
        }
        FormatSpecifier.prototype.toString = function() {
          return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
        };
        function formatTrim(s) {
          out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
            switch (s[i]) {
              case ".":
                i0 = i1 = i;
                break;
              case "0":
                if (i0 === 0) i0 = i;
                i1 = i;
                break;
              default:
                if (!+s[i]) break out;
                if (i0 > 0) i0 = 0;
                break;
            }
          }
          return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
        }
        var prefixExponent;
        function formatPrefixAuto(x, p) {
          var d = formatDecimalParts(x, p);
          if (!d) return x + "";
          var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
          return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
        }
        function formatRounded(x, p) {
          var d = formatDecimalParts(x, p);
          if (!d) return x + "";
          var coefficient = d[0], exponent2 = d[1];
          return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
        }
        var formatTypes = {
          "%": function(x, p) {
            return (x * 100).toFixed(p);
          },
          "b": function(x) {
            return Math.round(x).toString(2);
          },
          "c": function(x) {
            return x + "";
          },
          "d": formatDecimal,
          "e": function(x, p) {
            return x.toExponential(p);
          },
          "f": function(x, p) {
            return x.toFixed(p);
          },
          "g": function(x, p) {
            return x.toPrecision(p);
          },
          "o": function(x) {
            return Math.round(x).toString(8);
          },
          "p": function(x, p) {
            return formatRounded(x * 100, p);
          },
          "r": formatRounded,
          "s": formatPrefixAuto,
          "X": function(x) {
            return Math.round(x).toString(16).toUpperCase();
          },
          "x": function(x) {
            return Math.round(x).toString(16);
          }
        };
        function identity(x) {
          return x;
        }
        var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
        function formatLocale(locale2) {
          var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "-" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
          function newFormat(specifier) {
            specifier = formatSpecifier(specifier);
            var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
            if (type === "n") comma = true, type = "g";
            else if (!formatTypes[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
            if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
            var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
            var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
            precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
            function format(value) {
              var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
              if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
              } else {
                value = +value;
                var valueNegative = value < 0 || 1 / value < 0;
                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                if (trim) value = formatTrim(value);
                if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
                valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                if (maybeSuffix) {
                  i = -1, n = value.length;
                  while (++i < n) {
                    if (c = value.charCodeAt(i), 48 > c || c > 57) {
                      valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                      value = value.slice(0, i);
                      break;
                    }
                  }
                }
              }
              if (comma && !zero) value = group(value, Infinity);
              var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
              if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
              switch (align) {
                case "<":
                  value = valuePrefix + value + valueSuffix + padding;
                  break;
                case "=":
                  value = valuePrefix + padding + value + valueSuffix;
                  break;
                case "^":
                  value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                  break;
                default:
                  value = padding + valuePrefix + value + valueSuffix;
                  break;
              }
              return numerals(value);
            }
            format.toString = function() {
              return specifier + "";
            };
            return format;
          }
          function formatPrefix(specifier, value) {
            var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
            return function(value2) {
              return f(k * value2) + prefix;
            };
          }
          return {
            format: newFormat,
            formatPrefix
          };
        }
        var locale;
        defaultLocale({
          decimal: ".",
          thousands: ",",
          grouping: [3],
          currency: ["$", ""],
          minus: "-"
        });
        function defaultLocale(definition) {
          locale = formatLocale(definition);
          exports2.format = locale.format;
          exports2.formatPrefix = locale.formatPrefix;
          return locale;
        }
        function precisionFixed(step) {
          return Math.max(0, -exponent(Math.abs(step)));
        }
        function precisionPrefix(step, value) {
          return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
        }
        function precisionRound(step, max) {
          step = Math.abs(step), max = Math.abs(max) - step;
          return Math.max(0, exponent(max) - exponent(step)) + 1;
        }
        exports2.FormatSpecifier = FormatSpecifier;
        exports2.formatDefaultLocale = defaultLocale;
        exports2.formatLocale = formatLocale;
        exports2.formatSpecifier = formatSpecifier;
        exports2.precisionFixed = precisionFixed;
        exports2.precisionPrefix = precisionPrefix;
        exports2.precisionRound = precisionRound;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/is-string-blank/index.js
  var require_is_string_blank = __commonJS({
    "node_modules/is-string-blank/index.js"(exports, module) {
      "use strict";
      module.exports = function(str) {
        var l = str.length, a;
        for (var i = 0; i < l; i++) {
          a = str.charCodeAt(i);
          if ((a < 9 || a > 13) && a !== 32 && a !== 133 && a !== 160 && a !== 5760 && a !== 6158 && (a < 8192 || a > 8205) && a !== 8232 && a !== 8233 && a !== 8239 && a !== 8287 && a !== 8288 && a !== 12288 && a !== 65279) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/fast-isnumeric/index.js
  var require_fast_isnumeric = __commonJS({
    "node_modules/fast-isnumeric/index.js"(exports, module) {
      "use strict";
      var allBlankCharCodes = require_is_string_blank();
      module.exports = function(n) {
        var type = typeof n;
        if (type === "string") {
          var original = n;
          n = +n;
          if (n === 0 && allBlankCharCodes(original)) return false;
        } else if (type !== "number") return false;
        return n - n < 1;
      };
    }
  });

  // src/constants/numerical.js
  var require_numerical = __commonJS({
    "src/constants/numerical.js"(exports, module) {
      "use strict";
      module.exports = {
        /**
         * Standardize all missing data in calcdata to use undefined
         * never null or NaN.
         * That way we can use !==undefined, or !== BADNUM,
         * to test for real data
         */
        BADNUM: void 0,
        /*
         * Limit certain operations to well below floating point max value
         * to avoid glitches: Make sure that even when you multiply it by the
         * number of pixels on a giant screen it still works
         */
        FP_SAFE: Number.MAX_VALUE * 1e-4,
        /*
         * conversion of date units to milliseconds
         * year and month constants are marked "AVG"
         * to remind us that not all years and months
         * have the same length
         */
        ONEMAXYEAR: 316224e5,
        // 366 * ONEDAY
        ONEAVGYEAR: 315576e5,
        // 365.25 days
        ONEMINYEAR: 31536e6,
        // 365 * ONEDAY
        ONEMAXQUARTER: 79488e5,
        // 92 * ONEDAY
        ONEAVGQUARTER: 78894e5,
        // 1/4 of ONEAVGYEAR
        ONEMINQUARTER: 76896e5,
        // 89 * ONEDAY
        ONEMAXMONTH: 26784e5,
        // 31 * ONEDAY
        ONEAVGMONTH: 26298e5,
        // 1/12 of ONEAVGYEAR
        ONEMINMONTH: 24192e5,
        // 28 * ONEDAY
        ONEWEEK: 6048e5,
        // 7 * ONEDAY
        ONEDAY: 864e5,
        // 24 * ONEHOUR
        ONEHOUR: 36e5,
        ONEMIN: 6e4,
        ONESEC: 1e3,
        ONEMILLI: 1,
        ONEMICROSEC: 1e-3,
        /*
         * For fast conversion btwn world calendars and epoch ms, the Julian Day Number
         * of the unix epoch. From calendars.instance().newDate(1970, 1, 1).toJD()
         */
        EPOCHJD: 24405875e-1,
        /*
         * Are two values nearly equal? Compare to 1PPM
         */
        ALMOST_EQUAL: 1 - 1e-6,
        /*
         * If we're asked to clip a non-positive log value, how far off-screen
         * do we put it?
         */
        LOG_CLIP: 10,
        /*
         * not a number, but for displaying numbers: the "minus sign" symbol is
         * wider than the regular ascii dash "-"
         */
        MINUS_SIGN: "\u2212"
      };
    }
  });

  // node_modules/base64-arraybuffer/dist/base64-arraybuffer.umd.js
  var require_base64_arraybuffer_umd = __commonJS({
    "node_modules/base64-arraybuffer/dist/base64-arraybuffer.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["base64-arraybuffer"] = {}));
      })(exports, function(exports2) {
        "use strict";
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i = 0; i < chars.length; i++) {
          lookup[chars.charCodeAt(i)] = i;
        }
        var encode = function(arraybuffer) {
          var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = "";
          for (i2 = 0; i2 < len; i2 += 3) {
            base64 += chars[bytes[i2] >> 2];
            base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
            base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
            base64 += chars[bytes[i2 + 2] & 63];
          }
          if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
          return base64;
        };
        var decode = function(base64) {
          var bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
          if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }
          var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
          for (i2 = 0; i2 < len; i2 += 4) {
            encoded1 = lookup[base64.charCodeAt(i2)];
            encoded2 = lookup[base64.charCodeAt(i2 + 1)];
            encoded3 = lookup[base64.charCodeAt(i2 + 2)];
            encoded4 = lookup[base64.charCodeAt(i2 + 3)];
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return arraybuffer;
        };
        exports2.decode = decode;
        exports2.encode = encode;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // src/lib/is_plain_object.js
  var require_is_plain_object = __commonJS({
    "src/lib/is_plain_object.js"(exports, module) {
      "use strict";
      module.exports = function isPlainObject(obj) {
        if (window && window.process && window.process.versions) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        }
        return Object.prototype.toString.call(obj) === "[object Object]" && Object.getPrototypeOf(obj).hasOwnProperty("hasOwnProperty");
      };
    }
  });

  // src/lib/array.js
  var require_array = __commonJS({
    "src/lib/array.js"(exports) {
      "use strict";
      var b64decode = require_base64_arraybuffer_umd().decode;
      var isPlainObject = require_is_plain_object();
      var isArray = Array.isArray;
      var ab = ArrayBuffer;
      var dv = DataView;
      function isTypedArray(a) {
        return ab.isView(a) && !(a instanceof dv);
      }
      exports.isTypedArray = isTypedArray;
      function isArrayOrTypedArray(a) {
        return isArray(a) || isTypedArray(a);
      }
      exports.isArrayOrTypedArray = isArrayOrTypedArray;
      function isArray1D(a) {
        return !isArrayOrTypedArray(a[0]);
      }
      exports.isArray1D = isArray1D;
      exports.ensureArray = function(out, n) {
        if (!isArray(out)) out = [];
        out.length = n;
        return out;
      };
      var typedArrays = {
        u1c: typeof Uint8ClampedArray === "undefined" ? void 0 : Uint8ClampedArray,
        // not supported in numpy?
        i1: typeof Int8Array === "undefined" ? void 0 : Int8Array,
        u1: typeof Uint8Array === "undefined" ? void 0 : Uint8Array,
        i2: typeof Int16Array === "undefined" ? void 0 : Int16Array,
        u2: typeof Uint16Array === "undefined" ? void 0 : Uint16Array,
        i4: typeof Int32Array === "undefined" ? void 0 : Int32Array,
        u4: typeof Uint32Array === "undefined" ? void 0 : Uint32Array,
        f4: typeof Float32Array === "undefined" ? void 0 : Float32Array,
        f8: typeof Float64Array === "undefined" ? void 0 : Float64Array
        /* TODO: potentially add Big Int
        
            i8: typeof BigInt64Array === 'undefined' ? undefined :
                       BigInt64Array,
        
            u8: typeof BigUint64Array === 'undefined' ? undefined :
                       BigUint64Array,
            */
      };
      typedArrays.uint8c = typedArrays.u1c;
      typedArrays.uint8 = typedArrays.u1;
      typedArrays.int8 = typedArrays.i1;
      typedArrays.uint16 = typedArrays.u2;
      typedArrays.int16 = typedArrays.i2;
      typedArrays.uint32 = typedArrays.u4;
      typedArrays.int32 = typedArrays.i4;
      typedArrays.float32 = typedArrays.f4;
      typedArrays.float64 = typedArrays.f8;
      function isArrayBuffer(a) {
        return a.constructor === ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      exports.decodeTypedArraySpec = function(vIn) {
        var out = [];
        var v = coerceTypedArraySpec(vIn);
        var dtype = v.dtype;
        var T = typedArrays[dtype];
        if (!T) throw new Error('Error in dtype: "' + dtype + '"');
        var BYTES_PER_ELEMENT = T.BYTES_PER_ELEMENT;
        var buffer = v.bdata;
        if (!isArrayBuffer(buffer)) {
          buffer = b64decode(buffer);
        }
        var shape = v.shape === void 0 ? (
          // detect 1-d length
          [buffer.byteLength / BYTES_PER_ELEMENT]
        ) : (
          // convert number to string and split to array
          ("" + v.shape).split(",")
        );
        shape.reverse();
        var ndim = shape.length;
        var nj, j;
        var ni = +shape[0];
        var rowBytes = BYTES_PER_ELEMENT * ni;
        var pos = 0;
        if (ndim === 1) {
          out = new T(buffer);
        } else if (ndim === 2) {
          nj = +shape[1];
          for (j = 0; j < nj; j++) {
            out[j] = new T(buffer, pos, ni);
            pos += rowBytes;
          }
        } else if (ndim === 3) {
          nj = +shape[1];
          var nk = +shape[2];
          for (var k = 0; k < nk; k++) {
            out[k] = [];
            for (j = 0; j < nj; j++) {
              out[k][j] = new T(buffer, pos, ni);
              pos += rowBytes;
            }
          }
        } else {
          throw new Error("ndim: " + ndim + 'is not supported with the shape:"' + v.shape + '"');
        }
        out.bdata = v.bdata;
        out.dtype = v.dtype;
        out.shape = shape.reverse().join(",");
        vIn._inputArray = out;
        return out;
      };
      exports.isTypedArraySpec = function(v) {
        return isPlainObject(v) && v.hasOwnProperty("dtype") && typeof v.dtype === "string" && v.hasOwnProperty("bdata") && (typeof v.bdata === "string" || isArrayBuffer(v.bdata)) && (v.shape === void 0 || v.hasOwnProperty("shape") && (typeof v.shape === "string" || typeof v.shape === "number"));
      };
      function coerceTypedArraySpec(v) {
        return {
          bdata: v.bdata,
          dtype: v.dtype,
          shape: v.shape
        };
      }
      exports.concat = function() {
        var args = [];
        var allArray = true;
        var totalLen = 0;
        var _constructor, arg0, i, argi, posi, leni, out, j;
        for (i = 0; i < arguments.length; i++) {
          argi = arguments[i];
          leni = argi.length;
          if (leni) {
            if (arg0) args.push(argi);
            else {
              arg0 = argi;
              posi = leni;
            }
            if (isArray(argi)) {
              _constructor = false;
            } else {
              allArray = false;
              if (!totalLen) {
                _constructor = argi.constructor;
              } else if (_constructor !== argi.constructor) {
                _constructor = false;
              }
            }
            totalLen += leni;
          }
        }
        if (!totalLen) return [];
        if (!args.length) return arg0;
        if (allArray) return arg0.concat.apply(arg0, args);
        if (_constructor) {
          out = new _constructor(totalLen);
          out.set(arg0);
          for (i = 0; i < args.length; i++) {
            argi = args[i];
            out.set(argi, posi);
            posi += argi.length;
          }
          return out;
        }
        out = new Array(totalLen);
        for (j = 0; j < arg0.length; j++) out[j] = arg0[j];
        for (i = 0; i < args.length; i++) {
          argi = args[i];
          for (j = 0; j < argi.length; j++) out[posi + j] = argi[j];
          posi += j;
        }
        return out;
      };
      exports.maxRowLength = function(z) {
        return _rowLength(z, Math.max, 0);
      };
      exports.minRowLength = function(z) {
        return _rowLength(z, Math.min, Infinity);
      };
      function _rowLength(z, fn, len0) {
        if (isArrayOrTypedArray(z)) {
          if (isArrayOrTypedArray(z[0])) {
            var len = len0;
            for (var i = 0; i < z.length; i++) {
              len = fn(len, z[i].length);
            }
            return len;
          } else {
            return z.length;
          }
        }
        return 0;
      }
    }
  });

  // src/lib/nested_property.js
  var require_nested_property = __commonJS({
    "src/lib/nested_property.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      module.exports = function nestedProperty(container, propStr) {
        if (isNumeric(propStr)) propStr = String(propStr);
        else if (typeof propStr !== "string" || propStr.substr(propStr.length - 4) === "[-1]") {
          throw "bad property string";
        }
        var propParts = propStr.split(".");
        var indexed;
        var indices;
        var i, j;
        for (j = 0; j < propParts.length; j++) {
          if (String(propParts[j]).slice(0, 2) === "__") {
            throw "bad property string";
          }
        }
        j = 0;
        while (j < propParts.length) {
          indexed = String(propParts[j]).match(/^([^\[\]]*)((\[\-?[0-9]*\])+)$/);
          if (indexed) {
            if (indexed[1]) propParts[j] = indexed[1];
            else if (j === 0) propParts.splice(0, 1);
            else throw "bad property string";
            indices = indexed[2].substr(1, indexed[2].length - 2).split("][");
            for (i = 0; i < indices.length; i++) {
              j++;
              propParts.splice(j, 0, Number(indices[i]));
            }
          }
          j++;
        }
        if (typeof container !== "object") {
          return badContainer(container, propStr, propParts);
        }
        return {
          set: npSet(container, propParts, propStr),
          get: npGet(container, propParts),
          astr: propStr,
          parts: propParts,
          obj: container
        };
      };
      function npGet(cont, parts) {
        return function(retainNull) {
          var curCont = cont;
          var curPart;
          var allSame;
          var out;
          var i;
          var j;
          for (i = 0; i < parts.length - 1; i++) {
            curPart = parts[i];
            if (curPart === -1) {
              allSame = true;
              out = [];
              for (j = 0; j < curCont.length; j++) {
                out[j] = npGet(curCont[j], parts.slice(i + 1))(retainNull);
                if (out[j] !== out[0]) allSame = false;
              }
              return allSame ? out[0] : out;
            }
            if (typeof curPart === "number" && !isArrayOrTypedArray(curCont)) {
              return void 0;
            }
            curCont = curCont[curPart];
            if (typeof curCont !== "object" || curCont === null) {
              return void 0;
            }
          }
          if (typeof curCont !== "object" || curCont === null) return void 0;
          out = curCont[parts[i]];
          if (!retainNull && out === null) return void 0;
          return out;
        };
      }
      var ARGS_PATTERN = /(^|\.)args\[/;
      function isDeletable(val, propStr) {
        return val === void 0 || val === null && !propStr.match(ARGS_PATTERN);
      }
      function npSet(cont, parts, propStr) {
        return function(val) {
          var curCont = cont;
          var propPart = "";
          var containerLevels = [[cont, propPart]];
          var toDelete = isDeletable(val, propStr);
          var curPart;
          var i;
          for (i = 0; i < parts.length - 1; i++) {
            curPart = parts[i];
            if (typeof curPart === "number" && !isArrayOrTypedArray(curCont)) {
              throw "array index but container is not an array";
            }
            if (curPart === -1) {
              toDelete = !setArrayAll(curCont, parts.slice(i + 1), val, propStr);
              if (toDelete) break;
              else return;
            }
            if (!checkNewContainer(curCont, curPart, parts[i + 1], toDelete)) {
              break;
            }
            curCont = curCont[curPart];
            if (typeof curCont !== "object" || curCont === null) {
              throw "container is not an object";
            }
            propPart = joinPropStr(propPart, curPart);
            containerLevels.push([curCont, propPart]);
          }
          if (toDelete) {
            if (i === parts.length - 1) {
              delete curCont[parts[i]];
              if (Array.isArray(curCont) && +parts[i] === curCont.length - 1) {
                while (curCont.length && curCont[curCont.length - 1] === void 0) {
                  curCont.pop();
                }
              }
            }
          } else curCont[parts[i]] = val;
        };
      }
      function joinPropStr(propStr, newPart) {
        var toAdd = newPart;
        if (isNumeric(newPart)) toAdd = "[" + newPart + "]";
        else if (propStr) toAdd = "." + newPart;
        return propStr + toAdd;
      }
      function setArrayAll(containerArray, innerParts, val, propStr) {
        var arrayVal = isArrayOrTypedArray(val);
        var allSet = true;
        var thisVal = val;
        var thisPropStr = propStr.replace("-1", 0);
        var deleteThis = arrayVal ? false : isDeletable(val, thisPropStr);
        var firstPart = innerParts[0];
        var i;
        for (i = 0; i < containerArray.length; i++) {
          thisPropStr = propStr.replace("-1", i);
          if (arrayVal) {
            thisVal = val[i % val.length];
            deleteThis = isDeletable(thisVal, thisPropStr);
          }
          if (deleteThis) allSet = false;
          if (!checkNewContainer(containerArray, i, firstPart, deleteThis)) {
            continue;
          }
          npSet(containerArray[i], innerParts, propStr.replace("-1", i))(thisVal);
        }
        return allSet;
      }
      function checkNewContainer(container, part, nextPart, toDelete) {
        if (container[part] === void 0) {
          if (toDelete) return false;
          if (typeof nextPart === "number") container[part] = [];
          else container[part] = {};
        }
        return true;
      }
      function badContainer(container, propStr, propParts) {
        return {
          set: function() {
            throw "bad container";
          },
          get: function() {
          },
          astr: propStr,
          parts: propParts,
          obj: container
        };
      }
    }
  });

  // src/lib/keyed_container.js
  var require_keyed_container = __commonJS({
    "src/lib/keyed_container.js"(exports, module) {
      "use strict";
      var nestedProperty = require_nested_property();
      var SIMPLE_PROPERTY_REGEX = /^\w*$/;
      var NONE = 0;
      var NAME = 1;
      var VALUE = 2;
      var BOTH = 3;
      var UNSET = 4;
      module.exports = function keyedContainer(baseObj, path, keyName, valueName) {
        keyName = keyName || "name";
        valueName = valueName || "value";
        var i, arr, baseProp;
        var changeTypes = {};
        if (path && path.length) {
          baseProp = nestedProperty(baseObj, path);
          arr = baseProp.get();
        } else {
          arr = baseObj;
        }
        path = path || "";
        var indexLookup = {};
        if (arr) {
          for (i = 0; i < arr.length; i++) {
            indexLookup[arr[i][keyName]] = i;
          }
        }
        var isSimpleValueProp = SIMPLE_PROPERTY_REGEX.test(valueName);
        var obj = {
          set: function(name, value) {
            var changeType = value === null ? UNSET : NONE;
            if (!arr) {
              if (!baseProp || changeType === UNSET) return;
              arr = [];
              baseProp.set(arr);
            }
            var idx = indexLookup[name];
            if (idx === void 0) {
              if (changeType === UNSET) return;
              changeType = changeType | BOTH;
              idx = arr.length;
              indexLookup[name] = idx;
            } else if (value !== (isSimpleValueProp ? arr[idx][valueName] : nestedProperty(arr[idx], valueName).get())) {
              changeType = changeType | VALUE;
            }
            var newValue = arr[idx] = arr[idx] || {};
            newValue[keyName] = name;
            if (isSimpleValueProp) {
              newValue[valueName] = value;
            } else {
              nestedProperty(newValue, valueName).set(value);
            }
            if (value !== null) {
              changeType = changeType & ~UNSET;
            }
            changeTypes[idx] = changeTypes[idx] | changeType;
            return obj;
          },
          get: function(name) {
            if (!arr) return;
            var idx = indexLookup[name];
            if (idx === void 0) {
              return void 0;
            } else if (isSimpleValueProp) {
              return arr[idx][valueName];
            } else {
              return nestedProperty(arr[idx], valueName).get();
            }
          },
          rename: function(name, newName) {
            var idx = indexLookup[name];
            if (idx === void 0) return obj;
            changeTypes[idx] = changeTypes[idx] | NAME;
            indexLookup[newName] = idx;
            delete indexLookup[name];
            arr[idx][keyName] = newName;
            return obj;
          },
          remove: function(name) {
            var idx = indexLookup[name];
            if (idx === void 0) return obj;
            var object = arr[idx];
            if (Object.keys(object).length > 2) {
              changeTypes[idx] = changeTypes[idx] | VALUE;
              return obj.set(name, null);
            }
            if (isSimpleValueProp) {
              for (i = idx; i < arr.length; i++) {
                changeTypes[i] = changeTypes[i] | BOTH;
              }
              for (i = idx; i < arr.length; i++) {
                indexLookup[arr[i][keyName]]--;
              }
              arr.splice(idx, 1);
              delete indexLookup[name];
            } else {
              nestedProperty(object, valueName).set(null);
              changeTypes[idx] = changeTypes[idx] | VALUE | UNSET;
            }
            return obj;
          },
          constructUpdate: function() {
            var astr, idx;
            var update = {};
            var changed = Object.keys(changeTypes);
            for (var i2 = 0; i2 < changed.length; i2++) {
              idx = changed[i2];
              astr = path + "[" + idx + "]";
              if (arr[idx]) {
                if (changeTypes[idx] & NAME) {
                  update[astr + "." + keyName] = arr[idx][keyName];
                }
                if (changeTypes[idx] & VALUE) {
                  if (isSimpleValueProp) {
                    update[astr + "." + valueName] = changeTypes[idx] & UNSET ? null : arr[idx][valueName];
                  } else {
                    update[astr + "." + valueName] = changeTypes[idx] & UNSET ? null : nestedProperty(arr[idx], valueName).get();
                  }
                }
              } else {
                update[astr] = null;
              }
            }
            return update;
          }
        };
        return obj;
      };
    }
  });

  // src/lib/relative_attr.js
  var require_relative_attr = __commonJS({
    "src/lib/relative_attr.js"(exports, module) {
      "use strict";
      var ASCEND = /^(.*)(\.[^\.\[\]]+|\[\d\])$/;
      var SIMPLEATTR = /^[^\.\[\]]+$/;
      module.exports = function(baseAttr, relativeAttr) {
        while (relativeAttr) {
          var match = baseAttr.match(ASCEND);
          if (match) baseAttr = match[1];
          else if (baseAttr.match(SIMPLEATTR)) baseAttr = "";
          else throw new Error("bad relativeAttr call:" + [baseAttr, relativeAttr]);
          if (relativeAttr.charAt(0) === "^") relativeAttr = relativeAttr.slice(1);
          else break;
        }
        if (baseAttr && relativeAttr.charAt(0) !== "[") {
          return baseAttr + "." + relativeAttr;
        }
        return baseAttr + relativeAttr;
      };
    }
  });

  // src/lib/to_log_range.js
  var require_to_log_range = __commonJS({
    "src/lib/to_log_range.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      module.exports = function toLogRange(val, range) {
        if (val > 0) return Math.log(val) / Math.LN10;
        var newVal = Math.log(Math.min(range[0], range[1])) / Math.LN10;
        if (!isNumeric(newVal)) newVal = Math.log(Math.max(range[0], range[1])) / Math.LN10 - 6;
        return newVal;
      };
    }
  });

  // src/lib/relink_private.js
  var require_relink_private = __commonJS({
    "src/lib/relink_private.js"(exports, module) {
      "use strict";
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      var isPlainObject = require_is_plain_object();
      module.exports = function relinkPrivateKeys(toContainer, fromContainer) {
        for (var k in fromContainer) {
          var fromVal = fromContainer[k];
          var toVal = toContainer[k];
          if (toVal === fromVal) continue;
          if (k.charAt(0) === "_" || typeof fromVal === "function") {
            if (k in toContainer) continue;
            toContainer[k] = fromVal;
          } else if (isArrayOrTypedArray(fromVal) && isArrayOrTypedArray(toVal) && isPlainObject(fromVal[0])) {
            if (k === "customdata" || k === "ids") continue;
            var minLen = Math.min(fromVal.length, toVal.length);
            for (var j = 0; j < minLen; j++) {
              if (toVal[j] !== fromVal[j] && isPlainObject(fromVal[j]) && isPlainObject(toVal[j])) {
                relinkPrivateKeys(toVal[j], fromVal[j]);
              }
            }
          } else if (isPlainObject(fromVal) && isPlainObject(toVal)) {
            relinkPrivateKeys(toVal, fromVal);
            if (!Object.keys(toVal).length) delete toContainer[k];
          }
        }
      };
    }
  });

  // src/lib/mod.js
  var require_mod = __commonJS({
    "src/lib/mod.js"(exports, module) {
      "use strict";
      function mod(v, d) {
        var out = v % d;
        return out < 0 ? out + d : out;
      }
      function modHalf(v, d) {
        return Math.abs(v) > d / 2 ? v - Math.round(v / d) * d : v;
      }
      module.exports = {
        mod,
        modHalf
      };
    }
  });

  // node_modules/tinycolor2/tinycolor.js
  var require_tinycolor = __commonJS({
    "node_modules/tinycolor2/tinycolor.js"(exports, module) {
      (function(Math2) {
        var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
        function tinycolor(color, opts) {
          color = color ? color : "";
          opts = opts || {};
          if (color instanceof tinycolor) {
            return color;
          }
          if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
          }
          var rgb = inputToRGB(color);
          this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
          this._gradientType = opts.gradientType;
          if (this._r < 1) {
            this._r = mathRound(this._r);
          }
          if (this._g < 1) {
            this._g = mathRound(this._g);
          }
          if (this._b < 1) {
            this._b = mathRound(this._b);
          }
          this._ok = rgb.ok;
          this._tc_id = tinyCounter++;
        }
        tinycolor.prototype = {
          isDark: function() {
            return this.getBrightness() < 128;
          },
          isLight: function() {
            return !this.isDark();
          },
          isValid: function() {
            return this._ok;
          },
          getOriginalInput: function() {
            return this._originalInput;
          },
          getFormat: function() {
            return this._format;
          },
          getAlpha: function() {
            return this._a;
          },
          getBrightness: function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          },
          getLuminance: function() {
            var rgb = this.toRgb();
            var RsRGB, GsRGB, BsRGB, R, G, B;
            RsRGB = rgb.r / 255;
            GsRGB = rgb.g / 255;
            BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R = RsRGB / 12.92;
            } else {
              R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G = GsRGB / 12.92;
            } else {
              G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B = BsRGB / 12.92;
            } else {
              B = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
          },
          setAlpha: function(value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(100 * this._a) / 100;
            return this;
          },
          toHsv: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
          },
          toHsvString: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
          },
          toHsl: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
          },
          toHslString: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
          },
          toHex: function(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
          },
          toHexString: function(allow3Char) {
            return "#" + this.toHex(allow3Char);
          },
          toHex8: function(allow4Char) {
            return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
          },
          toHex8String: function(allow4Char) {
            return "#" + this.toHex8(allow4Char);
          },
          toRgb: function() {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
          },
          toRgbString: function() {
            return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
          },
          toPercentageRgb: function() {
            return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
          },
          toPercentageRgbString: function() {
            return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
          },
          toName: function() {
            if (this._a === 0) {
              return "transparent";
            }
            if (this._a < 1) {
              return false;
            }
            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
          },
          toFilter: function(secondColor) {
            var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";
            if (secondColor) {
              var s = tinycolor(secondColor);
              secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
            }
            return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
          },
          toString: function(format) {
            var formatSet = !!format;
            format = format || this._format;
            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
            if (needsAlphaFormat) {
              if (format === "name" && this._a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          },
          clone: function() {
            return tinycolor(this.toString());
          },
          _applyModification: function(fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
          },
          lighten: function() {
            return this._applyModification(lighten, arguments);
          },
          brighten: function() {
            return this._applyModification(brighten, arguments);
          },
          darken: function() {
            return this._applyModification(darken, arguments);
          },
          desaturate: function() {
            return this._applyModification(desaturate, arguments);
          },
          saturate: function() {
            return this._applyModification(saturate, arguments);
          },
          greyscale: function() {
            return this._applyModification(greyscale, arguments);
          },
          spin: function() {
            return this._applyModification(spin, arguments);
          },
          _applyCombination: function(fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
          },
          analogous: function() {
            return this._applyCombination(analogous, arguments);
          },
          complement: function() {
            return this._applyCombination(complement, arguments);
          },
          monochromatic: function() {
            return this._applyCombination(monochromatic, arguments);
          },
          splitcomplement: function() {
            return this._applyCombination(splitcomplement, arguments);
          },
          triad: function() {
            return this._applyCombination(triad, arguments);
          },
          tetrad: function() {
            return this._applyCombination(tetrad, arguments);
          }
        };
        tinycolor.fromRatio = function(color, opts) {
          if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
              if (color.hasOwnProperty(i)) {
                if (i === "a") {
                  newColor[i] = color[i];
                } else {
                  newColor[i] = convertToPercentage(color[i]);
                }
              }
            }
            color = newColor;
          }
          return tinycolor(color, opts);
        };
        function inputToRGB(color) {
          var rgb = { r: 0, g: 0, b: 0 };
          var a = 1;
          var s = null;
          var v = null;
          var l = null;
          var ok = false;
          var format = false;
          if (typeof color == "string") {
            color = stringInputToObject(color);
          }
          if (typeof color == "object") {
            if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
              rgb = rgbToRgb(color.r, color.g, color.b);
              ok = true;
              format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
              s = convertToPercentage(color.s);
              v = convertToPercentage(color.v);
              rgb = hsvToRgb(color.h, s, v);
              ok = true;
              format = "hsv";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
              s = convertToPercentage(color.s);
              l = convertToPercentage(color.l);
              rgb = hslToRgb(color.h, s, l);
              ok = true;
              format = "hsl";
            }
            if (color.hasOwnProperty("a")) {
              a = color.a;
            }
          }
          a = boundAlpha(a);
          return {
            ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a
          };
        }
        function rgbToRgb(r, g, b) {
          return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
          };
        }
        function rgbToHsl(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = mathMax(r, g, b), min = mathMin(r, g, b);
          var h, s, l = (max + min) / 2;
          if (max == min) {
            h = s = 0;
          } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h, s, l };
        }
        function hslToRgb(h, s, l) {
          var r, g, b;
          h = bound01(h, 360);
          s = bound01(s, 100);
          l = bound01(l, 100);
          function hue2rgb(p2, q2, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
            if (t < 1 / 2) return q2;
            if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
            return p2;
          }
          if (s === 0) {
            r = g = b = l;
          } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return { r: r * 255, g: g * 255, b: b * 255 };
        }
        function rgbToHsv(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = mathMax(r, g, b), min = mathMin(r, g, b);
          var h, s, v = max;
          var d = max - min;
          s = max === 0 ? 0 : d / max;
          if (max == min) {
            h = 0;
          } else {
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h, s, v };
        }
        function hsvToRgb(h, s, v) {
          h = bound01(h, 360) * 6;
          s = bound01(s, 100);
          v = bound01(v, 100);
          var i = Math2.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
          return { r: r * 255, g: g * 255, b: b * 255 };
        }
        function rgbToHex(r, g, b, allow3Char) {
          var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
          ];
          if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
          }
          return hex.join("");
        }
        function rgbaToHex(r, g, b, a, allow4Char) {
          var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16)),
            pad2(convertDecimalToHex(a))
          ];
          if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
          }
          return hex.join("");
        }
        function rgbaToArgbHex(r, g, b, a) {
          var hex = [
            pad2(convertDecimalToHex(a)),
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
          ];
          return hex.join("");
        }
        tinycolor.equals = function(color1, color2) {
          if (!color1 || !color2) {
            return false;
          }
          return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
        };
        tinycolor.random = function() {
          return tinycolor.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
          });
        };
        function desaturate(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function saturate(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function greyscale(color) {
          return tinycolor(color).desaturate(100);
        }
        function lighten(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }
        function brighten(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var rgb = tinycolor(color).toRgb();
          rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
          rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
          rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
          return tinycolor(rgb);
        }
        function darken(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }
        function spin(color, amount) {
          var hsl = tinycolor(color).toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return tinycolor(hsl);
        }
        function complement(color) {
          var hsl = tinycolor(color).toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return tinycolor(hsl);
        }
        function triad(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [
            tinycolor(color),
            tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
          ];
        }
        function tetrad(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [
            tinycolor(color),
            tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
          ];
        }
        function splitcomplement(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [
            tinycolor(color),
            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        }
        function analogous(color, results, slices) {
          results = results || 6;
          slices = slices || 30;
          var hsl = tinycolor(color).toHsl();
          var part = 360 / slices;
          var ret = [tinycolor(color)];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
          }
          return ret;
        }
        function monochromatic(color, results) {
          results = results || 6;
          var hsv = tinycolor(color).toHsv();
          var h = hsv.h, s = hsv.s, v = hsv.v;
          var ret = [];
          var modification = 1 / results;
          while (results--) {
            ret.push(tinycolor({ h, s, v }));
            v = (v + modification) % 1;
          }
          return ret;
        }
        tinycolor.mix = function(color1, color2, amount) {
          amount = amount === 0 ? 0 : amount || 50;
          var rgb1 = tinycolor(color1).toRgb();
          var rgb2 = tinycolor(color2).toRgb();
          var p = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p + rgb1.r,
            g: (rgb2.g - rgb1.g) * p + rgb1.g,
            b: (rgb2.b - rgb1.b) * p + rgb1.b,
            a: (rgb2.a - rgb1.a) * p + rgb1.a
          };
          return tinycolor(rgba);
        };
        tinycolor.readability = function(color1, color2) {
          var c1 = tinycolor(color1);
          var c2 = tinycolor(color2);
          return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
        };
        tinycolor.isReadable = function(color1, color2, wcag2) {
          var readability = tinycolor.readability(color1, color2);
          var wcag2Parms, out;
          out = false;
          wcag2Parms = validateWCAG2Parms(wcag2);
          switch (wcag2Parms.level + wcag2Parms.size) {
            case "AAsmall":
            case "AAAlarge":
              out = readability >= 4.5;
              break;
            case "AAlarge":
              out = readability >= 3;
              break;
            case "AAAsmall":
              out = readability >= 7;
              break;
          }
          return out;
        };
        tinycolor.mostReadable = function(baseColor, colorList, args) {
          var bestColor = null;
          var bestScore = 0;
          var readability;
          var includeFallbackColors, level, size;
          args = args || {};
          includeFallbackColors = args.includeFallbackColors;
          level = args.level;
          size = args.size;
          for (var i = 0; i < colorList.length; i++) {
            readability = tinycolor.readability(baseColor, colorList[i]);
            if (readability > bestScore) {
              bestScore = readability;
              bestColor = tinycolor(colorList[i]);
            }
          }
          if (tinycolor.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
            return bestColor;
          } else {
            args.includeFallbackColors = false;
            return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
          }
        };
        var names = tinycolor.names = {
          aliceblue: "f0f8ff",
          antiquewhite: "faebd7",
          aqua: "0ff",
          aquamarine: "7fffd4",
          azure: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "000",
          blanchedalmond: "ffebcd",
          blue: "00f",
          blueviolet: "8a2be2",
          brown: "a52a2a",
          burlywood: "deb887",
          burntsienna: "ea7e5d",
          cadetblue: "5f9ea0",
          chartreuse: "7fff00",
          chocolate: "d2691e",
          coral: "ff7f50",
          cornflowerblue: "6495ed",
          cornsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "0ff",
          darkblue: "00008b",
          darkcyan: "008b8b",
          darkgoldenrod: "b8860b",
          darkgray: "a9a9a9",
          darkgreen: "006400",
          darkgrey: "a9a9a9",
          darkkhaki: "bdb76b",
          darkmagenta: "8b008b",
          darkolivegreen: "556b2f",
          darkorange: "ff8c00",
          darkorchid: "9932cc",
          darkred: "8b0000",
          darksalmon: "e9967a",
          darkseagreen: "8fbc8f",
          darkslateblue: "483d8b",
          darkslategray: "2f4f4f",
          darkslategrey: "2f4f4f",
          darkturquoise: "00ced1",
          darkviolet: "9400d3",
          deeppink: "ff1493",
          deepskyblue: "00bfff",
          dimgray: "696969",
          dimgrey: "696969",
          dodgerblue: "1e90ff",
          firebrick: "b22222",
          floralwhite: "fffaf0",
          forestgreen: "228b22",
          fuchsia: "f0f",
          gainsboro: "dcdcdc",
          ghostwhite: "f8f8ff",
          gold: "ffd700",
          goldenrod: "daa520",
          gray: "808080",
          green: "008000",
          greenyellow: "adff2f",
          grey: "808080",
          honeydew: "f0fff0",
          hotpink: "ff69b4",
          indianred: "cd5c5c",
          indigo: "4b0082",
          ivory: "fffff0",
          khaki: "f0e68c",
          lavender: "e6e6fa",
          lavenderblush: "fff0f5",
          lawngreen: "7cfc00",
          lemonchiffon: "fffacd",
          lightblue: "add8e6",
          lightcoral: "f08080",
          lightcyan: "e0ffff",
          lightgoldenrodyellow: "fafad2",
          lightgray: "d3d3d3",
          lightgreen: "90ee90",
          lightgrey: "d3d3d3",
          lightpink: "ffb6c1",
          lightsalmon: "ffa07a",
          lightseagreen: "20b2aa",
          lightskyblue: "87cefa",
          lightslategray: "789",
          lightslategrey: "789",
          lightsteelblue: "b0c4de",
          lightyellow: "ffffe0",
          lime: "0f0",
          limegreen: "32cd32",
          linen: "faf0e6",
          magenta: "f0f",
          maroon: "800000",
          mediumaquamarine: "66cdaa",
          mediumblue: "0000cd",
          mediumorchid: "ba55d3",
          mediumpurple: "9370db",
          mediumseagreen: "3cb371",
          mediumslateblue: "7b68ee",
          mediumspringgreen: "00fa9a",
          mediumturquoise: "48d1cc",
          mediumvioletred: "c71585",
          midnightblue: "191970",
          mintcream: "f5fffa",
          mistyrose: "ffe4e1",
          moccasin: "ffe4b5",
          navajowhite: "ffdead",
          navy: "000080",
          oldlace: "fdf5e6",
          olive: "808000",
          olivedrab: "6b8e23",
          orange: "ffa500",
          orangered: "ff4500",
          orchid: "da70d6",
          palegoldenrod: "eee8aa",
          palegreen: "98fb98",
          paleturquoise: "afeeee",
          palevioletred: "db7093",
          papayawhip: "ffefd5",
          peachpuff: "ffdab9",
          peru: "cd853f",
          pink: "ffc0cb",
          plum: "dda0dd",
          powderblue: "b0e0e6",
          purple: "800080",
          rebeccapurple: "663399",
          red: "f00",
          rosybrown: "bc8f8f",
          royalblue: "4169e1",
          saddlebrown: "8b4513",
          salmon: "fa8072",
          sandybrown: "f4a460",
          seagreen: "2e8b57",
          seashell: "fff5ee",
          sienna: "a0522d",
          silver: "c0c0c0",
          skyblue: "87ceeb",
          slateblue: "6a5acd",
          slategray: "708090",
          slategrey: "708090",
          snow: "fffafa",
          springgreen: "00ff7f",
          steelblue: "4682b4",
          tan: "d2b48c",
          teal: "008080",
          thistle: "d8bfd8",
          tomato: "ff6347",
          turquoise: "40e0d0",
          violet: "ee82ee",
          wheat: "f5deb3",
          white: "fff",
          whitesmoke: "f5f5f5",
          yellow: "ff0",
          yellowgreen: "9acd32"
        };
        var hexNames = tinycolor.hexNames = flip(names);
        function flip(o) {
          var flipped = {};
          for (var i in o) {
            if (o.hasOwnProperty(i)) {
              flipped[o[i]] = i;
            }
          }
          return flipped;
        }
        function boundAlpha(a) {
          a = parseFloat(a);
          if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
          }
          return a;
        }
        function bound01(n, max) {
          if (isOnePointZero(n)) {
            n = "100%";
          }
          var processPercent = isPercentage(n);
          n = mathMin(max, mathMax(0, parseFloat(n)));
          if (processPercent) {
            n = parseInt(n * max, 10) / 100;
          }
          if (Math2.abs(n - max) < 1e-6) {
            return 1;
          }
          return n % max / parseFloat(max);
        }
        function clamp01(val) {
          return mathMin(1, mathMax(0, val));
        }
        function parseIntFromHex(val) {
          return parseInt(val, 16);
        }
        function isOnePointZero(n) {
          return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
        }
        function isPercentage(n) {
          return typeof n === "string" && n.indexOf("%") != -1;
        }
        function pad2(c) {
          return c.length == 1 ? "0" + c : "" + c;
        }
        function convertToPercentage(n) {
          if (n <= 1) {
            n = n * 100 + "%";
          }
          return n;
        }
        function convertDecimalToHex(d) {
          return Math2.round(parseFloat(d) * 255).toString(16);
        }
        function convertHexToDecimal(h) {
          return parseIntFromHex(h) / 255;
        }
        var matchers = function() {
          var CSS_INTEGER = "[-\\+]?\\d+%?";
          var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
          var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
          var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          return {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
          };
        }();
        function isValidCSSUnit(color) {
          return !!matchers.CSS_UNIT.exec(color);
        }
        function stringInputToObject(color) {
          color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
          var named = false;
          if (names[color]) {
            color = names[color];
            named = true;
          } else if (color == "transparent") {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
          }
          var match;
          if (match = matchers.rgb.exec(color)) {
            return { r: match[1], g: match[2], b: match[3] };
          }
          if (match = matchers.rgba.exec(color)) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
          }
          if (match = matchers.hsl.exec(color)) {
            return { h: match[1], s: match[2], l: match[3] };
          }
          if (match = matchers.hsla.exec(color)) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
          }
          if (match = matchers.hsv.exec(color)) {
            return { h: match[1], s: match[2], v: match[3] };
          }
          if (match = matchers.hsva.exec(color)) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
          }
          if (match = matchers.hex8.exec(color)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              a: convertHexToDecimal(match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex6.exec(color)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              format: named ? "name" : "hex"
            };
          }
          if (match = matchers.hex4.exec(color)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              a: convertHexToDecimal(match[4] + "" + match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex3.exec(color)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              format: named ? "name" : "hex"
            };
          }
          return false;
        }
        function validateWCAG2Parms(parms) {
          var level, size;
          parms = parms || { "level": "AA", "size": "small" };
          level = (parms.level || "AA").toUpperCase();
          size = (parms.size || "small").toLowerCase();
          if (level !== "AA" && level !== "AAA") {
            level = "AA";
          }
          if (size !== "small" && size !== "large") {
            size = "small";
          }
          return { "level": level, "size": size };
        }
        if (typeof module !== "undefined" && module.exports) {
          module.exports = tinycolor;
        } else if (typeof define === "function" && false) {
          define(function() {
            return tinycolor;
          });
        } else {
          window.tinycolor = tinycolor;
        }
      })(Math);
    }
  });

  // src/lib/extend.js
  var require_extend = __commonJS({
    "src/lib/extend.js"(exports) {
      "use strict";
      var isPlainObject = require_is_plain_object();
      var isArray = Array.isArray;
      function primitivesLoopSplice(source, target) {
        var i, value;
        for (i = 0; i < source.length; i++) {
          value = source[i];
          if (value !== null && typeof value === "object") {
            return false;
          }
          if (value !== void 0) {
            target[i] = value;
          }
        }
        return true;
      }
      exports.extendFlat = function() {
        return _extend(arguments, false, false, false);
      };
      exports.extendDeep = function() {
        return _extend(arguments, true, false, false);
      };
      exports.extendDeepAll = function() {
        return _extend(arguments, true, true, false);
      };
      exports.extendDeepNoArrays = function() {
        return _extend(arguments, true, false, true);
      };
      function _extend(inputs, isDeep, keepAllKeys, noArrayCopies) {
        var target = inputs[0];
        var length = inputs.length;
        var input, key, src, copy, copyIsArray, clone, allPrimitives;
        if (length === 2 && isArray(target) && isArray(inputs[1]) && target.length === 0) {
          allPrimitives = primitivesLoopSplice(inputs[1], target);
          if (allPrimitives) {
            return target;
          } else {
            target.splice(0, target.length);
          }
        }
        for (var i = 1; i < length; i++) {
          input = inputs[i];
          for (key in input) {
            src = target[key];
            copy = input[key];
            if (noArrayCopies && isArray(copy)) {
              target[key] = copy;
            } else if (isDeep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }
              target[key] = _extend([clone, copy], isDeep, keepAllKeys, noArrayCopies);
            } else if (typeof copy !== "undefined" || keepAllKeys) {
              target[key] = copy;
            }
          }
        }
        return target;
      }
    }
  });

  // src/plots/font_attributes.js
  var require_font_attributes = __commonJS({
    "src/plots/font_attributes.js"(exports, module) {
      "use strict";
      module.exports = function(opts) {
        var variantValues = opts.variantValues;
        var editType = opts.editType;
        var colorEditType = opts.colorEditType;
        if (colorEditType === void 0) colorEditType = editType;
        var weight = {
          editType,
          valType: "integer",
          min: 1,
          max: 1e3,
          extras: ["normal", "bold"],
          dflt: "normal"
        };
        if (opts.noNumericWeightValues) {
          weight.valType = "enumerated";
          weight.values = weight.extras;
          weight.extras = void 0;
          weight.min = void 0;
          weight.max = void 0;
        }
        var attrs = {
          family: {
            valType: "string",
            noBlank: true,
            strict: true,
            editType
          },
          size: {
            valType: "number",
            min: 1,
            editType
          },
          color: {
            valType: "color",
            editType: colorEditType
          },
          weight,
          style: {
            editType,
            valType: "enumerated",
            values: ["normal", "italic"],
            dflt: "normal"
          },
          variant: opts.noFontVariant ? void 0 : {
            editType,
            valType: "enumerated",
            values: variantValues || [
              "normal",
              "small-caps",
              "all-small-caps",
              "all-petite-caps",
              "petite-caps",
              "unicase"
            ],
            dflt: "normal"
          },
          textcase: opts.noFontTextcase ? void 0 : {
            editType,
            valType: "enumerated",
            values: ["normal", "word caps", "upper", "lower"],
            dflt: "normal"
          },
          lineposition: opts.noFontLineposition ? void 0 : {
            editType,
            valType: "flaglist",
            flags: ["under", "over", "through"],
            extras: ["none"],
            dflt: "none"
          },
          shadow: opts.noFontShadow ? void 0 : {
            editType,
            valType: "string",
            dflt: opts.autoShadowDflt ? "auto" : "none"
          },
          editType
          // blank strings so compress_attributes can remove
          // TODO - that's uber hacky... better solution?
        };
        if (opts.autoSize) attrs.size.dflt = "auto";
        if (opts.autoColor) attrs.color.dflt = "auto";
        if (opts.arrayOk) {
          attrs.family.arrayOk = true;
          attrs.weight.arrayOk = true;
          attrs.style.arrayOk = true;
          if (!opts.noFontVariant) {
            attrs.variant.arrayOk = true;
          }
          if (!opts.noFontTextcase) {
            attrs.textcase.arrayOk = true;
          }
          if (!opts.noFontLineposition) {
            attrs.lineposition.arrayOk = true;
          }
          if (!opts.noFontShadow) {
            attrs.shadow.arrayOk = true;
          }
          attrs.size.arrayOk = true;
          attrs.color.arrayOk = true;
        }
        return attrs;
      };
    }
  });

  // src/components/fx/constants.js
  var require_constants = __commonJS({
    "src/components/fx/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // hover labels for multiple horizontal bars get tilted by this angle
        YANGLE: 60,
        // size and display constants for hover text
        // pixel size of hover arrows
        HOVERARROWSIZE: 6,
        // pixels padding around text
        HOVERTEXTPAD: 3,
        // hover font
        HOVERFONTSIZE: 13,
        HOVERFONT: "Arial, sans-serif",
        // minimum time (msec) between hover calls
        HOVERMINTIME: 50,
        // ID suffix (with fullLayout._uid) for hover events in the throttle cache
        HOVERID: "-hover"
      };
    }
  });

  // src/components/fx/layout_attributes.js
  var require_layout_attributes = __commonJS({
    "src/components/fx/layout_attributes.js"(exports, module) {
      "use strict";
      var constants = require_constants();
      var fontAttrs = require_font_attributes();
      var font = fontAttrs({
        editType: "none"
      });
      font.family.dflt = constants.HOVERFONT;
      font.size.dflt = constants.HOVERFONTSIZE;
      module.exports = {
        clickmode: {
          valType: "flaglist",
          flags: ["event", "select"],
          dflt: "event",
          editType: "plot",
          extras: ["none"]
        },
        dragmode: {
          valType: "enumerated",
          values: [
            "zoom",
            "pan",
            "select",
            "lasso",
            "drawclosedpath",
            "drawopenpath",
            "drawline",
            "drawrect",
            "drawcircle",
            "orbit",
            "turntable",
            false
          ],
          dflt: "zoom",
          editType: "modebar"
        },
        hovermode: {
          valType: "enumerated",
          values: ["x", "y", "closest", false, "x unified", "y unified"],
          dflt: "closest",
          editType: "modebar"
        },
        hoversubplots: {
          valType: "enumerated",
          values: ["single", "overlaying", "axis"],
          dflt: "overlaying",
          editType: "none"
        },
        hoverdistance: {
          valType: "integer",
          min: -1,
          dflt: 20,
          editType: "none"
        },
        spikedistance: {
          valType: "integer",
          min: -1,
          dflt: -1,
          editType: "none"
        },
        hoverlabel: {
          bgcolor: {
            valType: "color",
            editType: "none"
          },
          bordercolor: {
            valType: "color",
            editType: "none"
          },
          font,
          grouptitlefont: fontAttrs({
            editType: "none"
          }),
          align: {
            valType: "enumerated",
            values: ["left", "right", "auto"],
            dflt: "auto",
            editType: "none"
          },
          namelength: {
            valType: "integer",
            min: -1,
            dflt: 15,
            editType: "none"
          },
          editType: "none"
        },
        selectdirection: {
          valType: "enumerated",
          values: ["h", "v", "d", "any"],
          dflt: "any",
          editType: "none"
        }
      };
    }
  });

  // src/components/fx/attributes.js
  var require_attributes = __commonJS({
    "src/components/fx/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var hoverLabelAttrs = require_layout_attributes().hoverlabel;
      var extendFlat = require_extend().extendFlat;
      module.exports = {
        hoverlabel: {
          bgcolor: extendFlat({}, hoverLabelAttrs.bgcolor, {
            arrayOk: true
          }),
          bordercolor: extendFlat({}, hoverLabelAttrs.bordercolor, {
            arrayOk: true
          }),
          font: fontAttrs({
            arrayOk: true,
            editType: "none"
          }),
          align: extendFlat({}, hoverLabelAttrs.align, { arrayOk: true }),
          namelength: extendFlat({}, hoverLabelAttrs.namelength, { arrayOk: true }),
          editType: "none"
        }
      };
    }
  });

  // src/plots/attributes.js
  var require_attributes2 = __commonJS({
    "src/plots/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var fxAttrs = require_attributes();
      module.exports = {
        type: {
          valType: "enumerated",
          values: [],
          // listed dynamically
          dflt: "scatter",
          editType: "calc+clearAxisTypes",
          _noTemplating: true
          // we handle this at a higher level
        },
        visible: {
          valType: "enumerated",
          values: [true, false, "legendonly"],
          dflt: true,
          editType: "calc"
        },
        showlegend: {
          valType: "boolean",
          dflt: true,
          editType: "style"
        },
        legend: {
          valType: "subplotid",
          dflt: "legend",
          editType: "style"
        },
        legendgroup: {
          valType: "string",
          dflt: "",
          editType: "style"
        },
        legendgrouptitle: {
          text: {
            valType: "string",
            dflt: "",
            editType: "style"
          },
          font: fontAttrs({
            editType: "style"
          }),
          editType: "style"
        },
        legendrank: {
          valType: "number",
          dflt: 1e3,
          editType: "style"
        },
        legendwidth: {
          valType: "number",
          min: 0,
          editType: "style"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "style"
        },
        name: {
          valType: "string",
          editType: "style"
        },
        uid: {
          valType: "string",
          editType: "plot",
          anim: true
        },
        ids: {
          valType: "data_array",
          editType: "calc",
          anim: true
        },
        customdata: {
          valType: "data_array",
          editType: "calc"
        },
        meta: {
          valType: "any",
          arrayOk: true,
          editType: "plot"
        },
        // N.B. these cannot be 'data_array' as they do not have the same length as
        // other data arrays and arrayOk attributes in general
        //
        // Maybe add another valType:
        // https://github.com/plotly/plotly.js/issues/1894
        selectedpoints: {
          valType: "any",
          editType: "calc"
        },
        hoverinfo: {
          valType: "flaglist",
          flags: ["x", "y", "z", "text", "name"],
          extras: ["all", "none", "skip"],
          arrayOk: true,
          dflt: "all",
          editType: "none"
        },
        hoverlabel: fxAttrs.hoverlabel,
        stream: {
          token: {
            valType: "string",
            noBlank: true,
            strict: true,
            editType: "calc"
          },
          maxpoints: {
            valType: "number",
            min: 0,
            max: 1e4,
            dflt: 500,
            editType: "calc"
          },
          editType: "calc"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        }
      };
    }
  });

  // src/components/colorscale/scales.js
  var require_scales = __commonJS({
    "src/components/colorscale/scales.js"(exports, module) {
      "use strict";
      var tinycolor = require_tinycolor();
      var scales = {
        Greys: [
          [0, "rgb(0,0,0)"],
          [1, "rgb(255,255,255)"]
        ],
        YlGnBu: [
          [0, "rgb(8,29,88)"],
          [0.125, "rgb(37,52,148)"],
          [0.25, "rgb(34,94,168)"],
          [0.375, "rgb(29,145,192)"],
          [0.5, "rgb(65,182,196)"],
          [0.625, "rgb(127,205,187)"],
          [0.75, "rgb(199,233,180)"],
          [0.875, "rgb(237,248,217)"],
          [1, "rgb(255,255,217)"]
        ],
        Greens: [
          [0, "rgb(0,68,27)"],
          [0.125, "rgb(0,109,44)"],
          [0.25, "rgb(35,139,69)"],
          [0.375, "rgb(65,171,93)"],
          [0.5, "rgb(116,196,118)"],
          [0.625, "rgb(161,217,155)"],
          [0.75, "rgb(199,233,192)"],
          [0.875, "rgb(229,245,224)"],
          [1, "rgb(247,252,245)"]
        ],
        YlOrRd: [
          [0, "rgb(128,0,38)"],
          [0.125, "rgb(189,0,38)"],
          [0.25, "rgb(227,26,28)"],
          [0.375, "rgb(252,78,42)"],
          [0.5, "rgb(253,141,60)"],
          [0.625, "rgb(254,178,76)"],
          [0.75, "rgb(254,217,118)"],
          [0.875, "rgb(255,237,160)"],
          [1, "rgb(255,255,204)"]
        ],
        Bluered: [
          [0, "rgb(0,0,255)"],
          [1, "rgb(255,0,0)"]
        ],
        // modified RdBu based on
        // http://www.kennethmoreland.com/color-maps/
        RdBu: [
          [0, "rgb(5,10,172)"],
          [0.35, "rgb(106,137,247)"],
          [0.5, "rgb(190,190,190)"],
          [0.6, "rgb(220,170,132)"],
          [0.7, "rgb(230,145,90)"],
          [1, "rgb(178,10,28)"]
        ],
        // Scale for non-negative numeric values
        Reds: [
          [0, "rgb(220,220,220)"],
          [0.2, "rgb(245,195,157)"],
          [0.4, "rgb(245,160,105)"],
          [1, "rgb(178,10,28)"]
        ],
        // Scale for non-positive numeric values
        Blues: [
          [0, "rgb(5,10,172)"],
          [0.35, "rgb(40,60,190)"],
          [0.5, "rgb(70,100,245)"],
          [0.6, "rgb(90,120,245)"],
          [0.7, "rgb(106,137,247)"],
          [1, "rgb(220,220,220)"]
        ],
        Picnic: [
          [0, "rgb(0,0,255)"],
          [0.1, "rgb(51,153,255)"],
          [0.2, "rgb(102,204,255)"],
          [0.3, "rgb(153,204,255)"],
          [0.4, "rgb(204,204,255)"],
          [0.5, "rgb(255,255,255)"],
          [0.6, "rgb(255,204,255)"],
          [0.7, "rgb(255,153,255)"],
          [0.8, "rgb(255,102,204)"],
          [0.9, "rgb(255,102,102)"],
          [1, "rgb(255,0,0)"]
        ],
        Rainbow: [
          [0, "rgb(150,0,90)"],
          [0.125, "rgb(0,0,200)"],
          [0.25, "rgb(0,25,255)"],
          [0.375, "rgb(0,152,255)"],
          [0.5, "rgb(44,255,150)"],
          [0.625, "rgb(151,255,0)"],
          [0.75, "rgb(255,234,0)"],
          [0.875, "rgb(255,111,0)"],
          [1, "rgb(255,0,0)"]
        ],
        Portland: [
          [0, "rgb(12,51,131)"],
          [0.25, "rgb(10,136,186)"],
          [0.5, "rgb(242,211,56)"],
          [0.75, "rgb(242,143,56)"],
          [1, "rgb(217,30,30)"]
        ],
        Jet: [
          [0, "rgb(0,0,131)"],
          [0.125, "rgb(0,60,170)"],
          [0.375, "rgb(5,255,255)"],
          [0.625, "rgb(255,255,0)"],
          [0.875, "rgb(250,0,0)"],
          [1, "rgb(128,0,0)"]
        ],
        Hot: [
          [0, "rgb(0,0,0)"],
          [0.3, "rgb(230,0,0)"],
          [0.6, "rgb(255,210,0)"],
          [1, "rgb(255,255,255)"]
        ],
        Blackbody: [
          [0, "rgb(0,0,0)"],
          [0.2, "rgb(230,0,0)"],
          [0.4, "rgb(230,210,0)"],
          [0.7, "rgb(255,255,255)"],
          [1, "rgb(160,200,255)"]
        ],
        Earth: [
          [0, "rgb(0,0,130)"],
          [0.1, "rgb(0,180,180)"],
          [0.2, "rgb(40,210,40)"],
          [0.4, "rgb(230,230,50)"],
          [0.6, "rgb(120,70,20)"],
          [1, "rgb(255,255,255)"]
        ],
        Electric: [
          [0, "rgb(0,0,0)"],
          [0.15, "rgb(30,0,100)"],
          [0.4, "rgb(120,0,100)"],
          [0.6, "rgb(160,90,0)"],
          [0.8, "rgb(230,200,0)"],
          [1, "rgb(255,250,220)"]
        ],
        Viridis: [
          [0, "#440154"],
          [0.06274509803921569, "#48186a"],
          [0.12549019607843137, "#472d7b"],
          [0.18823529411764706, "#424086"],
          [0.25098039215686274, "#3b528b"],
          [0.3137254901960784, "#33638d"],
          [0.3764705882352941, "#2c728e"],
          [0.4392156862745098, "#26828e"],
          [0.5019607843137255, "#21918c"],
          [0.5647058823529412, "#1fa088"],
          [0.6274509803921569, "#28ae80"],
          [0.6901960784313725, "#3fbc73"],
          [0.7529411764705882, "#5ec962"],
          [0.8156862745098039, "#84d44b"],
          [0.8784313725490196, "#addc30"],
          [0.9411764705882353, "#d8e219"],
          [1, "#fde725"]
        ],
        Cividis: [
          [0, "rgb(0,32,76)"],
          [0.058824, "rgb(0,42,102)"],
          [0.117647, "rgb(0,52,110)"],
          [0.176471, "rgb(39,63,108)"],
          [0.235294, "rgb(60,74,107)"],
          [0.294118, "rgb(76,85,107)"],
          [0.352941, "rgb(91,95,109)"],
          [0.411765, "rgb(104,106,112)"],
          [0.470588, "rgb(117,117,117)"],
          [0.529412, "rgb(131,129,120)"],
          [0.588235, "rgb(146,140,120)"],
          [0.647059, "rgb(161,152,118)"],
          [0.705882, "rgb(176,165,114)"],
          [0.764706, "rgb(192,177,109)"],
          [0.823529, "rgb(209,191,102)"],
          [0.882353, "rgb(225,204,92)"],
          [0.941176, "rgb(243,219,79)"],
          [1, "rgb(255,233,69)"]
        ]
      };
      var defaultScale = scales.RdBu;
      function getScale(scl, dflt) {
        if (!dflt) dflt = defaultScale;
        if (!scl) return dflt;
        function parseScale() {
          try {
            scl = scales[scl] || JSON.parse(scl);
          } catch (e) {
            scl = dflt;
          }
        }
        if (typeof scl === "string") {
          parseScale();
          if (typeof scl === "string") parseScale();
        }
        if (!isValidScaleArray(scl)) return dflt;
        return scl;
      }
      function isValidScaleArray(scl) {
        var highestVal = 0;
        if (!Array.isArray(scl) || scl.length < 2) return false;
        if (!scl[0] || !scl[scl.length - 1]) return false;
        if (+scl[0][0] !== 0 || +scl[scl.length - 1][0] !== 1) return false;
        for (var i = 0; i < scl.length; i++) {
          var si = scl[i];
          if (si.length !== 2 || +si[0] < highestVal || !tinycolor(si[1]).isValid()) {
            return false;
          }
          highestVal = +si[0];
        }
        return true;
      }
      function isValidScale(scl) {
        if (scales[scl] !== void 0) return true;
        else return isValidScaleArray(scl);
      }
      module.exports = {
        scales,
        defaultScale,
        get: getScale,
        isValid: isValidScale
      };
    }
  });

  // src/components/color/attributes.js
  var require_attributes3 = __commonJS({
    "src/components/color/attributes.js"(exports) {
      "use strict";
      exports.defaults = [
        "#1f77b4",
        // muted blue
        "#ff7f0e",
        // safety orange
        "#2ca02c",
        // cooked asparagus green
        "#d62728",
        // brick red
        "#9467bd",
        // muted purple
        "#8c564b",
        // chestnut brown
        "#e377c2",
        // raspberry yogurt pink
        "#7f7f7f",
        // middle gray
        "#bcbd22",
        // curry yellow-green
        "#17becf"
        // blue-teal
      ];
      exports.defaultLine = "#444";
      exports.lightLine = "#eee";
      exports.background = "#fff";
      exports.borderLine = "#BEC8D9";
      exports.lightFraction = 100 * (14 - 4) / (15 - 4);
    }
  });

  // src/components/color/index.js
  var require_color = __commonJS({
    "src/components/color/index.js"(exports, module) {
      "use strict";
      var tinycolor = require_tinycolor();
      var isNumeric = require_fast_isnumeric();
      var isTypedArray = require_array().isTypedArray;
      var color = module.exports = {};
      var colorAttrs = require_attributes3();
      color.defaults = colorAttrs.defaults;
      var defaultLine = color.defaultLine = colorAttrs.defaultLine;
      color.lightLine = colorAttrs.lightLine;
      var background = color.background = colorAttrs.background;
      color.tinyRGB = function(tc) {
        var c = tc.toRgb();
        return "rgb(" + Math.round(c.r) + ", " + Math.round(c.g) + ", " + Math.round(c.b) + ")";
      };
      color.rgb = function(cstr) {
        return color.tinyRGB(tinycolor(cstr));
      };
      color.opacity = function(cstr) {
        return cstr ? tinycolor(cstr).getAlpha() : 0;
      };
      color.addOpacity = function(cstr, op) {
        var c = tinycolor(cstr).toRgb();
        return "rgba(" + Math.round(c.r) + ", " + Math.round(c.g) + ", " + Math.round(c.b) + ", " + op + ")";
      };
      color.combine = function(front, back) {
        var fc = tinycolor(front).toRgb();
        if (fc.a === 1) return tinycolor(front).toRgbString();
        var bc = tinycolor(back || background).toRgb();
        var bcflat = bc.a === 1 ? bc : {
          r: 255 * (1 - bc.a) + bc.r * bc.a,
          g: 255 * (1 - bc.a) + bc.g * bc.a,
          b: 255 * (1 - bc.a) + bc.b * bc.a
        };
        var fcflat = {
          r: bcflat.r * (1 - fc.a) + fc.r * fc.a,
          g: bcflat.g * (1 - fc.a) + fc.g * fc.a,
          b: bcflat.b * (1 - fc.a) + fc.b * fc.a
        };
        return tinycolor(fcflat).toRgbString();
      };
      color.interpolate = function(first, second, factor) {
        var fc = tinycolor(first).toRgb();
        var sc = tinycolor(second).toRgb();
        var ic = {
          r: factor * fc.r + (1 - factor) * sc.r,
          g: factor * fc.g + (1 - factor) * sc.g,
          b: factor * fc.b + (1 - factor) * sc.b
        };
        return tinycolor(ic).toRgbString();
      };
      color.contrast = function(cstr, lightAmount, darkAmount) {
        var tc = tinycolor(cstr);
        if (tc.getAlpha() !== 1) tc = tinycolor(color.combine(cstr, background));
        var newColor = tc.isDark() ? lightAmount ? tc.lighten(lightAmount) : background : darkAmount ? tc.darken(darkAmount) : defaultLine;
        return newColor.toString();
      };
      color.stroke = function(s, c) {
        var tc = tinycolor(c);
        s.style({ stroke: color.tinyRGB(tc), "stroke-opacity": tc.getAlpha() });
      };
      color.fill = function(s, c) {
        var tc = tinycolor(c);
        s.style({
          fill: color.tinyRGB(tc),
          "fill-opacity": tc.getAlpha()
        });
      };
      color.clean = function(container) {
        if (!container || typeof container !== "object") return;
        var keys = Object.keys(container);
        var i, j, key, val;
        for (i = 0; i < keys.length; i++) {
          key = keys[i];
          val = container[key];
          if (key.substr(key.length - 5) === "color") {
            if (Array.isArray(val)) {
              for (j = 0; j < val.length; j++) val[j] = cleanOne(val[j]);
            } else container[key] = cleanOne(val);
          } else if (key.substr(key.length - 10) === "colorscale" && Array.isArray(val)) {
            for (j = 0; j < val.length; j++) {
              if (Array.isArray(val[j])) val[j][1] = cleanOne(val[j][1]);
            }
          } else if (Array.isArray(val)) {
            var el0 = val[0];
            if (!Array.isArray(el0) && el0 && typeof el0 === "object") {
              for (j = 0; j < val.length; j++) color.clean(val[j]);
            }
          } else if (val && typeof val === "object" && !isTypedArray(val)) color.clean(val);
        }
      };
      function cleanOne(val) {
        if (isNumeric(val) || typeof val !== "string") return val;
        var valTrim = val.trim();
        if (valTrim.substr(0, 3) !== "rgb") return val;
        var match = valTrim.match(/^rgba?\s*\(([^()]*)\)$/);
        if (!match) return val;
        var parts = match[1].trim().split(/\s*[\s,]\s*/);
        var rgba = valTrim.charAt(3) === "a" && parts.length === 4;
        if (!rgba && parts.length !== 3) return val;
        for (var i = 0; i < parts.length; i++) {
          if (!parts[i].length) return val;
          parts[i] = Number(parts[i]);
          if (!(parts[i] >= 0)) {
            return val;
          }
          if (i === 3) {
            if (parts[i] > 1) parts[i] = 1;
          } else if (parts[i] >= 1) {
            return val;
          }
        }
        var rgbStr = Math.round(parts[0] * 255) + ", " + Math.round(parts[1] * 255) + ", " + Math.round(parts[2] * 255);
        if (rgba) return "rgba(" + rgbStr + ", " + parts[3] + ")";
        return "rgb(" + rgbStr + ")";
      }
    }
  });

  // src/constants/interactions.js
  var require_interactions = __commonJS({
    "src/constants/interactions.js"(exports, module) {
      "use strict";
      module.exports = {
        /**
         * Timing information for interactive elements
         */
        SHOW_PLACEHOLDER: 100,
        HIDE_PLACEHOLDER: 1e3,
        // opacity dimming fraction for points that are not in selection
        DESELECTDIM: 0.2
      };
    }
  });

  // src/lib/regex.js
  var require_regex = __commonJS({
    "src/lib/regex.js"(exports) {
      "use strict";
      exports.counter = function(head, tail, openEnded, matchBeginning) {
        var fullTail = (tail || "") + (openEnded ? "" : "$");
        var startWithPrefix = matchBeginning === false ? "" : "^";
        if (head === "xy") {
          return new RegExp(startWithPrefix + "x([2-9]|[1-9][0-9]+)?y([2-9]|[1-9][0-9]+)?" + fullTail);
        }
        return new RegExp(startWithPrefix + head + "([2-9]|[1-9][0-9]+)?" + fullTail);
      };
    }
  });

  // src/lib/coerce.js
  var require_coerce = __commonJS({
    "src/lib/coerce.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var extendFlat = require_extend().extendFlat;
      var baseTraceAttrs = require_attributes2();
      var colorscales = require_scales();
      var Color = require_color();
      var DESELECTDIM = require_interactions().DESELECTDIM;
      var nestedProperty = require_nested_property();
      var counterRegex = require_regex().counter;
      var modHalf = require_mod().modHalf;
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      var isTypedArraySpec = require_array().isTypedArraySpec;
      var decodeTypedArraySpec = require_array().decodeTypedArraySpec;
      exports.valObjectMeta = {
        data_array: {
          // You can use *dflt=[] to force said array to exist though.
          coerceFunction: function(v, propOut, dflt) {
            propOut.set(
              isArrayOrTypedArray(v) ? v : isTypedArraySpec(v) ? decodeTypedArraySpec(v) : dflt
            );
          }
        },
        enumerated: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if (opts.coerceNumber) v = +v;
            if (opts.values.indexOf(v) === -1) propOut.set(dflt);
            else propOut.set(v);
          },
          validateFunction: function(v, opts) {
            if (opts.coerceNumber) v = +v;
            var values = opts.values;
            for (var i = 0; i < values.length; i++) {
              var k = String(values[i]);
              if (k.charAt(0) === "/" && k.charAt(k.length - 1) === "/") {
                var regex = new RegExp(k.substr(1, k.length - 2));
                if (regex.test(v)) return true;
              } else if (v === values[i]) return true;
            }
            return false;
          }
        },
        boolean: {
          coerceFunction: function(v, propOut, dflt) {
            if (v === true || v === false) propOut.set(v);
            else propOut.set(dflt);
          }
        },
        number: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (!isNumeric(v) || opts.min !== void 0 && v < opts.min || opts.max !== void 0 && v > opts.max) {
              propOut.set(dflt);
            } else propOut.set(+v);
          }
        },
        integer: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if ((opts.extras || []).indexOf(v) !== -1) {
              propOut.set(v);
              return;
            }
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (v % 1 || !isNumeric(v) || opts.min !== void 0 && v < opts.min || opts.max !== void 0 && v > opts.max) {
              propOut.set(dflt);
            } else propOut.set(+v);
          }
        },
        string: {
          // TODO 'values shouldn't be in there (edge case: 'dash' in Scatter)
          coerceFunction: function(v, propOut, dflt, opts) {
            if (typeof v !== "string") {
              var okToCoerce = typeof v === "number";
              if (opts.strict === true || !okToCoerce) propOut.set(dflt);
              else propOut.set(String(v));
            } else if (opts.noBlank && !v) propOut.set(dflt);
            else propOut.set(v);
          }
        },
        color: {
          coerceFunction: function(v, propOut, dflt) {
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (tinycolor(v).isValid()) propOut.set(v);
            else propOut.set(dflt);
          }
        },
        colorlist: {
          coerceFunction: function(v, propOut, dflt) {
            function isColor(color) {
              return tinycolor(color).isValid();
            }
            if (!Array.isArray(v) || !v.length) propOut.set(dflt);
            else if (v.every(isColor)) propOut.set(v);
            else propOut.set(dflt);
          }
        },
        colorscale: {
          coerceFunction: function(v, propOut, dflt) {
            propOut.set(colorscales.get(v, dflt));
          }
        },
        angle: {
          coerceFunction: function(v, propOut, dflt) {
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (v === "auto") propOut.set("auto");
            else if (!isNumeric(v)) propOut.set(dflt);
            else propOut.set(modHalf(+v, 360));
          }
        },
        subplotid: {
          coerceFunction: function(v, propOut, dflt, opts) {
            var regex = opts.regex || counterRegex(dflt);
            if (typeof v === "string" && regex.test(v)) {
              propOut.set(v);
              return;
            }
            propOut.set(dflt);
          },
          validateFunction: function(v, opts) {
            var dflt = opts.dflt;
            if (v === dflt) return true;
            if (typeof v !== "string") return false;
            if (counterRegex(dflt).test(v)) return true;
            return false;
          }
        },
        flaglist: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if ((opts.extras || []).indexOf(v) !== -1) {
              propOut.set(v);
              return;
            }
            if (typeof v !== "string") {
              propOut.set(dflt);
              return;
            }
            var vParts = v.split("+");
            var i = 0;
            while (i < vParts.length) {
              var vi = vParts[i];
              if (opts.flags.indexOf(vi) === -1 || vParts.indexOf(vi) < i) {
                vParts.splice(i, 1);
              } else i++;
            }
            if (!vParts.length) propOut.set(dflt);
            else propOut.set(vParts.join("+"));
          }
        },
        any: {
          coerceFunction: function(v, propOut, dflt) {
            if (v === void 0) {
              propOut.set(dflt);
            } else {
              propOut.set(
                isTypedArraySpec(v) ? decodeTypedArraySpec(v) : v
              );
            }
          }
        },
        info_array: {
          // set `dimensions=2` for a 2D array or '1-2' for either
          // `items` may be a single object instead of an array, in which case
          // `freeLength` must be true.
          // if `dimensions='1-2'` and items is a 1D array, then the value can
          // either be a matching 1D array or an array of such matching 1D arrays
          coerceFunction: function(v, propOut, dflt, opts) {
            function coercePart(v2, opts2, dflt2) {
              var out;
              var propPart = { set: function(v3) {
                out = v3;
              } };
              if (dflt2 === void 0) dflt2 = opts2.dflt;
              exports.valObjectMeta[opts2.valType].coerceFunction(v2, propPart, dflt2, opts2);
              return out;
            }
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (!isArrayOrTypedArray(v)) {
              propOut.set(dflt);
              return;
            }
            var twoD = opts.dimensions === 2 || opts.dimensions === "1-2" && Array.isArray(v) && isArrayOrTypedArray(v[0]);
            var items = opts.items;
            var vOut = [];
            var arrayItems = Array.isArray(items);
            var arrayItems2D = arrayItems && twoD && isArrayOrTypedArray(items[0]);
            var innerItemsOnly = twoD && arrayItems && !arrayItems2D;
            var len = arrayItems && !innerItemsOnly ? items.length : v.length;
            var i, j, row, item, len2, vNew;
            dflt = Array.isArray(dflt) ? dflt : [];
            if (twoD) {
              for (i = 0; i < len; i++) {
                vOut[i] = [];
                row = isArrayOrTypedArray(v[i]) ? v[i] : [];
                if (innerItemsOnly) len2 = items.length;
                else if (arrayItems) len2 = items[i].length;
                else len2 = row.length;
                for (j = 0; j < len2; j++) {
                  if (innerItemsOnly) item = items[j];
                  else if (arrayItems) item = items[i][j];
                  else item = items;
                  vNew = coercePart(row[j], item, (dflt[i] || [])[j]);
                  if (vNew !== void 0) vOut[i][j] = vNew;
                }
              }
            } else {
              for (i = 0; i < len; i++) {
                vNew = coercePart(v[i], arrayItems ? items[i] : items, dflt[i]);
                if (vNew !== void 0) vOut[i] = vNew;
              }
            }
            propOut.set(vOut);
          },
          validateFunction: function(v, opts) {
            if (!isArrayOrTypedArray(v)) return false;
            var items = opts.items;
            var arrayItems = Array.isArray(items);
            var twoD = opts.dimensions === 2;
            if (!opts.freeLength && v.length !== items.length) return false;
            for (var i = 0; i < v.length; i++) {
              if (twoD) {
                if (!isArrayOrTypedArray(v[i]) || !opts.freeLength && v[i].length !== items[i].length) {
                  return false;
                }
                for (var j = 0; j < v[i].length; j++) {
                  if (!validate(v[i][j], arrayItems ? items[i][j] : items)) {
                    return false;
                  }
                }
              } else if (!validate(v[i], arrayItems ? items[i] : items)) return false;
            }
            return true;
          }
        }
      };
      exports.coerce = function(containerIn, containerOut, attributes, attribute, dflt) {
        var opts = nestedProperty(attributes, attribute).get();
        var propIn = nestedProperty(containerIn, attribute);
        var propOut = nestedProperty(containerOut, attribute);
        var v = propIn.get();
        var template = containerOut._template;
        if (v === void 0 && template) {
          v = nestedProperty(template, attribute).get();
          template = 0;
        }
        if (dflt === void 0) dflt = opts.dflt;
        if (opts.arrayOk) {
          if (isArrayOrTypedArray(v)) {
            propOut.set(v);
            return v;
          } else {
            if (isTypedArraySpec(v)) {
              v = decodeTypedArraySpec(v);
              propOut.set(v);
              return v;
            }
          }
        }
        var coerceFunction = exports.valObjectMeta[opts.valType].coerceFunction;
        coerceFunction(v, propOut, dflt, opts);
        var out = propOut.get();
        if (template && out === dflt && !validate(v, opts)) {
          v = nestedProperty(template, attribute).get();
          coerceFunction(v, propOut, dflt, opts);
          out = propOut.get();
        }
        return out;
      };
      exports.coerce2 = function(containerIn, containerOut, attributes, attribute, dflt) {
        var propIn = nestedProperty(containerIn, attribute);
        var propOut = exports.coerce(containerIn, containerOut, attributes, attribute, dflt);
        var valIn = propIn.get();
        return valIn !== void 0 && valIn !== null ? propOut : false;
      };
      exports.coerceFont = function(coerce, attr, dfltObj, opts) {
        if (!opts) opts = {};
        dfltObj = extendFlat({}, dfltObj);
        dfltObj = extendFlat(dfltObj, opts.overrideDflt || {});
        var out = {
          family: coerce(attr + ".family", dfltObj.family),
          size: coerce(attr + ".size", dfltObj.size),
          color: coerce(attr + ".color", dfltObj.color),
          weight: coerce(attr + ".weight", dfltObj.weight),
          style: coerce(attr + ".style", dfltObj.style)
        };
        if (!opts.noFontVariant) out.variant = coerce(attr + ".variant", dfltObj.variant);
        if (!opts.noFontLineposition) out.lineposition = coerce(attr + ".lineposition", dfltObj.lineposition);
        if (!opts.noFontTextcase) out.textcase = coerce(attr + ".textcase", dfltObj.textcase);
        if (!opts.noFontShadow) {
          var dfltShadow = dfltObj.shadow;
          if (dfltShadow === "none" && opts.autoShadowDflt) {
            dfltShadow = "auto";
          }
          out.shadow = coerce(attr + ".shadow", dfltShadow);
        }
        return out;
      };
      exports.coercePattern = function(coerce, attr, markerColor, hasMarkerColorscale) {
        var shape = coerce(attr + ".shape");
        if (shape) {
          coerce(attr + ".solidity");
          coerce(attr + ".size");
          var fillmode = coerce(attr + ".fillmode");
          var isOverlay = fillmode === "overlay";
          if (!hasMarkerColorscale) {
            var bgcolor = coerce(
              attr + ".bgcolor",
              isOverlay ? markerColor : void 0
            );
            coerce(
              attr + ".fgcolor",
              isOverlay ? Color.contrast(bgcolor) : markerColor
            );
          }
          coerce(
            attr + ".fgopacity",
            isOverlay ? 0.5 : 1
          );
        }
      };
      exports.coerceHoverinfo = function(traceIn, traceOut, layoutOut) {
        var moduleAttrs = traceOut._module.attributes;
        var attrs = moduleAttrs.hoverinfo ? moduleAttrs : baseTraceAttrs;
        var valObj = attrs.hoverinfo;
        var dflt;
        if (layoutOut._dataLength === 1) {
          var flags = valObj.dflt === "all" ? valObj.flags.slice() : valObj.dflt.split("+");
          flags.splice(flags.indexOf("name"), 1);
          dflt = flags.join("+");
        }
        return exports.coerce(traceIn, traceOut, attrs, "hoverinfo", dflt);
      };
      exports.coerceSelectionMarkerOpacity = function(traceOut, coerce) {
        if (!traceOut.marker) return;
        var mo = traceOut.marker.opacity;
        if (mo === void 0) return;
        var smoDflt;
        var usmoDflt;
        if (!isArrayOrTypedArray(mo) && !traceOut.selected && !traceOut.unselected) {
          smoDflt = mo;
          usmoDflt = DESELECTDIM * mo;
        }
        coerce("selected.marker.opacity", smoDflt);
        coerce("unselected.marker.opacity", usmoDflt);
      };
      function validate(value, opts) {
        var valObjectDef = exports.valObjectMeta[opts.valType];
        if (opts.arrayOk && isArrayOrTypedArray(value)) return true;
        if (valObjectDef.validateFunction) {
          return valObjectDef.validateFunction(value, opts);
        }
        var failed = {};
        var out = failed;
        var propMock = { set: function(v) {
          out = v;
        } };
        valObjectDef.coerceFunction(value, propMock, failed, opts);
        return out !== failed;
      }
      exports.validate = validate;
    }
  });

  // src/plot_api/plot_config.js
  var require_plot_config = __commonJS({
    "src/plot_api/plot_config.js"(exports, module) {
      "use strict";
      var configAttributes = {
        staticPlot: {
          valType: "boolean",
          dflt: false
        },
        typesetMath: {
          valType: "boolean",
          dflt: true
        },
        plotlyServerURL: {
          valType: "string",
          dflt: ""
        },
        editable: {
          valType: "boolean",
          dflt: false
        },
        edits: {
          annotationPosition: {
            valType: "boolean",
            dflt: false
          },
          annotationTail: {
            valType: "boolean",
            dflt: false
          },
          annotationText: {
            valType: "boolean",
            dflt: false
          },
          axisTitleText: {
            valType: "boolean",
            dflt: false
          },
          colorbarPosition: {
            valType: "boolean",
            dflt: false
          },
          colorbarTitleText: {
            valType: "boolean",
            dflt: false
          },
          legendPosition: {
            valType: "boolean",
            dflt: false
          },
          legendText: {
            valType: "boolean",
            dflt: false
          },
          shapePosition: {
            valType: "boolean",
            dflt: false
          },
          titleText: {
            valType: "boolean",
            dflt: false
          }
        },
        editSelection: {
          valType: "boolean",
          dflt: true
        },
        autosizable: {
          valType: "boolean",
          dflt: false
        },
        responsive: {
          valType: "boolean",
          dflt: false
        },
        fillFrame: {
          valType: "boolean",
          dflt: false
        },
        frameMargins: {
          valType: "number",
          dflt: 0,
          min: 0,
          max: 0.5
        },
        scrollZoom: {
          valType: "flaglist",
          flags: ["cartesian", "gl3d", "geo", "mapbox", "map"],
          extras: [true, false],
          dflt: "gl3d+geo+map"
        },
        doubleClick: {
          valType: "enumerated",
          values: [false, "reset", "autosize", "reset+autosize"],
          dflt: "reset+autosize"
        },
        doubleClickDelay: {
          valType: "number",
          dflt: 300,
          min: 0
        },
        showAxisDragHandles: {
          valType: "boolean",
          dflt: true
        },
        showAxisRangeEntryBoxes: {
          valType: "boolean",
          dflt: true
        },
        showTips: {
          valType: "boolean",
          dflt: true
        },
        showLink: {
          valType: "boolean",
          dflt: false
        },
        linkText: {
          valType: "string",
          dflt: "Edit chart",
          noBlank: true
        },
        sendData: {
          valType: "boolean",
          dflt: true
        },
        showSources: {
          valType: "any",
          dflt: false
        },
        displayModeBar: {
          valType: "enumerated",
          values: ["hover", true, false],
          dflt: "hover"
        },
        showSendToCloud: {
          valType: "boolean",
          dflt: false
        },
        showEditInChartStudio: {
          valType: "boolean",
          dflt: false
        },
        modeBarButtonsToRemove: {
          valType: "any",
          dflt: []
        },
        modeBarButtonsToAdd: {
          valType: "any",
          dflt: []
        },
        modeBarButtons: {
          valType: "any",
          dflt: false
        },
        toImageButtonOptions: {
          valType: "any",
          dflt: {}
        },
        displaylogo: {
          valType: "boolean",
          dflt: true
        },
        watermark: {
          valType: "boolean",
          dflt: false
        },
        plotGlPixelRatio: {
          valType: "number",
          dflt: 2,
          min: 1,
          max: 4
        },
        setBackground: {
          valType: "any",
          dflt: "transparent"
        },
        topojsonURL: {
          valType: "string",
          noBlank: true,
          dflt: "https://cdn.plot.ly/"
        },
        mapboxAccessToken: {
          valType: "string",
          dflt: null
        },
        logging: {
          valType: "integer",
          min: 0,
          max: 2,
          dflt: 1
        },
        notifyOnLogging: {
          valType: "integer",
          min: 0,
          max: 2,
          dflt: 0
        },
        queueLength: {
          valType: "integer",
          min: 0,
          dflt: 0
        },
        locale: {
          valType: "string",
          dflt: "en-US"
        },
        locales: {
          valType: "any",
          dflt: {}
        }
      };
      var dfltConfig = {};
      function crawl(src, target) {
        for (var k in src) {
          var obj = src[k];
          if (obj.valType) {
            target[k] = obj.dflt;
          } else {
            if (!target[k]) {
              target[k] = {};
            }
            crawl(obj, target[k]);
          }
        }
      }
      crawl(configAttributes, dfltConfig);
      module.exports = {
        configAttributes,
        dfltConfig
      };
    }
  });

  // src/lib/notifier.js
  var require_notifier = __commonJS({
    "src/lib/notifier.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var NOTEDATA = [];
      module.exports = function(text, displayLength) {
        if (NOTEDATA.indexOf(text) !== -1) return;
        NOTEDATA.push(text);
        var ts = 1e3;
        if (isNumeric(displayLength)) ts = displayLength;
        else if (displayLength === "long") ts = 3e3;
        var notifierContainer = d3.select("body").selectAll(".plotly-notifier").data([0]);
        notifierContainer.enter().append("div").classed("plotly-notifier", true);
        var notes = notifierContainer.selectAll(".notifier-note").data(NOTEDATA);
        function killNote(transition) {
          transition.duration(700).style("opacity", 0).each("end", function(thisText) {
            var thisIndex = NOTEDATA.indexOf(thisText);
            if (thisIndex !== -1) NOTEDATA.splice(thisIndex, 1);
            d3.select(this).remove();
          });
        }
        notes.enter().append("div").classed("notifier-note", true).style("opacity", 0).each(function(thisText) {
          var note = d3.select(this);
          note.append("button").classed("notifier-close", true).html("&times;").on("click", function() {
            note.transition().call(killNote);
          });
          var p = note.append("p");
          var lines = thisText.split(/<br\s*\/?>/g);
          for (var i = 0; i < lines.length; i++) {
            if (i) p.append("br");
            p.append("span").text(lines[i]);
          }
          if (displayLength === "stick") {
            note.transition().duration(350).style("opacity", 1);
          } else {
            note.transition().duration(700).style("opacity", 1).transition().delay(ts).call(killNote);
          }
        });
      };
    }
  });

  // src/lib/loggers.js
  var require_loggers = __commonJS({
    "src/lib/loggers.js"(exports, module) {
      "use strict";
      var dfltConfig = require_plot_config().dfltConfig;
      var notifier = require_notifier();
      var loggers = module.exports = {};
      loggers.log = function() {
        var i;
        if (dfltConfig.logging > 1) {
          var messages = ["LOG:"];
          for (i = 0; i < arguments.length; i++) {
            messages.push(arguments[i]);
          }
          console.trace.apply(console, messages);
        }
        if (dfltConfig.notifyOnLogging > 1) {
          var lines = [];
          for (i = 0; i < arguments.length; i++) {
            lines.push(arguments[i]);
          }
          notifier(lines.join("<br>"), "long");
        }
      };
      loggers.warn = function() {
        var i;
        if (dfltConfig.logging > 0) {
          var messages = ["WARN:"];
          for (i = 0; i < arguments.length; i++) {
            messages.push(arguments[i]);
          }
          console.trace.apply(console, messages);
        }
        if (dfltConfig.notifyOnLogging > 0) {
          var lines = [];
          for (i = 0; i < arguments.length; i++) {
            lines.push(arguments[i]);
          }
          notifier(lines.join("<br>"), "stick");
        }
      };
      loggers.error = function() {
        var i;
        if (dfltConfig.logging > 0) {
          var messages = ["ERROR:"];
          for (i = 0; i < arguments.length; i++) {
            messages.push(arguments[i]);
          }
          console.error.apply(console, messages);
        }
        if (dfltConfig.notifyOnLogging > 0) {
          var lines = [];
          for (i = 0; i < arguments.length; i++) {
            lines.push(arguments[i]);
          }
          notifier(lines.join("<br>"), "stick");
        }
      };
    }
  });

  // src/lib/noop.js
  var require_noop = __commonJS({
    "src/lib/noop.js"(exports, module) {
      "use strict";
      module.exports = function noop() {
      };
    }
  });

  // src/lib/push_unique.js
  var require_push_unique = __commonJS({
    "src/lib/push_unique.js"(exports, module) {
      "use strict";
      module.exports = function pushUnique(array, item) {
        if (item instanceof RegExp) {
          var itemStr = item.toString();
          for (var i = 0; i < array.length; i++) {
            if (array[i] instanceof RegExp && array[i].toString() === itemStr) {
              return array;
            }
          }
          array.push(item);
        } else if ((item || item === 0) && array.indexOf(item) === -1) array.push(item);
        return array;
      };
    }
  });

  // node_modules/gl-mat4/create.js
  var require_create = __commonJS({
    "node_modules/gl-mat4/create.js"(exports, module) {
      module.exports = create;
      function create() {
        var out = new Float32Array(16);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/clone.js
  var require_clone = __commonJS({
    "node_modules/gl-mat4/clone.js"(exports, module) {
      module.exports = clone;
      function clone(a) {
        var out = new Float32Array(16);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      }
    }
  });

  // node_modules/gl-mat4/copy.js
  var require_copy = __commonJS({
    "node_modules/gl-mat4/copy.js"(exports, module) {
      module.exports = copy;
      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      }
    }
  });

  // node_modules/gl-mat4/identity.js
  var require_identity = __commonJS({
    "node_modules/gl-mat4/identity.js"(exports, module) {
      module.exports = identity;
      function identity(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/transpose.js
  var require_transpose = __commonJS({
    "node_modules/gl-mat4/transpose.js"(exports, module) {
      module.exports = transpose;
      function transpose(out, a) {
        if (out === a) {
          var a01 = a[1], a02 = a[2], a03 = a[3], a12 = a[6], a13 = a[7], a23 = a[11];
          out[1] = a[4];
          out[2] = a[8];
          out[3] = a[12];
          out[4] = a01;
          out[6] = a[9];
          out[7] = a[13];
          out[8] = a02;
          out[9] = a12;
          out[11] = a[14];
          out[12] = a03;
          out[13] = a13;
          out[14] = a23;
        } else {
          out[0] = a[0];
          out[1] = a[4];
          out[2] = a[8];
          out[3] = a[12];
          out[4] = a[1];
          out[5] = a[5];
          out[6] = a[9];
          out[7] = a[13];
          out[8] = a[2];
          out[9] = a[6];
          out[10] = a[10];
          out[11] = a[14];
          out[12] = a[3];
          out[13] = a[7];
          out[14] = a[11];
          out[15] = a[15];
        }
        return out;
      }
    }
  });

  // node_modules/gl-mat4/invert.js
  var require_invert = __commonJS({
    "node_modules/gl-mat4/invert.js"(exports, module) {
      module.exports = invert;
      function invert(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
          return null;
        }
        det = 1 / det;
        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/adjoint.js
  var require_adjoint = __commonJS({
    "node_modules/gl-mat4/adjoint.js"(exports, module) {
      module.exports = adjoint;
      function adjoint(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
        out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
        out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
        out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
        out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
        out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
        out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
        out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
        out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
        out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
        out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
        out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
        out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
        out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
        out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
        out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
        out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
        return out;
      }
    }
  });

  // node_modules/gl-mat4/determinant.js
  var require_determinant = __commonJS({
    "node_modules/gl-mat4/determinant.js"(exports, module) {
      module.exports = determinant;
      function determinant(a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      }
    }
  });

  // node_modules/gl-mat4/multiply.js
  var require_multiply = __commonJS({
    "node_modules/gl-mat4/multiply.js"(exports, module) {
      module.exports = multiply;
      function multiply(out, a, b) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];
        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];
        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];
        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/translate.js
  var require_translate = __commonJS({
    "node_modules/gl-mat4/translate.js"(exports, module) {
      module.exports = translate;
      function translate(out, a, v) {
        var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
        if (a === out) {
          out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          out[0] = a00;
          out[1] = a01;
          out[2] = a02;
          out[3] = a03;
          out[4] = a10;
          out[5] = a11;
          out[6] = a12;
          out[7] = a13;
          out[8] = a20;
          out[9] = a21;
          out[10] = a22;
          out[11] = a23;
          out[12] = a00 * x + a10 * y + a20 * z + a[12];
          out[13] = a01 * x + a11 * y + a21 * z + a[13];
          out[14] = a02 * x + a12 * y + a22 * z + a[14];
          out[15] = a03 * x + a13 * y + a23 * z + a[15];
        }
        return out;
      }
    }
  });

  // node_modules/gl-mat4/scale.js
  var require_scale = __commonJS({
    "node_modules/gl-mat4/scale.js"(exports, module) {
      module.exports = scale;
      function scale(out, a, v) {
        var x = v[0], y = v[1], z = v[2];
        out[0] = a[0] * x;
        out[1] = a[1] * x;
        out[2] = a[2] * x;
        out[3] = a[3] * x;
        out[4] = a[4] * y;
        out[5] = a[5] * y;
        out[6] = a[6] * y;
        out[7] = a[7] * y;
        out[8] = a[8] * z;
        out[9] = a[9] * z;
        out[10] = a[10] * z;
        out[11] = a[11] * z;
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotate.js
  var require_rotate = __commonJS({
    "node_modules/gl-mat4/rotate.js"(exports, module) {
      module.exports = rotate;
      function rotate(out, a, rad, axis) {
        var x = axis[0], y = axis[1], z = axis[2], len = Math.sqrt(x * x + y * y + z * z), s, c, t, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, b00, b01, b02, b10, b11, b12, b20, b21, b22;
        if (Math.abs(len) < 1e-6) {
          return null;
        }
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        b00 = x * x * t + c;
        b01 = y * x * t + z * s;
        b02 = z * x * t - y * s;
        b10 = x * y * t - z * s;
        b11 = y * y * t + c;
        b12 = z * y * t + x * s;
        b20 = x * z * t + y * s;
        b21 = y * z * t - x * s;
        b22 = z * z * t + c;
        out[0] = a00 * b00 + a10 * b01 + a20 * b02;
        out[1] = a01 * b00 + a11 * b01 + a21 * b02;
        out[2] = a02 * b00 + a12 * b01 + a22 * b02;
        out[3] = a03 * b00 + a13 * b01 + a23 * b02;
        out[4] = a00 * b10 + a10 * b11 + a20 * b12;
        out[5] = a01 * b10 + a11 * b11 + a21 * b12;
        out[6] = a02 * b10 + a12 * b11 + a22 * b12;
        out[7] = a03 * b10 + a13 * b11 + a23 * b12;
        out[8] = a00 * b20 + a10 * b21 + a20 * b22;
        out[9] = a01 * b20 + a11 * b21 + a21 * b22;
        out[10] = a02 * b20 + a12 * b21 + a22 * b22;
        out[11] = a03 * b20 + a13 * b21 + a23 * b22;
        if (a !== out) {
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotateX.js
  var require_rotateX = __commonJS({
    "node_modules/gl-mat4/rotateX.js"(exports, module) {
      module.exports = rotateX;
      function rotateX(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        if (a !== out) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[4] = a10 * c + a20 * s;
        out[5] = a11 * c + a21 * s;
        out[6] = a12 * c + a22 * s;
        out[7] = a13 * c + a23 * s;
        out[8] = a20 * c - a10 * s;
        out[9] = a21 * c - a11 * s;
        out[10] = a22 * c - a12 * s;
        out[11] = a23 * c - a13 * s;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotateY.js
  var require_rotateY = __commonJS({
    "node_modules/gl-mat4/rotateY.js"(exports, module) {
      module.exports = rotateY;
      function rotateY(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        if (a !== out) {
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[0] = a00 * c - a20 * s;
        out[1] = a01 * c - a21 * s;
        out[2] = a02 * c - a22 * s;
        out[3] = a03 * c - a23 * s;
        out[8] = a00 * s + a20 * c;
        out[9] = a01 * s + a21 * c;
        out[10] = a02 * s + a22 * c;
        out[11] = a03 * s + a23 * c;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotateZ.js
  var require_rotateZ = __commonJS({
    "node_modules/gl-mat4/rotateZ.js"(exports, module) {
      module.exports = rotateZ;
      function rotateZ(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        if (a !== out) {
          out[8] = a[8];
          out[9] = a[9];
          out[10] = a[10];
          out[11] = a[11];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[0] = a00 * c + a10 * s;
        out[1] = a01 * c + a11 * s;
        out[2] = a02 * c + a12 * s;
        out[3] = a03 * c + a13 * s;
        out[4] = a10 * c - a00 * s;
        out[5] = a11 * c - a01 * s;
        out[6] = a12 * c - a02 * s;
        out[7] = a13 * c - a03 * s;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromRotation.js
  var require_fromRotation = __commonJS({
    "node_modules/gl-mat4/fromRotation.js"(exports, module) {
      module.exports = fromRotation;
      function fromRotation(out, rad, axis) {
        var s, c, t;
        var x = axis[0];
        var y = axis[1];
        var z = axis[2];
        var len = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(len) < 1e-6) {
          return null;
        }
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;
        out[0] = x * x * t + c;
        out[1] = y * x * t + z * s;
        out[2] = z * x * t - y * s;
        out[3] = 0;
        out[4] = x * y * t - z * s;
        out[5] = y * y * t + c;
        out[6] = z * y * t + x * s;
        out[7] = 0;
        out[8] = x * z * t + y * s;
        out[9] = y * z * t - x * s;
        out[10] = z * z * t + c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromRotationTranslation.js
  var require_fromRotationTranslation = __commonJS({
    "node_modules/gl-mat4/fromRotationTranslation.js"(exports, module) {
      module.exports = fromRotationTranslation;
      function fromRotationTranslation(out, q, v) {
        var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
        out[0] = 1 - (yy + zz);
        out[1] = xy + wz;
        out[2] = xz - wy;
        out[3] = 0;
        out[4] = xy - wz;
        out[5] = 1 - (xx + zz);
        out[6] = yz + wx;
        out[7] = 0;
        out[8] = xz + wy;
        out[9] = yz - wx;
        out[10] = 1 - (xx + yy);
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromScaling.js
  var require_fromScaling = __commonJS({
    "node_modules/gl-mat4/fromScaling.js"(exports, module) {
      module.exports = fromScaling;
      function fromScaling(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = v[1];
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = v[2];
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromTranslation.js
  var require_fromTranslation = __commonJS({
    "node_modules/gl-mat4/fromTranslation.js"(exports, module) {
      module.exports = fromTranslation;
      function fromTranslation(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromXRotation.js
  var require_fromXRotation = __commonJS({
    "node_modules/gl-mat4/fromXRotation.js"(exports, module) {
      module.exports = fromXRotation;
      function fromXRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = c;
        out[6] = s;
        out[7] = 0;
        out[8] = 0;
        out[9] = -s;
        out[10] = c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromYRotation.js
  var require_fromYRotation = __commonJS({
    "node_modules/gl-mat4/fromYRotation.js"(exports, module) {
      module.exports = fromYRotation;
      function fromYRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out[0] = c;
        out[1] = 0;
        out[2] = -s;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = s;
        out[9] = 0;
        out[10] = c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromZRotation.js
  var require_fromZRotation = __commonJS({
    "node_modules/gl-mat4/fromZRotation.js"(exports, module) {
      module.exports = fromZRotation;
      function fromZRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out[0] = c;
        out[1] = s;
        out[2] = 0;
        out[3] = 0;
        out[4] = -s;
        out[5] = c;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromQuat.js
  var require_fromQuat = __commonJS({
    "node_modules/gl-mat4/fromQuat.js"(exports, module) {
      module.exports = fromQuat;
      function fromQuat(out, q) {
        var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
        out[0] = 1 - yy - zz;
        out[1] = yx + wz;
        out[2] = zx - wy;
        out[3] = 0;
        out[4] = yx - wz;
        out[5] = 1 - xx - zz;
        out[6] = zy + wx;
        out[7] = 0;
        out[8] = zx + wy;
        out[9] = zy - wx;
        out[10] = 1 - xx - yy;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/frustum.js
  var require_frustum = __commonJS({
    "node_modules/gl-mat4/frustum.js"(exports, module) {
      module.exports = frustum;
      function frustum(out, left, right, bottom, top, near, far) {
        var rl = 1 / (right - left), tb = 1 / (top - bottom), nf = 1 / (near - far);
        out[0] = near * 2 * rl;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = near * 2 * tb;
        out[6] = 0;
        out[7] = 0;
        out[8] = (right + left) * rl;
        out[9] = (top + bottom) * tb;
        out[10] = (far + near) * nf;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = far * near * 2 * nf;
        out[15] = 0;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/perspective.js
  var require_perspective = __commonJS({
    "node_modules/gl-mat4/perspective.js"(exports, module) {
      module.exports = perspective;
      function perspective(out, fovy, aspect, near, far) {
        var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = (far + near) * nf;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = 2 * far * near * nf;
        out[15] = 0;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/perspectiveFromFieldOfView.js
  var require_perspectiveFromFieldOfView = __commonJS({
    "node_modules/gl-mat4/perspectiveFromFieldOfView.js"(exports, module) {
      module.exports = perspectiveFromFieldOfView;
      function perspectiveFromFieldOfView(out, fov, near, far) {
        var upTan = Math.tan(fov.upDegrees * Math.PI / 180), downTan = Math.tan(fov.downDegrees * Math.PI / 180), leftTan = Math.tan(fov.leftDegrees * Math.PI / 180), rightTan = Math.tan(fov.rightDegrees * Math.PI / 180), xScale = 2 / (leftTan + rightTan), yScale = 2 / (upTan + downTan);
        out[0] = xScale;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = yScale;
        out[6] = 0;
        out[7] = 0;
        out[8] = -((leftTan - rightTan) * xScale * 0.5);
        out[9] = (upTan - downTan) * yScale * 0.5;
        out[10] = far / (near - far);
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = far * near / (near - far);
        out[15] = 0;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/ortho.js
  var require_ortho = __commonJS({
    "node_modules/gl-mat4/ortho.js"(exports, module) {
      module.exports = ortho;
      function ortho(out, left, right, bottom, top, near, far) {
        var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
        out[0] = -2 * lr;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = -2 * bt;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 2 * nf;
        out[11] = 0;
        out[12] = (left + right) * lr;
        out[13] = (top + bottom) * bt;
        out[14] = (far + near) * nf;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/lookAt.js
  var require_lookAt = __commonJS({
    "node_modules/gl-mat4/lookAt.js"(exports, module) {
      var identity = require_identity();
      module.exports = lookAt;
      function lookAt(out, eye, center, up) {
        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len, eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center[0], centery = center[1], centerz = center[2];
        if (Math.abs(eyex - centerx) < 1e-6 && Math.abs(eyey - centery) < 1e-6 && Math.abs(eyez - centerz) < 1e-6) {
          return identity(out);
        }
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
          x0 = 0;
          x1 = 0;
          x2 = 0;
        } else {
          len = 1 / len;
          x0 *= len;
          x1 *= len;
          x2 *= len;
        }
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;
        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
          y0 = 0;
          y1 = 0;
          y2 = 0;
        } else {
          len = 1 / len;
          y0 *= len;
          y1 *= len;
          y2 *= len;
        }
        out[0] = x0;
        out[1] = y0;
        out[2] = z0;
        out[3] = 0;
        out[4] = x1;
        out[5] = y1;
        out[6] = z1;
        out[7] = 0;
        out[8] = x2;
        out[9] = y2;
        out[10] = z2;
        out[11] = 0;
        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/str.js
  var require_str = __commonJS({
    "node_modules/gl-mat4/str.js"(exports, module) {
      module.exports = str;
      function str(a) {
        return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
      }
    }
  });

  // node_modules/gl-mat4/index.js
  var require_gl_mat4 = __commonJS({
    "node_modules/gl-mat4/index.js"(exports, module) {
      module.exports = {
        create: require_create(),
        clone: require_clone(),
        copy: require_copy(),
        identity: require_identity(),
        transpose: require_transpose(),
        invert: require_invert(),
        adjoint: require_adjoint(),
        determinant: require_determinant(),
        multiply: require_multiply(),
        translate: require_translate(),
        scale: require_scale(),
        rotate: require_rotate(),
        rotateX: require_rotateX(),
        rotateY: require_rotateY(),
        rotateZ: require_rotateZ(),
        fromRotation: require_fromRotation(),
        fromRotationTranslation: require_fromRotationTranslation(),
        fromScaling: require_fromScaling(),
        fromTranslation: require_fromTranslation(),
        fromXRotation: require_fromXRotation(),
        fromYRotation: require_fromYRotation(),
        fromZRotation: require_fromZRotation(),
        fromQuat: require_fromQuat(),
        frustum: require_frustum(),
        perspective: require_perspective(),
        perspectiveFromFieldOfView: require_perspectiveFromFieldOfView(),
        ortho: require_ortho(),
        lookAt: require_lookAt(),
        str: require_str()
      };
    }
  });

  // src/lib/matrix.js
  var require_matrix = __commonJS({
    "src/lib/matrix.js"(exports) {
      "use strict";
      var mat4X4 = require_gl_mat4();
      exports.init2dArray = function(rowLength, colLength) {
        var array = new Array(rowLength);
        for (var i = 0; i < rowLength; i++) array[i] = new Array(colLength);
        return array;
      };
      exports.transposeRagged = function(z) {
        var maxlen = 0;
        var zlen = z.length;
        var i, j;
        for (i = 0; i < zlen; i++) maxlen = Math.max(maxlen, z[i].length);
        var t = new Array(maxlen);
        for (i = 0; i < maxlen; i++) {
          t[i] = new Array(zlen);
          for (j = 0; j < zlen; j++) t[i][j] = z[j][i];
        }
        return t;
      };
      exports.dot = function(x, y) {
        if (!(x.length && y.length) || x.length !== y.length) return null;
        var len = x.length;
        var out;
        var i;
        if (x[0].length) {
          out = new Array(len);
          for (i = 0; i < len; i++) out[i] = exports.dot(x[i], y);
        } else if (y[0].length) {
          var yTranspose = exports.transposeRagged(y);
          out = new Array(yTranspose.length);
          for (i = 0; i < yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
        } else {
          out = 0;
          for (i = 0; i < len; i++) out += x[i] * y[i];
        }
        return out;
      };
      exports.translationMatrix = function(x, y) {
        return [[1, 0, x], [0, 1, y], [0, 0, 1]];
      };
      exports.rotationMatrix = function(alpha) {
        var a = alpha * Math.PI / 180;
        return [
          [Math.cos(a), -Math.sin(a), 0],
          [Math.sin(a), Math.cos(a), 0],
          [0, 0, 1]
        ];
      };
      exports.rotationXYMatrix = function(a, x, y) {
        return exports.dot(
          exports.dot(
            exports.translationMatrix(x, y),
            exports.rotationMatrix(a)
          ),
          exports.translationMatrix(-x, -y)
        );
      };
      exports.apply3DTransform = function(transform) {
        return function() {
          var args = arguments;
          var xyz = arguments.length === 1 ? args[0] : [args[0], args[1], args[2] || 0];
          return exports.dot(transform, [xyz[0], xyz[1], xyz[2], 1]).slice(0, 3);
        };
      };
      exports.apply2DTransform = function(transform) {
        return function() {
          var args = arguments;
          if (args.length === 3) {
            args = args[0];
          }
          var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];
          return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);
        };
      };
      exports.apply2DTransform2 = function(transform) {
        var at = exports.apply2DTransform(transform);
        return function(xys) {
          return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));
        };
      };
      exports.convertCssMatrix = function(m) {
        if (m) {
          var len = m.length;
          if (len === 16) return m;
          if (len === 6) {
            return [
              m[0],
              m[1],
              0,
              0,
              m[2],
              m[3],
              0,
              0,
              0,
              0,
              1,
              0,
              m[4],
              m[5],
              0,
              1
            ];
          }
        }
        return [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
      };
      exports.inverseTransformMatrix = function(m) {
        var out = [];
        mat4X4.invert(out, m);
        return [
          [out[0], out[1], out[2], out[3]],
          [out[4], out[5], out[6], out[7]],
          [out[8], out[9], out[10], out[11]],
          [out[12], out[13], out[14], out[15]]
        ];
      };
    }
  });

  // src/lib/dom.js
  var require_dom = __commonJS({
    "src/lib/dom.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var loggers = require_loggers();
      var matrix = require_matrix();
      var mat4X4 = require_gl_mat4();
      function getGraphDiv(gd) {
        var gdElement;
        if (typeof gd === "string") {
          gdElement = document.getElementById(gd);
          if (gdElement === null) {
            throw new Error("No DOM element with id '" + gd + "' exists on the page.");
          }
          return gdElement;
        } else if (gd === null || gd === void 0) {
          throw new Error("DOM element provided is null or undefined");
        }
        return gd;
      }
      function isPlotDiv(el) {
        var el3 = d3.select(el);
        return el3.node() instanceof HTMLElement && el3.size() && el3.classed("js-plotly-plot");
      }
      function removeElement(el) {
        var elParent = el && el.parentNode;
        if (elParent) elParent.removeChild(el);
      }
      function addStyleRule(selector, styleString) {
        addRelatedStyleRule("global", selector, styleString);
      }
      function addRelatedStyleRule(uid, selector, styleString) {
        var id = "plotly.js-style-" + uid;
        var style = document.getElementById(id);
        if (style && style.matches(".no-inline-styles")) {
          return;
        }
        if (!style) {
          style = document.createElement("style");
          style.setAttribute("id", id);
          style.appendChild(document.createTextNode(""));
          document.head.appendChild(style);
        }
        var styleSheet = style.sheet;
        if (!styleSheet) {
          loggers.warn("Cannot addRelatedStyleRule, probably due to strict CSP...");
        } else if (styleSheet.insertRule) {
          styleSheet.insertRule(selector + "{" + styleString + "}", 0);
        } else if (styleSheet.addRule) {
          styleSheet.addRule(selector, styleString, 0);
        } else loggers.warn("addStyleRule failed");
      }
      function deleteRelatedStyleRule(uid) {
        var id = "plotly.js-style-" + uid;
        var style = document.getElementById(id);
        if (style) removeElement(style);
      }
      function setStyleOnHover(selector, activeSelector, childSelector, activeStyle, inactiveStyle, element) {
        var activeStyleParts = activeStyle.split(":");
        var inactiveStyleParts = inactiveStyle.split(":");
        var eventAddedAttrName = "data-btn-style-event-added";
        if (!element) {
          element = document;
        }
        element.querySelectorAll(selector).forEach(function(el) {
          if (!el.getAttribute(eventAddedAttrName)) {
            el.addEventListener("mouseenter", function() {
              var childEl = this.querySelector(childSelector);
              if (childEl) {
                childEl.style[activeStyleParts[0]] = activeStyleParts[1];
              }
            });
            el.addEventListener("mouseleave", function() {
              var childEl = this.querySelector(childSelector);
              if (childEl) {
                if (activeSelector && this.matches(activeSelector)) {
                  childEl.style[activeStyleParts[0]] = activeStyleParts[1];
                } else {
                  childEl.style[inactiveStyleParts[0]] = inactiveStyleParts[1];
                }
              }
            });
            el.setAttribute(eventAddedAttrName, true);
          }
        });
      }
      function getFullTransformMatrix(element) {
        var allElements = getElementAndAncestors(element);
        var out = [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
        allElements.forEach(function(e) {
          var t = getElementTransformMatrix(e);
          if (t) {
            var m = matrix.convertCssMatrix(t);
            out = mat4X4.multiply(out, out, m);
          }
        });
        return out;
      }
      function getElementTransformMatrix(element) {
        var style = window.getComputedStyle(element, null);
        var transform = style.getPropertyValue("-webkit-transform") || style.getPropertyValue("-moz-transform") || style.getPropertyValue("-ms-transform") || style.getPropertyValue("-o-transform") || style.getPropertyValue("transform");
        if (transform === "none") return null;
        return transform.replace("matrix", "").replace("3d", "").slice(1, -1).split(",").map(function(n) {
          return +n;
        });
      }
      function getElementAndAncestors(element) {
        var allElements = [];
        while (isTransformableElement(element)) {
          allElements.push(element);
          element = element.parentNode;
          if (typeof ShadowRoot === "function" && element instanceof ShadowRoot) {
            element = element.host;
          }
        }
        return allElements;
      }
      function isTransformableElement(element) {
        return element && (element instanceof Element || element instanceof HTMLElement);
      }
      function equalDomRects(a, b) {
        return a && b && a.top === b.top && a.left === b.left && a.right === b.right && a.bottom === b.bottom;
      }
      module.exports = {
        getGraphDiv,
        isPlotDiv,
        removeElement,
        addStyleRule,
        addRelatedStyleRule,
        deleteRelatedStyleRule,
        setStyleOnHover,
        getFullTransformMatrix,
        getElementTransformMatrix,
        getElementAndAncestors,
        equalDomRects
      };
    }
  });

  // src/plots/animation_attributes.js
  var require_animation_attributes = __commonJS({
    "src/plots/animation_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        mode: {
          valType: "enumerated",
          dflt: "afterall",
          values: ["immediate", "next", "afterall"]
        },
        direction: {
          valType: "enumerated",
          values: ["forward", "reverse"],
          dflt: "forward"
        },
        fromcurrent: {
          valType: "boolean",
          dflt: false
        },
        frame: {
          duration: {
            valType: "number",
            min: 0,
            dflt: 500
          },
          redraw: {
            valType: "boolean",
            dflt: true
          }
        },
        transition: {
          duration: {
            valType: "number",
            min: 0,
            dflt: 500,
            editType: "none"
          },
          easing: {
            valType: "enumerated",
            dflt: "cubic-in-out",
            values: [
              "linear",
              "quad",
              "cubic",
              "sin",
              "exp",
              "circle",
              "elastic",
              "back",
              "bounce",
              "linear-in",
              "quad-in",
              "cubic-in",
              "sin-in",
              "exp-in",
              "circle-in",
              "elastic-in",
              "back-in",
              "bounce-in",
              "linear-out",
              "quad-out",
              "cubic-out",
              "sin-out",
              "exp-out",
              "circle-out",
              "elastic-out",
              "back-out",
              "bounce-out",
              "linear-in-out",
              "quad-in-out",
              "cubic-in-out",
              "sin-in-out",
              "exp-in-out",
              "circle-in-out",
              "elastic-in-out",
              "back-in-out",
              "bounce-in-out"
            ],
            editType: "none"
          },
          ordering: {
            valType: "enumerated",
            values: ["layout first", "traces first"],
            dflt: "layout first",
            editType: "none"
          }
        }
      };
    }
  });

  // src/plot_api/edit_types.js
  var require_edit_types = __commonJS({
    "src/plot_api/edit_types.js"(exports, module) {
      "use strict";
      var extendFlat = require_extend().extendFlat;
      var isPlainObject = require_is_plain_object();
      var traceOpts = {
        valType: "flaglist",
        extras: ["none"],
        flags: ["calc", "clearAxisTypes", "plot", "style", "markerSize", "colorbars"]
      };
      var layoutOpts = {
        valType: "flaglist",
        extras: ["none"],
        flags: [
          "calc",
          "plot",
          "legend",
          "ticks",
          "axrange",
          "layoutstyle",
          "modebar",
          "camera",
          "arraydraw",
          "colorbars"
        ]
      };
      var traceEditTypeFlags = traceOpts.flags.slice().concat(["fullReplot"]);
      var layoutEditTypeFlags = layoutOpts.flags.slice().concat("layoutReplot");
      module.exports = {
        traces: traceOpts,
        layout: layoutOpts,
        /*
         * default (all false) edit flags for restyle (traces)
         * creates a new object each call, so the caller can mutate freely
         */
        traceFlags: function() {
          return falseObj(traceEditTypeFlags);
        },
        /*
         * default (all false) edit flags for relayout
         * creates a new object each call, so the caller can mutate freely
         */
        layoutFlags: function() {
          return falseObj(layoutEditTypeFlags);
        },
        /*
         * update `flags` with the `editType` values found in `attr`
         */
        update: function(flags, attr) {
          var editType = attr.editType;
          if (editType && editType !== "none") {
            var editTypeParts = editType.split("+");
            for (var i = 0; i < editTypeParts.length; i++) {
              flags[editTypeParts[i]] = true;
            }
          }
        },
        overrideAll
      };
      function falseObj(keys) {
        var out = {};
        for (var i = 0; i < keys.length; i++) out[keys[i]] = false;
        return out;
      }
      function overrideAll(attrs, editTypeOverride, overrideContainers) {
        var out = extendFlat({}, attrs);
        for (var key in out) {
          var attr = out[key];
          if (isPlainObject(attr)) {
            out[key] = overrideOne(attr, editTypeOverride, overrideContainers, key);
          }
        }
        if (overrideContainers === "from-root") out.editType = editTypeOverride;
        return out;
      }
      function overrideOne(attr, editTypeOverride, overrideContainers, key) {
        if (attr.valType) {
          var out = extendFlat({}, attr);
          out.editType = editTypeOverride;
          if (Array.isArray(attr.items)) {
            out.items = new Array(attr.items.length);
            for (var i = 0; i < attr.items.length; i++) {
              out.items[i] = overrideOne(attr.items[i], editTypeOverride, "from-root");
            }
          }
          return out;
        } else {
          return overrideAll(
            attr,
            editTypeOverride,
            key.charAt(0) === "_" ? "nested" : "from-root"
          );
        }
      }
    }
  });

  // src/components/drawing/attributes.js
  var require_attributes4 = __commonJS({
    "src/components/drawing/attributes.js"(exports) {
      "use strict";
      exports.dash = {
        valType: "string",
        // string type usually doesn't take values... this one should really be
        // a special type or at least a special coercion function, from the GUI
        // you only get these values but elsewhere the user can supply a list of
        // dash lengths in px, and it will be honored
        values: ["solid", "dot", "dash", "longdash", "dashdot", "longdashdot"],
        dflt: "solid",
        editType: "style"
      };
      exports.pattern = {
        shape: {
          valType: "enumerated",
          values: ["", "/", "\\", "x", "-", "|", "+", "."],
          dflt: "",
          arrayOk: true,
          editType: "style"
        },
        fillmode: {
          valType: "enumerated",
          values: ["replace", "overlay"],
          dflt: "replace",
          editType: "style"
        },
        bgcolor: {
          valType: "color",
          arrayOk: true,
          editType: "style"
        },
        fgcolor: {
          valType: "color",
          arrayOk: true,
          editType: "style"
        },
        fgopacity: {
          valType: "number",
          editType: "style",
          min: 0,
          max: 1
        },
        size: {
          valType: "number",
          min: 0,
          dflt: 8,
          arrayOk: true,
          editType: "style"
        },
        solidity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0.3,
          arrayOk: true,
          editType: "style"
        },
        editType: "style"
      };
    }
  });

  // src/constants/docs.js
  var require_docs = __commonJS({
    "src/constants/docs.js"(exports, module) {
      "use strict";
      module.exports = {
        FORMAT_LINK: "https://github.com/d3/d3-format/tree/v1.4.5#d3-format",
        DATE_FORMAT_LINK: "https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format"
      };
    }
  });

  // src/plots/template_attributes.js
  var require_template_attributes = __commonJS({
    "src/plots/template_attributes.js"(exports) {
      "use strict";
      var docs = require_docs();
      var FORMAT_LINK = docs.FORMAT_LINK;
      var DATE_FORMAT_LINK = docs.DATE_FORMAT_LINK;
      function describeVariables(extra) {
        var descPart = extra.description ? " " + extra.description : "";
        var keys = extra.keys || [];
        if (keys.length > 0) {
          var quotedKeys = [];
          for (var i = 0; i < keys.length; i++) {
            quotedKeys[i] = "`" + keys[i] + "`";
          }
          descPart = descPart + "Finally, the template string has access to ";
          if (keys.length === 1) {
            descPart = descPart + "variable " + quotedKeys[0];
          } else {
            descPart = descPart + "variables " + quotedKeys.slice(0, -1).join(", ") + " and " + quotedKeys.slice(-1) + ".";
          }
        }
        return descPart;
      }
      exports.hovertemplateAttrs = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var descPart = describeVariables(extra);
        var hovertemplate = {
          valType: "string",
          dflt: "",
          editType: opts.editType || "none"
        };
        if (opts.arrayOk !== false) {
          hovertemplate.arrayOk = true;
        }
        return hovertemplate;
      };
      exports.texttemplateAttrs = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var descPart = describeVariables(extra);
        var texttemplate = {
          valType: "string",
          dflt: "",
          editType: opts.editType || "calc"
        };
        if (opts.arrayOk !== false) {
          texttemplate.arrayOk = true;
        }
        return texttemplate;
      };
      exports.shapeTexttemplateAttrs = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var newStr = opts.newshape ? "new " : "";
        var descPart = describeVariables(extra);
        var texttemplate = {
          valType: "string",
          dflt: "",
          editType: opts.editType || "arraydraw"
        };
        return texttemplate;
      };
    }
  });

  // src/components/shapes/label_texttemplate.js
  var require_label_texttemplate = __commonJS({
    "src/components/shapes/label_texttemplate.js"(exports, module) {
      "use strict";
      function d2l(v, axis) {
        return axis ? axis.d2l(v) : v;
      }
      function l2d(v, axis) {
        return axis ? axis.l2d(v) : v;
      }
      function x0Fn(shape) {
        return shape.x0;
      }
      function x1Fn(shape) {
        return shape.x1;
      }
      function y0Fn(shape) {
        return shape.y0;
      }
      function y1Fn(shape) {
        return shape.y1;
      }
      function x0shiftFn(shape) {
        return shape.x0shift || 0;
      }
      function x1shiftFn(shape) {
        return shape.x1shift || 0;
      }
      function y0shiftFn(shape) {
        return shape.y0shift || 0;
      }
      function y1shiftFn(shape) {
        return shape.y1shift || 0;
      }
      function dxFn(shape, xa) {
        return d2l(shape.x1, xa) + x1shiftFn(shape) - d2l(shape.x0, xa) - x0shiftFn(shape);
      }
      function dyFn(shape, xa, ya) {
        return d2l(shape.y1, ya) + y1shiftFn(shape) - d2l(shape.y0, ya) - y0shiftFn(shape);
      }
      function widthFn(shape, xa) {
        return Math.abs(dxFn(shape, xa));
      }
      function heightFn(shape, xa, ya) {
        return Math.abs(dyFn(shape, xa, ya));
      }
      function lengthFn(shape, xa, ya) {
        return shape.type !== "line" ? void 0 : Math.sqrt(
          Math.pow(dxFn(shape, xa), 2) + Math.pow(dyFn(shape, xa, ya), 2)
        );
      }
      function xcenterFn(shape, xa) {
        return l2d((d2l(shape.x1, xa) + x1shiftFn(shape) + d2l(shape.x0, xa) + x0shiftFn(shape)) / 2, xa);
      }
      function ycenterFn(shape, xa, ya) {
        return l2d((d2l(shape.y1, ya) + y1shiftFn(shape) + d2l(shape.y0, ya) + y0shiftFn(shape)) / 2, ya);
      }
      function slopeFn(shape, xa, ya) {
        return shape.type !== "line" ? void 0 : dyFn(shape, xa, ya) / dxFn(shape, xa);
      }
      module.exports = {
        x0: x0Fn,
        x1: x1Fn,
        y0: y0Fn,
        y1: y1Fn,
        slope: slopeFn,
        dx: dxFn,
        dy: dyFn,
        width: widthFn,
        height: heightFn,
        length: lengthFn,
        xcenter: xcenterFn,
        ycenter: ycenterFn
      };
    }
  });

  // src/components/shapes/draw_newshape/attributes.js
  var require_attributes5 = __commonJS({
    "src/components/shapes/draw_newshape/attributes.js"(exports, module) {
      "use strict";
      var overrideAll = require_edit_types().overrideAll;
      var basePlotAttributes = require_attributes2();
      var fontAttrs = require_font_attributes();
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var shapeTexttemplateAttrs = require_template_attributes().shapeTexttemplateAttrs;
      var shapeLabelTexttemplateVars = require_label_texttemplate();
      module.exports = overrideAll({
        newshape: {
          visible: extendFlat({}, basePlotAttributes.visible, {}),
          showlegend: {
            valType: "boolean",
            dflt: false
          },
          legend: extendFlat({}, basePlotAttributes.legend, {}),
          legendgroup: extendFlat({}, basePlotAttributes.legendgroup, {}),
          legendgrouptitle: {
            text: extendFlat({}, basePlotAttributes.legendgrouptitle.text, {}),
            font: fontAttrs({})
          },
          legendrank: extendFlat({}, basePlotAttributes.legendrank, {}),
          legendwidth: extendFlat({}, basePlotAttributes.legendwidth, {}),
          line: {
            color: {
              valType: "color"
            },
            width: {
              valType: "number",
              min: 0,
              dflt: 4
            },
            dash: extendFlat({}, dash, {
              dflt: "solid"
            })
          },
          fillcolor: {
            valType: "color",
            dflt: "rgba(0,0,0,0)"
          },
          fillrule: {
            valType: "enumerated",
            values: ["evenodd", "nonzero"],
            dflt: "evenodd"
          },
          opacity: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 1
          },
          layer: {
            valType: "enumerated",
            values: ["below", "above", "between"],
            dflt: "above"
          },
          drawdirection: {
            valType: "enumerated",
            values: ["ortho", "horizontal", "vertical", "diagonal"],
            dflt: "diagonal"
          },
          name: extendFlat({}, basePlotAttributes.name, {}),
          label: {
            text: {
              valType: "string",
              dflt: ""
            },
            texttemplate: shapeTexttemplateAttrs({ newshape: true }, { keys: Object.keys(shapeLabelTexttemplateVars) }),
            font: fontAttrs({}),
            textposition: {
              valType: "enumerated",
              values: [
                "top left",
                "top center",
                "top right",
                "middle left",
                "middle center",
                "middle right",
                "bottom left",
                "bottom center",
                "bottom right",
                "start",
                "middle",
                "end"
              ]
            },
            textangle: {
              valType: "angle",
              dflt: "auto"
            },
            xanchor: {
              valType: "enumerated",
              values: ["auto", "left", "center", "right"],
              dflt: "auto"
            },
            yanchor: {
              valType: "enumerated",
              values: ["top", "middle", "bottom"]
            },
            padding: {
              valType: "number",
              dflt: 3,
              min: 0
            }
          }
        },
        activeshape: {
          fillcolor: {
            valType: "color",
            dflt: "rgb(255,0,255)"
          },
          opacity: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 0.5
          }
        }
      }, "none", "from-root");
    }
  });

  // src/components/selections/draw_newselection/attributes.js
  var require_attributes6 = __commonJS({
    "src/components/selections/draw_newselection/attributes.js"(exports, module) {
      "use strict";
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      module.exports = {
        newselection: {
          mode: {
            valType: "enumerated",
            values: ["immediate", "gradual"],
            dflt: "immediate",
            editType: "none"
          },
          line: {
            color: {
              valType: "color",
              editType: "none"
            },
            width: {
              valType: "number",
              min: 1,
              dflt: 1,
              editType: "none"
            },
            dash: extendFlat({}, dash, {
              dflt: "dot",
              editType: "none"
            }),
            editType: "none"
          },
          // no drawdirection here noting that layout.selectdirection is used instead.
          editType: "none"
        },
        activeselection: {
          fillcolor: {
            valType: "color",
            dflt: "rgba(0,0,0,0)",
            editType: "none"
          },
          opacity: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 0.5,
            editType: "none"
          },
          editType: "none"
        }
      };
    }
  });

  // src/plots/pad_attributes.js
  var require_pad_attributes = __commonJS({
    "src/plots/pad_attributes.js"(exports, module) {
      "use strict";
      module.exports = function(opts) {
        var editType = opts.editType;
        return {
          t: {
            valType: "number",
            dflt: 0,
            editType
          },
          r: {
            valType: "number",
            dflt: 0,
            editType
          },
          b: {
            valType: "number",
            dflt: 0,
            editType
          },
          l: {
            valType: "number",
            dflt: 0,
            editType
          },
          editType
        };
      };
    }
  });

  // src/plots/layout_attributes.js
  var require_layout_attributes2 = __commonJS({
    "src/plots/layout_attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var animationAttrs = require_animation_attributes();
      var colorAttrs = require_attributes3();
      var drawNewShapeAttrs = require_attributes5();
      var drawNewSelectionAttrs = require_attributes6();
      var padAttrs = require_pad_attributes();
      var extendFlat = require_extend().extendFlat;
      var globalFont = fontAttrs({
        editType: "calc"
      });
      globalFont.family.dflt = '"Open Sans", verdana, arial, sans-serif';
      globalFont.size.dflt = 12;
      globalFont.color.dflt = colorAttrs.defaultLine;
      module.exports = {
        font: globalFont,
        title: {
          text: {
            valType: "string",
            editType: "layoutstyle"
          },
          font: fontAttrs({
            editType: "layoutstyle"
          }),
          subtitle: {
            text: {
              valType: "string",
              editType: "layoutstyle"
            },
            font: fontAttrs({
              editType: "layoutstyle"
            }),
            editType: "layoutstyle"
          },
          xref: {
            valType: "enumerated",
            dflt: "container",
            values: ["container", "paper"],
            editType: "layoutstyle"
          },
          yref: {
            valType: "enumerated",
            dflt: "container",
            values: ["container", "paper"],
            editType: "layoutstyle"
          },
          x: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 0.5,
            editType: "layoutstyle"
          },
          y: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: "auto",
            editType: "layoutstyle"
          },
          xanchor: {
            valType: "enumerated",
            dflt: "auto",
            values: ["auto", "left", "center", "right"],
            editType: "layoutstyle"
          },
          yanchor: {
            valType: "enumerated",
            dflt: "auto",
            values: ["auto", "top", "middle", "bottom"],
            editType: "layoutstyle"
          },
          pad: extendFlat(padAttrs({ editType: "layoutstyle" }), {}),
          automargin: {
            valType: "boolean",
            dflt: false,
            editType: "plot"
          },
          editType: "layoutstyle"
        },
        uniformtext: {
          mode: {
            valType: "enumerated",
            values: [false, "hide", "show"],
            dflt: false,
            editType: "plot"
          },
          minsize: {
            valType: "number",
            min: 0,
            dflt: 0,
            editType: "plot"
          },
          editType: "plot"
        },
        autosize: {
          valType: "boolean",
          dflt: false,
          // autosize, width, and height get special editType treatment in _relayout
          // so we can handle noop resizes more efficiently
          editType: "none"
        },
        width: {
          valType: "number",
          min: 10,
          dflt: 700,
          editType: "plot"
        },
        height: {
          valType: "number",
          min: 10,
          dflt: 450,
          editType: "plot"
        },
        minreducedwidth: {
          valType: "number",
          min: 2,
          dflt: 64,
          editType: "plot"
        },
        minreducedheight: {
          valType: "number",
          min: 2,
          dflt: 64,
          editType: "plot"
        },
        margin: {
          l: {
            valType: "number",
            min: 0,
            dflt: 80,
            editType: "plot"
          },
          r: {
            valType: "number",
            min: 0,
            dflt: 80,
            editType: "plot"
          },
          t: {
            valType: "number",
            min: 0,
            dflt: 100,
            editType: "plot"
          },
          b: {
            valType: "number",
            min: 0,
            dflt: 80,
            editType: "plot"
          },
          pad: {
            valType: "number",
            min: 0,
            dflt: 0,
            editType: "plot"
          },
          autoexpand: {
            valType: "boolean",
            dflt: true,
            editType: "plot"
          },
          editType: "plot"
        },
        computed: {
          valType: "any",
          editType: "none"
        },
        paper_bgcolor: {
          valType: "color",
          dflt: colorAttrs.background,
          editType: "plot"
        },
        plot_bgcolor: {
          // defined here, but set in cartesian.supplyLayoutDefaults
          // because it needs to know if there are (2D) axes or not
          valType: "color",
          dflt: colorAttrs.background,
          editType: "layoutstyle"
        },
        autotypenumbers: {
          valType: "enumerated",
          values: ["convert types", "strict"],
          dflt: "convert types",
          editType: "calc"
        },
        separators: {
          valType: "string",
          editType: "plot"
        },
        hidesources: {
          valType: "boolean",
          dflt: false,
          editType: "plot"
        },
        showlegend: {
          // handled in legend.supplyLayoutDefaults
          // but included here because it's not in the legend object
          valType: "boolean",
          editType: "legend"
        },
        colorway: {
          valType: "colorlist",
          dflt: colorAttrs.defaults,
          editType: "calc"
        },
        datarevision: {
          valType: "any",
          editType: "calc"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        editrevision: {
          valType: "any",
          editType: "none"
        },
        selectionrevision: {
          valType: "any",
          editType: "none"
        },
        template: {
          valType: "any",
          editType: "calc"
        },
        newshape: drawNewShapeAttrs.newshape,
        activeshape: drawNewShapeAttrs.activeshape,
        newselection: drawNewSelectionAttrs.newselection,
        activeselection: drawNewSelectionAttrs.activeselection,
        meta: {
          valType: "any",
          arrayOk: true,
          editType: "plot"
        },
        transition: extendFlat({}, animationAttrs.transition, {
          editType: "none"
        })
      };
    }
  });

  // temp_stylePlugin:node_modules/maplibre-gl/dist/maplibre-gl.css
  var init_maplibre_gl = __esm({
    "temp_stylePlugin:node_modules/maplibre-gl/dist/maplibre-gl.css"() {
    }
  });

  // stylePlugin:/Users/ekl/code/plotly.js/node_modules/maplibre-gl/dist/maplibre-gl.css
  var maplibre_gl_exports = {};
  var init_maplibre_gl2 = __esm({
    "stylePlugin:/Users/ekl/code/plotly.js/node_modules/maplibre-gl/dist/maplibre-gl.css"() {
      init_maplibre_gl();
    }
  });

  // src/registry.js
  var require_registry = __commonJS({
    "src/registry.js"(exports) {
      "use strict";
      var Loggers = require_loggers();
      var noop = require_noop();
      var pushUnique = require_push_unique();
      var isPlainObject = require_is_plain_object();
      var addStyleRule = require_dom().addStyleRule;
      var ExtendModule = require_extend();
      var basePlotAttributes = require_attributes2();
      var baseLayoutAttributes = require_layout_attributes2();
      var extendFlat = ExtendModule.extendFlat;
      var extendDeepAll = ExtendModule.extendDeepAll;
      exports.modules = {};
      exports.allCategories = {};
      exports.allTypes = [];
      exports.subplotsRegistry = {};
      exports.componentsRegistry = {};
      exports.layoutArrayContainers = [];
      exports.layoutArrayRegexes = [];
      exports.traceLayoutAttributes = {};
      exports.localeRegistry = {};
      exports.apiMethodRegistry = {};
      exports.collectableSubplotTypes = null;
      exports.register = function register(_modules) {
        exports.collectableSubplotTypes = null;
        if (!_modules) {
          throw new Error("No argument passed to Plotly.register.");
        } else if (_modules && !Array.isArray(_modules)) {
          _modules = [_modules];
        }
        for (var i = 0; i < _modules.length; i++) {
          var newModule = _modules[i];
          if (!newModule) {
            throw new Error("Invalid module was attempted to be registered!");
          }
          switch (newModule.moduleType) {
            case "trace":
              registerTraceModule(newModule);
              break;
            case "transform":
              registerTransformModule(newModule);
              break;
            case "component":
              registerComponentModule(newModule);
              break;
            case "locale":
              registerLocale(newModule);
              break;
            case "apiMethod":
              var name = newModule.name;
              exports.apiMethodRegistry[name] = newModule.fn;
              break;
            default:
              throw new Error("Invalid module was attempted to be registered!");
          }
        }
      };
      exports.getModule = function(trace) {
        var _module = exports.modules[getTraceType(trace)];
        if (!_module) return false;
        return _module._module;
      };
      exports.traceIs = function(traceType, category) {
        traceType = getTraceType(traceType);
        if (traceType === "various") return false;
        var _module = exports.modules[traceType];
        if (!_module) {
          if (traceType) {
            Loggers.log("Unrecognized trace type " + traceType + ".");
          }
          _module = exports.modules[basePlotAttributes.type.dflt];
        }
        return !!_module.categories[category];
      };
      exports.getComponentMethod = function(name, method) {
        var _module = exports.componentsRegistry[name];
        if (!_module) return noop;
        return _module[method] || noop;
      };
      exports.call = function() {
        var name = arguments[0];
        var args = [].slice.call(arguments, 1);
        return exports.apiMethodRegistry[name].apply(null, args);
      };
      function registerTraceModule(_module) {
        var thisType = _module.name;
        var categoriesIn = _module.categories;
        var meta = _module.meta;
        if (exports.modules[thisType]) {
          Loggers.log("Type " + thisType + " already registered");
          return;
        }
        if (!exports.subplotsRegistry[_module.basePlotModule.name]) {
          registerSubplot(_module.basePlotModule);
        }
        var categoryObj = {};
        for (var i = 0; i < categoriesIn.length; i++) {
          categoryObj[categoriesIn[i]] = true;
          exports.allCategories[categoriesIn[i]] = true;
        }
        exports.modules[thisType] = {
          _module,
          categories: categoryObj
        };
        if (meta && Object.keys(meta).length) {
          exports.modules[thisType].meta = meta;
        }
        exports.allTypes.push(thisType);
        for (var componentName in exports.componentsRegistry) {
          mergeComponentAttrsToTrace(componentName, thisType);
        }
        if (_module.layoutAttributes) {
          extendFlat(exports.traceLayoutAttributes, _module.layoutAttributes);
        }
        var basePlotModule = _module.basePlotModule;
        var bpmName = basePlotModule.name;
        if (bpmName === "mapbox") {
          var styleRules = basePlotModule.constants.styleRules;
          for (var k in styleRules) {
            addStyleRule(".js-plotly-plot .plotly .mapboxgl-" + k, styleRules[k]);
          }
        }
        if (bpmName === "map") {
          init_maplibre_gl2();
        }
        if ((bpmName === "geo" || bpmName === "mapbox" || bpmName === "map") && window.PlotlyGeoAssets === void 0) {
          window.PlotlyGeoAssets = { topojson: {} };
        }
      }
      function registerSubplot(_module) {
        var plotType = _module.name;
        if (exports.subplotsRegistry[plotType]) {
          Loggers.log("Plot type " + plotType + " already registered.");
          return;
        }
        findArrayRegexps(_module);
        exports.subplotsRegistry[plotType] = _module;
        for (var componentName in exports.componentsRegistry) {
          mergeComponentAttrsToSubplot(componentName, _module.name);
        }
      }
      function registerComponentModule(_module) {
        if (typeof _module.name !== "string") {
          throw new Error("Component module *name* must be a string.");
        }
        var name = _module.name;
        exports.componentsRegistry[name] = _module;
        if (_module.layoutAttributes) {
          if (_module.layoutAttributes._isLinkedToArray) {
            pushUnique(exports.layoutArrayContainers, name);
          }
          findArrayRegexps(_module);
        }
        for (var traceType in exports.modules) {
          mergeComponentAttrsToTrace(name, traceType);
        }
        for (var subplotName in exports.subplotsRegistry) {
          mergeComponentAttrsToSubplot(name, subplotName);
        }
        if (_module.schema && _module.schema.layout) {
          extendDeepAll(baseLayoutAttributes, _module.schema.layout);
        }
      }
      function registerTransformModule(_module) {
        if (typeof _module.name !== "string") {
          throw new Error("Transform module *name* must be a string.");
        }
        var prefix = "Transform module " + _module.name;
        var hasTransform = typeof _module.transform === "function";
        var hasCalcTransform = typeof _module.calcTransform === "function";
        if (!hasTransform && !hasCalcTransform) {
          throw new Error(prefix + " is missing a *transform* or *calcTransform* method.");
        }
        if (hasTransform && hasCalcTransform) {
          Loggers.log([
            prefix + " has both a *transform* and *calcTransform* methods.",
            "Please note that all *transform* methods are executed",
            "before all *calcTransform* methods."
          ].join(" "));
        }
        if (!isPlainObject(_module.attributes)) {
          Loggers.log(prefix + " registered without an *attributes* object.");
        }
        if (typeof _module.supplyDefaults !== "function") {
          Loggers.log(prefix + " registered without a *supplyDefaults* method.");
        }
      }
      function registerLocale(_module) {
        var locale = _module.name;
        var baseLocale = locale.split("-")[0];
        var newDict = _module.dictionary;
        var newFormat = _module.format;
        var hasDict = newDict && Object.keys(newDict).length;
        var hasFormat = newFormat && Object.keys(newFormat).length;
        var locales = exports.localeRegistry;
        var localeObj = locales[locale];
        if (!localeObj) locales[locale] = localeObj = {};
        if (baseLocale !== locale) {
          var baseLocaleObj = locales[baseLocale];
          if (!baseLocaleObj) locales[baseLocale] = baseLocaleObj = {};
          if (hasDict && baseLocaleObj.dictionary === localeObj.dictionary) {
            baseLocaleObj.dictionary = newDict;
          }
          if (hasFormat && baseLocaleObj.format === localeObj.format) {
            baseLocaleObj.format = newFormat;
          }
        }
        if (hasDict) localeObj.dictionary = newDict;
        if (hasFormat) localeObj.format = newFormat;
      }
      function findArrayRegexps(_module) {
        if (_module.layoutAttributes) {
          var arrayAttrRegexps = _module.layoutAttributes._arrayAttrRegexps;
          if (arrayAttrRegexps) {
            for (var i = 0; i < arrayAttrRegexps.length; i++) {
              pushUnique(exports.layoutArrayRegexes, arrayAttrRegexps[i]);
            }
          }
        }
      }
      function mergeComponentAttrsToTrace(componentName, traceType) {
        var componentSchema = exports.componentsRegistry[componentName].schema;
        if (!componentSchema || !componentSchema.traces) return;
        var traceAttrs = componentSchema.traces[traceType];
        if (traceAttrs) {
          extendDeepAll(exports.modules[traceType]._module.attributes, traceAttrs);
        }
      }
      function mergeComponentAttrsToSubplot(componentName, subplotName) {
        var componentSchema = exports.componentsRegistry[componentName].schema;
        if (!componentSchema || !componentSchema.subplots) return;
        var subplotModule = exports.subplotsRegistry[subplotName];
        var subplotAttrs = subplotModule.layoutAttributes;
        var subplotAttr = subplotModule.attr === "subplot" ? subplotModule.name : subplotModule.attr;
        if (Array.isArray(subplotAttr)) subplotAttr = subplotAttr[0];
        var componentLayoutAttrs = componentSchema.subplots[subplotAttr];
        if (subplotAttrs && componentLayoutAttrs) {
          extendDeepAll(subplotAttrs, componentLayoutAttrs);
        }
      }
      function getTraceType(traceType) {
        if (typeof traceType === "object") traceType = traceType.type;
        return traceType;
      }
    }
  });

  // src/lib/dates.js
  var require_dates = __commonJS({
    "src/lib/dates.js"(exports) {
      "use strict";
      var timeFormat = require_d3_time_format().timeFormat;
      var isNumeric = require_fast_isnumeric();
      var Loggers = require_loggers();
      var mod = require_mod().mod;
      var constants = require_numerical();
      var BADNUM = constants.BADNUM;
      var ONEDAY = constants.ONEDAY;
      var ONEHOUR = constants.ONEHOUR;
      var ONEMIN = constants.ONEMIN;
      var ONESEC = constants.ONESEC;
      var EPOCHJD = constants.EPOCHJD;
      var Registry = require_registry();
      var utcFormat = require_d3_time_format().utcFormat;
      var DATETIME_REGEXP = /^\s*(-?\d\d\d\d|\d\d)(-(\d?\d)(-(\d?\d)([ Tt]([01]?\d|2[0-3])(:([0-5]\d)(:([0-5]\d(\.\d+)?))?(Z|z|[+\-]\d\d(:?\d\d)?)?)?)?)?)?\s*$/m;
      var DATETIME_REGEXP_CN = /^\s*(-?\d\d\d\d|\d\d)(-(\d?\di?)(-(\d?\d)([ Tt]([01]?\d|2[0-3])(:([0-5]\d)(:([0-5]\d(\.\d+)?))?(Z|z|[+\-]\d\d(:?\d\d)?)?)?)?)?)?\s*$/m;
      var YFIRST = (/* @__PURE__ */ new Date()).getFullYear() - 70;
      function isWorldCalendar(calendar) {
        return calendar && Registry.componentsRegistry.calendars && typeof calendar === "string" && calendar !== "gregorian";
      }
      exports.dateTick0 = function(calendar, dayOfWeek) {
        var tick0 = _dateTick0(calendar, !!dayOfWeek);
        if (dayOfWeek < 2) return tick0;
        var v = exports.dateTime2ms(tick0, calendar);
        v += ONEDAY * (dayOfWeek - 1);
        return exports.ms2DateTime(v, 0, calendar);
      };
      function _dateTick0(calendar, sunday) {
        if (isWorldCalendar(calendar)) {
          return sunday ? Registry.getComponentMethod("calendars", "CANONICAL_SUNDAY")[calendar] : Registry.getComponentMethod("calendars", "CANONICAL_TICK")[calendar];
        } else {
          return sunday ? "2000-01-02" : "2000-01-01";
        }
      }
      exports.dfltRange = function(calendar) {
        if (isWorldCalendar(calendar)) {
          return Registry.getComponentMethod("calendars", "DFLTRANGE")[calendar];
        } else {
          return ["2000-01-01", "2001-01-01"];
        }
      };
      exports.isJSDate = function(v) {
        return typeof v === "object" && v !== null && typeof v.getTime === "function";
      };
      var MIN_MS;
      var MAX_MS;
      exports.dateTime2ms = function(s, calendar) {
        if (exports.isJSDate(s)) {
          var tzOffset = s.getTimezoneOffset() * ONEMIN;
          var offsetTweak = (s.getUTCMinutes() - s.getMinutes()) * ONEMIN + (s.getUTCSeconds() - s.getSeconds()) * ONESEC + (s.getUTCMilliseconds() - s.getMilliseconds());
          if (offsetTweak) {
            var comb = 3 * ONEMIN;
            tzOffset = tzOffset - comb / 2 + mod(offsetTweak - tzOffset + comb / 2, comb);
          }
          s = Number(s) - tzOffset;
          if (s >= MIN_MS && s <= MAX_MS) return s;
          return BADNUM;
        }
        if (typeof s !== "string" && typeof s !== "number") return BADNUM;
        s = String(s);
        var isWorld = isWorldCalendar(calendar);
        var s0 = s.charAt(0);
        if (isWorld && (s0 === "G" || s0 === "g")) {
          s = s.substr(1);
          calendar = "";
        }
        var isChinese = isWorld && calendar.substr(0, 7) === "chinese";
        var match = s.match(isChinese ? DATETIME_REGEXP_CN : DATETIME_REGEXP);
        if (!match) return BADNUM;
        var y = match[1];
        var m = match[3] || "1";
        var d = Number(match[5] || 1);
        var H = Number(match[7] || 0);
        var M = Number(match[9] || 0);
        var S = Number(match[11] || 0);
        if (isWorld) {
          if (y.length === 2) return BADNUM;
          y = Number(y);
          var cDate;
          try {
            var calInstance = Registry.getComponentMethod("calendars", "getCal")(calendar);
            if (isChinese) {
              var isIntercalary = m.charAt(m.length - 1) === "i";
              m = parseInt(m, 10);
              cDate = calInstance.newDate(y, calInstance.toMonthIndex(y, m, isIntercalary), d);
            } else {
              cDate = calInstance.newDate(y, Number(m), d);
            }
          } catch (e) {
            return BADNUM;
          }
          if (!cDate) return BADNUM;
          return (cDate.toJD() - EPOCHJD) * ONEDAY + H * ONEHOUR + M * ONEMIN + S * ONESEC;
        }
        if (y.length === 2) {
          y = (Number(y) + 2e3 - YFIRST) % 100 + YFIRST;
        } else y = Number(y);
        m -= 1;
        var date = new Date(Date.UTC(2e3, m, d, H, M));
        date.setUTCFullYear(y);
        if (date.getUTCMonth() !== m) return BADNUM;
        if (date.getUTCDate() !== d) return BADNUM;
        return date.getTime() + S * ONESEC;
      };
      MIN_MS = exports.MIN_MS = exports.dateTime2ms("-9999");
      MAX_MS = exports.MAX_MS = exports.dateTime2ms("9999-12-31 23:59:59.9999");
      exports.isDateTime = function(s, calendar) {
        return exports.dateTime2ms(s, calendar) !== BADNUM;
      };
      function lpad(val, digits) {
        return String(val + Math.pow(10, digits)).substr(1);
      }
      var NINETYDAYS = 90 * ONEDAY;
      var THREEHOURS = 3 * ONEHOUR;
      var FIVEMIN = 5 * ONEMIN;
      exports.ms2DateTime = function(ms, r, calendar) {
        if (typeof ms !== "number" || !(ms >= MIN_MS && ms <= MAX_MS)) return BADNUM;
        if (!r) r = 0;
        var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10);
        var msRounded = Math.round(ms - msecTenths / 10);
        var dateStr, h, m, s, msec10, d;
        if (isWorldCalendar(calendar)) {
          var dateJD = Math.floor(msRounded / ONEDAY) + EPOCHJD;
          var timeMs = Math.floor(mod(ms, ONEDAY));
          try {
            dateStr = Registry.getComponentMethod("calendars", "getCal")(calendar).fromJD(dateJD).formatDate("yyyy-mm-dd");
          } catch (e) {
            dateStr = utcFormat("G%Y-%m-%d")(new Date(msRounded));
          }
          if (dateStr.charAt(0) === "-") {
            while (dateStr.length < 11) dateStr = "-0" + dateStr.substr(1);
          } else {
            while (dateStr.length < 10) dateStr = "0" + dateStr;
          }
          h = r < NINETYDAYS ? Math.floor(timeMs / ONEHOUR) : 0;
          m = r < NINETYDAYS ? Math.floor(timeMs % ONEHOUR / ONEMIN) : 0;
          s = r < THREEHOURS ? Math.floor(timeMs % ONEMIN / ONESEC) : 0;
          msec10 = r < FIVEMIN ? timeMs % ONESEC * 10 + msecTenths : 0;
        } else {
          d = new Date(msRounded);
          dateStr = utcFormat("%Y-%m-%d")(d);
          h = r < NINETYDAYS ? d.getUTCHours() : 0;
          m = r < NINETYDAYS ? d.getUTCMinutes() : 0;
          s = r < THREEHOURS ? d.getUTCSeconds() : 0;
          msec10 = r < FIVEMIN ? d.getUTCMilliseconds() * 10 + msecTenths : 0;
        }
        return includeTime(dateStr, h, m, s, msec10);
      };
      exports.ms2DateTimeLocal = function(ms) {
        if (!(ms >= MIN_MS + ONEDAY && ms <= MAX_MS - ONEDAY)) return BADNUM;
        var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10);
        var d = new Date(Math.round(ms - msecTenths / 10));
        var dateStr = timeFormat("%Y-%m-%d")(d);
        var h = d.getHours();
        var m = d.getMinutes();
        var s = d.getSeconds();
        var msec10 = d.getUTCMilliseconds() * 10 + msecTenths;
        return includeTime(dateStr, h, m, s, msec10);
      };
      function includeTime(dateStr, h, m, s, msec10) {
        if (h || m || s || msec10) {
          dateStr += " " + lpad(h, 2) + ":" + lpad(m, 2);
          if (s || msec10) {
            dateStr += ":" + lpad(s, 2);
            if (msec10) {
              var digits = 4;
              while (msec10 % 10 === 0) {
                digits -= 1;
                msec10 /= 10;
              }
              dateStr += "." + lpad(msec10, digits);
            }
          }
        }
        return dateStr;
      }
      exports.cleanDate = function(v, dflt, calendar) {
        if (v === BADNUM) return dflt;
        if (exports.isJSDate(v) || typeof v === "number" && isFinite(v)) {
          if (isWorldCalendar(calendar)) {
            Loggers.error("JS Dates and milliseconds are incompatible with world calendars", v);
            return dflt;
          }
          v = exports.ms2DateTimeLocal(+v);
          if (!v && dflt !== void 0) return dflt;
        } else if (!exports.isDateTime(v, calendar)) {
          Loggers.error("unrecognized date", v);
          return dflt;
        }
        return v;
      };
      var fracMatch = /%\d?f/g;
      var halfYearMatch = /%h/g;
      var quarterToHalfYear = {
        1: "1",
        2: "1",
        3: "2",
        4: "2"
      };
      function modDateFormat(fmt, x, formatter, calendar) {
        fmt = fmt.replace(fracMatch, function(match) {
          var digits = Math.min(+match.charAt(1) || 6, 6);
          var fracSecs = (x / 1e3 % 1 + 2).toFixed(digits).substr(2).replace(/0+$/, "") || "0";
          return fracSecs;
        });
        var d = new Date(Math.floor(x + 0.05));
        fmt = fmt.replace(halfYearMatch, function() {
          return quarterToHalfYear[formatter("%q")(d)];
        });
        if (isWorldCalendar(calendar)) {
          try {
            fmt = Registry.getComponentMethod("calendars", "worldCalFmt")(fmt, x, calendar);
          } catch (e) {
            return "Invalid";
          }
        }
        return formatter(fmt)(d);
      }
      var MAXSECONDS = [59, 59.9, 59.99, 59.999, 59.9999];
      function formatTime(x, tr) {
        var timePart = mod(x + 0.05, ONEDAY);
        var timeStr = lpad(Math.floor(timePart / ONEHOUR), 2) + ":" + lpad(mod(Math.floor(timePart / ONEMIN), 60), 2);
        if (tr !== "M") {
          if (!isNumeric(tr)) tr = 0;
          var sec = Math.min(mod(x / ONESEC, 60), MAXSECONDS[tr]);
          var secStr = (100 + sec).toFixed(tr).substr(1);
          if (tr > 0) {
            secStr = secStr.replace(/0+$/, "").replace(/[\.]$/, "");
          }
          timeStr += ":" + secStr;
        }
        return timeStr;
      }
      exports.formatDate = function(x, fmt, tr, formatter, calendar, extraFormat) {
        calendar = isWorldCalendar(calendar) && calendar;
        if (!fmt) {
          if (tr === "y") fmt = extraFormat.year;
          else if (tr === "m") fmt = extraFormat.month;
          else if (tr === "d") {
            fmt = extraFormat.dayMonth + "\n" + extraFormat.year;
          } else {
            return formatTime(x, tr) + "\n" + modDateFormat(extraFormat.dayMonthYear, x, formatter, calendar);
          }
        }
        return modDateFormat(fmt, x, formatter, calendar);
      };
      var THREEDAYS = 3 * ONEDAY;
      exports.incrementMonth = function(ms, dMonth, calendar) {
        calendar = isWorldCalendar(calendar) && calendar;
        var timeMs = mod(ms, ONEDAY);
        ms = Math.round(ms - timeMs);
        if (calendar) {
          try {
            var dateJD = Math.round(ms / ONEDAY) + EPOCHJD;
            var calInstance = Registry.getComponentMethod("calendars", "getCal")(calendar);
            var cDate = calInstance.fromJD(dateJD);
            if (dMonth % 12) calInstance.add(cDate, dMonth, "m");
            else calInstance.add(cDate, dMonth / 12, "y");
            return (cDate.toJD() - EPOCHJD) * ONEDAY + timeMs;
          } catch (e) {
            Loggers.error("invalid ms " + ms + " in calendar " + calendar);
          }
        }
        var y = new Date(ms + THREEDAYS);
        return y.setUTCMonth(y.getUTCMonth() + dMonth) + timeMs - THREEDAYS;
      };
      exports.findExactDates = function(data, calendar) {
        var exactYears = 0;
        var exactMonths = 0;
        var exactDays = 0;
        var blankCount = 0;
        var d;
        var di;
        var calInstance = isWorldCalendar(calendar) && Registry.getComponentMethod("calendars", "getCal")(calendar);
        for (var i = 0; i < data.length; i++) {
          di = data[i];
          if (!isNumeric(di)) {
            blankCount++;
            continue;
          }
          if (di % ONEDAY) continue;
          if (calInstance) {
            try {
              d = calInstance.fromJD(di / ONEDAY + EPOCHJD);
              if (d.day() === 1) {
                if (d.month() === 1) exactYears++;
                else exactMonths++;
              } else exactDays++;
            } catch (e) {
            }
          } else {
            d = new Date(di);
            if (d.getUTCDate() === 1) {
              if (d.getUTCMonth() === 0) exactYears++;
              else exactMonths++;
            } else exactDays++;
          }
        }
        exactMonths += exactYears;
        exactDays += exactMonths;
        var dataCount = data.length - blankCount;
        return {
          exactYears: exactYears / dataCount,
          exactMonths: exactMonths / dataCount,
          exactDays: exactDays / dataCount
        };
      };
    }
  });

  // src/lib/identity.js
  var require_identity2 = __commonJS({
    "src/lib/identity.js"(exports, module) {
      "use strict";
      module.exports = function identity(d) {
        return d;
      };
    }
  });

  // src/lib/search.js
  var require_search = __commonJS({
    "src/lib/search.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var loggers = require_loggers();
      var identity = require_identity2();
      var BADNUM = require_numerical().BADNUM;
      var roundingError = 1e-9;
      exports.findBin = function(val, bins, linelow) {
        if (isNumeric(bins.start)) {
          return linelow ? Math.ceil((val - bins.start) / bins.size - roundingError) - 1 : Math.floor((val - bins.start) / bins.size + roundingError);
        } else {
          var n1 = 0;
          var n2 = bins.length;
          var c = 0;
          var binSize = n2 > 1 ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;
          var n, test;
          if (binSize >= 0) {
            test = linelow ? lessThan : lessOrEqual;
          } else {
            test = linelow ? greaterOrEqual : greaterThan;
          }
          val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1);
          while (n1 < n2 && c++ < 100) {
            n = Math.floor((n1 + n2) / 2);
            if (test(bins[n], val)) n1 = n + 1;
            else n2 = n;
          }
          if (c > 90) loggers.log("Long binary search...");
          return n1 - 1;
        }
      };
      function lessThan(a, b) {
        return a < b;
      }
      function lessOrEqual(a, b) {
        return a <= b;
      }
      function greaterThan(a, b) {
        return a > b;
      }
      function greaterOrEqual(a, b) {
        return a >= b;
      }
      exports.sorterAsc = function(a, b) {
        return a - b;
      };
      exports.sorterDes = function(a, b) {
        return b - a;
      };
      exports.distinctVals = function(valsIn) {
        var vals = valsIn.slice();
        vals.sort(exports.sorterAsc);
        var last;
        for (last = vals.length - 1; last > -1; last--) {
          if (vals[last] !== BADNUM) break;
        }
        var minDiff = vals[last] - vals[0] || 1;
        var errDiff = minDiff / (last || 1) / 1e4;
        var newVals = [];
        var preV;
        for (var i = 0; i <= last; i++) {
          var v = vals[i];
          var diff = v - preV;
          if (preV === void 0) {
            newVals.push(v);
            preV = v;
          } else if (diff > errDiff) {
            minDiff = Math.min(minDiff, diff);
            newVals.push(v);
            preV = v;
          }
        }
        return { vals: newVals, minDiff };
      };
      exports.roundUp = function(val, arrayIn, reverse) {
        var low = 0;
        var high = arrayIn.length - 1;
        var mid;
        var c = 0;
        var dlow = reverse ? 0 : 1;
        var dhigh = reverse ? 1 : 0;
        var rounded = reverse ? Math.ceil : Math.floor;
        while (low < high && c++ < 100) {
          mid = rounded((low + high) / 2);
          if (arrayIn[mid] <= val) low = mid + dlow;
          else high = mid - dhigh;
        }
        return arrayIn[low];
      };
      exports.sort = function(array, sortFn) {
        var notOrdered = 0;
        var notReversed = 0;
        for (var i = 1; i < array.length; i++) {
          var pairOrder = sortFn(array[i], array[i - 1]);
          if (pairOrder < 0) notOrdered = 1;
          else if (pairOrder > 0) notReversed = 1;
          if (notOrdered && notReversed) return array.sort(sortFn);
        }
        return notReversed ? array : array.reverse();
      };
      exports.findIndexOfMin = function(arr, fn) {
        fn = fn || identity;
        var min = Infinity;
        var ind;
        for (var i = 0; i < arr.length; i++) {
          var v = fn(arr[i]);
          if (v < min) {
            min = v;
            ind = i;
          }
        }
        return ind;
      };
    }
  });

  // src/lib/sort_object_keys.js
  var require_sort_object_keys = __commonJS({
    "src/lib/sort_object_keys.js"(exports, module) {
      "use strict";
      module.exports = function sortObjectKeys(obj) {
        return Object.keys(obj).sort();
      };
    }
  });

  // src/lib/stats.js
  var require_stats = __commonJS({
    "src/lib/stats.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      exports.aggNums = function(f, v, a, len) {
        var i, b;
        if (!len || len > a.length) len = a.length;
        if (!isNumeric(v)) v = false;
        if (isArrayOrTypedArray(a[0])) {
          b = new Array(len);
          for (i = 0; i < len; i++) b[i] = exports.aggNums(f, v, a[i]);
          a = b;
        }
        for (i = 0; i < len; i++) {
          if (!isNumeric(v)) v = a[i];
          else if (isNumeric(a[i])) v = f(+v, +a[i]);
        }
        return v;
      };
      exports.len = function(data) {
        return exports.aggNums(function(a) {
          return a + 1;
        }, 0, data);
      };
      exports.mean = function(data, len) {
        if (!len) len = exports.len(data);
        return exports.aggNums(function(a, b) {
          return a + b;
        }, 0, data) / len;
      };
      exports.geometricMean = function(data, len) {
        if (!len) len = exports.len(data);
        return Math.pow(exports.aggNums(function(a, b) {
          return a * b;
        }, 1, data), 1 / len);
      };
      exports.midRange = function(numArr) {
        if (numArr === void 0 || numArr.length === 0) return void 0;
        return (exports.aggNums(Math.max, null, numArr) + exports.aggNums(Math.min, null, numArr)) / 2;
      };
      exports.variance = function(data, len, mean) {
        if (!len) len = exports.len(data);
        if (!isNumeric(mean)) mean = exports.mean(data, len);
        return exports.aggNums(function(a, b) {
          return a + Math.pow(b - mean, 2);
        }, 0, data) / len;
      };
      exports.stdev = function(data, len, mean) {
        return Math.sqrt(exports.variance(data, len, mean));
      };
      exports.median = function(data) {
        var b = data.slice().sort();
        return exports.interp(b, 0.5);
      };
      exports.interp = function(arr, n) {
        if (!isNumeric(n)) throw "n should be a finite number";
        n = n * arr.length - 0.5;
        if (n < 0) return arr[0];
        if (n > arr.length - 1) return arr[arr.length - 1];
        var frac = n % 1;
        return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];
      };
    }
  });

  // src/lib/angles.js
  var require_angles = __commonJS({
    "src/lib/angles.js"(exports, module) {
      "use strict";
      var modModule = require_mod();
      var mod = modModule.mod;
      var modHalf = modModule.modHalf;
      var PI = Math.PI;
      var twoPI = 2 * PI;
      function deg2rad(deg) {
        return deg / 180 * PI;
      }
      function rad2deg(rad) {
        return rad / PI * 180;
      }
      function isFullCircle(aBnds) {
        return Math.abs(aBnds[1] - aBnds[0]) > twoPI - 1e-14;
      }
      function angleDelta(a, b) {
        return modHalf(b - a, twoPI);
      }
      function angleDist(a, b) {
        return Math.abs(angleDelta(a, b));
      }
      function isAngleInsideSector(a, aBnds) {
        if (isFullCircle(aBnds)) return true;
        var s0, s1;
        if (aBnds[0] < aBnds[1]) {
          s0 = aBnds[0];
          s1 = aBnds[1];
        } else {
          s0 = aBnds[1];
          s1 = aBnds[0];
        }
        s0 = mod(s0, twoPI);
        s1 = mod(s1, twoPI);
        if (s0 > s1) s1 += twoPI;
        var a0 = mod(a, twoPI);
        var a1 = a0 + twoPI;
        return a0 >= s0 && a0 <= s1 || a1 >= s0 && a1 <= s1;
      }
      function isPtInsideSector(r, a, rBnds, aBnds) {
        if (!isAngleInsideSector(a, aBnds)) return false;
        var r0, r1;
        if (rBnds[0] < rBnds[1]) {
          r0 = rBnds[0];
          r1 = rBnds[1];
        } else {
          r0 = rBnds[1];
          r1 = rBnds[0];
        }
        return r >= r0 && r <= r1;
      }
      function _path(r0, r1, a0, a1, cx, cy, isClosed) {
        cx = cx || 0;
        cy = cy || 0;
        var isCircle = isFullCircle([a0, a1]);
        var aStart, aMid, aEnd;
        var rStart, rEnd;
        if (isCircle) {
          aStart = 0;
          aMid = PI;
          aEnd = twoPI;
        } else {
          if (a0 < a1) {
            aStart = a0;
            aEnd = a1;
          } else {
            aStart = a1;
            aEnd = a0;
          }
        }
        if (r0 < r1) {
          rStart = r0;
          rEnd = r1;
        } else {
          rStart = r1;
          rEnd = r0;
        }
        function pt(r, a) {
          return [r * Math.cos(a) + cx, cy - r * Math.sin(a)];
        }
        var largeArc = Math.abs(aEnd - aStart) <= PI ? 0 : 1;
        function arc(r, a, cw) {
          return "A" + [r, r] + " " + [0, largeArc, cw] + " " + pt(r, a);
        }
        var p;
        if (isCircle) {
          if (rStart === null) {
            p = "M" + pt(rEnd, aStart) + arc(rEnd, aMid, 0) + arc(rEnd, aEnd, 0) + "Z";
          } else {
            p = "M" + pt(rStart, aStart) + arc(rStart, aMid, 0) + arc(rStart, aEnd, 0) + "ZM" + pt(rEnd, aStart) + arc(rEnd, aMid, 1) + arc(rEnd, aEnd, 1) + "Z";
          }
        } else {
          if (rStart === null) {
            p = "M" + pt(rEnd, aStart) + arc(rEnd, aEnd, 0);
            if (isClosed) p += "L0,0Z";
          } else {
            p = "M" + pt(rStart, aStart) + "L" + pt(rEnd, aStart) + arc(rEnd, aEnd, 0) + "L" + pt(rStart, aEnd) + arc(rStart, aStart, 1) + "Z";
          }
        }
        return p;
      }
      function pathArc(r, a0, a1, cx, cy) {
        return _path(null, r, a0, a1, cx, cy, 0);
      }
      function pathSector(r, a0, a1, cx, cy) {
        return _path(null, r, a0, a1, cx, cy, 1);
      }
      function pathAnnulus(r0, r1, a0, a1, cx, cy) {
        return _path(r0, r1, a0, a1, cx, cy, 1);
      }
      module.exports = {
        deg2rad,
        rad2deg,
        angleDelta,
        angleDist,
        isFullCircle,
        isAngleInsideSector,
        isPtInsideSector,
        pathArc,
        pathSector,
        pathAnnulus
      };
    }
  });

  // src/lib/anchor_utils.js
  var require_anchor_utils = __commonJS({
    "src/lib/anchor_utils.js"(exports) {
      "use strict";
      exports.isLeftAnchor = function isLeftAnchor(opts) {
        return opts.xanchor === "left" || opts.xanchor === "auto" && opts.x <= 1 / 3;
      };
      exports.isCenterAnchor = function isCenterAnchor(opts) {
        return opts.xanchor === "center" || opts.xanchor === "auto" && opts.x > 1 / 3 && opts.x < 2 / 3;
      };
      exports.isRightAnchor = function isRightAnchor(opts) {
        return opts.xanchor === "right" || opts.xanchor === "auto" && opts.x >= 2 / 3;
      };
      exports.isTopAnchor = function isTopAnchor(opts) {
        return opts.yanchor === "top" || opts.yanchor === "auto" && opts.y >= 2 / 3;
      };
      exports.isMiddleAnchor = function isMiddleAnchor(opts) {
        return opts.yanchor === "middle" || opts.yanchor === "auto" && opts.y > 1 / 3 && opts.y < 2 / 3;
      };
      exports.isBottomAnchor = function isBottomAnchor(opts) {
        return opts.yanchor === "bottom" || opts.yanchor === "auto" && opts.y <= 1 / 3;
      };
    }
  });

  // src/lib/geometry2d.js
  var require_geometry2d = __commonJS({
    "src/lib/geometry2d.js"(exports) {
      "use strict";
      var mod = require_mod().mod;
      exports.segmentsIntersect = segmentsIntersect;
      function segmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        var a = x2 - x1;
        var b = x3 - x1;
        var c = x4 - x3;
        var d = y2 - y1;
        var e = y3 - y1;
        var f = y4 - y3;
        var det = a * f - c * d;
        if (det === 0) return null;
        var t = (b * f - c * e) / det;
        var u = (b * d - a * e) / det;
        if (u < 0 || u > 1 || t < 0 || t > 1) return null;
        return { x: x1 + a * t, y: y1 + d * t };
      }
      exports.segmentDistance = function segmentDistance(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (segmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4)) return 0;
        var x12 = x2 - x1;
        var y12 = y2 - y1;
        var x34 = x4 - x3;
        var y34 = y4 - y3;
        var ll12 = x12 * x12 + y12 * y12;
        var ll34 = x34 * x34 + y34 * y34;
        var dist2 = Math.min(
          perpDistance2(x12, y12, ll12, x3 - x1, y3 - y1),
          perpDistance2(x12, y12, ll12, x4 - x1, y4 - y1),
          perpDistance2(x34, y34, ll34, x1 - x3, y1 - y3),
          perpDistance2(x34, y34, ll34, x2 - x3, y2 - y3)
        );
        return Math.sqrt(dist2);
      };
      function perpDistance2(xab, yab, llab, xac, yac) {
        var fcAB = xac * xab + yac * yab;
        if (fcAB < 0) {
          return xac * xac + yac * yac;
        } else if (fcAB > llab) {
          var xbc = xac - xab;
          var ybc = yac - yab;
          return xbc * xbc + ybc * ybc;
        } else {
          var crossProduct = xac * yab - yac * xab;
          return crossProduct * crossProduct / llab;
        }
      }
      var locationCache;
      var workingPath;
      var workingTextWidth;
      exports.getTextLocation = function getTextLocation(path, totalPathLen, positionOnPath, textWidth) {
        if (path !== workingPath || textWidth !== workingTextWidth) {
          locationCache = {};
          workingPath = path;
          workingTextWidth = textWidth;
        }
        if (locationCache[positionOnPath]) {
          return locationCache[positionOnPath];
        }
        var p0 = path.getPointAtLength(mod(positionOnPath - textWidth / 2, totalPathLen));
        var p1 = path.getPointAtLength(mod(positionOnPath + textWidth / 2, totalPathLen));
        var theta = Math.atan((p1.y - p0.y) / (p1.x - p0.x));
        var pCenter = path.getPointAtLength(mod(positionOnPath, totalPathLen));
        var x = (pCenter.x * 4 + p0.x + p1.x) / 6;
        var y = (pCenter.y * 4 + p0.y + p1.y) / 6;
        var out = { x, y, theta };
        locationCache[positionOnPath] = out;
        return out;
      };
      exports.clearLocationCache = function() {
        workingPath = null;
      };
      exports.getVisibleSegment = function getVisibleSegment(path, bounds, buffer) {
        var left = bounds.left;
        var right = bounds.right;
        var top = bounds.top;
        var bottom = bounds.bottom;
        var pMin = 0;
        var pTotal = path.getTotalLength();
        var pMax = pTotal;
        var pt0, ptTotal;
        function getDistToPlot(len) {
          var pt = path.getPointAtLength(len);
          if (len === 0) pt0 = pt;
          else if (len === pTotal) ptTotal = pt;
          var dx = pt.x < left ? left - pt.x : pt.x > right ? pt.x - right : 0;
          var dy = pt.y < top ? top - pt.y : pt.y > bottom ? pt.y - bottom : 0;
          return Math.sqrt(dx * dx + dy * dy);
        }
        var distToPlot = getDistToPlot(pMin);
        while (distToPlot) {
          pMin += distToPlot + buffer;
          if (pMin > pMax) return;
          distToPlot = getDistToPlot(pMin);
        }
        distToPlot = getDistToPlot(pMax);
        while (distToPlot) {
          pMax -= distToPlot + buffer;
          if (pMin > pMax) return;
          distToPlot = getDistToPlot(pMax);
        }
        return {
          min: pMin,
          max: pMax,
          len: pMax - pMin,
          total: pTotal,
          isClosed: pMin === 0 && pMax === pTotal && Math.abs(pt0.x - ptTotal.x) < 0.1 && Math.abs(pt0.y - ptTotal.y) < 0.1
        };
      };
      exports.findPointOnPath = function findPointOnPath(path, val, coord, opts) {
        opts = opts || {};
        var pathLength = opts.pathLength || path.getTotalLength();
        var tolerance = opts.tolerance || 1e-3;
        var iterationLimit = opts.iterationLimit || 30;
        var mul = path.getPointAtLength(0)[coord] > path.getPointAtLength(pathLength)[coord] ? -1 : 1;
        var i = 0;
        var b0 = 0;
        var b1 = pathLength;
        var mid;
        var pt;
        var diff;
        while (i < iterationLimit) {
          mid = (b0 + b1) / 2;
          pt = path.getPointAtLength(mid);
          diff = pt[coord] - val;
          if (Math.abs(diff) < tolerance) {
            return pt;
          } else {
            if (mul * diff > 0) {
              b1 = mid;
            } else {
              b0 = mid;
            }
            i++;
          }
        }
        return pt;
      };
    }
  });

  // src/lib/throttle.js
  var require_throttle = __commonJS({
    "src/lib/throttle.js"(exports) {
      "use strict";
      var timerCache = {};
      exports.throttle = function throttle(id, minInterval, callback) {
        var cache = timerCache[id];
        var now = Date.now();
        if (!cache) {
          for (var idi in timerCache) {
            if (timerCache[idi].ts < now - 6e4) {
              delete timerCache[idi];
            }
          }
          cache = timerCache[id] = { ts: 0, timer: null };
        }
        _clearTimeout(cache);
        function exec() {
          callback();
          cache.ts = Date.now();
          if (cache.onDone) {
            cache.onDone();
            cache.onDone = null;
          }
        }
        if (now > cache.ts + minInterval) {
          exec();
          return;
        }
        cache.timer = setTimeout(function() {
          exec();
          cache.timer = null;
        }, minInterval);
      };
      exports.done = function(id) {
        var cache = timerCache[id];
        if (!cache || !cache.timer) return Promise.resolve();
        return new Promise(function(resolve) {
          var previousOnDone = cache.onDone;
          cache.onDone = function onDone() {
            if (previousOnDone) previousOnDone();
            resolve();
            cache.onDone = null;
          };
        });
      };
      exports.clear = function(id) {
        if (id) {
          _clearTimeout(timerCache[id]);
          delete timerCache[id];
        } else {
          for (var idi in timerCache) exports.clear(idi);
        }
      };
      function _clearTimeout(cache) {
        if (cache && cache.timer !== null) {
          clearTimeout(cache.timer);
          cache.timer = null;
        }
      }
    }
  });

  // src/lib/clear_responsive.js
  var require_clear_responsive = __commonJS({
    "src/lib/clear_responsive.js"(exports, module) {
      "use strict";
      module.exports = function clearResponsive(gd) {
        if (gd._responsiveChartHandler) {
          window.removeEventListener("resize", gd._responsiveChartHandler);
          delete gd._responsiveChartHandler;
        }
      };
    }
  });

  // node_modules/is-mobile/index.js
  var require_is_mobile = __commonJS({
    "node_modules/is-mobile/index.js"(exports, module) {
      "use strict";
      module.exports = isMobile;
      module.exports.isMobile = isMobile;
      module.exports.default = isMobile;
      var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
      var notMobileRE = /CrOS/;
      var tabletRE = /android|ipad|playbook|silk/i;
      function isMobile(opts) {
        if (!opts) opts = {};
        let ua = opts.ua;
        if (!ua && typeof navigator !== "undefined") ua = navigator.userAgent;
        if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
          ua = ua.headers["user-agent"];
        }
        if (typeof ua !== "string") return false;
        let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
        if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
          result = true;
        }
        return result;
      }
    }
  });

  // src/lib/preserve_drawing_buffer.js
  var require_preserve_drawing_buffer = __commonJS({
    "src/lib/preserve_drawing_buffer.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isMobileOrTablet = require_is_mobile();
      module.exports = function preserveDrawingBuffer(opts) {
        var ua;
        if (opts && opts.hasOwnProperty("userAgent")) {
          ua = opts.userAgent;
        } else {
          ua = getUserAgent();
        }
        if (typeof ua !== "string") return true;
        var enable = isMobileOrTablet({
          ua: { headers: { "user-agent": ua } },
          tablet: true,
          featureDetect: false
        });
        if (!enable) {
          var allParts = ua.split(" ");
          for (var i = 1; i < allParts.length; i++) {
            var part = allParts[i];
            if (part.indexOf("Safari") !== -1) {
              for (var k = i - 1; k > -1; k--) {
                var prevPart = allParts[k];
                if (prevPart.substr(0, 8) === "Version/") {
                  var v = prevPart.substr(8).split(".")[0];
                  if (isNumeric(v)) v = +v;
                  if (v >= 13) return true;
                }
              }
            }
          }
        }
        return enable;
      };
      function getUserAgent() {
        var ua;
        if (typeof navigator !== "undefined") {
          ua = navigator.userAgent;
        }
        if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
          ua = ua.headers["user-agent"];
        }
        return ua;
      }
    }
  });

  // src/lib/make_trace_groups.js
  var require_make_trace_groups = __commonJS({
    "src/lib/make_trace_groups.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      module.exports = function makeTraceGroups(traceLayer, cdModule, cls) {
        var traces = traceLayer.selectAll("g." + cls.replace(/\s/g, ".")).data(cdModule, function(cd) {
          return cd[0].trace.uid;
        });
        traces.exit().remove();
        traces.enter().append("g").attr("class", cls);
        traces.order();
        var k = traceLayer.classed("rangeplot") ? "nodeRangePlot3" : "node3";
        traces.each(function(cd) {
          cd[0][k] = d3.select(this);
        });
        return traces;
      };
    }
  });

  // src/lib/localize.js
  var require_localize = __commonJS({
    "src/lib/localize.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      module.exports = function localize(gd, s) {
        var locale = gd._context.locale;
        for (var i = 0; i < 2; i++) {
          var locales = gd._context.locales;
          for (var j = 0; j < 2; j++) {
            var dict = (locales[locale] || {}).dictionary;
            if (dict) {
              var out = dict[s];
              if (out) return out;
            }
            locales = Registry.localeRegistry;
          }
          var baseLocale = locale.split("-")[0];
          if (baseLocale === locale) break;
          locale = baseLocale;
        }
        return s;
      };
    }
  });

  // src/lib/filter_unique.js
  var require_filter_unique = __commonJS({
    "src/lib/filter_unique.js"(exports, module) {
      "use strict";
      module.exports = function filterUnique(array) {
        var seen = {};
        var out = [];
        var j = 0;
        for (var i = 0; i < array.length; i++) {
          var item = array[i];
          if (seen[item] !== 1) {
            seen[item] = 1;
            out[j++] = item;
          }
        }
        return out;
      };
    }
  });

  // src/lib/filter_visible.js
  var require_filter_visible = __commonJS({
    "src/lib/filter_visible.js"(exports, module) {
      "use strict";
      module.exports = function filterVisible(container) {
        var filterFn = isCalcData(container) ? calcDataFilter : baseFilter;
        var out = [];
        for (var i = 0; i < container.length; i++) {
          var item = container[i];
          if (filterFn(item)) out.push(item);
        }
        return out;
      };
      function baseFilter(item) {
        return item.visible === true;
      }
      function calcDataFilter(item) {
        var trace = item[0].trace;
        return trace.visible === true && trace._length !== 0;
      }
      function isCalcData(cont) {
        return Array.isArray(cont) && Array.isArray(cont[0]) && cont[0][0] && cont[0][0].trace;
      }
    }
  });

  // src/lib/increment.js
  var require_increment = __commonJS({
    "src/lib/increment.js"(exports, module) {
      "use strict";
      module.exports = function incrementNumeric(x, delta) {
        if (!delta) return x;
        var scale = 1 / Math.abs(delta);
        var newX = scale > 1 ? (scale * x + scale * delta) / scale : x + delta;
        var lenX1 = String(newX).length;
        if (lenX1 > 16) {
          var lenDt = String(delta).length;
          var lenX0 = String(x).length;
          if (lenX1 >= lenX0 + lenDt) {
            var s = parseFloat(newX).toPrecision(12);
            if (s.indexOf("e+") === -1) newX = +s;
          }
        }
        return newX;
      };
    }
  });

  // src/lib/clean_number.js
  var require_clean_number = __commonJS({
    "src/lib/clean_number.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var BADNUM = require_numerical().BADNUM;
      var JUNK = /^['"%,$#\s']+|[, ]|['"%,$#\s']+$/g;
      module.exports = function cleanNumber(v) {
        if (typeof v === "string") {
          v = v.replace(JUNK, "");
        }
        if (isNumeric(v)) return Number(v);
        return BADNUM;
      };
    }
  });

  // src/lib/index.js
  var require_lib = __commonJS({
    "src/lib/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var utcFormat = require_d3_time_format().utcFormat;
      var d3Format = require_d3_format().format;
      var isNumeric = require_fast_isnumeric();
      var numConstants = require_numerical();
      var MAX_SAFE = numConstants.FP_SAFE;
      var MIN_SAFE = -MAX_SAFE;
      var BADNUM = numConstants.BADNUM;
      var lib = module.exports = {};
      lib.adjustFormat = function adjustFormat(formatStr) {
        if (!formatStr || /^\d[.]\df/.test(formatStr) || /[.]\d%/.test(formatStr)) return formatStr;
        if (formatStr === "0.f") return "~f";
        if (/^\d%/.test(formatStr)) return "~%";
        if (/^\ds/.test(formatStr)) return "~s";
        if (!/^[~,.0$]/.test(formatStr) && /[&fps]/.test(formatStr)) return "~" + formatStr;
        return formatStr;
      };
      var seenBadFormats = {};
      lib.warnBadFormat = function(f) {
        var key = String(f);
        if (!seenBadFormats[key]) {
          seenBadFormats[key] = 1;
          lib.warn('encountered bad format: "' + key + '"');
        }
      };
      lib.noFormat = function(value) {
        return String(value);
      };
      lib.numberFormat = function(formatStr) {
        var fn;
        try {
          fn = d3Format(lib.adjustFormat(formatStr));
        } catch (e) {
          lib.warnBadFormat(formatStr);
          return lib.noFormat;
        }
        return fn;
      };
      lib.nestedProperty = require_nested_property();
      lib.keyedContainer = require_keyed_container();
      lib.relativeAttr = require_relative_attr();
      lib.isPlainObject = require_is_plain_object();
      lib.toLogRange = require_to_log_range();
      lib.relinkPrivateKeys = require_relink_private();
      var arrayModule = require_array();
      lib.isArrayBuffer = arrayModule.isArrayBuffer;
      lib.isTypedArray = arrayModule.isTypedArray;
      lib.isArrayOrTypedArray = arrayModule.isArrayOrTypedArray;
      lib.isArray1D = arrayModule.isArray1D;
      lib.ensureArray = arrayModule.ensureArray;
      lib.concat = arrayModule.concat;
      lib.maxRowLength = arrayModule.maxRowLength;
      lib.minRowLength = arrayModule.minRowLength;
      var modModule = require_mod();
      lib.mod = modModule.mod;
      lib.modHalf = modModule.modHalf;
      var coerceModule = require_coerce();
      lib.valObjectMeta = coerceModule.valObjectMeta;
      lib.coerce = coerceModule.coerce;
      lib.coerce2 = coerceModule.coerce2;
      lib.coerceFont = coerceModule.coerceFont;
      lib.coercePattern = coerceModule.coercePattern;
      lib.coerceHoverinfo = coerceModule.coerceHoverinfo;
      lib.coerceSelectionMarkerOpacity = coerceModule.coerceSelectionMarkerOpacity;
      lib.validate = coerceModule.validate;
      var datesModule = require_dates();
      lib.dateTime2ms = datesModule.dateTime2ms;
      lib.isDateTime = datesModule.isDateTime;
      lib.ms2DateTime = datesModule.ms2DateTime;
      lib.ms2DateTimeLocal = datesModule.ms2DateTimeLocal;
      lib.cleanDate = datesModule.cleanDate;
      lib.isJSDate = datesModule.isJSDate;
      lib.formatDate = datesModule.formatDate;
      lib.incrementMonth = datesModule.incrementMonth;
      lib.dateTick0 = datesModule.dateTick0;
      lib.dfltRange = datesModule.dfltRange;
      lib.findExactDates = datesModule.findExactDates;
      lib.MIN_MS = datesModule.MIN_MS;
      lib.MAX_MS = datesModule.MAX_MS;
      var searchModule = require_search();
      lib.findBin = searchModule.findBin;
      lib.sorterAsc = searchModule.sorterAsc;
      lib.sorterDes = searchModule.sorterDes;
      lib.distinctVals = searchModule.distinctVals;
      lib.roundUp = searchModule.roundUp;
      lib.sort = searchModule.sort;
      lib.findIndexOfMin = searchModule.findIndexOfMin;
      lib.sortObjectKeys = require_sort_object_keys();
      var statsModule = require_stats();
      lib.aggNums = statsModule.aggNums;
      lib.len = statsModule.len;
      lib.mean = statsModule.mean;
      lib.geometricMean = statsModule.geometricMean;
      lib.median = statsModule.median;
      lib.midRange = statsModule.midRange;
      lib.variance = statsModule.variance;
      lib.stdev = statsModule.stdev;
      lib.interp = statsModule.interp;
      var matrixModule = require_matrix();
      lib.init2dArray = matrixModule.init2dArray;
      lib.transposeRagged = matrixModule.transposeRagged;
      lib.dot = matrixModule.dot;
      lib.translationMatrix = matrixModule.translationMatrix;
      lib.rotationMatrix = matrixModule.rotationMatrix;
      lib.rotationXYMatrix = matrixModule.rotationXYMatrix;
      lib.apply3DTransform = matrixModule.apply3DTransform;
      lib.apply2DTransform = matrixModule.apply2DTransform;
      lib.apply2DTransform2 = matrixModule.apply2DTransform2;
      lib.convertCssMatrix = matrixModule.convertCssMatrix;
      lib.inverseTransformMatrix = matrixModule.inverseTransformMatrix;
      var anglesModule = require_angles();
      lib.deg2rad = anglesModule.deg2rad;
      lib.rad2deg = anglesModule.rad2deg;
      lib.angleDelta = anglesModule.angleDelta;
      lib.angleDist = anglesModule.angleDist;
      lib.isFullCircle = anglesModule.isFullCircle;
      lib.isAngleInsideSector = anglesModule.isAngleInsideSector;
      lib.isPtInsideSector = anglesModule.isPtInsideSector;
      lib.pathArc = anglesModule.pathArc;
      lib.pathSector = anglesModule.pathSector;
      lib.pathAnnulus = anglesModule.pathAnnulus;
      var anchorUtils = require_anchor_utils();
      lib.isLeftAnchor = anchorUtils.isLeftAnchor;
      lib.isCenterAnchor = anchorUtils.isCenterAnchor;
      lib.isRightAnchor = anchorUtils.isRightAnchor;
      lib.isTopAnchor = anchorUtils.isTopAnchor;
      lib.isMiddleAnchor = anchorUtils.isMiddleAnchor;
      lib.isBottomAnchor = anchorUtils.isBottomAnchor;
      var geom2dModule = require_geometry2d();
      lib.segmentsIntersect = geom2dModule.segmentsIntersect;
      lib.segmentDistance = geom2dModule.segmentDistance;
      lib.getTextLocation = geom2dModule.getTextLocation;
      lib.clearLocationCache = geom2dModule.clearLocationCache;
      lib.getVisibleSegment = geom2dModule.getVisibleSegment;
      lib.findPointOnPath = geom2dModule.findPointOnPath;
      var extendModule = require_extend();
      lib.extendFlat = extendModule.extendFlat;
      lib.extendDeep = extendModule.extendDeep;
      lib.extendDeepAll = extendModule.extendDeepAll;
      lib.extendDeepNoArrays = extendModule.extendDeepNoArrays;
      var loggersModule = require_loggers();
      lib.log = loggersModule.log;
      lib.warn = loggersModule.warn;
      lib.error = loggersModule.error;
      var regexModule = require_regex();
      lib.counterRegex = regexModule.counter;
      var throttleModule = require_throttle();
      lib.throttle = throttleModule.throttle;
      lib.throttleDone = throttleModule.done;
      lib.clearThrottle = throttleModule.clear;
      var domModule = require_dom();
      lib.getGraphDiv = domModule.getGraphDiv;
      lib.isPlotDiv = domModule.isPlotDiv;
      lib.removeElement = domModule.removeElement;
      lib.addStyleRule = domModule.addStyleRule;
      lib.addRelatedStyleRule = domModule.addRelatedStyleRule;
      lib.deleteRelatedStyleRule = domModule.deleteRelatedStyleRule;
      lib.setStyleOnHover = domModule.setStyleOnHover;
      lib.getFullTransformMatrix = domModule.getFullTransformMatrix;
      lib.getElementTransformMatrix = domModule.getElementTransformMatrix;
      lib.getElementAndAncestors = domModule.getElementAndAncestors;
      lib.equalDomRects = domModule.equalDomRects;
      lib.clearResponsive = require_clear_responsive();
      lib.preserveDrawingBuffer = require_preserve_drawing_buffer();
      lib.makeTraceGroups = require_make_trace_groups();
      lib._ = require_localize();
      lib.notifier = require_notifier();
      lib.filterUnique = require_filter_unique();
      lib.filterVisible = require_filter_visible();
      lib.pushUnique = require_push_unique();
      lib.increment = require_increment();
      lib.cleanNumber = require_clean_number();
      lib.ensureNumber = function ensureNumber(v) {
        if (!isNumeric(v)) return BADNUM;
        v = Number(v);
        return v > MAX_SAFE || v < MIN_SAFE ? BADNUM : v;
      };
      lib.isIndex = function(v, len) {
        if (len !== void 0 && v >= len) return false;
        return isNumeric(v) && v >= 0 && v % 1 === 0;
      };
      lib.noop = require_noop();
      lib.identity = require_identity2();
      lib.repeat = function(v, cnt) {
        var out = new Array(cnt);
        for (var i = 0; i < cnt; i++) {
          out[i] = v;
        }
        return out;
      };
      lib.swapAttrs = function(cont, attrList, part1, part2) {
        if (!part1) part1 = "x";
        if (!part2) part2 = "y";
        for (var i = 0; i < attrList.length; i++) {
          var attr = attrList[i];
          var xp = lib.nestedProperty(cont, attr.replace("?", part1));
          var yp = lib.nestedProperty(cont, attr.replace("?", part2));
          var temp = xp.get();
          xp.set(yp.get());
          yp.set(temp);
        }
      };
      lib.raiseToTop = function raiseToTop(elem) {
        elem.parentNode.appendChild(elem);
      };
      lib.cancelTransition = function(selection) {
        return selection.transition().duration(0);
      };
      lib.constrain = function(v, v0, v1) {
        if (v0 > v1) return Math.max(v1, Math.min(v0, v));
        return Math.max(v0, Math.min(v1, v));
      };
      lib.bBoxIntersect = function(a, b, pad) {
        pad = pad || 0;
        return a.left <= b.right + pad && b.left <= a.right + pad && a.top <= b.bottom + pad && b.top <= a.bottom + pad;
      };
      lib.simpleMap = function(array, func, x1, x2, opts) {
        var len = array.length;
        var out = new Array(len);
        for (var i = 0; i < len; i++) out[i] = func(array[i], x1, x2, opts);
        return out;
      };
      lib.randstr = function randstr(existing, bits, base, _recursion) {
        if (!base) base = 16;
        if (bits === void 0) bits = 24;
        if (bits <= 0) return "0";
        var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
        var res = "";
        var i, b, x;
        for (i = 2; digits === Infinity; i *= 2) {
          digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
        }
        var rem = digits - Math.floor(digits);
        for (i = 0; i < Math.floor(digits); i++) {
          x = Math.floor(Math.random() * base).toString(base);
          res = x + res;
        }
        if (rem) {
          b = Math.pow(base, rem);
          x = Math.floor(Math.random() * b).toString(base);
          res = x + res;
        }
        var parsed = parseInt(res, base);
        if (existing && existing[res] || parsed !== Infinity && parsed >= Math.pow(2, bits)) {
          if (_recursion > 10) {
            lib.warn("randstr failed uniqueness");
            return res;
          }
          return randstr(existing, bits, base, (_recursion || 0) + 1);
        } else return res;
      };
      lib.OptionControl = function(opt, optname) {
        if (!opt) opt = {};
        if (!optname) optname = "opt";
        var self2 = {};
        self2.optionList = [];
        self2._newoption = function(optObj) {
          optObj[optname] = opt;
          self2[optObj.name] = optObj;
          self2.optionList.push(optObj);
        };
        self2["_" + optname] = opt;
        return self2;
      };
      lib.smooth = function(arrayIn, FWHM) {
        FWHM = Math.round(FWHM) || 0;
        if (FWHM < 2) return arrayIn;
        var alen = arrayIn.length;
        var alen2 = 2 * alen;
        var wlen = 2 * FWHM - 1;
        var w = new Array(wlen);
        var arrayOut = new Array(alen);
        var i;
        var j;
        var k;
        var v;
        for (i = 0; i < wlen; i++) {
          w[i] = (1 - Math.cos(Math.PI * (i + 1) / FWHM)) / (2 * FWHM);
        }
        for (i = 0; i < alen; i++) {
          v = 0;
          for (j = 0; j < wlen; j++) {
            k = i + j + 1 - FWHM;
            if (k < -alen) k -= alen2 * Math.round(k / alen2);
            else if (k >= alen2) k -= alen2 * Math.floor(k / alen2);
            if (k < 0) k = -1 - k;
            else if (k >= alen) k = alen2 - 1 - k;
            v += arrayIn[k] * w[j];
          }
          arrayOut[i] = v;
        }
        return arrayOut;
      };
      lib.syncOrAsync = function(sequence, arg, finalStep) {
        var ret, fni;
        function continueAsync() {
          return lib.syncOrAsync(sequence, arg, finalStep);
        }
        while (sequence.length) {
          fni = sequence.splice(0, 1)[0];
          ret = fni(arg);
          if (ret && ret.then) {
            return ret.then(continueAsync);
          }
        }
        return finalStep && finalStep(arg);
      };
      lib.stripTrailingSlash = function(str) {
        if (str.substr(-1) === "/") return str.substr(0, str.length - 1);
        return str;
      };
      lib.noneOrAll = function(containerIn, containerOut, attrList) {
        if (!containerIn) return;
        var hasAny = false;
        var hasAll = true;
        var i;
        var val;
        for (i = 0; i < attrList.length; i++) {
          val = containerIn[attrList[i]];
          if (val !== void 0 && val !== null) hasAny = true;
          else hasAll = false;
        }
        if (hasAny && !hasAll) {
          for (i = 0; i < attrList.length; i++) {
            containerIn[attrList[i]] = containerOut[attrList[i]];
          }
        }
      };
      lib.mergeArray = function(traceAttr, cd, cdAttr, fn) {
        var hasFn = typeof fn === "function";
        if (lib.isArrayOrTypedArray(traceAttr)) {
          var imax = Math.min(traceAttr.length, cd.length);
          for (var i = 0; i < imax; i++) {
            var v = traceAttr[i];
            cd[i][cdAttr] = hasFn ? fn(v) : v;
          }
        }
      };
      lib.mergeArrayCastPositive = function(traceAttr, cd, cdAttr) {
        return lib.mergeArray(traceAttr, cd, cdAttr, function(v) {
          var w = +v;
          return !isFinite(w) ? 0 : w > 0 ? w : 0;
        });
      };
      lib.fillArray = function(traceAttr, cd, cdAttr, fn) {
        fn = fn || lib.identity;
        if (lib.isArrayOrTypedArray(traceAttr)) {
          for (var i = 0; i < cd.length; i++) {
            cd[i][cdAttr] = fn(traceAttr[i]);
          }
        }
      };
      lib.castOption = function(trace, ptNumber, astr, fn) {
        fn = fn || lib.identity;
        var val = lib.nestedProperty(trace, astr).get();
        if (lib.isArrayOrTypedArray(val)) {
          if (Array.isArray(ptNumber) && lib.isArrayOrTypedArray(val[ptNumber[0]])) {
            return fn(val[ptNumber[0]][ptNumber[1]]);
          } else {
            return fn(val[ptNumber]);
          }
        } else {
          return val;
        }
      };
      lib.extractOption = function(calcPt, trace, calcKey, traceKey) {
        if (calcKey in calcPt) return calcPt[calcKey];
        var traceVal = lib.nestedProperty(trace, traceKey).get();
        if (!Array.isArray(traceVal)) return traceVal;
      };
      function makePtIndex2PtNumber(indexToPoints) {
        var ptIndex2ptNumber = {};
        for (var k in indexToPoints) {
          var pts = indexToPoints[k];
          for (var j = 0; j < pts.length; j++) {
            ptIndex2ptNumber[pts[j]] = +k;
          }
        }
        return ptIndex2ptNumber;
      }
      lib.tagSelected = function(calcTrace, trace, ptNumber2cdIndex) {
        var selectedpoints = trace.selectedpoints;
        var indexToPoints = trace._indexToPoints;
        var ptIndex2ptNumber;
        if (indexToPoints) {
          ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);
        }
        function isCdIndexValid(v) {
          return v !== void 0 && v < calcTrace.length;
        }
        for (var i = 0; i < selectedpoints.length; i++) {
          var ptIndex = selectedpoints[i];
          if (lib.isIndex(ptIndex) || lib.isArrayOrTypedArray(ptIndex) && lib.isIndex(ptIndex[0]) && lib.isIndex(ptIndex[1])) {
            var ptNumber = ptIndex2ptNumber ? ptIndex2ptNumber[ptIndex] : ptIndex;
            var cdIndex = ptNumber2cdIndex ? ptNumber2cdIndex[ptNumber] : ptNumber;
            if (isCdIndexValid(cdIndex)) {
              calcTrace[cdIndex].selected = 1;
            }
          }
        }
      };
      lib.selIndices2selPoints = function(trace) {
        var selectedpoints = trace.selectedpoints;
        var indexToPoints = trace._indexToPoints;
        if (indexToPoints) {
          var ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);
          var out = [];
          for (var i = 0; i < selectedpoints.length; i++) {
            var ptIndex = selectedpoints[i];
            if (lib.isIndex(ptIndex)) {
              var ptNumber = ptIndex2ptNumber[ptIndex];
              if (lib.isIndex(ptNumber)) {
                out.push(ptNumber);
              }
            }
          }
          return out;
        } else {
          return selectedpoints;
        }
      };
      lib.getTargetArray = function(trace, transformOpts) {
        var target = transformOpts.target;
        if (typeof target === "string" && target) {
          var array = lib.nestedProperty(trace, target).get();
          return lib.isArrayOrTypedArray(array) ? array : false;
        } else if (lib.isArrayOrTypedArray(target)) {
          return target;
        }
        return false;
      };
      function minExtend(obj1, obj2, opt) {
        var objOut = {};
        if (typeof obj2 !== "object") obj2 = {};
        var arrayLen = opt === "pieLike" ? -1 : 3;
        var keys = Object.keys(obj1);
        var i, k, v;
        for (i = 0; i < keys.length; i++) {
          k = keys[i];
          v = obj1[k];
          if (k.charAt(0) === "_" || typeof v === "function") continue;
          else if (k === "module") objOut[k] = v;
          else if (Array.isArray(v)) {
            if (k === "colorscale" || arrayLen === -1) {
              objOut[k] = v.slice();
            } else {
              objOut[k] = v.slice(0, arrayLen);
            }
          } else if (lib.isTypedArray(v)) {
            if (arrayLen === -1) {
              objOut[k] = v.subarray();
            } else {
              objOut[k] = v.subarray(0, arrayLen);
            }
          } else if (v && typeof v === "object") objOut[k] = minExtend(obj1[k], obj2[k], opt);
          else objOut[k] = v;
        }
        keys = Object.keys(obj2);
        for (i = 0; i < keys.length; i++) {
          k = keys[i];
          v = obj2[k];
          if (typeof v !== "object" || !(k in objOut) || typeof objOut[k] !== "object") {
            objOut[k] = v;
          }
        }
        return objOut;
      }
      lib.minExtend = minExtend;
      lib.titleCase = function(s) {
        return s.charAt(0).toUpperCase() + s.substr(1);
      };
      lib.containsAny = function(s, fragments) {
        for (var i = 0; i < fragments.length; i++) {
          if (s.indexOf(fragments[i]) !== -1) return true;
        }
        return false;
      };
      var IS_SAFARI_REGEX = /Version\/[\d\.]+.*Safari/;
      lib.isSafari = function() {
        return IS_SAFARI_REGEX.test(window.navigator.userAgent);
      };
      var IS_IOS_REGEX = /iPad|iPhone|iPod/;
      lib.isIOS = function() {
        return IS_IOS_REGEX.test(window.navigator.userAgent);
      };
      var FIREFOX_VERSION_REGEX = /Firefox\/(\d+)\.\d+/;
      lib.getFirefoxVersion = function() {
        var match = FIREFOX_VERSION_REGEX.exec(window.navigator.userAgent);
        if (match && match.length === 2) {
          var versionInt = parseInt(match[1]);
          if (!isNaN(versionInt)) {
            return versionInt;
          }
        }
        return null;
      };
      lib.isD3Selection = function(obj) {
        return obj instanceof d3.selection;
      };
      lib.ensureSingle = function(parent, nodeType, className, enterFn) {
        var sel = parent.select(nodeType + (className ? "." + className : ""));
        if (sel.size()) return sel;
        var layer = parent.append(nodeType);
        if (className) layer.classed(className, true);
        if (enterFn) layer.call(enterFn);
        return layer;
      };
      lib.ensureSingleById = function(parent, nodeType, id, enterFn) {
        var sel = parent.select(nodeType + "#" + id);
        if (sel.size()) return sel;
        var layer = parent.append(nodeType).attr("id", id);
        if (enterFn) layer.call(enterFn);
        return layer;
      };
      lib.objectFromPath = function(path, value) {
        var keys = path.split(".");
        var tmpObj;
        var obj = tmpObj = {};
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var el = null;
          var parts = keys[i].match(/(.*)\[([0-9]+)\]/);
          if (parts) {
            key = parts[1];
            el = parts[2];
            tmpObj = tmpObj[key] = [];
            if (i === keys.length - 1) {
              tmpObj[el] = value;
            } else {
              tmpObj[el] = {};
            }
            tmpObj = tmpObj[el];
          } else {
            if (i === keys.length - 1) {
              tmpObj[key] = value;
            } else {
              tmpObj[key] = {};
            }
            tmpObj = tmpObj[key];
          }
        }
        return obj;
      };
      var dottedPropertyRegex = /^([^\[\.]+)\.(.+)?/;
      var indexedPropertyRegex = /^([^\.]+)\[([0-9]+)\](\.)?(.+)?/;
      function notValid(prop) {
        return prop.slice(0, 2) === "__";
      }
      lib.expandObjectPaths = function(data) {
        var match, key, prop, datum, idx, dest, trailingPath;
        if (typeof data === "object" && !Array.isArray(data)) {
          for (key in data) {
            if (data.hasOwnProperty(key)) {
              if (match = key.match(dottedPropertyRegex)) {
                datum = data[key];
                prop = match[1];
                if (notValid(prop)) continue;
                delete data[key];
                data[prop] = lib.extendDeepNoArrays(data[prop] || {}, lib.objectFromPath(key, lib.expandObjectPaths(datum))[prop]);
              } else if (match = key.match(indexedPropertyRegex)) {
                datum = data[key];
                prop = match[1];
                if (notValid(prop)) continue;
                idx = parseInt(match[2]);
                delete data[key];
                data[prop] = data[prop] || [];
                if (match[3] === ".") {
                  trailingPath = match[4];
                  dest = data[prop][idx] = data[prop][idx] || {};
                  lib.extendDeepNoArrays(dest, lib.objectFromPath(trailingPath, lib.expandObjectPaths(datum)));
                } else {
                  if (notValid(prop)) continue;
                  data[prop][idx] = lib.expandObjectPaths(datum);
                }
              } else {
                if (notValid(key)) continue;
                data[key] = lib.expandObjectPaths(data[key]);
              }
            }
          }
        }
        return data;
      };
      lib.numSeparate = function(value, separators, separatethousands) {
        if (!separatethousands) separatethousands = false;
        if (typeof separators !== "string" || separators.length === 0) {
          throw new Error("Separator string required for formatting!");
        }
        if (typeof value === "number") {
          value = String(value);
        }
        var thousandsRe = /(\d+)(\d{3})/;
        var decimalSep = separators.charAt(0);
        var thouSep = separators.charAt(1);
        var x = value.split(".");
        var x1 = x[0];
        var x2 = x.length > 1 ? decimalSep + x[1] : "";
        if (thouSep && (x.length > 1 || x1.length > 4 || separatethousands)) {
          while (thousandsRe.test(x1)) {
            x1 = x1.replace(thousandsRe, "$1" + thouSep + "$2");
          }
        }
        return x1 + x2;
      };
      lib.TEMPLATE_STRING_REGEX = /%{([^\s%{}:]*)([:|\|][^}]*)?}/g;
      var SIMPLE_PROPERTY_REGEX = /^\w*$/;
      lib.templateString = function(string, obj) {
        var getterCache = {};
        return string.replace(lib.TEMPLATE_STRING_REGEX, function(dummy, key) {
          var v;
          if (SIMPLE_PROPERTY_REGEX.test(key)) {
            v = obj[key];
          } else {
            getterCache[key] = getterCache[key] || lib.nestedProperty(obj, key).get;
            v = getterCache[key](true);
          }
          return v !== void 0 ? v : "";
        });
      };
      var hovertemplateWarnings = {
        max: 10,
        count: 0,
        name: "hovertemplate"
      };
      lib.hovertemplateString = function() {
        return templateFormatString.apply(hovertemplateWarnings, arguments);
      };
      var texttemplateWarnings = {
        max: 10,
        count: 0,
        name: "texttemplate"
      };
      lib.texttemplateString = function() {
        return templateFormatString.apply(texttemplateWarnings, arguments);
      };
      var MULT_DIV_REGEX = /^(\S+)([\*\/])(-?\d+(\.\d+)?)$/;
      function multDivParser(inputStr) {
        var match = inputStr.match(MULT_DIV_REGEX);
        if (match) return { key: match[1], op: match[2], number: Number(match[3]) };
        return { key: inputStr, op: null, number: null };
      }
      var texttemplateWarningsForShapes = {
        max: 10,
        count: 0,
        name: "texttemplate",
        parseMultDiv: true
      };
      lib.texttemplateStringForShapes = function() {
        return templateFormatString.apply(texttemplateWarningsForShapes, arguments);
      };
      var TEMPLATE_STRING_FORMAT_SEPARATOR = /^[:|\|]/;
      function templateFormatString(string, labels, d3locale) {
        var opts = this;
        var args = arguments;
        if (!labels) labels = {};
        return string.replace(lib.TEMPLATE_STRING_REGEX, function(match, rawKey, format) {
          var isOther = rawKey === "xother" || rawKey === "yother";
          var isSpaceOther = rawKey === "_xother" || rawKey === "_yother";
          var isSpaceOtherSpace = rawKey === "_xother_" || rawKey === "_yother_";
          var isOtherSpace = rawKey === "xother_" || rawKey === "yother_";
          var hasOther = isOther || isSpaceOther || isOtherSpace || isSpaceOtherSpace;
          var key = rawKey;
          if (isSpaceOther || isSpaceOtherSpace) key = key.substring(1);
          if (isOtherSpace || isSpaceOtherSpace) key = key.substring(0, key.length - 1);
          var parsedOp = null;
          var parsedNumber = null;
          if (opts.parseMultDiv) {
            var _match = multDivParser(key);
            key = _match.key;
            parsedOp = _match.op;
            parsedNumber = _match.number;
          }
          var value;
          if (hasOther) {
            value = labels[key];
            if (value === void 0) return "";
          } else {
            var obj, i;
            for (i = 3; i < args.length; i++) {
              obj = args[i];
              if (!obj) continue;
              if (obj.hasOwnProperty(key)) {
                value = obj[key];
                break;
              }
              if (!SIMPLE_PROPERTY_REGEX.test(key)) {
                value = lib.nestedProperty(obj, key).get(true);
              }
              if (value !== void 0) break;
            }
          }
          if (value !== void 0) {
            if (parsedOp === "*") value *= parsedNumber;
            if (parsedOp === "/") value /= parsedNumber;
          }
          if (value === void 0 && opts) {
            if (opts.count < opts.max) {
              lib.warn("Variable '" + key + "' in " + opts.name + " could not be found!");
              value = match;
            }
            if (opts.count === opts.max) {
              lib.warn("Too many " + opts.name + " warnings - additional warnings will be suppressed");
            }
            opts.count++;
            return match;
          }
          if (format) {
            var fmt;
            if (format[0] === ":") {
              fmt = d3locale ? d3locale.numberFormat : lib.numberFormat;
              if (value !== "") {
                value = fmt(format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR, ""))(value);
              }
            }
            if (format[0] === "|") {
              fmt = d3locale ? d3locale.timeFormat : utcFormat;
              var ms = lib.dateTime2ms(value);
              value = lib.formatDate(ms, format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR, ""), false, fmt);
            }
          } else {
            var keyLabel = key + "Label";
            if (labels.hasOwnProperty(keyLabel)) value = labels[keyLabel];
          }
          if (hasOther) {
            value = "(" + value + ")";
            if (isSpaceOther || isSpaceOtherSpace) value = " " + value;
            if (isOtherSpace || isSpaceOtherSpace) value = value + " ";
          }
          return value;
        });
      }
      var char0 = 48;
      var char9 = 57;
      lib.subplotSort = function(a, b) {
        var l = Math.min(a.length, b.length) + 1;
        var numA = 0;
        var numB = 0;
        for (var i = 0; i < l; i++) {
          var charA = a.charCodeAt(i) || 0;
          var charB = b.charCodeAt(i) || 0;
          var isNumA = charA >= char0 && charA <= char9;
          var isNumB = charB >= char0 && charB <= char9;
          if (isNumA) numA = 10 * numA + charA - char0;
          if (isNumB) numB = 10 * numB + charB - char0;
          if (!isNumA || !isNumB) {
            if (numA !== numB) return numA - numB;
            if (charA !== charB) return charA - charB;
          }
        }
        return numB - numA;
      };
      var randSeed = 2e9;
      lib.seedPseudoRandom = function() {
        randSeed = 2e9;
      };
      lib.pseudoRandom = function() {
        var lastVal = randSeed;
        randSeed = (69069 * randSeed + 1) % 4294967296;
        if (Math.abs(randSeed - lastVal) < 429496729) return lib.pseudoRandom();
        return randSeed / 4294967296;
      };
      lib.fillText = function(calcPt, trace, contOut) {
        var fill = Array.isArray(contOut) ? function(v) {
          contOut.push(v);
        } : function(v) {
          contOut.text = v;
        };
        var htx = lib.extractOption(calcPt, trace, "htx", "hovertext");
        if (lib.isValidTextValue(htx)) return fill(htx);
        var tx = lib.extractOption(calcPt, trace, "tx", "text");
        if (lib.isValidTextValue(tx)) return fill(tx);
      };
      lib.isValidTextValue = function(v) {
        return v || v === 0;
      };
      lib.formatPercent = function(ratio, n) {
        n = n || 0;
        var str = (Math.round(100 * ratio * Math.pow(10, n)) * Math.pow(0.1, n)).toFixed(n) + "%";
        for (var i = 0; i < n; i++) {
          if (str.indexOf(".") !== -1) {
            str = str.replace("0%", "%");
            str = str.replace(".%", "%");
          }
        }
        return str;
      };
      lib.isHidden = function(gd) {
        var display = window.getComputedStyle(gd).display;
        return !display || display === "none";
      };
      lib.strTranslate = function(x, y) {
        return x || y ? "translate(" + x + "," + y + ")" : "";
      };
      lib.strRotate = function(a) {
        return a ? "rotate(" + a + ")" : "";
      };
      lib.strScale = function(s) {
        return s !== 1 ? "scale(" + s + ")" : "";
      };
      lib.getTextTransform = function(transform) {
        var noCenter = transform.noCenter;
        var textX = transform.textX;
        var textY = transform.textY;
        var targetX = transform.targetX;
        var targetY = transform.targetY;
        var anchorX = transform.anchorX || 0;
        var anchorY = transform.anchorY || 0;
        var rotate = transform.rotate;
        var scale = transform.scale;
        if (!scale) scale = 0;
        else if (scale > 1) scale = 1;
        return lib.strTranslate(
          targetX - scale * (textX + anchorX),
          targetY - scale * (textY + anchorY)
        ) + lib.strScale(scale) + (rotate ? "rotate(" + rotate + (noCenter ? "" : " " + textX + " " + textY) + ")" : "");
      };
      lib.setTransormAndDisplay = function(s, transform) {
        s.attr("transform", lib.getTextTransform(transform));
        s.style("display", transform.scale ? null : "none");
      };
      lib.ensureUniformFontSize = function(gd, baseFont) {
        var out = lib.extendFlat({}, baseFont);
        out.size = Math.max(
          baseFont.size,
          gd._fullLayout.uniformtext.minsize || 0
        );
        return out;
      };
      lib.join2 = function(arr, mainSeparator, lastSeparator) {
        var len = arr.length;
        if (len > 1) {
          return arr.slice(0, -1).join(mainSeparator) + lastSeparator + arr[len - 1];
        }
        return arr.join(mainSeparator);
      };
      lib.bigFont = function(size) {
        return Math.round(1.2 * size);
      };
      var firefoxVersion = lib.getFirefoxVersion();
      var isProblematicFirefox = firefoxVersion !== null && firefoxVersion < 86;
      lib.getPositionFromD3Event = function() {
        if (isProblematicFirefox) {
          return [
            d3.event.layerX,
            d3.event.layerY
          ];
        } else {
          return [
            d3.event.offsetX,
            d3.event.offsetY
          ];
        }
      };
    }
  });

  // build/plotcss.js
  var require_plotcss = __commonJS({
    "build/plotcss.js"() {
      "use strict";
      var Lib = require_lib();
      var rules = {
        "X,X div": 'direction:ltr;font-family:"Open Sans",verdana,arial,sans-serif;margin:0;padding:0;',
        "X input,X button": 'font-family:"Open Sans",verdana,arial,sans-serif;',
        "X input:focus,X button:focus": "outline:none;",
        "X a": "text-decoration:none;",
        "X a:hover": "text-decoration:none;",
        "X .crisp": "shape-rendering:crispEdges;",
        "X .user-select-none": "-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;",
        "X svg a": "fill:#447adb;",
        "X svg a:hover": "fill:#3c6dc5;",
        "X .main-svg": "position:absolute;top:0;left:0;pointer-events:none;",
        "X .main-svg .draglayer": "pointer-events:all;",
        "X .cursor-default": "cursor:default;",
        "X .cursor-pointer": "cursor:pointer;",
        "X .cursor-crosshair": "cursor:crosshair;",
        "X .cursor-move": "cursor:move;",
        "X .cursor-col-resize": "cursor:col-resize;",
        "X .cursor-row-resize": "cursor:row-resize;",
        "X .cursor-ns-resize": "cursor:ns-resize;",
        "X .cursor-ew-resize": "cursor:ew-resize;",
        "X .cursor-sw-resize": "cursor:sw-resize;",
        "X .cursor-s-resize": "cursor:s-resize;",
        "X .cursor-se-resize": "cursor:se-resize;",
        "X .cursor-w-resize": "cursor:w-resize;",
        "X .cursor-e-resize": "cursor:e-resize;",
        "X .cursor-nw-resize": "cursor:nw-resize;",
        "X .cursor-n-resize": "cursor:n-resize;",
        "X .cursor-ne-resize": "cursor:ne-resize;",
        "X .cursor-grab": "cursor:-webkit-grab;cursor:grab;",
        "X .modebar": "position:absolute;top:2px;right:2px;",
        "X .ease-bg": "-webkit-transition:background-color .3s ease 0s;-moz-transition:background-color .3s ease 0s;-ms-transition:background-color .3s ease 0s;-o-transition:background-color .3s ease 0s;transition:background-color .3s ease 0s;",
        "X .modebar--hover>:not(.watermark)": "opacity:0;-webkit-transition:opacity .3s ease 0s;-moz-transition:opacity .3s ease 0s;-ms-transition:opacity .3s ease 0s;-o-transition:opacity .3s ease 0s;transition:opacity .3s ease 0s;",
        "X:hover .modebar--hover .modebar-group": "opacity:1;",
        "X .modebar-group": "float:left;display:inline-block;box-sizing:border-box;padding-left:8px;position:relative;vertical-align:middle;white-space:nowrap;",
        "X .modebar-btn": "position:relative;font-size:16px;padding:3px 4px;height:22px;cursor:pointer;line-height:normal;box-sizing:border-box;",
        "X .modebar-btn svg": "position:relative;top:2px;",
        "X .modebar.vertical": "display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;max-height:100%;",
        "X .modebar.vertical svg": "top:-1px;",
        "X .modebar.vertical .modebar-group": "display:block;float:none;padding-left:0px;padding-bottom:8px;",
        "X .modebar.vertical .modebar-group .modebar-btn": "display:block;text-align:center;",
        "X [data-title]:before,X [data-title]:after": "position:absolute;-webkit-transform:translate3d(0, 0, 0);-moz-transform:translate3d(0, 0, 0);-ms-transform:translate3d(0, 0, 0);-o-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);display:none;opacity:0;z-index:1001;pointer-events:none;top:110%;right:50%;",
        "X [data-title]:hover:before,X [data-title]:hover:after": "display:block;opacity:1;",
        "X [data-title]:before": 'content:"";position:absolute;background:rgba(0,0,0,0);border:6px solid rgba(0,0,0,0);z-index:1002;margin-top:-12px;border-bottom-color:#69738a;margin-right:-6px;',
        "X [data-title]:after": "content:attr(data-title);background:#69738a;color:#fff;padding:8px 10px;font-size:12px;line-height:12px;white-space:nowrap;margin-right:-18px;border-radius:2px;",
        "X .vertical [data-title]:before,X .vertical [data-title]:after": "top:0%;right:200%;",
        "X .vertical [data-title]:before": "border:6px solid rgba(0,0,0,0);border-left-color:#69738a;margin-top:8px;margin-right:-30px;",
        Y: 'font-family:"Open Sans",verdana,arial,sans-serif;position:fixed;top:50px;right:20px;z-index:10000;font-size:10pt;max-width:180px;',
        "Y p": "margin:0;",
        "Y .notifier-note": "min-width:180px;max-width:250px;border:1px solid #fff;z-index:3000;margin:0;background-color:#8c97af;background-color:rgba(140,151,175,.9);color:#fff;padding:10px;overflow-wrap:break-word;word-wrap:break-word;-ms-hyphens:auto;-webkit-hyphens:auto;hyphens:auto;",
        "Y .notifier-close": "color:#fff;opacity:.8;float:right;padding:0 5px;background:none;border:none;font-size:20px;font-weight:bold;line-height:20px;",
        "Y .notifier-close:hover": "color:#444;text-decoration:none;cursor:pointer;"
      };
      for (selector in rules) {
        fullSelector = selector.replace(/^,/, " ,").replace(/X/g, ".js-plotly-plot .plotly").replace(/Y/g, ".plotly-notifier");
        Lib.addStyleRule(fullSelector, rules[selector]);
      }
      var fullSelector;
      var selector;
    }
  });

  // node_modules/is-browser/client.js
  var require_client = __commonJS({
    "node_modules/is-browser/client.js"(exports, module) {
      module.exports = true;
    }
  });

  // node_modules/has-hover/index.js
  var require_has_hover = __commonJS({
    "node_modules/has-hover/index.js"(exports, module) {
      "use strict";
      var isBrowser = require_client();
      var hasHover;
      if (typeof window.matchMedia === "function") {
        hasHover = !window.matchMedia("(hover: none)").matches;
      } else {
        hasHover = isBrowser;
      }
      module.exports = hasHover;
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // src/lib/events.js
  var require_events2 = __commonJS({
    "src/lib/events.js"(exports, module) {
      "use strict";
      var EventEmitter = require_events().EventEmitter;
      var Events = {
        init: function(plotObj) {
          if (plotObj._ev instanceof EventEmitter) return plotObj;
          var ev = new EventEmitter();
          var internalEv = new EventEmitter();
          plotObj._ev = ev;
          plotObj._internalEv = internalEv;
          plotObj.on = ev.on.bind(ev);
          plotObj.once = ev.once.bind(ev);
          plotObj.removeListener = ev.removeListener.bind(ev);
          plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);
          plotObj._internalOn = internalEv.on.bind(internalEv);
          plotObj._internalOnce = internalEv.once.bind(internalEv);
          plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);
          plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);
          plotObj.emit = function(event, data) {
            ev.emit(event, data);
            internalEv.emit(event, data);
          };
          return plotObj;
        },
        /*
         * This function behaves like jQuery's triggerHandler. It calls
         * all handlers for a particular event and returns the return value
         * of the LAST handler.
         */
        triggerHandler: function(plotObj, event, data) {
          var nodeEventHandlerValue;
          var ev = plotObj._ev;
          if (!ev) return;
          var handlers = ev._events[event];
          if (!handlers) return;
          function apply(handler) {
            if (handler.listener) {
              ev.removeListener(event, handler.listener);
              if (!handler.fired) {
                handler.fired = true;
                return handler.listener.apply(ev, [data]);
              }
            } else {
              return handler.apply(ev, [data]);
            }
          }
          handlers = Array.isArray(handlers) ? handlers : [handlers];
          var i;
          for (i = 0; i < handlers.length - 1; i++) {
            apply(handlers[i]);
          }
          nodeEventHandlerValue = apply(handlers[i]);
          return nodeEventHandlerValue;
        },
        purge: function(plotObj) {
          delete plotObj._ev;
          delete plotObj.on;
          delete plotObj.once;
          delete plotObj.removeListener;
          delete plotObj.removeAllListeners;
          delete plotObj.emit;
          delete plotObj._ev;
          delete plotObj._internalEv;
          delete plotObj._internalOn;
          delete plotObj._internalOnce;
          delete plotObj._removeInternalListener;
          delete plotObj._removeAllInternalListeners;
          return plotObj;
        }
      };
      module.exports = Events;
    }
  });

  // src/lib/queue.js
  var require_queue = __commonJS({
    "src/lib/queue.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var dfltConfig = require_plot_config().dfltConfig;
      function copyArgArray(gd, args) {
        var copy = [];
        var arg;
        for (var i = 0; i < args.length; i++) {
          arg = args[i];
          if (arg === gd) copy[i] = arg;
          else if (typeof arg === "object") {
            copy[i] = Array.isArray(arg) ? Lib.extendDeep([], arg) : Lib.extendDeepAll({}, arg);
          } else copy[i] = arg;
        }
        return copy;
      }
      var queue = {};
      queue.add = function(gd, undoFunc, undoArgs, redoFunc, redoArgs) {
        var queueObj, queueIndex;
        gd.undoQueue = gd.undoQueue || { index: 0, queue: [], sequence: false };
        queueIndex = gd.undoQueue.index;
        if (gd.autoplay) {
          if (!gd.undoQueue.inSequence) gd.autoplay = false;
          return;
        }
        if (!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {
          queueObj = { undo: { calls: [], args: [] }, redo: { calls: [], args: [] } };
          gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);
          gd.undoQueue.index += 1;
        } else {
          queueObj = gd.undoQueue.queue[queueIndex - 1];
        }
        gd.undoQueue.beginSequence = false;
        if (queueObj) {
          queueObj.undo.calls.unshift(undoFunc);
          queueObj.undo.args.unshift(undoArgs);
          queueObj.redo.calls.push(redoFunc);
          queueObj.redo.args.push(redoArgs);
        }
        if (gd.undoQueue.queue.length > dfltConfig.queueLength) {
          gd.undoQueue.queue.shift();
          gd.undoQueue.index--;
        }
      };
      queue.startSequence = function(gd) {
        gd.undoQueue = gd.undoQueue || { index: 0, queue: [], sequence: false };
        gd.undoQueue.sequence = true;
        gd.undoQueue.beginSequence = true;
      };
      queue.stopSequence = function(gd) {
        gd.undoQueue = gd.undoQueue || { index: 0, queue: [], sequence: false };
        gd.undoQueue.sequence = false;
        gd.undoQueue.beginSequence = false;
      };
      queue.undo = function undo(gd) {
        var queueObj, i;
        if (gd.undoQueue === void 0 || isNaN(gd.undoQueue.index) || gd.undoQueue.index <= 0) {
          return;
        }
        gd.undoQueue.index--;
        queueObj = gd.undoQueue.queue[gd.undoQueue.index];
        gd.undoQueue.inSequence = true;
        for (i = 0; i < queueObj.undo.calls.length; i++) {
          queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);
        }
        gd.undoQueue.inSequence = false;
        gd.autoplay = false;
      };
      queue.redo = function redo(gd) {
        var queueObj, i;
        if (gd.undoQueue === void 0 || isNaN(gd.undoQueue.index) || gd.undoQueue.index >= gd.undoQueue.queue.length) {
          return;
        }
        queueObj = gd.undoQueue.queue[gd.undoQueue.index];
        gd.undoQueue.inSequence = true;
        for (i = 0; i < queueObj.redo.calls.length; i++) {
          queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);
        }
        gd.undoQueue.inSequence = false;
        gd.autoplay = false;
        gd.undoQueue.index++;
      };
      queue.plotDo = function(gd, func, args) {
        gd.autoplay = true;
        args = copyArgArray(gd, args);
        func.apply(null, args);
      };
      module.exports = queue;
    }
  });

  // src/plots/frame_attributes.js
  var require_frame_attributes = __commonJS({
    "src/plots/frame_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        _isLinkedToArray: "frames_entry",
        group: {
          valType: "string"
        },
        name: {
          valType: "string"
        },
        traces: {
          valType: "any"
        },
        baseframe: {
          valType: "string"
        },
        data: {
          valType: "any"
        },
        layout: {
          valType: "any"
        }
      };
    }
  });

  // src/plot_api/plot_schema.js
  var require_plot_schema = __commonJS({
    "src/plot_api/plot_schema.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var baseAttributes = require_attributes2();
      var baseLayoutAttributes = require_layout_attributes2();
      var frameAttributes = require_frame_attributes();
      var animationAttributes = require_animation_attributes();
      var configAttributes = require_plot_config().configAttributes;
      var editTypes = require_edit_types();
      var extendDeepAll = Lib.extendDeepAll;
      var isPlainObject = Lib.isPlainObject;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var nestedProperty = Lib.nestedProperty;
      var valObjectMeta = Lib.valObjectMeta;
      var IS_SUBPLOT_OBJ = "_isSubplotObj";
      var IS_LINKED_TO_ARRAY = "_isLinkedToArray";
      var ARRAY_ATTR_REGEXPS = "_arrayAttrRegexps";
      var DEPRECATED = "_deprecated";
      var UNDERSCORE_ATTRS = [IS_SUBPLOT_OBJ, IS_LINKED_TO_ARRAY, ARRAY_ATTR_REGEXPS, DEPRECATED];
      exports.IS_SUBPLOT_OBJ = IS_SUBPLOT_OBJ;
      exports.IS_LINKED_TO_ARRAY = IS_LINKED_TO_ARRAY;
      exports.DEPRECATED = DEPRECATED;
      exports.UNDERSCORE_ATTRS = UNDERSCORE_ATTRS;
      exports.get = function() {
        var traces = {};
        Registry.allTypes.forEach(function(type) {
          traces[type] = getTraceAttributes(type);
        });
        return {
          defs: {
            valObjects: valObjectMeta,
            metaKeys: UNDERSCORE_ATTRS.concat(["description", "role", "editType", "impliedEdits"]),
            editType: {
              traces: editTypes.traces,
              layout: editTypes.layout
            },
            impliedEdits: {}
          },
          traces,
          layout: getLayoutAttributes(),
          frames: getFramesAttributes(),
          animation: formatAttributes(animationAttributes),
          config: formatAttributes(configAttributes)
        };
      };
      exports.crawl = function(attrs, callback, specifiedLevel, attrString) {
        var level = specifiedLevel || 0;
        attrString = attrString || "";
        Object.keys(attrs).forEach(function(attrName) {
          var attr = attrs[attrName];
          if (UNDERSCORE_ATTRS.indexOf(attrName) !== -1) return;
          var fullAttrString = (attrString ? attrString + "." : "") + attrName;
          callback(attr, attrName, attrs, level, fullAttrString);
          if (exports.isValObject(attr)) return;
          if (isPlainObject(attr) && attrName !== "impliedEdits") {
            exports.crawl(attr, callback, level + 1, fullAttrString);
          }
        });
      };
      exports.isValObject = function(obj) {
        return obj && obj.valType !== void 0;
      };
      exports.findArrayAttributes = function(trace) {
        var arrayAttributes = [];
        var stack = [];
        var isArrayStack = [];
        var baseContainer, baseAttrName;
        function callback(attr, attrName, attrs, level) {
          stack = stack.slice(0, level).concat([attrName]);
          isArrayStack = isArrayStack.slice(0, level).concat([attr && attr._isLinkedToArray]);
          var splittableAttr = attr && (attr.valType === "data_array" || attr.arrayOk === true) && !(stack[level - 1] === "colorbar" && (attrName === "ticktext" || attrName === "tickvals"));
          if (!splittableAttr) return;
          crawlIntoTrace(baseContainer, 0, "");
        }
        function crawlIntoTrace(container, i, astrPartial) {
          var item = container[stack[i]];
          var newAstrPartial = astrPartial + stack[i];
          if (i === stack.length - 1) {
            if (isArrayOrTypedArray(item)) {
              arrayAttributes.push(baseAttrName + newAstrPartial);
            }
          } else {
            if (isArrayStack[i]) {
              if (Array.isArray(item)) {
                for (var j = 0; j < item.length; j++) {
                  if (isPlainObject(item[j])) {
                    crawlIntoTrace(item[j], i + 1, newAstrPartial + "[" + j + "].");
                  }
                }
              }
            } else if (isPlainObject(item)) {
              crawlIntoTrace(item, i + 1, newAstrPartial + ".");
            }
          }
        }
        baseContainer = trace;
        baseAttrName = "";
        exports.crawl(baseAttributes, callback);
        if (trace._module && trace._module.attributes) {
          exports.crawl(trace._module.attributes, callback);
        }
        return arrayAttributes;
      };
      exports.getTraceValObject = function(trace, parts) {
        var head = parts[0];
        var i = 1;
        var moduleAttrs, valObject;
        var _module = trace._module;
        if (!_module) _module = (Registry.modules[trace.type || baseAttributes.type.dflt] || {})._module;
        if (!_module) return false;
        moduleAttrs = _module.attributes;
        valObject = moduleAttrs && moduleAttrs[head];
        if (!valObject) {
          var subplotModule = _module.basePlotModule;
          if (subplotModule && subplotModule.attributes) {
            valObject = subplotModule.attributes[head];
          }
        }
        if (!valObject) valObject = baseAttributes[head];
        return recurseIntoValObject(valObject, parts, i);
      };
      exports.getLayoutValObject = function(fullLayout, parts) {
        var valObject = layoutHeadAttr(fullLayout, parts[0]);
        return recurseIntoValObject(valObject, parts, 1);
      };
      function layoutHeadAttr(fullLayout, head) {
        var i, key, _module, attributes;
        var basePlotModules = fullLayout._basePlotModules;
        if (basePlotModules) {
          var out;
          for (i = 0; i < basePlotModules.length; i++) {
            _module = basePlotModules[i];
            if (_module.attrRegex && _module.attrRegex.test(head)) {
              if (_module.layoutAttrOverrides) return _module.layoutAttrOverrides;
              if (!out && _module.layoutAttributes) out = _module.layoutAttributes;
            }
            var baseOverrides = _module.baseLayoutAttrOverrides;
            if (baseOverrides && head in baseOverrides) return baseOverrides[head];
          }
          if (out) return out;
        }
        var modules = fullLayout._modules;
        if (modules) {
          for (i = 0; i < modules.length; i++) {
            attributes = modules[i].layoutAttributes;
            if (attributes && head in attributes) {
              return attributes[head];
            }
          }
        }
        for (key in Registry.componentsRegistry) {
          _module = Registry.componentsRegistry[key];
          if (_module.name === "colorscale" && head.indexOf("coloraxis") === 0) {
            return _module.layoutAttributes[head];
          } else if (!_module.schema && head === _module.name) {
            return _module.layoutAttributes;
          }
        }
        if (head in baseLayoutAttributes) return baseLayoutAttributes[head];
        return false;
      }
      function recurseIntoValObject(valObject, parts, i) {
        if (!valObject) return false;
        if (valObject._isLinkedToArray) {
          if (isIndex(parts[i])) i++;
          else if (i < parts.length) return false;
        }
        for (; i < parts.length; i++) {
          var newValObject = valObject[parts[i]];
          if (isPlainObject(newValObject)) valObject = newValObject;
          else break;
          if (i === parts.length - 1) break;
          if (valObject._isLinkedToArray) {
            i++;
            if (!isIndex(parts[i])) return false;
          } else if (valObject.valType === "info_array") {
            i++;
            var index = parts[i];
            if (!isIndex(index)) return false;
            var items = valObject.items;
            if (Array.isArray(items)) {
              if (index >= items.length) return false;
              if (valObject.dimensions === 2) {
                i++;
                if (parts.length === i) return valObject;
                var index2 = parts[i];
                if (!isIndex(index2)) return false;
                valObject = items[index][index2];
              } else valObject = items[index];
            } else {
              valObject = items;
            }
          }
        }
        return valObject;
      }
      function isIndex(val) {
        return val === Math.round(val) && val >= 0;
      }
      function getTraceAttributes(type) {
        var _module, basePlotModule;
        _module = Registry.modules[type]._module, basePlotModule = _module.basePlotModule;
        var attributes = {};
        attributes.type = null;
        var copyBaseAttributes = extendDeepAll({}, baseAttributes);
        var copyModuleAttributes = extendDeepAll({}, _module.attributes);
        exports.crawl(copyModuleAttributes, function(attr, attrName, attrs, level, fullAttrString) {
          nestedProperty(copyBaseAttributes, fullAttrString).set(void 0);
          if (attr === void 0) nestedProperty(copyModuleAttributes, fullAttrString).set(void 0);
        });
        extendDeepAll(attributes, copyBaseAttributes);
        if (Registry.traceIs(type, "noOpacity")) {
          delete attributes.opacity;
        }
        if (!Registry.traceIs(type, "showLegend")) {
          delete attributes.showlegend;
          delete attributes.legendgroup;
        }
        if (Registry.traceIs(type, "noHover")) {
          delete attributes.hoverinfo;
          delete attributes.hoverlabel;
        }
        if (!_module.selectPoints) {
          delete attributes.selectedpoints;
        }
        extendDeepAll(attributes, copyModuleAttributes);
        if (basePlotModule.attributes) {
          extendDeepAll(attributes, basePlotModule.attributes);
        }
        attributes.type = type;
        var out = {
          meta: _module.meta || {},
          categories: _module.categories || {},
          animatable: Boolean(_module.animatable),
          type,
          attributes: formatAttributes(attributes)
        };
        if (_module.layoutAttributes) {
          var layoutAttributes = {};
          extendDeepAll(layoutAttributes, _module.layoutAttributes);
          out.layoutAttributes = formatAttributes(layoutAttributes);
        }
        if (!_module.animatable) {
          exports.crawl(out, function(attr) {
            if (exports.isValObject(attr) && "anim" in attr) {
              delete attr.anim;
            }
          });
        }
        return out;
      }
      function getLayoutAttributes() {
        var layoutAttributes = {};
        var key, _module;
        extendDeepAll(layoutAttributes, baseLayoutAttributes);
        for (key in Registry.subplotsRegistry) {
          _module = Registry.subplotsRegistry[key];
          if (!_module.layoutAttributes) continue;
          if (Array.isArray(_module.attr)) {
            for (var i = 0; i < _module.attr.length; i++) {
              handleBasePlotModule(layoutAttributes, _module, _module.attr[i]);
            }
          } else {
            var astr = _module.attr === "subplot" ? _module.name : _module.attr;
            handleBasePlotModule(layoutAttributes, _module, astr);
          }
        }
        for (key in Registry.componentsRegistry) {
          _module = Registry.componentsRegistry[key];
          var schema = _module.schema;
          if (schema && (schema.subplots || schema.layout)) {
            var subplots = schema.subplots;
            if (subplots && subplots.xaxis && !subplots.yaxis) {
              for (var xkey in subplots.xaxis) {
                delete layoutAttributes.yaxis[xkey];
              }
            }
            delete layoutAttributes.xaxis.shift;
            delete layoutAttributes.xaxis.autoshift;
          } else if (_module.name === "colorscale") {
            extendDeepAll(layoutAttributes, _module.layoutAttributes);
          } else if (_module.layoutAttributes) {
            insertAttrs(layoutAttributes, _module.layoutAttributes, _module.name);
          }
        }
        return {
          layoutAttributes: formatAttributes(layoutAttributes)
        };
      }
      function getFramesAttributes() {
        var attrs = {
          frames: extendDeepAll({}, frameAttributes)
        };
        formatAttributes(attrs);
        return attrs.frames;
      }
      function formatAttributes(attrs) {
        mergeValTypeAndRole(attrs);
        formatArrayContainers(attrs);
        stringify(attrs);
        return attrs;
      }
      function mergeValTypeAndRole(attrs) {
        function makeSrcAttr(attrName) {
          return {
            valType: "string",
            editType: "none"
          };
        }
        function callback(attr, attrName, attrs2) {
          if (exports.isValObject(attr)) {
            if (attr.arrayOk === true || attr.valType === "data_array") {
              attrs2[attrName + "src"] = makeSrcAttr(attrName);
            }
          } else if (isPlainObject(attr)) {
            attr.role = "object";
          }
        }
        exports.crawl(attrs, callback);
      }
      function formatArrayContainers(attrs) {
        function callback(attr, attrName, attrs2) {
          if (!attr) return;
          var itemName = attr[IS_LINKED_TO_ARRAY];
          if (!itemName) return;
          delete attr[IS_LINKED_TO_ARRAY];
          attrs2[attrName] = { items: {} };
          attrs2[attrName].items[itemName] = attr;
          attrs2[attrName].role = "object";
        }
        exports.crawl(attrs, callback);
      }
      function stringify(attrs) {
        function walk(attr) {
          for (var k in attr) {
            if (isPlainObject(attr[k])) {
              walk(attr[k]);
            } else if (Array.isArray(attr[k])) {
              for (var i = 0; i < attr[k].length; i++) {
                walk(attr[k][i]);
              }
            } else {
              if (attr[k] instanceof RegExp) {
                attr[k] = attr[k].toString();
              }
            }
          }
        }
        walk(attrs);
      }
      function handleBasePlotModule(layoutAttributes, _module, astr) {
        var np = nestedProperty(layoutAttributes, astr);
        var attrs = extendDeepAll({}, _module.layoutAttributes);
        attrs[IS_SUBPLOT_OBJ] = true;
        np.set(attrs);
      }
      function insertAttrs(baseAttrs, newAttrs, astr) {
        var np = nestedProperty(baseAttrs, astr);
        np.set(extendDeepAll(np.get() || {}, newAttrs));
      }
    }
  });

  // src/plot_api/plot_template.js
  var require_plot_template = __commonJS({
    "src/plot_api/plot_template.js"(exports) {
      "use strict";
      var Lib = require_lib();
      var plotAttributes = require_attributes2();
      var TEMPLATEITEMNAME = "templateitemname";
      var templateAttrs = {
        name: {
          valType: "string",
          editType: "none"
        }
      };
      templateAttrs[TEMPLATEITEMNAME] = {
        valType: "string",
        editType: "calc"
      };
      exports.templatedArray = function(name, attrs) {
        attrs._isLinkedToArray = name;
        attrs.name = templateAttrs.name;
        attrs[TEMPLATEITEMNAME] = templateAttrs[TEMPLATEITEMNAME];
        return attrs;
      };
      exports.traceTemplater = function(dataTemplate) {
        var traceCounts = {};
        var traceType, typeTemplates;
        for (traceType in dataTemplate) {
          typeTemplates = dataTemplate[traceType];
          if (Array.isArray(typeTemplates) && typeTemplates.length) {
            traceCounts[traceType] = 0;
          }
        }
        function newTrace(traceIn) {
          traceType = Lib.coerce(traceIn, {}, plotAttributes, "type");
          var traceOut = { type: traceType, _template: null };
          if (traceType in traceCounts) {
            typeTemplates = dataTemplate[traceType];
            var typei = traceCounts[traceType] % typeTemplates.length;
            traceCounts[traceType]++;
            traceOut._template = typeTemplates[typei];
          } else {
          }
          return traceOut;
        }
        return {
          newTrace
          // TODO: function to figure out what's left & what didn't work
        };
      };
      exports.newContainer = function(container, name, baseName) {
        var template = container._template;
        var part = template && (template[name] || baseName && template[baseName]);
        if (!Lib.isPlainObject(part)) part = null;
        var out = container[name] = { _template: part };
        return out;
      };
      exports.arrayTemplater = function(container, name, inclusionAttr) {
        var template = container._template;
        var defaultsTemplate = template && template[arrayDefaultKey(name)];
        var templateItems = template && template[name];
        if (!Array.isArray(templateItems) || !templateItems.length) {
          templateItems = [];
        }
        var usedNames = {};
        function newItem(itemIn) {
          var out = { name: itemIn.name, _input: itemIn };
          var templateItemName = out[TEMPLATEITEMNAME] = itemIn[TEMPLATEITEMNAME];
          if (!validItemName(templateItemName)) {
            out._template = defaultsTemplate;
            return out;
          }
          for (var i = 0; i < templateItems.length; i++) {
            var templateItem = templateItems[i];
            if (templateItem.name === templateItemName) {
              usedNames[templateItemName] = 1;
              out._template = templateItem;
              return out;
            }
          }
          out[inclusionAttr] = itemIn[inclusionAttr] || false;
          out._template = false;
          return out;
        }
        function defaultItems() {
          var out = [];
          for (var i = 0; i < templateItems.length; i++) {
            var templateItem = templateItems[i];
            var name2 = templateItem.name;
            if (validItemName(name2) && !usedNames[name2]) {
              var outi = {
                _template: templateItem,
                name: name2,
                _input: { _templateitemname: name2 }
              };
              outi[TEMPLATEITEMNAME] = templateItem[TEMPLATEITEMNAME];
              out.push(outi);
              usedNames[name2] = 1;
            }
          }
          return out;
        }
        return {
          newItem,
          defaultItems
        };
      };
      function validItemName(name) {
        return name && typeof name === "string";
      }
      function arrayDefaultKey(name) {
        var lastChar = name.length - 1;
        if (name.charAt(lastChar) !== "s") {
          Lib.warn("bad argument to arrayDefaultKey: " + name);
        }
        return name.substr(0, name.length - 1) + "defaults";
      }
      exports.arrayDefaultKey = arrayDefaultKey;
      exports.arrayEditor = function(parentIn, containerStr, itemOut) {
        var lengthIn = (Lib.nestedProperty(parentIn, containerStr).get() || []).length;
        var index = itemOut._index;
        var templateItemName = index >= lengthIn && (itemOut._input || {})._templateitemname;
        if (templateItemName) index = lengthIn;
        var itemStr = containerStr + "[" + index + "]";
        var update;
        function resetUpdate() {
          update = {};
          if (templateItemName) {
            update[itemStr] = {};
            update[itemStr][TEMPLATEITEMNAME] = templateItemName;
          }
        }
        resetUpdate();
        function modifyBase(attr, value) {
          update[attr] = value;
        }
        function modifyItem(attr, value) {
          if (templateItemName) {
            Lib.nestedProperty(update[itemStr], attr).set(value);
          } else {
            update[itemStr + "." + attr] = value;
          }
        }
        function getUpdateObj() {
          var updateOut = update;
          resetUpdate();
          return updateOut;
        }
        function applyUpdate(attr, value) {
          if (attr) modifyItem(attr, value);
          var updateToApply = getUpdateObj();
          for (var key in updateToApply) {
            Lib.nestedProperty(parentIn, key).set(updateToApply[key]);
          }
        }
        return {
          modifyBase,
          modifyItem,
          getUpdateObj,
          applyUpdate
        };
      };
    }
  });

  // src/plots/cartesian/constants.js
  var require_constants2 = __commonJS({
    "src/plots/cartesian/constants.js"(exports, module) {
      "use strict";
      var counterRegex = require_regex().counter;
      module.exports = {
        idRegex: {
          x: counterRegex("x", "( domain)?"),
          y: counterRegex("y", "( domain)?")
        },
        attrRegex: counterRegex("[xy]axis"),
        // axis match regular expression
        xAxisMatch: counterRegex("xaxis"),
        yAxisMatch: counterRegex("yaxis"),
        // pattern matching axis ids and names
        // note that this is more permissive than counterRegex, as
        // id2name, name2id, and cleanId accept "x1" etc
        AX_ID_PATTERN: /^[xyz][0-9]*( domain)?$/,
        AX_NAME_PATTERN: /^[xyz]axis[0-9]*$/,
        // and for 2D subplots
        SUBPLOT_PATTERN: /^x([0-9]*)y([0-9]*)$/,
        HOUR_PATTERN: "hour",
        WEEKDAY_PATTERN: "day of week",
        // pixels to move mouse before you stop clamping to starting point
        MINDRAG: 8,
        // smallest dimension allowed for a zoombox
        MINZOOM: 20,
        // width of axis drag regions
        DRAGGERSIZE: 20,
        // delay before a redraw (relayout) after smooth panning and zooming
        REDRAWDELAY: 50,
        // last resort axis ranges for x and y axes if we have no data
        DFLTRANGEX: [-1, 6],
        DFLTRANGEY: [-1, 4],
        // Layers to keep trace types in the right order
        // N.B. each  'unique' plot method must have its own layer
        traceLayerClasses: [
          "imagelayer",
          "heatmaplayer",
          "contourcarpetlayer",
          "contourlayer",
          "funnellayer",
          "waterfalllayer",
          "barlayer",
          "carpetlayer",
          "violinlayer",
          "boxlayer",
          "ohlclayer",
          "scattercarpetlayer",
          "scatterlayer"
        ],
        clipOnAxisFalseQuery: [
          ".scatterlayer",
          ".barlayer",
          ".funnellayer",
          ".waterfalllayer"
        ],
        layerValue2layerClass: {
          "above traces": "above",
          "below traces": "below"
        },
        zindexSeparator: "z"
        // used for zindex of cartesian subplots e.g. xy, xyz2, xyz3, etc.
      };
    }
  });

  // src/plots/cartesian/axis_ids.js
  var require_axis_ids = __commonJS({
    "src/plots/cartesian/axis_ids.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var constants = require_constants2();
      exports.id2name = function id2name(id) {
        if (typeof id !== "string" || !id.match(constants.AX_ID_PATTERN)) return;
        var axNum = id.split(" ")[0].substr(1);
        if (axNum === "1") axNum = "";
        return id.charAt(0) + "axis" + axNum;
      };
      exports.name2id = function name2id(name) {
        if (!name.match(constants.AX_NAME_PATTERN)) return;
        var axNum = name.substr(5);
        if (axNum === "1") axNum = "";
        return name.charAt(0) + axNum;
      };
      exports.cleanId = function cleanId(id, axLetter, domainId) {
        var domainTest = /( domain)$/.test(id);
        if (typeof id !== "string" || !id.match(constants.AX_ID_PATTERN)) return;
        if (axLetter && id.charAt(0) !== axLetter) return;
        if (domainTest && !domainId) return;
        var axNum = id.split(" ")[0].substr(1).replace(/^0+/, "");
        if (axNum === "1") axNum = "";
        return id.charAt(0) + axNum + (domainTest && domainId ? " domain" : "");
      };
      exports.list = function(gd, axLetter, only2d) {
        var fullLayout = gd._fullLayout;
        if (!fullLayout) return [];
        var idList = exports.listIds(gd, axLetter);
        var out = new Array(idList.length);
        var i;
        for (i = 0; i < idList.length; i++) {
          var idi = idList[i];
          out[i] = fullLayout[idi.charAt(0) + "axis" + idi.substr(1)];
        }
        if (!only2d) {
          var sceneIds3D = fullLayout._subplots.gl3d || [];
          for (i = 0; i < sceneIds3D.length; i++) {
            var scene = fullLayout[sceneIds3D[i]];
            if (axLetter) out.push(scene[axLetter + "axis"]);
            else out.push(scene.xaxis, scene.yaxis, scene.zaxis);
          }
        }
        return out;
      };
      exports.listIds = function(gd, axLetter) {
        var fullLayout = gd._fullLayout;
        if (!fullLayout) return [];
        var subplotLists = fullLayout._subplots;
        if (axLetter) return subplotLists[axLetter + "axis"];
        return subplotLists.xaxis.concat(subplotLists.yaxis);
      };
      exports.getFromId = function(gd, id, type) {
        var fullLayout = gd._fullLayout;
        id = id === void 0 || typeof id !== "string" ? id : id.replace(" domain", "");
        if (type === "x") id = id.replace(/y[0-9]*/, "");
        else if (type === "y") id = id.replace(/x[0-9]*/, "");
        return fullLayout[exports.id2name(id)];
      };
      exports.getFromTrace = function(gd, fullTrace, type) {
        var fullLayout = gd._fullLayout;
        var ax = null;
        if (Registry.traceIs(fullTrace, "gl3d")) {
          var scene = fullTrace.scene;
          if (scene.substr(0, 5) === "scene") {
            ax = fullLayout[scene][type + "axis"];
          }
        } else {
          ax = exports.getFromId(gd, fullTrace[type + "axis"] || type);
        }
        return ax;
      };
      exports.idSort = function(id1, id2) {
        var letter1 = id1.charAt(0);
        var letter2 = id2.charAt(0);
        if (letter1 !== letter2) return letter1 > letter2 ? 1 : -1;
        return +(id1.substr(1) || 1) - +(id2.substr(1) || 1);
      };
      exports.ref2id = function(ar) {
        return /^[xyz]/.test(ar) ? ar.split(" ")[0] : false;
      };
      function isFound(axId, list) {
        if (list && list.length) {
          for (var i = 0; i < list.length; i++) {
            if (list[i][axId]) return true;
          }
        }
        return false;
      }
      exports.isLinked = function(fullLayout, axId) {
        return isFound(axId, fullLayout._axisMatchGroups) || isFound(axId, fullLayout._axisConstraintGroups);
      };
    }
  });

  // src/components/shapes/handle_outline.js
  var require_handle_outline = __commonJS({
    "src/components/shapes/handle_outline.js"(exports, module) {
      "use strict";
      function clearOutlineControllers(gd) {
        var zoomLayer = gd._fullLayout._zoomlayer;
        if (zoomLayer) {
          zoomLayer.selectAll(".outline-controllers").remove();
        }
      }
      function clearOutline(gd) {
        var zoomLayer = gd._fullLayout._zoomlayer;
        if (zoomLayer) {
          zoomLayer.selectAll(".select-outline").remove();
        }
        gd._fullLayout._outlining = false;
      }
      module.exports = {
        clearOutlineControllers,
        clearOutline
      };
    }
  });

  // src/traces/scatter/layout_attributes.js
  var require_layout_attributes3 = __commonJS({
    "src/traces/scatter/layout_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        scattermode: {
          valType: "enumerated",
          values: ["group", "overlay"],
          dflt: "overlay",
          editType: "calc"
        },
        scattergap: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "calc"
        }
      };
    }
  });

  // src/plots/get_data.js
  var require_get_data = __commonJS({
    "src/plots/get_data.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var SUBPLOT_PATTERN = require_constants2().SUBPLOT_PATTERN;
      exports.getSubplotCalcData = function(calcData, type, subplotId) {
        var basePlotModule = Registry.subplotsRegistry[type];
        if (!basePlotModule) return [];
        var attr = basePlotModule.attr;
        var subplotCalcData = [];
        for (var i = 0; i < calcData.length; i++) {
          var calcTrace = calcData[i];
          var trace = calcTrace[0].trace;
          if (trace[attr] === subplotId) subplotCalcData.push(calcTrace);
        }
        return subplotCalcData;
      };
      exports.getModuleCalcData = function(calcdata, arg1, arg2) {
        var moduleCalcData = [];
        var remainingCalcData = [];
        var plotMethod;
        if (typeof arg1 === "string") {
          plotMethod = Registry.getModule(arg1).plot;
        } else if (typeof arg1 === "function") {
          plotMethod = arg1;
        } else {
          plotMethod = arg1.plot;
        }
        if (!plotMethod) {
          return [moduleCalcData, calcdata];
        }
        var zorder = arg2;
        for (var i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var trace = cd[0].trace;
          var filterByZ = trace.zorder !== void 0;
          if (trace.visible !== true || trace._length === 0) continue;
          if (trace._module && trace._module.plot === plotMethod && (!filterByZ || trace.zorder === zorder)) {
            moduleCalcData.push(cd);
          } else {
            remainingCalcData.push(cd);
          }
        }
        return [moduleCalcData, remainingCalcData];
      };
      exports.getSubplotData = function getSubplotData(data, type, subplotId) {
        if (!Registry.subplotsRegistry[type]) return [];
        var attr = Registry.subplotsRegistry[type].attr;
        var subplotData = [];
        var trace, subplotX, subplotY;
        for (var i = 0; i < data.length; i++) {
          trace = data[i];
          if (trace[attr] === subplotId) subplotData.push(trace);
        }
        return subplotData;
      };
    }
  });

  // src/plots/command.js
  var require_command = __commonJS({
    "src/plots/command.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      exports.manageCommandObserver = function(gd, container, commandList, onchange) {
        var ret = {};
        var enabled = true;
        if (container && container._commandObserver) {
          ret = container._commandObserver;
        }
        if (!ret.cache) {
          ret.cache = {};
        }
        ret.lookupTable = {};
        var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);
        if (container && container._commandObserver) {
          if (!binding) {
            if (container._commandObserver.remove) {
              container._commandObserver.remove();
              container._commandObserver = null;
              return ret;
            }
          } else {
            return ret;
          }
        }
        if (binding) {
          bindingValueHasChanged(gd, binding, ret.cache);
          ret.check = function check() {
            if (!enabled) return;
            var update = bindingValueHasChanged(gd, binding, ret.cache);
            if (update.changed && onchange) {
              if (ret.lookupTable[update.value] !== void 0) {
                ret.disable();
                Promise.resolve(onchange({
                  value: update.value,
                  type: binding.type,
                  prop: binding.prop,
                  traces: binding.traces,
                  index: ret.lookupTable[update.value]
                })).then(ret.enable, ret.enable);
              }
            }
            return update.changed;
          };
          var checkEvents = [
            "plotly_relayout",
            "plotly_redraw",
            "plotly_restyle",
            "plotly_update",
            "plotly_animatingframe",
            "plotly_afterplot"
          ];
          for (var i = 0; i < checkEvents.length; i++) {
            gd._internalOn(checkEvents[i], ret.check);
          }
          ret.remove = function() {
            for (var i2 = 0; i2 < checkEvents.length; i2++) {
              gd._removeInternalListener(checkEvents[i2], ret.check);
            }
          };
        } else {
          Lib.log("Unable to automatically bind plot updates to API command");
          ret.lookupTable = {};
          ret.remove = function() {
          };
        }
        ret.disable = function disable() {
          enabled = false;
        };
        ret.enable = function enable() {
          enabled = true;
        };
        if (container) {
          container._commandObserver = ret;
        }
        return ret;
      };
      exports.hasSimpleAPICommandBindings = function(gd, commandList, bindingsByValue) {
        var i;
        var n = commandList.length;
        var refBinding;
        for (i = 0; i < n; i++) {
          var binding;
          var command = commandList[i];
          var method = command.method;
          var args = command.args;
          if (!Array.isArray(args)) args = [];
          if (!method) {
            return false;
          }
          var bindings = exports.computeAPICommandBindings(gd, method, args);
          if (bindings.length !== 1) {
            return false;
          }
          if (!refBinding) {
            refBinding = bindings[0];
            if (Array.isArray(refBinding.traces)) {
              refBinding.traces.sort();
            }
          } else {
            binding = bindings[0];
            if (binding.type !== refBinding.type) {
              return false;
            }
            if (binding.prop !== refBinding.prop) {
              return false;
            }
            if (Array.isArray(refBinding.traces)) {
              if (Array.isArray(binding.traces)) {
                binding.traces.sort();
                for (var j = 0; j < refBinding.traces.length; j++) {
                  if (refBinding.traces[j] !== binding.traces[j]) {
                    return false;
                  }
                }
              } else {
                return false;
              }
            } else {
              if (binding.prop !== refBinding.prop) {
                return false;
              }
            }
          }
          binding = bindings[0];
          var value = binding.value;
          if (Array.isArray(value)) {
            if (value.length === 1) {
              value = value[0];
            } else {
              return false;
            }
          }
          if (bindingsByValue) {
            bindingsByValue[value] = i;
          }
        }
        return refBinding;
      };
      function bindingValueHasChanged(gd, binding, cache) {
        var container, value, obj;
        var changed = false;
        if (binding.type === "data") {
          container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];
        } else if (binding.type === "layout") {
          container = gd._fullLayout;
        } else {
          return false;
        }
        value = Lib.nestedProperty(container, binding.prop).get();
        obj = cache[binding.type] = cache[binding.type] || {};
        if (obj.hasOwnProperty(binding.prop)) {
          if (obj[binding.prop] !== value) {
            changed = true;
          }
        }
        obj[binding.prop] = value;
        return {
          changed,
          value
        };
      }
      exports.executeAPICommand = function(gd, method, args) {
        if (method === "skip") return Promise.resolve();
        var _method = Registry.apiMethodRegistry[method];
        var allArgs = [gd];
        if (!Array.isArray(args)) args = [];
        for (var i = 0; i < args.length; i++) {
          allArgs.push(args[i]);
        }
        return _method.apply(null, allArgs).catch(function(err) {
          Lib.warn("API call to Plotly." + method + " rejected.", err);
          return Promise.reject(err);
        });
      };
      exports.computeAPICommandBindings = function(gd, method, args) {
        var bindings;
        if (!Array.isArray(args)) args = [];
        switch (method) {
          case "restyle":
            bindings = computeDataBindings(gd, args);
            break;
          case "relayout":
            bindings = computeLayoutBindings(gd, args);
            break;
          case "update":
            bindings = computeDataBindings(gd, [args[0], args[2]]).concat(computeLayoutBindings(gd, [args[1]]));
            break;
          case "animate":
            bindings = computeAnimateBindings(gd, args);
            break;
          default:
            bindings = [];
        }
        return bindings;
      };
      function computeAnimateBindings(gd, args) {
        if (Array.isArray(args[0]) && args[0].length === 1 && ["string", "number"].indexOf(typeof args[0][0]) !== -1) {
          return [{ type: "layout", prop: "_currentFrame", value: args[0][0].toString() }];
        } else {
          return [];
        }
      }
      function computeLayoutBindings(gd, args) {
        var bindings = [];
        var astr = args[0];
        var aobj = {};
        if (typeof astr === "string") {
          aobj[astr] = args[1];
        } else if (Lib.isPlainObject(astr)) {
          aobj = astr;
        } else {
          return bindings;
        }
        crawl(aobj, function(path, attrName, attr) {
          bindings.push({ type: "layout", prop: path, value: attr });
        }, "", 0);
        return bindings;
      }
      function computeDataBindings(gd, args) {
        var traces, astr, val, aobj;
        var bindings = [];
        astr = args[0];
        val = args[1];
        traces = args[2];
        aobj = {};
        if (typeof astr === "string") {
          aobj[astr] = val;
        } else if (Lib.isPlainObject(astr)) {
          aobj = astr;
          if (traces === void 0) {
            traces = val;
          }
        } else {
          return bindings;
        }
        if (traces === void 0) {
          traces = null;
        }
        crawl(aobj, function(path, attrName, _attr) {
          var thisTraces;
          var attr;
          if (Array.isArray(_attr)) {
            attr = _attr.slice();
            var nAttr = Math.min(attr.length, gd.data.length);
            if (traces) {
              nAttr = Math.min(nAttr, traces.length);
            }
            thisTraces = [];
            for (var j = 0; j < nAttr; j++) {
              thisTraces[j] = traces ? traces[j] : j;
            }
          } else {
            attr = _attr;
            thisTraces = traces ? traces.slice() : null;
          }
          if (thisTraces === null) {
            if (Array.isArray(attr)) {
              attr = attr[0];
            }
          } else if (Array.isArray(thisTraces)) {
            if (!Array.isArray(attr)) {
              var tmp = attr;
              attr = [];
              for (var i = 0; i < thisTraces.length; i++) {
                attr[i] = tmp;
              }
            }
            attr.length = Math.min(thisTraces.length, attr.length);
          }
          bindings.push({
            type: "data",
            prop: path,
            traces: thisTraces,
            value: attr
          });
        }, "", 0);
        return bindings;
      }
      function crawl(attrs, callback, path, depth) {
        Object.keys(attrs).forEach(function(attrName) {
          var attr = attrs[attrName];
          if (attrName[0] === "_") return;
          var thisPath = path + (depth > 0 ? "." : "") + attrName;
          if (Lib.isPlainObject(attr)) {
            crawl(attr, callback, thisPath, depth + 1);
          } else {
            callback(thisPath, attrName, attr);
          }
        });
      }
    }
  });

  // src/plots/plots.js
  var require_plots = __commonJS({
    "src/plots/plots.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var timeFormatLocale = require_d3_time_format().timeFormatLocale;
      var formatLocale = require_d3_format().formatLocale;
      var isNumeric = require_fast_isnumeric();
      var b64encode = require_base64_arraybuffer_umd();
      var Registry = require_registry();
      var PlotSchema = require_plot_schema();
      var Template = require_plot_template();
      var Lib = require_lib();
      var Color = require_color();
      var BADNUM = require_numerical().BADNUM;
      var axisIDs = require_axis_ids();
      var clearOutline = require_handle_outline().clearOutline;
      var scatterAttrs = require_layout_attributes3();
      var animationAttrs = require_animation_attributes();
      var frameAttrs = require_frame_attributes();
      var getModuleCalcData = require_get_data().getModuleCalcData;
      var relinkPrivateKeys = Lib.relinkPrivateKeys;
      var _ = Lib._;
      var plots = module.exports = {};
      Lib.extendFlat(plots, Registry);
      plots.attributes = require_attributes2();
      plots.attributes.type.values = plots.allTypes;
      plots.fontAttrs = require_font_attributes();
      plots.layoutAttributes = require_layout_attributes2();
      var commandModule = require_command();
      plots.executeAPICommand = commandModule.executeAPICommand;
      plots.computeAPICommandBindings = commandModule.computeAPICommandBindings;
      plots.manageCommandObserver = commandModule.manageCommandObserver;
      plots.hasSimpleAPICommandBindings = commandModule.hasSimpleAPICommandBindings;
      plots.redrawText = function(gd) {
        gd = Lib.getGraphDiv(gd);
        return new Promise(function(resolve) {
          setTimeout(function() {
            if (!gd._fullLayout) return;
            Registry.getComponentMethod("annotations", "draw")(gd);
            Registry.getComponentMethod("legend", "draw")(gd);
            Registry.getComponentMethod("colorbar", "draw")(gd);
            resolve(plots.previousPromises(gd));
          }, 300);
        });
      };
      plots.resize = function(gd) {
        gd = Lib.getGraphDiv(gd);
        var resolveLastResize;
        var p = new Promise(function(resolve, reject) {
          if (!gd || Lib.isHidden(gd)) {
            reject(new Error("Resize must be passed a displayed plot div element."));
          }
          if (gd._redrawTimer) clearTimeout(gd._redrawTimer);
          if (gd._resolveResize) resolveLastResize = gd._resolveResize;
          gd._resolveResize = resolve;
          gd._redrawTimer = setTimeout(function() {
            if (!gd.layout || gd.layout.width && gd.layout.height || Lib.isHidden(gd)) {
              resolve(gd);
              return;
            }
            delete gd.layout.width;
            delete gd.layout.height;
            var oldchanged = gd.changed;
            gd.autoplay = true;
            Registry.call("relayout", gd, { autosize: true }).then(function() {
              gd.changed = oldchanged;
              if (gd._resolveResize === resolve) {
                delete gd._resolveResize;
                resolve(gd);
              }
            });
          }, 100);
        });
        if (resolveLastResize) resolveLastResize(p);
        return p;
      };
      plots.previousPromises = function(gd) {
        if ((gd._promises || []).length) {
          return Promise.all(gd._promises).then(function() {
            gd._promises = [];
          });
        }
      };
      plots.addLinks = function(gd) {
        if (!gd._context.showLink && !gd._context.showSources) return;
        var fullLayout = gd._fullLayout;
        var linkContainer = Lib.ensureSingle(fullLayout._paper, "text", "js-plot-link-container", function(s) {
          s.style({
            "font-family": '"Open Sans", Arial, sans-serif',
            "font-size": "12px",
            fill: Color.defaultLine,
            "pointer-events": "all"
          }).each(function() {
            var links = d3.select(this);
            links.append("tspan").classed("js-link-to-tool", true);
            links.append("tspan").classed("js-link-spacer", true);
            links.append("tspan").classed("js-sourcelinks", true);
          });
        });
        var text = linkContainer.node();
        var attrs = { y: fullLayout._paper.attr("height") - 9 };
        if (document.body.contains(text) && text.getComputedTextLength() >= fullLayout.width - 20) {
          attrs["text-anchor"] = "start";
          attrs.x = 5;
        } else {
          attrs["text-anchor"] = "end";
          attrs.x = fullLayout._paper.attr("width") - 7;
        }
        linkContainer.attr(attrs);
        var toolspan = linkContainer.select(".js-link-to-tool");
        var spacespan = linkContainer.select(".js-link-spacer");
        var sourcespan = linkContainer.select(".js-sourcelinks");
        if (gd._context.showSources) gd._context.showSources(gd);
        if (gd._context.showLink) positionPlayWithData(gd, toolspan);
        spacespan.text(toolspan.text() && sourcespan.text() ? " - " : "");
      };
      function positionPlayWithData(gd, container) {
        container.text("");
        var link = container.append("a").attr({
          "xlink:xlink:href": "#",
          class: "link--impt link--embedview",
          "font-weight": "bold"
        }).text(gd._context.linkText + " " + String.fromCharCode(187));
        if (gd._context.sendData) {
          link.on("click", function() {
            plots.sendDataToCloud(gd);
          });
        } else {
          var path = window.location.pathname.split("/");
          var query = window.location.search;
          link.attr({
            "xlink:xlink:show": "new",
            "xlink:xlink:href": "/" + path[2].split(".")[0] + "/" + path[1] + query
          });
        }
      }
      plots.sendDataToCloud = function(gd) {
        var baseUrl = (window.PLOTLYENV || {}).BASE_URL || gd._context.plotlyServerURL;
        if (!baseUrl) return;
        gd.emit("plotly_beforeexport");
        var hiddenformDiv = d3.select(gd).append("div").attr("id", "hiddenform").style("display", "none");
        var hiddenform = hiddenformDiv.append("form").attr({
          action: baseUrl + "/external",
          method: "post",
          target: "_blank"
        });
        var hiddenformInput = hiddenform.append("input").attr({
          type: "text",
          name: "data"
        });
        hiddenformInput.node().value = plots.graphJson(gd, false, "keepdata");
        hiddenform.node().submit();
        hiddenformDiv.remove();
        gd.emit("plotly_afterexport");
        return false;
      };
      var d3FormatKeys = [
        "days",
        "shortDays",
        "months",
        "shortMonths",
        "periods",
        "dateTime",
        "date",
        "time",
        "decimal",
        "thousands",
        "grouping",
        "currency"
      ];
      var extraFormatKeys = [
        "year",
        "month",
        "dayMonth",
        "dayMonthYear"
      ];
      plots.supplyDefaults = function(gd, opts) {
        var skipUpdateCalc = opts && opts.skipUpdateCalc;
        var oldFullLayout = gd._fullLayout || {};
        if (oldFullLayout._skipDefaults) {
          delete oldFullLayout._skipDefaults;
          return;
        }
        var newFullLayout = gd._fullLayout = {};
        var newLayout = gd.layout || {};
        var oldFullData = gd._fullData || [];
        var newFullData = gd._fullData = [];
        var newData = gd.data || [];
        var oldCalcdata = gd.calcdata || [];
        var context = gd._context || {};
        var i;
        if (!gd._transitionData) plots.createTransitionData(gd);
        newFullLayout._dfltTitle = {
          plot: _(gd, "Click to enter Plot title"),
          subtitle: _(gd, "Click to enter Plot subtitle"),
          x: _(gd, "Click to enter X axis title"),
          y: _(gd, "Click to enter Y axis title"),
          colorbar: _(gd, "Click to enter Colorscale title"),
          annotation: _(gd, "new text")
        };
        newFullLayout._traceWord = _(gd, "trace");
        var formatObj = getFormatObj(gd, d3FormatKeys);
        newFullLayout._mapboxAccessToken = context.mapboxAccessToken;
        if (oldFullLayout._initialAutoSizeIsDone) {
          var oldWidth = oldFullLayout.width;
          var oldHeight = oldFullLayout.height;
          plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);
          if (!newLayout.width) newFullLayout.width = oldWidth;
          if (!newLayout.height) newFullLayout.height = oldHeight;
          plots.sanitizeMargins(newFullLayout);
        } else {
          plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);
          var missingWidthOrHeight = !newLayout.width || !newLayout.height;
          var autosize = newFullLayout.autosize;
          var autosizable = context.autosizable;
          var initialAutoSize = missingWidthOrHeight && (autosize || autosizable);
          if (initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);
          else if (missingWidthOrHeight) plots.sanitizeMargins(newFullLayout);
          if (!autosize && missingWidthOrHeight) {
            newLayout.width = newFullLayout.width;
            newLayout.height = newFullLayout.height;
          }
        }
        newFullLayout._d3locale = getFormatter(formatObj, newFullLayout.separators);
        newFullLayout._extraFormat = getFormatObj(gd, extraFormatKeys);
        newFullLayout._initialAutoSizeIsDone = true;
        newFullLayout._dataLength = newData.length;
        newFullLayout._modules = [];
        newFullLayout._visibleModules = [];
        newFullLayout._basePlotModules = [];
        var subplots = newFullLayout._subplots = emptySubplotLists();
        var splomAxes = newFullLayout._splomAxes = { x: {}, y: {} };
        var splomSubplots = newFullLayout._splomSubplots = {};
        newFullLayout._splomGridDflt = {};
        newFullLayout._scatterStackOpts = {};
        newFullLayout._firstScatter = {};
        newFullLayout._alignmentOpts = {};
        newFullLayout._colorAxes = {};
        newFullLayout._requestRangeslider = {};
        newFullLayout._traceUids = getTraceUids(oldFullData, newData);
        plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout);
        var splomXa = Object.keys(splomAxes.x);
        var splomYa = Object.keys(splomAxes.y);
        if (splomXa.length > 1 && splomYa.length > 1) {
          Registry.getComponentMethod("grid", "sizeDefaults")(newLayout, newFullLayout);
          for (i = 0; i < splomXa.length; i++) {
            Lib.pushUnique(subplots.xaxis, splomXa[i]);
          }
          for (i = 0; i < splomYa.length; i++) {
            Lib.pushUnique(subplots.yaxis, splomYa[i]);
          }
          for (var k in splomSubplots) {
            Lib.pushUnique(subplots.cartesian, k);
          }
        }
        newFullLayout._has = plots._hasPlotType.bind(newFullLayout);
        if (oldFullData.length === newFullData.length) {
          for (i = 0; i < newFullData.length; i++) {
            relinkPrivateKeys(newFullData[i], oldFullData[i]);
          }
        }
        plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData);
        var _modules = newFullLayout._visibleModules;
        var crossTraceDefaultsFuncs = [];
        for (i = 0; i < _modules.length; i++) {
          var funci = _modules[i].crossTraceDefaults;
          if (funci) Lib.pushUnique(crossTraceDefaultsFuncs, funci);
        }
        for (i = 0; i < crossTraceDefaultsFuncs.length; i++) {
          crossTraceDefaultsFuncs[i](newFullData, newFullLayout);
        }
        newFullLayout._hasOnlyLargeSploms = newFullLayout._basePlotModules.length === 1 && newFullLayout._basePlotModules[0].name === "splom" && splomXa.length > 15 && splomYa.length > 15 && newFullLayout.shapes.length === 0 && newFullLayout.images.length === 0;
        plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout);
        plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);
        var hadCartesian = !!(oldFullLayout._has && oldFullLayout._has("cartesian"));
        var hasCartesian = !!(newFullLayout._has && newFullLayout._has("cartesian"));
        var hadBgLayer = hadCartesian;
        var hasBgLayer = hasCartesian;
        if (hadBgLayer && !hasBgLayer) {
          oldFullLayout._bgLayer.remove();
        } else if (hasBgLayer && !hadBgLayer) {
          newFullLayout._shouldCreateBgLayer = true;
        }
        if (oldFullLayout._zoomlayer && !gd._dragging) {
          clearOutline({
            // mock old gd
            _fullLayout: oldFullLayout
          });
        }
        fillMetaTextHelpers(newFullData, newFullLayout);
        relinkPrivateKeys(newFullLayout, oldFullLayout);
        Registry.getComponentMethod("colorscale", "crossTraceDefaults")(newFullData, newFullLayout);
        if (!newFullLayout._preGUI) newFullLayout._preGUI = {};
        if (!newFullLayout._tracePreGUI) newFullLayout._tracePreGUI = {};
        var tracePreGUI = newFullLayout._tracePreGUI;
        var uids = {};
        var uid;
        for (uid in tracePreGUI) uids[uid] = "old";
        for (i = 0; i < newFullData.length; i++) {
          uid = newFullData[i]._fullInput.uid;
          if (!uids[uid]) tracePreGUI[uid] = {};
          uids[uid] = "new";
        }
        for (uid in uids) {
          if (uids[uid] === "old") delete tracePreGUI[uid];
        }
        initMargins(newFullLayout);
        Registry.getComponentMethod("rangeslider", "makeData")(newFullLayout);
        if (!skipUpdateCalc && oldCalcdata.length === newFullData.length) {
          plots.supplyDefaultsUpdateCalc(oldCalcdata, newFullData);
        }
      };
      plots.supplyDefaultsUpdateCalc = function(oldCalcdata, newFullData) {
        for (var i = 0; i < newFullData.length; i++) {
          var newTrace = newFullData[i];
          var cd0 = (oldCalcdata[i] || [])[0];
          if (cd0 && cd0.trace) {
            var oldTrace = cd0.trace;
            if (oldTrace._hasCalcTransform) {
              var arrayAttrs = oldTrace._arrayAttrs;
              var j, astr, oldArrayVal;
              for (j = 0; j < arrayAttrs.length; j++) {
                astr = arrayAttrs[j];
                oldArrayVal = Lib.nestedProperty(oldTrace, astr).get().slice();
                Lib.nestedProperty(newTrace, astr).set(oldArrayVal);
              }
            }
            cd0.trace = newTrace;
          }
        }
      };
      function getTraceUids(oldFullData, newData) {
        var len = newData.length;
        var oldFullInput = [];
        var i, prevFullInput;
        for (i = 0; i < oldFullData.length; i++) {
          var thisFullInput = oldFullData[i]._fullInput;
          if (thisFullInput !== prevFullInput) oldFullInput.push(thisFullInput);
          prevFullInput = thisFullInput;
        }
        var oldLen = oldFullInput.length;
        var out = new Array(len);
        var seenUids = {};
        function setUid(uid, i2) {
          out[i2] = uid;
          seenUids[uid] = 1;
        }
        function tryUid(uid, i2) {
          if (uid && typeof uid === "string" && !seenUids[uid]) {
            setUid(uid, i2);
            return true;
          }
        }
        for (i = 0; i < len; i++) {
          var newUid = newData[i].uid;
          if (typeof newUid === "number") newUid = String(newUid);
          if (tryUid(newUid, i)) continue;
          if (i < oldLen && tryUid(oldFullInput[i].uid, i)) continue;
          setUid(Lib.randstr(seenUids), i);
        }
        return out;
      }
      function emptySubplotLists() {
        var collectableSubplotTypes = Registry.collectableSubplotTypes;
        var out = {};
        var i, j;
        if (!collectableSubplotTypes) {
          collectableSubplotTypes = [];
          var subplotsRegistry = Registry.subplotsRegistry;
          for (var subplotType in subplotsRegistry) {
            var subplotModule = subplotsRegistry[subplotType];
            var subplotAttr = subplotModule.attr;
            if (subplotAttr) {
              collectableSubplotTypes.push(subplotType);
              if (Array.isArray(subplotAttr)) {
                for (j = 0; j < subplotAttr.length; j++) {
                  Lib.pushUnique(collectableSubplotTypes, subplotAttr[j]);
                }
              }
            }
          }
        }
        for (i = 0; i < collectableSubplotTypes.length; i++) {
          out[collectableSubplotTypes[i]] = [];
        }
        return out;
      }
      function getFormatObj(gd, formatKeys) {
        var locale = gd._context.locale;
        if (!locale) locale = "en-US";
        var formatDone = false;
        var formatObj = {};
        function includeFormat(newFormat) {
          var formatFinished = true;
          for (var i2 = 0; i2 < formatKeys.length; i2++) {
            var formatKey = formatKeys[i2];
            if (!formatObj[formatKey]) {
              if (newFormat[formatKey]) {
                formatObj[formatKey] = newFormat[formatKey];
              } else formatFinished = false;
            }
          }
          if (formatFinished) formatDone = true;
        }
        for (var i = 0; i < 2; i++) {
          var locales = gd._context.locales;
          for (var j = 0; j < 2; j++) {
            var formatj = (locales[locale] || {}).format;
            if (formatj) {
              includeFormat(formatj);
              if (formatDone) break;
            }
            locales = Registry.localeRegistry;
          }
          var baseLocale = locale.split("-")[0];
          if (formatDone || baseLocale === locale) break;
          locale = baseLocale;
        }
        if (!formatDone) includeFormat(Registry.localeRegistry.en.format);
        return formatObj;
      }
      function getFormatter(formatObj, separators) {
        formatObj.decimal = separators.charAt(0);
        formatObj.thousands = separators.charAt(1);
        return {
          numberFormat: function(formatStr) {
            try {
              formatStr = formatLocale(formatObj).format(
                Lib.adjustFormat(formatStr)
              );
            } catch (e) {
              Lib.warnBadFormat(formatStr);
              return Lib.noFormat;
            }
            return formatStr;
          },
          timeFormat: timeFormatLocale(formatObj).utcFormat
        };
      }
      function fillMetaTextHelpers(newFullData, newFullLayout) {
        var _meta;
        var meta4data = [];
        if (newFullLayout.meta) {
          _meta = newFullLayout._meta = {
            meta: newFullLayout.meta,
            layout: { meta: newFullLayout.meta }
          };
        }
        for (var i = 0; i < newFullData.length; i++) {
          var trace = newFullData[i];
          if (trace.meta) {
            meta4data[trace.index] = trace._meta = { meta: trace.meta };
          } else if (newFullLayout.meta) {
            trace._meta = { meta: newFullLayout.meta };
          }
          if (newFullLayout.meta) {
            trace._meta.layout = { meta: newFullLayout.meta };
          }
        }
        if (meta4data.length) {
          if (!_meta) {
            _meta = newFullLayout._meta = {};
          }
          _meta.data = meta4data;
        }
      }
      plots.createTransitionData = function(gd) {
        if (!gd._transitionData) {
          gd._transitionData = {};
        }
        if (!gd._transitionData._frames) {
          gd._transitionData._frames = [];
        }
        if (!gd._transitionData._frameHash) {
          gd._transitionData._frameHash = {};
        }
        if (!gd._transitionData._counter) {
          gd._transitionData._counter = 0;
        }
        if (!gd._transitionData._interruptCallbacks) {
          gd._transitionData._interruptCallbacks = [];
        }
      };
      plots._hasPlotType = function(category) {
        var i;
        var basePlotModules = this._basePlotModules || [];
        for (i = 0; i < basePlotModules.length; i++) {
          if (basePlotModules[i].name === category) return true;
        }
        var modules = this._modules || [];
        for (i = 0; i < modules.length; i++) {
          var name = modules[i].name;
          if (name === category) return true;
          var _module = Registry.modules[name];
          if (_module && _module.categories[category]) return true;
        }
        return false;
      };
      plots.cleanPlot = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var i, j;
        var basePlotModules = oldFullLayout._basePlotModules || [];
        for (i = 0; i < basePlotModules.length; i++) {
          var _module = basePlotModules[i];
          if (_module.clean) {
            _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);
          }
        }
        var hadGl = oldFullLayout._has && oldFullLayout._has("gl");
        var hasGl = newFullLayout._has && newFullLayout._has("gl");
        if (hadGl && !hasGl) {
          if (oldFullLayout._glcontainer !== void 0) {
            oldFullLayout._glcontainer.selectAll(".gl-canvas").remove();
            oldFullLayout._glcontainer.selectAll(".no-webgl").remove();
            oldFullLayout._glcanvas = null;
          }
        }
        var hasInfoLayer = !!oldFullLayout._infolayer;
        oldLoop:
          for (i = 0; i < oldFullData.length; i++) {
            var oldTrace = oldFullData[i];
            var oldUid = oldTrace.uid;
            for (j = 0; j < newFullData.length; j++) {
              var newTrace = newFullData[j];
              if (oldUid === newTrace.uid) continue oldLoop;
            }
            if (hasInfoLayer) {
              oldFullLayout._infolayer.select(".cb" + oldUid).remove();
            }
          }
      };
      plots.linkSubplots = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var i, j;
        var oldSubplots = oldFullLayout._plots || {};
        var newSubplots = newFullLayout._plots = {};
        var newSubplotList = newFullLayout._subplots;
        var mockGd = {
          _fullData: newFullData,
          _fullLayout: newFullLayout
        };
        var ids = newSubplotList.cartesian || [];
        for (i = 0; i < ids.length; i++) {
          var id = ids[i];
          var oldSubplot = oldSubplots[id];
          var xaxis = axisIDs.getFromId(mockGd, id, "x");
          var yaxis = axisIDs.getFromId(mockGd, id, "y");
          var plotinfo;
          if (oldSubplot) {
            plotinfo = newSubplots[id] = oldSubplot;
          } else {
            plotinfo = newSubplots[id] = {};
            plotinfo.id = id;
          }
          xaxis._counterAxes.push(yaxis._id);
          yaxis._counterAxes.push(xaxis._id);
          xaxis._subplotsWith.push(id);
          yaxis._subplotsWith.push(id);
          plotinfo.xaxis = xaxis;
          plotinfo.yaxis = yaxis;
          plotinfo._hasClipOnAxisFalse = false;
          for (j = 0; j < newFullData.length; j++) {
            var trace = newFullData[j];
            if (trace.xaxis === plotinfo.xaxis._id && trace.yaxis === plotinfo.yaxis._id && trace.cliponaxis === false) {
              plotinfo._hasClipOnAxisFalse = true;
              break;
            }
          }
        }
        var axList = axisIDs.list(mockGd, null, true);
        var ax;
        for (i = 0; i < axList.length; i++) {
          ax = axList[i];
          var mainAx = null;
          if (ax.overlaying) {
            mainAx = axisIDs.getFromId(mockGd, ax.overlaying);
            if (mainAx && mainAx.overlaying) {
              ax.overlaying = false;
              mainAx = null;
            }
          }
          ax._mainAxis = mainAx || ax;
          if (mainAx) ax.domain = mainAx.domain.slice();
          ax._anchorAxis = ax.anchor === "free" ? null : axisIDs.getFromId(mockGd, ax.anchor);
        }
        for (i = 0; i < axList.length; i++) {
          ax = axList[i];
          ax._counterAxes.sort(axisIDs.idSort);
          ax._subplotsWith.sort(Lib.subplotSort);
          ax._mainSubplot = findMainSubplot(ax, newFullLayout);
          if (ax._counterAxes.length && (ax.spikemode && ax.spikemode.indexOf("across") !== -1 || ax.automargin && ax.mirror && ax.anchor !== "free" || Registry.getComponentMethod("rangeslider", "isVisible")(ax))) {
            var min = 1;
            var max = 0;
            for (j = 0; j < ax._counterAxes.length; j++) {
              var ax2 = axisIDs.getFromId(mockGd, ax._counterAxes[j]);
              min = Math.min(min, ax2.domain[0]);
              max = Math.max(max, ax2.domain[1]);
            }
            if (min < max) {
              ax._counterDomainMin = min;
              ax._counterDomainMax = max;
            }
          }
        }
      };
      function findMainSubplot(ax, fullLayout) {
        var mockGd = { _fullLayout: fullLayout };
        var isX = ax._id.charAt(0) === "x";
        var anchorAx = ax._mainAxis._anchorAxis;
        var mainSubplotID = "";
        var nextBestMainSubplotID = "";
        var anchorID = "";
        if (anchorAx) {
          anchorID = anchorAx._mainAxis._id;
          mainSubplotID = isX ? ax._id + anchorID : anchorID + ax._id;
        }
        if (!mainSubplotID || !fullLayout._plots[mainSubplotID]) {
          mainSubplotID = "";
          var counterIDs = ax._counterAxes;
          for (var j = 0; j < counterIDs.length; j++) {
            var counterPart = counterIDs[j];
            var id = isX ? ax._id + counterPart : counterPart + ax._id;
            if (!nextBestMainSubplotID) nextBestMainSubplotID = id;
            var counterAx = axisIDs.getFromId(mockGd, counterPart);
            if (anchorID && counterAx.overlaying === anchorID) {
              mainSubplotID = id;
              break;
            }
          }
        }
        return mainSubplotID || nextBestMainSubplotID;
      }
      plots.clearExpandedTraceDefaultColors = function(trace) {
        var colorAttrs, path, i;
        function locateColorAttrs(attr, attrName, attrs, level) {
          path[level] = attrName;
          path.length = level + 1;
          if (attr.valType === "color" && attr.dflt === void 0) {
            colorAttrs.push(path.join("."));
          }
        }
        path = [];
        colorAttrs = trace._module._colorAttrs;
        if (!colorAttrs) {
          trace._module._colorAttrs = colorAttrs = [];
          PlotSchema.crawl(
            trace._module.attributes,
            locateColorAttrs
          );
        }
        for (i = 0; i < colorAttrs.length; i++) {
          var origprop = Lib.nestedProperty(trace, "_input." + colorAttrs[i]);
          if (!origprop.get()) {
            Lib.nestedProperty(trace, colorAttrs[i]).set(null);
          }
        }
      };
      plots.supplyDataDefaults = function(dataIn, dataOut, layout, fullLayout) {
        var modules = fullLayout._modules;
        var visibleModules = fullLayout._visibleModules;
        var basePlotModules = fullLayout._basePlotModules;
        var cnt = 0;
        var colorCnt = 0;
        var i, fullTrace, trace;
        fullLayout._transformModules = [];
        function pushModule(fullTrace2) {
          dataOut.push(fullTrace2);
          var _module = fullTrace2._module;
          if (!_module) return;
          Lib.pushUnique(modules, _module);
          if (fullTrace2.visible === true) Lib.pushUnique(visibleModules, _module);
          Lib.pushUnique(basePlotModules, fullTrace2._module.basePlotModule);
          cnt++;
          if (fullTrace2._input.visible !== false) colorCnt++;
        }
        var carpetIndex = {};
        var carpetDependents = [];
        var dataTemplate = (layout.template || {}).data || {};
        var templater = Template.traceTemplater(dataTemplate);
        for (i = 0; i < dataIn.length; i++) {
          trace = dataIn[i];
          fullTrace = templater.newTrace(trace);
          fullTrace.uid = fullLayout._traceUids[i];
          plots.supplyTraceDefaults(trace, fullTrace, colorCnt, fullLayout, i);
          fullTrace.index = i;
          fullTrace._input = trace;
          fullTrace._fullInput = fullTrace;
          pushModule(fullTrace);
          if (Registry.traceIs(fullTrace, "carpetAxis")) {
            carpetIndex[fullTrace.carpet] = fullTrace;
          }
          if (Registry.traceIs(fullTrace, "carpetDependent")) {
            carpetDependents.push(i);
          }
        }
        for (i = 0; i < carpetDependents.length; i++) {
          fullTrace = dataOut[carpetDependents[i]];
          if (!fullTrace.visible) continue;
          var carpetAxis = carpetIndex[fullTrace.carpet];
          fullTrace._carpet = carpetAxis;
          if (!carpetAxis || !carpetAxis.visible) {
            fullTrace.visible = false;
            continue;
          }
          fullTrace.xaxis = carpetAxis.xaxis;
          fullTrace.yaxis = carpetAxis.yaxis;
        }
      };
      plots.supplyAnimationDefaults = function(opts) {
        opts = opts || {};
        var i;
        var optsOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);
        }
        coerce("mode");
        coerce("direction");
        coerce("fromcurrent");
        if (Array.isArray(opts.frame)) {
          optsOut.frame = [];
          for (i = 0; i < opts.frame.length; i++) {
            optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});
          }
        } else {
          optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});
        }
        if (Array.isArray(opts.transition)) {
          optsOut.transition = [];
          for (i = 0; i < opts.transition.length; i++) {
            optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});
          }
        } else {
          optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});
        }
        return optsOut;
      };
      plots.supplyAnimationFrameDefaults = function(opts) {
        var optsOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);
        }
        coerce("duration");
        coerce("redraw");
        return optsOut;
      };
      plots.supplyAnimationTransitionDefaults = function(opts) {
        var optsOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);
        }
        coerce("duration");
        coerce("easing");
        return optsOut;
      };
      plots.supplyFrameDefaults = function(frameIn) {
        var frameOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);
        }
        coerce("group");
        coerce("name");
        coerce("traces");
        coerce("baseframe");
        coerce("data");
        coerce("layout");
        return frameOut;
      };
      plots.supplyTraceDefaults = function(traceIn, traceOut, colorIndex, layout, traceInIndex) {
        var colorway = layout.colorway || Color.defaults;
        var defaultColor = colorway[colorIndex % colorway.length];
        var i;
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);
        }
        var visible = coerce("visible");
        coerce("type");
        coerce("name", layout._traceWord + " " + traceInIndex);
        coerce("uirevision", layout.uirevision);
        var _module = plots.getModule(traceOut);
        traceOut._module = _module;
        if (_module) {
          var basePlotModule = _module.basePlotModule;
          var subplotAttr = basePlotModule.attr;
          var subplotAttrs = basePlotModule.attributes;
          if (subplotAttr && subplotAttrs) {
            var subplots = layout._subplots;
            var subplotId = "";
            if (Array.isArray(subplotAttr)) {
              for (i = 0; i < subplotAttr.length; i++) {
                var attri = subplotAttr[i];
                var vali = Lib.coerce(traceIn, traceOut, subplotAttrs, attri);
                if (subplots[attri]) Lib.pushUnique(subplots[attri], vali);
                subplotId += vali;
              }
            } else {
              subplotId = Lib.coerce(traceIn, traceOut, subplotAttrs, subplotAttr);
            }
            if (subplots[basePlotModule.name]) {
              Lib.pushUnique(subplots[basePlotModule.name], subplotId);
            }
          }
        }
        if (visible) {
          coerce("customdata");
          coerce("ids");
          coerce("meta");
          if (Registry.traceIs(traceOut, "showLegend")) {
            Lib.coerce(
              traceIn,
              traceOut,
              _module.attributes.showlegend ? _module.attributes : plots.attributes,
              "showlegend"
            );
            coerce("legend");
            coerce("legendwidth");
            coerce("legendgroup");
            coerce("legendgrouptitle.text");
            coerce("legendrank");
            traceOut._dfltShowLegend = true;
          } else {
            traceOut._dfltShowLegend = false;
          }
          if (_module) {
            _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);
          }
          if (!Registry.traceIs(traceOut, "noOpacity")) {
            coerce("opacity");
          }
          if (Registry.traceIs(traceOut, "notLegendIsolatable")) {
            traceOut.visible = !!traceOut.visible;
          }
          if (!Registry.traceIs(traceOut, "noHover")) {
            if (!traceOut.hovertemplate) Lib.coerceHoverinfo(traceIn, traceOut, layout);
            if (traceOut.type !== "parcats") {
              Registry.getComponentMethod("fx", "supplyDefaults")(traceIn, traceOut, defaultColor, layout);
            }
          }
          if (_module && _module.selectPoints) {
            var selectedpoints = coerce("selectedpoints");
            if (Lib.isTypedArray(selectedpoints)) {
              traceOut.selectedpoints = Array.from(selectedpoints);
            }
          }
        }
        return traceOut;
      };
      plots.supplyLayoutGlobalDefaults = function(layoutIn, layoutOut, formatObj) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);
        }
        var template = layoutIn.template;
        if (Lib.isPlainObject(template)) {
          layoutOut.template = template;
          layoutOut._template = template.layout;
          layoutOut._dataTemplate = template.data;
        }
        coerce("autotypenumbers");
        var font = Lib.coerceFont(coerce, "font");
        var fontSize = font.size;
        Lib.coerceFont(coerce, "title.font", font, { overrideDflt: {
          size: Math.round(fontSize * 1.4)
        } });
        coerce("title.text", layoutOut._dfltTitle.plot);
        coerce("title.xref");
        var titleYref = coerce("title.yref");
        coerce("title.pad.t");
        coerce("title.pad.r");
        coerce("title.pad.b");
        coerce("title.pad.l");
        var titleAutomargin = coerce("title.automargin");
        coerce("title.x");
        coerce("title.xanchor");
        coerce("title.y");
        coerce("title.yanchor");
        coerce("title.subtitle.text", layoutOut._dfltTitle.subtitle);
        Lib.coerceFont(coerce, "title.subtitle.font", font, {
          overrideDflt: {
            size: Math.round(layoutOut.title.font.size * 0.7)
          }
        });
        if (titleAutomargin) {
          if (titleYref === "paper") {
            if (layoutOut.title.y !== 0) layoutOut.title.y = 1;
            if (layoutOut.title.yanchor === "auto") {
              layoutOut.title.yanchor = layoutOut.title.y === 0 ? "top" : "bottom";
            }
          }
          if (titleYref === "container") {
            if (layoutOut.title.y === "auto") layoutOut.title.y = 1;
            if (layoutOut.title.yanchor === "auto") {
              layoutOut.title.yanchor = layoutOut.title.y < 0.5 ? "bottom" : "top";
            }
          }
        }
        var uniformtextMode = coerce("uniformtext.mode");
        if (uniformtextMode) {
          coerce("uniformtext.minsize");
        }
        coerce("autosize", !(layoutIn.width && layoutIn.height));
        coerce("width");
        coerce("height");
        coerce("minreducedwidth");
        coerce("minreducedheight");
        coerce("margin.l");
        coerce("margin.r");
        coerce("margin.t");
        coerce("margin.b");
        coerce("margin.pad");
        coerce("margin.autoexpand");
        if (layoutIn.width && layoutIn.height) plots.sanitizeMargins(layoutOut);
        Registry.getComponentMethod("grid", "sizeDefaults")(layoutIn, layoutOut);
        coerce("paper_bgcolor");
        coerce("separators", formatObj.decimal + formatObj.thousands);
        coerce("hidesources");
        coerce("colorway");
        coerce("datarevision");
        var uirevision = coerce("uirevision");
        coerce("editrevision", uirevision);
        coerce("selectionrevision", uirevision);
        Registry.getComponentMethod(
          "modebar",
          "supplyLayoutDefaults"
        )(layoutIn, layoutOut);
        Registry.getComponentMethod(
          "shapes",
          "supplyDrawNewShapeDefaults"
        )(layoutIn, layoutOut, coerce);
        Registry.getComponentMethod(
          "selections",
          "supplyDrawNewSelectionDefaults"
        )(layoutIn, layoutOut, coerce);
        coerce("meta");
        if (Lib.isPlainObject(layoutIn.transition)) {
          coerce("transition.duration");
          coerce("transition.easing");
          coerce("transition.ordering");
        }
        Registry.getComponentMethod(
          "calendars",
          "handleDefaults"
        )(layoutIn, layoutOut, "calendar");
        Registry.getComponentMethod(
          "fx",
          "supplyLayoutGlobalDefaults"
        )(layoutIn, layoutOut, coerce);
        Lib.coerce(layoutIn, layoutOut, scatterAttrs, "scattermode");
      };
      function getComputedSize(attr) {
        return typeof attr === "string" && attr.substr(attr.length - 2) === "px" && parseFloat(attr);
      }
      plots.plotAutoSize = function plotAutoSize(gd, layout, fullLayout) {
        var context = gd._context || {};
        var frameMargins = context.frameMargins;
        var newWidth;
        var newHeight;
        var isPlotDiv = Lib.isPlotDiv(gd);
        if (isPlotDiv) gd.emit("plotly_autosize");
        if (context.fillFrame) {
          newWidth = window.innerWidth;
          newHeight = window.innerHeight;
          document.body.style.overflow = "hidden";
        } else {
          var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};
          newWidth = getComputedSize(computedStyle.width) || getComputedSize(computedStyle.maxWidth) || fullLayout.width;
          newHeight = getComputedSize(computedStyle.height) || getComputedSize(computedStyle.maxHeight) || fullLayout.height;
          if (isNumeric(frameMargins) && frameMargins > 0) {
            var factor = 1 - 2 * frameMargins;
            newWidth = Math.round(factor * newWidth);
            newHeight = Math.round(factor * newHeight);
          }
        }
        var minWidth = plots.layoutAttributes.width.min;
        var minHeight = plots.layoutAttributes.height.min;
        if (newWidth < minWidth) newWidth = minWidth;
        if (newHeight < minHeight) newHeight = minHeight;
        var widthHasChanged = !layout.width && Math.abs(fullLayout.width - newWidth) > 1;
        var heightHasChanged = !layout.height && Math.abs(fullLayout.height - newHeight) > 1;
        if (heightHasChanged || widthHasChanged) {
          if (widthHasChanged) fullLayout.width = newWidth;
          if (heightHasChanged) fullLayout.height = newHeight;
        }
        if (!gd._initialAutoSize) {
          gd._initialAutoSize = { width: newWidth, height: newHeight };
        }
        plots.sanitizeMargins(fullLayout);
      };
      plots.supplyLayoutModuleDefaults = function(layoutIn, layoutOut, fullData, transitionData) {
        var componentsRegistry = Registry.componentsRegistry;
        var basePlotModules = layoutOut._basePlotModules;
        var component, i, _module;
        var Cartesian = Registry.subplotsRegistry.cartesian;
        for (component in componentsRegistry) {
          _module = componentsRegistry[component];
          if (_module.includeBasePlot) {
            _module.includeBasePlot(layoutIn, layoutOut);
          }
        }
        if (!basePlotModules.length) {
          basePlotModules.push(Cartesian);
        }
        if (layoutOut._has("cartesian")) {
          Registry.getComponentMethod("grid", "contentDefaults")(layoutIn, layoutOut);
          Cartesian.finalizeSubplots(layoutIn, layoutOut);
        }
        for (var subplotType in layoutOut._subplots) {
          layoutOut._subplots[subplotType].sort(Lib.subplotSort);
        }
        for (i = 0; i < basePlotModules.length; i++) {
          _module = basePlotModules[i];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
          }
        }
        var modules = layoutOut._modules;
        for (i = 0; i < modules.length; i++) {
          _module = modules[i];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
          }
        }
        var transformModules = layoutOut._transformModules;
        for (i = 0; i < transformModules.length; i++) {
          _module = transformModules[i];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);
          }
        }
        for (component in componentsRegistry) {
          _module = componentsRegistry[component];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
          }
        }
      };
      plots.purge = function(gd) {
        var fullLayout = gd._fullLayout || {};
        if (fullLayout._glcontainer !== void 0) {
          fullLayout._glcontainer.selectAll(".gl-canvas").remove();
          fullLayout._glcontainer.remove();
          fullLayout._glcanvas = null;
        }
        if (fullLayout._modeBar) fullLayout._modeBar.destroy();
        if (gd._transitionData) {
          if (gd._transitionData._interruptCallbacks) {
            gd._transitionData._interruptCallbacks.length = 0;
          }
          if (gd._transitionData._animationRaf) {
            window.cancelAnimationFrame(gd._transitionData._animationRaf);
          }
        }
        Lib.clearThrottle();
        Lib.clearResponsive(gd);
        delete gd.data;
        delete gd.layout;
        delete gd._fullData;
        delete gd._fullLayout;
        delete gd.calcdata;
        delete gd.empty;
        delete gd.fid;
        delete gd.undoqueue;
        delete gd.undonum;
        delete gd.autoplay;
        delete gd.changed;
        delete gd._promises;
        delete gd._redrawTimer;
        delete gd._hmlumcount;
        delete gd._hmpixcount;
        delete gd._transitionData;
        delete gd._transitioning;
        delete gd._initialAutoSize;
        delete gd._transitioningWithDuration;
        delete gd._dragging;
        delete gd._dragged;
        delete gd._dragdata;
        delete gd._hoverdata;
        delete gd._snapshotInProgress;
        delete gd._editing;
        delete gd._mouseDownTime;
        delete gd._legendMouseDownTime;
        if (gd.removeAllListeners) gd.removeAllListeners();
      };
      plots.style = function(gd) {
        var _modules = gd._fullLayout._visibleModules;
        var styleModules = [];
        var i;
        for (i = 0; i < _modules.length; i++) {
          var _module = _modules[i];
          if (_module.style) {
            Lib.pushUnique(styleModules, _module.style);
          }
        }
        for (i = 0; i < styleModules.length; i++) {
          styleModules[i](gd);
        }
      };
      plots.sanitizeMargins = function(fullLayout) {
        if (!fullLayout || !fullLayout.margin) return;
        var width = fullLayout.width;
        var height = fullLayout.height;
        var margin = fullLayout.margin;
        var plotWidth = width - (margin.l + margin.r);
        var plotHeight = height - (margin.t + margin.b);
        var correction;
        if (plotWidth < 0) {
          correction = (width - 1) / (margin.l + margin.r);
          margin.l = Math.floor(correction * margin.l);
          margin.r = Math.floor(correction * margin.r);
        }
        if (plotHeight < 0) {
          correction = (height - 1) / (margin.t + margin.b);
          margin.t = Math.floor(correction * margin.t);
          margin.b = Math.floor(correction * margin.b);
        }
      };
      plots.clearAutoMarginIds = function(gd) {
        gd._fullLayout._pushmarginIds = {};
      };
      plots.allowAutoMargin = function(gd, id) {
        gd._fullLayout._pushmarginIds[id] = 1;
      };
      function initMargins(fullLayout) {
        var margin = fullLayout.margin;
        if (!fullLayout._size) {
          var gs = fullLayout._size = {
            l: Math.round(margin.l),
            r: Math.round(margin.r),
            t: Math.round(margin.t),
            b: Math.round(margin.b),
            p: Math.round(margin.pad)
          };
          gs.w = Math.round(fullLayout.width) - gs.l - gs.r;
          gs.h = Math.round(fullLayout.height) - gs.t - gs.b;
        }
        if (!fullLayout._pushmargin) fullLayout._pushmargin = {};
        if (!fullLayout._pushmarginIds) fullLayout._pushmarginIds = {};
        if (!fullLayout._reservedMargin) fullLayout._reservedMargin = {};
      }
      var MIN_SPECIFIED_WIDTH = 2;
      var MIN_SPECIFIED_HEIGHT = 2;
      plots.autoMargin = function(gd, id, o) {
        var fullLayout = gd._fullLayout;
        var width = fullLayout.width;
        var height = fullLayout.height;
        var margin = fullLayout.margin;
        var minreducedwidth = fullLayout.minreducedwidth;
        var minreducedheight = fullLayout.minreducedheight;
        var minFinalWidth = Lib.constrain(
          width - margin.l - margin.r,
          MIN_SPECIFIED_WIDTH,
          minreducedwidth
        );
        var minFinalHeight = Lib.constrain(
          height - margin.t - margin.b,
          MIN_SPECIFIED_HEIGHT,
          minreducedheight
        );
        var maxSpaceW = Math.max(0, width - minFinalWidth);
        var maxSpaceH = Math.max(0, height - minFinalHeight);
        var pushMargin = fullLayout._pushmargin;
        var pushMarginIds = fullLayout._pushmarginIds;
        if (margin.autoexpand !== false) {
          if (!o) {
            delete pushMargin[id];
            delete pushMarginIds[id];
          } else {
            var pad = o.pad;
            if (pad === void 0) {
              pad = Math.min(12, margin.l, margin.r, margin.t, margin.b);
            }
            if (maxSpaceW) {
              var rW = (o.l + o.r) / maxSpaceW;
              if (rW > 1) {
                o.l /= rW;
                o.r /= rW;
              }
            }
            if (maxSpaceH) {
              var rH = (o.t + o.b) / maxSpaceH;
              if (rH > 1) {
                o.t /= rH;
                o.b /= rH;
              }
            }
            var xl = o.xl !== void 0 ? o.xl : o.x;
            var xr = o.xr !== void 0 ? o.xr : o.x;
            var yt = o.yt !== void 0 ? o.yt : o.y;
            var yb = o.yb !== void 0 ? o.yb : o.y;
            pushMargin[id] = {
              l: { val: xl, size: o.l + pad },
              r: { val: xr, size: o.r + pad },
              b: { val: yb, size: o.b + pad },
              t: { val: yt, size: o.t + pad }
            };
            pushMarginIds[id] = 1;
          }
          if (!fullLayout._replotting) {
            return plots.doAutoMargin(gd);
          }
        }
      };
      function needsRedrawForShift(gd) {
        if ("_redrawFromAutoMarginCount" in gd._fullLayout) {
          return false;
        }
        var axList = axisIDs.list(gd, "", true);
        for (var ax in axList) {
          if (axList[ax].autoshift || axList[ax].shift) return true;
        }
        return false;
      }
      plots.doAutoMargin = function(gd) {
        var fullLayout = gd._fullLayout;
        var width = fullLayout.width;
        var height = fullLayout.height;
        if (!fullLayout._size) fullLayout._size = {};
        initMargins(fullLayout);
        var gs = fullLayout._size;
        var margin = fullLayout.margin;
        var reservedMargins = { t: 0, b: 0, l: 0, r: 0 };
        var oldMargins = Lib.extendFlat({}, gs);
        var ml = margin.l;
        var mr = margin.r;
        var mt = margin.t;
        var mb = margin.b;
        var pushMargin = fullLayout._pushmargin;
        var pushMarginIds = fullLayout._pushmarginIds;
        var minreducedwidth = fullLayout.minreducedwidth;
        var minreducedheight = fullLayout.minreducedheight;
        if (margin.autoexpand !== false) {
          for (var k in pushMargin) {
            if (!pushMarginIds[k]) delete pushMargin[k];
          }
          var margins = gd._fullLayout._reservedMargin;
          for (var key in margins) {
            for (var side in margins[key]) {
              var val = margins[key][side];
              reservedMargins[side] = Math.max(reservedMargins[side], val);
            }
          }
          pushMargin.base = {
            l: { val: 0, size: ml },
            r: { val: 1, size: mr },
            t: { val: 1, size: mt },
            b: { val: 0, size: mb }
          };
          for (var s in reservedMargins) {
            var autoMarginPush = 0;
            for (var m in pushMargin) {
              if (m !== "base") {
                if (isNumeric(pushMargin[m][s].size)) {
                  autoMarginPush = pushMargin[m][s].size > autoMarginPush ? pushMargin[m][s].size : autoMarginPush;
                }
              }
            }
            var extraMargin = Math.max(0, margin[s] - autoMarginPush);
            reservedMargins[s] = Math.max(0, reservedMargins[s] - extraMargin);
          }
          for (var k1 in pushMargin) {
            var pushleft = pushMargin[k1].l || {};
            var pushbottom = pushMargin[k1].b || {};
            var fl = pushleft.val;
            var pl = pushleft.size;
            var fb = pushbottom.val;
            var pb = pushbottom.size;
            var availableWidth = width - reservedMargins.r - reservedMargins.l;
            var availableHeight = height - reservedMargins.t - reservedMargins.b;
            for (var k2 in pushMargin) {
              if (isNumeric(pl) && pushMargin[k2].r) {
                var fr = pushMargin[k2].r.val;
                var pr = pushMargin[k2].r.size;
                if (fr > fl) {
                  var newL = (pl * fr + (pr - availableWidth) * fl) / (fr - fl);
                  var newR = (pr * (1 - fl) + (pl - availableWidth) * (1 - fr)) / (fr - fl);
                  if (newL + newR > ml + mr) {
                    ml = newL;
                    mr = newR;
                  }
                }
              }
              if (isNumeric(pb) && pushMargin[k2].t) {
                var ft = pushMargin[k2].t.val;
                var pt = pushMargin[k2].t.size;
                if (ft > fb) {
                  var newB = (pb * ft + (pt - availableHeight) * fb) / (ft - fb);
                  var newT = (pt * (1 - fb) + (pb - availableHeight) * (1 - ft)) / (ft - fb);
                  if (newB + newT > mb + mt) {
                    mb = newB;
                    mt = newT;
                  }
                }
              }
            }
          }
        }
        var minFinalWidth = Lib.constrain(
          width - margin.l - margin.r,
          MIN_SPECIFIED_WIDTH,
          minreducedwidth
        );
        var minFinalHeight = Lib.constrain(
          height - margin.t - margin.b,
          MIN_SPECIFIED_HEIGHT,
          minreducedheight
        );
        var maxSpaceW = Math.max(0, width - minFinalWidth);
        var maxSpaceH = Math.max(0, height - minFinalHeight);
        if (maxSpaceW) {
          var rW = (ml + mr) / maxSpaceW;
          if (rW > 1) {
            ml /= rW;
            mr /= rW;
          }
        }
        if (maxSpaceH) {
          var rH = (mb + mt) / maxSpaceH;
          if (rH > 1) {
            mb /= rH;
            mt /= rH;
          }
        }
        gs.l = Math.round(ml) + reservedMargins.l;
        gs.r = Math.round(mr) + reservedMargins.r;
        gs.t = Math.round(mt) + reservedMargins.t;
        gs.b = Math.round(mb) + reservedMargins.b;
        gs.p = Math.round(margin.pad);
        gs.w = Math.round(width) - gs.l - gs.r;
        gs.h = Math.round(height) - gs.t - gs.b;
        if (!fullLayout._replotting && (plots.didMarginChange(oldMargins, gs) || needsRedrawForShift(gd))) {
          if ("_redrawFromAutoMarginCount" in fullLayout) {
            fullLayout._redrawFromAutoMarginCount++;
          } else {
            fullLayout._redrawFromAutoMarginCount = 1;
          }
          var maxNumberOfRedraws = 3 * (1 + Object.keys(pushMarginIds).length);
          if (fullLayout._redrawFromAutoMarginCount < maxNumberOfRedraws) {
            return Registry.call("_doPlot", gd);
          } else {
            fullLayout._size = oldMargins;
            Lib.warn("Too many auto-margin redraws.");
          }
        }
        refineTicks(gd);
      };
      function refineTicks(gd) {
        var axList = axisIDs.list(gd, "", true);
        [
          "_adjustTickLabelsOverflow",
          "_hideCounterAxisInsideTickLabels"
        ].forEach(function(k) {
          for (var i = 0; i < axList.length; i++) {
            var hideFn = axList[i][k];
            if (hideFn) hideFn();
          }
        });
      }
      var marginKeys = ["l", "r", "t", "b", "p", "w", "h"];
      plots.didMarginChange = function(margin0, margin1) {
        for (var i = 0; i < marginKeys.length; i++) {
          var k = marginKeys[i];
          var m0 = margin0[k];
          var m1 = margin1[k];
          if (!isNumeric(m0) || Math.abs(m1 - m0) > 1) {
            return true;
          }
        }
        return false;
      };
      plots.graphJson = function(gd, dataonly, mode, output, useDefaults, includeConfig) {
        if (useDefaults && dataonly && !gd._fullData || useDefaults && !dataonly && !gd._fullLayout) {
          plots.supplyDefaults(gd);
        }
        var data = useDefaults ? gd._fullData : gd.data;
        var layout = useDefaults ? gd._fullLayout : gd.layout;
        var frames = (gd._transitionData || {})._frames;
        function stripObj(d, keepFunction) {
          if (typeof d === "function") {
            return keepFunction ? "_function_" : null;
          }
          if (Lib.isPlainObject(d)) {
            var o = {};
            var src;
            Object.keys(d).sort().forEach(function(v) {
              if (["_", "["].indexOf(v.charAt(0)) !== -1) return;
              if (typeof d[v] === "function") {
                if (keepFunction) o[v] = "_function";
                return;
              }
              if (mode === "keepdata") {
                if (v.substr(v.length - 3) === "src") {
                  return;
                }
              } else if (mode === "keepstream") {
                src = d[v + "src"];
                if (typeof src === "string" && src.indexOf(":") > 0) {
                  if (!Lib.isPlainObject(d.stream)) {
                    return;
                  }
                }
              } else if (mode !== "keepall") {
                src = d[v + "src"];
                if (typeof src === "string" && src.indexOf(":") > 0) {
                  return;
                }
              }
              o[v] = stripObj(d[v], keepFunction);
            });
            return o;
          }
          var dIsArray = Array.isArray(d);
          var dIsTypedArray = Lib.isTypedArray(d);
          if ((dIsArray || dIsTypedArray) && d.dtype && d.shape) {
            var bdata = d.bdata;
            return stripObj({
              dtype: d.dtype,
              shape: d.shape,
              bdata: (
                // case of ArrayBuffer
                Lib.isArrayBuffer(bdata) ? b64encode.encode(bdata) : (
                  // case of b64 string
                  bdata
                )
              )
            }, keepFunction);
          }
          if (dIsArray) {
            return d.map(function(x) {
              return stripObj(x, keepFunction);
            });
          }
          if (dIsTypedArray) {
            return Lib.simpleMap(d, Lib.identity);
          }
          if (Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);
          return d;
        }
        var obj = {
          data: (data || []).map(function(v) {
            var d = stripObj(v);
            if (dataonly) {
              delete d.fit;
            }
            return d;
          })
        };
        if (!dataonly) {
          obj.layout = stripObj(layout);
          if (useDefaults) {
            var gs = layout._size;
            obj.layout.computed = {
              margin: {
                b: gs.b,
                l: gs.l,
                r: gs.r,
                t: gs.t
              }
            };
          }
        }
        if (frames) obj.frames = stripObj(frames);
        if (includeConfig) obj.config = stripObj(gd._context, true);
        return output === "object" ? obj : JSON.stringify(obj);
      };
      plots.modifyFrames = function(gd, operations) {
        var i, op, frame;
        var _frames = gd._transitionData._frames;
        var _frameHash = gd._transitionData._frameHash;
        for (i = 0; i < operations.length; i++) {
          op = operations[i];
          switch (op.type) {
            // No reason this couldn't exist, but is currently unused/untested:
            /* case 'rename':
                frame = _frames[op.index];
                delete _frameHash[frame.name];
                _frameHash[op.name] = frame;
                frame.name = op.name;
                break;*/
            case "replace":
              frame = op.value;
              var oldName = (_frames[op.index] || {}).name;
              var newName = frame.name;
              _frames[op.index] = _frameHash[newName] = frame;
              if (newName !== oldName) {
                delete _frameHash[oldName];
                _frameHash[newName] = frame;
              }
              break;
            case "insert":
              frame = op.value;
              _frameHash[frame.name] = frame;
              _frames.splice(op.index, 0, frame);
              break;
            case "delete":
              frame = _frames[op.index];
              delete _frameHash[frame.name];
              _frames.splice(op.index, 1);
              break;
          }
        }
        return Promise.resolve();
      };
      plots.computeFrame = function(gd, frameName) {
        var frameLookup = gd._transitionData._frameHash;
        var i, traceIndices, traceIndex, destIndex;
        if (!frameName) {
          throw new Error("computeFrame must be given a string frame name");
        }
        var framePtr = frameLookup[frameName.toString()];
        if (!framePtr) {
          return false;
        }
        var frameStack = [framePtr];
        var frameNameStack = [framePtr.name];
        while (framePtr.baseframe && (framePtr = frameLookup[framePtr.baseframe.toString()])) {
          if (frameNameStack.indexOf(framePtr.name) !== -1) break;
          frameStack.push(framePtr);
          frameNameStack.push(framePtr.name);
        }
        var result = {};
        while (framePtr = frameStack.pop()) {
          if (framePtr.layout) {
            result.layout = plots.extendLayout(result.layout, framePtr.layout);
          }
          if (framePtr.data) {
            if (!result.data) {
              result.data = [];
            }
            traceIndices = framePtr.traces;
            if (!traceIndices) {
              traceIndices = [];
              for (i = 0; i < framePtr.data.length; i++) {
                traceIndices[i] = i;
              }
            }
            if (!result.traces) {
              result.traces = [];
            }
            for (i = 0; i < framePtr.data.length; i++) {
              traceIndex = traceIndices[i];
              if (traceIndex === void 0 || traceIndex === null) {
                continue;
              }
              destIndex = result.traces.indexOf(traceIndex);
              if (destIndex === -1) {
                destIndex = result.data.length;
                result.traces[destIndex] = traceIndex;
              }
              result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);
            }
          }
        }
        return result;
      };
      plots.recomputeFrameHash = function(gd) {
        var hash = gd._transitionData._frameHash = {};
        var frames = gd._transitionData._frames;
        for (var i = 0; i < frames.length; i++) {
          var frame = frames[i];
          if (frame && frame.name) {
            hash[frame.name] = frame;
          }
        }
      };
      plots.extendObjectWithContainers = function(dest, src, containerPaths) {
        var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;
        var copy = Lib.extendDeepNoArrays({}, src || {});
        var expandedObj = Lib.expandObjectPaths(copy);
        var containerObj = {};
        if (containerPaths && containerPaths.length) {
          for (i = 0; i < containerPaths.length; i++) {
            containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);
            containerVal = containerProp.get();
            if (containerVal === void 0) {
              Lib.nestedProperty(containerObj, containerPaths[i]).set(null);
            } else {
              containerProp.set(null);
              Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);
            }
          }
        }
        dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);
        if (containerPaths && containerPaths.length) {
          for (i = 0; i < containerPaths.length; i++) {
            srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);
            srcContainer = srcProp.get();
            if (!srcContainer) continue;
            destProp = Lib.nestedProperty(dest, containerPaths[i]);
            destContainer = destProp.get();
            if (!Array.isArray(destContainer)) {
              destContainer = [];
              destProp.set(destContainer);
            }
            for (j = 0; j < srcContainer.length; j++) {
              var srcObj = srcContainer[j];
              if (srcObj === null) destContainer[j] = null;
              else {
                destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);
              }
            }
            destProp.set(destContainer);
          }
        }
        return dest;
      };
      plots.dataArrayContainers = ["transforms", "dimensions"];
      plots.layoutArrayContainers = Registry.layoutArrayContainers;
      plots.extendTrace = function(destTrace, srcTrace) {
        return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);
      };
      plots.extendLayout = function(destLayout, srcLayout) {
        return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);
      };
      plots.transition = function(gd, data, layout, traces, frameOpts, transitionOpts) {
        var opts = { redraw: frameOpts.redraw };
        var transitionedTraces = {};
        var axEdits = [];
        opts.prepareFn = function() {
          var dataLength = Array.isArray(data) ? data.length : 0;
          var traceIndices = traces.slice(0, dataLength);
          for (var i = 0; i < traceIndices.length; i++) {
            var traceIdx = traceIndices[i];
            var trace = gd._fullData[traceIdx];
            var _module = trace._module;
            if (!_module) continue;
            if (_module.animatable) {
              var n = _module.basePlotModule.name;
              if (!transitionedTraces[n]) transitionedTraces[n] = [];
              transitionedTraces[n].push(traceIdx);
            }
            gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);
          }
          var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout));
          var axisAttrRe = /^[xy]axis[0-9]*$/;
          for (var attr in layoutUpdate) {
            if (!axisAttrRe.test(attr)) continue;
            delete layoutUpdate[attr].range;
          }
          plots.extendLayout(gd.layout, layoutUpdate);
          delete gd.calcdata;
          plots.supplyDefaults(gd);
          plots.doCalcdata(gd);
          var newLayout = Lib.expandObjectPaths(layout);
          if (newLayout) {
            var subplots = gd._fullLayout._plots;
            for (var k in subplots) {
              var plotinfo = subplots[k];
              var xa = plotinfo.xaxis;
              var ya = plotinfo.yaxis;
              var xr0 = xa.range.slice();
              var yr0 = ya.range.slice();
              var xr1 = null;
              var yr1 = null;
              var editX = null;
              var editY = null;
              if (Array.isArray(newLayout[xa._name + ".range"])) {
                xr1 = newLayout[xa._name + ".range"].slice();
              } else if (Array.isArray((newLayout[xa._name] || {}).range)) {
                xr1 = newLayout[xa._name].range.slice();
              }
              if (Array.isArray(newLayout[ya._name + ".range"])) {
                yr1 = newLayout[ya._name + ".range"].slice();
              } else if (Array.isArray((newLayout[ya._name] || {}).range)) {
                yr1 = newLayout[ya._name].range.slice();
              }
              if (xr0 && xr1 && (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1]))) {
                editX = { xr0, xr1 };
              }
              if (yr0 && yr1 && (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1]))) {
                editY = { yr0, yr1 };
              }
              if (editX || editY) {
                axEdits.push(Lib.extendFlat({ plotinfo }, editX, editY));
              }
            }
          }
          return Promise.resolve();
        };
        opts.runFn = function(makeCallback) {
          var traceTransitionOpts;
          var basePlotModules = gd._fullLayout._basePlotModules;
          var hasAxisTransition = axEdits.length;
          var i;
          if (layout) {
            for (i = 0; i < basePlotModules.length; i++) {
              if (basePlotModules[i].transitionAxes) {
                basePlotModules[i].transitionAxes(gd, axEdits, transitionOpts, makeCallback);
              }
            }
          }
          if (hasAxisTransition) {
            traceTransitionOpts = Lib.extendFlat({}, transitionOpts);
            traceTransitionOpts.duration = 0;
            delete transitionedTraces.cartesian;
          } else {
            traceTransitionOpts = transitionOpts;
          }
          for (var n in transitionedTraces) {
            var traceIndices = transitionedTraces[n];
            var _module = gd._fullData[traceIndices[0]]._module;
            _module.basePlotModule.plot(gd, traceIndices, traceTransitionOpts, makeCallback);
          }
        };
        return _transition(gd, transitionOpts, opts);
      };
      plots.transitionFromReact = function(gd, restyleFlags, relayoutFlags, oldFullLayout) {
        var fullLayout = gd._fullLayout;
        var transitionOpts = fullLayout.transition;
        var opts = {};
        var axEdits = [];
        opts.prepareFn = function() {
          var subplots = fullLayout._plots;
          opts.redraw = false;
          if (restyleFlags.anim === "some") opts.redraw = true;
          if (relayoutFlags.anim === "some") opts.redraw = true;
          for (var k in subplots) {
            var plotinfo = subplots[k];
            var xa = plotinfo.xaxis;
            var ya = plotinfo.yaxis;
            var xr0 = oldFullLayout[xa._name].range.slice();
            var yr0 = oldFullLayout[ya._name].range.slice();
            var xr1 = xa.range.slice();
            var yr1 = ya.range.slice();
            xa.setScale();
            ya.setScale();
            var editX = null;
            var editY = null;
            if (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1])) {
              editX = { xr0, xr1 };
            }
            if (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1])) {
              editY = { yr0, yr1 };
            }
            if (editX || editY) {
              axEdits.push(Lib.extendFlat({ plotinfo }, editX, editY));
            }
          }
          return Promise.resolve();
        };
        opts.runFn = function(makeCallback) {
          var fullData = gd._fullData;
          var fullLayout2 = gd._fullLayout;
          var basePlotModules = fullLayout2._basePlotModules;
          var axisTransitionOpts;
          var traceTransitionOpts;
          var transitionedTraces;
          var allTraceIndices = [];
          for (var i = 0; i < fullData.length; i++) {
            allTraceIndices.push(i);
          }
          function transitionAxes() {
            if (!gd._fullLayout) return;
            for (var j = 0; j < basePlotModules.length; j++) {
              if (basePlotModules[j].transitionAxes) {
                basePlotModules[j].transitionAxes(gd, axEdits, axisTransitionOpts, makeCallback);
              }
            }
          }
          function transitionTraces() {
            if (!gd._fullLayout) return;
            for (var j = 0; j < basePlotModules.length; j++) {
              basePlotModules[j].plot(gd, transitionedTraces, traceTransitionOpts, makeCallback);
            }
          }
          if (axEdits.length && restyleFlags.anim) {
            if (transitionOpts.ordering === "traces first") {
              axisTransitionOpts = Lib.extendFlat({}, transitionOpts, { duration: 0 });
              transitionedTraces = allTraceIndices;
              traceTransitionOpts = transitionOpts;
              setTimeout(transitionAxes, transitionOpts.duration);
              transitionTraces();
            } else {
              axisTransitionOpts = transitionOpts;
              transitionedTraces = null;
              traceTransitionOpts = Lib.extendFlat({}, transitionOpts, { duration: 0 });
              setTimeout(transitionTraces, axisTransitionOpts.duration);
              transitionAxes();
            }
          } else if (axEdits.length) {
            axisTransitionOpts = transitionOpts;
            transitionAxes();
          } else if (restyleFlags.anim) {
            transitionedTraces = allTraceIndices;
            traceTransitionOpts = transitionOpts;
            transitionTraces();
          }
        };
        return _transition(gd, transitionOpts, opts);
      };
      function _transition(gd, transitionOpts, opts) {
        var aborted = false;
        function executeCallbacks(list) {
          var p = Promise.resolve();
          if (!list) return p;
          while (list.length) {
            p = p.then(list.shift());
          }
          return p;
        }
        function flushCallbacks(list) {
          if (!list) return;
          while (list.length) {
            list.shift();
          }
        }
        function executeTransitions() {
          gd.emit("plotly_transitioning", []);
          return new Promise(function(resolve) {
            gd._transitioning = true;
            if (transitionOpts.duration > 0) {
              gd._transitioningWithDuration = true;
            }
            gd._transitionData._interruptCallbacks.push(function() {
              aborted = true;
            });
            if (opts.redraw) {
              gd._transitionData._interruptCallbacks.push(function() {
                return Registry.call("redraw", gd);
              });
            }
            gd._transitionData._interruptCallbacks.push(function() {
              gd.emit("plotly_transitioninterrupted", []);
            });
            var numCallbacks = 0;
            var numCompleted = 0;
            function makeCallback() {
              numCallbacks++;
              return function() {
                numCompleted++;
                if (!aborted && numCompleted === numCallbacks) {
                  completeTransition(resolve);
                }
              };
            }
            opts.runFn(makeCallback);
            setTimeout(makeCallback());
          });
        }
        function completeTransition(callback) {
          if (!gd._transitionData) return;
          flushCallbacks(gd._transitionData._interruptCallbacks);
          return Promise.resolve().then(function() {
            if (opts.redraw) {
              return Registry.call("redraw", gd);
            }
          }).then(function() {
            gd._transitioning = false;
            gd._transitioningWithDuration = false;
            gd.emit("plotly_transitioned", []);
          }).then(callback);
        }
        function interruptPreviousTransitions() {
          if (!gd._transitionData) return;
          gd._transitioning = false;
          return executeCallbacks(gd._transitionData._interruptCallbacks);
        }
        var seq = [
          plots.previousPromises,
          interruptPreviousTransitions,
          opts.prepareFn,
          plots.rehover,
          plots.reselect,
          executeTransitions
        ];
        var transitionStarting = Lib.syncOrAsync(seq, gd);
        if (!transitionStarting || !transitionStarting.then) {
          transitionStarting = Promise.resolve();
        }
        return transitionStarting.then(function() {
          return gd;
        });
      }
      plots.doCalcdata = function(gd, traces) {
        var axList = axisIDs.list(gd);
        var fullData = gd._fullData;
        var fullLayout = gd._fullLayout;
        var trace, _module, i, j;
        var calcdata = new Array(fullData.length);
        var oldCalcdata = (gd.calcdata || []).slice();
        gd.calcdata = calcdata;
        fullLayout._numBoxes = 0;
        fullLayout._numViolins = 0;
        fullLayout._violinScaleGroupStats = {};
        gd._hmpixcount = 0;
        gd._hmlumcount = 0;
        fullLayout._piecolormap = {};
        fullLayout._sunburstcolormap = {};
        fullLayout._treemapcolormap = {};
        fullLayout._iciclecolormap = {};
        fullLayout._funnelareacolormap = {};
        for (i = 0; i < fullData.length; i++) {
          if (Array.isArray(traces) && traces.indexOf(i) === -1) {
            calcdata[i] = oldCalcdata[i];
            continue;
          }
        }
        for (i = 0; i < fullData.length; i++) {
          trace = fullData[i];
          trace._arrayAttrs = PlotSchema.findArrayAttributes(trace);
          trace._extremes = {};
        }
        var polarIds = fullLayout._subplots.polar || [];
        for (i = 0; i < polarIds.length; i++) {
          axList.push(
            fullLayout[polarIds[i]].radialaxis,
            fullLayout[polarIds[i]].angularaxis
          );
        }
        for (var k in fullLayout._colorAxes) {
          var cOpts = fullLayout[k];
          if (cOpts.cauto !== false) {
            delete cOpts.cmin;
            delete cOpts.cmax;
          }
        }
        var hasCalcTransform = false;
        function transformCalci(i2) {
          trace = fullData[i2];
          _module = trace._module;
          if (trace.visible === true && trace.transforms) {
            if (_module && _module.calc) {
              var cdi = _module.calc(gd, trace);
              if (cdi[0] && cdi[0].t && cdi[0].t._scene) {
                delete cdi[0].t._scene.dirty;
              }
            }
            for (j = 0; j < trace.transforms.length; j++) {
              var transform = trace.transforms[j];
              _module = transformsRegistry[transform.type];
              if (_module && _module.calcTransform) {
                trace._hasCalcTransform = true;
                hasCalcTransform = true;
                _module.calcTransform(gd, trace, transform);
              }
            }
          }
        }
        function calci(i2, isContainer) {
          trace = fullData[i2];
          _module = trace._module;
          if (!!_module.isContainer !== isContainer) return;
          var cd = [];
          if (trace.visible === true && trace._length !== 0) {
            delete trace._indexToPoints;
            var transforms = trace.transforms || [];
            for (j = transforms.length - 1; j >= 0; j--) {
              if (transforms[j].enabled) {
                trace._indexToPoints = transforms[j]._indexToPoints;
                break;
              }
            }
            if (_module && _module.calc) {
              cd = _module.calc(gd, trace);
            }
          }
          if (!Array.isArray(cd) || !cd[0]) {
            cd = [{ x: BADNUM, y: BADNUM }];
          }
          if (!cd[0].t) cd[0].t = {};
          cd[0].trace = trace;
          calcdata[i2] = cd;
        }
        setupAxisCategories(axList, fullData, fullLayout);
        for (i = 0; i < fullData.length; i++) calci(i, true);
        for (i = 0; i < fullData.length; i++) transformCalci(i);
        if (hasCalcTransform) setupAxisCategories(axList, fullData, fullLayout);
        for (i = 0; i < fullData.length; i++) calci(i, true);
        for (i = 0; i < fullData.length; i++) calci(i, false);
        doCrossTraceCalc(gd);
        var sorted = sortAxisCategoriesByValue(axList, gd);
        if (sorted.length) {
          fullLayout._numBoxes = 0;
          fullLayout._numViolins = 0;
          for (i = 0; i < sorted.length; i++) calci(sorted[i], true);
          for (i = 0; i < sorted.length; i++) calci(sorted[i], false);
          doCrossTraceCalc(gd);
        }
        Registry.getComponentMethod("fx", "calc")(gd);
        Registry.getComponentMethod("errorbars", "calc")(gd);
      };
      var sortAxisCategoriesByValueRegex = /(total|sum|min|max|mean|geometric mean|median) (ascending|descending)/;
      function sortAxisCategoriesByValue(axList, gd) {
        var affectedTraces = [];
        var i, j, k, l, o;
        function zMapCategory(type2, ax2, value2) {
          var axLetter2 = ax2._id.charAt(0);
          if (type2 === "histogram2dcontour") {
            var counterAxLetter = ax2._counterAxes[0];
            var counterAx = axisIDs.getFromId(gd, counterAxLetter);
            var xCategorical = axLetter2 === "x" || counterAxLetter === "x" && counterAx.type === "category";
            var yCategorical = axLetter2 === "y" || counterAxLetter === "y" && counterAx.type === "category";
            return function(o2, l2) {
              if (o2 === 0 || l2 === 0) return -1;
              if (xCategorical && o2 === value2[l2].length - 1) return -1;
              if (yCategorical && l2 === value2.length - 1) return -1;
              return (axLetter2 === "y" ? l2 : o2) - 1;
            };
          } else {
            return function(o2, l2) {
              return axLetter2 === "y" ? l2 : o2;
            };
          }
        }
        var aggFn = {
          min: function(values) {
            return Lib.aggNums(Math.min, null, values);
          },
          max: function(values) {
            return Lib.aggNums(Math.max, null, values);
          },
          sum: function(values) {
            return Lib.aggNums(function(a, b) {
              return a + b;
            }, null, values);
          },
          total: function(values) {
            return Lib.aggNums(function(a, b) {
              return a + b;
            }, null, values);
          },
          mean: function(values) {
            return Lib.mean(values);
          },
          "geometric mean": function(values) {
            return Lib.geometricMean(values);
          },
          median: function(values) {
            return Lib.median(values);
          }
        };
        function sortAscending(a, b) {
          return a[1] - b[1];
        }
        function sortDescending(a, b) {
          return b[1] - a[1];
        }
        for (i = 0; i < axList.length; i++) {
          var ax = axList[i];
          if (ax.type !== "category") continue;
          var match = ax.categoryorder.match(sortAxisCategoriesByValueRegex);
          if (match) {
            var aggregator = match[1];
            var order = match[2];
            var axLetter = ax._id.charAt(0);
            var isX = axLetter === "x";
            var categoriesValue = [];
            for (j = 0; j < ax._categories.length; j++) {
              categoriesValue.push([ax._categories[j], []]);
            }
            for (j = 0; j < ax._traceIndices.length; j++) {
              var traceIndex = ax._traceIndices[j];
              var fullTrace = gd._fullData[traceIndex];
              if (fullTrace.visible !== true) continue;
              var type = fullTrace.type;
              if (Registry.traceIs(fullTrace, "histogram")) {
                delete fullTrace._xautoBinFinished;
                delete fullTrace._yautoBinFinished;
              }
              var isSplom = type === "splom";
              var isScattergl = type === "scattergl";
              var cd = gd.calcdata[traceIndex];
              for (k = 0; k < cd.length; k++) {
                var cdi = cd[k];
                var catIndex, value;
                if (isSplom) {
                  var currentDimensionIndex = fullTrace._axesDim[ax._id];
                  if (!isX) {
                    var associatedXAxisID = fullTrace._diag[currentDimensionIndex][0];
                    if (associatedXAxisID) ax = gd._fullLayout[axisIDs.id2name(associatedXAxisID)];
                  }
                  var categories = cdi.trace.dimensions[currentDimensionIndex].values;
                  for (l = 0; l < categories.length; l++) {
                    catIndex = ax._categoriesMap[categories[l]];
                    for (o = 0; o < cdi.trace.dimensions.length; o++) {
                      if (o === currentDimensionIndex) continue;
                      var dimension = cdi.trace.dimensions[o];
                      categoriesValue[catIndex][1].push(dimension.values[l]);
                    }
                  }
                } else if (isScattergl) {
                  for (l = 0; l < cdi.t.x.length; l++) {
                    if (isX) {
                      catIndex = cdi.t.x[l];
                      value = cdi.t.y[l];
                    } else {
                      catIndex = cdi.t.y[l];
                      value = cdi.t.x[l];
                    }
                    categoriesValue[catIndex][1].push(value);
                  }
                  if (cdi.t && cdi.t._scene) {
                    delete cdi.t._scene.dirty;
                  }
                } else if (cdi.hasOwnProperty("z")) {
                  value = cdi.z;
                  var mapping = zMapCategory(fullTrace.type, ax, value);
                  for (l = 0; l < value.length; l++) {
                    for (o = 0; o < value[l].length; o++) {
                      catIndex = mapping(o, l);
                      if (catIndex + 1) categoriesValue[catIndex][1].push(value[l][o]);
                    }
                  }
                } else {
                  catIndex = cdi.p;
                  if (catIndex === void 0) catIndex = cdi[axLetter];
                  value = cdi.s;
                  if (value === void 0) value = cdi.v;
                  if (value === void 0) value = isX ? cdi.y : cdi.x;
                  if (!Array.isArray(value)) {
                    if (value === void 0) value = [];
                    else value = [value];
                  }
                  for (l = 0; l < value.length; l++) {
                    categoriesValue[catIndex][1].push(value[l]);
                  }
                }
              }
            }
            ax._categoriesValue = categoriesValue;
            var categoriesAggregatedValue = [];
            for (j = 0; j < categoriesValue.length; j++) {
              categoriesAggregatedValue.push([
                categoriesValue[j][0],
                aggFn[aggregator](categoriesValue[j][1])
              ]);
            }
            categoriesAggregatedValue.sort(order === "descending" ? sortDescending : sortAscending);
            ax._categoriesAggregatedValue = categoriesAggregatedValue;
            ax._initialCategories = categoriesAggregatedValue.map(function(c) {
              return c[0];
            });
            affectedTraces = affectedTraces.concat(ax.sortByInitialCategories());
          }
        }
        return affectedTraces;
      }
      function setupAxisCategories(axList, fullData, fullLayout) {
        var axLookup = {};
        function setupOne(ax) {
          ax.clearCalc();
          if (ax.type === "multicategory") {
            ax.setupMultiCategory(fullData);
          }
          axLookup[ax._id] = 1;
        }
        Lib.simpleMap(axList, setupOne);
        var matchGroups = fullLayout._axisMatchGroups || [];
        for (var i = 0; i < matchGroups.length; i++) {
          for (var axId in matchGroups[i]) {
            if (!axLookup[axId]) {
              setupOne(fullLayout[axisIDs.id2name(axId)]);
            }
          }
        }
      }
      function doCrossTraceCalc(gd) {
        var fullLayout = gd._fullLayout;
        var modules = fullLayout._visibleModules;
        var hash = {};
        var i, j, k;
        for (j = 0; j < modules.length; j++) {
          var _module = modules[j];
          var fn = _module.crossTraceCalc;
          if (fn) {
            var spType = _module.basePlotModule.name;
            if (hash[spType]) {
              Lib.pushUnique(hash[spType], fn);
            } else {
              hash[spType] = [fn];
            }
          }
        }
        for (k in hash) {
          var methods = hash[k];
          var subplots = fullLayout._subplots[k];
          if (Array.isArray(subplots)) {
            for (i = 0; i < subplots.length; i++) {
              var sp = subplots[i];
              var spInfo = k === "cartesian" ? fullLayout._plots[sp] : fullLayout[sp];
              for (j = 0; j < methods.length; j++) {
                methods[j](gd, spInfo, sp);
              }
            }
          } else {
            for (j = 0; j < methods.length; j++) {
              methods[j](gd);
            }
          }
        }
      }
      plots.rehover = function(gd) {
        if (gd._fullLayout._rehover) {
          gd._fullLayout._rehover();
        }
      };
      plots.redrag = function(gd) {
        if (gd._fullLayout._redrag) {
          gd._fullLayout._redrag();
        }
      };
      plots.reselect = function(gd) {
        var fullLayout = gd._fullLayout;
        var A = (gd.layout || {}).selections;
        var B = fullLayout._previousSelections;
        fullLayout._previousSelections = A;
        var mayEmitSelected = fullLayout._reselect || JSON.stringify(A) !== JSON.stringify(B);
        Registry.getComponentMethod("selections", "reselect")(gd, mayEmitSelected);
      };
      plots.generalUpdatePerTraceModule = function(gd, subplot, subplotCalcData, subplotLayout) {
        var traceHashOld = subplot.traceHash;
        var traceHash = {};
        var i;
        for (i = 0; i < subplotCalcData.length; i++) {
          var calcTraces = subplotCalcData[i];
          var trace = calcTraces[0].trace;
          if (trace.visible) {
            traceHash[trace.type] = traceHash[trace.type] || [];
            traceHash[trace.type].push(calcTraces);
          }
        }
        for (var moduleNameOld in traceHashOld) {
          if (!traceHash[moduleNameOld]) {
            var fakeCalcTrace = traceHashOld[moduleNameOld][0];
            var fakeTrace = fakeCalcTrace[0].trace;
            fakeTrace.visible = false;
            traceHash[moduleNameOld] = [fakeCalcTrace];
          }
        }
        for (var moduleName in traceHash) {
          var moduleCalcData = traceHash[moduleName];
          var _module = moduleCalcData[0][0].trace._module;
          _module.plot(gd, subplot, Lib.filterVisible(moduleCalcData), subplotLayout);
        }
        subplot.traceHash = traceHash;
      };
      plots.plotBasePlot = function(desiredType, gd, traces, transitionOpts, makeOnCompleteCallback) {
        var _module = Registry.getModule(desiredType);
        var cdmodule = getModuleCalcData(gd.calcdata, _module)[0];
        _module.plot(gd, cdmodule, transitionOpts, makeOnCompleteCallback);
      };
      plots.cleanBasePlot = function(desiredType, newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var had = oldFullLayout._has && oldFullLayout._has(desiredType);
        var has = newFullLayout._has && newFullLayout._has(desiredType);
        if (had && !has) {
          oldFullLayout["_" + desiredType + "layer"].selectAll("g.trace").remove();
        }
      };
    }
  });

  // src/constants/xmlns_namespaces.js
  var require_xmlns_namespaces = __commonJS({
    "src/constants/xmlns_namespaces.js"(exports) {
      "use strict";
      exports.xmlns = "http://www.w3.org/2000/xmlns/";
      exports.svg = "http://www.w3.org/2000/svg";
      exports.xlink = "http://www.w3.org/1999/xlink";
      exports.svgAttrs = {
        xmlns: exports.svg,
        "xmlns:xlink": exports.xlink
      };
    }
  });

  // src/constants/alignment.js
  var require_alignment = __commonJS({
    "src/constants/alignment.js"(exports, module) {
      "use strict";
      module.exports = {
        // from bottom left: this is the origin of our paper-reference
        // positioning system
        FROM_BL: {
          left: 0,
          center: 0.5,
          right: 1,
          bottom: 0,
          middle: 0.5,
          top: 1
        },
        // from top left: this is the screen pixel positioning origin
        FROM_TL: {
          left: 0,
          center: 0.5,
          right: 1,
          bottom: 1,
          middle: 0.5,
          top: 0
        },
        // from bottom right: sometimes you just need the opposite of ^^
        FROM_BR: {
          left: 1,
          center: 0.5,
          right: 0,
          bottom: 0,
          middle: 0.5,
          top: 1
        },
        // multiple of fontSize to get the vertical offset between lines
        LINE_SPACING: 1.3,
        // multiple of fontSize to shift from the baseline
        // to the cap (captical letter) line
        // (to use when we don't calculate this shift from Drawing.bBox)
        // This is an approximation since in reality cap height can differ
        // from font to font. However, according to Wikipedia
        //   an "average" font might have a cap height of 70% of the em
        // https://en.wikipedia.org/wiki/Em_(typography)#History
        CAP_SHIFT: 0.7,
        // half the cap height (distance between baseline and cap line)
        // of an "average" font (for more info see above).
        MID_SHIFT: 0.35,
        OPPOSITE_SIDE: {
          left: "right",
          right: "left",
          top: "bottom",
          bottom: "top"
        }
      };
    }
  });

  // src/lib/svg_text_utils.js
  var require_svg_text_utils = __commonJS({
    "src/lib/svg_text_utils.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var xmlnsNamespaces = require_xmlns_namespaces();
      var LINE_SPACING = require_alignment().LINE_SPACING;
      var FIND_TEX = /([^$]*)([$]+[^$]*[$]+)([^$]*)/;
      exports.convertToTspans = function(_context, gd, _callback) {
        var str = _context.text();
        var tex = !_context.attr("data-notex") && gd && gd._context.typesetMath && typeof MathJax !== "undefined" && str.match(FIND_TEX);
        var parent = d3.select(_context.node().parentNode);
        if (parent.empty()) return;
        var svgClass = _context.attr("class") ? _context.attr("class").split(" ")[0] : "text";
        svgClass += "-math";
        parent.selectAll("svg." + svgClass).remove();
        parent.selectAll("g." + svgClass + "-group").remove();
        _context.style("display", null).attr({
          // some callers use data-unformatted *from the <text> element* in 'cancel'
          // so we need it here even if we're going to turn it into math
          // these two (plus style and text-anchor attributes) form the key we're
          // going to use for Drawing.bBox
          "data-unformatted": str,
          "data-math": "N"
        });
        function showText() {
          if (!parent.empty()) {
            svgClass = _context.attr("class") + "-math";
            parent.select("svg." + svgClass).remove();
          }
          _context.text("").style("white-space", "pre");
          var hasLink = buildSVGText(_context.node(), str);
          if (hasLink) {
            _context.style("pointer-events", "all");
          }
          exports.positionText(_context);
          if (_callback) _callback.call(_context);
        }
        if (tex) {
          (gd && gd._promises || []).push(new Promise(function(resolve) {
            _context.style("display", "none");
            var fontSize = parseInt(_context.node().style.fontSize, 10);
            var config = { fontSize };
            texToSVG(tex[2], config, function(_svgEl, _glyphDefs, _svgBBox) {
              parent.selectAll("svg." + svgClass).remove();
              parent.selectAll("g." + svgClass + "-group").remove();
              var newSvg = _svgEl && _svgEl.select("svg");
              if (!newSvg || !newSvg.node()) {
                showText();
                resolve();
                return;
              }
              var mathjaxGroup = parent.append("g").classed(svgClass + "-group", true).attr({
                "pointer-events": "none",
                "data-unformatted": str,
                "data-math": "Y"
              });
              mathjaxGroup.node().appendChild(newSvg.node());
              if (_glyphDefs && _glyphDefs.node()) {
                newSvg.node().insertBefore(
                  _glyphDefs.node().cloneNode(true),
                  newSvg.node().firstChild
                );
              }
              var w0 = _svgBBox.width;
              var h0 = _svgBBox.height;
              newSvg.attr({
                class: svgClass,
                height: h0,
                preserveAspectRatio: "xMinYMin meet"
              }).style({ overflow: "visible", "pointer-events": "none" });
              var fill = _context.node().style.fill || "black";
              var g = newSvg.select("g");
              g.attr({ fill, stroke: fill });
              var bb = g.node().getBoundingClientRect();
              var w = bb.width;
              var h = bb.height;
              if (w > w0 || h > h0) {
                newSvg.style("overflow", "hidden");
                bb = newSvg.node().getBoundingClientRect();
                w = bb.width;
                h = bb.height;
              }
              var x = +_context.attr("x");
              var y = +_context.attr("y");
              var textHeight = fontSize || _context.node().getBoundingClientRect().height;
              var dy = -textHeight / 4;
              if (svgClass[0] === "y") {
                mathjaxGroup.attr({
                  transform: "rotate(" + [-90, x, y] + ")" + strTranslate(-w / 2, dy - h / 2)
                });
              } else if (svgClass[0] === "l") {
                y = dy - h / 2;
              } else if (svgClass[0] === "a" && svgClass.indexOf("atitle") !== 0) {
                x = 0;
                y = dy;
              } else {
                var anchor = _context.attr("text-anchor");
                x = x - w * (anchor === "middle" ? 0.5 : anchor === "end" ? 1 : 0);
                y = y + dy - h / 2;
              }
              newSvg.attr({
                x,
                y
              });
              if (_callback) _callback.call(_context, mathjaxGroup);
              resolve(mathjaxGroup);
            });
          }));
        } else showText();
        return _context;
      };
      var LT_MATCH = /(<|&lt;|&#60;)/g;
      var GT_MATCH = /(>|&gt;|&#62;)/g;
      function cleanEscapesForTex(s) {
        return s.replace(LT_MATCH, "\\lt ").replace(GT_MATCH, "\\gt ");
      }
      var inlineMath = [["$", "$"], ["\\(", "\\)"]];
      function texToSVG(_texString, _config, _callback) {
        var MathJaxVersion = parseInt(
          (MathJax.version || "").split(".")[0]
        );
        if (MathJaxVersion !== 2 && MathJaxVersion !== 3) {
          Lib.warn("No MathJax version:", MathJax.version);
          return;
        }
        var originalRenderer, originalConfig, originalProcessSectionDelay, tmpDiv;
        var setConfig2 = function() {
          originalConfig = Lib.extendDeepAll({}, MathJax.Hub.config);
          originalProcessSectionDelay = MathJax.Hub.processSectionDelay;
          if (MathJax.Hub.processSectionDelay !== void 0) {
            MathJax.Hub.processSectionDelay = 0;
          }
          return MathJax.Hub.Config({
            messageStyle: "none",
            tex2jax: {
              inlineMath
            },
            displayAlign: "left"
          });
        };
        var setConfig3 = function() {
          originalConfig = Lib.extendDeepAll({}, MathJax.config);
          if (!MathJax.config.tex) {
            MathJax.config.tex = {};
          }
          MathJax.config.tex.inlineMath = inlineMath;
        };
        var setRenderer2 = function() {
          originalRenderer = MathJax.Hub.config.menuSettings.renderer;
          if (originalRenderer !== "SVG") {
            return MathJax.Hub.setRenderer("SVG");
          }
        };
        var setRenderer3 = function() {
          originalRenderer = MathJax.config.startup.output;
          if (originalRenderer !== "svg") {
            MathJax.config.startup.output = "svg";
          }
        };
        var initiateMathJax = function() {
          var randomID = "math-output-" + Lib.randstr({}, 64);
          tmpDiv = d3.select("body").append("div").attr({ id: randomID }).style({
            visibility: "hidden",
            position: "absolute",
            "font-size": _config.fontSize + "px"
          }).text(cleanEscapesForTex(_texString));
          var tmpNode = tmpDiv.node();
          return MathJaxVersion === 2 ? MathJax.Hub.Typeset(tmpNode) : MathJax.typeset([tmpNode]);
        };
        var finalizeMathJax = function() {
          var sel = tmpDiv.select(
            MathJaxVersion === 2 ? ".MathJax_SVG" : ".MathJax"
          );
          var node = !sel.empty() && tmpDiv.select("svg").node();
          if (!node) {
            Lib.log("There was an error in the tex syntax.", _texString);
            _callback();
          } else {
            var nodeBBox = node.getBoundingClientRect();
            var glyphDefs;
            if (MathJaxVersion === 2) {
              glyphDefs = d3.select("body").select("#MathJax_SVG_glyphs");
            } else {
              glyphDefs = sel.select("defs");
            }
            _callback(sel, glyphDefs, nodeBBox);
          }
          tmpDiv.remove();
        };
        var resetRenderer2 = function() {
          if (originalRenderer !== "SVG") {
            return MathJax.Hub.setRenderer(originalRenderer);
          }
        };
        var resetRenderer3 = function() {
          if (originalRenderer !== "svg") {
            MathJax.config.startup.output = originalRenderer;
          }
        };
        var resetConfig2 = function() {
          if (originalProcessSectionDelay !== void 0) {
            MathJax.Hub.processSectionDelay = originalProcessSectionDelay;
          }
          return MathJax.Hub.Config(originalConfig);
        };
        var resetConfig3 = function() {
          MathJax.config = originalConfig;
        };
        if (MathJaxVersion === 2) {
          MathJax.Hub.Queue(
            setConfig2,
            setRenderer2,
            initiateMathJax,
            finalizeMathJax,
            resetRenderer2,
            resetConfig2
          );
        } else if (MathJaxVersion === 3) {
          setConfig3();
          setRenderer3();
          MathJax.startup.defaultReady();
          MathJax.startup.promise.then(function() {
            initiateMathJax();
            finalizeMathJax();
            resetRenderer3();
            resetConfig3();
          });
        }
      }
      var TAG_STYLES = {
        // would like to use baseline-shift for sub/sup but FF doesn't support it
        // so we need to use dy along with the uber hacky shift-back-to
        // baseline below
        sup: "font-size:70%",
        sub: "font-size:70%",
        s: "text-decoration:line-through",
        u: "text-decoration:underline",
        b: "font-weight:bold",
        i: "font-style:italic",
        a: "cursor:pointer",
        span: "",
        em: "font-style:italic;font-weight:bold"
      };
      var SHIFT_DY = {
        sub: "0.3em",
        sup: "-0.6em"
      };
      var RESET_DY = {
        sub: "-0.21em",
        sup: "0.42em"
      };
      var ZERO_WIDTH_SPACE = "\u200B";
      var PROTOCOLS = ["http:", "https:", "mailto:", "", void 0, ":"];
      var NEWLINES = exports.NEWLINES = /(\r\n?|\n)/g;
      var SPLIT_TAGS = /(<[^<>]*>)/;
      var ONE_TAG = /<(\/?)([^ >]*)(\s+(.*))?>/i;
      var BR_TAG = /<br(\s+.*)?>/i;
      exports.BR_TAG_ALL = /<br(\s+.*)?>/gi;
      var STYLEMATCH = /(^|[\s"'])style\s*=\s*("([^"]*);?"|'([^']*);?')/i;
      var HREFMATCH = /(^|[\s"'])href\s*=\s*("([^"]*)"|'([^']*)')/i;
      var TARGETMATCH = /(^|[\s"'])target\s*=\s*("([^"\s]*)"|'([^'\s]*)')/i;
      var POPUPMATCH = /(^|[\s"'])popup\s*=\s*("([\w=,]*)"|'([\w=,]*)')/i;
      function getQuotedMatch(_str, re) {
        if (!_str) return null;
        var match = _str.match(re);
        var result = match && (match[3] || match[4]);
        return result && convertEntities(result);
      }
      var COLORMATCH = /(^|;)\s*color:/;
      exports.plainText = function(_str, opts) {
        opts = opts || {};
        var len = opts.len !== void 0 && opts.len !== -1 ? opts.len : Infinity;
        var allowedTags = opts.allowedTags !== void 0 ? opts.allowedTags : ["br"];
        var ellipsis = "...";
        var eLen = ellipsis.length;
        var oldParts = _str.split(SPLIT_TAGS);
        var newParts = [];
        var prevTag = "";
        var l = 0;
        for (var i = 0; i < oldParts.length; i++) {
          var p = oldParts[i];
          var match = p.match(ONE_TAG);
          var tagType = match && match[2].toLowerCase();
          if (tagType) {
            if (allowedTags.indexOf(tagType) !== -1) {
              newParts.push(p);
              prevTag = tagType;
            }
          } else {
            var pLen = p.length;
            if (l + pLen < len) {
              newParts.push(p);
              l += pLen;
            } else if (l < len) {
              var pLen2 = len - l;
              if (prevTag && (prevTag !== "br" || pLen2 <= eLen || pLen <= eLen)) {
                newParts.pop();
              }
              if (len > eLen) {
                newParts.push(p.substr(0, pLen2 - eLen) + ellipsis);
              } else {
                newParts.push(p.substr(0, pLen2));
              }
              break;
            }
            prevTag = "";
          }
        }
        return newParts.join("");
      };
      var entityToUnicode = {
        mu: "\u03BC",
        amp: "&",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        times: "\xD7",
        plusmn: "\xB1",
        deg: "\xB0"
      };
      var ENTITY_MATCH = /&(#\d+|#x[\da-fA-F]+|[a-z]+);/g;
      function convertEntities(_str) {
        return _str.replace(ENTITY_MATCH, function(fullMatch, innerMatch) {
          var outChar;
          if (innerMatch.charAt(0) === "#") {
            outChar = fromCodePoint(
              innerMatch.charAt(1) === "x" ? parseInt(innerMatch.substr(2), 16) : parseInt(innerMatch.substr(1), 10)
            );
          } else outChar = entityToUnicode[innerMatch];
          return outChar || fullMatch;
        });
      }
      exports.convertEntities = convertEntities;
      function fromCodePoint(code) {
        if (code > 1114111) return;
        var stringFromCodePoint = String.fromCodePoint;
        if (stringFromCodePoint) return stringFromCodePoint(code);
        var stringFromCharCode = String.fromCharCode;
        if (code <= 65535) return stringFromCharCode(code);
        return stringFromCharCode(
          (code >> 10) + 55232,
          code % 1024 + 56320
        );
      }
      function buildSVGText(containerNode, str) {
        str = str.replace(NEWLINES, " ");
        var hasLink = false;
        var nodeStack = [];
        var currentNode;
        var currentLine = -1;
        function newLine() {
          currentLine++;
          var lineNode = document.createElementNS(xmlnsNamespaces.svg, "tspan");
          d3.select(lineNode).attr({
            class: "line",
            dy: currentLine * LINE_SPACING + "em"
          });
          containerNode.appendChild(lineNode);
          currentNode = lineNode;
          var oldNodeStack = nodeStack;
          nodeStack = [{ node: lineNode }];
          if (oldNodeStack.length > 1) {
            for (var i2 = 1; i2 < oldNodeStack.length; i2++) {
              enterNode(oldNodeStack[i2]);
            }
          }
        }
        function enterNode(nodeSpec2) {
          var type = nodeSpec2.type;
          var nodeAttrs = {};
          var nodeType;
          if (type === "a") {
            nodeType = "a";
            var target = nodeSpec2.target;
            var href2 = nodeSpec2.href;
            var popup = nodeSpec2.popup;
            if (href2) {
              nodeAttrs = {
                "xlink:xlink:show": target === "_blank" || target.charAt(0) !== "_" ? "new" : "replace",
                target,
                "xlink:xlink:href": href2
              };
              if (popup) {
                nodeAttrs.onclick = 'window.open(this.href.baseVal,this.target.baseVal,"' + popup + '");return false;';
              }
            }
          } else nodeType = "tspan";
          if (nodeSpec2.style) nodeAttrs.style = nodeSpec2.style;
          var newNode = document.createElementNS(xmlnsNamespaces.svg, nodeType);
          if (type === "sup" || type === "sub") {
            addTextNode(currentNode, ZERO_WIDTH_SPACE);
            currentNode.appendChild(newNode);
            var resetter = document.createElementNS(xmlnsNamespaces.svg, "tspan");
            addTextNode(resetter, ZERO_WIDTH_SPACE);
            d3.select(resetter).attr("dy", RESET_DY[type]);
            nodeAttrs.dy = SHIFT_DY[type];
            currentNode.appendChild(newNode);
            currentNode.appendChild(resetter);
          } else {
            currentNode.appendChild(newNode);
          }
          d3.select(newNode).attr(nodeAttrs);
          currentNode = nodeSpec2.node = newNode;
          nodeStack.push(nodeSpec2);
        }
        function addTextNode(node, text) {
          node.appendChild(document.createTextNode(text));
        }
        function exitNode(type) {
          if (nodeStack.length === 1) {
            Lib.log("Ignoring unexpected end tag </" + type + ">.", str);
            return;
          }
          var innerNode = nodeStack.pop();
          if (type !== innerNode.type) {
            Lib.log("Start tag <" + innerNode.type + "> doesnt match end tag <" + type + ">. Pretending it did match.", str);
          }
          currentNode = nodeStack[nodeStack.length - 1].node;
        }
        var hasLines = BR_TAG.test(str);
        if (hasLines) newLine();
        else {
          currentNode = containerNode;
          nodeStack = [{ node: containerNode }];
        }
        var parts = str.split(SPLIT_TAGS);
        for (var i = 0; i < parts.length; i++) {
          var parti = parts[i];
          var match = parti.match(ONE_TAG);
          var tagType = match && match[2].toLowerCase();
          var tagStyle = TAG_STYLES[tagType];
          if (tagType === "br") {
            newLine();
          } else if (tagStyle === void 0) {
            addTextNode(currentNode, convertEntities(parti));
          } else {
            if (match[1]) {
              exitNode(tagType);
            } else {
              var extra = match[4];
              var nodeSpec = { type: tagType };
              var css = getQuotedMatch(extra, STYLEMATCH);
              if (css) {
                css = css.replace(COLORMATCH, "$1 fill:");
                if (tagStyle) css += ";" + tagStyle;
              } else if (tagStyle) css = tagStyle;
              if (css) nodeSpec.style = css;
              if (tagType === "a") {
                hasLink = true;
                var href = getQuotedMatch(extra, HREFMATCH);
                if (href) {
                  var safeHref = sanitizeHref(href);
                  if (safeHref) {
                    nodeSpec.href = safeHref;
                    nodeSpec.target = getQuotedMatch(extra, TARGETMATCH) || "_blank";
                    nodeSpec.popup = getQuotedMatch(extra, POPUPMATCH);
                  }
                }
              }
              enterNode(nodeSpec);
            }
          }
        }
        return hasLink;
      }
      function sanitizeHref(href) {
        var decodedHref = encodeURI(decodeURI(href));
        var dummyAnchor1 = document.createElement("a");
        var dummyAnchor2 = document.createElement("a");
        dummyAnchor1.href = href;
        dummyAnchor2.href = decodedHref;
        var p1 = dummyAnchor1.protocol;
        var p2 = dummyAnchor2.protocol;
        if (PROTOCOLS.indexOf(p1) !== -1 && PROTOCOLS.indexOf(p2) !== -1) {
          return decodedHref;
        } else {
          return "";
        }
      }
      exports.sanitizeHTML = function sanitizeHTML(str) {
        str = str.replace(NEWLINES, " ");
        var rootNode = document.createElement("p");
        var currentNode = rootNode;
        var nodeStack = [];
        var parts = str.split(SPLIT_TAGS);
        for (var i = 0; i < parts.length; i++) {
          var parti = parts[i];
          var match = parti.match(ONE_TAG);
          var tagType = match && match[2].toLowerCase();
          if (tagType in TAG_STYLES) {
            if (match[1]) {
              if (nodeStack.length) {
                currentNode = nodeStack.pop();
              }
            } else {
              var extra = match[4];
              var css = getQuotedMatch(extra, STYLEMATCH);
              var nodeAttrs = css ? { style: css } : {};
              if (tagType === "a") {
                var href = getQuotedMatch(extra, HREFMATCH);
                if (href) {
                  var safeHref = sanitizeHref(href);
                  if (safeHref) {
                    nodeAttrs.href = safeHref;
                    var target = getQuotedMatch(extra, TARGETMATCH);
                    if (target) {
                      nodeAttrs.target = target;
                    }
                  }
                }
              }
              var newNode = document.createElement(tagType);
              currentNode.appendChild(newNode);
              d3.select(newNode).attr(nodeAttrs);
              currentNode = newNode;
              nodeStack.push(newNode);
            }
          } else {
            currentNode.appendChild(
              document.createTextNode(convertEntities(parti))
            );
          }
        }
        var key = "innerHTML";
        return rootNode[key];
      };
      exports.lineCount = function lineCount(s) {
        return s.selectAll("tspan.line").size() || 1;
      };
      exports.positionText = function positionText(s, x, y) {
        return s.each(function() {
          var text = d3.select(this);
          function setOrGet(attr, val) {
            if (val === void 0) {
              val = text.attr(attr);
              if (val === null) {
                text.attr(attr, 0);
                val = 0;
              }
            } else text.attr(attr, val);
            return val;
          }
          var thisX = setOrGet("x", x);
          var thisY = setOrGet("y", y);
          if (this.nodeName === "text") {
            text.selectAll("tspan.line").attr({ x: thisX, y: thisY });
          }
        });
      };
      function alignHTMLWith(_base, container, options) {
        var alignH = options.horizontalAlign;
        var alignV = options.verticalAlign || "top";
        var bRect = _base.node().getBoundingClientRect();
        var cRect = container.node().getBoundingClientRect();
        var thisRect;
        var getTop;
        var getLeft;
        if (alignV === "bottom") {
          getTop = function() {
            return bRect.bottom - thisRect.height;
          };
        } else if (alignV === "middle") {
          getTop = function() {
            return bRect.top + (bRect.height - thisRect.height) / 2;
          };
        } else {
          getTop = function() {
            return bRect.top;
          };
        }
        if (alignH === "right") {
          getLeft = function() {
            return bRect.right - thisRect.width;
          };
        } else if (alignH === "center") {
          getLeft = function() {
            return bRect.left + (bRect.width - thisRect.width) / 2;
          };
        } else {
          getLeft = function() {
            return bRect.left;
          };
        }
        return function() {
          thisRect = this.node().getBoundingClientRect();
          var x0 = getLeft() - cRect.left;
          var y0 = getTop() - cRect.top;
          var gd = options.gd || {};
          if (options.gd) {
            gd._fullLayout._calcInverseTransform(gd);
            var transformedCoords = Lib.apply3DTransform(gd._fullLayout._invTransform)(x0, y0);
            x0 = transformedCoords[0];
            y0 = transformedCoords[1];
          }
          this.style({
            top: y0 + "px",
            left: x0 + "px",
            "z-index": 1e3
          });
          return this;
        };
      }
      var onePx = "1px ";
      exports.makeTextShadow = function(color) {
        var x = onePx;
        var y = onePx;
        var b = onePx;
        return x + y + b + color + ", -" + x + "-" + y + b + color + ", " + x + "-" + y + b + color + ", -" + x + y + b + color;
      };
      exports.makeEditable = function(context, options) {
        var gd = options.gd;
        var _delegate = options.delegate;
        var dispatch = d3.dispatch("edit", "input", "cancel");
        var handlerElement = _delegate || context;
        context.style({ "pointer-events": _delegate ? "none" : "all" });
        if (context.size() !== 1) throw new Error("boo");
        function handleClick() {
          appendEditable();
          context.style({ opacity: 0 });
          var svgClass = handlerElement.attr("class");
          var mathjaxClass;
          if (svgClass) mathjaxClass = "." + svgClass.split(" ")[0] + "-math-group";
          else mathjaxClass = "[class*=-math-group]";
          if (mathjaxClass) {
            d3.select(context.node().parentNode).select(mathjaxClass).style({ opacity: 0 });
          }
        }
        function selectElementContents(_el) {
          var el = _el.node();
          var range = document.createRange();
          range.selectNodeContents(el);
          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
          el.focus();
        }
        function appendEditable() {
          var plotDiv = d3.select(gd);
          var container = plotDiv.select(".svg-container");
          var div = container.append("div");
          var cStyle = context.node().style;
          var fontSize = parseFloat(cStyle.fontSize || 12);
          var initialText = options.text;
          if (initialText === void 0) initialText = context.attr("data-unformatted");
          div.classed("plugin-editable editable", true).style({
            position: "absolute",
            "font-family": cStyle.fontFamily || "Arial",
            "font-size": fontSize,
            color: options.fill || cStyle.fill || "black",
            opacity: 1,
            "background-color": options.background || "transparent",
            outline: "#ffffff33 1px solid",
            margin: [-fontSize / 8 + 1, 0, 0, -1].join("px ") + "px",
            padding: "0",
            "box-sizing": "border-box"
          }).attr({ contenteditable: true }).text(initialText).call(alignHTMLWith(context, container, options)).on("blur", function() {
            gd._editing = false;
            context.text(this.textContent).style({ opacity: 1 });
            var svgClass = d3.select(this).attr("class");
            var mathjaxClass;
            if (svgClass) mathjaxClass = "." + svgClass.split(" ")[0] + "-math-group";
            else mathjaxClass = "[class*=-math-group]";
            if (mathjaxClass) {
              d3.select(context.node().parentNode).select(mathjaxClass).style({ opacity: 0 });
            }
            var text = this.textContent;
            d3.select(this).transition().duration(0).remove();
            d3.select(document).on("mouseup", null);
            dispatch.edit.call(context, text);
          }).on("focus", function() {
            var editDiv = this;
            gd._editing = true;
            d3.select(document).on("mouseup", function() {
              if (d3.event.target === editDiv) return false;
              if (document.activeElement === div.node()) div.node().blur();
            });
          }).on("keyup", function() {
            if (d3.event.which === 27) {
              gd._editing = false;
              context.style({ opacity: 1 });
              d3.select(this).style({ opacity: 0 }).on("blur", function() {
                return false;
              }).transition().remove();
              dispatch.cancel.call(context, this.textContent);
            } else {
              dispatch.input.call(context, this.textContent);
              d3.select(this).call(alignHTMLWith(context, container, options));
            }
          }).on("keydown", function() {
            if (d3.event.which === 13) this.blur();
          }).call(selectElementContents);
        }
        if (options.immediate) handleClick();
        else handlerElement.on("click", handleClick);
        return d3.rebind(context, dispatch, "on");
      };
    }
  });

  // src/components/colorscale/helpers.js
  var require_helpers = __commonJS({
    "src/components/colorscale/helpers.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var tinycolor = require_tinycolor();
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Color = require_color();
      var isValidScale = require_scales().isValid;
      function hasColorscale(trace, containerStr, colorKey) {
        var container = containerStr ? Lib.nestedProperty(trace, containerStr).get() || {} : trace;
        var color = container[colorKey || "color"];
        if (color && color._inputArray) color = color._inputArray;
        var isArrayWithOneNumber = false;
        if (Lib.isArrayOrTypedArray(color)) {
          for (var i = 0; i < color.length; i++) {
            if (isNumeric(color[i])) {
              isArrayWithOneNumber = true;
              break;
            }
          }
        }
        return Lib.isPlainObject(container) && (isArrayWithOneNumber || container.showscale === true || isNumeric(container.cmin) && isNumeric(container.cmax) || isValidScale(container.colorscale) || Lib.isPlainObject(container.colorbar));
      }
      var constantAttrs = ["showscale", "autocolorscale", "colorscale", "reversescale", "colorbar"];
      var letterAttrs = ["min", "max", "mid", "auto"];
      function extractOpts(cont) {
        var colorAx = cont._colorAx;
        var cont2 = colorAx ? colorAx : cont;
        var out = {};
        var cLetter;
        var i, k;
        for (i = 0; i < constantAttrs.length; i++) {
          k = constantAttrs[i];
          out[k] = cont2[k];
        }
        if (colorAx) {
          cLetter = "c";
          for (i = 0; i < letterAttrs.length; i++) {
            k = letterAttrs[i];
            out[k] = cont2["c" + k];
          }
        } else {
          var k2;
          for (i = 0; i < letterAttrs.length; i++) {
            k = letterAttrs[i];
            k2 = "c" + k;
            if (k2 in cont2) {
              out[k] = cont2[k2];
              continue;
            }
            k2 = "z" + k;
            if (k2 in cont2) {
              out[k] = cont2[k2];
            }
          }
          cLetter = k2.charAt(0);
        }
        out._sync = function(k3, v) {
          var k22 = letterAttrs.indexOf(k3) !== -1 ? cLetter + k3 : k3;
          cont2[k22] = cont2["_" + k22] = v;
        };
        return out;
      }
      function extractScale(cont) {
        var cOpts = extractOpts(cont);
        var cmin = cOpts.min;
        var cmax = cOpts.max;
        var scl = cOpts.reversescale ? flipScale(cOpts.colorscale) : cOpts.colorscale;
        var N = scl.length;
        var domain = new Array(N);
        var range = new Array(N);
        for (var i = 0; i < N; i++) {
          var si = scl[i];
          domain[i] = cmin + si[0] * (cmax - cmin);
          range[i] = si[1];
        }
        return { domain, range };
      }
      function flipScale(scl) {
        var N = scl.length;
        var sclNew = new Array(N);
        for (var i = N - 1, j = 0; i >= 0; i--, j++) {
          var si = scl[i];
          sclNew[j] = [1 - si[0], si[1]];
        }
        return sclNew;
      }
      function makeColorScaleFunc(specs, opts) {
        opts = opts || {};
        var domain = specs.domain;
        var range = specs.range;
        var N = range.length;
        var _range = new Array(N);
        for (var i = 0; i < N; i++) {
          var rgba = tinycolor(range[i]).toRgb();
          _range[i] = [rgba.r, rgba.g, rgba.b, rgba.a];
        }
        var _sclFunc = d3.scale.linear().domain(domain).range(_range).clamp(true);
        var noNumericCheck = opts.noNumericCheck;
        var returnArray = opts.returnArray;
        var sclFunc;
        if (noNumericCheck && returnArray) {
          sclFunc = _sclFunc;
        } else if (noNumericCheck) {
          sclFunc = function(v) {
            return colorArray2rbga(_sclFunc(v));
          };
        } else if (returnArray) {
          sclFunc = function(v) {
            if (isNumeric(v)) return _sclFunc(v);
            else if (tinycolor(v).isValid()) return v;
            else return Color.defaultLine;
          };
        } else {
          sclFunc = function(v) {
            if (isNumeric(v)) return colorArray2rbga(_sclFunc(v));
            else if (tinycolor(v).isValid()) return v;
            else return Color.defaultLine;
          };
        }
        sclFunc.domain = _sclFunc.domain;
        sclFunc.range = function() {
          return range;
        };
        return sclFunc;
      }
      function makeColorScaleFuncFromTrace(trace, opts) {
        return makeColorScaleFunc(extractScale(trace), opts);
      }
      function colorArray2rbga(colorArray) {
        var colorObj = {
          r: colorArray[0],
          g: colorArray[1],
          b: colorArray[2],
          a: colorArray[3]
        };
        return tinycolor(colorObj).toRgbString();
      }
      module.exports = {
        hasColorscale,
        extractOpts,
        extractScale,
        flipScale,
        makeColorScaleFunc,
        makeColorScaleFuncFromTrace
      };
    }
  });

  // src/plots/cartesian/axis_format_attributes.js
  var require_axis_format_attributes = __commonJS({
    "src/plots/cartesian/axis_format_attributes.js"(exports, module) {
      "use strict";
      var docs = require_docs();
      var FORMAT_LINK = docs.FORMAT_LINK;
      var DATE_FORMAT_LINK = docs.DATE_FORMAT_LINK;
      function axisHoverFormat(x, noDates) {
        return {
          valType: "string",
          dflt: "",
          editType: "none",
          description: (noDates ? descriptionOnlyNumbers : descriptionWithDates)("hover text", x) + [
            "By default the values are formatted using " + (noDates ? "generic number format" : "`" + x + "axis.hoverformat`") + "."
          ].join(" ")
        };
      }
      function descriptionOnlyNumbers(label, x) {
        return [
          "Sets the " + label + " formatting rule" + (x ? "for `" + x + "` " : ""),
          "using d3 formatting mini-languages",
          "which are very similar to those in Python. For numbers, see: " + FORMAT_LINK + "."
        ].join(" ");
      }
      function descriptionWithDates(label, x) {
        return descriptionOnlyNumbers(label, x) + [
          " And for dates see: " + DATE_FORMAT_LINK + ".",
          "We add two items to d3's date formatter:",
          "*%h* for half of the year as a decimal number as well as",
          "*%{n}f* for fractional seconds",
          "with n digits. For example, *2016-10-13 09:15:23.456* with tickformat",
          "*%H~%M~%S.%2f* would display *09~15~23.46*"
        ].join(" ");
      }
      module.exports = {
        axisHoverFormat,
        descriptionOnlyNumbers,
        descriptionWithDates
      };
    }
  });

  // src/plots/cartesian/layout_attributes.js
  var require_layout_attributes4 = __commonJS({
    "src/plots/cartesian/layout_attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var templatedArray = require_plot_template().templatedArray;
      var descriptionWithDates = require_axis_format_attributes().descriptionWithDates;
      var ONEDAY = require_numerical().ONEDAY;
      var constants = require_constants2();
      var HOUR = constants.HOUR_PATTERN;
      var DAY_OF_WEEK = constants.WEEKDAY_PATTERN;
      var minorTickmode = {
        valType: "enumerated",
        values: ["auto", "linear", "array"],
        editType: "ticks",
        impliedEdits: { tick0: void 0, dtick: void 0 }
      };
      var tickmode = extendFlat({}, minorTickmode, {
        values: minorTickmode.values.slice().concat(["sync"])
      });
      function makeNticks(minor) {
        return {
          valType: "integer",
          min: 0,
          dflt: minor ? 5 : 0,
          editType: "ticks"
        };
      }
      var tick0 = {
        valType: "any",
        editType: "ticks",
        impliedEdits: { tickmode: "linear" }
      };
      var dtick = {
        valType: "any",
        editType: "ticks",
        impliedEdits: { tickmode: "linear" }
      };
      var tickvals = {
        valType: "data_array",
        editType: "ticks"
      };
      var ticks = {
        valType: "enumerated",
        values: ["outside", "inside", ""],
        editType: "ticks"
      };
      function makeTicklen(minor) {
        var obj = {
          valType: "number",
          min: 0,
          editType: "ticks"
        };
        if (!minor) obj.dflt = 5;
        return obj;
      }
      function makeTickwidth(minor) {
        var obj = {
          valType: "number",
          min: 0,
          editType: "ticks"
        };
        if (!minor) obj.dflt = 1;
        return obj;
      }
      var tickcolor = {
        valType: "color",
        dflt: colorAttrs.defaultLine,
        editType: "ticks"
      };
      var gridcolor = {
        valType: "color",
        dflt: colorAttrs.lightLine,
        editType: "ticks"
      };
      function makeGridwidth(minor) {
        var obj = {
          valType: "number",
          min: 0,
          editType: "ticks"
        };
        if (!minor) obj.dflt = 1;
        return obj;
      }
      var griddash = extendFlat({}, dash, { editType: "ticks" });
      var showgrid = {
        valType: "boolean",
        editType: "ticks"
      };
      module.exports = {
        visible: {
          valType: "boolean",
          editType: "plot"
        },
        color: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "ticks"
        },
        title: {
          text: {
            valType: "string",
            editType: "ticks"
          },
          font: fontAttrs({
            editType: "ticks"
          }),
          standoff: {
            valType: "number",
            min: 0,
            editType: "ticks"
          },
          editType: "ticks"
        },
        type: {
          valType: "enumerated",
          // '-' means we haven't yet run autotype or couldn't find any data
          // it gets turned into linear in gd._fullLayout but not copied back
          // to gd.data like the others are.
          values: ["-", "linear", "log", "date", "category", "multicategory"],
          dflt: "-",
          editType: "calc",
          // we forget when an axis has been autotyped, just writing the auto
          // value back to the input - so it doesn't make sense to template this.
          // Note: we do NOT prohibit this in `coerce`, so if someone enters a
          // type in the template explicitly it will be honored as the default.
          _noTemplating: true
        },
        autotypenumbers: {
          valType: "enumerated",
          values: ["convert types", "strict"],
          dflt: "convert types",
          editType: "calc"
        },
        autorange: {
          valType: "enumerated",
          values: [true, false, "reversed", "min reversed", "max reversed", "min", "max"],
          dflt: true,
          editType: "axrange",
          impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
        },
        autorangeoptions: {
          minallowed: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          maxallowed: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          clipmin: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          clipmax: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          include: {
            valType: "any",
            arrayOk: true,
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          editType: "plot"
        },
        rangemode: {
          valType: "enumerated",
          values: ["normal", "tozero", "nonnegative"],
          dflt: "normal",
          editType: "plot"
        },
        range: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "axrange", impliedEdits: { "^autorange": false }, anim: true },
            { valType: "any", editType: "axrange", impliedEdits: { "^autorange": false }, anim: true }
          ],
          editType: "axrange",
          impliedEdits: { autorange: false },
          anim: true
        },
        minallowed: {
          valType: "any",
          editType: "plot",
          impliedEdits: { "^autorange": false }
        },
        maxallowed: {
          valType: "any",
          editType: "plot",
          impliedEdits: { "^autorange": false }
        },
        fixedrange: {
          valType: "boolean",
          dflt: false,
          editType: "calc"
        },
        insiderange: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "plot" },
            { valType: "any", editType: "plot" }
          ],
          editType: "plot"
        },
        // scaleanchor: not used directly, just put here for reference
        // values are any opposite-letter axis id, or `false`.
        scaleanchor: {
          valType: "enumerated",
          values: [
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString(),
            false
          ],
          editType: "plot"
        },
        scaleratio: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "plot"
        },
        constrain: {
          valType: "enumerated",
          values: ["range", "domain"],
          editType: "plot"
        },
        // constraintoward: not used directly, just put here for reference
        constraintoward: {
          valType: "enumerated",
          values: ["left", "center", "right", "top", "middle", "bottom"],
          editType: "plot"
        },
        matches: {
          valType: "enumerated",
          values: [
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString()
          ],
          editType: "calc"
        },
        rangebreaks: templatedArray("rangebreak", {
          enabled: {
            valType: "boolean",
            dflt: true,
            editType: "calc"
          },
          bounds: {
            valType: "info_array",
            items: [
              { valType: "any", editType: "calc" },
              { valType: "any", editType: "calc" }
            ],
            editType: "calc"
          },
          pattern: {
            valType: "enumerated",
            values: [DAY_OF_WEEK, HOUR, ""],
            editType: "calc"
          },
          values: {
            valType: "info_array",
            freeLength: true,
            editType: "calc",
            items: {
              valType: "any",
              editType: "calc"
            }
          },
          dvalue: {
            // TODO could become 'any' to add support for 'months', 'years'
            valType: "number",
            editType: "calc",
            min: 0,
            dflt: ONEDAY
          },
          /*
          gap: {
              valType: 'number',
              min: 0,
              dflt: 0, // for *date* axes, maybe something else for *linear*
              editType: 'calc',
          },
          gapmode: {
              valType: 'enumerated',
              values: ['pixels', 'fraction'],
              dflt: 'pixels',
              editType: 'calc',
          },
          */
          // To complete https://github.com/plotly/plotly.js/issues/4210
          // we additionally need `gap` and make this work on *linear*, and
          // possibly all other cartesian axis types. We possibly would also need
          // some style attributes controlling the zig-zag on the corresponding
          // axis.
          editType: "calc"
        }),
        // ticks
        tickmode,
        nticks: makeNticks(),
        tick0,
        dtick,
        ticklabelstep: {
          valType: "integer",
          min: 1,
          dflt: 1,
          editType: "ticks"
        },
        tickvals,
        ticktext: {
          valType: "data_array",
          editType: "ticks"
        },
        ticks,
        tickson: {
          valType: "enumerated",
          values: ["labels", "boundaries"],
          dflt: "labels",
          editType: "ticks"
        },
        ticklabelmode: {
          valType: "enumerated",
          values: ["instant", "period"],
          dflt: "instant",
          editType: "ticks"
        },
        // ticklabelposition: not used directly, as values depend on direction (similar to side)
        // left/right options are for x axes, and top/bottom options are for y axes
        ticklabelposition: {
          valType: "enumerated",
          values: [
            "outside",
            "inside",
            "outside top",
            "inside top",
            "outside left",
            "inside left",
            "outside right",
            "inside right",
            "outside bottom",
            "inside bottom"
          ],
          dflt: "outside",
          editType: "calc"
        },
        ticklabeloverflow: {
          valType: "enumerated",
          values: [
            "allow",
            "hide past div",
            "hide past domain"
          ],
          editType: "calc"
        },
        ticklabelshift: {
          valType: "integer",
          dflt: 0,
          editType: "ticks"
        },
        ticklabelstandoff: {
          valType: "integer",
          dflt: 0,
          editType: "ticks"
        },
        ticklabelindex: {
          // in the future maybe add `extras: ['all', 'minor']` to allow showing labels for all ticks
          // or for all minor ticks.
          valType: "integer",
          arrayOk: true,
          editType: "calc"
        },
        mirror: {
          valType: "enumerated",
          values: [true, "ticks", false, "all", "allticks"],
          dflt: false,
          editType: "ticks+layoutstyle"
        },
        ticklen: makeTicklen(),
        tickwidth: makeTickwidth(),
        tickcolor,
        showticklabels: {
          valType: "boolean",
          dflt: true,
          editType: "ticks"
        },
        labelalias: {
          valType: "any",
          dflt: false,
          editType: "ticks"
        },
        automargin: {
          valType: "flaglist",
          flags: ["height", "width", "left", "right", "top", "bottom"],
          extras: [true, false],
          dflt: false,
          editType: "ticks"
        },
        showspikes: {
          valType: "boolean",
          dflt: false,
          editType: "modebar"
        },
        spikecolor: {
          valType: "color",
          dflt: null,
          editType: "none"
        },
        spikethickness: {
          valType: "number",
          dflt: 3,
          editType: "none"
        },
        spikedash: extendFlat({}, dash, { dflt: "dash", editType: "none" }),
        spikemode: {
          valType: "flaglist",
          flags: ["toaxis", "across", "marker"],
          dflt: "toaxis",
          editType: "none"
        },
        spikesnap: {
          valType: "enumerated",
          values: ["data", "cursor", "hovered data"],
          dflt: "hovered data",
          editType: "none"
        },
        tickfont: fontAttrs({
          editType: "ticks"
        }),
        tickangle: {
          valType: "angle",
          dflt: "auto",
          editType: "ticks"
        },
        autotickangles: {
          valType: "info_array",
          freeLength: true,
          items: {
            valType: "angle"
          },
          dflt: [0, 30, 90],
          editType: "ticks"
        },
        tickprefix: {
          valType: "string",
          dflt: "",
          editType: "ticks"
        },
        showtickprefix: {
          valType: "enumerated",
          values: ["all", "first", "last", "none"],
          dflt: "all",
          editType: "ticks"
        },
        ticksuffix: {
          valType: "string",
          dflt: "",
          editType: "ticks"
        },
        showticksuffix: {
          valType: "enumerated",
          values: ["all", "first", "last", "none"],
          dflt: "all",
          editType: "ticks"
        },
        showexponent: {
          valType: "enumerated",
          values: ["all", "first", "last", "none"],
          dflt: "all",
          editType: "ticks"
        },
        exponentformat: {
          valType: "enumerated",
          values: ["none", "e", "E", "power", "SI", "B"],
          dflt: "B",
          editType: "ticks"
        },
        minexponent: {
          valType: "number",
          dflt: 3,
          min: 0,
          editType: "ticks"
        },
        separatethousands: {
          valType: "boolean",
          dflt: false,
          editType: "ticks"
        },
        tickformat: {
          valType: "string",
          dflt: "",
          editType: "ticks",
          description: descriptionWithDates("tick label")
        },
        tickformatstops: templatedArray("tickformatstop", {
          enabled: {
            valType: "boolean",
            dflt: true,
            editType: "ticks"
          },
          dtickrange: {
            valType: "info_array",
            items: [
              { valType: "any", editType: "ticks" },
              { valType: "any", editType: "ticks" }
            ],
            editType: "ticks"
          },
          value: {
            valType: "string",
            dflt: "",
            editType: "ticks"
          },
          editType: "ticks"
        }),
        hoverformat: {
          valType: "string",
          dflt: "",
          editType: "none",
          description: descriptionWithDates("hover text")
        },
        // lines and grids
        showline: {
          valType: "boolean",
          dflt: false,
          editType: "ticks+layoutstyle"
        },
        linecolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "layoutstyle"
        },
        linewidth: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "ticks+layoutstyle"
        },
        showgrid,
        gridcolor,
        gridwidth: makeGridwidth(),
        griddash,
        zeroline: {
          valType: "boolean",
          editType: "ticks"
        },
        zerolinecolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "ticks"
        },
        zerolinewidth: {
          valType: "number",
          dflt: 1,
          editType: "ticks"
        },
        showdividers: {
          valType: "boolean",
          dflt: true,
          editType: "ticks"
        },
        dividercolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "ticks"
        },
        dividerwidth: {
          valType: "number",
          dflt: 1,
          editType: "ticks"
        },
        // TODO dividerlen: that would override "to label base" length?
        // positioning attributes
        // anchor: not used directly, just put here for reference
        // values are any opposite-letter axis id
        anchor: {
          valType: "enumerated",
          values: [
            "free",
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString()
          ],
          editType: "plot"
        },
        // side: not used directly, as values depend on direction
        // values are top, bottom for x axes, and left, right for y
        side: {
          valType: "enumerated",
          values: ["top", "bottom", "left", "right"],
          editType: "plot"
        },
        // overlaying: not used directly, just put here for reference
        // values are false and any other same-letter axis id that's not
        // itself overlaying anything
        overlaying: {
          valType: "enumerated",
          values: [
            "free",
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString()
          ],
          editType: "plot"
        },
        minor: {
          tickmode: minorTickmode,
          nticks: makeNticks("minor"),
          tick0,
          dtick,
          tickvals,
          ticks,
          ticklen: makeTicklen("minor"),
          tickwidth: makeTickwidth("minor"),
          tickcolor,
          gridcolor,
          gridwidth: makeGridwidth("minor"),
          griddash,
          showgrid,
          editType: "ticks"
        },
        layer: {
          valType: "enumerated",
          values: ["above traces", "below traces"],
          dflt: "above traces",
          editType: "plot"
        },
        domain: {
          valType: "info_array",
          items: [
            { valType: "number", min: 0, max: 1, editType: "plot" },
            { valType: "number", min: 0, max: 1, editType: "plot" }
          ],
          dflt: [0, 1],
          editType: "plot"
        },
        position: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0,
          editType: "plot"
        },
        autoshift: {
          valType: "boolean",
          dflt: false,
          editType: "plot"
        },
        shift: {
          valType: "number",
          editType: "plot"
        },
        categoryorder: {
          valType: "enumerated",
          values: [
            "trace",
            "category ascending",
            "category descending",
            "array",
            "total ascending",
            "total descending",
            "min ascending",
            "min descending",
            "max ascending",
            "max descending",
            "sum ascending",
            "sum descending",
            "mean ascending",
            "mean descending",
            "geometric mean ascending",
            "geometric mean descending",
            "median ascending",
            "median descending"
          ],
          dflt: "trace",
          editType: "calc"
        },
        categoryarray: {
          valType: "data_array",
          editType: "calc"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        editType: "calc"
      };
    }
  });

  // src/components/colorbar/attributes.js
  var require_attributes7 = __commonJS({
    "src/components/colorbar/attributes.js"(exports, module) {
      "use strict";
      var axesAttrs = require_layout_attributes4();
      var fontAttrs = require_font_attributes();
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      module.exports = overrideAll({
        orientation: {
          valType: "enumerated",
          values: ["h", "v"],
          dflt: "v"
        },
        thicknessmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "pixels"
        },
        thickness: {
          valType: "number",
          min: 0,
          dflt: 30
        },
        lenmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "fraction"
        },
        len: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        x: {
          valType: "number"
        },
        xref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        xanchor: {
          valType: "enumerated",
          values: ["left", "center", "right"]
        },
        xpad: {
          valType: "number",
          min: 0,
          dflt: 10
        },
        y: {
          valType: "number"
        },
        yref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        yanchor: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"]
        },
        ypad: {
          valType: "number",
          min: 0,
          dflt: 10
        },
        // a possible line around the bar itself
        outlinecolor: axesAttrs.linecolor,
        outlinewidth: axesAttrs.linewidth,
        // Should outlinewidth have {dflt: 0} ?
        // another possible line outside the padding and tick labels
        bordercolor: axesAttrs.linecolor,
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 0
        },
        bgcolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)"
        },
        // tick and title properties named and function exactly as in axes
        tickmode: axesAttrs.minor.tickmode,
        nticks: axesAttrs.nticks,
        tick0: axesAttrs.tick0,
        dtick: axesAttrs.dtick,
        tickvals: axesAttrs.tickvals,
        ticktext: axesAttrs.ticktext,
        ticks: extendFlat({}, axesAttrs.ticks, { dflt: "" }),
        ticklabeloverflow: extendFlat({}, axesAttrs.ticklabeloverflow, {}),
        // ticklabelposition: not used directly, as values depend on orientation
        // left/right options are for x axes, and top/bottom options are for y axes
        ticklabelposition: {
          valType: "enumerated",
          values: [
            "outside",
            "inside",
            "outside top",
            "inside top",
            "outside left",
            "inside left",
            "outside right",
            "inside right",
            "outside bottom",
            "inside bottom"
          ],
          dflt: "outside"
        },
        ticklen: axesAttrs.ticklen,
        tickwidth: axesAttrs.tickwidth,
        tickcolor: axesAttrs.tickcolor,
        ticklabelstep: axesAttrs.ticklabelstep,
        showticklabels: axesAttrs.showticklabels,
        labelalias: axesAttrs.labelalias,
        tickfont: fontAttrs({}),
        tickangle: axesAttrs.tickangle,
        tickformat: axesAttrs.tickformat,
        tickformatstops: axesAttrs.tickformatstops,
        tickprefix: axesAttrs.tickprefix,
        showtickprefix: axesAttrs.showtickprefix,
        ticksuffix: axesAttrs.ticksuffix,
        showticksuffix: axesAttrs.showticksuffix,
        separatethousands: axesAttrs.separatethousands,
        exponentformat: axesAttrs.exponentformat,
        minexponent: axesAttrs.minexponent,
        showexponent: axesAttrs.showexponent,
        title: {
          text: {
            valType: "string"
          },
          font: fontAttrs({}),
          side: {
            valType: "enumerated",
            values: ["right", "top", "bottom"]
          }
        }
      }, "colorbars", "from-root");
    }
  });

  // src/components/colorscale/attributes.js
  var require_attributes8 = __commonJS({
    "src/components/colorscale/attributes.js"(exports, module) {
      "use strict";
      var colorbarAttrs = require_attributes7();
      var counterRegex = require_regex().counter;
      var sortObjectKeys = require_sort_object_keys();
      var palettes = require_scales().scales;
      var paletteStr = sortObjectKeys(palettes);
      function code(s) {
        return "`" + s + "`";
      }
      module.exports = function colorScaleAttrs(context, opts) {
        context = context || "";
        opts = opts || {};
        var cLetter = opts.cLetter || "c";
        var onlyIfNumerical = "onlyIfNumerical" in opts ? opts.onlyIfNumerical : Boolean(context);
        var noScale = "noScale" in opts ? opts.noScale : context === "marker.line";
        var showScaleDflt = "showScaleDflt" in opts ? opts.showScaleDflt : cLetter === "z";
        var colorscaleDflt = typeof opts.colorscaleDflt === "string" ? palettes[opts.colorscaleDflt] : null;
        var editTypeOverride = opts.editTypeOverride || "";
        var contextHead = context ? context + "." : "";
        var colorAttr, colorAttrFull;
        if ("colorAttr" in opts) {
          colorAttr = opts.colorAttr;
          colorAttrFull = opts.colorAttr;
        } else {
          colorAttr = { z: "z", c: "color" }[cLetter];
          colorAttrFull = "in " + code(contextHead + colorAttr);
        }
        var effectDesc = onlyIfNumerical ? " Has an effect only if " + colorAttrFull + " is set to a numerical array." : "";
        var auto = cLetter + "auto";
        var min = cLetter + "min";
        var max = cLetter + "max";
        var mid = cLetter + "mid";
        var autoFull = code(contextHead + auto);
        var minFull = code(contextHead + min);
        var maxFull = code(contextHead + max);
        var minmaxFull = minFull + " and " + maxFull;
        var autoImpliedEdits = {};
        autoImpliedEdits[min] = autoImpliedEdits[max] = void 0;
        var minmaxImpliedEdits = {};
        minmaxImpliedEdits[auto] = false;
        var attrs = {};
        if (colorAttr === "color") {
          attrs.color = {
            valType: "color",
            arrayOk: true,
            editType: editTypeOverride || "style"
          };
          if (opts.anim) {
            attrs.color.anim = true;
          }
        }
        attrs[auto] = {
          valType: "boolean",
          dflt: true,
          editType: "calc",
          impliedEdits: autoImpliedEdits
        };
        attrs[min] = {
          valType: "number",
          dflt: null,
          editType: editTypeOverride || "plot",
          impliedEdits: minmaxImpliedEdits
        };
        attrs[max] = {
          valType: "number",
          dflt: null,
          editType: editTypeOverride || "plot",
          impliedEdits: minmaxImpliedEdits
        };
        attrs[mid] = {
          valType: "number",
          dflt: null,
          editType: "calc",
          impliedEdits: autoImpliedEdits
        };
        attrs.colorscale = {
          valType: "colorscale",
          editType: "calc",
          dflt: colorscaleDflt,
          impliedEdits: { autocolorscale: false }
        };
        attrs.autocolorscale = {
          valType: "boolean",
          // gets overrode in 'heatmap' & 'surface' for backwards comp.
          dflt: opts.autoColorDflt === false ? false : true,
          editType: "calc",
          impliedEdits: { colorscale: void 0 }
        };
        attrs.reversescale = {
          valType: "boolean",
          dflt: false,
          editType: "plot"
        };
        if (!noScale) {
          attrs.showscale = {
            valType: "boolean",
            dflt: showScaleDflt,
            editType: "calc"
          };
          attrs.colorbar = colorbarAttrs;
        }
        if (!opts.noColorAxis) {
          attrs.coloraxis = {
            valType: "subplotid",
            regex: counterRegex("coloraxis"),
            dflt: null,
            editType: "calc"
          };
        }
        return attrs;
      };
    }
  });

  // src/components/colorscale/layout_attributes.js
  var require_layout_attributes5 = __commonJS({
    "src/components/colorscale/layout_attributes.js"(exports, module) {
      "use strict";
      var extendFlat = require_extend().extendFlat;
      var colorScaleAttrs = require_attributes8();
      var scales = require_scales().scales;
      module.exports = {
        editType: "calc",
        colorscale: {
          editType: "calc",
          sequential: {
            valType: "colorscale",
            dflt: scales.Reds,
            editType: "calc"
          },
          sequentialminus: {
            valType: "colorscale",
            dflt: scales.Blues,
            editType: "calc"
          },
          diverging: {
            valType: "colorscale",
            dflt: scales.RdBu,
            editType: "calc"
          }
        },
        coloraxis: extendFlat({
          // not really a 'subplot' attribute container,
          // but this is the flag we use to denote attributes that
          // support yaxis, yaxis2, yaxis3, ... counters
          _isSubplotObj: true,
          editType: "calc"
        }, colorScaleAttrs("", {
          colorAttr: "corresponding trace color array(s)",
          noColorAxis: true,
          showScaleDflt: true
        }))
      };
    }
  });

  // src/components/colorbar/has_colorbar.js
  var require_has_colorbar = __commonJS({
    "src/components/colorbar/has_colorbar.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function hasColorbar(container) {
        return Lib.isPlainObject(container.colorbar);
      };
    }
  });

  // src/plots/cartesian/clean_ticks.js
  var require_clean_ticks = __commonJS({
    "src/plots/cartesian/clean_ticks.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var constants = require_numerical();
      var ONEDAY = constants.ONEDAY;
      var ONEWEEK = constants.ONEWEEK;
      exports.dtick = function(dtick, axType) {
        var isLog = axType === "log";
        var isDate = axType === "date";
        var isCat = axType === "category";
        var dtickDflt = isDate ? ONEDAY : 1;
        if (!dtick) return dtickDflt;
        if (isNumeric(dtick)) {
          dtick = Number(dtick);
          if (dtick <= 0) return dtickDflt;
          if (isCat) {
            return Math.max(1, Math.round(dtick));
          }
          if (isDate) {
            return Math.max(0.1, dtick);
          }
          return dtick;
        }
        if (typeof dtick !== "string" || !(isDate || isLog)) {
          return dtickDflt;
        }
        var prefix = dtick.charAt(0);
        var dtickNum = dtick.substr(1);
        dtickNum = isNumeric(dtickNum) ? Number(dtickNum) : 0;
        if (dtickNum <= 0 || !// "M<n>" gives ticks every (integer) n months
        (isDate && prefix === "M" && dtickNum === Math.round(dtickNum) || // "L<f>" gives ticks linearly spaced in data (not in position) every (float) f
        isLog && prefix === "L" || // "D1" gives powers of 10 with all small digits between, "D2" gives only 2 and 5
        isLog && prefix === "D" && (dtickNum === 1 || dtickNum === 2))) {
          return dtickDflt;
        }
        return dtick;
      };
      exports.tick0 = function(tick0, axType, calendar, dtick) {
        if (axType === "date") {
          return Lib.cleanDate(
            tick0,
            Lib.dateTick0(calendar, dtick % ONEWEEK === 0 ? 1 : 0)
          );
        }
        if (dtick === "D1" || dtick === "D2") {
          return void 0;
        }
        return isNumeric(tick0) ? Number(tick0) : 0;
      };
    }
  });

  // src/plots/cartesian/tick_value_defaults.js
  var require_tick_value_defaults = __commonJS({
    "src/plots/cartesian/tick_value_defaults.js"(exports, module) {
      "use strict";
      var cleanTicks = require_clean_ticks();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var isTypedArraySpec = require_array().isTypedArraySpec;
      var decodeTypedArraySpec = require_array().decodeTypedArraySpec;
      module.exports = function handleTickValueDefaults(containerIn, containerOut, coerce, axType, opts) {
        if (!opts) opts = {};
        var isMinor = opts.isMinor;
        var cIn = isMinor ? containerIn.minor || {} : containerIn;
        var cOut = isMinor ? containerOut.minor : containerOut;
        var prefix = isMinor ? "minor." : "";
        function readInput(attr) {
          var v = cIn[attr];
          if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
          return v !== void 0 ? v : (cOut._template || {})[attr];
        }
        var _tick0 = readInput("tick0");
        var _dtick = readInput("dtick");
        var _tickvals = readInput("tickvals");
        var tickmodeDefault = isArrayOrTypedArray(_tickvals) ? "array" : _dtick ? "linear" : "auto";
        var tickmode = coerce(prefix + "tickmode", tickmodeDefault);
        if (tickmode === "auto" || tickmode === "sync") {
          coerce(prefix + "nticks");
        } else if (tickmode === "linear") {
          var dtick = cOut.dtick = cleanTicks.dtick(
            _dtick,
            axType
          );
          cOut.tick0 = cleanTicks.tick0(
            _tick0,
            axType,
            containerOut.calendar,
            dtick
          );
        } else if (axType !== "multicategory") {
          var tickvals = coerce(prefix + "tickvals");
          if (tickvals === void 0) cOut.tickmode = "auto";
          else if (!isMinor) coerce("ticktext");
        }
      };
    }
  });

  // src/plots/cartesian/tick_mark_defaults.js
  var require_tick_mark_defaults = __commonJS({
    "src/plots/cartesian/tick_mark_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes4();
      module.exports = function handleTickMarkDefaults(containerIn, containerOut, coerce, options) {
        var isMinor = options.isMinor;
        var cIn = isMinor ? containerIn.minor || {} : containerIn;
        var cOut = isMinor ? containerOut.minor : containerOut;
        var lAttr = isMinor ? layoutAttributes.minor : layoutAttributes;
        var prefix = isMinor ? "minor." : "";
        var tickLen = Lib.coerce2(cIn, cOut, lAttr, "ticklen", isMinor ? (containerOut.ticklen || 5) * 0.6 : void 0);
        var tickWidth = Lib.coerce2(cIn, cOut, lAttr, "tickwidth", isMinor ? containerOut.tickwidth || 1 : void 0);
        var tickColor = Lib.coerce2(cIn, cOut, lAttr, "tickcolor", (isMinor ? containerOut.tickcolor : void 0) || cOut.color);
        var showTicks = coerce(prefix + "ticks", !isMinor && options.outerTicks || tickLen || tickWidth || tickColor ? "outside" : "");
        if (!showTicks) {
          delete cOut.ticklen;
          delete cOut.tickwidth;
          delete cOut.tickcolor;
        }
      };
    }
  });

  // src/plots/cartesian/show_dflt.js
  var require_show_dflt = __commonJS({
    "src/plots/cartesian/show_dflt.js"(exports, module) {
      "use strict";
      module.exports = function getShowAttrDflt(containerIn) {
        var showAttrsAll = ["showexponent", "showtickprefix", "showticksuffix"];
        var showAttrs = showAttrsAll.filter(function(a) {
          return containerIn[a] !== void 0;
        });
        var sameVal = function(a) {
          return containerIn[a] === containerIn[showAttrs[0]];
        };
        if (showAttrs.every(sameVal) || showAttrs.length === 1) {
          return containerIn[showAttrs[0]];
        }
      };
    }
  });

  // src/plots/array_container_defaults.js
  var require_array_container_defaults = __commonJS({
    "src/plots/array_container_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      module.exports = function handleArrayContainerDefaults(parentObjIn, parentObjOut, opts) {
        var name = opts.name;
        var inclusionAttr = opts.inclusionAttr || "visible";
        var previousContOut = parentObjOut[name];
        var contIn = Lib.isArrayOrTypedArray(parentObjIn[name]) ? parentObjIn[name] : [];
        var contOut = parentObjOut[name] = [];
        var templater = Template.arrayTemplater(parentObjOut, name, inclusionAttr);
        var i, itemOut;
        for (i = 0; i < contIn.length; i++) {
          var itemIn = contIn[i];
          if (!Lib.isPlainObject(itemIn)) {
            itemOut = templater.newItem({});
            itemOut[inclusionAttr] = false;
          } else {
            itemOut = templater.newItem(itemIn);
          }
          itemOut._index = i;
          if (itemOut[inclusionAttr] !== false) {
            opts.handleItemDefaults(itemIn, itemOut, parentObjOut, opts);
          }
          contOut.push(itemOut);
        }
        var defaultItems = templater.defaultItems();
        for (i = 0; i < defaultItems.length; i++) {
          itemOut = defaultItems[i];
          itemOut._index = contOut.length;
          opts.handleItemDefaults({}, itemOut, parentObjOut, opts, {});
          contOut.push(itemOut);
        }
        if (Lib.isArrayOrTypedArray(previousContOut)) {
          var len = Math.min(previousContOut.length, contOut.length);
          for (i = 0; i < len; i++) {
            Lib.relinkPrivateKeys(contOut[i], previousContOut[i]);
          }
        }
        return contOut;
      };
    }
  });

  // src/plots/cartesian/tick_label_defaults.js
  var require_tick_label_defaults = __commonJS({
    "src/plots/cartesian/tick_label_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var contrast = require_color().contrast;
      var layoutAttributes = require_layout_attributes4();
      var getShowAttrDflt = require_show_dflt();
      var handleArrayContainerDefaults = require_array_container_defaults();
      module.exports = function handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options) {
        if (!options) options = {};
        var labelalias = coerce("labelalias");
        if (!Lib.isPlainObject(labelalias)) delete containerOut.labelalias;
        var showAttrDflt = getShowAttrDflt(containerIn);
        var showTickLabels = coerce("showticklabels");
        if (showTickLabels) {
          if (!options.noTicklabelshift) {
            coerce("ticklabelshift");
          }
          if (!options.noTicklabelstandoff) {
            coerce("ticklabelstandoff");
          }
          var font = options.font || {};
          var contColor = containerOut.color;
          var position = containerOut.ticklabelposition || "";
          var dfltFontColor = position.indexOf("inside") !== -1 ? contrast(options.bgColor) : (
            // as with title.font.color, inherit axis.color only if one was
            // explicitly provided
            contColor && contColor !== layoutAttributes.color.dflt ? contColor : font.color
          );
          Lib.coerceFont(coerce, "tickfont", font, { overrideDflt: {
            color: dfltFontColor
          } });
          if (!options.noTicklabelstep && axType !== "multicategory" && axType !== "log") {
            coerce("ticklabelstep");
          }
          if (!options.noAng) {
            var tickAngle = coerce("tickangle");
            if (!options.noAutotickangles && tickAngle === "auto") {
              coerce("autotickangles");
            }
          }
          if (axType !== "category") {
            var tickFormat = coerce("tickformat");
            handleArrayContainerDefaults(containerIn, containerOut, {
              name: "tickformatstops",
              inclusionAttr: "enabled",
              handleItemDefaults: tickformatstopDefaults
            });
            if (!containerOut.tickformatstops.length) {
              delete containerOut.tickformatstops;
            }
            if (!options.noExp && !tickFormat && axType !== "date") {
              coerce("showexponent", showAttrDflt);
              coerce("exponentformat");
              coerce("minexponent");
              coerce("separatethousands");
            }
          }
        }
      };
      function tickformatstopDefaults(valueIn, valueOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(valueIn, valueOut, layoutAttributes.tickformatstops, attr, dflt);
        }
        var enabled = coerce("enabled");
        if (enabled) {
          coerce("dtickrange");
          coerce("value");
        }
      }
    }
  });

  // src/plots/cartesian/prefix_suffix_defaults.js
  var require_prefix_suffix_defaults = __commonJS({
    "src/plots/cartesian/prefix_suffix_defaults.js"(exports, module) {
      "use strict";
      var getShowAttrDflt = require_show_dflt();
      module.exports = function handlePrefixSuffixDefaults(containerIn, containerOut, coerce, axType, options) {
        if (!options) options = {};
        var tickSuffixDflt = options.tickSuffixDflt;
        var showAttrDflt = getShowAttrDflt(containerIn);
        var tickPrefix = coerce("tickprefix");
        if (tickPrefix) coerce("showtickprefix", showAttrDflt);
        var tickSuffix = coerce("ticksuffix", tickSuffixDflt);
        if (tickSuffix) coerce("showticksuffix", showAttrDflt);
      };
    }
  });

  // src/components/colorbar/defaults.js
  var require_defaults = __commonJS({
    "src/components/colorbar/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var handleTickValueDefaults = require_tick_value_defaults();
      var handleTickMarkDefaults = require_tick_mark_defaults();
      var handleTickLabelDefaults = require_tick_label_defaults();
      var handlePrefixSuffixDefaults = require_prefix_suffix_defaults();
      var attributes = require_attributes7();
      module.exports = function colorbarDefaults(containerIn, containerOut, layout) {
        var colorbarOut = Template.newContainer(containerOut, "colorbar");
        var colorbarIn = containerIn.colorbar || {};
        function coerce(attr, dflt) {
          return Lib.coerce(colorbarIn, colorbarOut, attributes, attr, dflt);
        }
        var margin = layout.margin || { t: 0, b: 0, l: 0, r: 0 };
        var w = layout.width - margin.l - margin.r;
        var h = layout.height - margin.t - margin.b;
        var orientation = coerce("orientation");
        var isVertical = orientation === "v";
        var thicknessmode = coerce("thicknessmode");
        coerce(
          "thickness",
          thicknessmode === "fraction" ? 30 / (isVertical ? w : h) : 30
        );
        var lenmode = coerce("lenmode");
        coerce(
          "len",
          lenmode === "fraction" ? 1 : isVertical ? h : w
        );
        var yref = coerce("yref");
        var xref = coerce("xref");
        var isPaperY = yref === "paper";
        var isPaperX = xref === "paper";
        var defaultX, defaultY, defaultYAnchor;
        var defaultXAnchor = "left";
        if (isVertical) {
          defaultYAnchor = "middle";
          defaultXAnchor = isPaperX ? "left" : "right";
          defaultX = isPaperX ? 1.02 : 1;
          defaultY = 0.5;
        } else {
          defaultYAnchor = isPaperY ? "bottom" : "top";
          defaultXAnchor = "center";
          defaultX = 0.5;
          defaultY = isPaperY ? 1.02 : 1;
        }
        Lib.coerce(colorbarIn, colorbarOut, {
          x: {
            valType: "number",
            min: isPaperX ? -2 : 0,
            max: isPaperX ? 3 : 1,
            dflt: defaultX
          }
        }, "x");
        Lib.coerce(colorbarIn, colorbarOut, {
          y: {
            valType: "number",
            min: isPaperY ? -2 : 0,
            max: isPaperY ? 3 : 1,
            dflt: defaultY
          }
        }, "y");
        coerce("xanchor", defaultXAnchor);
        coerce("xpad");
        coerce("yanchor", defaultYAnchor);
        coerce("ypad");
        Lib.noneOrAll(colorbarIn, colorbarOut, ["x", "y"]);
        coerce("outlinecolor");
        coerce("outlinewidth");
        coerce("bordercolor");
        coerce("borderwidth");
        coerce("bgcolor");
        var ticklabelposition = Lib.coerce(colorbarIn, colorbarOut, {
          ticklabelposition: {
            valType: "enumerated",
            dflt: "outside",
            values: isVertical ? [
              "outside",
              "inside",
              "outside top",
              "inside top",
              "outside bottom",
              "inside bottom"
            ] : [
              "outside",
              "inside",
              "outside left",
              "inside left",
              "outside right",
              "inside right"
            ]
          }
        }, "ticklabelposition");
        coerce("ticklabeloverflow", ticklabelposition.indexOf("inside") !== -1 ? "hide past domain" : "hide past div");
        handleTickValueDefaults(colorbarIn, colorbarOut, coerce, "linear");
        var font = layout.font;
        var opts = {
          noAutotickangles: true,
          noTicklabelshift: true,
          noTicklabelstandoff: true,
          outerTicks: false,
          font
        };
        if (ticklabelposition.indexOf("inside") !== -1) {
          opts.bgColor = "black";
        }
        handlePrefixSuffixDefaults(colorbarIn, colorbarOut, coerce, "linear", opts);
        handleTickLabelDefaults(colorbarIn, colorbarOut, coerce, "linear", opts);
        handleTickMarkDefaults(colorbarIn, colorbarOut, coerce, "linear", opts);
        coerce("title.text", layout._dfltTitle.colorbar);
        var tickFont = colorbarOut.showticklabels ? colorbarOut.tickfont : font;
        var dfltTitleFont = Lib.extendFlat({}, font, {
          family: tickFont.family,
          size: Lib.bigFont(tickFont.size)
        });
        Lib.coerceFont(coerce, "title.font", dfltTitleFont);
        coerce("title.side", isVertical ? "top" : "right");
      };
    }
  });

  // src/components/colorscale/defaults.js
  var require_defaults2 = __commonJS({
    "src/components/colorscale/defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var hasColorbar = require_has_colorbar();
      var colorbarDefaults = require_defaults();
      var isValidScale = require_scales().isValid;
      var traceIs = require_registry().traceIs;
      function npMaybe(parentCont, prefix) {
        var containerStr = prefix.slice(0, prefix.length - 1);
        return prefix ? Lib.nestedProperty(parentCont, containerStr).get() || {} : parentCont;
      }
      module.exports = function colorScaleDefaults(parentContIn, parentContOut, layout, coerce, opts) {
        var prefix = opts.prefix;
        var cLetter = opts.cLetter;
        var inTrace = "_module" in parentContOut;
        var containerIn = npMaybe(parentContIn, prefix);
        var containerOut = npMaybe(parentContOut, prefix);
        var template = npMaybe(parentContOut._template || {}, prefix) || {};
        var thisFn = function() {
          delete parentContIn.coloraxis;
          delete parentContOut.coloraxis;
          return colorScaleDefaults(parentContIn, parentContOut, layout, coerce, opts);
        };
        if (inTrace) {
          var colorAxes = layout._colorAxes || {};
          var colorAx = coerce(prefix + "coloraxis");
          if (colorAx) {
            var colorbarVisuals = traceIs(parentContOut, "contour") && Lib.nestedProperty(parentContOut, "contours.coloring").get() || "heatmap";
            var stash = colorAxes[colorAx];
            if (stash) {
              stash[2].push(thisFn);
              if (stash[0] !== colorbarVisuals) {
                stash[0] = false;
                Lib.warn([
                  "Ignoring coloraxis:",
                  colorAx,
                  "setting",
                  "as it is linked to incompatible colorscales."
                ].join(" "));
              }
            } else {
              colorAxes[colorAx] = [colorbarVisuals, parentContOut, [thisFn]];
            }
            return;
          }
        }
        var minIn = containerIn[cLetter + "min"];
        var maxIn = containerIn[cLetter + "max"];
        var validMinMax = isNumeric(minIn) && isNumeric(maxIn) && minIn < maxIn;
        var auto = coerce(prefix + cLetter + "auto", !validMinMax);
        if (auto) {
          coerce(prefix + cLetter + "mid");
        } else {
          coerce(prefix + cLetter + "min");
          coerce(prefix + cLetter + "max");
        }
        var sclIn = containerIn.colorscale;
        var sclTemplate = template.colorscale;
        var autoColorscaleDflt;
        if (sclIn !== void 0) autoColorscaleDflt = !isValidScale(sclIn);
        if (sclTemplate !== void 0) autoColorscaleDflt = !isValidScale(sclTemplate);
        coerce(prefix + "autocolorscale", autoColorscaleDflt);
        coerce(prefix + "colorscale");
        coerce(prefix + "reversescale");
        if (prefix !== "marker.line.") {
          var showScaleDflt;
          if (prefix && inTrace) showScaleDflt = hasColorbar(containerIn);
          var showScale = coerce(prefix + "showscale", showScaleDflt);
          if (showScale) {
            if (prefix && template) containerOut._template = template;
            colorbarDefaults(containerIn, containerOut, layout);
          }
        }
      };
    }
  });

  // src/components/colorscale/layout_defaults.js
  var require_layout_defaults = __commonJS({
    "src/components/colorscale/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var colorScaleAttrs = require_layout_attributes5();
      var colorScaleDefaults = require_defaults2();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, colorScaleAttrs, attr, dflt);
        }
        coerce("colorscale.sequential");
        coerce("colorscale.sequentialminus");
        coerce("colorscale.diverging");
        var colorAxes = layoutOut._colorAxes;
        var colorAxIn, colorAxOut;
        function coerceAx(attr, dflt) {
          return Lib.coerce(colorAxIn, colorAxOut, colorScaleAttrs.coloraxis, attr, dflt);
        }
        for (var k in colorAxes) {
          var stash = colorAxes[k];
          if (stash[0]) {
            colorAxIn = layoutIn[k] || {};
            colorAxOut = Template.newContainer(layoutOut, k, "coloraxis");
            colorAxOut._name = k;
            colorScaleDefaults(colorAxIn, colorAxOut, layoutOut, coerceAx, { prefix: "", cLetter: "c" });
          } else {
            for (var i = 0; i < stash[2].length; i++) {
              stash[2][i]();
            }
            delete layoutOut._colorAxes[k];
          }
        }
      };
    }
  });

  // src/components/colorscale/cross_trace_defaults.js
  var require_cross_trace_defaults = __commonJS({
    "src/components/colorscale/cross_trace_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var hasColorscale = require_helpers().hasColorscale;
      var extractOpts = require_helpers().extractOpts;
      module.exports = function crossTraceDefaults(fullData, fullLayout) {
        function replace(cont, k2) {
          var val = cont["_" + k2];
          if (val !== void 0) {
            cont[k2] = val;
          }
        }
        function relinkColorAttrs(outerCont, cbOpt) {
          var cont = cbOpt.container ? Lib.nestedProperty(outerCont, cbOpt.container).get() : outerCont;
          if (cont) {
            if (cont.coloraxis) {
              cont._colorAx = fullLayout[cont.coloraxis];
            } else {
              var cOpts = extractOpts(cont);
              var isAuto = cOpts.auto;
              if (isAuto || cOpts.min === void 0) {
                replace(cont, cbOpt.min);
              }
              if (isAuto || cOpts.max === void 0) {
                replace(cont, cbOpt.max);
              }
              if (cOpts.autocolorscale) {
                replace(cont, "colorscale");
              }
            }
          }
        }
        for (var i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          var cbOpts = trace._module.colorbar;
          if (cbOpts) {
            if (Array.isArray(cbOpts)) {
              for (var j = 0; j < cbOpts.length; j++) {
                relinkColorAttrs(trace, cbOpts[j]);
              }
            } else {
              relinkColorAttrs(trace, cbOpts);
            }
          }
          if (hasColorscale(trace, "marker.line")) {
            relinkColorAttrs(trace, {
              container: "marker.line",
              min: "cmin",
              max: "cmax"
            });
          }
        }
        for (var k in fullLayout._colorAxes) {
          relinkColorAttrs(fullLayout[k], { min: "cmin", max: "cmax" });
        }
      };
    }
  });

  // src/components/colorscale/calc.js
  var require_calc = __commonJS({
    "src/components/colorscale/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var extractOpts = require_helpers().extractOpts;
      module.exports = function calc(gd, trace, opts) {
        var fullLayout = gd._fullLayout;
        var vals = opts.vals;
        var containerStr = opts.containerStr;
        var container = containerStr ? Lib.nestedProperty(trace, containerStr).get() : trace;
        var cOpts = extractOpts(container);
        var auto = cOpts.auto !== false;
        var min = cOpts.min;
        var max = cOpts.max;
        var mid = cOpts.mid;
        var minVal = function() {
          return Lib.aggNums(Math.min, null, vals);
        };
        var maxVal = function() {
          return Lib.aggNums(Math.max, null, vals);
        };
        if (min === void 0) {
          min = minVal();
        } else if (auto) {
          if (container._colorAx && isNumeric(min)) {
            min = Math.min(min, minVal());
          } else {
            min = minVal();
          }
        }
        if (max === void 0) {
          max = maxVal();
        } else if (auto) {
          if (container._colorAx && isNumeric(max)) {
            max = Math.max(max, maxVal());
          } else {
            max = maxVal();
          }
        }
        if (auto && mid !== void 0) {
          if (max - mid > mid - min) {
            min = mid - (max - mid);
          } else if (max - mid < mid - min) {
            max = mid + (mid - min);
          }
        }
        if (min === max) {
          min -= 0.5;
          max += 0.5;
        }
        cOpts._sync("min", min);
        cOpts._sync("max", max);
        if (cOpts.autocolorscale) {
          var scl;
          if (min * max < 0) scl = fullLayout.colorscale.diverging;
          else if (min >= 0) scl = fullLayout.colorscale.sequential;
          else scl = fullLayout.colorscale.sequentialminus;
          cOpts._sync("colorscale", scl);
        }
      };
    }
  });

  // src/components/colorscale/index.js
  var require_colorscale = __commonJS({
    "src/components/colorscale/index.js"(exports, module) {
      "use strict";
      var scales = require_scales();
      var helpers = require_helpers();
      module.exports = {
        moduleType: "component",
        name: "colorscale",
        attributes: require_attributes8(),
        layoutAttributes: require_layout_attributes5(),
        supplyLayoutDefaults: require_layout_defaults(),
        handleDefaults: require_defaults2(),
        crossTraceDefaults: require_cross_trace_defaults(),
        calc: require_calc(),
        // ./scales.js is required in lib/coerce.js ;
        // it needs to be a separate module to avoid a circular dependency
        scales: scales.scales,
        defaultScale: scales.defaultScale,
        getScale: scales.get,
        isValidScale: scales.isValid,
        hasColorscale: helpers.hasColorscale,
        extractOpts: helpers.extractOpts,
        extractScale: helpers.extractScale,
        flipScale: helpers.flipScale,
        makeColorScaleFunc: helpers.makeColorScaleFunc,
        makeColorScaleFuncFromTrace: helpers.makeColorScaleFuncFromTrace
      };
    }
  });

  // src/traces/scatter/subtypes.js
  var require_subtypes = __commonJS({
    "src/traces/scatter/subtypes.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var isTypedArraySpec = require_array().isTypedArraySpec;
      module.exports = {
        hasLines: function(trace) {
          return trace.visible && trace.mode && trace.mode.indexOf("lines") !== -1;
        },
        hasMarkers: function(trace) {
          return trace.visible && (trace.mode && trace.mode.indexOf("markers") !== -1 || // until splom implements 'mode'
          trace.type === "splom");
        },
        hasText: function(trace) {
          return trace.visible && trace.mode && trace.mode.indexOf("text") !== -1;
        },
        isBubble: function(trace) {
          var marker = trace.marker;
          return Lib.isPlainObject(marker) && (Lib.isArrayOrTypedArray(marker.size) || isTypedArraySpec(marker.size));
        }
      };
    }
  });

  // src/traces/scatter/make_bubble_size_func.js
  var require_make_bubble_size_func = __commonJS({
    "src/traces/scatter/make_bubble_size_func.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      module.exports = function makeBubbleSizeFn(trace, factor) {
        if (!factor) {
          factor = 2;
        }
        var marker = trace.marker;
        var sizeRef = marker.sizeref || 1;
        var sizeMin = marker.sizemin || 0;
        var baseFn = marker.sizemode === "area" ? function(v) {
          return Math.sqrt(v / sizeRef);
        } : function(v) {
          return v / sizeRef;
        };
        return function(v) {
          var baseSize = baseFn(v / factor);
          return isNumeric(baseSize) && baseSize > 0 ? Math.max(baseSize, sizeMin) : 0;
        };
      };
    }
  });

  // src/components/fx/helpers.js
  var require_helpers2 = __commonJS({
    "src/components/fx/helpers.js"(exports) {
      "use strict";
      var Lib = require_lib();
      exports.getSubplot = function(trace) {
        return trace.subplot || trace.xaxis + trace.yaxis || trace.geo;
      };
      exports.isTraceInSubplots = function(trace, subplots) {
        if (trace.type === "splom") {
          var xaxes = trace.xaxes || [];
          var yaxes = trace.yaxes || [];
          for (var i = 0; i < xaxes.length; i++) {
            for (var j = 0; j < yaxes.length; j++) {
              if (subplots.indexOf(xaxes[i] + yaxes[j]) !== -1) {
                return true;
              }
            }
          }
          return false;
        }
        return subplots.indexOf(exports.getSubplot(trace)) !== -1;
      };
      exports.flat = function(subplots, v) {
        var out = new Array(subplots.length);
        for (var i = 0; i < subplots.length; i++) {
          out[i] = v;
        }
        return out;
      };
      exports.p2c = function(axArray, v) {
        var out = new Array(axArray.length);
        for (var i = 0; i < axArray.length; i++) {
          out[i] = axArray[i].p2c(v);
        }
        return out;
      };
      exports.getDistanceFunction = function(mode, dx, dy, dxy) {
        if (mode === "closest") return dxy || exports.quadrature(dx, dy);
        return mode.charAt(0) === "x" ? dx : dy;
      };
      exports.getClosest = function(cd, distfn, pointData) {
        if (pointData.index !== false) {
          if (pointData.index >= 0 && pointData.index < cd.length) {
            pointData.distance = 0;
          } else pointData.index = false;
        } else {
          var newDistance = Infinity;
          var len = cd.length;
          for (var i = 0; i < len; i++) {
            newDistance = distfn(cd[i]);
            if (newDistance <= pointData.distance) {
              pointData.index = i;
              pointData.distance = newDistance;
            }
          }
        }
        return pointData;
      };
      exports.inbox = function(v0, v1, passVal) {
        return v0 * v1 < 0 || v0 === 0 ? passVal : Infinity;
      };
      exports.quadrature = function(dx, dy) {
        return function(di) {
          var x = dx(di);
          var y = dy(di);
          return Math.sqrt(x * x + y * y);
        };
      };
      exports.makeEventData = function(pt, trace, cd) {
        var pointNumber = "index" in pt ? pt.index : pt.pointNumber;
        var out = {
          data: trace._input,
          fullData: trace,
          curveNumber: trace.index,
          pointNumber
        };
        if (trace._indexToPoints) {
          var pointIndices = trace._indexToPoints[pointNumber];
          if (pointIndices.length === 1) {
            out.pointIndex = pointIndices[0];
          } else {
            out.pointIndices = pointIndices;
          }
        } else {
          out.pointIndex = pointNumber;
        }
        if (trace._module.eventData) {
          out = trace._module.eventData(out, pt, trace, cd, pointNumber);
        } else {
          if ("xVal" in pt) out.x = pt.xVal;
          else if ("x" in pt) out.x = pt.x;
          if ("yVal" in pt) out.y = pt.yVal;
          else if ("y" in pt) out.y = pt.y;
          if (pt.xa) out.xaxis = pt.xa;
          if (pt.ya) out.yaxis = pt.ya;
          if (pt.zLabelVal !== void 0) out.z = pt.zLabelVal;
        }
        exports.appendArrayPointValue(out, trace, pointNumber);
        return out;
      };
      exports.appendArrayPointValue = function(pointData, trace, pointNumber) {
        var arrayAttrs = trace._arrayAttrs;
        if (!arrayAttrs) {
          return;
        }
        for (var i = 0; i < arrayAttrs.length; i++) {
          var astr = arrayAttrs[i];
          var key = getPointKey(astr);
          if (pointData[key] === void 0) {
            var val = Lib.nestedProperty(trace, astr).get();
            var pointVal = getPointData(val, pointNumber);
            if (pointVal !== void 0) pointData[key] = pointVal;
          }
        }
      };
      exports.appendArrayMultiPointValues = function(pointData, trace, pointNumbers) {
        var arrayAttrs = trace._arrayAttrs;
        if (!arrayAttrs) {
          return;
        }
        for (var i = 0; i < arrayAttrs.length; i++) {
          var astr = arrayAttrs[i];
          var key = getPointKey(astr);
          if (pointData[key] === void 0) {
            var val = Lib.nestedProperty(trace, astr).get();
            var keyVal = new Array(pointNumbers.length);
            for (var j = 0; j < pointNumbers.length; j++) {
              keyVal[j] = getPointData(val, pointNumbers[j]);
            }
            pointData[key] = keyVal;
          }
        }
      };
      var pointKeyMap = {
        ids: "id",
        locations: "location",
        labels: "label",
        values: "value",
        "marker.colors": "color",
        parents: "parent"
      };
      function getPointKey(astr) {
        return pointKeyMap[astr] || astr;
      }
      function getPointData(val, pointNumber) {
        if (Array.isArray(pointNumber)) {
          if (Array.isArray(val) && Array.isArray(val[pointNumber[0]])) {
            return val[pointNumber[0]][pointNumber[1]];
          }
        } else {
          return val[pointNumber];
        }
      }
      var xyHoverMode = {
        x: true,
        y: true
      };
      var unifiedHoverMode = {
        "x unified": true,
        "y unified": true
      };
      exports.isUnifiedHover = function(hovermode) {
        if (typeof hovermode !== "string") return false;
        return !!unifiedHoverMode[hovermode];
      };
      exports.isXYhover = function(hovermode) {
        if (typeof hovermode !== "string") return false;
        return !!xyHoverMode[hovermode];
      };
    }
  });

  // node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS({
    "node_modules/parse-svg-path/index.js"(exports, module) {
      module.exports = parse;
      var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function parse(path) {
        var data = [];
        path.replace(segment, function(_, command, args) {
          var type = command.toLowerCase();
          args = parseValues(args);
          if (type == "m" && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = "l";
            command = command == "m" ? "l" : "L";
          }
          while (true) {
            if (args.length == length[type]) {
              args.unshift(command);
              return data.push(args);
            }
            if (args.length < length[type]) throw new Error("malformed path data");
            data.push([command].concat(args.splice(0, length[type])));
          }
        });
        return data;
      }
      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function parseValues(args) {
        var numbers = args.match(number);
        return numbers ? numbers.map(Number) : [];
      }
    }
  });

  // src/components/drawing/symbol_defs.js
  var require_symbol_defs = __commonJS({
    "src/components/drawing/symbol_defs.js"(exports, module) {
      "use strict";
      var parseSvgPath = require_parse_svg_path();
      var round = (
        // require('@plotly/d3').round;
        function(x, n) {
          return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
        }
      );
      var emptyPath = "M0,0Z";
      var sqrt2 = Math.sqrt(2);
      var sqrt3 = Math.sqrt(3);
      var PI = Math.PI;
      var cos = Math.cos;
      var sin = Math.sin;
      module.exports = {
        circle: {
          n: 0,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            var circle = "M" + rs + ",0A" + rs + "," + rs + " 0 1,1 0,-" + rs + "A" + rs + "," + rs + " 0 0,1 " + rs + ",0Z";
            return standoff ? align(angle, standoff, circle) : circle;
          }
        },
        square: {
          n: 1,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "H-" + rs + "V-" + rs + "H" + rs + "Z");
          }
        },
        diamond: {
          n: 2,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rd = round(r * 1.3, 2);
            return align(angle, standoff, "M" + rd + ",0L0," + rd + "L-" + rd + ",0L0,-" + rd + "Z");
          }
        },
        cross: {
          n: 3,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 0.4, 2);
            var rc2 = round(r * 1.2, 2);
            return align(angle, standoff, "M" + rc2 + "," + rc + "H" + rc + "V" + rc2 + "H-" + rc + "V" + rc + "H-" + rc2 + "V-" + rc + "H-" + rc + "V-" + rc2 + "H" + rc + "V-" + rc + "H" + rc2 + "Z");
          }
        },
        x: {
          n: 4,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 0.8 / sqrt2, 2);
            var ne = "l" + rx + "," + rx;
            var se = "l" + rx + ",-" + rx;
            var sw = "l-" + rx + ",-" + rx;
            var nw = "l-" + rx + "," + rx;
            return align(angle, standoff, "M0," + rx + ne + se + sw + se + sw + nw + sw + nw + ne + nw + ne + "Z");
          }
        },
        "triangle-up": {
          n: 5,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M-" + rt + "," + r2 + "H" + rt + "L0,-" + rs + "Z");
          }
        },
        "triangle-down": {
          n: 6,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M-" + rt + ",-" + r2 + "H" + rt + "L0," + rs + "Z");
          }
        },
        "triangle-left": {
          n: 7,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M" + r2 + ",-" + rt + "V" + rt + "L-" + rs + ",0Z");
          }
        },
        "triangle-right": {
          n: 8,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M-" + r2 + ",-" + rt + "V" + rt + "L" + rs + ",0Z");
          }
        },
        "triangle-ne": {
          n: 9,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M-" + r2 + ",-" + r1 + "H" + r1 + "V" + r2 + "Z");
          }
        },
        "triangle-se": {
          n: 10,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M" + r1 + ",-" + r2 + "V" + r1 + "H-" + r2 + "Z");
          }
        },
        "triangle-sw": {
          n: 11,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M" + r2 + "," + r1 + "H-" + r1 + "V-" + r2 + "Z");
          }
        },
        "triangle-nw": {
          n: 12,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M-" + r1 + "," + r2 + "V-" + r1 + "H" + r2 + "Z");
          }
        },
        pentagon: {
          n: 13,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x1 = round(r * 0.951, 2);
            var x2 = round(r * 0.588, 2);
            var y0 = round(-r, 2);
            var y1 = round(r * -0.309, 2);
            var y2 = round(r * 0.809, 2);
            return align(angle, standoff, "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + "H-" + x2 + "L-" + x1 + "," + y1 + "L0," + y0 + "Z");
          }
        },
        hexagon: {
          n: 14,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y0 = round(r, 2);
            var y1 = round(r / 2, 2);
            var x = round(r * sqrt3 / 2, 2);
            return align(angle, standoff, "M" + x + ",-" + y1 + "V" + y1 + "L0," + y0 + "L-" + x + "," + y1 + "V-" + y1 + "L0,-" + y0 + "Z");
          }
        },
        hexagon2: {
          n: 15,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x0 = round(r, 2);
            var x1 = round(r / 2, 2);
            var y = round(r * sqrt3 / 2, 2);
            return align(angle, standoff, "M-" + x1 + "," + y + "H" + x1 + "L" + x0 + ",0L" + x1 + ",-" + y + "H-" + x1 + "L-" + x0 + ",0Z");
          }
        },
        octagon: {
          n: 16,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var a = round(r * 0.924, 2);
            var b = round(r * 0.383, 2);
            return align(angle, standoff, "M-" + b + ",-" + a + "H" + b + "L" + a + ",-" + b + "V" + b + "L" + b + "," + a + "H-" + b + "L-" + a + "," + b + "V-" + b + "Z");
          }
        },
        star: {
          n: 17,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = r * 1.4;
            var x1 = round(rs * 0.225, 2);
            var x2 = round(rs * 0.951, 2);
            var x3 = round(rs * 0.363, 2);
            var x4 = round(rs * 0.588, 2);
            var y0 = round(-rs, 2);
            var y1 = round(rs * -0.309, 2);
            var y3 = round(rs * 0.118, 2);
            var y4 = round(rs * 0.809, 2);
            var y5 = round(rs * 0.382, 2);
            return align(angle, standoff, "M" + x1 + "," + y1 + "H" + x2 + "L" + x3 + "," + y3 + "L" + x4 + "," + y4 + "L0," + y5 + "L-" + x4 + "," + y4 + "L-" + x3 + "," + y3 + "L-" + x2 + "," + y1 + "H-" + x1 + "L0," + y0 + "Z");
          }
        },
        hexagram: {
          n: 18,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y = round(r * 0.66, 2);
            var x1 = round(r * 0.38, 2);
            var x2 = round(r * 0.76, 2);
            return align(angle, standoff, "M-" + x2 + ",0l-" + x1 + ",-" + y + "h" + x2 + "l" + x1 + ",-" + y + "l" + x1 + "," + y + "h" + x2 + "l-" + x1 + "," + y + "l" + x1 + "," + y + "h-" + x2 + "l-" + x1 + "," + y + "l-" + x1 + ",-" + y + "h-" + x2 + "Z");
          }
        },
        "star-triangle-up": {
          n: 19,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * sqrt3 * 0.8, 2);
            var y1 = round(r * 0.8, 2);
            var y2 = round(r * 1.6, 2);
            var rc = round(r * 4, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M-" + x + "," + y1 + aPart + x + "," + y1 + aPart + "0,-" + y2 + aPart + "-" + x + "," + y1 + "Z");
          }
        },
        "star-triangle-down": {
          n: 20,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * sqrt3 * 0.8, 2);
            var y1 = round(r * 0.8, 2);
            var y2 = round(r * 1.6, 2);
            var rc = round(r * 4, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M" + x + ",-" + y1 + aPart + "-" + x + ",-" + y1 + aPart + "0," + y2 + aPart + x + ",-" + y1 + "Z");
          }
        },
        "star-square": {
          n: 21,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rp = round(r * 1.1, 2);
            var rc = round(r * 2, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M-" + rp + ",-" + rp + aPart + "-" + rp + "," + rp + aPart + rp + "," + rp + aPart + rp + ",-" + rp + aPart + "-" + rp + ",-" + rp + "Z");
          }
        },
        "star-diamond": {
          n: 22,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rp = round(r * 1.4, 2);
            var rc = round(r * 1.9, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M-" + rp + ",0" + aPart + "0," + rp + aPart + rp + ",0" + aPart + "0,-" + rp + aPart + "-" + rp + ",0Z");
          }
        },
        "diamond-tall": {
          n: 23,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 0.7, 2);
            var y = round(r * 1.4, 2);
            return align(angle, standoff, "M0," + y + "L" + x + ",0L0,-" + y + "L-" + x + ",0Z");
          }
        },
        "diamond-wide": {
          n: 24,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 1.4, 2);
            var y = round(r * 0.7, 2);
            return align(angle, standoff, "M0," + y + "L" + x + ",0L0,-" + y + "L-" + x + ",0Z");
          }
        },
        hourglass: {
          n: 25,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "H-" + rs + "L" + rs + ",-" + rs + "H-" + rs + "Z");
          },
          noDot: true
        },
        bowtie: {
          n: 26,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "V-" + rs + "L-" + rs + "," + rs + "V-" + rs + "Z");
          },
          noDot: true
        },
        "circle-cross": {
          n: 27,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M0," + rs + "V-" + rs + "M" + rs + ",0H-" + rs + "M" + rs + ",0A" + rs + "," + rs + " 0 1,1 0,-" + rs + "A" + rs + "," + rs + " 0 0,1 " + rs + ",0Z");
          },
          needLine: true,
          noDot: true
        },
        "circle-x": {
          n: 28,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            var rc = round(r / sqrt2, 2);
            return align(angle, standoff, "M" + rc + "," + rc + "L-" + rc + ",-" + rc + "M" + rc + ",-" + rc + "L-" + rc + "," + rc + "M" + rs + ",0A" + rs + "," + rs + " 0 1,1 0,-" + rs + "A" + rs + "," + rs + " 0 0,1 " + rs + ",0Z");
          },
          needLine: true,
          noDot: true
        },
        "square-cross": {
          n: 29,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M0," + rs + "V-" + rs + "M" + rs + ",0H-" + rs + "M" + rs + "," + rs + "H-" + rs + "V-" + rs + "H" + rs + "Z");
          },
          needLine: true,
          noDot: true
        },
        "square-x": {
          n: 30,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "L-" + rs + ",-" + rs + "M" + rs + ",-" + rs + "L-" + rs + "," + rs + "M" + rs + "," + rs + "H-" + rs + "V-" + rs + "H" + rs + "Z");
          },
          needLine: true,
          noDot: true
        },
        "diamond-cross": {
          n: 31,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rd = round(r * 1.3, 2);
            return align(angle, standoff, "M" + rd + ",0L0," + rd + "L-" + rd + ",0L0,-" + rd + "ZM0,-" + rd + "V" + rd + "M-" + rd + ",0H" + rd);
          },
          needLine: true,
          noDot: true
        },
        "diamond-x": {
          n: 32,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rd = round(r * 1.3, 2);
            var r2 = round(r * 0.65, 2);
            return align(angle, standoff, "M" + rd + ",0L0," + rd + "L-" + rd + ",0L0,-" + rd + "ZM-" + r2 + ",-" + r2 + "L" + r2 + "," + r2 + "M-" + r2 + "," + r2 + "L" + r2 + ",-" + r2);
          },
          needLine: true,
          noDot: true
        },
        "cross-thin": {
          n: 33,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.4, 2);
            return align(angle, standoff, "M0," + rc + "V-" + rc + "M" + rc + ",0H-" + rc);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "x-thin": {
          n: 34,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            return align(angle, standoff, "M" + rx + "," + rx + "L-" + rx + ",-" + rx + "M" + rx + ",-" + rx + "L-" + rx + "," + rx);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        asterisk: {
          n: 35,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.2, 2);
            var rs = round(r * 0.85, 2);
            return align(angle, standoff, "M0," + rc + "V-" + rc + "M" + rc + ",0H-" + rc + "M" + rs + "," + rs + "L-" + rs + ",-" + rs + "M" + rs + ",-" + rs + "L-" + rs + "," + rs);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        hash: {
          n: 36,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r / 2, 2);
            var r2 = round(r, 2);
            return align(angle, standoff, "M" + r1 + "," + r2 + "V-" + r2 + "M" + (r1 - r2) + ",-" + r2 + "V" + r2 + "M" + r2 + "," + r1 + "H-" + r2 + "M-" + r2 + "," + (r1 - r2) + "H" + r2);
          },
          needLine: true,
          noFill: true
        },
        "y-up": {
          n: 37,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 1.2, 2);
            var y0 = round(r * 1.6, 2);
            var y1 = round(r * 0.8, 2);
            return align(angle, standoff, "M-" + x + "," + y1 + "L0,0M" + x + "," + y1 + "L0,0M0,-" + y0 + "L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "y-down": {
          n: 38,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 1.2, 2);
            var y0 = round(r * 1.6, 2);
            var y1 = round(r * 0.8, 2);
            return align(angle, standoff, "M-" + x + ",-" + y1 + "L0,0M" + x + ",-" + y1 + "L0,0M0," + y0 + "L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "y-left": {
          n: 39,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y = round(r * 1.2, 2);
            var x0 = round(r * 1.6, 2);
            var x1 = round(r * 0.8, 2);
            return align(angle, standoff, "M" + x1 + "," + y + "L0,0M" + x1 + ",-" + y + "L0,0M-" + x0 + ",0L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "y-right": {
          n: 40,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y = round(r * 1.2, 2);
            var x0 = round(r * 1.6, 2);
            var x1 = round(r * 0.8, 2);
            return align(angle, standoff, "M-" + x1 + "," + y + "L0,0M-" + x1 + ",-" + y + "L0,0M" + x0 + ",0L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-ew": {
          n: 41,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.4, 2);
            return align(angle, standoff, "M" + rc + ",0H-" + rc);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-ns": {
          n: 42,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.4, 2);
            return align(angle, standoff, "M0," + rc + "V-" + rc);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-ne": {
          n: 43,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            return align(angle, standoff, "M" + rx + ",-" + rx + "L-" + rx + "," + rx);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-nw": {
          n: 44,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            return align(angle, standoff, "M" + rx + "," + rx + "L-" + rx + ",-" + rx);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "arrow-up": {
          n: 45,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M0,0L-" + rx + "," + ry + "H" + rx + "Z");
          },
          backoff: 1,
          noDot: true
        },
        "arrow-down": {
          n: 46,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M0,0L-" + rx + ",-" + ry + "H" + rx + "Z");
          },
          noDot: true
        },
        "arrow-left": {
          n: 47,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,0L" + rx + ",-" + ry + "V" + ry + "Z");
          },
          noDot: true
        },
        "arrow-right": {
          n: 48,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,0L-" + rx + ",-" + ry + "V" + ry + "Z");
          },
          noDot: true
        },
        "arrow-bar-up": {
          n: 49,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M-" + rx + ",0H" + rx + "M0,0L-" + rx + "," + ry + "H" + rx + "Z");
          },
          backoff: 1,
          needLine: true,
          noDot: true
        },
        "arrow-bar-down": {
          n: 50,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M-" + rx + ",0H" + rx + "M0,0L-" + rx + ",-" + ry + "H" + rx + "Z");
          },
          needLine: true,
          noDot: true
        },
        "arrow-bar-left": {
          n: 51,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,-" + ry + "V" + ry + "M0,0L" + rx + ",-" + ry + "V" + ry + "Z");
          },
          needLine: true,
          noDot: true
        },
        "arrow-bar-right": {
          n: 52,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,-" + ry + "V" + ry + "M0,0L-" + rx + ",-" + ry + "V" + ry + "Z");
          },
          needLine: true,
          noDot: true
        },
        arrow: {
          n: 53,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var headAngle = PI / 2.5;
            var x = 2 * r * cos(headAngle);
            var y = 2 * r * sin(headAngle);
            return align(
              angle,
              standoff,
              "M0,0L" + -x + "," + y + "L" + x + "," + y + "Z"
            );
          },
          backoff: 0.9,
          noDot: true
        },
        "arrow-wide": {
          n: 54,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var headAngle = PI / 4;
            var x = 2 * r * cos(headAngle);
            var y = 2 * r * sin(headAngle);
            return align(
              angle,
              standoff,
              "M0,0L" + -x + "," + y + "A " + 2 * r + "," + 2 * r + " 0 0 1 " + x + "," + y + "Z"
            );
          },
          backoff: 0.4,
          noDot: true
        }
      };
      function skipAngle(angle) {
        return angle === null;
      }
      var lastPathIn;
      var lastPathOut;
      var lastAngle;
      var lastStandoff;
      function align(angle, standoff, path) {
        if ((!angle || angle % 360 === 0) && !standoff) return path;
        if (lastAngle === angle && lastStandoff === standoff && lastPathIn === path) return lastPathOut;
        lastAngle = angle;
        lastStandoff = standoff;
        lastPathIn = path;
        function rotate(t2, xy) {
          var cosT = cos(t2);
          var sinT = sin(t2);
          var x2 = xy[0];
          var y2 = xy[1] + (standoff || 0);
          return [
            x2 * cosT - y2 * sinT,
            x2 * sinT + y2 * cosT
          ];
        }
        var t = angle / 180 * PI;
        var x = 0;
        var y = 0;
        var cmd = parseSvgPath(path);
        var str = "";
        for (var i = 0; i < cmd.length; i++) {
          var cmdI = cmd[i];
          var op = cmdI[0];
          var x0 = x;
          var y0 = y;
          if (op === "M" || op === "L") {
            x = +cmdI[1];
            y = +cmdI[2];
          } else if (op === "m" || op === "l") {
            x += +cmdI[1];
            y += +cmdI[2];
          } else if (op === "H") {
            x = +cmdI[1];
          } else if (op === "h") {
            x += +cmdI[1];
          } else if (op === "V") {
            y = +cmdI[1];
          } else if (op === "v") {
            y += +cmdI[1];
          } else if (op === "A") {
            x = +cmdI[1];
            y = +cmdI[2];
            var E = rotate(t, [+cmdI[6], +cmdI[7]]);
            cmdI[6] = E[0];
            cmdI[7] = E[1];
            cmdI[3] = +cmdI[3] + angle;
          }
          if (op === "H" || op === "V") op = "L";
          if (op === "h" || op === "v") op = "l";
          if (op === "m" || op === "l") {
            x -= x0;
            y -= y0;
          }
          var B = rotate(t, [x, y]);
          if (op === "H" || op === "V") op = "L";
          if (op === "M" || op === "L" || op === "m" || op === "l") {
            cmdI[1] = B[0];
            cmdI[2] = B[1];
          }
          cmdI[0] = op;
          str += cmdI[0] + cmdI.slice(1).join(",");
        }
        lastPathOut = str;
        return str;
      }
    }
  });

  // src/components/drawing/index.js
  var require_drawing = __commonJS({
    "src/components/drawing/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var numberFormat = Lib.numberFormat;
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var Registry = require_registry();
      var Color = require_color();
      var Colorscale = require_colorscale();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var xmlnsNamespaces = require_xmlns_namespaces();
      var alignment = require_alignment();
      var LINE_SPACING = alignment.LINE_SPACING;
      var DESELECTDIM = require_interactions().DESELECTDIM;
      var subTypes = require_subtypes();
      var makeBubbleSizeFn = require_make_bubble_size_func();
      var appendArrayPointValue = require_helpers2().appendArrayPointValue;
      var drawing = module.exports = {};
      drawing.font = function(s, font) {
        var variant = font.variant;
        var style = font.style;
        var weight = font.weight;
        var color = font.color;
        var size = font.size;
        var family = font.family;
        var shadow = font.shadow;
        var lineposition = font.lineposition;
        var textcase = font.textcase;
        if (family) s.style("font-family", family);
        if (size + 1) s.style("font-size", size + "px");
        if (color) s.call(Color.fill, color);
        if (weight) s.style("font-weight", weight);
        if (style) s.style("font-style", style);
        if (variant) s.style("font-variant", variant);
        if (textcase) s.style("text-transform", dropNone(textcase2transform(textcase)));
        if (shadow) s.style("text-shadow", shadow === "auto" ? svgTextUtils.makeTextShadow(Color.contrast(color)) : dropNone(shadow));
        if (lineposition) s.style("text-decoration-line", dropNone(lineposition2decorationLine(lineposition)));
      };
      function dropNone(a) {
        return a === "none" ? void 0 : a;
      }
      var textcase2transformOptions = {
        normal: "none",
        lower: "lowercase",
        upper: "uppercase",
        "word caps": "capitalize"
      };
      function textcase2transform(textcase) {
        return textcase2transformOptions[textcase];
      }
      function lineposition2decorationLine(lineposition) {
        return lineposition.replace("under", "underline").replace("over", "overline").replace("through", "line-through").split("+").join(" ");
      }
      drawing.setPosition = function(s, x, y) {
        s.attr("x", x).attr("y", y);
      };
      drawing.setSize = function(s, w, h) {
        s.attr("width", w).attr("height", h);
      };
      drawing.setRect = function(s, x, y, w, h) {
        s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);
      };
      drawing.translatePoint = function(d, sel, xa, ya) {
        var x = xa.c2p(d.x);
        var y = ya.c2p(d.y);
        if (isNumeric(x) && isNumeric(y) && sel.node()) {
          if (sel.node().nodeName === "text") {
            sel.attr("x", x).attr("y", y);
          } else {
            sel.attr("transform", strTranslate(x, y));
          }
        } else {
          return false;
        }
        return true;
      };
      drawing.translatePoints = function(s, xa, ya) {
        s.each(function(d) {
          var sel = d3.select(this);
          drawing.translatePoint(d, sel, xa, ya);
        });
      };
      drawing.hideOutsideRangePoint = function(d, sel, xa, ya, xcalendar, ycalendar) {
        sel.attr(
          "display",
          xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar) ? null : "none"
        );
      };
      drawing.hideOutsideRangePoints = function(traceGroups, subplot) {
        if (!subplot._hasClipOnAxisFalse) return;
        var xa = subplot.xaxis;
        var ya = subplot.yaxis;
        traceGroups.each(function(d) {
          var trace = d[0].trace;
          var xcalendar = trace.xcalendar;
          var ycalendar = trace.ycalendar;
          var selector = Registry.traceIs(trace, "bar-like") ? ".bartext" : ".point,.textpoint";
          traceGroups.selectAll(selector).each(function(d2) {
            drawing.hideOutsideRangePoint(d2, d3.select(this), xa, ya, xcalendar, ycalendar);
          });
        });
      };
      drawing.crispRound = function(gd, lineWidth, dflt) {
        if (!lineWidth || !isNumeric(lineWidth)) return dflt || 0;
        if (gd._context.staticPlot) return lineWidth;
        if (lineWidth < 1) return 1;
        return Math.round(lineWidth);
      };
      drawing.singleLineStyle = function(d, s, lw, lc, ld) {
        s.style("fill", "none");
        var line = (((d || [])[0] || {}).trace || {}).line || {};
        var lw1 = lw || line.width || 0;
        var dash = ld || line.dash || "";
        Color.stroke(s, lc || line.color);
        drawing.dashLine(s, dash, lw1);
      };
      drawing.lineGroupStyle = function(s, lw, lc, ld) {
        s.style("fill", "none").each(function(d) {
          var line = (((d || [])[0] || {}).trace || {}).line || {};
          var lw1 = lw || line.width || 0;
          var dash = ld || line.dash || "";
          d3.select(this).call(Color.stroke, lc || line.color).call(drawing.dashLine, dash, lw1);
        });
      };
      drawing.dashLine = function(s, dash, lineWidth) {
        lineWidth = +lineWidth || 0;
        dash = drawing.dashStyle(dash, lineWidth);
        s.style({
          "stroke-dasharray": dash,
          "stroke-width": lineWidth + "px"
        });
      };
      drawing.dashStyle = function(dash, lineWidth) {
        lineWidth = +lineWidth || 1;
        var dlw = Math.max(lineWidth, 3);
        if (dash === "solid") dash = "";
        else if (dash === "dot") dash = dlw + "px," + dlw + "px";
        else if (dash === "dash") dash = 3 * dlw + "px," + 3 * dlw + "px";
        else if (dash === "longdash") dash = 5 * dlw + "px," + 5 * dlw + "px";
        else if (dash === "dashdot") {
          dash = 3 * dlw + "px," + dlw + "px," + dlw + "px," + dlw + "px";
        } else if (dash === "longdashdot") {
          dash = 5 * dlw + "px," + 2 * dlw + "px," + dlw + "px," + 2 * dlw + "px";
        }
        return dash;
      };
      function setFillStyle(sel, trace, gd, forLegend) {
        var markerPattern = trace.fillpattern;
        var fillgradient = trace.fillgradient;
        var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, "");
        if (patternShape) {
          var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);
          var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);
          var patternFGOpacity = markerPattern.fgopacity;
          var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);
          var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);
          var patternID = trace.uid;
          drawing.pattern(
            sel,
            "point",
            gd,
            patternID,
            patternShape,
            patternSize,
            patternSolidity,
            void 0,
            markerPattern.fillmode,
            patternBGColor,
            patternFGColor,
            patternFGOpacity
          );
        } else if (fillgradient && fillgradient.type !== "none") {
          var direction = fillgradient.type;
          var gradientID = "scatterfill-" + trace.uid;
          if (forLegend) {
            gradientID = "legendfill-" + trace.uid;
          }
          if (!forLegend && (fillgradient.start !== void 0 || fillgradient.stop !== void 0)) {
            var start, stop;
            if (direction === "horizontal") {
              start = {
                x: fillgradient.start,
                y: 0
              };
              stop = {
                x: fillgradient.stop,
                y: 0
              };
            } else if (direction === "vertical") {
              start = {
                x: 0,
                y: fillgradient.start
              };
              stop = {
                x: 0,
                y: fillgradient.stop
              };
            }
            start.x = trace._xA.c2p(
              start.x === void 0 ? trace._extremes.x.min[0].val : start.x,
              true
            );
            start.y = trace._yA.c2p(
              start.y === void 0 ? trace._extremes.y.min[0].val : start.y,
              true
            );
            stop.x = trace._xA.c2p(
              stop.x === void 0 ? trace._extremes.x.max[0].val : stop.x,
              true
            );
            stop.y = trace._yA.c2p(
              stop.y === void 0 ? trace._extremes.y.max[0].val : stop.y,
              true
            );
            sel.call(gradientWithBounds, gd, gradientID, "linear", fillgradient.colorscale, "fill", start, stop, true, false);
          } else {
            if (direction === "horizontal") {
              direction = direction + "reversed";
            }
            sel.call(drawing.gradient, gd, gradientID, direction, fillgradient.colorscale, "fill");
          }
        } else if (trace.fillcolor) {
          sel.call(Color.fill, trace.fillcolor);
        }
      }
      drawing.singleFillStyle = function(sel, gd) {
        var node = d3.select(sel.node());
        var data = node.data();
        var trace = ((data[0] || [])[0] || {}).trace || {};
        setFillStyle(sel, trace, gd, false);
      };
      drawing.fillGroupStyle = function(s, gd, forLegend) {
        s.style("stroke-width", 0).each(function(d) {
          var shape = d3.select(this);
          if (d[0].trace) {
            setFillStyle(shape, d[0].trace, gd, forLegend);
          }
        });
      };
      var SYMBOLDEFS = require_symbol_defs();
      drawing.symbolNames = [];
      drawing.symbolFuncs = [];
      drawing.symbolBackOffs = [];
      drawing.symbolNeedLines = {};
      drawing.symbolNoDot = {};
      drawing.symbolNoFill = {};
      drawing.symbolList = [];
      Object.keys(SYMBOLDEFS).forEach(function(k) {
        var symDef = SYMBOLDEFS[k];
        var n = symDef.n;
        drawing.symbolList.push(
          n,
          String(n),
          k,
          n + 100,
          String(n + 100),
          k + "-open"
        );
        drawing.symbolNames[n] = k;
        drawing.symbolFuncs[n] = symDef.f;
        drawing.symbolBackOffs[n] = symDef.backoff || 0;
        if (symDef.needLine) {
          drawing.symbolNeedLines[n] = true;
        }
        if (symDef.noDot) {
          drawing.symbolNoDot[n] = true;
        } else {
          drawing.symbolList.push(
            n + 200,
            String(n + 200),
            k + "-dot",
            n + 300,
            String(n + 300),
            k + "-open-dot"
          );
        }
        if (symDef.noFill) {
          drawing.symbolNoFill[n] = true;
        }
      });
      var MAXSYMBOL = drawing.symbolNames.length;
      var DOTPATH = "M0,0.5L0.5,0L0,-0.5L-0.5,0Z";
      drawing.symbolNumber = function(v) {
        if (isNumeric(v)) {
          v = +v;
        } else if (typeof v === "string") {
          var vbase = 0;
          if (v.indexOf("-open") > 0) {
            vbase = 100;
            v = v.replace("-open", "");
          }
          if (v.indexOf("-dot") > 0) {
            vbase += 200;
            v = v.replace("-dot", "");
          }
          v = drawing.symbolNames.indexOf(v);
          if (v >= 0) {
            v += vbase;
          }
        }
        return v % 100 >= MAXSYMBOL || v >= 400 ? 0 : Math.floor(Math.max(v, 0));
      };
      function makePointPath(symbolNumber, r, t, s) {
        var base = symbolNumber % 100;
        return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : "");
      }
      var stopFormatter = numberFormat("~f");
      var gradientInfo = {
        radial: { type: "radial" },
        radialreversed: { type: "radial", reversed: true },
        horizontal: { type: "linear", start: { x: 1, y: 0 }, stop: { x: 0, y: 0 } },
        horizontalreversed: { type: "linear", start: { x: 1, y: 0 }, stop: { x: 0, y: 0 }, reversed: true },
        vertical: { type: "linear", start: { x: 0, y: 1 }, stop: { x: 0, y: 0 } },
        verticalreversed: { type: "linear", start: { x: 0, y: 1 }, stop: { x: 0, y: 0 }, reversed: true }
      };
      drawing.gradient = function(sel, gd, gradientID, type, colorscale, prop) {
        var info = gradientInfo[type];
        return gradientWithBounds(
          sel,
          gd,
          gradientID,
          info.type,
          colorscale,
          prop,
          info.start,
          info.stop,
          false,
          info.reversed
        );
      };
      function gradientWithBounds(sel, gd, gradientID, type, colorscale, prop, start, stop, inUserSpace, reversed) {
        var len = colorscale.length;
        var info;
        if (type === "linear") {
          info = {
            node: "linearGradient",
            attrs: {
              x1: start.x,
              y1: start.y,
              x2: stop.x,
              y2: stop.y,
              gradientUnits: inUserSpace ? "userSpaceOnUse" : "objectBoundingBox"
            },
            reversed
          };
        } else if (type === "radial") {
          info = {
            node: "radialGradient",
            reversed
          };
        }
        var colorStops = new Array(len);
        for (var i = 0; i < len; i++) {
          if (info.reversed) {
            colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];
          } else {
            colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];
          }
        }
        var fullLayout = gd._fullLayout;
        var fullID = "g" + fullLayout._uid + "-" + gradientID;
        var gradient = fullLayout._defs.select(".gradients").selectAll("#" + fullID).data([type + colorStops.join(";")], Lib.identity);
        gradient.exit().remove();
        gradient.enter().append(info.node).each(function() {
          var el = d3.select(this);
          if (info.attrs) el.attr(info.attrs);
          el.attr("id", fullID);
          var stops = el.selectAll("stop").data(colorStops);
          stops.exit().remove();
          stops.enter().append("stop");
          stops.each(function(d) {
            var tc = tinycolor(d[1]);
            d3.select(this).attr({
              offset: d[0] + "%",
              "stop-color": Color.tinyRGB(tc),
              "stop-opacity": tc.getAlpha()
            });
          });
        });
        sel.style(prop, getFullUrl(fullID, gd)).style(prop + "-opacity", null);
        sel.classed("gradient_filled", true);
      }
      drawing.pattern = function(sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {
        var isLegend = calledBy === "legend";
        if (mcc) {
          if (fillmode === "overlay") {
            bgcolor = mcc;
            fgcolor = Color.contrast(bgcolor);
          } else {
            bgcolor = void 0;
            fgcolor = mcc;
          }
        }
        var fullLayout = gd._fullLayout;
        var fullID = "p" + fullLayout._uid + "-" + patternID;
        var width, height;
        var linearFn = function(x, x0, x1, y0, y1) {
          return y0 + (y1 - y0) * (x - x0) / (x1 - x0);
        };
        var path, linewidth, radius;
        var patternTag;
        var patternAttrs = {};
        var fgC = tinycolor(fgcolor);
        var fgRGB = Color.tinyRGB(fgC);
        var fgAlpha = fgC.getAlpha();
        var opacity = fgopacity * fgAlpha;
        switch (shape) {
          case "/":
            width = size * Math.sqrt(2);
            height = size * Math.sqrt(2);
            path = "M-" + width / 4 + "," + height / 4 + "l" + width / 2 + ",-" + height / 2 + "M0," + height + "L" + width + ",0M" + width / 4 * 3 + "," + height / 4 * 5 + "l" + width / 2 + ",-" + height / 2;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "\\":
            width = size * Math.sqrt(2);
            height = size * Math.sqrt(2);
            path = "M" + width / 4 * 3 + ",-" + height / 4 + "l" + width / 2 + "," + height / 2 + "M0,0L" + width + "," + height + "M-" + width / 4 + "," + height / 4 * 3 + "l" + width / 2 + "," + height / 2;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "x":
            width = size * Math.sqrt(2);
            height = size * Math.sqrt(2);
            path = "M-" + width / 4 + "," + height / 4 + "l" + width / 2 + ",-" + height / 2 + "M0," + height + "L" + width + ",0M" + width / 4 * 3 + "," + height / 4 * 5 + "l" + width / 2 + ",-" + height / 2 + "M" + width / 4 * 3 + ",-" + height / 4 + "l" + width / 2 + "," + height / 2 + "M0,0L" + width + "," + height + "M-" + width / 4 + "," + height / 4 * 3 + "l" + width / 2 + "," + height / 2;
            linewidth = size - size * Math.sqrt(1 - solidity);
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "|":
            width = size;
            height = size;
            patternTag = "path";
            path = "M" + width / 2 + ",0L" + width / 2 + "," + height;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "-":
            width = size;
            height = size;
            patternTag = "path";
            path = "M0," + height / 2 + "L" + width + "," + height / 2;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "+":
            width = size;
            height = size;
            patternTag = "path";
            path = "M" + width / 2 + ",0L" + width / 2 + "," + height + "M0," + height / 2 + "L" + width + "," + height / 2;
            linewidth = size - size * Math.sqrt(1 - solidity);
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case ".":
            width = size;
            height = size;
            if (solidity < Math.PI / 4) {
              radius = Math.sqrt(solidity * size * size / Math.PI);
            } else {
              radius = linearFn(solidity, Math.PI / 4, 1, size / 2, size / Math.sqrt(2));
            }
            patternTag = "circle";
            patternAttrs = {
              cx: width / 2,
              cy: height / 2,
              r: radius,
              opacity,
              fill: fgRGB
            };
            break;
        }
        var str = [
          shape || "noSh",
          bgcolor || "noBg",
          fgcolor || "noFg",
          size,
          solidity
        ].join(";");
        var pattern = fullLayout._defs.select(".patterns").selectAll("#" + fullID).data([str], Lib.identity);
        pattern.exit().remove();
        pattern.enter().append("pattern").each(function() {
          var el = d3.select(this);
          el.attr({
            id: fullID,
            width: width + "px",
            height: height + "px",
            patternUnits: "userSpaceOnUse",
            // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons
            patternTransform: isLegend ? "scale(0.8)" : ""
          });
          if (bgcolor) {
            var bgC = tinycolor(bgcolor);
            var bgRGB = Color.tinyRGB(bgC);
            var bgAlpha = bgC.getAlpha();
            var rects = el.selectAll("rect").data([0]);
            rects.exit().remove();
            rects.enter().append("rect").attr({
              width: width + "px",
              height: height + "px",
              fill: bgRGB,
              "fill-opacity": bgAlpha
            });
          }
          var patterns = el.selectAll(patternTag).data([0]);
          patterns.exit().remove();
          patterns.enter().append(patternTag).attr(patternAttrs);
        });
        sel.style("fill", getFullUrl(fullID, gd)).style("fill-opacity", null);
        sel.classed("pattern_filled", true);
      };
      drawing.initGradients = function(gd) {
        var fullLayout = gd._fullLayout;
        var gradientsGroup = Lib.ensureSingle(fullLayout._defs, "g", "gradients");
        gradientsGroup.selectAll("linearGradient,radialGradient").remove();
        d3.select(gd).selectAll(".gradient_filled").classed("gradient_filled", false);
      };
      drawing.initPatterns = function(gd) {
        var fullLayout = gd._fullLayout;
        var patternsGroup = Lib.ensureSingle(fullLayout._defs, "g", "patterns");
        patternsGroup.selectAll("pattern").remove();
        d3.select(gd).selectAll(".pattern_filled").classed("pattern_filled", false);
      };
      drawing.getPatternAttr = function(mp, i, dflt) {
        if (mp && Lib.isArrayOrTypedArray(mp)) {
          return i < mp.length ? mp[i] : dflt;
        }
        return mp;
      };
      drawing.pointStyle = function(s, trace, gd, pt) {
        if (!s.size()) return;
        var fns = drawing.makePointStyleFns(trace);
        s.each(function(d) {
          drawing.singlePointStyle(d, d3.select(this), trace, fns, gd, pt);
        });
      };
      drawing.singlePointStyle = function(d, sel, trace, fns, gd, pt) {
        var marker = trace.marker;
        var markerLine = marker.line;
        if (pt && pt.i >= 0 && d.i === void 0) d.i = pt.i;
        sel.style(
          "opacity",
          fns.selectedOpacityFn ? fns.selectedOpacityFn(d) : d.mo === void 0 ? marker.opacity : d.mo
        );
        if (fns.ms2mrc) {
          var r;
          if (d.ms === "various" || marker.size === "various") {
            r = 3;
          } else {
            r = fns.ms2mrc(d.ms);
          }
          d.mrc = r;
          if (fns.selectedSizeFn) {
            r = d.mrc = fns.selectedSizeFn(d);
          }
          var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;
          d.om = x % 200 >= 100;
          var angle = getMarkerAngle(d, trace);
          var standoff = getMarkerStandoff(d, trace);
          sel.attr("d", makePointPath(x, r, angle, standoff));
        }
        var perPointGradient = false;
        var fillColor, lineColor, lineWidth;
        if (d.so) {
          lineWidth = markerLine.outlierwidth;
          lineColor = markerLine.outliercolor;
          fillColor = marker.outliercolor;
        } else {
          var markerLineWidth = (markerLine || {}).width;
          lineWidth = (d.mlw + 1 || markerLineWidth + 1 || // TODO: we need the latter for legends... can we get rid of it?
          (d.trace ? (d.trace.marker.line || {}).width : 0) + 1) - 1 || 0;
          if ("mlc" in d) lineColor = d.mlcc = fns.lineScale(d.mlc);
          else if (Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;
          else lineColor = markerLine.color;
          if (Lib.isArrayOrTypedArray(marker.color)) {
            fillColor = Color.defaultLine;
            perPointGradient = true;
          }
          if ("mc" in d) {
            fillColor = d.mcc = fns.markerScale(d.mc);
          } else {
            fillColor = marker.color || marker.colors || "rgba(0,0,0,0)";
          }
          if (fns.selectedColorFn) {
            fillColor = fns.selectedColorFn(d);
          }
        }
        if (d.om) {
          sel.call(Color.stroke, fillColor).style({
            "stroke-width": (lineWidth || 1) + "px",
            fill: "none"
          });
        } else {
          sel.style("stroke-width", (d.isBlank ? 0 : lineWidth) + "px");
          var markerGradient = marker.gradient;
          var gradientType = d.mgt;
          if (gradientType) perPointGradient = true;
          else gradientType = markerGradient && markerGradient.type;
          if (Lib.isArrayOrTypedArray(gradientType)) {
            gradientType = gradientType[0];
            if (!gradientInfo[gradientType]) gradientType = 0;
          }
          var markerPattern = marker.pattern;
          var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, "");
          if (gradientType && gradientType !== "none") {
            var gradientColor = d.mgc;
            if (gradientColor) perPointGradient = true;
            else gradientColor = markerGradient.color;
            var gradientID = trace.uid;
            if (perPointGradient) gradientID += "-" + d.i;
            drawing.gradient(
              sel,
              gd,
              gradientID,
              gradientType,
              [[0, gradientColor], [1, fillColor]],
              "fill"
            );
          } else if (patternShape) {
            var perPointPattern = false;
            var fgcolor = markerPattern.fgcolor;
            if (!fgcolor && pt && pt.color) {
              fgcolor = pt.color;
              perPointPattern = true;
            }
            var patternFGColor = drawing.getPatternAttr(fgcolor, d.i, pt && pt.color || null);
            var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);
            var patternFGOpacity = markerPattern.fgopacity;
            var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);
            var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);
            perPointPattern = perPointPattern || d.mcc || Lib.isArrayOrTypedArray(markerPattern.shape) || Lib.isArrayOrTypedArray(markerPattern.bgcolor) || Lib.isArrayOrTypedArray(markerPattern.fgcolor) || Lib.isArrayOrTypedArray(markerPattern.size) || Lib.isArrayOrTypedArray(markerPattern.solidity);
            var patternID = trace.uid;
            if (perPointPattern) patternID += "-" + d.i;
            drawing.pattern(
              sel,
              "point",
              gd,
              patternID,
              patternShape,
              patternSize,
              patternSolidity,
              d.mcc,
              markerPattern.fillmode,
              patternBGColor,
              patternFGColor,
              patternFGOpacity
            );
          } else {
            Lib.isArrayOrTypedArray(fillColor) ? Color.fill(sel, fillColor[d.i]) : Color.fill(sel, fillColor);
          }
          if (lineWidth) {
            Color.stroke(sel, lineColor);
          }
        }
      };
      drawing.makePointStyleFns = function(trace) {
        var out = {};
        var marker = trace.marker;
        out.markerScale = drawing.tryColorscale(marker, "");
        out.lineScale = drawing.tryColorscale(marker, "line");
        if (Registry.traceIs(trace, "symbols")) {
          out.ms2mrc = subTypes.isBubble(trace) ? makeBubbleSizeFn(trace) : function() {
            return (marker.size || 6) / 2;
          };
        }
        if (trace.selectedpoints) {
          Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));
        }
        return out;
      };
      drawing.makeSelectedPointStyleFns = function(trace) {
        var out = {};
        var selectedAttrs = trace.selected || {};
        var unselectedAttrs = trace.unselected || {};
        var marker = trace.marker || {};
        var selectedMarker = selectedAttrs.marker || {};
        var unselectedMarker = unselectedAttrs.marker || {};
        var mo = marker.opacity;
        var smo = selectedMarker.opacity;
        var usmo = unselectedMarker.opacity;
        var smoIsDefined = smo !== void 0;
        var usmoIsDefined = usmo !== void 0;
        if (Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {
          out.selectedOpacityFn = function(d) {
            var base = d.mo === void 0 ? marker.opacity : d.mo;
            if (d.selected) {
              return smoIsDefined ? smo : base;
            } else {
              return usmoIsDefined ? usmo : DESELECTDIM * base;
            }
          };
        }
        var mc = marker.color;
        var smc = selectedMarker.color;
        var usmc = unselectedMarker.color;
        if (smc || usmc) {
          out.selectedColorFn = function(d) {
            var base = d.mcc || mc;
            if (d.selected) {
              return smc || base;
            } else {
              return usmc || base;
            }
          };
        }
        var ms = marker.size;
        var sms = selectedMarker.size;
        var usms = unselectedMarker.size;
        var smsIsDefined = sms !== void 0;
        var usmsIsDefined = usms !== void 0;
        if (Registry.traceIs(trace, "symbols") && (smsIsDefined || usmsIsDefined)) {
          out.selectedSizeFn = function(d) {
            var base = d.mrc || ms / 2;
            if (d.selected) {
              return smsIsDefined ? sms / 2 : base;
            } else {
              return usmsIsDefined ? usms / 2 : base;
            }
          };
        }
        return out;
      };
      drawing.makeSelectedTextStyleFns = function(trace) {
        var out = {};
        var selectedAttrs = trace.selected || {};
        var unselectedAttrs = trace.unselected || {};
        var textFont = trace.textfont || {};
        var selectedTextFont = selectedAttrs.textfont || {};
        var unselectedTextFont = unselectedAttrs.textfont || {};
        var tc = textFont.color;
        var stc = selectedTextFont.color;
        var utc = unselectedTextFont.color;
        out.selectedTextColorFn = function(d) {
          var base = d.tc || tc;
          if (d.selected) {
            return stc || base;
          } else {
            if (utc) return utc;
            else return stc ? base : Color.addOpacity(base, DESELECTDIM);
          }
        };
        return out;
      };
      drawing.selectedPointStyle = function(s, trace) {
        if (!s.size() || !trace.selectedpoints) return;
        var fns = drawing.makeSelectedPointStyleFns(trace);
        var marker = trace.marker || {};
        var seq = [];
        if (fns.selectedOpacityFn) {
          seq.push(function(pt, d) {
            pt.style("opacity", fns.selectedOpacityFn(d));
          });
        }
        if (fns.selectedColorFn) {
          seq.push(function(pt, d) {
            Color.fill(pt, fns.selectedColorFn(d));
          });
        }
        if (fns.selectedSizeFn) {
          seq.push(function(pt, d) {
            var mx = d.mx || marker.symbol || 0;
            var mrc2 = fns.selectedSizeFn(d);
            pt.attr("d", makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));
            d.mrc2 = mrc2;
          });
        }
        if (seq.length) {
          s.each(function(d) {
            var pt = d3.select(this);
            for (var i = 0; i < seq.length; i++) {
              seq[i](pt, d);
            }
          });
        }
      };
      drawing.tryColorscale = function(marker, prefix) {
        var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;
        if (cont) {
          var colorArray = cont.color;
          if ((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {
            return Colorscale.makeColorScaleFuncFromTrace(cont);
          }
        }
        return Lib.identity;
      };
      var TEXTOFFSETSIGN = {
        start: 1,
        end: -1,
        middle: 0,
        bottom: 1,
        top: -1
      };
      function textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {
        var group = d3.select(s.node().parentNode);
        var v = textPosition.indexOf("top") !== -1 ? "top" : textPosition.indexOf("bottom") !== -1 ? "bottom" : "middle";
        var h = textPosition.indexOf("left") !== -1 ? "end" : textPosition.indexOf("right") !== -1 ? "start" : "middle";
        var r = markerRadius ? markerRadius / 0.8 + 1 : 0;
        var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;
        var dx = TEXTOFFSETSIGN[h] * r;
        var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r + (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;
        s.attr("text-anchor", h);
        if (!dontTouchParent) {
          group.attr("transform", strTranslate(dx, dy));
        }
      }
      function extracTextFontSize(d, trace) {
        var fontSize = d.ts || trace.textfont.size;
        return isNumeric(fontSize) && fontSize > 0 ? fontSize : 0;
      }
      drawing.textPointStyle = function(s, trace, gd) {
        if (!s.size()) return;
        var selectedTextColorFn;
        if (trace.selectedpoints) {
          var fns = drawing.makeSelectedTextStyleFns(trace);
          selectedTextColorFn = fns.selectedTextColorFn;
        }
        var texttemplate = trace.texttemplate;
        var fullLayout = gd._fullLayout;
        s.each(function(d) {
          var p = d3.select(this);
          var text = texttemplate ? Lib.extractOption(d, trace, "txt", "texttemplate") : Lib.extractOption(d, trace, "tx", "text");
          if (!text && text !== 0) {
            p.remove();
            return;
          }
          if (texttemplate) {
            var fn = trace._module.formatLabels;
            var labels = fn ? fn(d, trace, fullLayout) : {};
            var pointValues = {};
            appendArrayPointValue(pointValues, trace, d.i);
            var meta = trace._meta || {};
            text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);
          }
          var pos = d.tp || trace.textposition;
          var fontSize = extracTextFontSize(d, trace);
          var fontColor = selectedTextColorFn ? selectedTextColorFn(d) : d.tc || trace.textfont.color;
          p.call(drawing.font, {
            family: d.tf || trace.textfont.family,
            weight: d.tw || trace.textfont.weight,
            style: d.ty || trace.textfont.style,
            variant: d.tv || trace.textfont.variant,
            textcase: d.tC || trace.textfont.textcase,
            lineposition: d.tE || trace.textfont.lineposition,
            shadow: d.tS || trace.textfont.shadow,
            size: fontSize,
            color: fontColor
          }).text(text).call(svgTextUtils.convertToTspans, gd).call(textPointPosition, pos, fontSize, d.mrc);
        });
      };
      drawing.selectedTextStyle = function(s, trace) {
        if (!s.size() || !trace.selectedpoints) return;
        var fns = drawing.makeSelectedTextStyleFns(trace);
        s.each(function(d) {
          var tx = d3.select(this);
          var tc = fns.selectedTextColorFn(d);
          var tp = d.tp || trace.textposition;
          var fontSize = extracTextFontSize(d, trace);
          Color.fill(tx, tc);
          var dontTouchParent = Registry.traceIs(trace, "bar-like");
          textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);
        });
      };
      var CatmullRomExp = 0.5;
      drawing.smoothopen = function(pts, smoothness) {
        if (pts.length < 3) {
          return "M" + pts.join("L");
        }
        var path = "M" + pts[0];
        var tangents = [];
        var i;
        for (i = 1; i < pts.length - 1; i++) {
          tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));
        }
        path += "Q" + tangents[0][0] + " " + pts[1];
        for (i = 2; i < pts.length - 1; i++) {
          path += "C" + tangents[i - 2][1] + " " + tangents[i - 1][0] + " " + pts[i];
        }
        path += "Q" + tangents[pts.length - 3][1] + " " + pts[pts.length - 1];
        return path;
      };
      drawing.smoothclosed = function(pts, smoothness) {
        if (pts.length < 3) {
          return "M" + pts.join("L") + "Z";
        }
        var path = "M" + pts[0];
        var pLast = pts.length - 1;
        var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];
        var i;
        for (i = 1; i < pLast; i++) {
          tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));
        }
        tangents.push(
          makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness)
        );
        for (i = 1; i <= pLast; i++) {
          path += "C" + tangents[i - 1][1] + " " + tangents[i][0] + " " + pts[i];
        }
        path += "C" + tangents[pLast][1] + " " + tangents[0][0] + " " + pts[0] + "Z";
        return path;
      };
      var lastDrawnX;
      var lastDrawnY;
      function roundEnd(pt, isY, isLastPoint) {
        if (isLastPoint) pt = applyBackoff(pt);
        return isY ? roundY(pt[1]) : roundX(pt[0]);
      }
      function roundX(p) {
        var v = d3.round(p, 2);
        lastDrawnX = v;
        return v;
      }
      function roundY(p) {
        var v = d3.round(p, 2);
        lastDrawnY = v;
        return v;
      }
      function makeTangent(prevpt, thispt, nextpt, smoothness) {
        var d1x = prevpt[0] - thispt[0];
        var d1y = prevpt[1] - thispt[1];
        var d2x = nextpt[0] - thispt[0];
        var d2y = nextpt[1] - thispt[1];
        var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);
        var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);
        var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;
        var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;
        var denom1 = 3 * d2a * (d1a + d2a);
        var denom2 = 3 * d1a * (d1a + d2a);
        return [
          [
            roundX(thispt[0] + (denom1 && numx / denom1)),
            roundY(thispt[1] + (denom1 && numy / denom1))
          ],
          [
            roundX(thispt[0] - (denom2 && numx / denom2)),
            roundY(thispt[1] - (denom2 && numy / denom2))
          ]
        ];
      }
      var STEPPATH = {
        hv: function(p0, p1, isLastPoint) {
          return "H" + roundX(p1[0]) + "V" + roundEnd(p1, 1, isLastPoint);
        },
        vh: function(p0, p1, isLastPoint) {
          return "V" + roundY(p1[1]) + "H" + roundEnd(p1, 0, isLastPoint);
        },
        hvh: function(p0, p1, isLastPoint) {
          return "H" + roundX((p0[0] + p1[0]) / 2) + "V" + roundY(p1[1]) + "H" + roundEnd(p1, 0, isLastPoint);
        },
        vhv: function(p0, p1, isLastPoint) {
          return "V" + roundY((p0[1] + p1[1]) / 2) + "H" + roundX(p1[0]) + "V" + roundEnd(p1, 1, isLastPoint);
        }
      };
      var STEPLINEAR = function(p0, p1, isLastPoint) {
        return "L" + roundEnd(p1, 0, isLastPoint) + "," + roundEnd(p1, 1, isLastPoint);
      };
      drawing.steps = function(shape) {
        var onestep = STEPPATH[shape] || STEPLINEAR;
        return function(pts) {
          var path = "M" + roundX(pts[0][0]) + "," + roundY(pts[0][1]);
          var len = pts.length;
          for (var i = 1; i < len; i++) {
            path += onestep(pts[i - 1], pts[i], i === len - 1);
          }
          return path;
        };
      };
      function applyBackoff(pt, start) {
        var backoff = pt.backoff;
        var trace = pt.trace;
        var d = pt.d;
        var i = pt.i;
        if (backoff && trace && trace.marker && trace.marker.angle % 360 === 0 && trace.line && trace.line.shape !== "spline") {
          var arrayBackoff = Lib.isArrayOrTypedArray(backoff);
          var end = pt;
          var x1 = start ? start[0] : lastDrawnX || 0;
          var y1 = start ? start[1] : lastDrawnY || 0;
          var x2 = end[0];
          var y2 = end[1];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var t = Math.atan2(dy, dx);
          var b = arrayBackoff ? backoff[i] : backoff;
          if (b === "auto") {
            var endI = end.i;
            if (trace.type === "scatter") endI--;
            var endMarker = end.marker;
            var endMarkerSymbol = endMarker.symbol;
            if (Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];
            var endMarkerSize = endMarker.size;
            if (Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];
            b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;
            b += drawing.getMarkerStandoff(d[endI], trace) || 0;
          }
          var x = x2 - b * Math.cos(t);
          var y = y2 - b * Math.sin(t);
          if ((x <= x2 && x >= x1 || x >= x2 && x <= x1) && (y <= y2 && y >= y1 || y >= y2 && y <= y1)) {
            pt = [x, y];
          }
        }
        return pt;
      }
      drawing.applyBackoff = applyBackoff;
      drawing.makeTester = function() {
        var tester = Lib.ensureSingleById(d3.select("body"), "svg", "js-plotly-tester", function(s) {
          s.attr(xmlnsNamespaces.svgAttrs).style({
            position: "absolute",
            left: "-10000px",
            top: "-10000px",
            width: "9000px",
            height: "9000px",
            "z-index": "1"
          });
        });
        var testref = Lib.ensureSingle(tester, "path", "js-reference-point", function(s) {
          s.attr("d", "M0,0H1V1H0Z").style({
            "stroke-width": 0,
            fill: "black"
          });
        });
        drawing.tester = tester;
        drawing.testref = testref;
      };
      drawing.savedBBoxes = {};
      var savedBBoxesCount = 0;
      var maxSavedBBoxes = 1e4;
      drawing.bBox = function(node, inTester, hash) {
        if (!hash) hash = nodeHash(node);
        var out;
        if (hash) {
          out = drawing.savedBBoxes[hash];
          if (out) return Lib.extendFlat({}, out);
        } else if (node.childNodes.length === 1) {
          var innerNode = node.childNodes[0];
          hash = nodeHash(innerNode);
          if (hash) {
            var x = +innerNode.getAttribute("x") || 0;
            var y = +innerNode.getAttribute("y") || 0;
            var transform = innerNode.getAttribute("transform");
            if (!transform) {
              var innerBB = drawing.bBox(innerNode, false, hash);
              if (x) {
                innerBB.left += x;
                innerBB.right += x;
              }
              if (y) {
                innerBB.top += y;
                innerBB.bottom += y;
              }
              return innerBB;
            }
            hash += "~" + x + "~" + y + "~" + transform;
            out = drawing.savedBBoxes[hash];
            if (out) return Lib.extendFlat({}, out);
          }
        }
        var testNode, tester;
        if (inTester) {
          testNode = node;
        } else {
          tester = drawing.tester.node();
          testNode = node.cloneNode(true);
          tester.appendChild(testNode);
        }
        d3.select(testNode).attr("transform", null).call(svgTextUtils.positionText, 0, 0);
        var testRect = testNode.getBoundingClientRect();
        var refRect = drawing.testref.node().getBoundingClientRect();
        if (!inTester) tester.removeChild(testNode);
        var bb = {
          height: testRect.height,
          width: testRect.width,
          left: testRect.left - refRect.left,
          top: testRect.top - refRect.top,
          right: testRect.right - refRect.left,
          bottom: testRect.bottom - refRect.top
        };
        if (savedBBoxesCount >= maxSavedBBoxes) {
          drawing.savedBBoxes = {};
          savedBBoxesCount = 0;
        }
        if (hash) drawing.savedBBoxes[hash] = bb;
        savedBBoxesCount++;
        return Lib.extendFlat({}, bb);
      };
      function nodeHash(node) {
        var inputText = node.getAttribute("data-unformatted");
        if (inputText === null) return;
        return inputText + node.getAttribute("data-math") + node.getAttribute("text-anchor") + node.getAttribute("style");
      }
      drawing.setClipUrl = function(s, localId, gd) {
        s.attr("clip-path", getFullUrl(localId, gd));
      };
      function getFullUrl(localId, gd) {
        if (!localId) return null;
        var context = gd._context;
        var baseUrl = context._exportedPlot ? "" : context._baseUrl || "";
        return baseUrl ? "url('" + baseUrl + "#" + localId + "')" : "url(#" + localId + ")";
      }
      drawing.getTranslate = function(element) {
        var re = /.*\btranslate\((-?\d*\.?\d*)[^-\d]*(-?\d*\.?\d*)[^\d].*/;
        var getter = element.attr ? "attr" : "getAttribute";
        var transform = element[getter]("transform") || "";
        var translate = transform.replace(re, function(match, p1, p2) {
          return [p1, p2].join(" ");
        }).split(" ");
        return {
          x: +translate[0] || 0,
          y: +translate[1] || 0
        };
      };
      drawing.setTranslate = function(element, x, y) {
        var re = /(\btranslate\(.*?\);?)/;
        var getter = element.attr ? "attr" : "getAttribute";
        var setter = element.attr ? "attr" : "setAttribute";
        var transform = element[getter]("transform") || "";
        x = x || 0;
        y = y || 0;
        transform = transform.replace(re, "").trim();
        transform += strTranslate(x, y);
        transform = transform.trim();
        element[setter]("transform", transform);
        return transform;
      };
      drawing.getScale = function(element) {
        var re = /.*\bscale\((\d*\.?\d*)[^\d]*(\d*\.?\d*)[^\d].*/;
        var getter = element.attr ? "attr" : "getAttribute";
        var transform = element[getter]("transform") || "";
        var translate = transform.replace(re, function(match, p1, p2) {
          return [p1, p2].join(" ");
        }).split(" ");
        return {
          x: +translate[0] || 1,
          y: +translate[1] || 1
        };
      };
      drawing.setScale = function(element, x, y) {
        var re = /(\bscale\(.*?\);?)/;
        var getter = element.attr ? "attr" : "getAttribute";
        var setter = element.attr ? "attr" : "setAttribute";
        var transform = element[getter]("transform") || "";
        x = x || 1;
        y = y || 1;
        transform = transform.replace(re, "").trim();
        transform += "scale(" + x + "," + y + ")";
        transform = transform.trim();
        element[setter]("transform", transform);
        return transform;
      };
      var SCALE_RE = /\s*sc.*/;
      drawing.setPointGroupScale = function(selection, xScale, yScale) {
        xScale = xScale || 1;
        yScale = yScale || 1;
        if (!selection) return;
        var scale = xScale === 1 && yScale === 1 ? "" : "scale(" + xScale + "," + yScale + ")";
        selection.each(function() {
          var t = (this.getAttribute("transform") || "").replace(SCALE_RE, "");
          t += scale;
          t = t.trim();
          this.setAttribute("transform", t);
        });
      };
      var TEXT_POINT_LAST_TRANSLATION_RE = /translate\([^)]*\)\s*$/;
      drawing.setTextPointsScale = function(selection, xScale, yScale) {
        if (!selection) return;
        selection.each(function() {
          var transforms;
          var el = d3.select(this);
          var text = el.select("text");
          if (!text.node()) return;
          var x = parseFloat(text.attr("x") || 0);
          var y = parseFloat(text.attr("y") || 0);
          var existingTransform = (el.attr("transform") || "").match(TEXT_POINT_LAST_TRANSLATION_RE);
          if (xScale === 1 && yScale === 1) {
            transforms = [];
          } else {
            transforms = [
              strTranslate(x, y),
              "scale(" + xScale + "," + yScale + ")",
              strTranslate(-x, -y)
            ];
          }
          if (existingTransform) {
            transforms.push(existingTransform);
          }
          el.attr("transform", transforms.join(""));
        });
      };
      function getMarkerStandoff(d, trace) {
        var standoff;
        if (d) standoff = d.mf;
        if (standoff === void 0) {
          standoff = trace.marker ? trace.marker.standoff || 0 : 0;
        }
        if (!trace._geo && !trace._xA) {
          return -standoff;
        }
        return standoff;
      }
      drawing.getMarkerStandoff = getMarkerStandoff;
      var atan2 = Math.atan2;
      var cos = Math.cos;
      var sin = Math.sin;
      function rotate(t, xy) {
        var x = xy[0];
        var y = xy[1];
        return [
          x * cos(t) - y * sin(t),
          x * sin(t) + y * cos(t)
        ];
      }
      var previousLon;
      var previousLat;
      var previousX;
      var previousY;
      var previousI;
      var previousTraceUid;
      function getMarkerAngle(d, trace) {
        var angle = d.ma;
        if (angle === void 0) {
          angle = trace.marker.angle;
          if (!angle || Lib.isArrayOrTypedArray(angle)) {
            angle = 0;
          }
        }
        var x, y;
        var ref = trace.marker.angleref;
        if (ref === "previous" || ref === "north") {
          if (trace._geo) {
            var p = trace._geo.project(d.lonlat);
            x = p[0];
            y = p[1];
          } else {
            var xa = trace._xA;
            var ya = trace._yA;
            if (xa && ya) {
              x = xa.c2p(d.x);
              y = ya.c2p(d.y);
            } else {
              return 90;
            }
          }
          if (trace._geo) {
            var lon = d.lonlat[0];
            var lat = d.lonlat[1];
            var north = trace._geo.project([
              lon,
              lat + 1e-5
              // epsilon
            ]);
            var east = trace._geo.project([
              lon + 1e-5,
              // epsilon
              lat
            ]);
            var u = atan2(
              east[1] - y,
              east[0] - x
            );
            var v = atan2(
              north[1] - y,
              north[0] - x
            );
            var t;
            if (ref === "north") {
              t = angle / 180 * Math.PI;
            } else if (ref === "previous") {
              var lon1 = lon / 180 * Math.PI;
              var lat1 = lat / 180 * Math.PI;
              var lon2 = previousLon / 180 * Math.PI;
              var lat2 = previousLat / 180 * Math.PI;
              var dLon = lon2 - lon1;
              var deltaY = cos(lat2) * sin(dLon);
              var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);
              t = -atan2(
                deltaY,
                deltaX
              ) - Math.PI;
              previousLon = lon;
              previousLat = lat;
            }
            var A = rotate(u, [cos(t), 0]);
            var B = rotate(v, [sin(t), 0]);
            angle = atan2(
              A[1] + B[1],
              A[0] + B[0]
            ) / Math.PI * 180;
            if (ref === "previous" && !(previousTraceUid === trace.uid && d.i === previousI + 1)) {
              angle = null;
            }
          }
          if (ref === "previous" && !trace._geo) {
            if (previousTraceUid === trace.uid && d.i === previousI + 1 && isNumeric(x) && isNumeric(y)) {
              var dX = x - previousX;
              var dY = y - previousY;
              var shape = trace.line ? trace.line.shape || "" : "";
              var lastShapeChar = shape.slice(shape.length - 1);
              if (lastShapeChar === "h") dY = 0;
              if (lastShapeChar === "v") dX = 0;
              angle += atan2(dY, dX) / Math.PI * 180 + 90;
            } else {
              angle = null;
            }
          }
        }
        previousX = x;
        previousY = y;
        previousI = d.i;
        previousTraceUid = trace.uid;
        return angle;
      }
      drawing.getMarkerAngle = getMarkerAngle;
    }
  });

  // src/components/titles/index.js
  var require_titles = __commonJS({
    "src/components/titles/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Plots = require_plots();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Drawing = require_drawing();
      var Color = require_color();
      var svgTextUtils = require_svg_text_utils();
      var interactConstants = require_interactions();
      var OPPOSITE_SIDE = require_alignment().OPPOSITE_SIDE;
      var numStripRE = / [XY][0-9]* /;
      var SUBTITLE_PADDING_MATHJAX_EM = 1.6;
      var SUBTITLE_PADDING_EM = 1.6;
      function draw(gd, titleClass, options) {
        var fullLayout = gd._fullLayout;
        var cont = options.propContainer;
        var prop = options.propName;
        var placeholder = options.placeholder;
        var traceIndex = options.traceIndex;
        var avoid = options.avoid || {};
        var attributes = options.attributes;
        var transform = options.transform;
        var group = options.containerGroup;
        var opacity = 1;
        var title = cont.title;
        var txt = (title && title.text ? title.text : "").trim();
        var titleIsPlaceholder = false;
        var font = title && title.font ? title.font : {};
        var fontFamily = font.family;
        var fontSize = font.size;
        var fontColor = font.color;
        var fontWeight = font.weight;
        var fontStyle = font.style;
        var fontVariant = font.variant;
        var fontTextcase = font.textcase;
        var fontLineposition = font.lineposition;
        var fontShadow = font.shadow;
        var subtitleProp = options.subtitlePropName;
        var subtitleEnabled = !!subtitleProp;
        var subtitlePlaceholder = options.subtitlePlaceholder;
        var subtitle = (cont.title || {}).subtitle || { text: "", font: {} };
        var subtitleTxt = subtitle.text.trim();
        var subtitleIsPlaceholder = false;
        var subtitleOpacity = 1;
        var subtitleFont = subtitle.font;
        var subFontFamily = subtitleFont.family;
        var subFontSize = subtitleFont.size;
        var subFontColor = subtitleFont.color;
        var subFontWeight = subtitleFont.weight;
        var subFontStyle = subtitleFont.style;
        var subFontVariant = subtitleFont.variant;
        var subFontTextcase = subtitleFont.textcase;
        var subFontLineposition = subtitleFont.lineposition;
        var subFontShadow = subtitleFont.shadow;
        var editAttr;
        if (prop === "title.text") editAttr = "titleText";
        else if (prop.indexOf("axis") !== -1) editAttr = "axisTitleText";
        else if (prop.indexOf("colorbar" !== -1)) editAttr = "colorbarTitleText";
        var editable = gd._context.edits[editAttr];
        function matchesPlaceholder(text, placeholder2) {
          if (text === void 0 || placeholder2 === void 0) return false;
          return text.replace(numStripRE, " % ") === placeholder2.replace(numStripRE, " % ");
        }
        if (txt === "") opacity = 0;
        else if (matchesPlaceholder(txt, placeholder)) {
          if (!editable) txt = "";
          opacity = 0.2;
          titleIsPlaceholder = true;
        }
        if (subtitleEnabled) {
          if (subtitleTxt === "") subtitleOpacity = 0;
          else if (matchesPlaceholder(subtitleTxt, subtitlePlaceholder)) {
            if (!editable) subtitleTxt = "";
            subtitleOpacity = 0.2;
            subtitleIsPlaceholder = true;
          }
        }
        if (options._meta) {
          txt = Lib.templateString(txt, options._meta);
        } else if (fullLayout._meta) {
          txt = Lib.templateString(txt, fullLayout._meta);
        }
        var elShouldExist = txt || subtitleTxt || editable;
        var hColorbarMoveTitle;
        if (!group) {
          group = Lib.ensureSingle(fullLayout._infolayer, "g", "g-" + titleClass);
          hColorbarMoveTitle = fullLayout._hColorbarMoveTitle;
        }
        var el = group.selectAll("text." + titleClass).data(elShouldExist ? [0] : []);
        el.enter().append("text");
        el.text(txt).attr("class", titleClass);
        el.exit().remove();
        var subtitleEl = null;
        var subtitleClass = titleClass + "-subtitle";
        var subtitleElShouldExist = subtitleTxt || editable;
        if (subtitleEnabled && subtitleElShouldExist) {
          subtitleEl = group.selectAll("text." + subtitleClass).data(subtitleElShouldExist ? [0] : []);
          subtitleEl.enter().append("text");
          subtitleEl.text(subtitleTxt).attr("class", subtitleClass);
          subtitleEl.exit().remove();
        }
        if (!elShouldExist) return group;
        function titleLayout(titleEl, subtitleEl2) {
          Lib.syncOrAsync([drawTitle, scootTitle], { title: titleEl, subtitle: subtitleEl2 });
        }
        function drawTitle(titleAndSubtitleEls) {
          var titleEl = titleAndSubtitleEls.title;
          var subtitleEl2 = titleAndSubtitleEls.subtitle;
          var transformVal;
          if (!transform && hColorbarMoveTitle) {
            transform = {};
          }
          if (transform) {
            transformVal = "";
            if (transform.rotate) {
              transformVal += "rotate(" + [transform.rotate, attributes.x, attributes.y] + ")";
            }
            if (transform.offset || hColorbarMoveTitle) {
              transformVal += strTranslate(0, (transform.offset || 0) - (hColorbarMoveTitle || 0));
            }
          } else {
            transformVal = null;
          }
          titleEl.attr("transform", transformVal);
          function adjustSubtitlePosition(titleElMathGroup2) {
            if (!titleElMathGroup2) return;
            var subtitleElement = d3.select(titleElMathGroup2.node().parentNode).select("." + subtitleClass);
            if (!subtitleElement.empty()) {
              var titleElMathBbox2 = titleElMathGroup2.node().getBBox();
              if (titleElMathBbox2.height) {
                var subtitleY3 = titleElMathBbox2.y + titleElMathBbox2.height + SUBTITLE_PADDING_MATHJAX_EM * subFontSize;
                subtitleElement.attr("y", subtitleY3);
              }
            }
          }
          titleEl.style("opacity", opacity * Color.opacity(fontColor)).call(Drawing.font, {
            color: Color.rgb(fontColor),
            size: d3.round(fontSize, 2),
            family: fontFamily,
            weight: fontWeight,
            style: fontStyle,
            variant: fontVariant,
            textcase: fontTextcase,
            shadow: fontShadow,
            lineposition: fontLineposition
          }).attr(attributes).call(svgTextUtils.convertToTspans, gd, adjustSubtitlePosition);
          if (subtitleEl2) {
            var titleElMathGroup = group.select("." + titleClass + "-math-group");
            var titleElBbox2 = titleEl.node().getBBox();
            var titleElMathBbox = titleElMathGroup.node() ? titleElMathGroup.node().getBBox() : void 0;
            var subtitleY2 = titleElMathBbox ? titleElMathBbox.y + titleElMathBbox.height + SUBTITLE_PADDING_MATHJAX_EM * subFontSize : titleElBbox2.y + titleElBbox2.height + SUBTITLE_PADDING_EM * subFontSize;
            var subtitleAttributes = Lib.extendFlat({}, attributes, {
              y: subtitleY2
            });
            subtitleEl2.attr("transform", transformVal);
            subtitleEl2.style("opacity", subtitleOpacity * Color.opacity(subFontColor)).call(Drawing.font, {
              color: Color.rgb(subFontColor),
              size: d3.round(subFontSize, 2),
              family: subFontFamily,
              weight: subFontWeight,
              style: subFontStyle,
              variant: subFontVariant,
              textcase: subFontTextcase,
              shadow: subFontShadow,
              lineposition: subFontLineposition
            }).attr(subtitleAttributes).call(svgTextUtils.convertToTspans, gd);
          }
          return Plots.previousPromises(gd);
        }
        function scootTitle(titleAndSubtitleEls) {
          var titleElIn = titleAndSubtitleEls.title;
          var titleGroup = d3.select(titleElIn.node().parentNode);
          if (avoid && avoid.selection && avoid.side && txt) {
            titleGroup.attr("transform", null);
            var backside = OPPOSITE_SIDE[avoid.side];
            var shiftSign = avoid.side === "left" || avoid.side === "top" ? -1 : 1;
            var pad = isNumeric(avoid.pad) ? avoid.pad : 2;
            var titlebb = Drawing.bBox(titleGroup.node());
            var reservedMargins = { t: 0, b: 0, l: 0, r: 0 };
            var margins = gd._fullLayout._reservedMargin;
            for (var key in margins) {
              for (var side in margins[key]) {
                var val = margins[key][side];
                reservedMargins[side] = Math.max(reservedMargins[side], val);
              }
            }
            var paperbb = {
              left: reservedMargins.l,
              top: reservedMargins.t,
              right: fullLayout.width - reservedMargins.r,
              bottom: fullLayout.height - reservedMargins.b
            };
            var maxshift = avoid.maxShift || shiftSign * (paperbb[avoid.side] - titlebb[avoid.side]);
            var shift = 0;
            if (maxshift < 0) {
              shift = maxshift;
            } else {
              var offsetLeft = avoid.offsetLeft || 0;
              var offsetTop = avoid.offsetTop || 0;
              titlebb.left -= offsetLeft;
              titlebb.right -= offsetLeft;
              titlebb.top -= offsetTop;
              titlebb.bottom -= offsetTop;
              avoid.selection.each(function() {
                var avoidbb = Drawing.bBox(this);
                if (Lib.bBoxIntersect(titlebb, avoidbb, pad)) {
                  shift = Math.max(shift, shiftSign * (avoidbb[avoid.side] - titlebb[backside]) + pad);
                }
              });
              shift = Math.min(maxshift, shift);
              cont._titleScoot = Math.abs(shift);
            }
            if (shift > 0 || maxshift < 0) {
              var shiftTemplate = {
                left: [-shift, 0],
                right: [shift, 0],
                top: [0, -shift],
                bottom: [0, shift]
              }[avoid.side];
              titleGroup.attr("transform", strTranslate(shiftTemplate[0], shiftTemplate[1]));
            }
          }
        }
        el.call(titleLayout, subtitleEl);
        function setPlaceholder(element, placeholderText) {
          element.text(placeholderText).on("mouseover.opacity", function() {
            d3.select(this).transition().duration(interactConstants.SHOW_PLACEHOLDER).style("opacity", 1);
          }).on("mouseout.opacity", function() {
            d3.select(this).transition().duration(interactConstants.HIDE_PLACEHOLDER).style("opacity", 0);
          });
        }
        if (editable) {
          if (!txt) {
            setPlaceholder(el, placeholder);
            titleIsPlaceholder = true;
          } else el.on(".opacity", null);
          el.call(svgTextUtils.makeEditable, { gd }).on("edit", function(text) {
            if (traceIndex !== void 0) {
              Registry.call("_guiRestyle", gd, prop, text, traceIndex);
            } else {
              Registry.call("_guiRelayout", gd, prop, text);
            }
          }).on("cancel", function() {
            this.text(this.attr("data-unformatted")).call(titleLayout);
          }).on("input", function(d) {
            this.text(d || " ").call(svgTextUtils.positionText, attributes.x, attributes.y);
          });
          if (subtitleEnabled) {
            if (subtitleEnabled && !txt) {
              var titleElBbox = el.node().getBBox();
              var subtitleY = titleElBbox.y + titleElBbox.height + SUBTITLE_PADDING_EM * subFontSize;
              subtitleEl.attr("y", subtitleY);
            }
            if (!subtitleTxt) {
              setPlaceholder(subtitleEl, subtitlePlaceholder);
              subtitleIsPlaceholder = true;
            } else subtitleEl.on(".opacity", null);
            subtitleEl.call(svgTextUtils.makeEditable, { gd }).on("edit", function(text) {
              Registry.call("_guiRelayout", gd, "title.subtitle.text", text);
            }).on("cancel", function() {
              this.text(this.attr("data-unformatted")).call(titleLayout);
            }).on("input", function(d) {
              this.text(d || " ").call(svgTextUtils.positionText, subtitleEl.attr("x"), subtitleEl.attr("y"));
            });
          }
        }
        el.classed("js-placeholder", titleIsPlaceholder);
        if (subtitleEl) subtitleEl.classed("js-placeholder", subtitleIsPlaceholder);
        return group;
      }
      module.exports = {
        draw,
        SUBTITLE_PADDING_EM,
        SUBTITLE_PADDING_MATHJAX_EM
      };
    }
  });

  // src/plots/cartesian/set_convert.js
  var require_set_convert = __commonJS({
    "src/plots/cartesian/set_convert.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var utcFormat = require_d3_time_format().utcFormat;
      var Lib = require_lib();
      var numberFormat = Lib.numberFormat;
      var isNumeric = require_fast_isnumeric();
      var cleanNumber = Lib.cleanNumber;
      var ms2DateTime = Lib.ms2DateTime;
      var dateTime2ms = Lib.dateTime2ms;
      var ensureNumber = Lib.ensureNumber;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var numConstants = require_numerical();
      var FP_SAFE = numConstants.FP_SAFE;
      var BADNUM = numConstants.BADNUM;
      var LOG_CLIP = numConstants.LOG_CLIP;
      var ONEWEEK = numConstants.ONEWEEK;
      var ONEDAY = numConstants.ONEDAY;
      var ONEHOUR = numConstants.ONEHOUR;
      var ONEMIN = numConstants.ONEMIN;
      var ONESEC = numConstants.ONESEC;
      var axisIds = require_axis_ids();
      var constants = require_constants2();
      var HOUR_PATTERN = constants.HOUR_PATTERN;
      var WEEKDAY_PATTERN = constants.WEEKDAY_PATTERN;
      function fromLog(v) {
        return Math.pow(10, v);
      }
      function isValidCategory(v) {
        return v !== null && v !== void 0;
      }
      module.exports = function setConvert(ax, fullLayout) {
        fullLayout = fullLayout || {};
        var axId = ax._id || "x";
        var axLetter = axId.charAt(0);
        function toLog(v, clip) {
          if (v > 0) return Math.log(v) / Math.LN10;
          else if (v <= 0 && clip && ax.range && ax.range.length === 2) {
            var r0 = ax.range[0];
            var r1 = ax.range[1];
            return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));
          } else return BADNUM;
        }
        function dt2ms(v, _, calendar, opts) {
          if ((opts || {}).msUTC && isNumeric(v)) {
            return +v;
          }
          var ms = dateTime2ms(v, calendar || ax.calendar);
          if (ms === BADNUM) {
            if (isNumeric(v)) {
              v = +v;
              var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);
              var msRounded = Math.round(v - msecTenths / 10);
              ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;
            } else return BADNUM;
          }
          return ms;
        }
        function ms2dt(v, r, calendar) {
          return ms2DateTime(v, r, calendar || ax.calendar);
        }
        function getCategoryName(v) {
          return ax._categories[Math.round(v)];
        }
        function setCategoryIndex(v) {
          if (isValidCategory(v)) {
            if (ax._categoriesMap === void 0) {
              ax._categoriesMap = {};
            }
            if (ax._categoriesMap[v] !== void 0) {
              return ax._categoriesMap[v];
            } else {
              ax._categories.push(typeof v === "number" ? String(v) : v);
              var curLength = ax._categories.length - 1;
              ax._categoriesMap[v] = curLength;
              return curLength;
            }
          }
          return BADNUM;
        }
        function setMultiCategoryIndex(arrayIn, len) {
          var arrayOut = new Array(len);
          for (var i = 0; i < len; i++) {
            var v0 = (arrayIn[0] || [])[i];
            var v1 = (arrayIn[1] || [])[i];
            arrayOut[i] = getCategoryIndex([v0, v1]);
          }
          return arrayOut;
        }
        function getCategoryIndex(v) {
          if (ax._categoriesMap) {
            return ax._categoriesMap[v];
          }
        }
        function getCategoryPosition(v) {
          var index = getCategoryIndex(v);
          if (index !== void 0) return index;
          if (isNumeric(v)) return +v;
        }
        function getRangePosition(v) {
          return isNumeric(v) ? +v : getCategoryIndex(v);
        }
        function _l2p(v, m, b) {
          return d3.round(b + m * v, 2);
        }
        function _p2l(px, m, b) {
          return (px - b) / m;
        }
        var l2p = function l2p2(v) {
          if (!isNumeric(v)) return BADNUM;
          return _l2p(v, ax._m, ax._b);
        };
        var p2l = function(px) {
          return _p2l(px, ax._m, ax._b);
        };
        if (ax.rangebreaks) {
          var isY = axLetter === "y";
          l2p = function(v) {
            if (!isNumeric(v)) return BADNUM;
            var len = ax._rangebreaks.length;
            if (!len) return _l2p(v, ax._m, ax._b);
            var flip = isY;
            if (ax.range[0] > ax.range[1]) flip = !flip;
            var signAx = flip ? -1 : 1;
            var pos = signAx * v;
            var q = 0;
            for (var i = 0; i < len; i++) {
              var min = signAx * ax._rangebreaks[i].min;
              var max = signAx * ax._rangebreaks[i].max;
              if (pos < min) break;
              if (pos > max) q = i + 1;
              else {
                q = pos < (min + max) / 2 ? i : i + 1;
                break;
              }
            }
            var b2 = ax._B[q] || 0;
            if (!isFinite(b2)) return 0;
            return _l2p(v, ax._m2, b2);
          };
          p2l = function(px) {
            var len = ax._rangebreaks.length;
            if (!len) return _p2l(px, ax._m, ax._b);
            var q = 0;
            for (var i = 0; i < len; i++) {
              if (px < ax._rangebreaks[i].pmin) break;
              if (px > ax._rangebreaks[i].pmax) q = i + 1;
            }
            return _p2l(px, ax._m2, ax._B[q]);
          };
        }
        ax.c2l = ax.type === "log" ? toLog : ensureNumber;
        ax.l2c = ax.type === "log" ? fromLog : ensureNumber;
        ax.l2p = l2p;
        ax.p2l = p2l;
        ax.c2p = ax.type === "log" ? function(v, clip) {
          return l2p(toLog(v, clip));
        } : l2p;
        ax.p2c = ax.type === "log" ? function(px) {
          return fromLog(p2l(px));
        } : p2l;
        if (["linear", "-"].indexOf(ax.type) !== -1) {
          ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;
          ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;
          ax.d2p = ax.r2p = function(v) {
            return ax.l2p(cleanNumber(v));
          };
          ax.p2d = ax.p2r = p2l;
          ax.cleanPos = ensureNumber;
        } else if (ax.type === "log") {
          ax.d2r = ax.d2l = function(v, clip) {
            return toLog(cleanNumber(v), clip);
          };
          ax.r2d = ax.r2c = function(v) {
            return fromLog(cleanNumber(v));
          };
          ax.d2c = ax.r2l = cleanNumber;
          ax.c2d = ax.l2r = ensureNumber;
          ax.c2r = toLog;
          ax.l2d = fromLog;
          ax.d2p = function(v, clip) {
            return ax.l2p(ax.d2r(v, clip));
          };
          ax.p2d = function(px) {
            return fromLog(p2l(px));
          };
          ax.r2p = function(v) {
            return ax.l2p(cleanNumber(v));
          };
          ax.p2r = p2l;
          ax.cleanPos = ensureNumber;
        } else if (ax.type === "date") {
          ax.d2r = ax.r2d = Lib.identity;
          ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;
          ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;
          ax.d2p = ax.r2p = function(v, _, calendar) {
            return ax.l2p(dt2ms(v, 0, calendar));
          };
          ax.p2d = ax.p2r = function(px, r, calendar) {
            return ms2dt(p2l(px), r, calendar);
          };
          ax.cleanPos = function(v) {
            return Lib.cleanDate(v, BADNUM, ax.calendar);
          };
        } else if (ax.type === "category") {
          ax.d2c = ax.d2l = setCategoryIndex;
          ax.r2d = ax.c2d = ax.l2d = getCategoryName;
          ax.d2r = ax.d2l_noadd = getCategoryPosition;
          ax.r2c = function(v) {
            var index = getRangePosition(v);
            return index !== void 0 ? index : ax.fraction2r(0.5);
          };
          ax.l2r = ax.c2r = ensureNumber;
          ax.r2l = getRangePosition;
          ax.d2p = function(v) {
            return ax.l2p(ax.r2c(v));
          };
          ax.p2d = function(px) {
            return getCategoryName(p2l(px));
          };
          ax.r2p = ax.d2p;
          ax.p2r = p2l;
          ax.cleanPos = function(v) {
            if (typeof v === "string" && v !== "") return v;
            return ensureNumber(v);
          };
        } else if (ax.type === "multicategory") {
          ax.r2d = ax.c2d = ax.l2d = getCategoryName;
          ax.d2r = ax.d2l_noadd = getCategoryPosition;
          ax.r2c = function(v) {
            var index = getCategoryPosition(v);
            return index !== void 0 ? index : ax.fraction2r(0.5);
          };
          ax.r2c_just_indices = getCategoryIndex;
          ax.l2r = ax.c2r = ensureNumber;
          ax.r2l = getCategoryPosition;
          ax.d2p = function(v) {
            return ax.l2p(ax.r2c(v));
          };
          ax.p2d = function(px) {
            return getCategoryName(p2l(px));
          };
          ax.r2p = ax.d2p;
          ax.p2r = p2l;
          ax.cleanPos = function(v) {
            if (Array.isArray(v) || typeof v === "string" && v !== "") return v;
            return ensureNumber(v);
          };
          ax.setupMultiCategory = function(fullData) {
            var traceIndices = ax._traceIndices;
            var i, j;
            var group = ax._matchGroup;
            if (group && ax._categories.length === 0) {
              for (var axId2 in group) {
                if (axId2 !== axId) {
                  var ax2 = fullLayout[axisIds.id2name(axId2)];
                  traceIndices = traceIndices.concat(ax2._traceIndices);
                }
              }
            }
            var seen = [[0, {}], [0, {}]];
            var list = [];
            for (i = 0; i < traceIndices.length; i++) {
              var trace = fullData[traceIndices[i]];
              if (axLetter in trace) {
                var arrayIn = trace[axLetter];
                var len = trace._length || Lib.minRowLength(arrayIn);
                if (isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {
                  for (j = 0; j < len; j++) {
                    var v0 = arrayIn[0][j];
                    var v1 = arrayIn[1][j];
                    if (isValidCategory(v0) && isValidCategory(v1)) {
                      list.push([v0, v1]);
                      if (!(v0 in seen[0][1])) {
                        seen[0][1][v0] = seen[0][0]++;
                      }
                      if (!(v1 in seen[1][1])) {
                        seen[1][1][v1] = seen[1][0]++;
                      }
                    }
                  }
                }
              }
            }
            list.sort(function(a, b) {
              var ind0 = seen[0][1];
              var d = ind0[a[0]] - ind0[b[0]];
              if (d) return d;
              var ind1 = seen[1][1];
              return ind1[a[1]] - ind1[b[1]];
            });
            for (i = 0; i < list.length; i++) {
              setCategoryIndex(list[i]);
            }
          };
        }
        ax.fraction2r = function(v) {
          var rl0 = ax.r2l(ax.range[0]);
          var rl1 = ax.r2l(ax.range[1]);
          return ax.l2r(rl0 + v * (rl1 - rl0));
        };
        ax.r2fraction = function(v) {
          var rl0 = ax.r2l(ax.range[0]);
          var rl1 = ax.r2l(ax.range[1]);
          return (ax.r2l(v) - rl0) / (rl1 - rl0);
        };
        ax.limitRange = function(rangeAttr) {
          var minallowed = ax.minallowed;
          var maxallowed = ax.maxallowed;
          if (minallowed === void 0 && maxallowed === void 0) return;
          if (!rangeAttr) rangeAttr = "range";
          var range = Lib.nestedProperty(ax, rangeAttr).get();
          var rng = Lib.simpleMap(range, ax.r2l);
          var axrev = rng[1] < rng[0];
          if (axrev) rng.reverse();
          var bounds = Lib.simpleMap([minallowed, maxallowed], ax.r2l);
          if (minallowed !== void 0 && rng[0] < bounds[0]) range[axrev ? 1 : 0] = minallowed;
          if (maxallowed !== void 0 && rng[1] > bounds[1]) range[axrev ? 0 : 1] = maxallowed;
          if (range[0] === range[1]) {
            var minL = ax.l2r(minallowed);
            var maxL = ax.l2r(maxallowed);
            if (minallowed !== void 0) {
              var _max = minL + 1;
              if (maxallowed !== void 0) _max = Math.min(_max, maxL);
              range[axrev ? 1 : 0] = _max;
            }
            if (maxallowed !== void 0) {
              var _min = maxL + 1;
              if (minallowed !== void 0) _min = Math.max(_min, minL);
              range[axrev ? 0 : 1] = _min;
            }
          }
        };
        ax.cleanRange = function(rangeAttr, opts) {
          ax._cleanRange(rangeAttr, opts);
          ax.limitRange(rangeAttr);
        };
        ax._cleanRange = function(rangeAttr, opts) {
          if (!opts) opts = {};
          if (!rangeAttr) rangeAttr = "range";
          var range = Lib.nestedProperty(ax, rangeAttr).get();
          var i, dflt;
          if (ax.type === "date") dflt = Lib.dfltRange(ax.calendar);
          else if (axLetter === "y") dflt = constants.DFLTRANGEY;
          else if (ax._name === "realaxis") dflt = [0, 1];
          else dflt = opts.dfltRange || constants.DFLTRANGEX;
          dflt = dflt.slice();
          if (ax.rangemode === "tozero" || ax.rangemode === "nonnegative") {
            dflt[0] = 0;
          }
          if (!range || range.length !== 2) {
            Lib.nestedProperty(ax, rangeAttr).set(dflt);
            return;
          }
          var nullRange0 = range[0] === null;
          var nullRange1 = range[1] === null;
          if (ax.type === "date" && !ax.autorange) {
            range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);
            range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);
          }
          for (i = 0; i < 2; i++) {
            if (ax.type === "date") {
              if (!Lib.isDateTime(range[i], ax.calendar)) {
                ax[rangeAttr] = dflt;
                break;
              }
              if (ax.r2l(range[0]) === ax.r2l(range[1])) {
                var linCenter = Lib.constrain(
                  ax.r2l(range[0]),
                  Lib.MIN_MS + 1e3,
                  Lib.MAX_MS - 1e3
                );
                range[0] = ax.l2r(linCenter - 1e3);
                range[1] = ax.l2r(linCenter + 1e3);
                break;
              }
            } else {
              if (!isNumeric(range[i])) {
                if (!(nullRange0 || nullRange1) && isNumeric(range[1 - i])) {
                  range[i] = range[1 - i] * (i ? 10 : 0.1);
                } else {
                  ax[rangeAttr] = dflt;
                  break;
                }
              }
              if (range[i] < -FP_SAFE) range[i] = -FP_SAFE;
              else if (range[i] > FP_SAFE) range[i] = FP_SAFE;
              if (range[0] === range[1]) {
                var inc = Math.max(1, Math.abs(range[0] * 1e-6));
                range[0] -= inc;
                range[1] += inc;
              }
            }
          }
        };
        ax.setScale = function(usePrivateRange) {
          var gs = fullLayout._size;
          if (ax.overlaying) {
            var ax2 = axisIds.getFromId({ _fullLayout: fullLayout }, ax.overlaying);
            ax.domain = ax2.domain;
          }
          var rangeAttr = usePrivateRange && ax._r ? "_r" : "range";
          var calendar = ax.calendar;
          ax.cleanRange(rangeAttr);
          var rl0 = ax.r2l(ax[rangeAttr][0], calendar);
          var rl1 = ax.r2l(ax[rangeAttr][1], calendar);
          var isY2 = axLetter === "y";
          if (isY2) {
            ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;
            ax._length = gs.h * (ax.domain[1] - ax.domain[0]);
            ax._m = ax._length / (rl0 - rl1);
            ax._b = -ax._m * rl1;
          } else {
            ax._offset = gs.l + ax.domain[0] * gs.w;
            ax._length = gs.w * (ax.domain[1] - ax.domain[0]);
            ax._m = ax._length / (rl1 - rl0);
            ax._b = -ax._m * rl0;
          }
          ax._rangebreaks = [];
          ax._lBreaks = 0;
          ax._m2 = 0;
          ax._B = [];
          if (ax.rangebreaks) {
            var i, brk;
            ax._rangebreaks = ax.locateBreaks(
              Math.min(rl0, rl1),
              Math.max(rl0, rl1)
            );
            if (ax._rangebreaks.length) {
              for (i = 0; i < ax._rangebreaks.length; i++) {
                brk = ax._rangebreaks[i];
                ax._lBreaks += Math.abs(brk.max - brk.min);
              }
              var flip = isY2;
              if (rl0 > rl1) flip = !flip;
              if (flip) ax._rangebreaks.reverse();
              var sign = flip ? -1 : 1;
              ax._m2 = sign * ax._length / (Math.abs(rl1 - rl0) - ax._lBreaks);
              ax._B.push(-ax._m2 * (isY2 ? rl1 : rl0));
              for (i = 0; i < ax._rangebreaks.length; i++) {
                brk = ax._rangebreaks[i];
                ax._B.push(
                  ax._B[ax._B.length - 1] - sign * ax._m2 * (brk.max - brk.min)
                );
              }
              for (i = 0; i < ax._rangebreaks.length; i++) {
                brk = ax._rangebreaks[i];
                brk.pmin = l2p(brk.min);
                brk.pmax = l2p(brk.max);
              }
            }
          }
          if (!isFinite(ax._m) || !isFinite(ax._b) || ax._length < 0) {
            fullLayout._replotting = false;
            throw new Error("Something went wrong with axis scaling");
          }
        };
        ax.maskBreaks = function(v) {
          var rangebreaksIn = ax.rangebreaks || [];
          var bnds, b0, b1, vb, vDate;
          if (!rangebreaksIn._cachedPatterns) {
            rangebreaksIn._cachedPatterns = rangebreaksIn.map(function(brk2) {
              return brk2.enabled && brk2.bounds ? Lib.simpleMap(
                brk2.bounds,
                brk2.pattern ? cleanNumber : ax.d2c
                // case of pattern: ''
              ) : null;
            });
          }
          if (!rangebreaksIn._cachedValues) {
            rangebreaksIn._cachedValues = rangebreaksIn.map(function(brk2) {
              return brk2.enabled && brk2.values ? Lib.simpleMap(brk2.values, ax.d2c).sort(Lib.sorterAsc) : null;
            });
          }
          for (var i = 0; i < rangebreaksIn.length; i++) {
            var brk = rangebreaksIn[i];
            if (brk.enabled) {
              if (brk.bounds) {
                var pattern = brk.pattern;
                bnds = rangebreaksIn._cachedPatterns[i];
                b0 = bnds[0];
                b1 = bnds[1];
                switch (pattern) {
                  case WEEKDAY_PATTERN:
                    vDate = new Date(v);
                    vb = vDate.getUTCDay();
                    if (b0 > b1) {
                      b1 += 7;
                      if (vb < b0) vb += 7;
                    }
                    break;
                  case HOUR_PATTERN:
                    vDate = new Date(v);
                    var hours = vDate.getUTCHours();
                    var minutes = vDate.getUTCMinutes();
                    var seconds = vDate.getUTCSeconds();
                    var milliseconds = vDate.getUTCMilliseconds();
                    vb = hours + (minutes / 60 + seconds / 3600 + milliseconds / 36e5);
                    if (b0 > b1) {
                      b1 += 24;
                      if (vb < b0) vb += 24;
                    }
                    break;
                  case "":
                    vb = v;
                    break;
                }
                if (vb >= b0 && vb < b1) return BADNUM;
              } else {
                var vals = rangebreaksIn._cachedValues[i];
                for (var j = 0; j < vals.length; j++) {
                  b0 = vals[j];
                  b1 = b0 + brk.dvalue;
                  if (v >= b0 && v < b1) return BADNUM;
                }
              }
            }
          }
          return v;
        };
        ax.locateBreaks = function(r0, r1) {
          var i, bnds, b0, b1;
          var rangebreaksOut = [];
          if (!ax.rangebreaks) return rangebreaksOut;
          var rangebreaksIn = ax.rangebreaks.slice().sort(function(a, b) {
            if (a.pattern === WEEKDAY_PATTERN && b.pattern === HOUR_PATTERN) return -1;
            if (b.pattern === WEEKDAY_PATTERN && a.pattern === HOUR_PATTERN) return 1;
            return 0;
          });
          var addBreak = function(min, max) {
            min = Lib.constrain(min, r0, r1);
            max = Lib.constrain(max, r0, r1);
            if (min === max) return;
            var isNewBreak = true;
            for (var j2 = 0; j2 < rangebreaksOut.length; j2++) {
              var brkj = rangebreaksOut[j2];
              if (min < brkj.max && max >= brkj.min) {
                if (min < brkj.min) {
                  brkj.min = min;
                }
                if (max > brkj.max) {
                  brkj.max = max;
                }
                isNewBreak = false;
              }
            }
            if (isNewBreak) {
              rangebreaksOut.push({ min, max });
            }
          };
          for (i = 0; i < rangebreaksIn.length; i++) {
            var brk = rangebreaksIn[i];
            if (brk.enabled) {
              if (brk.bounds) {
                var t0 = r0;
                var t1 = r1;
                if (brk.pattern) {
                  t0 = Math.floor(t0);
                }
                bnds = Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.r2l);
                b0 = bnds[0];
                b1 = bnds[1];
                var t0Date = new Date(t0);
                var bndDelta;
                var step;
                switch (brk.pattern) {
                  case WEEKDAY_PATTERN:
                    step = ONEWEEK;
                    bndDelta = ((b1 < b0 ? 7 : 0) + (b1 - b0)) * ONEDAY;
                    t0 += b0 * ONEDAY - (t0Date.getUTCDay() * ONEDAY + t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());
                    break;
                  case HOUR_PATTERN:
                    step = ONEDAY;
                    bndDelta = ((b1 < b0 ? 24 : 0) + (b1 - b0)) * ONEHOUR;
                    t0 += b0 * ONEHOUR - (t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());
                    break;
                  default:
                    t0 = Math.min(bnds[0], bnds[1]);
                    t1 = Math.max(bnds[0], bnds[1]);
                    step = t1 - t0;
                    bndDelta = step;
                }
                for (var t = t0; t < t1; t += step) {
                  addBreak(t, t + bndDelta);
                }
              } else {
                var vals = Lib.simpleMap(brk.values, ax.d2c);
                for (var j = 0; j < vals.length; j++) {
                  b0 = vals[j];
                  b1 = b0 + brk.dvalue;
                  addBreak(b0, b1);
                }
              }
            }
          }
          rangebreaksOut.sort(function(a, b) {
            return a.min - b.min;
          });
          return rangebreaksOut;
        };
        ax.makeCalcdata = function(trace, axLetter2, opts) {
          var arrayIn, arrayOut, i, len;
          var axType = ax.type;
          var cal = axType === "date" && trace[axLetter2 + "calendar"];
          if (axLetter2 in trace) {
            arrayIn = trace[axLetter2];
            len = trace._length || Lib.minRowLength(arrayIn);
            if (Lib.isTypedArray(arrayIn) && (axType === "linear" || axType === "log")) {
              if (len === arrayIn.length) {
                return arrayIn;
              } else if (arrayIn.subarray) {
                return arrayIn.subarray(0, len);
              }
            }
            if (axType === "multicategory") {
              return setMultiCategoryIndex(arrayIn, len);
            }
            arrayOut = new Array(len);
            for (i = 0; i < len; i++) {
              arrayOut[i] = ax.d2c(arrayIn[i], 0, cal, opts);
            }
          } else {
            var v0 = axLetter2 + "0" in trace ? ax.d2c(trace[axLetter2 + "0"], 0, cal) : 0;
            var dv = trace["d" + axLetter2] ? Number(trace["d" + axLetter2]) : 1;
            arrayIn = trace[{ x: "y", y: "x" }[axLetter2]];
            len = trace._length || arrayIn.length;
            arrayOut = new Array(len);
            for (i = 0; i < len; i++) {
              arrayOut[i] = v0 + i * dv;
            }
          }
          if (ax.rangebreaks) {
            for (i = 0; i < len; i++) {
              arrayOut[i] = ax.maskBreaks(arrayOut[i]);
            }
          }
          return arrayOut;
        };
        ax.isValidRange = function(range, nullOk) {
          return Array.isArray(range) && range.length === 2 && (nullOk && range[0] === null || isNumeric(ax.r2l(range[0]))) && (nullOk && range[1] === null || isNumeric(ax.r2l(range[1])));
        };
        ax.getAutorangeDflt = function(range, options) {
          var autorangeDflt = !ax.isValidRange(range, "nullOk");
          if (autorangeDflt && options && options.reverseDflt) autorangeDflt = "reversed";
          else if (range) {
            if (range[0] === null && range[1] === null) {
              autorangeDflt = true;
            } else if (range[0] === null && range[1] !== null) {
              autorangeDflt = "min";
            } else if (range[0] !== null && range[1] === null) {
              autorangeDflt = "max";
            }
          }
          return autorangeDflt;
        };
        ax.isReversed = function() {
          var autorange = ax.autorange;
          return autorange === "reversed" || autorange === "min reversed" || autorange === "max reversed";
        };
        ax.isPtWithinRange = function(d, calendar) {
          var coord = ax.c2l(d[axLetter], null, calendar);
          var r0 = ax.r2l(ax.range[0]);
          var r1 = ax.r2l(ax.range[1]);
          if (r0 < r1) {
            return r0 <= coord && coord <= r1;
          } else {
            return r1 <= coord && coord <= r0;
          }
        };
        ax._emptyCategories = function() {
          ax._categories = [];
          ax._categoriesMap = {};
        };
        ax.clearCalc = function() {
          var group = ax._matchGroup;
          if (group) {
            var categories = null;
            var categoriesMap = null;
            for (var axId2 in group) {
              var ax2 = fullLayout[axisIds.id2name(axId2)];
              if (ax2._categories) {
                categories = ax2._categories;
                categoriesMap = ax2._categoriesMap;
                break;
              }
            }
            if (categories && categoriesMap) {
              ax._categories = categories;
              ax._categoriesMap = categoriesMap;
            } else {
              ax._emptyCategories();
            }
          } else {
            ax._emptyCategories();
          }
          if (ax._initialCategories) {
            for (var j = 0; j < ax._initialCategories.length; j++) {
              setCategoryIndex(ax._initialCategories[j]);
            }
          }
        };
        ax.sortByInitialCategories = function() {
          var affectedTraces = [];
          ax._emptyCategories();
          if (ax._initialCategories) {
            for (var j = 0; j < ax._initialCategories.length; j++) {
              setCategoryIndex(ax._initialCategories[j]);
            }
          }
          affectedTraces = affectedTraces.concat(ax._traceIndices);
          var group = ax._matchGroup;
          for (var axId2 in group) {
            if (axId === axId2) continue;
            var ax2 = fullLayout[axisIds.id2name(axId2)];
            ax2._categories = ax._categories;
            ax2._categoriesMap = ax._categoriesMap;
            affectedTraces = affectedTraces.concat(ax2._traceIndices);
          }
          return affectedTraces;
        };
        var locale = fullLayout._d3locale;
        if (ax.type === "date") {
          ax._dateFormat = locale ? locale.timeFormat : utcFormat;
          ax._extraFormat = fullLayout._extraFormat;
        }
        ax._separators = fullLayout.separators;
        ax._numFormat = locale ? locale.numberFormat : numberFormat;
        delete ax._minDtick;
        delete ax._forceTick0;
      };
    }
  });

  // src/plots/cartesian/axis_autotype.js
  var require_axis_autotype = __commonJS({
    "src/plots/cartesian/axis_autotype.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var BADNUM = require_numerical().BADNUM;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var isDateTime = Lib.isDateTime;
      var cleanNumber = Lib.cleanNumber;
      var round = Math.round;
      module.exports = function autoType(array, calendar, opts) {
        var a = array;
        var noMultiCategory = opts.noMultiCategory;
        if (isArrayOrTypedArray(a) && !a.length) return "-";
        if (!noMultiCategory && multiCategory(a)) return "multicategory";
        if (noMultiCategory && Array.isArray(a[0])) {
          var b = [];
          for (var i = 0; i < a.length; i++) {
            if (isArrayOrTypedArray(a[i])) {
              for (var j = 0; j < a[i].length; j++) {
                b.push(a[i][j]);
              }
            }
          }
          a = b;
        }
        if (moreDates(a, calendar)) return "date";
        var convertNumeric = opts.autotypenumbers !== "strict";
        if (category(a, convertNumeric)) return "category";
        if (linearOK(a, convertNumeric)) return "linear";
        return "-";
      };
      function hasTypeNumber(v, convertNumeric) {
        return convertNumeric ? isNumeric(v) : typeof v === "number";
      }
      function linearOK(a, convertNumeric) {
        var len = a.length;
        for (var i = 0; i < len; i++) {
          if (hasTypeNumber(a[i], convertNumeric)) return true;
        }
        return false;
      }
      function moreDates(a, calendar) {
        var len = a.length;
        var inc = getIncrement(len);
        var dats = 0;
        var nums = 0;
        var seen = {};
        for (var f = 0; f < len; f += inc) {
          var i = round(f);
          var ai = a[i];
          var stri = String(ai);
          if (seen[stri]) continue;
          seen[stri] = 1;
          if (isDateTime(ai, calendar)) dats++;
          if (isNumeric(ai)) nums++;
        }
        return dats > nums * 2;
      }
      function getIncrement(len) {
        return Math.max(1, (len - 1) / 1e3);
      }
      function category(a, convertNumeric) {
        var len = a.length;
        var inc = getIncrement(len);
        var nums = 0;
        var cats = 0;
        var seen = {};
        for (var f = 0; f < len; f += inc) {
          var i = round(f);
          var ai = a[i];
          var stri = String(ai);
          if (seen[stri]) continue;
          seen[stri] = 1;
          var t = typeof ai;
          if (t === "boolean") cats++;
          else if (convertNumeric ? cleanNumber(ai) !== BADNUM : t === "number") nums++;
          else if (t === "string") cats++;
        }
        return cats > nums * 2;
      }
      function multiCategory(a) {
        return isArrayOrTypedArray(a[0]) && isArrayOrTypedArray(a[1]);
      }
    }
  });

  // src/plots/cartesian/autorange.js
  var require_autorange = __commonJS({
    "src/plots/cartesian/autorange.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var FP_SAFE = require_numerical().FP_SAFE;
      var Registry = require_registry();
      var Drawing = require_drawing();
      var axIds = require_axis_ids();
      var getFromId = axIds.getFromId;
      var isLinked = axIds.isLinked;
      module.exports = {
        applyAutorangeOptions,
        getAutoRange,
        makePadFn,
        doAutoRange,
        findExtremes,
        concatExtremes
      };
      function getAutoRange(gd, ax) {
        var i, j;
        var newRange = [];
        var fullLayout = gd._fullLayout;
        var getPadMin = makePadFn(fullLayout, ax, 0);
        var getPadMax = makePadFn(fullLayout, ax, 1);
        var extremes = concatExtremes(gd, ax);
        var minArray = extremes.min;
        var maxArray = extremes.max;
        if (minArray.length === 0 || maxArray.length === 0) {
          return Lib.simpleMap(ax.range, ax.r2l);
        }
        var minmin = minArray[0].val;
        var maxmax = maxArray[0].val;
        for (i = 1; i < minArray.length; i++) {
          if (minmin !== maxmax) break;
          minmin = Math.min(minmin, minArray[i].val);
        }
        for (i = 1; i < maxArray.length; i++) {
          if (minmin !== maxmax) break;
          maxmax = Math.max(maxmax, maxArray[i].val);
        }
        var autorange = ax.autorange;
        var axReverse = autorange === "reversed" || autorange === "min reversed" || autorange === "max reversed";
        if (!axReverse && ax.range) {
          var rng = Lib.simpleMap(ax.range, ax.r2l);
          axReverse = rng[1] < rng[0];
        }
        if (ax.autorange === "reversed") {
          ax.autorange = true;
        }
        var rangeMode = ax.rangemode;
        var toZero = rangeMode === "tozero";
        var nonNegative = rangeMode === "nonnegative";
        var axLen = ax._length;
        var minSpan = axLen / 10;
        var mbest = 0;
        var minpt, maxpt, minbest, maxbest, dp, dv;
        for (i = 0; i < minArray.length; i++) {
          minpt = minArray[i];
          for (j = 0; j < maxArray.length; j++) {
            maxpt = maxArray[j];
            dv = maxpt.val - minpt.val - calcBreaksLength(ax, minpt.val, maxpt.val);
            if (dv > 0) {
              dp = axLen - getPadMin(minpt) - getPadMax(maxpt);
              if (dp > minSpan) {
                if (dv / dp > mbest) {
                  minbest = minpt;
                  maxbest = maxpt;
                  mbest = dv / dp;
                }
              } else if (dv / axLen > mbest) {
                minbest = { val: minpt.val, nopad: 1 };
                maxbest = { val: maxpt.val, nopad: 1 };
                mbest = dv / axLen;
              }
            }
          }
        }
        function maximumPad(prev, pt) {
          return Math.max(prev, getPadMax(pt));
        }
        if (minmin === maxmax) {
          var lower = minmin - 1;
          var upper = minmin + 1;
          if (toZero) {
            if (minmin === 0) {
              newRange = [0, 1];
            } else {
              var maxPad = (minmin > 0 ? maxArray : minArray).reduce(maximumPad, 0);
              var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));
              newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];
            }
          } else if (nonNegative) {
            newRange = [Math.max(0, lower), Math.max(1, upper)];
          } else {
            newRange = [lower, upper];
          }
        } else {
          if (toZero) {
            if (minbest.val >= 0) {
              minbest = { val: 0, nopad: 1 };
            }
            if (maxbest.val <= 0) {
              maxbest = { val: 0, nopad: 1 };
            }
          } else if (nonNegative) {
            if (minbest.val - mbest * getPadMin(minbest) < 0) {
              minbest = { val: 0, nopad: 1 };
            }
            if (maxbest.val <= 0) {
              maxbest = { val: 1, nopad: 1 };
            }
          }
          mbest = (maxbest.val - minbest.val - calcBreaksLength(ax, minpt.val, maxpt.val)) / (axLen - getPadMin(minbest) - getPadMax(maxbest));
          newRange = [
            minbest.val - mbest * getPadMin(minbest),
            maxbest.val + mbest * getPadMax(maxbest)
          ];
        }
        newRange = applyAutorangeOptions(newRange, ax);
        if (ax.limitRange) ax.limitRange();
        if (axReverse) newRange.reverse();
        return Lib.simpleMap(newRange, ax.l2r || Number);
      }
      function calcBreaksLength(ax, v0, v1) {
        var lBreaks = 0;
        if (ax.rangebreaks) {
          var rangebreaksOut = ax.locateBreaks(v0, v1);
          for (var i = 0; i < rangebreaksOut.length; i++) {
            var brk = rangebreaksOut[i];
            lBreaks += brk.max - brk.min;
          }
        }
        return lBreaks;
      }
      function makePadFn(fullLayout, ax, max) {
        var extrappad = 0.05 * ax._length;
        var anchorAxis = ax._anchorAxis || {};
        if ((ax.ticklabelposition || "").indexOf("inside") !== -1 || (anchorAxis.ticklabelposition || "").indexOf("inside") !== -1) {
          var axReverse = ax.isReversed();
          if (!axReverse) {
            var rng = Lib.simpleMap(ax.range, ax.r2l);
            axReverse = rng[1] < rng[0];
          }
          if (axReverse) max = !max;
        }
        var zero = 0;
        if (!isLinked(fullLayout, ax._id)) {
          zero = padInsideLabelsOnAnchorAxis(fullLayout, ax, max);
        }
        extrappad = Math.max(zero, extrappad);
        if (ax.constrain === "domain" && ax._inputDomain) {
          extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) / (ax.domain[1] - ax.domain[0]);
        }
        return function getPad(pt) {
          if (pt.nopad) return 0;
          return pt.pad + (pt.extrapad ? extrappad : zero);
        };
      }
      var TEXTPAD = 3;
      function padInsideLabelsOnAnchorAxis(fullLayout, ax, max) {
        var pad = 0;
        var isX = ax._id.charAt(0) === "x";
        for (var subplot in fullLayout._plots) {
          var plotinfo = fullLayout._plots[subplot];
          if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
          var anchorAxis = (isX ? plotinfo.yaxis : plotinfo.xaxis) || {};
          if ((anchorAxis.ticklabelposition || "").indexOf("inside") !== -1) {
            if (!max && (anchorAxis.side === "left" || anchorAxis.side === "bottom") || max && (anchorAxis.side === "top" || anchorAxis.side === "right")) {
              if (anchorAxis._vals) {
                var rad = Lib.deg2rad(anchorAxis._tickAngles[anchorAxis._id + "tick"] || 0);
                var cosA = Math.abs(Math.cos(rad));
                var sinA = Math.abs(Math.sin(rad));
                if (!anchorAxis._vals[0].bb) {
                  var cls = anchorAxis._id + "tick";
                  var tickLabels = anchorAxis._selections[cls];
                  tickLabels.each(function(d) {
                    var thisLabel = d3.select(this);
                    var mathjaxGroup = thisLabel.select(".text-math-group");
                    if (mathjaxGroup.empty()) {
                      d.bb = Drawing.bBox(thisLabel.node());
                    }
                  });
                }
                for (var i = 0; i < anchorAxis._vals.length; i++) {
                  var t = anchorAxis._vals[i];
                  var bb = t.bb;
                  if (bb) {
                    var w = 2 * TEXTPAD + bb.width;
                    var h = 2 * TEXTPAD + bb.height;
                    pad = Math.max(
                      pad,
                      isX ? Math.max(w * cosA, h * sinA) : Math.max(h * cosA, w * sinA)
                    );
                  }
                }
              }
              if (anchorAxis.ticks === "inside" && anchorAxis.ticklabelposition === "inside") {
                pad += anchorAxis.ticklen || 0;
              }
            }
          }
        }
        return pad;
      }
      function concatExtremes(gd, ax, noMatch) {
        var axId = ax._id;
        var fullData = gd._fullData;
        var fullLayout = gd._fullLayout;
        var minArray = [];
        var maxArray = [];
        var i, j, d;
        function _concat(cont, indices) {
          for (i = 0; i < indices.length; i++) {
            var item = cont[indices[i]];
            var extremes = (item._extremes || {})[axId];
            if (item.visible === true && extremes) {
              for (j = 0; j < extremes.min.length; j++) {
                d = extremes.min[j];
                collapseMinArray(minArray, d.val, d.pad, { extrapad: d.extrapad });
              }
              for (j = 0; j < extremes.max.length; j++) {
                d = extremes.max[j];
                collapseMaxArray(maxArray, d.val, d.pad, { extrapad: d.extrapad });
              }
            }
          }
        }
        _concat(fullData, ax._traceIndices);
        _concat(fullLayout.annotations || [], ax._annIndices || []);
        _concat(fullLayout.shapes || [], ax._shapeIndices || []);
        if (ax._matchGroup && !noMatch) {
          for (var axId2 in ax._matchGroup) {
            if (axId2 !== ax._id) {
              var ax2 = getFromId(gd, axId2);
              var extremes2 = concatExtremes(gd, ax2, true);
              var lenRatio = ax._length / ax2._length;
              for (j = 0; j < extremes2.min.length; j++) {
                d = extremes2.min[j];
                collapseMinArray(minArray, d.val, d.pad * lenRatio, { extrapad: d.extrapad });
              }
              for (j = 0; j < extremes2.max.length; j++) {
                d = extremes2.max[j];
                collapseMaxArray(maxArray, d.val, d.pad * lenRatio, { extrapad: d.extrapad });
              }
            }
          }
        }
        return { min: minArray, max: maxArray };
      }
      function doAutoRange(gd, ax, presetRange) {
        ax.setScale();
        if (ax.autorange) {
          ax.range = presetRange ? presetRange.slice() : getAutoRange(gd, ax);
          ax._r = ax.range.slice();
          ax._rl = Lib.simpleMap(ax._r, ax.r2l);
          var axIn = ax._input;
          var edits = {};
          edits[ax._attr + ".range"] = ax.range;
          edits[ax._attr + ".autorange"] = ax.autorange;
          Registry.call("_storeDirectGUIEdit", gd.layout, gd._fullLayout._preGUI, edits);
          axIn.range = ax.range.slice();
          axIn.autorange = ax.autorange;
        }
        var anchorAx = ax._anchorAxis;
        if (anchorAx && anchorAx.rangeslider) {
          var axeRangeOpts = anchorAx.rangeslider[ax._name];
          if (axeRangeOpts) {
            if (axeRangeOpts.rangemode === "auto") {
              axeRangeOpts.range = getAutoRange(gd, ax);
            }
          }
          anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);
        }
      }
      function findExtremes(ax, data, opts) {
        if (!opts) opts = {};
        if (!ax._m) ax.setScale();
        var minArray = [];
        var maxArray = [];
        var len = data.length;
        var extrapad = opts.padded || false;
        var tozero = opts.tozero && (ax.type === "linear" || ax.type === "-");
        var isLog = ax.type === "log";
        var hasArrayOption = false;
        var vpadLinearized = opts.vpadLinearized || false;
        var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;
        function makePadAccessor(item) {
          if (Array.isArray(item)) {
            hasArrayOption = true;
            return function(i2) {
              return Math.max(Number(item[i2] || 0), 0);
            };
          } else {
            var v2 = Math.max(Number(item || 0), 0);
            return function() {
              return v2;
            };
          }
        }
        var ppadplus = makePadAccessor((ax._m > 0 ? opts.ppadplus : opts.ppadminus) || opts.ppad || 0);
        var ppadminus = makePadAccessor((ax._m > 0 ? opts.ppadminus : opts.ppadplus) || opts.ppad || 0);
        var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);
        var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);
        if (!hasArrayOption) {
          vmin = Infinity;
          vmax = -Infinity;
          if (isLog) {
            for (i = 0; i < len; i++) {
              v = data[i];
              if (v < vmin && v > 0) vmin = v;
              if (v > vmax && v < FP_SAFE) vmax = v;
            }
          } else {
            for (i = 0; i < len; i++) {
              v = data[i];
              if (v < vmin && v > -FP_SAFE) vmin = v;
              if (v > vmax && v < FP_SAFE) vmax = v;
            }
          }
          data = [vmin, vmax];
          len = 2;
        }
        var collapseOpts = { tozero, extrapad };
        function addItem(i2) {
          di = data[i2];
          if (!isNumeric(di)) return;
          ppadiplus = ppadplus(i2);
          ppadiminus = ppadminus(i2);
          if (vpadLinearized) {
            dmin = ax.c2l(di) - vpadminus(i2);
            dmax = ax.c2l(di) + vpadplus(i2);
          } else {
            vmin = di - vpadminus(i2);
            vmax = di + vpadplus(i2);
            if (isLog && vmin < vmax / 10) vmin = vmax / 10;
            dmin = ax.c2l(vmin);
            dmax = ax.c2l(vmax);
          }
          if (tozero) {
            dmin = Math.min(0, dmin);
            dmax = Math.max(0, dmax);
          }
          if (goodNumber(dmin)) {
            collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);
          }
          if (goodNumber(dmax)) {
            collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);
          }
        }
        var iMax = Math.min(6, len);
        for (i = 0; i < iMax; i++) addItem(i);
        for (i = len - 1; i >= iMax; i--) addItem(i);
        return {
          min: minArray,
          max: maxArray,
          opts
        };
      }
      function collapseMinArray(array, newVal, newPad, opts) {
        collapseArray(array, newVal, newPad, opts, lessOrEqual);
      }
      function collapseMaxArray(array, newVal, newPad, opts) {
        collapseArray(array, newVal, newPad, opts, greaterOrEqual);
      }
      function collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {
        var tozero = opts.tozero;
        var extrapad = opts.extrapad;
        var includeThis = true;
        for (var j = 0; j < array.length && includeThis; j++) {
          var v = array[j];
          if (atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {
            includeThis = false;
            break;
          } else if (atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {
            array.splice(j, 1);
            j--;
          }
        }
        if (includeThis) {
          var clipAtZero = tozero && newVal === 0;
          array.push({
            val: newVal,
            pad: clipAtZero ? 0 : newPad,
            extrapad: clipAtZero ? false : extrapad
          });
        }
      }
      function goodNumber(v) {
        return isNumeric(v) && Math.abs(v) < FP_SAFE;
      }
      function lessOrEqual(v0, v1) {
        return v0 <= v1;
      }
      function greaterOrEqual(v0, v1) {
        return v0 >= v1;
      }
      function applyAutorangeMinOptions(v, ax) {
        var autorangeoptions = ax.autorangeoptions;
        if (autorangeoptions && autorangeoptions.minallowed !== void 0 && hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)) {
          return autorangeoptions.minallowed;
        }
        if (autorangeoptions && autorangeoptions.clipmin !== void 0 && hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)) {
          return Math.max(v, ax.d2l(autorangeoptions.clipmin));
        }
        return v;
      }
      function applyAutorangeMaxOptions(v, ax) {
        var autorangeoptions = ax.autorangeoptions;
        if (autorangeoptions && autorangeoptions.maxallowed !== void 0 && hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)) {
          return autorangeoptions.maxallowed;
        }
        if (autorangeoptions && autorangeoptions.clipmax !== void 0 && hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)) {
          return Math.min(v, ax.d2l(autorangeoptions.clipmax));
        }
        return v;
      }
      function hasValidMinAndMax(ax, min, max) {
        if (min !== void 0 && max !== void 0) {
          min = ax.d2l(min);
          max = ax.d2l(max);
          return min < max;
        }
        return true;
      }
      function applyAutorangeOptions(range, ax) {
        if (!ax || !ax.autorangeoptions) return range;
        var min = range[0];
        var max = range[1];
        var include = ax.autorangeoptions.include;
        if (include !== void 0) {
          var lMin = ax.d2l(min);
          var lMax = ax.d2l(max);
          if (!Lib.isArrayOrTypedArray(include)) include = [include];
          for (var i = 0; i < include.length; i++) {
            var v = ax.d2l(include[i]);
            if (lMin >= v) {
              lMin = v;
              min = v;
            }
            if (lMax <= v) {
              lMax = v;
              max = v;
            }
          }
        }
        min = applyAutorangeMinOptions(min, ax);
        max = applyAutorangeMaxOptions(max, ax);
        return [min, max];
      }
    }
  });

  // src/plots/cartesian/axes.js
  var require_axes = __commonJS({
    "src/plots/cartesian/axes.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Plots = require_plots();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var Titles = require_titles();
      var Color = require_color();
      var Drawing = require_drawing();
      var axAttrs = require_layout_attributes4();
      var cleanTicks = require_clean_ticks();
      var constants = require_numerical();
      var ONEMAXYEAR = constants.ONEMAXYEAR;
      var ONEAVGYEAR = constants.ONEAVGYEAR;
      var ONEMINYEAR = constants.ONEMINYEAR;
      var ONEMAXQUARTER = constants.ONEMAXQUARTER;
      var ONEAVGQUARTER = constants.ONEAVGQUARTER;
      var ONEMINQUARTER = constants.ONEMINQUARTER;
      var ONEMAXMONTH = constants.ONEMAXMONTH;
      var ONEAVGMONTH = constants.ONEAVGMONTH;
      var ONEMINMONTH = constants.ONEMINMONTH;
      var ONEWEEK = constants.ONEWEEK;
      var ONEDAY = constants.ONEDAY;
      var HALFDAY = ONEDAY / 2;
      var ONEHOUR = constants.ONEHOUR;
      var ONEMIN = constants.ONEMIN;
      var ONESEC = constants.ONESEC;
      var ONEMILLI = constants.ONEMILLI;
      var ONEMICROSEC = constants.ONEMICROSEC;
      var MINUS_SIGN = constants.MINUS_SIGN;
      var BADNUM = constants.BADNUM;
      var ZERO_PATH = { K: "zeroline" };
      var GRID_PATH = { K: "gridline", L: "path" };
      var MINORGRID_PATH = { K: "minor-gridline", L: "path" };
      var TICK_PATH = { K: "tick", L: "path" };
      var TICK_TEXT = { K: "tick", L: "text" };
      var MARGIN_MAPPING = {
        width: ["x", "r", "l", "xl", "xr"],
        height: ["y", "t", "b", "yt", "yb"],
        right: ["r", "xr"],
        left: ["l", "xl"],
        top: ["t", "yt"],
        bottom: ["b", "yb"]
      };
      var alignmentConstants = require_alignment();
      var MID_SHIFT = alignmentConstants.MID_SHIFT;
      var CAP_SHIFT = alignmentConstants.CAP_SHIFT;
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;
      var TEXTPAD = 3;
      var axes = module.exports = {};
      axes.setConvert = require_set_convert();
      var autoType = require_axis_autotype();
      var axisIds = require_axis_ids();
      var idSort = axisIds.idSort;
      var isLinked = axisIds.isLinked;
      axes.id2name = axisIds.id2name;
      axes.name2id = axisIds.name2id;
      axes.cleanId = axisIds.cleanId;
      axes.list = axisIds.list;
      axes.listIds = axisIds.listIds;
      axes.getFromId = axisIds.getFromId;
      axes.getFromTrace = axisIds.getFromTrace;
      var autorange = require_autorange();
      axes.getAutoRange = autorange.getAutoRange;
      axes.findExtremes = autorange.findExtremes;
      var epsilon = 1e-4;
      function expandRange(range) {
        var delta = (range[1] - range[0]) * epsilon;
        return [
          range[0] - delta,
          range[1] + delta
        ];
      }
      axes.coerceRef = function(containerIn, containerOut, gd, attr, dflt, extraOption) {
        var axLetter = attr.charAt(attr.length - 1);
        var axlist = gd._fullLayout._subplots[axLetter + "axis"];
        var refAttr = attr + "ref";
        var attrDef = {};
        if (!dflt) dflt = axlist[0] || (typeof extraOption === "string" ? extraOption : extraOption[0]);
        if (!extraOption) extraOption = dflt;
        axlist = axlist.concat(axlist.map(function(x) {
          return x + " domain";
        }));
        attrDef[refAttr] = {
          valType: "enumerated",
          values: axlist.concat(extraOption ? typeof extraOption === "string" ? [extraOption] : extraOption : []),
          dflt
        };
        return Lib.coerce(containerIn, containerOut, attrDef, refAttr);
      };
      axes.getRefType = function(ar) {
        if (ar === void 0) {
          return ar;
        }
        if (ar === "paper") {
          return "paper";
        }
        if (ar === "pixel") {
          return "pixel";
        }
        if (/( domain)$/.test(ar)) {
          return "domain";
        } else {
          return "range";
        }
      };
      axes.coercePosition = function(containerOut, gd, coerce, axRef, attr, dflt) {
        var cleanPos, pos;
        var axRefType = axes.getRefType(axRef);
        if (axRefType !== "range") {
          cleanPos = Lib.ensureNumber;
          pos = coerce(attr, dflt);
        } else {
          var ax = axes.getFromId(gd, axRef);
          dflt = ax.fraction2r(dflt);
          pos = coerce(attr, dflt);
          cleanPos = ax.cleanPos;
        }
        containerOut[attr] = cleanPos(pos);
      };
      axes.cleanPosition = function(pos, gd, axRef) {
        var cleanPos = axRef === "paper" || axRef === "pixel" ? Lib.ensureNumber : axes.getFromId(gd, axRef).cleanPos;
        return cleanPos(pos);
      };
      axes.redrawComponents = function(gd, axIds) {
        axIds = axIds ? axIds : axes.listIds(gd);
        var fullLayout = gd._fullLayout;
        function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {
          var method = Registry.getComponentMethod(moduleName, methodName);
          var stash = {};
          for (var i = 0; i < axIds.length; i++) {
            var ax = fullLayout[axes.id2name(axIds[i])];
            var indices = ax[stashName];
            for (var j = 0; j < indices.length; j++) {
              var ind = indices[j];
              if (!stash[ind]) {
                method(gd, ind);
                stash[ind] = 1;
                if (shortCircuit) return;
              }
            }
          }
        }
        _redrawOneComp("annotations", "drawOne", "_annIndices");
        _redrawOneComp("shapes", "drawOne", "_shapeIndices");
        _redrawOneComp("images", "draw", "_imgIndices", true);
        _redrawOneComp("selections", "drawOne", "_selectionIndices");
      };
      var getDataConversions = axes.getDataConversions = function(gd, trace, target, targetArray) {
        var ax;
        var d2cTarget = target === "x" || target === "y" || target === "z" ? target : targetArray;
        if (Lib.isArrayOrTypedArray(d2cTarget)) {
          ax = {
            type: autoType(targetArray, void 0, {
              autotypenumbers: gd._fullLayout.autotypenumbers
            }),
            _categories: []
          };
          axes.setConvert(ax);
          if (ax.type === "category") {
            for (var i = 0; i < targetArray.length; i++) {
              ax.d2c(targetArray[i]);
            }
          }
        } else {
          ax = axes.getFromTrace(gd, trace, d2cTarget);
        }
        if (ax) return { d2c: ax.d2c, c2d: ax.c2d };
        if (d2cTarget === "ids") return { d2c: toString, c2d: toString };
        return { d2c: toNum, c2d: toNum };
      };
      function toNum(v) {
        return +v;
      }
      function toString(v) {
        return String(v);
      }
      axes.getDataToCoordFunc = function(gd, trace, target, targetArray) {
        return getDataConversions(gd, trace, target, targetArray).d2c;
      };
      axes.counterLetter = function(id) {
        var axLetter = id.charAt(0);
        if (axLetter === "x") return "y";
        if (axLetter === "y") return "x";
      };
      axes.minDtick = function(ax, newDiff, newFirst, allow) {
        if (["log", "category", "multicategory"].indexOf(ax.type) !== -1 || !allow) {
          ax._minDtick = 0;
        } else if (ax._minDtick === void 0) {
          ax._minDtick = newDiff;
          ax._forceTick0 = newFirst;
        } else if (ax._minDtick) {
          if ((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 && // existing minDtick is an integer multiple of newDiff
          // (within rounding err)
          // and forceTick0 can be shifted to newFirst
          ((newFirst - ax._forceTick0) / newDiff % 1 + 1.000001) % 1 < 2e-6) {
            ax._minDtick = newDiff;
            ax._forceTick0 = newFirst;
          } else if ((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 || // if the converse is true (newDiff is a multiple of minDtick and
          // newFirst can be shifted to forceTick0) then do nothing - same
          // forcing stands. Otherwise, cancel forced minimum
          ((newFirst - ax._forceTick0) / ax._minDtick % 1 + 1.000001) % 1 > 2e-6) {
            ax._minDtick = 0;
          }
        }
      };
      axes.saveRangeInitial = function(gd, overwrite) {
        var axList = axes.list(gd, "", true);
        var hasOneAxisChanged = false;
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          var isNew = ax._rangeInitial0 === void 0 && ax._rangeInitial1 === void 0;
          var hasChanged = isNew || (ax.range[0] !== ax._rangeInitial0 || ax.range[1] !== ax._rangeInitial1);
          var autorange2 = ax.autorange;
          if (isNew && autorange2 !== true || overwrite && hasChanged) {
            ax._rangeInitial0 = autorange2 === "min" || autorange2 === "max reversed" ? void 0 : ax.range[0];
            ax._rangeInitial1 = autorange2 === "max" || autorange2 === "min reversed" ? void 0 : ax.range[1];
            ax._autorangeInitial = autorange2;
            hasOneAxisChanged = true;
          }
        }
        return hasOneAxisChanged;
      };
      axes.saveShowSpikeInitial = function(gd, overwrite) {
        var axList = axes.list(gd, "", true);
        var hasOneAxisChanged = false;
        var allSpikesEnabled = "on";
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          var isNew = ax._showSpikeInitial === void 0;
          var hasChanged = isNew || !(ax.showspikes === ax._showspikes);
          if (isNew || overwrite && hasChanged) {
            ax._showSpikeInitial = ax.showspikes;
            hasOneAxisChanged = true;
          }
          if (allSpikesEnabled === "on" && !ax.showspikes) {
            allSpikesEnabled = "off";
          }
        }
        gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;
        return hasOneAxisChanged;
      };
      axes.autoBin = function(data, ax, nbins, is2d, calendar, size) {
        var dataMin = Lib.aggNums(Math.min, null, data);
        var dataMax = Lib.aggNums(Math.max, null, data);
        if (ax.type === "category" || ax.type === "multicategory") {
          return {
            start: dataMin - 0.5,
            end: dataMax + 0.5,
            size: Math.max(1, Math.round(size) || 1),
            _dataSpan: dataMax - dataMin
          };
        }
        if (!calendar) calendar = ax.calendar;
        var dummyAx;
        if (ax.type === "log") {
          dummyAx = {
            type: "linear",
            range: [dataMin, dataMax]
          };
        } else {
          dummyAx = {
            type: ax.type,
            range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),
            calendar
          };
        }
        axes.setConvert(dummyAx);
        size = size && cleanTicks.dtick(size, dummyAx.type);
        if (size) {
          dummyAx.dtick = size;
          dummyAx.tick0 = cleanTicks.tick0(void 0, dummyAx.type, calendar);
        } else {
          var size0;
          if (nbins) size0 = (dataMax - dataMin) / nbins;
          else {
            var distinctData = Lib.distinctVals(data);
            var msexp = Math.pow(10, Math.floor(
              Math.log(distinctData.minDiff) / Math.LN10
            ));
            var minSize = msexp * Lib.roundUp(
              distinctData.minDiff / msexp,
              [0.9, 1.9, 4.9, 9.9],
              true
            );
            size0 = Math.max(minSize, 2 * Lib.stdev(data) / Math.pow(data.length, is2d ? 0.25 : 0.4));
            if (!isNumeric(size0)) size0 = 1;
          }
          axes.autoTicks(dummyAx, size0);
        }
        var finalSize = dummyAx.dtick;
        var binStart = axes.tickIncrement(
          axes.tickFirst(dummyAx),
          finalSize,
          "reverse",
          calendar
        );
        var binEnd, bincount;
        if (typeof finalSize === "number") {
          binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);
          bincount = 1 + Math.floor((dataMax - binStart) / finalSize);
          binEnd = binStart + bincount * finalSize;
        } else {
          if (dummyAx.dtick.charAt(0) === "M") {
            binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);
          }
          binEnd = binStart;
          bincount = 0;
          while (binEnd <= dataMax) {
            binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);
            bincount++;
          }
        }
        return {
          start: ax.c2r(binStart, 0, calendar),
          end: ax.c2r(binEnd, 0, calendar),
          size: finalSize,
          _dataSpan: dataMax - dataMin
        };
      };
      function autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {
        var edgecount = 0;
        var midcount = 0;
        var intcount = 0;
        var blankCount = 0;
        function nearEdge(v) {
          return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;
        }
        for (var i = 0; i < data.length; i++) {
          if (data[i] % 1 === 0) intcount++;
          else if (!isNumeric(data[i])) blankCount++;
          if (nearEdge(data[i])) edgecount++;
          if (nearEdge(data[i] + ax.dtick / 2)) midcount++;
        }
        var dataCount = data.length - blankCount;
        if (intcount === dataCount && ax.type !== "date") {
          if (ax.dtick < 1) {
            binStart = dataMin - 0.5 * ax.dtick;
          } else {
            binStart -= 0.5;
            if (binStart + ax.dtick < dataMin) binStart += ax.dtick;
          }
        } else if (midcount < dataCount * 0.1) {
          if (edgecount > dataCount * 0.3 || nearEdge(dataMin) || nearEdge(dataMax)) {
            var binshift = ax.dtick / 2;
            binStart += binStart + binshift < dataMin ? binshift : -binshift;
          }
        }
        return binStart;
      }
      function autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {
        var stats = Lib.findExactDates(data, calendar);
        var threshold = 0.8;
        if (stats.exactDays > threshold) {
          var numMonths = Number(dtick.substr(1));
          if (stats.exactYears > threshold && numMonths % 12 === 0) {
            binStart = axes.tickIncrement(binStart, "M6", "reverse") + ONEDAY * 1.5;
          } else if (stats.exactMonths > threshold) {
            binStart = axes.tickIncrement(binStart, "M1", "reverse") + ONEDAY * 15.5;
          } else {
            binStart -= HALFDAY;
          }
          var nextBinStart = axes.tickIncrement(binStart, dtick);
          if (nextBinStart <= dataMin) return nextBinStart;
        }
        return binStart;
      }
      axes.prepMinorTicks = function(mockAx, ax, opts) {
        if (!ax.minor.dtick) {
          delete mockAx.dtick;
          var hasMajor = ax.dtick && isNumeric(ax._tmin);
          var mockMinorRange;
          if (hasMajor) {
            var tick2 = axes.tickIncrement(ax._tmin, ax.dtick, true);
            mockMinorRange = [ax._tmin, tick2 * 0.99 + ax._tmin * 0.01];
          } else {
            var rl = Lib.simpleMap(ax.range, ax.r2l);
            mockMinorRange = [rl[0], 0.8 * rl[0] + 0.2 * rl[1]];
          }
          mockAx.range = Lib.simpleMap(mockMinorRange, ax.l2r);
          mockAx._isMinor = true;
          axes.prepTicks(mockAx, opts);
          if (hasMajor) {
            var numericMajor = isNumeric(ax.dtick);
            var numericMinor = isNumeric(mockAx.dtick);
            var majorNum = numericMajor ? ax.dtick : +ax.dtick.substring(1);
            var minorNum = numericMinor ? mockAx.dtick : +mockAx.dtick.substring(1);
            if (numericMajor && numericMinor) {
              if (!isMultiple(majorNum, minorNum)) {
                if (majorNum === 2 * ONEWEEK && minorNum === 3 * ONEDAY) {
                  mockAx.dtick = ONEWEEK;
                } else if (majorNum === ONEWEEK && !(ax._input.minor || {}).nticks) {
                  mockAx.dtick = ONEDAY;
                } else if (isClose(majorNum / minorNum, 2.5)) {
                  mockAx.dtick = majorNum / 2;
                } else {
                  mockAx.dtick = majorNum;
                }
              } else if (majorNum === 2 * ONEWEEK && minorNum === 2 * ONEDAY) {
                mockAx.dtick = ONEWEEK;
              }
            } else if (String(ax.dtick).charAt(0) === "M") {
              if (numericMinor) {
                mockAx.dtick = "M1";
              } else {
                if (!isMultiple(majorNum, minorNum)) {
                  mockAx.dtick = ax.dtick;
                } else if (majorNum >= 12 && minorNum === 2) {
                  mockAx.dtick = "M3";
                }
              }
            } else if (String(mockAx.dtick).charAt(0) === "L") {
              if (String(ax.dtick).charAt(0) === "L") {
                if (!isMultiple(majorNum, minorNum)) {
                  mockAx.dtick = isClose(majorNum / minorNum, 2.5) ? ax.dtick / 2 : ax.dtick;
                }
              } else {
                mockAx.dtick = "D1";
              }
            } else if (mockAx.dtick === "D2" && +ax.dtick > 1) {
              mockAx.dtick = 1;
            }
          }
          mockAx.range = ax.range;
        }
        if (ax.minor._tick0Init === void 0) {
          mockAx.tick0 = ax.tick0;
        }
      };
      function isMultiple(bigger, smaller) {
        return Math.abs((bigger / smaller + 0.5) % 1 - 0.5) < 1e-3;
      }
      function isClose(a, b) {
        return Math.abs(a / b - 1) < 1e-3;
      }
      axes.prepTicks = function(ax, opts) {
        var rng = Lib.simpleMap(ax.range, ax.r2l, void 0, void 0, opts);
        if (ax.tickmode === "auto" || !ax.dtick) {
          var nt = ax.nticks;
          var minPx;
          if (!nt) {
            if (ax.type === "category" || ax.type === "multicategory") {
              minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;
              nt = ax._length / minPx;
            } else {
              minPx = ax._id.charAt(0) === "y" ? 40 : 80;
              nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;
            }
            if (ax._name === "radialaxis") nt *= 2;
          }
          if (!(ax.minor && ax.minor.tickmode !== "array")) {
            if (ax.tickmode === "array") nt *= 100;
          }
          ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;
          axes.autoTicks(ax, ax._roughDTick);
          if (ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {
            ax.dtick = ax._minDtick;
            ax.tick0 = ax.l2r(ax._forceTick0);
          }
        }
        if (ax.ticklabelmode === "period") {
          adjustPeriodDelta(ax);
        }
        if (!ax.tick0) {
          ax.tick0 = ax.type === "date" ? "2000-01-01" : 0;
        }
        if (ax.type === "date" && ax.dtick < 0.1) ax.dtick = 0.1;
        autoTickRound(ax);
      };
      function nMonths(dtick) {
        return +dtick.substring(1);
      }
      function adjustPeriodDelta(ax) {
        var definedDelta;
        function mDate() {
          return !(isNumeric(ax.dtick) || ax.dtick.charAt(0) !== "M");
        }
        var isMDate = mDate();
        var tickformat = axes.getTickFormat(ax);
        if (tickformat) {
          var noDtick = ax._dtickInit !== ax.dtick;
          if (!/%[fLQsSMX]/.test(tickformat)) {
            if (/%[HI]/.test(tickformat)) {
              definedDelta = ONEHOUR;
              if (noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;
            } else if (/%p/.test(tickformat)) {
              definedDelta = HALFDAY;
              if (noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;
            } else if (/%[Aadejuwx]/.test(tickformat)) {
              definedDelta = ONEDAY;
              if (noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;
            } else if (/%[UVW]/.test(tickformat)) {
              definedDelta = ONEWEEK;
              if (noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;
            } else if (/%[Bbm]/.test(tickformat)) {
              definedDelta = ONEAVGMONTH;
              if (noDtick && (isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)) ax.dtick = "M1";
            } else if (/%[q]/.test(tickformat)) {
              definedDelta = ONEAVGQUARTER;
              if (noDtick && (isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)) ax.dtick = "M3";
            } else if (/%[Yy]/.test(tickformat)) {
              definedDelta = ONEAVGYEAR;
              if (noDtick && (isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)) ax.dtick = "M12";
            }
          }
        }
        isMDate = mDate();
        if (isMDate && ax.tick0 === ax._dowTick0) {
          ax.tick0 = ax._rawTick0;
        }
        ax._definedDelta = definedDelta;
      }
      function positionPeriodTicks(tickVals, ax, definedDelta) {
        for (var i = 0; i < tickVals.length; i++) {
          var v = tickVals[i].value;
          var a = i;
          var b = i + 1;
          if (i < tickVals.length - 1) {
            a = i;
            b = i + 1;
          } else if (i > 0) {
            a = i - 1;
            b = i;
          } else {
            a = i;
            b = i;
          }
          var A = tickVals[a].value;
          var B = tickVals[b].value;
          var actualDelta = Math.abs(B - A);
          var delta = definedDelta || actualDelta;
          var periodLength = 0;
          if (delta >= ONEMINYEAR) {
            if (actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {
              periodLength = actualDelta;
            } else {
              periodLength = ONEAVGYEAR;
            }
          } else if (definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {
            if (actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {
              periodLength = actualDelta;
            } else {
              periodLength = ONEAVGQUARTER;
            }
          } else if (delta >= ONEMINMONTH) {
            if (actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {
              periodLength = actualDelta;
            } else {
              periodLength = ONEAVGMONTH;
            }
          } else if (definedDelta === ONEWEEK && delta >= ONEWEEK) {
            periodLength = ONEWEEK;
          } else if (delta >= ONEDAY) {
            periodLength = ONEDAY;
          } else if (definedDelta === HALFDAY && delta >= HALFDAY) {
            periodLength = HALFDAY;
          } else if (definedDelta === ONEHOUR && delta >= ONEHOUR) {
            periodLength = ONEHOUR;
          }
          var inBetween;
          if (periodLength >= actualDelta) {
            periodLength = actualDelta;
            inBetween = true;
          }
          var endPeriod = v + periodLength;
          if (ax.rangebreaks && periodLength > 0) {
            var nAll = 84;
            var n = 0;
            for (var c = 0; c < nAll; c++) {
              var r = (c + 0.5) / nAll;
              if (ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;
            }
            periodLength *= n / nAll;
            if (!periodLength) {
              tickVals[i].drop = true;
            }
            if (inBetween && actualDelta > ONEWEEK) periodLength = actualDelta;
          }
          if (periodLength > 0 || // not instant
          i === 0) {
            tickVals[i].periodX = v + periodLength / 2;
          }
        }
      }
      axes.calcTicks = function calcTicks(ax, opts) {
        var type = ax.type;
        var calendar = ax.calendar;
        var ticklabelstep = ax.ticklabelstep;
        var isPeriod = ax.ticklabelmode === "period";
        var isReversed = ax.range[0] > ax.range[1];
        var ticklabelIndex = !ax.ticklabelindex || Lib.isArrayOrTypedArray(ax.ticklabelindex) ? ax.ticklabelindex : [ax.ticklabelindex];
        var rng = Lib.simpleMap(ax.range, ax.r2l, void 0, void 0, opts);
        var axrev = rng[1] < rng[0];
        var minRange = Math.min(rng[0], rng[1]);
        var maxRange = Math.max(rng[0], rng[1]);
        var maxTicks = Math.max(1e3, ax._length || 0);
        var ticksOut = [];
        var minorTicks = [];
        var tickVals = [];
        var minorTickVals = [];
        var allTicklabelVals = [];
        var hasMinor = ax.minor && (ax.minor.ticks || ax.minor.showgrid);
        for (var major = 1; major >= (hasMinor ? 0 : 1); major--) {
          var isMinor = !major;
          if (major) {
            ax._dtickInit = ax.dtick;
            ax._tick0Init = ax.tick0;
          } else {
            ax.minor._dtickInit = ax.minor.dtick;
            ax.minor._tick0Init = ax.minor.tick0;
          }
          var mockAx = major ? ax : Lib.extendFlat({}, ax, ax.minor);
          if (isMinor) {
            axes.prepMinorTicks(mockAx, ax, opts);
          } else {
            axes.prepTicks(mockAx, opts);
          }
          if (mockAx.tickmode === "array") {
            if (major) {
              tickVals = [];
              ticksOut = arrayTicks(ax, !isMinor);
            } else {
              minorTickVals = [];
              minorTicks = arrayTicks(ax, !isMinor);
            }
            continue;
          }
          if (mockAx.tickmode === "sync") {
            tickVals = [];
            ticksOut = syncTicks(ax);
            continue;
          }
          var exRng = expandRange(rng);
          var startTick = exRng[0];
          var endTick = exRng[1];
          var numDtick = isNumeric(mockAx.dtick);
          var isDLog = type === "log" && !(numDtick || mockAx.dtick.charAt(0) === "L");
          var x0 = axes.tickFirst(mockAx, opts);
          if (major) {
            ax._tmin = x0;
            if (x0 < startTick !== axrev) break;
            if (type === "category" || type === "multicategory") {
              endTick = axrev ? Math.max(-0.5, endTick) : Math.min(ax._categories.length - 0.5, endTick);
            }
          }
          var prevX = null;
          var x = x0;
          var majorId;
          if (major) {
            var _dTick;
            if (numDtick) {
              _dTick = ax.dtick;
            } else {
              if (type === "date") {
                if (typeof ax.dtick === "string" && ax.dtick.charAt(0) === "M") {
                  _dTick = ONEAVGMONTH * ax.dtick.substring(1);
                }
              } else {
                _dTick = ax._roughDTick;
              }
            }
            majorId = Math.round((ax.r2l(x) - ax.r2l(ax.tick0)) / _dTick) - 1;
          }
          var dtick = mockAx.dtick;
          if (mockAx.rangebreaks && mockAx._tick0Init !== mockAx.tick0) {
            x = moveOutsideBreak(x, ax);
            if (!axrev) {
              x = axes.tickIncrement(x, dtick, !axrev, calendar);
            }
          }
          if (major && isPeriod) {
            x = axes.tickIncrement(x, dtick, !axrev, calendar);
            majorId--;
          }
          for (; axrev ? x >= endTick : x <= endTick; x = axes.tickIncrement(
            x,
            dtick,
            axrev,
            calendar
          )) {
            if (major) majorId++;
            if (mockAx.rangebreaks) {
              if (!axrev) {
                if (x < startTick) continue;
                if (mockAx.maskBreaks(x) === BADNUM && moveOutsideBreak(x, mockAx) >= maxRange) break;
              }
            }
            if (tickVals.length > maxTicks || x === prevX) break;
            prevX = x;
            var obj = { value: x };
            if (major) {
              if (isDLog && x !== (x | 0)) {
                obj.simpleLabel = true;
              }
              if (ticklabelstep > 1 && majorId % ticklabelstep) {
                obj.skipLabel = true;
              }
              tickVals.push(obj);
            } else {
              obj.minor = true;
              minorTickVals.push(obj);
            }
          }
        }
        if (!minorTickVals || minorTickVals.length < 2) {
          ticklabelIndex = false;
        } else {
          var diff = (minorTickVals[1].value - minorTickVals[0].value) * (isReversed ? -1 : 1);
          if (!periodCompatibleWithTickformat(diff, ax.tickformat)) {
            ticklabelIndex = false;
          }
        }
        if (!ticklabelIndex) {
          allTicklabelVals = tickVals;
        } else {
          var allTickVals = tickVals.concat(minorTickVals);
          if (isPeriod && tickVals.length) {
            allTickVals = allTickVals.slice(1);
          }
          allTickVals = allTickVals.sort(function(a, b) {
            return a.value - b.value;
          }).filter(function(tick, index, self2) {
            return index === 0 || tick.value !== self2[index - 1].value;
          });
          var majorTickIndices = allTickVals.map(function(item, index) {
            return item.minor === void 0 && !item.skipLabel ? index : null;
          }).filter(function(index) {
            return index !== null;
          });
          majorTickIndices.forEach(function(majorIdx) {
            ticklabelIndex.map(function(nextLabelIdx) {
              var minorIdx = majorIdx + nextLabelIdx;
              if (minorIdx >= 0 && minorIdx < allTickVals.length) {
                Lib.pushUnique(allTicklabelVals, allTickVals[minorIdx]);
              }
            });
          });
        }
        if (hasMinor) {
          var canOverlap = ax.minor.ticks === "inside" && ax.ticks === "outside" || ax.minor.ticks === "outside" && ax.ticks === "inside";
          if (!canOverlap) {
            var majorValues = tickVals.map(function(d) {
              return d.value;
            });
            var list = [];
            for (var k = 0; k < minorTickVals.length; k++) {
              var T = minorTickVals[k];
              var v = T.value;
              if (majorValues.indexOf(v) !== -1) {
                continue;
              }
              var found = false;
              for (var q = 0; !found && q < tickVals.length; q++) {
                if (
                  // add 10e6 to eliminate problematic digits
                  1e7 + tickVals[q].value === 1e7 + v
                ) {
                  found = true;
                }
              }
              if (!found) list.push(T);
            }
            minorTickVals = list;
          }
        }
        if (isPeriod) positionPeriodTicks(allTicklabelVals, ax, ax._definedDelta);
        var i;
        if (ax.rangebreaks) {
          var flip = ax._id.charAt(0) === "y";
          var fontSize = 1;
          if (ax.tickmode === "auto") {
            fontSize = ax.tickfont ? ax.tickfont.size : 12;
          }
          var prevL = NaN;
          for (i = tickVals.length - 1; i > -1; i--) {
            if (tickVals[i].drop) {
              tickVals.splice(i, 1);
              continue;
            }
            tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax);
            var l = ax.c2p(tickVals[i].value);
            if (flip ? prevL > l - fontSize : prevL < l + fontSize) {
              tickVals.splice(axrev ? i + 1 : i, 1);
            } else {
              prevL = l;
            }
          }
        }
        if (isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {
          tickVals.pop();
        }
        ax._tmax = (tickVals[tickVals.length - 1] || {}).value;
        ax._prevDateHead = "";
        ax._inCalcTicks = true;
        var lastVisibleHead;
        var hideLabel = function(tick) {
          tick.text = "";
          ax._prevDateHead = lastVisibleHead;
        };
        tickVals = tickVals.concat(minorTickVals);
        function setTickLabel(ax2, tickVal) {
          var text = axes.tickText(
            ax2,
            tickVal.value,
            false,
            // hover
            tickVal.simpleLabel
            // noSuffixPrefix
          );
          var p = tickVal.periodX;
          if (p !== void 0) {
            text.periodX = p;
            if (p > maxRange || p < minRange) {
              if (p > maxRange) text.periodX = maxRange;
              if (p < minRange) text.periodX = minRange;
              hideLabel(text);
            }
          }
          return text;
        }
        var t;
        for (i = 0; i < tickVals.length; i++) {
          var _minor = tickVals[i].minor;
          var _value = tickVals[i].value;
          if (_minor) {
            if (ticklabelIndex && allTicklabelVals.indexOf(tickVals[i]) !== -1) {
              t = setTickLabel(ax, tickVals[i]);
            } else {
              t = { x: _value };
            }
            t.minor = true;
            minorTicks.push(t);
          } else {
            lastVisibleHead = ax._prevDateHead;
            t = setTickLabel(ax, tickVals[i]);
            if (tickVals[i].skipLabel || ticklabelIndex && allTicklabelVals.indexOf(tickVals[i]) === -1) {
              hideLabel(t);
            }
            ticksOut.push(t);
          }
        }
        ticksOut = ticksOut.concat(minorTicks);
        ax._inCalcTicks = false;
        if (isPeriod && ticksOut.length) {
          ticksOut[0].noTick = true;
        }
        return ticksOut;
      };
      function filterRangeBreaks(ax, ticksOut) {
        if (ax.rangebreaks) {
          ticksOut = ticksOut.filter(function(d) {
            return ax.maskBreaks(d.x) !== BADNUM;
          });
        }
        return ticksOut;
      }
      function syncTicks(ax) {
        var baseAxis = ax._mainAxis;
        var ticksOut = [];
        if (baseAxis._vals) {
          for (var i = 0; i < baseAxis._vals.length; i++) {
            if (baseAxis._vals[i].noTick) {
              continue;
            }
            var pos = baseAxis.l2p(baseAxis._vals[i].x);
            var vali = ax.p2l(pos);
            var obj = axes.tickText(ax, vali);
            if (baseAxis._vals[i].minor) {
              obj.minor = true;
              obj.text = "";
            }
            ticksOut.push(obj);
          }
        }
        ticksOut = filterRangeBreaks(ax, ticksOut);
        return ticksOut;
      }
      function arrayTicks(ax, majorOnly) {
        var rng = Lib.simpleMap(ax.range, ax.r2l);
        var exRng = expandRange(rng);
        var tickMin = Math.min(exRng[0], exRng[1]);
        var tickMax = Math.max(exRng[0], exRng[1]);
        var tickVal2l = ax.type === "category" ? ax.d2l_noadd : ax.d2l;
        if (ax.type === "log" && String(ax.dtick).charAt(0) !== "L") {
          ax.dtick = "L" + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);
        }
        var ticksOut = [];
        for (var isMinor = 0; isMinor <= 1; isMinor++) {
          if (majorOnly !== void 0 && (majorOnly && isMinor || majorOnly === false && !isMinor)) continue;
          if (isMinor && !ax.minor) continue;
          var vals = !isMinor ? ax.tickvals : ax.minor.tickvals;
          var text = !isMinor ? ax.ticktext : [];
          if (!vals) continue;
          if (!Lib.isArrayOrTypedArray(text)) text = [];
          for (var i = 0; i < vals.length; i++) {
            var vali = tickVal2l(vals[i]);
            if (vali > tickMin && vali < tickMax) {
              var obj = axes.tickText(ax, vali, false, String(text[i]));
              if (isMinor) {
                obj.minor = true;
                obj.text = "";
              }
              ticksOut.push(obj);
            }
          }
        }
        ticksOut = filterRangeBreaks(ax, ticksOut);
        return ticksOut;
      }
      var roundBase10 = [2, 5, 10];
      var roundBase24 = [1, 2, 3, 6, 12];
      var roundBase60 = [1, 2, 5, 10, 15, 30];
      var roundDays = [1, 2, 3, 7, 14];
      var roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];
      var roundLog2 = [-0.301, 0, 0.301, 0.699, 1];
      var roundAngles = [15, 30, 45, 90, 180];
      function roundDTick(roughDTick, base, roundingSet) {
        return base * Lib.roundUp(roughDTick / base, roundingSet);
      }
      axes.autoTicks = function(ax, roughDTick, isMinor) {
        var base;
        function getBase(v) {
          return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));
        }
        if (ax.type === "date") {
          ax.tick0 = Lib.dateTick0(ax.calendar, 0);
          var roughX2 = 2 * roughDTick;
          if (roughX2 > ONEAVGYEAR) {
            roughDTick /= ONEAVGYEAR;
            base = getBase(10);
            ax.dtick = "M" + 12 * roundDTick(roughDTick, base, roundBase10);
          } else if (roughX2 > ONEAVGMONTH) {
            roughDTick /= ONEAVGMONTH;
            ax.dtick = "M" + roundDTick(roughDTick, 1, roundBase24);
          } else if (roughX2 > ONEDAY) {
            ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays);
            if (!isMinor) {
              var tickformat = axes.getTickFormat(ax);
              var isPeriod = ax.ticklabelmode === "period";
              if (isPeriod) ax._rawTick0 = ax.tick0;
              if (/%[uVW]/.test(tickformat)) {
                ax.tick0 = Lib.dateTick0(ax.calendar, 2);
              } else {
                ax.tick0 = Lib.dateTick0(ax.calendar, 1);
              }
              if (isPeriod) ax._dowTick0 = ax.tick0;
            }
          } else if (roughX2 > ONEHOUR) {
            ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);
          } else if (roughX2 > ONEMIN) {
            ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);
          } else if (roughX2 > ONESEC) {
            ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);
          } else {
            base = getBase(10);
            ax.dtick = roundDTick(roughDTick, base, roundBase10);
          }
        } else if (ax.type === "log") {
          ax.tick0 = 0;
          var rng = Lib.simpleMap(ax.range, ax.r2l);
          if (ax._isMinor) {
            roughDTick *= 1.5;
          }
          if (roughDTick > 0.7) {
            ax.dtick = Math.ceil(roughDTick);
          } else if (Math.abs(rng[1] - rng[0]) < 1) {
            var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);
            roughDTick = Math.abs(Math.pow(10, rng[1]) - Math.pow(10, rng[0])) / nt;
            base = getBase(10);
            ax.dtick = "L" + roundDTick(roughDTick, base, roundBase10);
          } else {
            ax.dtick = roughDTick > 0.3 ? "D2" : "D1";
          }
        } else if (ax.type === "category" || ax.type === "multicategory") {
          ax.tick0 = 0;
          ax.dtick = Math.ceil(Math.max(roughDTick, 1));
        } else if (isAngular(ax)) {
          ax.tick0 = 0;
          base = 1;
          ax.dtick = roundDTick(roughDTick, base, roundAngles);
        } else {
          ax.tick0 = 0;
          base = getBase(10);
          ax.dtick = roundDTick(roughDTick, base, roundBase10);
        }
        if (ax.dtick === 0) ax.dtick = 1;
        if (!isNumeric(ax.dtick) && typeof ax.dtick !== "string") {
          var olddtick = ax.dtick;
          ax.dtick = 1;
          throw "ax.dtick error: " + String(olddtick);
        }
      };
      function autoTickRound(ax) {
        var dtick = ax.dtick;
        ax._tickexponent = 0;
        if (!isNumeric(dtick) && typeof dtick !== "string") {
          dtick = 1;
        }
        if (ax.type === "category" || ax.type === "multicategory") {
          ax._tickround = null;
        }
        if (ax.type === "date") {
          var tick0ms = ax.r2l(ax.tick0);
          var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, "");
          var tick0len = tick0str.length;
          if (String(dtick).charAt(0) === "M") {
            if (tick0len > 10 || tick0str.substr(5) !== "01-01") ax._tickround = "d";
            else ax._tickround = +dtick.substr(1) % 12 === 0 ? "y" : "m";
          } else if (dtick >= ONEDAY && tick0len <= 10 || dtick >= ONEDAY * 15) ax._tickround = "d";
          else if (dtick >= ONEMIN && tick0len <= 16 || dtick >= ONEHOUR) ax._tickround = "M";
          else if (dtick >= ONESEC && tick0len <= 19 || dtick >= ONEMIN) ax._tickround = "S";
          else {
            var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, "").length;
            ax._tickround = Math.max(tick0len, tick1len) - 20;
            if (ax._tickround < 0) ax._tickround = 4;
          }
        } else if (isNumeric(dtick) || dtick.charAt(0) === "L") {
          var rng = ax.range.map(ax.r2d || Number);
          if (!isNumeric(dtick)) dtick = Number(dtick.substr(1));
          ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);
          var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));
          var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);
          var minexponent = ax.minexponent === void 0 ? 3 : ax.minexponent;
          if (Math.abs(rangeexp) > minexponent) {
            if (isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {
              ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);
            } else ax._tickexponent = rangeexp;
          }
        } else {
          ax._tickround = null;
        }
      }
      axes.tickIncrement = function(x, dtick, axrev, calendar) {
        var axSign = axrev ? -1 : 1;
        if (isNumeric(dtick)) return Lib.increment(x, axSign * dtick);
        var tType = dtick.charAt(0);
        var dtSigned = axSign * Number(dtick.substr(1));
        if (tType === "M") return Lib.incrementMonth(x, dtSigned, calendar);
        if (tType === "L") return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;
        if (tType === "D") {
          var tickset = dtick === "D2" ? roundLog2 : roundLog1;
          var x2 = x + axSign * 0.01;
          var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);
          return Math.floor(x2) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
        }
        throw "unrecognized dtick " + String(dtick);
      };
      axes.tickFirst = function(ax, opts) {
        var r2l = ax.r2l || Number;
        var rng = Lib.simpleMap(ax.range, r2l, void 0, void 0, opts);
        var axrev = rng[1] < rng[0];
        var sRound = axrev ? Math.floor : Math.ceil;
        var r0 = expandRange(rng)[0];
        var dtick = ax.dtick;
        var tick0 = r2l(ax.tick0);
        if (isNumeric(dtick)) {
          var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;
          if (ax.type === "category" || ax.type === "multicategory") {
            tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);
          }
          return tmin;
        }
        var tType = dtick.charAt(0);
        var dtNum = Number(dtick.substr(1));
        if (tType === "M") {
          var cnt = 0;
          var t0 = tick0;
          var t1, mult, newDTick;
          while (cnt < 10) {
            t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);
            if ((t1 - r0) * (t0 - r0) <= 0) {
              if (axrev) return Math.min(t0, t1);
              return Math.max(t0, t1);
            }
            mult = (r0 - (t0 + t1) / 2) / (t1 - t0);
            newDTick = tType + (Math.abs(Math.round(mult)) || 1) * dtNum;
            t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);
            cnt++;
          }
          Lib.error("tickFirst did not converge", ax);
          return t0;
        } else if (tType === "L") {
          return Math.log(sRound(
            (Math.pow(10, r0) - tick0) / dtNum
          ) * dtNum + tick0) / Math.LN10;
        } else if (tType === "D") {
          var tickset = dtick === "D2" ? roundLog2 : roundLog1;
          var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);
          return Math.floor(r0) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
        } else throw "unrecognized dtick " + String(dtick);
      };
      axes.tickText = function(ax, x, hover, noSuffixPrefix) {
        var out = tickTextObj(ax, x);
        var arrayMode = ax.tickmode === "array";
        var extraPrecision = hover || arrayMode;
        var axType = ax.type;
        var tickVal2l = axType === "category" ? ax.d2l_noadd : ax.d2l;
        var i;
        var inbounds = function(v) {
          var p = ax.l2p(v);
          return p >= 0 && p <= ax._length ? v : null;
        };
        if (arrayMode && Lib.isArrayOrTypedArray(ax.ticktext)) {
          var rng = Lib.simpleMap(ax.range, ax.r2l);
          var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 1e4;
          for (i = 0; i < ax.ticktext.length; i++) {
            if (Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;
          }
          if (i < ax.ticktext.length) {
            out.text = String(ax.ticktext[i]);
            out.xbnd = [
              inbounds(out.x - 0.5),
              inbounds(out.x + ax.dtick - 0.5)
            ];
            return out;
          }
        }
        function isHidden(showAttr) {
          if (showAttr === void 0) return true;
          if (hover) return showAttr === "none";
          var firstOrLast = {
            first: ax._tmin,
            last: ax._tmax
          }[showAttr];
          return showAttr !== "all" && x !== firstOrLast;
        }
        var hideexp = hover ? "never" : ax.exponentformat !== "none" && isHidden(ax.showexponent) ? "hide" : "";
        if (axType === "date") formatDate(ax, out, hover, extraPrecision);
        else if (axType === "log") formatLog(ax, out, hover, extraPrecision, hideexp);
        else if (axType === "category") formatCategory(ax, out);
        else if (axType === "multicategory") formatMultiCategory(ax, out, hover);
        else if (isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);
        else formatLinear(ax, out, hover, extraPrecision, hideexp);
        if (!noSuffixPrefix) {
          if (ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;
          if (ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;
        }
        if (ax.labelalias && ax.labelalias.hasOwnProperty(out.text)) {
          var t = ax.labelalias[out.text];
          if (typeof t === "string") out.text = t;
        }
        if (ax.tickson === "boundaries" || ax.showdividers) {
          out.xbnd = [
            inbounds(out.x - 0.5),
            inbounds(out.x + ax.dtick - 0.5)
          ];
        }
        return out;
      };
      axes.hoverLabelText = function(ax, values, hoverformat) {
        if (hoverformat) ax = Lib.extendFlat({}, ax, { hoverformat });
        var val = Lib.isArrayOrTypedArray(values) ? values[0] : values;
        var val2 = Lib.isArrayOrTypedArray(values) ? values[1] : void 0;
        if (val2 !== void 0 && val2 !== val) {
          return axes.hoverLabelText(ax, val, hoverformat) + " - " + axes.hoverLabelText(ax, val2, hoverformat);
        }
        var logOffScale = ax.type === "log" && val <= 0;
        var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), "hover").text;
        if (logOffScale) {
          return val === 0 ? "0" : MINUS_SIGN + tx;
        }
        return tx;
      };
      function tickTextObj(ax, x, text) {
        var tf = ax.tickfont || {};
        return {
          x,
          dx: 0,
          dy: 0,
          text: text || "",
          fontSize: tf.size,
          font: tf.family,
          fontWeight: tf.weight,
          fontStyle: tf.style,
          fontVariant: tf.variant,
          fontTextcase: tf.textcase,
          fontLineposition: tf.lineposition,
          fontShadow: tf.shadow,
          fontColor: tf.color
        };
      }
      function formatDate(ax, out, hover, extraPrecision) {
        var tr = ax._tickround;
        var fmt = hover && ax.hoverformat || axes.getTickFormat(ax);
        extraPrecision = !fmt && extraPrecision;
        if (extraPrecision) {
          if (isNumeric(tr)) tr = 4;
          else tr = { y: "m", m: "d", d: "M", M: "S", S: 4 }[tr];
        }
        var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);
        var headStr;
        var splitIndex = dateStr.indexOf("\n");
        if (splitIndex !== -1) {
          headStr = dateStr.substr(splitIndex + 1);
          dateStr = dateStr.substr(0, splitIndex);
        }
        if (extraPrecision) {
          if (headStr !== void 0 && (dateStr === "00:00:00" || dateStr === "00:00")) {
            dateStr = headStr;
            headStr = "";
          } else if (dateStr.length === 8) {
            dateStr = dateStr.replace(/:00$/, "");
          }
        }
        if (headStr) {
          if (hover) {
            if (tr === "d") dateStr += ", " + headStr;
            else dateStr = headStr + (dateStr ? ", " + dateStr : "");
          } else {
            if (!ax._inCalcTicks || ax._prevDateHead !== headStr) {
              ax._prevDateHead = headStr;
              dateStr += "<br>" + headStr;
            } else {
              var isInside = insideTicklabelposition(ax);
              var side = ax._trueSide || ax.side;
              if (!isInside && side === "top" || isInside && side === "bottom") {
                dateStr += "<br> ";
              }
            }
          }
        }
        out.text = dateStr;
      }
      function formatLog(ax, out, hover, extraPrecision, hideexp) {
        var dtick = ax.dtick;
        var x = out.x;
        var tickformat = ax.tickformat;
        var dtChar0 = typeof dtick === "string" && dtick.charAt(0);
        if (hideexp === "never") {
          hideexp = "";
        }
        if (extraPrecision && dtChar0 !== "L") {
          dtick = "L3";
          dtChar0 = "L";
        }
        if (tickformat || dtChar0 === "L") {
          out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);
        } else if (isNumeric(dtick) || dtChar0 === "D" && Lib.mod(x + 0.01, 1) < 0.1) {
          var p = Math.round(x);
          var absP = Math.abs(p);
          var exponentFormat = ax.exponentformat;
          if (exponentFormat === "power" || isSIFormat(exponentFormat) && beyondSI(p)) {
            if (p === 0) out.text = 1;
            else if (p === 1) out.text = "10";
            else out.text = "10<sup>" + (p > 1 ? "" : MINUS_SIGN) + absP + "</sup>";
            out.fontSize *= 1.25;
          } else if ((exponentFormat === "e" || exponentFormat === "E") && absP > 2) {
            out.text = "1" + exponentFormat + (p > 0 ? "+" : MINUS_SIGN) + absP;
          } else {
            out.text = numFormat(Math.pow(10, x), ax, "", "fakehover");
            if (dtick === "D1" && ax._id.charAt(0) === "y") {
              out.dy -= out.fontSize / 6;
            }
          }
        } else if (dtChar0 === "D") {
          out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));
          out.fontSize *= 0.75;
        } else throw "unrecognized dtick " + String(dtick);
        if (ax.dtick === "D1") {
          var firstChar = String(out.text).charAt(0);
          if (firstChar === "0" || firstChar === "1") {
            if (ax._id.charAt(0) === "y") {
              out.dx -= out.fontSize / 4;
            } else {
              out.dy += out.fontSize / 2;
              out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) * out.fontSize * (x < 0 ? 0.5 : 0.25);
            }
          }
        }
      }
      function formatCategory(ax, out) {
        var tt = ax._categories[Math.round(out.x)];
        if (tt === void 0) tt = "";
        out.text = String(tt);
      }
      function formatMultiCategory(ax, out, hover) {
        var v = Math.round(out.x);
        var cats = ax._categories[v] || [];
        var tt = cats[1] === void 0 ? "" : String(cats[1]);
        var tt2 = cats[0] === void 0 ? "" : String(cats[0]);
        if (hover) {
          out.text = tt2 + " - " + tt;
        } else {
          out.text = tt;
          out.text2 = tt2;
        }
      }
      function formatLinear(ax, out, hover, extraPrecision, hideexp) {
        if (hideexp === "never") {
          hideexp = "";
        } else if (ax.showexponent === "all" && Math.abs(out.x / ax.dtick) < 1e-6) {
          hideexp = "hide";
        }
        out.text = numFormat(out.x, ax, hideexp, extraPrecision);
      }
      function formatAngle(ax, out, hover, extraPrecision, hideexp) {
        if (ax.thetaunit === "radians" && !hover) {
          var num = out.x / 180;
          if (num === 0) {
            out.text = "0";
          } else {
            var frac = num2frac(num);
            if (frac[1] >= 100) {
              out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);
            } else {
              var isNeg = out.x < 0;
              if (frac[1] === 1) {
                if (frac[0] === 1) out.text = "\u03C0";
                else out.text = frac[0] + "\u03C0";
              } else {
                out.text = [
                  "<sup>",
                  frac[0],
                  "</sup>",
                  "\u2044",
                  "<sub>",
                  frac[1],
                  "</sub>",
                  "\u03C0"
                ].join("");
              }
              if (isNeg) out.text = MINUS_SIGN + out.text;
            }
          }
        } else {
          out.text = numFormat(out.x, ax, hideexp, extraPrecision);
        }
      }
      function num2frac(num) {
        function almostEq(a, b) {
          return Math.abs(a - b) <= 1e-6;
        }
        function findGCD(a, b) {
          return almostEq(b, 0) ? a : findGCD(b, a % b);
        }
        function findPrecision(n) {
          var e = 1;
          while (!almostEq(Math.round(n * e) / e, n)) {
            e *= 10;
          }
          return e;
        }
        var precision = findPrecision(num);
        var number = num * precision;
        var gcd = Math.abs(findGCD(number, precision));
        return [
          // numerator
          Math.round(number / gcd),
          // denominator
          Math.round(precision / gcd)
        ];
      }
      var SIPREFIXES = ["f", "p", "n", "\u03BC", "m", "", "k", "M", "G", "T"];
      function isSIFormat(exponentFormat) {
        return exponentFormat === "SI" || exponentFormat === "B";
      }
      function beyondSI(exponent) {
        return exponent > 14 || exponent < -15;
      }
      function numFormat(v, ax, fmtoverride, hover) {
        var isNeg = v < 0;
        var tickRound = ax._tickround;
        var exponentFormat = fmtoverride || ax.exponentformat || "B";
        var exponent = ax._tickexponent;
        var tickformat = axes.getTickFormat(ax);
        var separatethousands = ax.separatethousands;
        if (hover) {
          var ah = {
            exponentformat: exponentFormat,
            minexponent: ax.minexponent,
            dtick: ax.showexponent === "none" ? ax.dtick : isNumeric(v) ? Math.abs(v) || 1 : 1,
            // if not showing any exponents, don't change the exponent
            // from what we calculate
            range: ax.showexponent === "none" ? ax.range.map(ax.r2d) : [0, v || 1]
          };
          autoTickRound(ah);
          tickRound = (Number(ah._tickround) || 0) + 4;
          exponent = ah._tickexponent;
          if (ax.hoverformat) tickformat = ax.hoverformat;
        }
        if (tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);
        var e = Math.pow(10, -tickRound) / 2;
        if (exponentFormat === "none") exponent = 0;
        v = Math.abs(v);
        if (v < e) {
          v = "0";
          isNeg = false;
        } else {
          v += e;
          if (exponent) {
            v *= Math.pow(10, -exponent);
            tickRound += exponent;
          }
          if (tickRound === 0) v = String(Math.floor(v));
          else if (tickRound < 0) {
            v = String(Math.round(v));
            v = v.substr(0, v.length + tickRound);
            for (var i = tickRound; i < 0; i++) v += "0";
          } else {
            v = String(v);
            var dp = v.indexOf(".") + 1;
            if (dp) v = v.substr(0, dp + tickRound).replace(/\.?0+$/, "");
          }
          v = Lib.numSeparate(v, ax._separators, separatethousands);
        }
        if (exponent && exponentFormat !== "hide") {
          if (isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = "power";
          var signedExponent;
          if (exponent < 0) signedExponent = MINUS_SIGN + -exponent;
          else if (exponentFormat !== "power") signedExponent = "+" + exponent;
          else signedExponent = String(exponent);
          if (exponentFormat === "e" || exponentFormat === "E") {
            v += exponentFormat + signedExponent;
          } else if (exponentFormat === "power") {
            v += "\xD710<sup>" + signedExponent + "</sup>";
          } else if (exponentFormat === "B" && exponent === 9) {
            v += "B";
          } else if (isSIFormat(exponentFormat)) {
            v += SIPREFIXES[exponent / 3 + 5];
          }
        }
        if (isNeg) return MINUS_SIGN + v;
        return v;
      }
      axes.getTickFormat = function(ax) {
        var i;
        function convertToMs(dtick) {
          return typeof dtick !== "string" ? dtick : Number(dtick.replace("M", "")) * ONEAVGMONTH;
        }
        function compareLogTicks(left, right) {
          var priority = ["L", "D"];
          if (typeof left === typeof right) {
            if (typeof left === "number") {
              return left - right;
            } else {
              var leftPriority = priority.indexOf(left.charAt(0));
              var rightPriority = priority.indexOf(right.charAt(0));
              if (leftPriority === rightPriority) {
                return Number(left.replace(/(L|D)/g, "")) - Number(right.replace(/(L|D)/g, ""));
              } else {
                return leftPriority - rightPriority;
              }
            }
          } else {
            return typeof left === "number" ? 1 : -1;
          }
        }
        function isProperStop(dtick, range, convert) {
          var convertFn = convert || function(x) {
            return x;
          };
          var leftDtick = range[0];
          var rightDtick = range[1];
          return (!leftDtick && typeof leftDtick !== "number" || convertFn(leftDtick) <= convertFn(dtick)) && (!rightDtick && typeof rightDtick !== "number" || convertFn(rightDtick) >= convertFn(dtick));
        }
        function isProperLogStop(dtick, range) {
          var isLeftDtickNull = range[0] === null;
          var isRightDtickNull = range[1] === null;
          var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;
          var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;
          return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);
        }
        var tickstop, stopi;
        if (ax.tickformatstops && ax.tickformatstops.length > 0) {
          switch (ax.type) {
            case "date":
            case "linear": {
              for (i = 0; i < ax.tickformatstops.length; i++) {
                stopi = ax.tickformatstops[i];
                if (stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {
                  tickstop = stopi;
                  break;
                }
              }
              break;
            }
            case "log": {
              for (i = 0; i < ax.tickformatstops.length; i++) {
                stopi = ax.tickformatstops[i];
                if (stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {
                  tickstop = stopi;
                  break;
                }
              }
              break;
            }
            default:
          }
        }
        return tickstop ? tickstop.value : ax.tickformat;
      };
      axes.getSubplots = function(gd, ax) {
        var subplotObj = gd._fullLayout._subplots;
        var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);
        var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;
        out.sort(function(a, b) {
          var aParts = a.substr(1).split("y");
          var bParts = b.substr(1).split("y");
          if (aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];
          return +aParts[0] - +bParts[0];
        });
        return out;
      };
      axes.findSubplotsWithAxis = function(subplots, ax) {
        var axMatch = new RegExp(
          ax._id.charAt(0) === "x" ? "^" + ax._id + "y" : ax._id + "$"
        );
        var subplotsWithAx = [];
        for (var i = 0; i < subplots.length; i++) {
          var sp = subplots[i];
          if (axMatch.test(sp)) subplotsWithAx.push(sp);
        }
        return subplotsWithAx;
      };
      axes.makeClipPaths = function(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._hasOnlyLargeSploms) return;
        var fullWidth = { _offset: 0, _length: fullLayout.width, _id: "" };
        var fullHeight = { _offset: 0, _length: fullLayout.height, _id: "" };
        var xaList = axes.list(gd, "x", true);
        var yaList = axes.list(gd, "y", true);
        var clipList = [];
        var i, j;
        for (i = 0; i < xaList.length; i++) {
          clipList.push({ x: xaList[i], y: fullHeight });
          for (j = 0; j < yaList.length; j++) {
            if (i === 0) clipList.push({ x: fullWidth, y: yaList[j] });
            clipList.push({ x: xaList[i], y: yaList[j] });
          }
        }
        var axClips = fullLayout._clips.selectAll(".axesclip").data(clipList, function(d) {
          return d.x._id + d.y._id;
        });
        axClips.enter().append("clipPath").classed("axesclip", true).attr("id", function(d) {
          return "clip" + fullLayout._uid + d.x._id + d.y._id;
        }).append("rect");
        axClips.exit().remove();
        axClips.each(function(d) {
          d3.select(this).select("rect").attr({
            x: d.x._offset || 0,
            y: d.y._offset || 0,
            width: d.x._length || 1,
            height: d.y._length || 1
          });
        });
      };
      axes.draw = function(gd, arg, opts) {
        var fullLayout = gd._fullLayout;
        if (arg === "redraw") {
          fullLayout._paper.selectAll("g.subplot").each(function(d) {
            var id = d[0];
            var plotinfo = fullLayout._plots[id];
            if (plotinfo) {
              var xa = plotinfo.xaxis;
              var ya = plotinfo.yaxis;
              plotinfo.xaxislayer.selectAll("." + xa._id + "tick").remove();
              plotinfo.yaxislayer.selectAll("." + ya._id + "tick").remove();
              plotinfo.xaxislayer.selectAll("." + xa._id + "tick2").remove();
              plotinfo.yaxislayer.selectAll("." + ya._id + "tick2").remove();
              plotinfo.xaxislayer.selectAll("." + xa._id + "divider").remove();
              plotinfo.yaxislayer.selectAll("." + ya._id + "divider").remove();
              if (plotinfo.minorGridlayer) plotinfo.minorGridlayer.selectAll("path").remove();
              if (plotinfo.gridlayer) plotinfo.gridlayer.selectAll("path").remove();
              if (plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll("path").remove();
              fullLayout._infolayer.select(".g-" + xa._id + "title").remove();
              fullLayout._infolayer.select(".g-" + ya._id + "title").remove();
            }
          });
        }
        var axList = !arg || arg === "redraw" ? axes.listIds(gd) : arg;
        var fullAxList = axes.list(gd);
        var overlayingShiftedAx = fullAxList.filter(function(ax) {
          return ax.autoshift;
        }).map(function(ax) {
          return ax.overlaying;
        });
        axList.map(function(axId) {
          var ax = axes.getFromId(gd, axId);
          if (ax.tickmode === "sync" && ax.overlaying) {
            var overlayingIndex = axList.findIndex(function(axis) {
              return axis === ax.overlaying;
            });
            if (overlayingIndex >= 0) {
              axList.unshift(axList.splice(overlayingIndex, 1).shift());
            }
          }
        });
        var axShifts = { false: { left: 0, right: 0 } };
        return Lib.syncOrAsync(axList.map(function(axId) {
          return function() {
            if (!axId) return;
            var ax = axes.getFromId(gd, axId);
            if (!opts) opts = {};
            opts.axShifts = axShifts;
            opts.overlayingShiftedAx = overlayingShiftedAx;
            var axDone = axes.drawOne(gd, ax, opts);
            if (ax._shiftPusher) {
              incrementShift(ax, ax._fullDepth || 0, axShifts, true);
            }
            ax._r = ax.range.slice();
            ax._rl = Lib.simpleMap(ax._r, ax.r2l);
            return axDone;
          };
        }));
      };
      axes.drawOne = function(gd, ax, opts) {
        opts = opts || {};
        var axShifts = opts.axShifts || {};
        var overlayingShiftedAx = opts.overlayingShiftedAx || [];
        var i, sp, plotinfo;
        ax.setScale();
        var fullLayout = gd._fullLayout;
        var axId = ax._id;
        var axLetter = axId.charAt(0);
        var counterLetter = axes.counterLetter(axId);
        var mainPlotinfo = fullLayout._plots[ax._mainSubplot];
        if (!mainPlotinfo) return;
        ax._shiftPusher = ax.autoshift || overlayingShiftedAx.indexOf(ax._id) !== -1 || overlayingShiftedAx.indexOf(ax.overlaying) !== -1;
        if (ax._shiftPusher & ax.anchor === "free") {
          var selfPush = ax.linewidth / 2 || 0;
          if (ax.ticks === "inside") {
            selfPush += ax.ticklen;
          }
          incrementShift(ax, selfPush, axShifts, true);
          incrementShift(ax, ax.shift || 0, axShifts, false);
        }
        if (opts.skipTitle !== true || ax._shift === void 0) ax._shift = setShiftVal(ax, axShifts);
        var mainAxLayer = mainPlotinfo[axLetter + "axislayer"];
        var mainLinePosition = ax._mainLinePosition;
        var mainLinePositionShift = mainLinePosition += ax._shift;
        var mainMirrorPosition = ax._mainMirrorPosition;
        var vals = ax._vals = axes.calcTicks(ax);
        var axInfo = [ax.mirror, mainLinePositionShift, mainMirrorPosition].join("_");
        for (i = 0; i < vals.length; i++) {
          vals[i].axInfo = axInfo;
        }
        ax._selections = {};
        if (ax._tickAngles) ax._prevTickAngles = ax._tickAngles;
        ax._tickAngles = {};
        ax._depth = null;
        var llbboxes = {};
        function getLabelLevelBbox(suffix) {
          var cls = axId + (suffix || "tick");
          if (!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls, mainLinePositionShift);
          return llbboxes[cls];
        }
        if (!ax.visible) return;
        var transTickFn = axes.makeTransTickFn(ax);
        var transTickLabelFn = axes.makeTransTickLabelFn(ax);
        var tickVals;
        var valsClipped;
        var insideTicks = ax.ticks === "inside";
        var outsideTicks = ax.ticks === "outside";
        if (ax.tickson === "boundaries") {
          var boundaryVals = getBoundaryVals(ax, vals);
          valsClipped = axes.clipEnds(ax, boundaryVals);
          tickVals = insideTicks ? valsClipped : boundaryVals;
        } else {
          valsClipped = axes.clipEnds(ax, vals);
          tickVals = insideTicks && ax.ticklabelmode !== "period" ? valsClipped : vals;
        }
        var gridVals = ax._gridVals = valsClipped;
        var dividerVals = getDividerVals(ax, vals);
        if (!fullLayout._hasOnlyLargeSploms) {
          var subplotsWithAx = ax._subplotsWith;
          var finishedGrids = {};
          for (i = 0; i < subplotsWithAx.length; i++) {
            sp = subplotsWithAx[i];
            plotinfo = fullLayout._plots[sp];
            var counterAxis = plotinfo[counterLetter + "axis"];
            var mainCounterID = counterAxis._mainAxis._id;
            if (finishedGrids[mainCounterID]) continue;
            finishedGrids[mainCounterID] = 1;
            var gridPath = axLetter === "x" ? "M0," + counterAxis._offset + "v" + counterAxis._length : "M" + counterAxis._offset + ",0h" + counterAxis._length;
            axes.drawGrid(gd, ax, {
              vals: gridVals,
              counterAxis,
              layer: plotinfo.gridlayer.select("." + axId),
              minorLayer: plotinfo.minorGridlayer.select("." + axId),
              path: gridPath,
              transFn: transTickFn
            });
            axes.drawZeroLine(gd, ax, {
              counterAxis,
              layer: plotinfo.zerolinelayer,
              path: gridPath,
              transFn: transTickFn
            });
          }
        }
        var tickPath;
        var majorTickSigns = axes.getTickSigns(ax);
        var minorTickSigns = axes.getTickSigns(ax, "minor");
        if (ax.ticks || ax.minor && ax.minor.ticks) {
          var majorTickPath = axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[2]);
          var minorTickPath = axes.makeTickPath(ax, mainLinePositionShift, minorTickSigns[2], { minor: true });
          var mirrorMajorTickPath;
          var mirrorMinorTickPath;
          var fullMajorTickPath;
          var fullMinorTickPath;
          if (ax._anchorAxis && ax.mirror && ax.mirror !== true) {
            mirrorMajorTickPath = axes.makeTickPath(ax, mainMirrorPosition, majorTickSigns[3]);
            mirrorMinorTickPath = axes.makeTickPath(ax, mainMirrorPosition, minorTickSigns[3], { minor: true });
            fullMajorTickPath = majorTickPath + mirrorMajorTickPath;
            fullMinorTickPath = minorTickPath + mirrorMinorTickPath;
          } else {
            mirrorMajorTickPath = "";
            mirrorMinorTickPath = "";
            fullMajorTickPath = majorTickPath;
            fullMinorTickPath = minorTickPath;
          }
          if (ax.showdividers && outsideTicks && ax.tickson === "boundaries") {
            var dividerLookup = {};
            for (i = 0; i < dividerVals.length; i++) {
              dividerLookup[dividerVals[i].x] = 1;
            }
            tickPath = function(d) {
              return dividerLookup[d.x] ? mirrorMajorTickPath : fullMajorTickPath;
            };
          } else {
            tickPath = function(d) {
              return d.minor ? fullMinorTickPath : fullMajorTickPath;
            };
          }
        }
        axes.drawTicks(gd, ax, {
          vals: tickVals,
          layer: mainAxLayer,
          path: tickPath,
          transFn: transTickFn
        });
        if (ax.mirror === "allticks") {
          var tickSubplots = Object.keys(ax._linepositions || {});
          for (i = 0; i < tickSubplots.length; i++) {
            sp = tickSubplots[i];
            plotinfo = fullLayout._plots[sp];
            var linepositions = ax._linepositions[sp] || [];
            var p0 = linepositions[0];
            var p1 = linepositions[1];
            var isMinor = linepositions[2];
            var spTickPath = axes.makeTickPath(
              ax,
              p0,
              isMinor ? majorTickSigns[0] : minorTickSigns[0],
              { minor: isMinor }
            ) + axes.makeTickPath(
              ax,
              p1,
              isMinor ? majorTickSigns[1] : minorTickSigns[1],
              { minor: isMinor }
            );
            axes.drawTicks(gd, ax, {
              vals: tickVals,
              layer: plotinfo[axLetter + "axislayer"],
              path: spTickPath,
              transFn: transTickFn
            });
          }
        }
        var seq = [];
        seq.push(function() {
          return axes.drawLabels(gd, ax, {
            vals,
            layer: mainAxLayer,
            plotinfo,
            transFn: transTickLabelFn,
            labelFns: axes.makeLabelFns(ax, mainLinePositionShift)
          });
        });
        if (ax.type === "multicategory") {
          var pad = { x: 2, y: 10 }[axLetter];
          seq.push(function() {
            var bboxKey = { x: "height", y: "width" }[axLetter];
            var standoff = getLabelLevelBbox()[bboxKey] + pad + (ax._tickAngles[axId + "tick"] ? ax.tickfont.size * LINE_SPACING : 0);
            return axes.drawLabels(gd, ax, {
              vals: getSecondaryLabelVals(ax, vals),
              layer: mainAxLayer,
              cls: axId + "tick2",
              repositionOnUpdate: true,
              secondary: true,
              transFn: transTickFn,
              labelFns: axes.makeLabelFns(ax, mainLinePositionShift + standoff * majorTickSigns[4])
            });
          });
          seq.push(function() {
            ax._depth = majorTickSigns[4] * (getLabelLevelBbox("tick2")[ax.side] - mainLinePositionShift);
            return drawDividers(gd, ax, {
              vals: dividerVals,
              layer: mainAxLayer,
              path: axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[4], { len: ax._depth }),
              transFn: transTickFn
            });
          });
        } else if (ax.title.hasOwnProperty("standoff")) {
          seq.push(function() {
            ax._depth = majorTickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePositionShift);
          });
        }
        var hasRangeSlider = Registry.getComponentMethod("rangeslider", "isVisible")(ax);
        if (!opts.skipTitle && !(hasRangeSlider && ax.side === "bottom")) {
          seq.push(function() {
            return drawTitle(gd, ax);
          });
        }
        seq.push(function() {
          var s = ax.side.charAt(0);
          var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);
          var pos = axes.getPxPosition(gd, ax);
          var outsideTickLen = outsideTicks ? ax.ticklen : 0;
          var llbbox;
          var push;
          var mirrorPush;
          var rangeSliderPush;
          if (ax.automargin || hasRangeSlider || ax._shiftPusher) {
            if (ax.type === "multicategory") {
              llbbox = getLabelLevelBbox("tick2");
            } else {
              llbbox = getLabelLevelBbox();
              if (axLetter === "x" && s === "b") {
                ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);
              }
            }
          }
          var axDepth = 0;
          var titleDepth = 0;
          if (ax._shiftPusher) {
            axDepth = Math.max(
              outsideTickLen,
              llbbox.height > 0 ? s === "l" ? pos - llbbox.left : llbbox.right - pos : 0
            );
            if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
              titleDepth = (ax._titleStandoff || 0) + (ax._titleScoot || 0);
              if (s === "l") {
                titleDepth += approxTitleDepth(ax);
              }
            }
            ax._fullDepth = Math.max(axDepth, titleDepth);
          }
          if (ax.automargin) {
            push = { x: 0, y: 0, r: 0, l: 0, t: 0, b: 0 };
            var domainIndices = [0, 1];
            var shift = typeof ax._shift === "number" ? ax._shift : 0;
            if (axLetter === "x") {
              if (s === "b") {
                push[s] = ax._depth;
              } else {
                push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);
                domainIndices.reverse();
              }
              if (llbbox.width > 0) {
                var rExtra = llbbox.right - (ax._offset + ax._length);
                if (rExtra > 0) {
                  push.xr = 1;
                  push.r = rExtra;
                }
                var lExtra = ax._offset - llbbox.left;
                if (lExtra > 0) {
                  push.xl = 0;
                  push.l = lExtra;
                }
              }
            } else {
              if (s === "l") {
                ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);
                push[s] = ax._depth - shift;
              } else {
                ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);
                push[s] = ax._depth + shift;
                domainIndices.reverse();
              }
              if (llbbox.height > 0) {
                var bExtra = llbbox.bottom - (ax._offset + ax._length);
                if (bExtra > 0) {
                  push.yb = 0;
                  push.b = bExtra;
                }
                var tExtra = ax._offset - llbbox.top;
                if (tExtra > 0) {
                  push.yt = 1;
                  push.t = tExtra;
                }
              }
            }
            push[counterLetter] = ax.anchor === "free" ? ax.position : ax._anchorAxis.domain[domainIndices[0]];
            if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
              push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);
            }
            if (ax.mirror && ax.anchor !== "free") {
              mirrorPush = { x: 0, y: 0, r: 0, l: 0, t: 0, b: 0 };
              mirrorPush[sMirror] = ax.linewidth;
              if (ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;
              if (ax.mirror === true || ax.mirror === "ticks") {
                mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];
              } else if (ax.mirror === "all" || ax.mirror === "allticks") {
                mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];
              }
            }
          }
          if (hasRangeSlider) {
            rangeSliderPush = Registry.getComponentMethod("rangeslider", "autoMarginOpts")(gd, ax);
          }
          if (typeof ax.automargin === "string") {
            filterPush(push, ax.automargin);
            filterPush(mirrorPush, ax.automargin);
          }
          Plots.autoMargin(gd, axAutoMarginID(ax), push);
          Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);
          Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);
        });
        return Lib.syncOrAsync(seq);
      };
      function filterPush(push, automargin) {
        if (!push) return;
        var keepMargin = Object.keys(MARGIN_MAPPING).reduce(function(data, nextKey) {
          if (automargin.indexOf(nextKey) !== -1) {
            MARGIN_MAPPING[nextKey].forEach(function(key) {
              data[key] = 1;
            });
          }
          return data;
        }, {});
        Object.keys(push).forEach(function(key) {
          if (!keepMargin[key]) {
            if (key.length === 1) push[key] = 0;
            else delete push[key];
          }
        });
      }
      function getBoundaryVals(ax, vals) {
        var out = [];
        var i;
        var _push = function(d, bndIndex) {
          var xb = d.xbnd[bndIndex];
          if (xb !== null) {
            out.push(Lib.extendFlat({}, d, { x: xb }));
          }
        };
        if (vals.length) {
          for (i = 0; i < vals.length; i++) {
            _push(vals[i], 0);
          }
          _push(vals[i - 1], 1);
        }
        return out;
      }
      function getSecondaryLabelVals(ax, vals) {
        var out = [];
        var lookup = {};
        for (var i = 0; i < vals.length; i++) {
          var d = vals[i];
          if (lookup[d.text2]) {
            lookup[d.text2].push(d.x);
          } else {
            lookup[d.text2] = [d.x];
          }
        }
        for (var k in lookup) {
          out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));
        }
        return out;
      }
      function getDividerVals(ax, vals) {
        var out = [];
        var i, current;
        var reversed = vals.length && vals[vals.length - 1].x < vals[0].x;
        var _push = function(d2, bndIndex) {
          var xb = d2.xbnd[bndIndex];
          if (xb !== null) {
            out.push(Lib.extendFlat({}, d2, { x: xb }));
          }
        };
        if (ax.showdividers && vals.length) {
          for (i = 0; i < vals.length; i++) {
            var d = vals[i];
            if (d.text2 !== current) {
              _push(d, reversed ? 1 : 0);
            }
            current = d.text2;
          }
          _push(vals[i - 1], reversed ? 0 : 1);
        }
        return out;
      }
      function calcLabelLevelBbox(ax, cls, mainLinePositionShift) {
        var top, bottom;
        var left, right;
        if (ax._selections[cls].size()) {
          top = Infinity;
          bottom = -Infinity;
          left = Infinity;
          right = -Infinity;
          ax._selections[cls].each(function() {
            var thisLabel = selectTickLabel(this);
            var bb = Drawing.bBox(thisLabel.node().parentNode);
            top = Math.min(top, bb.top);
            bottom = Math.max(bottom, bb.bottom);
            left = Math.min(left, bb.left);
            right = Math.max(right, bb.right);
          });
        } else {
          var dummyCalc = axes.makeLabelFns(ax, mainLinePositionShift);
          top = bottom = dummyCalc.yFn({ dx: 0, dy: 0, fontSize: 0 });
          left = right = dummyCalc.xFn({ dx: 0, dy: 0, fontSize: 0 });
        }
        return {
          top,
          bottom,
          left,
          right,
          height: bottom - top,
          width: right - left
        };
      }
      axes.getTickSigns = function(ax, minor) {
        var axLetter = ax._id.charAt(0);
        var sideOpposite = { x: "top", y: "right" }[axLetter];
        var main = ax.side === sideOpposite ? 1 : -1;
        var out = [-1, 1, main, -main];
        var ticks = minor ? (ax.minor || {}).ticks : ax.ticks;
        if (ticks !== "inside" === (axLetter === "x")) {
          out = out.map(function(v) {
            return -v;
          });
        }
        if (ax.side) {
          out.push({ l: -1, t: -1, r: 1, b: 1 }[ax.side.charAt(0)]);
        }
        return out;
      };
      axes.makeTransTickFn = function(ax) {
        return ax._id.charAt(0) === "x" ? function(d) {
          return strTranslate(ax._offset + ax.l2p(d.x), 0);
        } : function(d) {
          return strTranslate(0, ax._offset + ax.l2p(d.x));
        };
      };
      axes.makeTransTickLabelFn = function(ax) {
        var uv = getTickLabelUV(ax);
        var shift = ax.ticklabelshift || 0;
        var standoff = ax.ticklabelstandoff || 0;
        var u = uv[0];
        var v = uv[1];
        var isReversed = ax.range[0] > ax.range[1];
        var labelsInside = ax.ticklabelposition && ax.ticklabelposition.indexOf("inside") !== -1;
        var labelsOutside = !labelsInside;
        if (shift) {
          var shiftSign = isReversed ? -1 : 1;
          shift = shift * shiftSign;
        }
        if (standoff) {
          var side = ax.side;
          var standoffSign = labelsInside && (side === "top" || side === "left") || labelsOutside && (side === "bottom" || side === "right") ? 1 : -1;
          standoff = standoff * standoffSign;
        }
        return ax._id.charAt(0) === "x" ? function(d) {
          return strTranslate(
            u + ax._offset + ax.l2p(getPosX(d)) + shift,
            v + standoff
          );
        } : function(d) {
          return strTranslate(
            v + standoff,
            u + ax._offset + ax.l2p(getPosX(d)) + shift
          );
        };
      };
      function getPosX(d) {
        return d.periodX !== void 0 ? d.periodX : d.x;
      }
      function getTickLabelUV(ax) {
        var ticklabelposition = ax.ticklabelposition || "";
        var has = function(str) {
          return ticklabelposition.indexOf(str) !== -1;
        };
        var isTop = has("top");
        var isLeft = has("left");
        var isRight = has("right");
        var isBottom = has("bottom");
        var isInside = has("inside");
        var isAligned = isBottom || isLeft || isTop || isRight;
        if (!isAligned && !isInside) return [0, 0];
        var side = ax.side;
        var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;
        var v = TEXTPAD;
        var fontSize = ax.tickfont ? ax.tickfont.size : 12;
        if (isBottom || isTop) {
          u += fontSize * CAP_SHIFT;
          v += (ax.linewidth || 0) / 2;
        }
        if (isLeft || isRight) {
          u += (ax.linewidth || 0) / 2;
          v += TEXTPAD;
        }
        if (isInside && side === "top") {
          v -= fontSize * (1 - CAP_SHIFT);
        }
        if (isLeft || isTop) u = -u;
        if (side === "bottom" || side === "right") v = -v;
        return [
          isAligned ? u : 0,
          isInside ? v : 0
        ];
      }
      axes.makeTickPath = function(ax, shift, sgn, opts) {
        if (!opts) opts = {};
        var minor = opts.minor;
        if (minor && !ax.minor) return "";
        var len = opts.len !== void 0 ? opts.len : minor ? ax.minor.ticklen : ax.ticklen;
        var axLetter = ax._id.charAt(0);
        var pad = (ax.linewidth || 1) / 2;
        return axLetter === "x" ? "M0," + (shift + pad * sgn) + "v" + len * sgn : "M" + (shift + pad * sgn) + ",0h" + len * sgn;
      };
      axes.makeLabelFns = function(ax, shift, angle) {
        var ticklabelposition = ax.ticklabelposition || "";
        var has = function(str) {
          return ticklabelposition.indexOf(str) !== -1;
        };
        var isTop = has("top");
        var isLeft = has("left");
        var isRight = has("right");
        var isBottom = has("bottom");
        var isAligned = isBottom || isLeft || isTop || isRight;
        var insideTickLabels = has("inside");
        var labelsOverTicks = ticklabelposition === "inside" && ax.ticks === "inside" || !insideTickLabels && ax.ticks === "outside" && ax.tickson !== "boundaries";
        var labelStandoff = 0;
        var labelShift = 0;
        var tickLen = labelsOverTicks ? ax.ticklen : 0;
        if (insideTickLabels) {
          tickLen *= -1;
        } else if (isAligned) {
          tickLen = 0;
        }
        if (labelsOverTicks) {
          labelStandoff += tickLen;
          if (angle) {
            var rad = Lib.deg2rad(angle);
            labelStandoff = tickLen * Math.cos(rad) + 1;
            labelShift = tickLen * Math.sin(rad);
          }
        }
        if (ax.showticklabels && (labelsOverTicks || ax.showline)) {
          labelStandoff += 0.2 * ax.tickfont.size;
        }
        labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);
        var out = {
          labelStandoff,
          labelShift
        };
        var x0, y0, ff, flipIt;
        var xQ = 0;
        var side = ax.side;
        var axLetter = ax._id.charAt(0);
        var tickangle = ax.tickangle;
        var endSide;
        if (axLetter === "x") {
          endSide = !insideTickLabels && side === "bottom" || insideTickLabels && side === "top";
          flipIt = endSide ? 1 : -1;
          if (insideTickLabels) flipIt *= -1;
          x0 = labelShift * flipIt;
          y0 = shift + labelStandoff * flipIt;
          ff = endSide ? 1 : -0.2;
          if (Math.abs(tickangle) === 90) {
            if (insideTickLabels) {
              ff += MID_SHIFT;
            } else {
              if (tickangle === -90 && side === "bottom") {
                ff = CAP_SHIFT;
              } else if (tickangle === 90 && side === "top") {
                ff = MID_SHIFT;
              } else {
                ff = 0.5;
              }
            }
            xQ = MID_SHIFT / 2 * (tickangle / 90);
          }
          out.xFn = function(d) {
            return d.dx + x0 + xQ * d.fontSize;
          };
          out.yFn = function(d) {
            return d.dy + y0 + d.fontSize * ff;
          };
          out.anchorFn = function(d, a) {
            if (isAligned) {
              if (isLeft) return "end";
              if (isRight) return "start";
            }
            if (!isNumeric(a) || a === 0 || a === 180) {
              return "middle";
            }
            return a * flipIt < 0 !== insideTickLabels ? "end" : "start";
          };
          out.heightFn = function(d, a, h) {
            return a < -60 || a > 60 ? -0.5 * h : ax.side === "top" !== insideTickLabels ? -h : 0;
          };
        } else if (axLetter === "y") {
          endSide = !insideTickLabels && side === "left" || insideTickLabels && side === "right";
          flipIt = endSide ? 1 : -1;
          if (insideTickLabels) flipIt *= -1;
          x0 = labelStandoff;
          y0 = labelShift * flipIt;
          ff = 0;
          if (!insideTickLabels && Math.abs(tickangle) === 90) {
            if (tickangle === -90 && side === "left" || tickangle === 90 && side === "right") {
              ff = CAP_SHIFT;
            } else {
              ff = 0.5;
            }
          }
          if (insideTickLabels) {
            var ang = isNumeric(tickangle) ? +tickangle : 0;
            if (ang !== 0) {
              var rA = Lib.deg2rad(ang);
              xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;
              ff = 0;
            }
          }
          out.xFn = function(d) {
            return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize;
          };
          out.yFn = function(d) {
            return d.dy + y0 + d.fontSize * MID_SHIFT;
          };
          out.anchorFn = function(d, a) {
            if (isNumeric(a) && Math.abs(a) === 90) {
              return "middle";
            }
            return endSide ? "end" : "start";
          };
          out.heightFn = function(d, a, h) {
            if (ax.side === "right") a *= -1;
            return a < -30 ? -h : a < 30 ? -0.5 * h : 0;
          };
        }
        return out;
      };
      function tickDataFn(d) {
        return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join("_");
      }
      axes.drawTicks = function(gd, ax, opts) {
        opts = opts || {};
        var cls = ax._id + "tick";
        var vals = [].concat(
          ax.minor && ax.minor.ticks ? (
            // minor vals
            opts.vals.filter(function(d) {
              return d.minor && !d.noTick;
            })
          ) : []
        ).concat(
          ax.ticks ? (
            // major vals
            opts.vals.filter(function(d) {
              return !d.minor && !d.noTick;
            })
          ) : []
        );
        var ticks = opts.layer.selectAll("path." + cls).data(vals, tickDataFn);
        ticks.exit().remove();
        ticks.enter().append("path").classed(cls, 1).classed("ticks", 1).classed("crisp", opts.crisp !== false).each(function(d) {
          return Color.stroke(d3.select(this), d.minor ? ax.minor.tickcolor : ax.tickcolor);
        }).style("stroke-width", function(d) {
          return Drawing.crispRound(
            gd,
            d.minor ? ax.minor.tickwidth : ax.tickwidth,
            1
          ) + "px";
        }).attr("d", opts.path).style("display", null);
        hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);
        ticks.attr("transform", opts.transFn);
      };
      axes.drawGrid = function(gd, ax, opts) {
        opts = opts || {};
        if (ax.tickmode === "sync") {
          return;
        }
        var cls = ax._id + "grid";
        var hasMinor = ax.minor && ax.minor.showgrid;
        var minorVals = hasMinor ? opts.vals.filter(function(d) {
          return d.minor;
        }) : [];
        var majorVals = ax.showgrid ? opts.vals.filter(function(d) {
          return !d.minor;
        }) : [];
        var counterAx = opts.counterAxis;
        if (counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {
          var isArrayMode = ax.tickmode === "array";
          for (var i = 0; i < majorVals.length; i++) {
            var xi = majorVals[i].x;
            if (isArrayMode ? !xi : Math.abs(xi) < ax.dtick / 100) {
              majorVals = majorVals.slice(0, i).concat(majorVals.slice(i + 1));
              if (isArrayMode) i--;
              else break;
            }
          }
        }
        ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);
        var wMinor = !hasMinor ? 0 : Drawing.crispRound(gd, ax.minor.gridwidth, 1);
        var majorLayer = opts.layer;
        var minorLayer = opts.minorLayer;
        for (var major = 1; major >= 0; major--) {
          var layer = major ? majorLayer : minorLayer;
          if (!layer) continue;
          var grid = layer.selectAll("path." + cls).data(major ? majorVals : minorVals, tickDataFn);
          grid.exit().remove();
          grid.enter().append("path").classed(cls, 1).classed("crisp", opts.crisp !== false);
          grid.attr("transform", opts.transFn).attr("d", opts.path).each(function(d) {
            return Color.stroke(
              d3.select(this),
              d.minor ? ax.minor.gridcolor : ax.gridcolor || "#ddd"
            );
          }).style("stroke-dasharray", function(d) {
            return Drawing.dashStyle(
              d.minor ? ax.minor.griddash : ax.griddash,
              d.minor ? ax.minor.gridwidth : ax.gridwidth
            );
          }).style("stroke-width", function(d) {
            return (d.minor ? wMinor : ax._gw) + "px";
          }).style("display", null);
          if (typeof opts.path === "function") grid.attr("d", opts.path);
        }
        hideCounterAxisInsideTickLabels(ax, [GRID_PATH, MINORGRID_PATH]);
      };
      axes.drawZeroLine = function(gd, ax, opts) {
        opts = opts || opts;
        var cls = ax._id + "zl";
        var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);
        var zl = opts.layer.selectAll("path." + cls).data(show ? [{ x: 0, id: ax._id }] : []);
        zl.exit().remove();
        zl.enter().append("path").classed(cls, 1).classed("zl", 1).classed("crisp", opts.crisp !== false).each(function() {
          opts.layer.selectAll("path").sort(function(da, db) {
            return idSort(da.id, db.id);
          });
        });
        zl.attr("transform", opts.transFn).attr("d", opts.path).call(Color.stroke, ax.zerolinecolor || Color.defaultLine).style("stroke-width", Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + "px").style("display", null);
        hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);
      };
      axes.drawLabels = function(gd, ax, opts) {
        opts = opts || {};
        var fullLayout = gd._fullLayout;
        var axId = ax._id;
        var cls = opts.cls || axId + "tick";
        var vals = opts.vals.filter(function(d) {
          return d.text;
        });
        var labelFns = opts.labelFns;
        var tickAngle = opts.secondary ? 0 : ax.tickangle;
        var prevAngle = (ax._prevTickAngles || {})[cls];
        var tickLabels = opts.layer.selectAll("g." + cls).data(ax.showticklabels ? vals : [], tickDataFn);
        var labelsReady = [];
        tickLabels.enter().append("g").classed(cls, 1).append("text").attr("text-anchor", "middle").each(function(d) {
          var thisLabel = d3.select(this);
          var newPromise = gd._promises.length;
          thisLabel.call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d)).call(Drawing.font, {
            family: d.font,
            size: d.fontSize,
            color: d.fontColor,
            weight: d.fontWeight,
            style: d.fontStyle,
            variant: d.fontVariant,
            textcase: d.fontTextcase,
            lineposition: d.fontLineposition,
            shadow: d.fontShadow
          }).text(d.text).call(svgTextUtils.convertToTspans, gd);
          if (gd._promises[newPromise]) {
            labelsReady.push(gd._promises.pop().then(function() {
              positionLabels(thisLabel, tickAngle);
            }));
          } else {
            positionLabels(thisLabel, tickAngle);
          }
        });
        hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);
        tickLabels.exit().remove();
        if (opts.repositionOnUpdate) {
          tickLabels.each(function(d) {
            d3.select(this).select("text").call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));
          });
        }
        function positionLabels(s, angle) {
          s.each(function(d) {
            var thisLabel = d3.select(this);
            var mathjaxGroup = thisLabel.select(".text-math-group");
            var anchor = labelFns.anchorFn(d, angle);
            var transform = opts.transFn.call(thisLabel.node(), d) + (isNumeric(angle) && +angle !== 0 ? " rotate(" + angle + "," + labelFns.xFn(d) + "," + (labelFns.yFn(d) - d.fontSize / 2) + ")" : "");
            var nLines = svgTextUtils.lineCount(thisLabel);
            var lineHeight = LINE_SPACING * d.fontSize;
            var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);
            if (anchorHeight) {
              transform += strTranslate(0, anchorHeight);
            }
            if (mathjaxGroup.empty()) {
              var thisText = thisLabel.select("text");
              thisText.attr({
                transform,
                "text-anchor": anchor
              });
              thisText.style("opacity", 1);
              if (ax._adjustTickLabelsOverflow) {
                ax._adjustTickLabelsOverflow();
              }
            } else {
              var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;
              var mjShift = mjWidth * { end: -0.5, start: 0.5 }[anchor];
              mathjaxGroup.attr("transform", transform + strTranslate(mjShift, 0));
            }
          });
        }
        ax._adjustTickLabelsOverflow = function() {
          var ticklabeloverflow = ax.ticklabeloverflow;
          if (!ticklabeloverflow || ticklabeloverflow === "allow") return;
          var hideOverflow = ticklabeloverflow.indexOf("hide") !== -1;
          var isX = ax._id.charAt(0) === "x";
          var p02 = 0;
          var p12 = isX ? gd._fullLayout.width : gd._fullLayout.height;
          if (ticklabeloverflow.indexOf("domain") !== -1) {
            var rl = Lib.simpleMap(ax.range, ax.r2l);
            p02 = ax.l2p(rl[0]) + ax._offset;
            p12 = ax.l2p(rl[1]) + ax._offset;
          }
          var min = Math.min(p02, p12);
          var max = Math.max(p02, p12);
          var side = ax.side;
          var visibleLabelMin = Infinity;
          var visibleLabelMax = -Infinity;
          tickLabels.each(function(d) {
            var thisLabel = d3.select(this);
            var mathjaxGroup = thisLabel.select(".text-math-group");
            if (mathjaxGroup.empty()) {
              var bb = Drawing.bBox(thisLabel.node());
              var adjust = 0;
              if (isX) {
                if (bb.right > max) adjust = 1;
                else if (bb.left < min) adjust = 1;
              } else {
                if (bb.bottom > max) adjust = 1;
                else if (bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;
              }
              var t = thisLabel.select("text");
              if (adjust) {
                if (hideOverflow) t.style("opacity", 0);
              } else {
                t.style("opacity", 1);
                if (side === "bottom" || side === "right") {
                  visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);
                } else {
                  visibleLabelMin = -Infinity;
                }
                if (side === "top" || side === "left") {
                  visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);
                } else {
                  visibleLabelMax = Infinity;
                }
              }
            }
          });
          for (var subplot in fullLayout._plots) {
            var plotinfo = fullLayout._plots[subplot];
            if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
            var anchorAx2 = isX ? plotinfo.yaxis : plotinfo.xaxis;
            if (anchorAx2) {
              anchorAx2["_visibleLabelMin_" + ax._id] = visibleLabelMin;
              anchorAx2["_visibleLabelMax_" + ax._id] = visibleLabelMax;
            }
          }
        };
        ax._hideCounterAxisInsideTickLabels = function(partialOpts) {
          var isX = ax._id.charAt(0) === "x";
          var anchoredAxes = [];
          for (var subplot in fullLayout._plots) {
            var plotinfo = fullLayout._plots[subplot];
            if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
            anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);
          }
          anchoredAxes.forEach(function(anchorAx2, idx) {
            if (anchorAx2 && insideTicklabelposition(anchorAx2)) {
              (partialOpts || [
                ZERO_PATH,
                MINORGRID_PATH,
                GRID_PATH,
                TICK_PATH,
                TICK_TEXT
              ]).forEach(function(e) {
                var isPeriodLabel = e.K === "tick" && e.L === "text" && ax.ticklabelmode === "period";
                var mainPlotinfo = fullLayout._plots[ax._mainSubplot];
                var sel;
                if (e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll("." + ax._id + "zl");
                else if (e.K === MINORGRID_PATH.K) sel = mainPlotinfo.minorGridlayer.selectAll("." + ax._id);
                else if (e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll("." + ax._id);
                else sel = mainPlotinfo[ax._id.charAt(0) + "axislayer"];
                sel.each(function() {
                  var w = d3.select(this);
                  if (e.L) w = w.selectAll(e.L);
                  w.each(function(d) {
                    var q = ax.l2p(
                      isPeriodLabel ? getPosX(d) : d.x
                    ) + ax._offset;
                    var t = d3.select(this);
                    if (q < ax["_visibleLabelMax_" + anchorAx2._id] && q > ax["_visibleLabelMin_" + anchorAx2._id]) {
                      t.style("display", "none");
                    } else if (e.K === "tick" && !idx) {
                      t.style("display", null);
                    }
                  });
                });
              });
            }
          });
        };
        positionLabels(tickLabels, prevAngle + 1 ? prevAngle : tickAngle);
        function allLabelsReady() {
          return labelsReady.length && Promise.all(labelsReady);
        }
        var autoangle = null;
        function fixLabelOverlaps() {
          positionLabels(tickLabels, tickAngle);
          if (vals.length && ax.autotickangles && (ax.type !== "log" || String(ax.dtick).charAt(0) !== "D")) {
            autoangle = ax.autotickangles[0];
            var maxFontSize = 0;
            var lbbArray = [];
            var i;
            var maxLines = 1;
            tickLabels.each(function(d) {
              maxFontSize = Math.max(maxFontSize, d.fontSize);
              var x = ax.l2p(d.x);
              var thisLabel = selectTickLabel(this);
              var bb = Drawing.bBox(thisLabel.node());
              maxLines = Math.max(maxLines, svgTextUtils.lineCount(thisLabel));
              lbbArray.push({
                // ignore about y, just deal with x overlaps
                top: 0,
                bottom: 10,
                height: 10,
                left: x - bb.width / 2,
                // impose a 2px gap
                right: x + bb.width / 2 + 2,
                width: bb.width + 2
              });
            });
            var preventOverlapWithTick = (ax.tickson === "boundaries" || ax.showdividers) && !opts.secondary;
            var vLen = vals.length;
            var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);
            var adjacent = preventOverlapWithTick ? tickSpacing / 2 : tickSpacing;
            var opposite = preventOverlapWithTick ? ax.ticklen : maxFontSize * 1.25 * maxLines;
            var hypotenuse = Math.sqrt(Math.pow(adjacent, 2) + Math.pow(opposite, 2));
            var maxCos = adjacent / hypotenuse;
            var autoTickAnglesRadians = ax.autotickangles.map(
              function(degrees) {
                return degrees * Math.PI / 180;
              }
            );
            var angleRadians = autoTickAnglesRadians.find(
              function(angle) {
                return Math.abs(Math.cos(angle)) <= maxCos;
              }
            );
            if (angleRadians === void 0) {
              angleRadians = autoTickAnglesRadians.reduce(
                function(currentMax, nextAngle) {
                  return Math.abs(Math.cos(currentMax)) < Math.abs(Math.cos(nextAngle)) ? currentMax : nextAngle;
                },
                autoTickAnglesRadians[0]
              );
            }
            var newAngle = angleRadians * (180 / Math.PI);
            if (preventOverlapWithTick) {
              var gap = 2;
              if (ax.ticks) gap += ax.tickwidth / 2;
              for (i = 0; i < lbbArray.length; i++) {
                var xbnd = vals[i].xbnd;
                var lbb = lbbArray[i];
                if (xbnd[0] !== null && lbb.left - ax.l2p(xbnd[0]) < gap || xbnd[1] !== null && ax.l2p(xbnd[1]) - lbb.right < gap) {
                  autoangle = newAngle;
                  break;
                }
              }
            } else {
              var ticklabelposition = ax.ticklabelposition || "";
              var has = function(str) {
                return ticklabelposition.indexOf(str) !== -1;
              };
              var isTop = has("top");
              var isLeft = has("left");
              var isRight = has("right");
              var isBottom = has("bottom");
              var isAligned = isBottom || isLeft || isTop || isRight;
              var pad = !isAligned ? 0 : (ax.tickwidth || 0) + 2 * TEXTPAD;
              for (i = 0; i < lbbArray.length - 1; i++) {
                if (Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {
                  autoangle = newAngle;
                  break;
                }
              }
            }
            if (autoangle) {
              positionLabels(tickLabels, autoangle);
            }
          }
        }
        if (ax._selections) {
          ax._selections[cls] = tickLabels;
        }
        var seq = [allLabelsReady];
        if (ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {
          autoangle = prevAngle;
          seq.push(function() {
            positionLabels(tickLabels, prevAngle);
          });
        } else {
          seq.push(fixLabelOverlaps);
        }
        if (ax._tickAngles) {
          seq.push(function() {
            ax._tickAngles[cls] = autoangle === null ? isNumeric(tickAngle) ? tickAngle : 0 : autoangle;
          });
        }
        var computeTickLabelBoundingBoxes = function() {
          var labelsMaxW = 0;
          var labelsMaxH = 0;
          tickLabels.each(function(d, i) {
            var thisLabel = selectTickLabel(this);
            var mathjaxGroup = thisLabel.select(".text-math-group");
            if (mathjaxGroup.empty()) {
              var bb;
              if (ax._vals[i]) {
                bb = ax._vals[i].bb || Drawing.bBox(thisLabel.node());
                ax._vals[i].bb = bb;
              }
              labelsMaxW = Math.max(labelsMaxW, bb.width);
              labelsMaxH = Math.max(labelsMaxH, bb.height);
            }
          });
          return {
            labelsMaxW,
            labelsMaxH
          };
        };
        var anchorAx = ax._anchorAxis;
        if (anchorAx && (anchorAx.autorange || anchorAx.insiderange) && insideTicklabelposition(ax) && !isLinked(fullLayout, ax._id)) {
          if (!fullLayout._insideTickLabelsUpdaterange) {
            fullLayout._insideTickLabelsUpdaterange = {};
          }
          if (anchorAx.autorange) {
            fullLayout._insideTickLabelsUpdaterange[anchorAx._name + ".autorange"] = anchorAx.autorange;
            seq.push(computeTickLabelBoundingBoxes);
          }
          if (anchorAx.insiderange) {
            var BBs = computeTickLabelBoundingBoxes();
            var move = ax._id.charAt(0) === "y" ? BBs.labelsMaxW : BBs.labelsMaxH;
            move += 2 * TEXTPAD;
            if (ax.ticklabelposition === "inside") {
              move += ax.ticklen || 0;
            }
            var sgn = ax.side === "right" || ax.side === "top" ? 1 : -1;
            var index = sgn === 1 ? 1 : 0;
            var otherIndex = sgn === 1 ? 0 : 1;
            var newRange = [];
            newRange[otherIndex] = anchorAx.range[otherIndex];
            var anchorAxRange = anchorAx.range;
            var p0 = anchorAx.r2p(anchorAxRange[index]);
            var p1 = anchorAx.r2p(anchorAxRange[otherIndex]);
            var _tempNewRange = fullLayout._insideTickLabelsUpdaterange[anchorAx._name + ".range"];
            if (_tempNewRange) {
              var q0 = anchorAx.r2p(_tempNewRange[index]);
              var q1 = anchorAx.r2p(_tempNewRange[otherIndex]);
              var dir = sgn * (ax._id.charAt(0) === "y" ? 1 : -1);
              if (dir * p0 < dir * q0) {
                p0 = q0;
                newRange[index] = anchorAxRange[index] = _tempNewRange[index];
              }
              if (dir * p1 > dir * q1) {
                p1 = q1;
                newRange[otherIndex] = anchorAxRange[otherIndex] = _tempNewRange[otherIndex];
              }
            }
            var dist = Math.abs(p1 - p0);
            if (dist - move > 0) {
              dist -= move;
              move *= 1 + move / dist;
            } else {
              move = 0;
            }
            if (ax._id.charAt(0) !== "y") move = -move;
            newRange[index] = anchorAx.p2r(
              anchorAx.r2p(anchorAxRange[index]) + sgn * move
            );
            if (anchorAx.autorange === "min" || anchorAx.autorange === "max reversed") {
              newRange[0] = null;
              anchorAx._rangeInitial0 = void 0;
              anchorAx._rangeInitial1 = void 0;
            } else if (anchorAx.autorange === "max" || anchorAx.autorange === "min reversed") {
              newRange[1] = null;
              anchorAx._rangeInitial0 = void 0;
              anchorAx._rangeInitial1 = void 0;
            }
            fullLayout._insideTickLabelsUpdaterange[anchorAx._name + ".range"] = newRange;
          }
        }
        var done = Lib.syncOrAsync(seq);
        if (done && done.then) gd._promises.push(done);
        return done;
      };
      function drawDividers(gd, ax, opts) {
        var cls = ax._id + "divider";
        var vals = opts.vals;
        var dividers = opts.layer.selectAll("path." + cls).data(vals, tickDataFn);
        dividers.exit().remove();
        dividers.enter().insert("path", ":first-child").classed(cls, 1).classed("crisp", 1).call(Color.stroke, ax.dividercolor).style("stroke-width", Drawing.crispRound(gd, ax.dividerwidth, 1) + "px");
        dividers.attr("transform", opts.transFn).attr("d", opts.path);
      }
      axes.getPxPosition = function(gd, ax) {
        var gs = gd._fullLayout._size;
        var axLetter = ax._id.charAt(0);
        var side = ax.side;
        var anchorAxis;
        if (ax.anchor !== "free") {
          anchorAxis = ax._anchorAxis;
        } else if (axLetter === "x") {
          anchorAxis = {
            _offset: gs.t + (1 - (ax.position || 0)) * gs.h,
            _length: 0
          };
        } else if (axLetter === "y") {
          anchorAxis = {
            _offset: gs.l + (ax.position || 0) * gs.w + ax._shift,
            _length: 0
          };
        }
        if (side === "top" || side === "left") {
          return anchorAxis._offset;
        } else if (side === "bottom" || side === "right") {
          return anchorAxis._offset + anchorAxis._length;
        }
      };
      function approxTitleDepth(ax) {
        var fontSize = ax.title.font.size;
        var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
        if (ax.title.hasOwnProperty("standoff")) {
          return fontSize * (CAP_SHIFT + extraLines * LINE_SPACING);
        } else {
          return extraLines ? fontSize * (extraLines + 1) * LINE_SPACING : fontSize;
        }
      }
      function drawTitle(gd, ax) {
        var fullLayout = gd._fullLayout;
        var axId = ax._id;
        var axLetter = axId.charAt(0);
        var fontSize = ax.title.font.size;
        var titleStandoff;
        var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
        if (ax.title.hasOwnProperty("standoff")) {
          if (ax.side === "bottom" || ax.side === "right") {
            titleStandoff = ax._depth + ax.title.standoff + fontSize * CAP_SHIFT;
          } else if (ax.side === "top" || ax.side === "left") {
            titleStandoff = ax._depth + ax.title.standoff + fontSize * (MID_SHIFT + extraLines * LINE_SPACING);
          }
        } else {
          var isInside = insideTicklabelposition(ax);
          if (ax.type === "multicategory") {
            titleStandoff = ax._depth;
          } else {
            var offsetBase = 1.5 * fontSize;
            if (isInside) {
              offsetBase = 0.5 * fontSize;
              if (ax.ticks === "outside") {
                offsetBase += ax.ticklen;
              }
            }
            titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);
          }
          if (!isInside) {
            if (axLetter === "x") {
              titleStandoff += ax.side === "top" ? fontSize * (ax.showticklabels ? 1 : 0) : fontSize * (ax.showticklabels ? 1.5 : 0.5);
            } else {
              titleStandoff += ax.side === "right" ? fontSize * (ax.showticklabels ? 1 : 0.5) : fontSize * (ax.showticklabels ? 0.5 : 0);
            }
          }
        }
        var pos = axes.getPxPosition(gd, ax);
        var transform, x, y;
        if (axLetter === "x") {
          x = ax._offset + ax._length / 2;
          y = ax.side === "top" ? pos - titleStandoff : pos + titleStandoff;
        } else {
          y = ax._offset + ax._length / 2;
          x = ax.side === "right" ? pos + titleStandoff : pos - titleStandoff;
          transform = { rotate: "-90", offset: 0 };
        }
        var avoid;
        if (ax.type !== "multicategory") {
          var tickLabels = ax._selections[ax._id + "tick"];
          avoid = {
            selection: tickLabels,
            side: ax.side
          };
          if (tickLabels && tickLabels.node() && tickLabels.node().parentNode) {
            var translation = Drawing.getTranslate(tickLabels.node().parentNode);
            avoid.offsetLeft = translation.x;
            avoid.offsetTop = translation.y;
          }
          if (ax.title.hasOwnProperty("standoff")) {
            avoid.pad = 0;
          }
        }
        ax._titleStandoff = titleStandoff;
        return Titles.draw(gd, axId + "title", {
          propContainer: ax,
          propName: ax._name + ".title.text",
          placeholder: fullLayout._dfltTitle[axLetter],
          avoid,
          transform,
          attributes: { x, y, "text-anchor": "middle" }
        });
      }
      axes.shouldShowZeroLine = function(gd, ax, counterAxis) {
        var rng = Lib.simpleMap(ax.range, ax.r2l);
        return rng[0] * rng[1] <= 0 && ax.zeroline && (ax.type === "linear" || ax.type === "-") && !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) && (clipEnds(ax, 0) || !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) || hasBarsOrFill(gd, ax));
      };
      axes.clipEnds = function(ax, vals) {
        return vals.filter(function(d) {
          return clipEnds(ax, d.x);
        });
      };
      function clipEnds(ax, l) {
        var p = ax.l2p(l);
        return p > 1 && p < ax._length - 1;
      }
      function anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {
        var mainCounterAxis = counterAxis._mainAxis;
        if (!mainCounterAxis) return;
        var fullLayout = gd._fullLayout;
        var axLetter = ax._id.charAt(0);
        var counterLetter = axes.counterLetter(ax._id);
        var zeroPosition = ax._offset + (Math.abs(rng[0]) < Math.abs(rng[1]) === (axLetter === "x") ? 0 : ax._length);
        function lineNearZero(ax2) {
          if (!ax2.showline || !ax2.linewidth) return false;
          var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);
          function closeEnough(pos2) {
            return typeof pos2 === "number" && Math.abs(pos2 - zeroPosition) < tolerance;
          }
          if (closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {
            return true;
          }
          var linePositions = ax2._linepositions || {};
          for (var k in linePositions) {
            if (closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {
              return true;
            }
          }
        }
        var plotinfo = fullLayout._plots[counterAxis._mainSubplot];
        if (!(plotinfo.mainplotinfo || plotinfo).overlays.length) {
          return lineNearZero(counterAxis, zeroPosition);
        }
        var counterLetterAxes = axes.list(gd, counterLetter);
        for (var i = 0; i < counterLetterAxes.length; i++) {
          var counterAxis2 = counterLetterAxes[i];
          if (counterAxis2._mainAxis === mainCounterAxis && lineNearZero(counterAxis2, zeroPosition)) {
            return true;
          }
        }
      }
      function hasBarsOrFill(gd, ax) {
        var fullData = gd._fullData;
        var subplot = ax._mainSubplot;
        var axLetter = ax._id.charAt(0);
        for (var i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          if (trace.visible === true && trace.xaxis + trace.yaxis === subplot) {
            if (Registry.traceIs(trace, "bar-like") && trace.orientation === { x: "h", y: "v" }[axLetter]) return true;
            if (trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter) return true;
          }
        }
        return false;
      }
      function selectTickLabel(gTick) {
        var s = d3.select(gTick);
        var mj = s.select(".text-math-group");
        return mj.empty() ? s.select("text") : mj;
      }
      axes.allowAutoMargin = function(gd) {
        var axList = axes.list(gd, "", true);
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          if (ax.automargin) {
            Plots.allowAutoMargin(gd, axAutoMarginID(ax));
            if (ax.mirror) {
              Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));
            }
          }
          if (Registry.getComponentMethod("rangeslider", "isVisible")(ax)) {
            Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));
          }
        }
      };
      function axAutoMarginID(ax) {
        return ax._id + ".automargin";
      }
      function axMirrorAutoMarginID(ax) {
        return axAutoMarginID(ax) + ".mirror";
      }
      function rangeSliderAutoMarginID(ax) {
        return ax._id + ".rangeslider";
      }
      axes.swap = function(gd, traces) {
        var axGroups = makeAxisGroups(gd, traces);
        for (var i = 0; i < axGroups.length; i++) {
          swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);
        }
      };
      function makeAxisGroups(gd, traces) {
        var groups = [];
        var i, j;
        for (i = 0; i < traces.length; i++) {
          var groupsi = [];
          var xi = gd._fullData[traces[i]].xaxis;
          var yi = gd._fullData[traces[i]].yaxis;
          if (!xi || !yi) continue;
          for (j = 0; j < groups.length; j++) {
            if (groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {
              groupsi.push(j);
            }
          }
          if (!groupsi.length) {
            groups.push({ x: [xi], y: [yi] });
            continue;
          }
          var group0 = groups[groupsi[0]];
          var groupj;
          if (groupsi.length > 1) {
            for (j = 1; j < groupsi.length; j++) {
              groupj = groups[groupsi[j]];
              mergeAxisGroups(group0.x, groupj.x);
              mergeAxisGroups(group0.y, groupj.y);
            }
          }
          mergeAxisGroups(group0.x, [xi]);
          mergeAxisGroups(group0.y, [yi]);
        }
        return groups;
      }
      function mergeAxisGroups(intoSet, fromSet) {
        for (var i = 0; i < fromSet.length; i++) {
          if (intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);
        }
      }
      function swapAxisGroup(gd, xIds, yIds) {
        var xFullAxes = [];
        var yFullAxes = [];
        var layout = gd.layout;
        var i, j;
        for (i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));
        for (i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));
        var allAxKeys = Object.keys(axAttrs);
        var noSwapAttrs = [
          "anchor",
          "domain",
          "overlaying",
          "position",
          "side",
          "tickangle",
          "editType"
        ];
        var numericTypes = ["linear", "log"];
        for (i = 0; i < allAxKeys.length; i++) {
          var keyi = allAxKeys[i];
          var xVal = xFullAxes[0][keyi];
          var yVal = yFullAxes[0][keyi];
          var allEqual = true;
          var coerceLinearX = false;
          var coerceLinearY = false;
          if (keyi.charAt(0) === "_" || typeof xVal === "function" || noSwapAttrs.indexOf(keyi) !== -1) {
            continue;
          }
          for (j = 1; j < xFullAxes.length && allEqual; j++) {
            var xVali = xFullAxes[j][keyi];
            if (keyi === "type" && numericTypes.indexOf(xVal) !== -1 && numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {
              coerceLinearX = true;
            } else if (xVali !== xVal) allEqual = false;
          }
          for (j = 1; j < yFullAxes.length && allEqual; j++) {
            var yVali = yFullAxes[j][keyi];
            if (keyi === "type" && numericTypes.indexOf(yVal) !== -1 && numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {
              coerceLinearY = true;
            } else if (yFullAxes[j][keyi] !== yVal) allEqual = false;
          }
          if (allEqual) {
            if (coerceLinearX) layout[xFullAxes[0]._name].type = "linear";
            if (coerceLinearY) layout[yFullAxes[0]._name].type = "linear";
            swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);
          }
        }
        for (i = 0; i < gd._fullLayout.annotations.length; i++) {
          var ann = gd._fullLayout.annotations[i];
          if (xIds.indexOf(ann.xref) !== -1 && yIds.indexOf(ann.yref) !== -1) {
            Lib.swapAttrs(layout.annotations[i], ["?"]);
          }
        }
      }
      function swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {
        var np = Lib.nestedProperty;
        var xVal = np(layout[xFullAxes[0]._name], key).get();
        var yVal = np(layout[yFullAxes[0]._name], key).get();
        var i;
        if (key === "title") {
          if (xVal && xVal.text === dfltTitle.x) {
            xVal.text = dfltTitle.y;
          }
          if (yVal && yVal.text === dfltTitle.y) {
            yVal.text = dfltTitle.x;
          }
        }
        for (i = 0; i < xFullAxes.length; i++) {
          np(layout, xFullAxes[i]._name + "." + key).set(yVal);
        }
        for (i = 0; i < yFullAxes.length; i++) {
          np(layout, yFullAxes[i]._name + "." + key).set(xVal);
        }
      }
      function isAngular(ax) {
        return ax._id === "angularaxis";
      }
      function moveOutsideBreak(v, ax) {
        var len = ax._rangebreaks.length;
        for (var k = 0; k < len; k++) {
          var brk = ax._rangebreaks[k];
          if (v >= brk.min && v < brk.max) {
            return brk.max;
          }
        }
        return v;
      }
      function insideTicklabelposition(ax) {
        return (ax.ticklabelposition || "").indexOf("inside") !== -1;
      }
      function hideCounterAxisInsideTickLabels(ax, opts) {
        if (insideTicklabelposition(ax._anchorAxis || {})) {
          if (ax._hideCounterAxisInsideTickLabels) {
            ax._hideCounterAxisInsideTickLabels(opts);
          }
        }
      }
      function incrementShift(ax, shiftVal, axShifts, normalize) {
        var overlay = ax.anchor !== "free" && (ax.overlaying === void 0 || ax.overlaying === false) ? ax._id : ax.overlaying;
        var shiftValAdj;
        if (normalize) {
          shiftValAdj = ax.side === "right" ? shiftVal : -shiftVal;
        } else {
          shiftValAdj = shiftVal;
        }
        if (!(overlay in axShifts)) {
          axShifts[overlay] = {};
        }
        if (!(ax.side in axShifts[overlay])) {
          axShifts[overlay][ax.side] = 0;
        }
        axShifts[overlay][ax.side] += shiftValAdj;
      }
      function setShiftVal(ax, axShifts) {
        return ax.autoshift ? axShifts[ax.overlaying][ax.side] : ax.shift || 0;
      }
      function periodCompatibleWithTickformat(period, tickformat) {
        return /%f/.test(tickformat) ? period >= ONEMICROSEC : /%L/.test(tickformat) ? period >= ONEMILLI : /%[SX]/.test(tickformat) ? period >= ONESEC : /%M/.test(tickformat) ? period >= ONEMIN : /%[HI]/.test(tickformat) ? period >= ONEHOUR : /%p/.test(tickformat) ? period >= HALFDAY : /%[Aadejuwx]/.test(tickformat) ? period >= ONEDAY : /%[UVW]/.test(tickformat) ? period >= ONEWEEK : /%[Bbm]/.test(tickformat) ? period >= ONEMINMONTH : /%[q]/.test(tickformat) ? period >= ONEMINQUARTER : /%[Yy]/.test(tickformat) ? period >= ONEMINYEAR : true;
      }
    }
  });

  // src/plots/cartesian/autorange_options_defaults.js
  var require_autorange_options_defaults = __commonJS({
    "src/plots/cartesian/autorange_options_defaults.js"(exports, module) {
      "use strict";
      module.exports = function handleAutorangeOptionsDefaults(coerce, autorange, range) {
        var minRange, maxRange;
        if (range) {
          var isReversed = autorange === "reversed" || autorange === "min reversed" || autorange === "max reversed";
          minRange = range[isReversed ? 1 : 0];
          maxRange = range[isReversed ? 0 : 1];
        }
        var minallowed = coerce("autorangeoptions.minallowed", maxRange === null ? minRange : void 0);
        var maxallowed = coerce("autorangeoptions.maxallowed", minRange === null ? maxRange : void 0);
        if (minallowed === void 0) coerce("autorangeoptions.clipmin");
        if (maxallowed === void 0) coerce("autorangeoptions.clipmax");
        coerce("autorangeoptions.include");
      };
    }
  });

  // src/plots/cartesian/range_defaults.js
  var require_range_defaults = __commonJS({
    "src/plots/cartesian/range_defaults.js"(exports, module) {
      "use strict";
      var handleAutorangeOptionsDefaults = require_autorange_options_defaults();
      module.exports = function handleRangeDefaults(containerIn, containerOut, coerce, options) {
        var axTemplate = containerOut._template || {};
        var axType = containerOut.type || axTemplate.type || "-";
        coerce("minallowed");
        coerce("maxallowed");
        var range = coerce("range");
        if (!range) {
          var insiderange;
          if (!options.noInsiderange && axType !== "log") {
            insiderange = coerce("insiderange");
            if (insiderange && (insiderange[0] === null || insiderange[1] === null)) {
              containerOut.insiderange = false;
              insiderange = void 0;
            }
            if (insiderange) range = coerce("range", insiderange);
          }
        }
        var autorangeDflt = containerOut.getAutorangeDflt(range, options);
        var autorange = coerce("autorange", autorangeDflt);
        var shouldAutorange;
        if (range && (range[0] === null && range[1] === null || (range[0] === null || range[1] === null) && (autorange === "reversed" || autorange === true) || range[0] !== null && (autorange === "min" || autorange === "max reversed") || range[1] !== null && (autorange === "max" || autorange === "min reversed"))) {
          range = void 0;
          delete containerOut.range;
          containerOut.autorange = true;
          shouldAutorange = true;
        }
        if (!shouldAutorange) {
          autorangeDflt = containerOut.getAutorangeDflt(range, options);
          autorange = coerce("autorange", autorangeDflt);
        }
        if (autorange) {
          handleAutorangeOptionsDefaults(coerce, autorange, range);
          if (axType === "linear" || axType === "-") coerce("rangemode");
        }
        containerOut.cleanRange();
      };
    }
  });

  // node_modules/mouse-event-offset/index.js
  var require_mouse_event_offset = __commonJS({
    "node_modules/mouse-event-offset/index.js"(exports, module) {
      var rootPosition = { left: 0, top: 0 };
      module.exports = mouseEventOffset;
      function mouseEventOffset(ev, target, out) {
        target = target || ev.currentTarget || ev.srcElement;
        if (!Array.isArray(out)) {
          out = [0, 0];
        }
        var cx = ev.clientX || 0;
        var cy = ev.clientY || 0;
        var rect = getBoundingClientOffset(target);
        out[0] = cx - rect.left;
        out[1] = cy - rect.top;
        return out;
      }
      function getBoundingClientOffset(element) {
        if (element === window || element === document || element === document.body) {
          return rootPosition;
        } else {
          return element.getBoundingClientRect();
        }
      }
    }
  });

  // node_modules/has-passive-events/index.js
  var require_has_passive_events = __commonJS({
    "node_modules/has-passive-events/index.js"(exports, module) {
      "use strict";
      var isBrowser = require_client();
      function detect() {
        var supported = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supported = true;
            }
          });
          window.addEventListener("test", null, opts);
          window.removeEventListener("test", null, opts);
        } catch (e) {
          supported = false;
        }
        return supported;
      }
      module.exports = isBrowser && detect();
    }
  });

  // src/components/dragelement/align.js
  var require_align = __commonJS({
    "src/components/dragelement/align.js"(exports, module) {
      "use strict";
      module.exports = function align(v, dv, v0, v1, anchor) {
        var vmin = (v - v0) / (v1 - v0);
        var vmax = vmin + dv / (v1 - v0);
        var vc = (vmin + vmax) / 2;
        if (anchor === "left" || anchor === "bottom") return vmin;
        if (anchor === "center" || anchor === "middle") return vc;
        if (anchor === "right" || anchor === "top") return vmax;
        if (vmin < 2 / 3 - vc) return vmin;
        if (vmax > 4 / 3 - vc) return vmax;
        return vc;
      };
    }
  });

  // src/components/dragelement/cursor.js
  var require_cursor = __commonJS({
    "src/components/dragelement/cursor.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var cursorset = [
        ["sw-resize", "s-resize", "se-resize"],
        ["w-resize", "move", "e-resize"],
        ["nw-resize", "n-resize", "ne-resize"]
      ];
      module.exports = function getCursor(x, y, xanchor, yanchor) {
        if (xanchor === "left") x = 0;
        else if (xanchor === "center") x = 1;
        else if (xanchor === "right") x = 2;
        else x = Lib.constrain(Math.floor(x * 3), 0, 2);
        if (yanchor === "bottom") y = 0;
        else if (yanchor === "middle") y = 1;
        else if (yanchor === "top") y = 2;
        else y = Lib.constrain(Math.floor(y * 3), 0, 2);
        return cursorset[y][x];
      };
    }
  });

  // src/components/dragelement/unhover.js
  var require_unhover = __commonJS({
    "src/components/dragelement/unhover.js"(exports, module) {
      "use strict";
      var Events = require_events2();
      var throttle = require_throttle();
      var getGraphDiv = require_dom().getGraphDiv;
      var hoverConstants = require_constants();
      var unhover = module.exports = {};
      unhover.wrapped = function(gd, evt, subplot) {
        gd = getGraphDiv(gd);
        if (gd._fullLayout) {
          throttle.clear(gd._fullLayout._uid + hoverConstants.HOVERID);
        }
        unhover.raw(gd, evt, subplot);
      };
      unhover.raw = function raw(gd, evt) {
        var fullLayout = gd._fullLayout;
        var oldhoverdata = gd._hoverdata;
        if (!evt) evt = {};
        if (evt.target && !gd._dragged && Events.triggerHandler(gd, "plotly_beforehover", evt) === false) {
          return;
        }
        fullLayout._hoverlayer.selectAll("g").remove();
        fullLayout._hoverlayer.selectAll("line").remove();
        fullLayout._hoverlayer.selectAll("circle").remove();
        gd._hoverdata = void 0;
        if (evt.target && oldhoverdata) {
          gd.emit("plotly_unhover", {
            event: evt,
            points: oldhoverdata
          });
        }
      };
    }
  });

  // src/components/dragelement/index.js
  var require_dragelement = __commonJS({
    "src/components/dragelement/index.js"(exports, module) {
      "use strict";
      var mouseOffset = require_mouse_event_offset();
      var hasHover = require_has_hover();
      var supportsPassive = require_has_passive_events();
      var removeElement = require_lib().removeElement;
      var constants = require_constants2();
      var dragElement = module.exports = {};
      dragElement.align = require_align();
      dragElement.getCursor = require_cursor();
      var unhover = require_unhover();
      dragElement.unhover = unhover.wrapped;
      dragElement.unhoverRaw = unhover.raw;
      dragElement.init = function init(options) {
        var gd = options.gd;
        var numClicks = 1;
        var doubleClickDelay = gd._context.doubleClickDelay;
        var element = options.element;
        var startX, startY, newMouseDownTime, cursor, dragCover, initialEvent, initialTarget, rightClick;
        if (!gd._mouseDownTime) gd._mouseDownTime = 0;
        element.style.pointerEvents = "all";
        element.onmousedown = onStart;
        if (!supportsPassive) {
          element.ontouchstart = onStart;
        } else {
          if (element._ontouchstart) {
            element.removeEventListener("touchstart", element._ontouchstart);
          }
          element._ontouchstart = onStart;
          element.addEventListener("touchstart", onStart, { passive: false });
        }
        function _clampFn(dx, dy, minDrag) {
          if (Math.abs(dx) < minDrag) dx = 0;
          if (Math.abs(dy) < minDrag) dy = 0;
          return [dx, dy];
        }
        var clampFn = options.clampFn || _clampFn;
        function onStart(e) {
          gd._dragged = false;
          gd._dragging = true;
          var offset = pointerOffset(e);
          startX = offset[0];
          startY = offset[1];
          initialTarget = e.target;
          initialEvent = e;
          rightClick = e.buttons === 2 || e.ctrlKey;
          if (typeof e.clientX === "undefined" && typeof e.clientY === "undefined") {
            e.clientX = startX;
            e.clientY = startY;
          }
          newMouseDownTime = (/* @__PURE__ */ new Date()).getTime();
          if (newMouseDownTime - gd._mouseDownTime < doubleClickDelay) {
            numClicks += 1;
          } else {
            numClicks = 1;
            gd._mouseDownTime = newMouseDownTime;
          }
          if (options.prepFn) options.prepFn(e, startX, startY);
          if (hasHover && !rightClick) {
            dragCover = coverSlip();
            dragCover.style.cursor = window.getComputedStyle(element).cursor;
          } else if (!hasHover) {
            dragCover = document;
            cursor = window.getComputedStyle(document.documentElement).cursor;
            document.documentElement.style.cursor = window.getComputedStyle(element).cursor;
          }
          document.addEventListener("mouseup", onDone);
          document.addEventListener("touchend", onDone);
          if (options.dragmode !== false) {
            e.preventDefault();
            document.addEventListener("mousemove", onMove);
            document.addEventListener("touchmove", onMove, { passive: false });
          }
          return;
        }
        function onMove(e) {
          e.preventDefault();
          var offset = pointerOffset(e);
          var minDrag = options.minDrag || constants.MINDRAG;
          var dxdy = clampFn(offset[0] - startX, offset[1] - startY, minDrag);
          var dx = dxdy[0];
          var dy = dxdy[1];
          if (dx || dy) {
            gd._dragged = true;
            dragElement.unhover(gd, e);
          }
          if (gd._dragged && options.moveFn && !rightClick) {
            gd._dragdata = {
              element,
              dx,
              dy
            };
            options.moveFn(dx, dy);
          }
          return;
        }
        function onDone(e) {
          delete gd._dragdata;
          if (options.dragmode !== false) {
            e.preventDefault();
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("touchmove", onMove);
          }
          document.removeEventListener("mouseup", onDone);
          document.removeEventListener("touchend", onDone);
          if (hasHover) {
            removeElement(dragCover);
          } else if (cursor) {
            dragCover.documentElement.style.cursor = cursor;
            cursor = null;
          }
          if (!gd._dragging) {
            gd._dragged = false;
            return;
          }
          gd._dragging = false;
          if ((/* @__PURE__ */ new Date()).getTime() - gd._mouseDownTime > doubleClickDelay) {
            numClicks = Math.max(numClicks - 1, 1);
          }
          if (gd._dragged) {
            if (options.doneFn) options.doneFn();
          } else {
            var clickEvent;
            if (initialEvent.target === initialTarget) {
              clickEvent = initialEvent;
            } else {
              clickEvent = {
                target: initialTarget,
                srcElement: initialTarget,
                toElement: initialTarget
              };
              Object.keys(initialEvent).concat(Object.keys(initialEvent.__proto__)).forEach((k) => {
                var v = initialEvent[k];
                if (!clickEvent[k] && typeof v !== "function") {
                  clickEvent[k] = v;
                }
              });
            }
            if (options.clickFn) options.clickFn(numClicks, clickEvent);
            if (!rightClick) {
              initialTarget.dispatchEvent(new MouseEvent("click", e));
            }
          }
          gd._dragging = false;
          gd._dragged = false;
          return;
        }
      };
      function coverSlip() {
        var cover = document.createElement("div");
        cover.className = "dragcover";
        var cStyle = cover.style;
        cStyle.position = "fixed";
        cStyle.left = 0;
        cStyle.right = 0;
        cStyle.top = 0;
        cStyle.bottom = 0;
        cStyle.zIndex = 999999999;
        cStyle.background = "none";
        document.body.appendChild(cover);
        return cover;
      }
      dragElement.coverSlip = coverSlip;
      function pointerOffset(e) {
        return mouseOffset(
          e.changedTouches ? e.changedTouches[0] : e,
          document.body
        );
      }
    }
  });

  // src/lib/setcursor.js
  var require_setcursor = __commonJS({
    "src/lib/setcursor.js"(exports, module) {
      "use strict";
      module.exports = function setCursor(el3, csr) {
        (el3.attr("class") || "").split(" ").forEach(function(cls) {
          if (cls.indexOf("cursor-") === 0) el3.classed(cls, false);
        });
        if (csr) el3.classed("cursor-" + csr, true);
      };
    }
  });

  // src/lib/override_cursor.js
  var require_override_cursor = __commonJS({
    "src/lib/override_cursor.js"(exports, module) {
      "use strict";
      var setCursor = require_setcursor();
      var STASHATTR = "data-savedcursor";
      var NO_CURSOR = "!!";
      module.exports = function overrideCursor(el3, csr) {
        var savedCursor = el3.attr(STASHATTR);
        if (csr) {
          if (!savedCursor) {
            var classes = (el3.attr("class") || "").split(" ");
            for (var i = 0; i < classes.length; i++) {
              var cls = classes[i];
              if (cls.indexOf("cursor-") === 0) {
                el3.attr(STASHATTR, cls.substr(7)).classed(cls, false);
              }
            }
            if (!el3.attr(STASHATTR)) {
              el3.attr(STASHATTR, NO_CURSOR);
            }
          }
          setCursor(el3, csr);
        } else if (savedCursor) {
          el3.attr(STASHATTR, null);
          if (savedCursor === NO_CURSOR) setCursor(el3);
          else setCursor(el3, savedCursor);
        }
      };
    }
  });

  // src/components/legend/attributes.js
  var require_attributes9 = __commonJS({
    "src/components/legend/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      module.exports = {
        // not really a 'subplot' attribute container,
        // but this is the flag we use to denote attributes that
        // support yaxis, yaxis2, yaxis3, ... counters
        _isSubplotObj: true,
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "legend"
        },
        bgcolor: {
          valType: "color",
          editType: "legend"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "legend"
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "legend"
        },
        font: fontAttrs({
          editType: "legend"
        }),
        grouptitlefont: fontAttrs({
          editType: "legend"
        }),
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          dflt: "v",
          editType: "legend"
        },
        traceorder: {
          valType: "flaglist",
          flags: ["reversed", "grouped"],
          extras: ["normal"],
          editType: "legend"
        },
        tracegroupgap: {
          valType: "number",
          min: 0,
          dflt: 10,
          editType: "legend"
        },
        entrywidth: {
          valType: "number",
          min: 0,
          editType: "legend"
        },
        entrywidthmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "pixels",
          editType: "legend"
        },
        indentation: {
          valType: "number",
          min: -15,
          dflt: 0,
          editType: "legend"
        },
        itemsizing: {
          valType: "enumerated",
          values: ["trace", "constant"],
          dflt: "trace",
          editType: "legend"
        },
        itemwidth: {
          valType: "number",
          min: 30,
          dflt: 30,
          editType: "legend"
        },
        itemclick: {
          valType: "enumerated",
          values: ["toggle", "toggleothers", false],
          dflt: "toggle",
          editType: "legend"
        },
        itemdoubleclick: {
          valType: "enumerated",
          values: ["toggle", "toggleothers", false],
          dflt: "toggleothers",
          editType: "legend"
        },
        groupclick: {
          valType: "enumerated",
          values: ["toggleitem", "togglegroup"],
          dflt: "togglegroup",
          editType: "legend"
        },
        x: {
          valType: "number",
          editType: "legend"
        },
        xref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "left",
          editType: "legend"
        },
        y: {
          valType: "number",
          editType: "legend"
        },
        yref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          editType: "legend"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        valign: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"],
          dflt: "middle",
          editType: "legend"
        },
        title: {
          text: {
            valType: "string",
            dflt: "",
            editType: "legend"
          },
          font: fontAttrs({
            editType: "legend"
          }),
          side: {
            valType: "enumerated",
            values: ["top", "left", "top left", "top center", "top right"],
            editType: "legend"
          },
          editType: "legend"
        },
        editType: "legend"
      };
    }
  });

  // src/components/legend/helpers.js
  var require_helpers3 = __commonJS({
    "src/components/legend/helpers.js"(exports) {
      "use strict";
      exports.isGrouped = function isGrouped(legendLayout) {
        return (legendLayout.traceorder || "").indexOf("grouped") !== -1;
      };
      exports.isVertical = function isVertical(legendLayout) {
        return legendLayout.orientation !== "h";
      };
      exports.isReversed = function isReversed(legendLayout) {
        return (legendLayout.traceorder || "").indexOf("reversed") !== -1;
      };
    }
  });

  // src/components/legend/defaults.js
  var require_defaults3 = __commonJS({
    "src/components/legend/defaults.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var Template = require_plot_template();
      var plotsAttrs = require_attributes2();
      var attributes = require_attributes9();
      var basePlotLayoutAttributes = require_layout_attributes2();
      var helpers = require_helpers3();
      function groupDefaults(legendId, layoutIn, layoutOut, fullData) {
        var containerIn = layoutIn[legendId] || {};
        var containerOut = Template.newContainer(layoutOut, legendId);
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        var itemFont = Lib.coerceFont(coerce, "font", layoutOut.font);
        coerce("bgcolor", layoutOut.paper_bgcolor);
        coerce("bordercolor");
        var visible = coerce("visible");
        if (!visible) return;
        var trace;
        var traceCoerce = function(attr, dflt) {
          var traceIn = trace._input;
          var traceOut = trace;
          return Lib.coerce(traceIn, traceOut, plotsAttrs, attr, dflt);
        };
        var globalFont = layoutOut.font || {};
        var grouptitlefont = Lib.coerceFont(coerce, "grouptitlefont", globalFont, { overrideDflt: {
          size: Math.round(globalFont.size * 1.1)
        } });
        var legendTraceCount = 0;
        var legendReallyHasATrace = false;
        var defaultOrder = "normal";
        var shapesWithLegend = (layoutOut.shapes || []).filter(function(d) {
          return d.showlegend;
        });
        var allLegendItems = fullData.concat(shapesWithLegend).filter(function(d) {
          return legendId === (d.legend || "legend");
        });
        for (var i = 0; i < allLegendItems.length; i++) {
          trace = allLegendItems[i];
          if (!trace.visible) continue;
          var isShape = trace._isShape;
          if (trace.showlegend || trace._dfltShowLegend && !(trace._module && trace._module.attributes && trace._module.attributes.showlegend && trace._module.attributes.showlegend.dflt === false)) {
            legendTraceCount++;
            if (trace.showlegend) {
              legendReallyHasATrace = true;
              if (!isShape && Registry.traceIs(trace, "pie-like") || trace._input.showlegend === true) {
                legendTraceCount++;
              }
            }
            Lib.coerceFont(traceCoerce, "legendgrouptitle.font", grouptitlefont);
          }
          if (!isShape && Registry.traceIs(trace, "bar") && layoutOut.barmode === "stack" || ["tonextx", "tonexty"].indexOf(trace.fill) !== -1) {
            defaultOrder = helpers.isGrouped({ traceorder: defaultOrder }) ? "grouped+reversed" : "reversed";
          }
          if (trace.legendgroup !== void 0 && trace.legendgroup !== "") {
            defaultOrder = helpers.isReversed({ traceorder: defaultOrder }) ? "reversed+grouped" : "grouped";
          }
        }
        var showLegend = Lib.coerce(
          layoutIn,
          layoutOut,
          basePlotLayoutAttributes,
          "showlegend",
          legendReallyHasATrace && legendTraceCount > (legendId === "legend" ? 1 : 0)
        );
        if (showLegend === false) layoutOut[legendId] = void 0;
        if (showLegend === false && !containerIn.uirevision) return;
        coerce("uirevision", layoutOut.uirevision);
        if (showLegend === false) return;
        coerce("borderwidth");
        var orientation = coerce("orientation");
        var yref = coerce("yref");
        var xref = coerce("xref");
        var isHorizontal = orientation === "h";
        var isPaperY = yref === "paper";
        var isPaperX = xref === "paper";
        var defaultX, defaultY, defaultYAnchor;
        var defaultXAnchor = "left";
        if (isHorizontal) {
          defaultX = 0;
          if (Registry.getComponentMethod("rangeslider", "isVisible")(layoutIn.xaxis)) {
            if (isPaperY) {
              defaultY = 1.1;
              defaultYAnchor = "bottom";
            } else {
              defaultY = 1;
              defaultYAnchor = "top";
            }
          } else {
            if (isPaperY) {
              defaultY = -0.1;
              defaultYAnchor = "top";
            } else {
              defaultY = 0;
              defaultYAnchor = "bottom";
            }
          }
        } else {
          defaultY = 1;
          defaultYAnchor = "auto";
          if (isPaperX) {
            defaultX = 1.02;
          } else {
            defaultX = 1;
            defaultXAnchor = "right";
          }
        }
        Lib.coerce(containerIn, containerOut, {
          x: {
            valType: "number",
            editType: "legend",
            min: isPaperX ? -2 : 0,
            max: isPaperX ? 3 : 1,
            dflt: defaultX
          }
        }, "x");
        Lib.coerce(containerIn, containerOut, {
          y: {
            valType: "number",
            editType: "legend",
            min: isPaperY ? -2 : 0,
            max: isPaperY ? 3 : 1,
            dflt: defaultY
          }
        }, "y");
        coerce("traceorder", defaultOrder);
        if (helpers.isGrouped(layoutOut[legendId])) coerce("tracegroupgap");
        coerce("entrywidth");
        coerce("entrywidthmode");
        coerce("indentation");
        coerce("itemsizing");
        coerce("itemwidth");
        coerce("itemclick");
        coerce("itemdoubleclick");
        coerce("groupclick");
        coerce("xanchor", defaultXAnchor);
        coerce("yanchor", defaultYAnchor);
        coerce("valign");
        Lib.noneOrAll(containerIn, containerOut, ["x", "y"]);
        var titleText = coerce("title.text");
        if (titleText) {
          coerce("title.side", isHorizontal ? "left" : "top");
          var dfltTitleFont = Lib.extendFlat({}, itemFont, {
            size: Lib.bigFont(itemFont.size)
          });
          Lib.coerceFont(coerce, "title.font", dfltTitleFont);
        }
      }
      module.exports = function legendDefaults(layoutIn, layoutOut, fullData) {
        var i;
        var allLegendsData = fullData.slice();
        var shapes = layoutOut.shapes;
        if (shapes) {
          for (i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            if (!shape.showlegend) continue;
            var mockTrace = {
              _input: shape._input,
              visible: shape.visible,
              showlegend: shape.showlegend,
              legend: shape.legend
            };
            allLegendsData.push(mockTrace);
          }
        }
        var legends = ["legend"];
        for (i = 0; i < allLegendsData.length; i++) {
          Lib.pushUnique(legends, allLegendsData[i].legend);
        }
        layoutOut._legends = [];
        for (i = 0; i < legends.length; i++) {
          var legendId = legends[i];
          groupDefaults(legendId, layoutIn, layoutOut, allLegendsData);
          if (layoutOut[legendId] && layoutOut[legendId].visible) {
            layoutOut[legendId]._id = legendId;
          }
          layoutOut._legends.push(legendId);
        }
      };
    }
  });

  // src/components/legend/handle_click.js
  var require_handle_click = __commonJS({
    "src/components/legend/handle_click.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var pushUnique = Lib.pushUnique;
      var SHOWISOLATETIP = true;
      module.exports = function handleClick(g, gd, numClicks) {
        var fullLayout = gd._fullLayout;
        if (gd._dragged || gd._editing) return;
        var itemClick = fullLayout.legend.itemclick;
        var itemDoubleClick = fullLayout.legend.itemdoubleclick;
        var groupClick = fullLayout.legend.groupclick;
        if (numClicks === 1 && itemClick === "toggle" && itemDoubleClick === "toggleothers" && SHOWISOLATETIP && gd.data && gd._context.showTips) {
          Lib.notifier(Lib._(gd, "Double-click on legend to isolate one trace"), "long");
          SHOWISOLATETIP = false;
        } else {
          SHOWISOLATETIP = false;
        }
        var mode;
        if (numClicks === 1) mode = itemClick;
        else if (numClicks === 2) mode = itemDoubleClick;
        if (!mode) return;
        var toggleGroup = groupClick === "togglegroup";
        var hiddenSlices = fullLayout.hiddenlabels ? fullLayout.hiddenlabels.slice() : [];
        var legendItem = g.data()[0][0];
        if (legendItem.groupTitle && legendItem.noClick) return;
        var fullData = gd._fullData;
        var shapesWithLegend = (fullLayout.shapes || []).filter(function(d2) {
          return d2.showlegend;
        });
        var allLegendItems = fullData.concat(shapesWithLegend);
        var fullTrace = legendItem.trace;
        if (fullTrace._isShape) {
          fullTrace = fullTrace._fullInput;
        }
        var legendgroup = fullTrace.legendgroup;
        var i, j, kcont, key, keys, val;
        var dataUpdate = {};
        var dataIndices = [];
        var carrs = [];
        var carrIdx = [];
        function insertDataUpdate(traceIndex, value) {
          var attrIndex = dataIndices.indexOf(traceIndex);
          var valueArray = dataUpdate.visible;
          if (!valueArray) {
            valueArray = dataUpdate.visible = [];
          }
          if (dataIndices.indexOf(traceIndex) === -1) {
            dataIndices.push(traceIndex);
            attrIndex = dataIndices.length - 1;
          }
          valueArray[attrIndex] = value;
          return attrIndex;
        }
        var updatedShapes = (fullLayout.shapes || []).map(function(d2) {
          return d2._input;
        });
        var shapesUpdated = false;
        function insertShapesUpdate(shapeIndex, value) {
          updatedShapes[shapeIndex].visible = value;
          shapesUpdated = true;
        }
        function setVisibility(fullTrace2, visibility) {
          if (legendItem.groupTitle && !toggleGroup) return;
          var fullInput2 = fullTrace2._fullInput || fullTrace2;
          var isShape2 = fullInput2._isShape;
          var index = fullInput2.index;
          if (index === void 0) index = fullInput2._index;
          var nextVisibility2 = fullInput2.visible === false ? false : visibility;
          if (isShape2) {
            insertShapesUpdate(index, nextVisibility2);
          } else {
            insertDataUpdate(index, nextVisibility2);
          }
        }
        var thisLegend = fullTrace.legend;
        var fullInput = fullTrace._fullInput;
        var isShape = fullInput && fullInput._isShape;
        if (!isShape && Registry.traceIs(fullTrace, "pie-like")) {
          var thisLabel = legendItem.label;
          var thisLabelIndex = hiddenSlices.indexOf(thisLabel);
          if (mode === "toggle") {
            if (thisLabelIndex === -1) hiddenSlices.push(thisLabel);
            else hiddenSlices.splice(thisLabelIndex, 1);
          } else if (mode === "toggleothers") {
            var changed = thisLabelIndex !== -1;
            var unhideList = [];
            for (i = 0; i < gd.calcdata.length; i++) {
              var cdi = gd.calcdata[i];
              for (j = 0; j < cdi.length; j++) {
                var d = cdi[j];
                var dLabel = d.label;
                if (thisLegend === cdi[0].trace.legend) {
                  if (thisLabel !== dLabel) {
                    if (hiddenSlices.indexOf(dLabel) === -1) changed = true;
                    pushUnique(hiddenSlices, dLabel);
                    unhideList.push(dLabel);
                  }
                }
              }
            }
            if (!changed) {
              for (var q = 0; q < unhideList.length; q++) {
                var pos = hiddenSlices.indexOf(unhideList[q]);
                if (pos !== -1) {
                  hiddenSlices.splice(pos, 1);
                }
              }
            }
          }
          Registry.call("_guiRelayout", gd, "hiddenlabels", hiddenSlices);
        } else {
          var hasLegendgroup = legendgroup && legendgroup.length;
          var traceIndicesInGroup = [];
          var tracei;
          if (hasLegendgroup) {
            for (i = 0; i < allLegendItems.length; i++) {
              tracei = allLegendItems[i];
              if (!tracei.visible) continue;
              if (tracei.legendgroup === legendgroup) {
                traceIndicesInGroup.push(i);
              }
            }
          }
          if (mode === "toggle") {
            var nextVisibility;
            switch (fullTrace.visible) {
              case true:
                nextVisibility = "legendonly";
                break;
              case false:
                nextVisibility = false;
                break;
              case "legendonly":
                nextVisibility = true;
                break;
            }
            if (hasLegendgroup) {
              if (toggleGroup) {
                for (i = 0; i < allLegendItems.length; i++) {
                  var item = allLegendItems[i];
                  if (item.visible !== false && item.legendgroup === legendgroup) {
                    setVisibility(item, nextVisibility);
                  }
                }
              } else {
                setVisibility(fullTrace, nextVisibility);
              }
            } else {
              setVisibility(fullTrace, nextVisibility);
            }
          } else if (mode === "toggleothers") {
            var isClicked, isInGroup, notInLegend, otherState, _item;
            var isIsolated = true;
            for (i = 0; i < allLegendItems.length; i++) {
              _item = allLegendItems[i];
              isClicked = _item === fullTrace;
              notInLegend = _item.showlegend !== true;
              if (isClicked || notInLegend) continue;
              isInGroup = hasLegendgroup && _item.legendgroup === legendgroup;
              if (!isInGroup && _item.legend === thisLegend && _item.visible === true && !Registry.traceIs(_item, "notLegendIsolatable")) {
                isIsolated = false;
                break;
              }
            }
            for (i = 0; i < allLegendItems.length; i++) {
              _item = allLegendItems[i];
              if (_item.visible === false || _item.legend !== thisLegend) continue;
              if (Registry.traceIs(_item, "notLegendIsolatable")) {
                continue;
              }
              switch (fullTrace.visible) {
                case "legendonly":
                  setVisibility(_item, true);
                  break;
                case true:
                  otherState = isIsolated ? true : "legendonly";
                  isClicked = _item === fullTrace;
                  notInLegend = _item.showlegend !== true && !_item.legendgroup;
                  isInGroup = isClicked || hasLegendgroup && _item.legendgroup === legendgroup;
                  setVisibility(_item, isInGroup || notInLegend ? true : otherState);
                  break;
              }
            }
          }
          for (i = 0; i < carrs.length; i++) {
            kcont = carrs[i];
            if (!kcont) continue;
            var update = kcont.constructUpdate();
            var updateKeys = Object.keys(update);
            for (j = 0; j < updateKeys.length; j++) {
              key = updateKeys[j];
              val = dataUpdate[key] = dataUpdate[key] || [];
              val[carrIdx[i]] = update[key];
            }
          }
          keys = Object.keys(dataUpdate);
          for (i = 0; i < keys.length; i++) {
            key = keys[i];
            for (j = 0; j < dataIndices.length; j++) {
              if (!dataUpdate[key].hasOwnProperty(j)) {
                dataUpdate[key][j] = void 0;
              }
            }
          }
          if (shapesUpdated) {
            Registry.call("_guiUpdate", gd, dataUpdate, { shapes: updatedShapes }, dataIndices);
          } else {
            Registry.call("_guiRestyle", gd, dataUpdate, dataIndices);
          }
        }
      };
    }
  });

  // src/components/legend/constants.js
  var require_constants3 = __commonJS({
    "src/components/legend/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        scrollBarWidth: 6,
        scrollBarMinHeight: 20,
        scrollBarColor: "#808BA4",
        scrollBarMargin: 4,
        scrollBarEnterAttrs: { rx: 20, ry: 3, width: 0, height: 0 },
        // number of px between legend title and (left) side of legend (always in x direction and from inner border)
        titlePad: 2,
        // number of px between each legend item (x and/or y direction)
        itemGap: 5
      };
    }
  });

  // src/components/legend/get_legend_data.js
  var require_get_legend_data = __commonJS({
    "src/components/legend/get_legend_data.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var helpers = require_helpers3();
      module.exports = function getLegendData(calcdata, opts, hasMultipleLegends) {
        var inHover = opts._inHover;
        var grouped = helpers.isGrouped(opts);
        var reversed = helpers.isReversed(opts);
        var lgroupToTraces = {};
        var lgroups = [];
        var hasOneNonBlankGroup = false;
        var slicesShown = {};
        var lgroupi = 0;
        var maxNameLength = 0;
        var i, j;
        function addOneItem(legendId, legendGroup, legendItem) {
          if (opts.visible === false) return;
          if (hasMultipleLegends && legendId !== opts._id) return;
          if (legendGroup === "" || !helpers.isGrouped(opts)) {
            var uniqueGroup = "~~i" + lgroupi;
            lgroups.push(uniqueGroup);
            lgroupToTraces[uniqueGroup] = [legendItem];
            lgroupi++;
          } else if (lgroups.indexOf(legendGroup) === -1) {
            lgroups.push(legendGroup);
            hasOneNonBlankGroup = true;
            lgroupToTraces[legendGroup] = [legendItem];
          } else {
            lgroupToTraces[legendGroup].push(legendItem);
          }
        }
        for (i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var cd0 = cd[0];
          var trace = cd0.trace;
          var lid = trace.legend;
          var lgroup = trace.legendgroup;
          if (!inHover && (!trace.visible || !trace.showlegend)) continue;
          if (Registry.traceIs(trace, "pie-like")) {
            if (!slicesShown[lgroup]) slicesShown[lgroup] = {};
            for (j = 0; j < cd.length; j++) {
              var labelj = cd[j].label;
              if (!slicesShown[lgroup][labelj]) {
                addOneItem(lid, lgroup, {
                  label: labelj,
                  color: cd[j].color,
                  i: cd[j].i,
                  trace,
                  pts: cd[j].pts
                });
                slicesShown[lgroup][labelj] = true;
                maxNameLength = Math.max(maxNameLength, (labelj || "").length);
              }
            }
          } else {
            addOneItem(lid, lgroup, cd0);
            maxNameLength = Math.max(maxNameLength, (trace.name || "").length);
          }
        }
        if (!lgroups.length) return [];
        var shouldCollapse = !hasOneNonBlankGroup || !grouped;
        var legendData = [];
        for (i = 0; i < lgroups.length; i++) {
          var t = lgroupToTraces[lgroups[i]];
          if (shouldCollapse) {
            legendData.push(t[0]);
          } else {
            legendData.push(t);
          }
        }
        if (shouldCollapse) legendData = [legendData];
        for (i = 0; i < legendData.length; i++) {
          var groupMinRank = Infinity;
          for (j = 0; j < legendData[i].length; j++) {
            var rank = legendData[i][j].trace.legendrank;
            if (groupMinRank > rank) groupMinRank = rank;
          }
          legendData[i][0]._groupMinRank = groupMinRank;
          legendData[i][0]._preGroupSort = i;
        }
        var orderFn1 = function(a, b) {
          return a[0]._groupMinRank - b[0]._groupMinRank || a[0]._preGroupSort - b[0]._preGroupSort;
        };
        var orderFn2 = function(a, b) {
          return a.trace.legendrank - b.trace.legendrank || a._preSort - b._preSort;
        };
        legendData.forEach(function(a, k) {
          a[0]._preGroupSort = k;
        });
        legendData.sort(orderFn1);
        for (i = 0; i < legendData.length; i++) {
          legendData[i].forEach(function(a, k) {
            a._preSort = k;
          });
          legendData[i].sort(orderFn2);
          var firstItemTrace = legendData[i][0].trace;
          var groupTitle = null;
          for (j = 0; j < legendData[i].length; j++) {
            var gt = legendData[i][j].trace.legendgrouptitle;
            if (gt && gt.text) {
              groupTitle = gt;
              if (inHover) gt.font = opts._groupTitleFont;
              break;
            }
          }
          if (reversed) legendData[i].reverse();
          if (groupTitle) {
            var hasPieLike = false;
            for (j = 0; j < legendData[i].length; j++) {
              if (Registry.traceIs(legendData[i][j].trace, "pie-like")) {
                hasPieLike = true;
                break;
              }
            }
            legendData[i].unshift({
              i: -1,
              groupTitle,
              noClick: hasPieLike,
              trace: {
                showlegend: firstItemTrace.showlegend,
                legendgroup: firstItemTrace.legendgroup,
                visible: opts.groupclick === "toggleitem" ? true : firstItemTrace.visible
              }
            });
          }
          for (j = 0; j < legendData[i].length; j++) {
            legendData[i][j] = [
              legendData[i][j]
            ];
          }
        }
        opts._lgroupsLength = legendData.length;
        opts._maxNameLength = maxNameLength;
        return legendData;
      };
    }
  });

  // src/traces/pie/helpers.js
  var require_helpers4 = __commonJS({
    "src/traces/pie/helpers.js"(exports) {
      "use strict";
      var Lib = require_lib();
      function format(vRounded) {
        return vRounded.indexOf("e") !== -1 ? vRounded.replace(/[.]?0+e/, "e") : vRounded.indexOf(".") !== -1 ? vRounded.replace(/[.]?0+$/, "") : vRounded;
      }
      exports.formatPiePercent = function formatPiePercent(v, separators) {
        var vRounded = format((v * 100).toPrecision(3));
        return Lib.numSeparate(vRounded, separators) + "%";
      };
      exports.formatPieValue = function formatPieValue(v, separators) {
        var vRounded = format(v.toPrecision(10));
        return Lib.numSeparate(vRounded, separators);
      };
      exports.getFirstFilled = function getFirstFilled(array, indices) {
        if (!Lib.isArrayOrTypedArray(array)) return;
        for (var i = 0; i < indices.length; i++) {
          var v = array[indices[i]];
          if (v || v === 0 || v === "") return v;
        }
      };
      exports.castOption = function castOption(item, indices) {
        if (Lib.isArrayOrTypedArray(item)) return exports.getFirstFilled(item, indices);
        else if (item) return item;
      };
      exports.getRotationAngle = function(rotation) {
        return (rotation === "auto" ? 0 : rotation) * Math.PI / 180;
      };
    }
  });

  // src/traces/pie/fill_one.js
  var require_fill_one = __commonJS({
    "src/traces/pie/fill_one.js"(exports, module) {
      "use strict";
      var Drawing = require_drawing();
      var Color = require_color();
      module.exports = function fillOne(s, pt, trace, gd) {
        var pattern = trace.marker.pattern;
        if (pattern && pattern.shape) {
          Drawing.pointStyle(s, trace, gd, pt);
        } else {
          Color.fill(s, pt.color);
        }
      };
    }
  });

  // src/traces/pie/style_one.js
  var require_style_one = __commonJS({
    "src/traces/pie/style_one.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var castOption = require_helpers4().castOption;
      var fillOne = require_fill_one();
      module.exports = function styleOne(s, pt, trace, gd) {
        var line = trace.marker.line;
        var lineColor = castOption(line.color, pt.pts) || Color.defaultLine;
        var lineWidth = castOption(line.width, pt.pts) || 0;
        s.call(fillOne, pt, trace, gd).style("stroke-width", lineWidth).call(Color.stroke, lineColor);
      };
    }
  });

  // src/components/legend/style.js
  var require_style = __commonJS({
    "src/components/legend/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Drawing = require_drawing();
      var Color = require_color();
      var extractOpts = require_helpers().extractOpts;
      var subTypes = require_subtypes();
      var stylePie = require_style_one();
      var pieCastOption = require_helpers4().castOption;
      var constants = require_constants3();
      var CST_MARKER_SIZE = 12;
      var CST_LINE_WIDTH = 5;
      var CST_MARKER_LINE_WIDTH = 2;
      var MAX_LINE_WIDTH = 10;
      var MAX_MARKER_LINE_WIDTH = 5;
      module.exports = function style(s, gd, legend) {
        var fullLayout = gd._fullLayout;
        if (!legend) legend = fullLayout.legend;
        var constantItemSizing = legend.itemsizing === "constant";
        var itemWidth = legend.itemwidth;
        var centerPos = (itemWidth + constants.itemGap * 2) / 2;
        var centerTransform = strTranslate(centerPos, 0);
        var boundLineWidth = function(mlw, cont, max, cst) {
          var v;
          if (mlw + 1) {
            v = mlw;
          } else if (cont && cont.width > 0) {
            v = cont.width;
          } else {
            return 0;
          }
          return constantItemSizing ? cst : Math.min(v, max);
        };
        s.each(function(d) {
          var traceGroup = d3.select(this);
          var layers = Lib.ensureSingle(traceGroup, "g", "layers");
          layers.style("opacity", d[0].trace.opacity);
          var indentation = legend.indentation;
          var valign = legend.valign;
          var lineHeight = d[0].lineHeight;
          var height = d[0].height;
          if (valign === "middle" && indentation === 0 || !lineHeight || !height) {
            layers.attr("transform", null);
          } else {
            var factor = { top: 1, bottom: -1 }[valign];
            var markerOffsetY = factor * (0.5 * (lineHeight - height + 3)) || 0;
            var markerOffsetX = legend.indentation;
            layers.attr("transform", strTranslate(markerOffsetX, markerOffsetY));
          }
          var fill = layers.selectAll("g.legendfill").data([d]);
          fill.enter().append("g").classed("legendfill", true);
          var line = layers.selectAll("g.legendlines").data([d]);
          line.enter().append("g").classed("legendlines", true);
          var symbol = layers.selectAll("g.legendsymbols").data([d]);
          symbol.enter().append("g").classed("legendsymbols", true);
          symbol.selectAll("g.legendpoints").data([d]).enter().append("g").classed("legendpoints", true);
        }).each(styleSpatial).each(styleWaterfalls).each(styleFunnels).each(styleBars).each(styleBoxes).each(styleFunnelareas).each(stylePies).each(styleLines).each(stylePoints).each(styleCandles).each(styleOHLC);
        function styleLines(d) {
          var styleGuide = getStyleGuide(d);
          var showFill = styleGuide.showFill;
          var showLine = styleGuide.showLine;
          var showGradientLine = styleGuide.showGradientLine;
          var showGradientFill = styleGuide.showGradientFill;
          var anyFill = styleGuide.anyFill;
          var anyLine = styleGuide.anyLine;
          var d0 = d[0];
          var trace = d0.trace;
          var dMod, tMod;
          var cOpts = extractOpts(trace);
          var colorscale = cOpts.colorscale;
          var reversescale = cOpts.reversescale;
          var fillStyle = function(s2) {
            if (s2.size()) {
              if (showFill) {
                Drawing.fillGroupStyle(s2, gd, true);
              } else {
                var gradientID = "legendfill-" + trace.uid;
                Drawing.gradient(
                  s2,
                  gd,
                  gradientID,
                  getGradientDirection(reversescale),
                  colorscale,
                  "fill"
                );
              }
            }
          };
          var lineGradient = function(s2) {
            if (s2.size()) {
              var gradientID = "legendline-" + trace.uid;
              Drawing.lineGroupStyle(s2);
              Drawing.gradient(
                s2,
                gd,
                gradientID,
                getGradientDirection(reversescale),
                colorscale,
                "stroke"
              );
            }
          };
          var pathStart = subTypes.hasMarkers(trace) || !anyFill ? "M5,0" : (
            // with a line leave it slightly below center, to leave room for the
            // line thickness and because the line is usually more prominent
            anyLine ? "M5,-2" : "M5,-3"
          );
          var this3 = d3.select(this);
          var fill = this3.select(".legendfill").selectAll("path").data(showFill || showGradientFill ? [d] : []);
          fill.enter().append("path").classed("js-fill", true);
          fill.exit().remove();
          fill.attr("d", pathStart + "h" + itemWidth + "v6h-" + itemWidth + "z").call(fillStyle);
          if (showLine || showGradientLine) {
            var lw = boundLineWidth(void 0, trace.line, MAX_LINE_WIDTH, CST_LINE_WIDTH);
            tMod = Lib.minExtend(trace, { line: { width: lw } });
            dMod = [Lib.minExtend(d0, { trace: tMod })];
          }
          var line = this3.select(".legendlines").selectAll("path").data(showLine || showGradientLine ? [dMod] : []);
          line.enter().append("path").classed("js-line", true);
          line.exit().remove();
          line.attr("d", pathStart + (showGradientLine ? "l" + itemWidth + ",0.0001" : "h" + itemWidth)).call(showLine ? Drawing.lineGroupStyle : lineGradient);
        }
        function stylePoints(d) {
          var styleGuide = getStyleGuide(d);
          var anyFill = styleGuide.anyFill;
          var anyLine = styleGuide.anyLine;
          var showLine = styleGuide.showLine;
          var showMarker = styleGuide.showMarker;
          var d0 = d[0];
          var trace = d0.trace;
          var showText = !showMarker && !anyLine && !anyFill && subTypes.hasText(trace);
          var dMod, tMod;
          function boundVal(attrIn, arrayToValFn, bounds, cst) {
            var valIn = Lib.nestedProperty(trace, attrIn).get();
            var valToBound = Lib.isArrayOrTypedArray(valIn) && arrayToValFn ? arrayToValFn(valIn) : valIn;
            if (constantItemSizing && valToBound && cst !== void 0) {
              valToBound = cst;
            }
            if (bounds) {
              if (valToBound < bounds[0]) return bounds[0];
              else if (valToBound > bounds[1]) return bounds[1];
            }
            return valToBound;
          }
          function pickFirst(array) {
            if (d0._distinct && d0.index && array[d0.index]) return array[d0.index];
            return array[0];
          }
          if (showMarker || showText || showLine) {
            var dEdit = {};
            var tEdit = {};
            if (showMarker) {
              dEdit.mc = boundVal("marker.color", pickFirst);
              dEdit.mx = boundVal("marker.symbol", pickFirst);
              dEdit.mo = boundVal("marker.opacity", Lib.mean, [0.2, 1]);
              dEdit.mlc = boundVal("marker.line.color", pickFirst);
              dEdit.mlw = boundVal("marker.line.width", Lib.mean, [0, 5], CST_MARKER_LINE_WIDTH);
              tEdit.marker = {
                sizeref: 1,
                sizemin: 1,
                sizemode: "diameter"
              };
              var ms = boundVal("marker.size", Lib.mean, [2, 16], CST_MARKER_SIZE);
              dEdit.ms = ms;
              tEdit.marker.size = ms;
            }
            if (showLine) {
              tEdit.line = {
                width: boundVal("line.width", pickFirst, [0, 10], CST_LINE_WIDTH)
              };
            }
            if (showText) {
              dEdit.tx = "Aa";
              dEdit.tp = boundVal("textposition", pickFirst);
              dEdit.ts = 10;
              dEdit.tc = boundVal("textfont.color", pickFirst);
              dEdit.tf = boundVal("textfont.family", pickFirst);
              dEdit.tw = boundVal("textfont.weight", pickFirst);
              dEdit.ty = boundVal("textfont.style", pickFirst);
              dEdit.tv = boundVal("textfont.variant", pickFirst);
              dEdit.tC = boundVal("textfont.textcase", pickFirst);
              dEdit.tE = boundVal("textfont.lineposition", pickFirst);
              dEdit.tS = boundVal("textfont.shadow", pickFirst);
            }
            dMod = [Lib.minExtend(d0, dEdit)];
            tMod = Lib.minExtend(trace, tEdit);
            tMod.selectedpoints = null;
            tMod.texttemplate = null;
          }
          var ptgroup = d3.select(this).select("g.legendpoints");
          var pts = ptgroup.selectAll("path.scatterpts").data(showMarker ? dMod : []);
          pts.enter().insert("path", ":first-child").classed("scatterpts", true).attr("transform", centerTransform);
          pts.exit().remove();
          pts.call(Drawing.pointStyle, tMod, gd);
          if (showMarker) dMod[0].mrc = 3;
          var txt = ptgroup.selectAll("g.pointtext").data(showText ? dMod : []);
          txt.enter().append("g").classed("pointtext", true).append("text").attr("transform", centerTransform);
          txt.exit().remove();
          txt.selectAll("text").call(Drawing.textPointStyle, tMod, gd);
        }
        function styleWaterfalls(d) {
          var trace = d[0].trace;
          var isWaterfall = trace.type === "waterfall";
          if (d[0]._distinct && isWaterfall) {
            var cont = d[0].trace[d[0].dir].marker;
            d[0].mc = cont.color;
            d[0].mlw = cont.line.width;
            d[0].mlc = cont.line.color;
            return styleBarLike(d, this, "waterfall");
          }
          var ptsData = [];
          if (trace.visible && isWaterfall) {
            ptsData = d[0].hasTotals ? [["increasing", "M-6,-6V6H0Z"], ["totals", "M6,6H0L-6,-6H-0Z"], ["decreasing", "M6,6V-6H0Z"]] : [["increasing", "M-6,-6V6H6Z"], ["decreasing", "M6,6V-6H-6Z"]];
          }
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendwaterfall").data(ptsData);
          pts.enter().append("path").classed("legendwaterfall", true).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(dd) {
            var pt = d3.select(this);
            var cont2 = trace[dd[0]].marker;
            var lw = boundLineWidth(void 0, cont2.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            pt.attr("d", dd[1]).style("stroke-width", lw + "px").call(Color.fill, cont2.color);
            if (lw) {
              pt.call(Color.stroke, cont2.line.color);
            }
          });
        }
        function styleBars(d) {
          styleBarLike(d, this);
        }
        function styleFunnels(d) {
          styleBarLike(d, this, "funnel");
        }
        function styleBarLike(d, lThis, desiredType) {
          var trace = d[0].trace;
          var marker = trace.marker || {};
          var markerLine = marker.line || {};
          var pathStr = marker.cornerradius ? "M6,3a3,3,0,0,1-3,3H-3a3,3,0,0,1-3-3V-3a3,3,0,0,1,3-3H3a3,3,0,0,1,3,3Z" : (
            // Square with rounded corners
            "M6,6H-6V-6H6Z"
          );
          var isVisible = !desiredType ? Registry.traceIs(trace, "bar") : trace.visible && trace.type === desiredType;
          var barpath = d3.select(lThis).select("g.legendpoints").selectAll("path.legend" + desiredType).data(isVisible ? [d] : []);
          barpath.enter().append("path").classed("legend" + desiredType, true).attr("d", pathStr).attr("transform", centerTransform);
          barpath.exit().remove();
          barpath.each(function(d2) {
            var p = d3.select(this);
            var d0 = d2[0];
            var w = boundLineWidth(d0.mlw, marker.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            p.style("stroke-width", w + "px");
            var mcc = d0.mcc;
            if (!legend._inHover && "mc" in d0) {
              var cOpts = extractOpts(marker);
              var mid = cOpts.mid;
              if (mid === void 0) mid = (cOpts.max + cOpts.min) / 2;
              mcc = Drawing.tryColorscale(marker, "")(mid);
            }
            var fillColor = mcc || d0.mc || marker.color;
            var markerPattern = marker.pattern;
            var patternShape = markerPattern && Drawing.getPatternAttr(markerPattern.shape, 0, "");
            if (patternShape) {
              var patternBGColor = Drawing.getPatternAttr(markerPattern.bgcolor, 0, null);
              var patternFGColor = Drawing.getPatternAttr(markerPattern.fgcolor, 0, null);
              var patternFGOpacity = markerPattern.fgopacity;
              var patternSize = dimAttr(markerPattern.size, 8, 10);
              var patternSolidity = dimAttr(markerPattern.solidity, 0.5, 1);
              var patternID = "legend-" + trace.uid;
              p.call(
                Drawing.pattern,
                "legend",
                gd,
                patternID,
                patternShape,
                patternSize,
                patternSolidity,
                mcc,
                markerPattern.fillmode,
                patternBGColor,
                patternFGColor,
                patternFGOpacity
              );
            } else {
              p.call(Color.fill, fillColor);
            }
            if (w) Color.stroke(p, d0.mlc || markerLine.color);
          });
        }
        function styleBoxes(d) {
          var trace = d[0].trace;
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendbox").data(trace.visible && Registry.traceIs(trace, "box-violin") ? [d] : []);
          pts.enter().append("path").classed("legendbox", true).attr("d", "M6,6H-6V-6H6Z").attr("transform", centerTransform);
          pts.exit().remove();
          pts.each(function() {
            var p = d3.select(this);
            if ((trace.boxpoints === "all" || trace.points === "all") && Color.opacity(trace.fillcolor) === 0 && Color.opacity((trace.line || {}).color) === 0) {
              var tMod = Lib.minExtend(trace, {
                marker: {
                  size: constantItemSizing ? CST_MARKER_SIZE : Lib.constrain(trace.marker.size, 2, 16),
                  sizeref: 1,
                  sizemin: 1,
                  sizemode: "diameter"
                }
              });
              pts.call(Drawing.pointStyle, tMod, gd);
            } else {
              var w = boundLineWidth(void 0, trace.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
              p.style("stroke-width", w + "px").call(Color.fill, trace.fillcolor);
              if (w) Color.stroke(p, trace.line.color);
            }
          });
        }
        function styleCandles(d) {
          var trace = d[0].trace;
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendcandle").data(trace.visible && trace.type === "candlestick" ? [d, d] : []);
          pts.enter().append("path").classed("legendcandle", true).attr("d", function(_, i) {
            if (i) return "M-15,0H-8M-8,6V-6H8Z";
            return "M15,0H8M8,-6V6H-8Z";
          }).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(_, i) {
            var p = d3.select(this);
            var cont = trace[i ? "increasing" : "decreasing"];
            var w = boundLineWidth(void 0, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            p.style("stroke-width", w + "px").call(Color.fill, cont.fillcolor);
            if (w) Color.stroke(p, cont.line.color);
          });
        }
        function styleOHLC(d) {
          var trace = d[0].trace;
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendohlc").data(trace.visible && trace.type === "ohlc" ? [d, d] : []);
          pts.enter().append("path").classed("legendohlc", true).attr("d", function(_, i) {
            if (i) return "M-15,0H0M-8,-6V0";
            return "M15,0H0M8,6V0";
          }).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(_, i) {
            var p = d3.select(this);
            var cont = trace[i ? "increasing" : "decreasing"];
            var w = boundLineWidth(void 0, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            p.style("fill", "none").call(Drawing.dashLine, cont.line.dash, w);
            if (w) Color.stroke(p, cont.line.color);
          });
        }
        function stylePies(d) {
          stylePieLike(d, this, "pie");
        }
        function styleFunnelareas(d) {
          stylePieLike(d, this, "funnelarea");
        }
        function stylePieLike(d, lThis, desiredType) {
          var d0 = d[0];
          var trace = d0.trace;
          var isVisible = !desiredType ? Registry.traceIs(trace, desiredType) : trace.visible && trace.type === desiredType;
          var pts = d3.select(lThis).select("g.legendpoints").selectAll("path.legend" + desiredType).data(isVisible ? [d] : []);
          pts.enter().append("path").classed("legend" + desiredType, true).attr("d", "M6,6H-6V-6H6Z").attr("transform", centerTransform);
          pts.exit().remove();
          if (pts.size()) {
            var cont = trace.marker || {};
            var lw = boundLineWidth(pieCastOption(cont.line.width, d0.pts), cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            var opt = "pieLike";
            var tMod = Lib.minExtend(trace, { marker: { line: { width: lw } } }, opt);
            var d0Mod = Lib.minExtend(d0, { trace: tMod }, opt);
            stylePie(pts, d0Mod, tMod, gd);
          }
        }
        function styleSpatial(d) {
          var trace = d[0].trace;
          var useGradient;
          var ptsData = [];
          if (trace.visible) {
            switch (trace.type) {
              case "histogram2d":
              case "heatmap":
                ptsData = [
                  ["M-15,-2V4H15V-2Z"]
                  // similar to contour
                ];
                useGradient = true;
                break;
              case "choropleth":
              case "choroplethmapbox":
              case "choroplethmap":
                ptsData = [
                  ["M-6,-6V6H6V-6Z"]
                ];
                useGradient = true;
                break;
              case "densitymapbox":
              case "densitymap":
                ptsData = [
                  ["M-6,0 a6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0"]
                ];
                useGradient = "radial";
                break;
              case "cone":
                ptsData = [
                  ["M-6,2 A2,2 0 0,0 -6,6 V6L6,4Z"],
                  ["M-6,-6 A2,2 0 0,0 -6,-2 L6,-4Z"],
                  ["M-6,-2 A2,2 0 0,0 -6,2 L6,0Z"]
                ];
                useGradient = false;
                break;
              case "streamtube":
                ptsData = [
                  ["M-6,2 A2,2 0 0,0 -6,6 H6 A2,2 0 0,1 6,2 Z"],
                  ["M-6,-6 A2,2 0 0,0 -6,-2 H6 A2,2 0 0,1 6,-6 Z"],
                  ["M-6,-2 A2,2 0 0,0 -6,2 H6 A2,2 0 0,1 6,-2 Z"]
                ];
                useGradient = false;
                break;
              case "surface":
                ptsData = [
                  ["M-6,-6 A2,3 0 0,0 -6,0 H6 A2,3 0 0,1 6,-6 Z"],
                  ["M-6,1 A2,3 0 0,1 -6,6 H6 A2,3 0 0,0 6,0 Z"]
                ];
                useGradient = true;
                break;
              case "mesh3d":
                ptsData = [
                  ["M-6,6H0L-6,-6Z"],
                  ["M6,6H0L6,-6Z"],
                  ["M-6,-6H6L0,6Z"]
                ];
                useGradient = false;
                break;
              case "volume":
                ptsData = [
                  ["M-6,6H0L-6,-6Z"],
                  ["M6,6H0L6,-6Z"],
                  ["M-6,-6H6L0,6Z"]
                ];
                useGradient = true;
                break;
              case "isosurface":
                ptsData = [
                  ["M-6,6H0L-6,-6Z"],
                  ["M6,6H0L6,-6Z"],
                  ["M-6,-6 A12,24 0 0,0 6,-6 L0,6Z"]
                ];
                useGradient = false;
                break;
            }
          }
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legend3dandfriends").data(ptsData);
          pts.enter().append("path").classed("legend3dandfriends", true).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(dd, i) {
            var pt = d3.select(this);
            var cOpts = extractOpts(trace);
            var colorscale = cOpts.colorscale;
            var reversescale = cOpts.reversescale;
            var fillGradient = function(s2) {
              if (s2.size()) {
                var gradientID = "legendfill-" + trace.uid;
                Drawing.gradient(
                  s2,
                  gd,
                  gradientID,
                  getGradientDirection(reversescale, useGradient === "radial"),
                  colorscale,
                  "fill"
                );
              }
            };
            var fillColor;
            if (!colorscale) {
              var color = trace.vertexcolor || trace.facecolor || trace.color;
              fillColor = Lib.isArrayOrTypedArray(color) ? color[i] || color[0] : color;
            } else {
              if (!useGradient) {
                var len = colorscale.length;
                fillColor = i === 0 ? colorscale[reversescale ? len - 1 : 0][1] : (
                  // minimum
                  i === 1 ? colorscale[reversescale ? 0 : len - 1][1] : (
                    // maximum
                    colorscale[Math.floor((len - 1) / 2)][1]
                  )
                );
              }
            }
            pt.attr("d", dd[0]);
            if (fillColor) {
              pt.call(Color.fill, fillColor);
            } else {
              pt.call(fillGradient);
            }
          });
        }
      };
      function getGradientDirection(reversescale, isRadial) {
        var str = isRadial ? "radial" : "horizontal";
        return str + (reversescale ? "" : "reversed");
      }
      function getStyleGuide(d) {
        var trace = d[0].trace;
        var contours = trace.contours;
        var showLine = subTypes.hasLines(trace);
        var showMarker = subTypes.hasMarkers(trace);
        var showFill = trace.visible && trace.fill && trace.fill !== "none";
        var showGradientLine = false;
        var showGradientFill = false;
        if (contours) {
          var coloring = contours.coloring;
          if (coloring === "lines") {
            showGradientLine = true;
          } else {
            showLine = coloring === "none" || coloring === "heatmap" || contours.showlines;
          }
          if (contours.type === "constraint") {
            showFill = contours._operation !== "=";
          } else if (coloring === "fill" || coloring === "heatmap") {
            showGradientFill = true;
          }
        }
        return {
          showMarker,
          showLine,
          showFill,
          showGradientLine,
          showGradientFill,
          anyLine: showLine || showGradientLine,
          anyFill: showFill || showGradientFill
        };
      }
      function dimAttr(v, dflt, max) {
        if (v && Lib.isArrayOrTypedArray(v)) return dflt;
        if (v > max) return max;
        return v;
      }
    }
  });

  // src/components/legend/draw.js
  var require_draw = __commonJS({
    "src/components/legend/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var Plots = require_plots();
      var Registry = require_registry();
      var Events = require_events2();
      var dragElement = require_dragelement();
      var Drawing = require_drawing();
      var Color = require_color();
      var svgTextUtils = require_svg_text_utils();
      var handleClick = require_handle_click();
      var constants = require_constants3();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      var getLegendData = require_get_legend_data();
      var style = require_style();
      var helpers = require_helpers3();
      var MAIN_TITLE = 1;
      var LEGEND_PATTERN = /^legend[0-9]*$/;
      module.exports = function draw(gd, opts) {
        if (opts) {
          drawOne(gd, opts);
        } else {
          var fullLayout = gd._fullLayout;
          var newLegends = fullLayout._legends;
          var oldLegends = fullLayout._infolayer.selectAll('[class^="legend"]');
          oldLegends.each(function() {
            var el = d3.select(this);
            var classes = el.attr("class");
            var cls = classes.split(" ")[0];
            if (cls.match(LEGEND_PATTERN) && newLegends.indexOf(cls) === -1) {
              el.remove();
            }
          });
          for (var i = 0; i < newLegends.length; i++) {
            var legendId = newLegends[i];
            var legendObj = gd._fullLayout[legendId];
            drawOne(gd, legendObj);
          }
        }
      };
      function horizontalAlignTitle(titleEl, legendObj, bw) {
        if (legendObj.title.side !== "top center" && legendObj.title.side !== "top right") return;
        var font = legendObj.title.font;
        var lineHeight = font.size * LINE_SPACING;
        var titleOffset = 0;
        var textNode = titleEl.node();
        var width = Drawing.bBox(textNode).width;
        if (legendObj.title.side === "top center") {
          titleOffset = 0.5 * (legendObj._width - 2 * bw - 2 * constants.titlePad - width);
        } else if (legendObj.title.side === "top right") {
          titleOffset = legendObj._width - 2 * bw - 2 * constants.titlePad - width;
        }
        svgTextUtils.positionText(
          titleEl,
          bw + constants.titlePad + titleOffset,
          bw + lineHeight
        );
      }
      function drawOne(gd, opts) {
        var legendObj = opts || {};
        var fullLayout = gd._fullLayout;
        var legendId = getId(legendObj);
        var clipId, layer;
        var inHover = legendObj._inHover;
        if (inHover) {
          layer = legendObj.layer;
          clipId = "hover";
        } else {
          layer = fullLayout._infolayer;
          clipId = legendId;
        }
        if (!layer) return;
        clipId += fullLayout._uid;
        if (!gd._legendMouseDownTime) gd._legendMouseDownTime = 0;
        var legendData;
        if (!inHover) {
          var calcdata = (gd.calcdata || []).slice();
          var shapes = fullLayout.shapes;
          for (var i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            if (!shape.showlegend) continue;
            var shapeLegend = {
              _isShape: true,
              _fullInput: shape,
              index: shape._index,
              name: shape.name || shape.label.text || "shape " + shape._index,
              legend: shape.legend,
              legendgroup: shape.legendgroup,
              legendgrouptitle: shape.legendgrouptitle,
              legendrank: shape.legendrank,
              legendwidth: shape.legendwidth,
              showlegend: shape.showlegend,
              visible: shape.visible,
              opacity: shape.opacity,
              mode: shape.type === "line" ? "lines" : "markers",
              line: shape.line,
              marker: {
                line: shape.line,
                color: shape.fillcolor,
                size: 12,
                symbol: shape.type === "rect" ? "square" : shape.type === "circle" ? "circle" : (
                  // case of path
                  "hexagon2"
                )
              }
            };
            calcdata.push([{ trace: shapeLegend }]);
          }
          legendData = fullLayout.showlegend && getLegendData(calcdata, legendObj, fullLayout._legends.length > 1);
        } else {
          if (!legendObj.entries) return;
          legendData = getLegendData(legendObj.entries, legendObj);
        }
        var hiddenSlices = fullLayout.hiddenlabels || [];
        if (!inHover && (!fullLayout.showlegend || !legendData.length)) {
          layer.selectAll("." + legendId).remove();
          fullLayout._topdefs.select("#" + clipId).remove();
          return Plots.autoMargin(gd, legendId);
        }
        var legend = Lib.ensureSingle(layer, "g", legendId, function(s) {
          if (!inHover) s.attr("pointer-events", "all");
        });
        var clipPath = Lib.ensureSingleById(fullLayout._topdefs, "clipPath", clipId, function(s) {
          s.append("rect");
        });
        var bg = Lib.ensureSingle(legend, "rect", "bg", function(s) {
          s.attr("shape-rendering", "crispEdges");
        });
        bg.call(Color.stroke, legendObj.bordercolor).call(Color.fill, legendObj.bgcolor).style("stroke-width", legendObj.borderwidth + "px");
        var scrollBox = Lib.ensureSingle(legend, "g", "scrollbox");
        var title = legendObj.title;
        legendObj._titleWidth = 0;
        legendObj._titleHeight = 0;
        var titleEl;
        if (title.text) {
          titleEl = Lib.ensureSingle(scrollBox, "text", legendId + "titletext");
          titleEl.attr("text-anchor", "start").call(Drawing.font, title.font).text(title.text);
          textLayout(titleEl, scrollBox, gd, legendObj, MAIN_TITLE);
        } else {
          scrollBox.selectAll("." + legendId + "titletext").remove();
        }
        var scrollBar = Lib.ensureSingle(legend, "rect", "scrollbar", function(s) {
          s.attr(constants.scrollBarEnterAttrs).call(Color.fill, constants.scrollBarColor);
        });
        var groups = scrollBox.selectAll("g.groups").data(legendData);
        groups.enter().append("g").attr("class", "groups");
        groups.exit().remove();
        var traces = groups.selectAll("g.traces").data(Lib.identity);
        traces.enter().append("g").attr("class", "traces");
        traces.exit().remove();
        traces.style("opacity", function(d) {
          var trace = d[0].trace;
          if (Registry.traceIs(trace, "pie-like")) {
            return hiddenSlices.indexOf(d[0].label) !== -1 ? 0.5 : 1;
          } else {
            return trace.visible === "legendonly" ? 0.5 : 1;
          }
        }).each(function() {
          d3.select(this).call(drawTexts, gd, legendObj);
        }).call(style, gd, legendObj).each(function() {
          if (!inHover) d3.select(this).call(setupTraceToggle, gd, legendId);
        });
        Lib.syncOrAsync([
          Plots.previousPromises,
          function() {
            return computeLegendDimensions(gd, groups, traces, legendObj);
          },
          function() {
            var gs = fullLayout._size;
            var bw = legendObj.borderwidth;
            var isPaperX = legendObj.xref === "paper";
            var isPaperY = legendObj.yref === "paper";
            if (title.text) {
              horizontalAlignTitle(titleEl, legendObj, bw);
            }
            if (!inHover) {
              var lx, ly;
              if (isPaperX) {
                lx = gs.l + gs.w * legendObj.x - FROM_TL[getXanchor(legendObj)] * legendObj._width;
              } else {
                lx = fullLayout.width * legendObj.x - FROM_TL[getXanchor(legendObj)] * legendObj._width;
              }
              if (isPaperY) {
                ly = gs.t + gs.h * (1 - legendObj.y) - FROM_TL[getYanchor(legendObj)] * legendObj._effHeight;
              } else {
                ly = fullLayout.height * (1 - legendObj.y) - FROM_TL[getYanchor(legendObj)] * legendObj._effHeight;
              }
              var expMargin = expandMargin(gd, legendId, lx, ly);
              if (expMargin) return;
              if (fullLayout.margin.autoexpand) {
                var lx0 = lx;
                var ly0 = ly;
                lx = isPaperX ? Lib.constrain(lx, 0, fullLayout.width - legendObj._width) : lx0;
                ly = isPaperY ? Lib.constrain(ly, 0, fullLayout.height - legendObj._effHeight) : ly0;
                if (lx !== lx0) {
                  Lib.log("Constrain " + legendId + ".x to make legend fit inside graph");
                }
                if (ly !== ly0) {
                  Lib.log("Constrain " + legendId + ".y to make legend fit inside graph");
                }
              }
              Drawing.setTranslate(legend, lx, ly);
            }
            scrollBar.on(".drag", null);
            legend.on("wheel", null);
            if (inHover || legendObj._height <= legendObj._maxHeight || gd._context.staticPlot) {
              var height = legendObj._effHeight;
              if (inHover) height = legendObj._height;
              bg.attr({
                width: legendObj._width - bw,
                height: height - bw,
                x: bw / 2,
                y: bw / 2
              });
              Drawing.setTranslate(scrollBox, 0, 0);
              clipPath.select("rect").attr({
                width: legendObj._width - 2 * bw,
                height: height - 2 * bw,
                x: bw,
                y: bw
              });
              Drawing.setClipUrl(scrollBox, clipId, gd);
              Drawing.setRect(scrollBar, 0, 0, 0, 0);
              delete legendObj._scrollY;
            } else {
              var scrollBarHeight = Math.max(
                constants.scrollBarMinHeight,
                legendObj._effHeight * legendObj._effHeight / legendObj._height
              );
              var scrollBarYMax = legendObj._effHeight - scrollBarHeight - 2 * constants.scrollBarMargin;
              var scrollBoxYMax = legendObj._height - legendObj._effHeight;
              var scrollRatio = scrollBarYMax / scrollBoxYMax;
              var scrollBoxY = Math.min(legendObj._scrollY || 0, scrollBoxYMax);
              bg.attr({
                width: legendObj._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,
                height: legendObj._effHeight - bw,
                x: bw / 2,
                y: bw / 2
              });
              clipPath.select("rect").attr({
                width: legendObj._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,
                height: legendObj._effHeight - 2 * bw,
                x: bw,
                y: bw + scrollBoxY
              });
              Drawing.setClipUrl(scrollBox, clipId, gd);
              scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
              legend.on("wheel", function() {
                scrollBoxY = Lib.constrain(
                  legendObj._scrollY + d3.event.deltaY / scrollBarYMax * scrollBoxYMax,
                  0,
                  scrollBoxYMax
                );
                scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
                if (scrollBoxY !== 0 && scrollBoxY !== scrollBoxYMax) {
                  d3.event.preventDefault();
                }
              });
              var eventY0, eventY1, scrollBoxY0;
              var getScrollBarDragY = function(scrollBoxY02, eventY02, eventY12) {
                var y = (eventY12 - eventY02) / scrollRatio + scrollBoxY02;
                return Lib.constrain(y, 0, scrollBoxYMax);
              };
              var getNaturalDragY = function(scrollBoxY02, eventY02, eventY12) {
                var y = (eventY02 - eventY12) / scrollRatio + scrollBoxY02;
                return Lib.constrain(y, 0, scrollBoxYMax);
              };
              var scrollBarDrag = d3.behavior.drag().on("dragstart", function() {
                var e = d3.event.sourceEvent;
                if (e.type === "touchstart") {
                  eventY0 = e.changedTouches[0].clientY;
                } else {
                  eventY0 = e.clientY;
                }
                scrollBoxY0 = scrollBoxY;
              }).on("drag", function() {
                var e = d3.event.sourceEvent;
                if (e.buttons === 2 || e.ctrlKey) return;
                if (e.type === "touchmove") {
                  eventY1 = e.changedTouches[0].clientY;
                } else {
                  eventY1 = e.clientY;
                }
                scrollBoxY = getScrollBarDragY(scrollBoxY0, eventY0, eventY1);
                scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
              });
              scrollBar.call(scrollBarDrag);
              var scrollBoxTouchDrag = d3.behavior.drag().on("dragstart", function() {
                var e = d3.event.sourceEvent;
                if (e.type === "touchstart") {
                  eventY0 = e.changedTouches[0].clientY;
                  scrollBoxY0 = scrollBoxY;
                }
              }).on("drag", function() {
                var e = d3.event.sourceEvent;
                if (e.type === "touchmove") {
                  eventY1 = e.changedTouches[0].clientY;
                  scrollBoxY = getNaturalDragY(scrollBoxY0, eventY0, eventY1);
                  scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
                }
              });
              scrollBox.call(scrollBoxTouchDrag);
            }
            function scrollHandler(scrollBoxY2, scrollBarHeight2, scrollRatio2) {
              legendObj._scrollY = gd._fullLayout[legendId]._scrollY = scrollBoxY2;
              Drawing.setTranslate(scrollBox, 0, -scrollBoxY2);
              Drawing.setRect(
                scrollBar,
                legendObj._width,
                constants.scrollBarMargin + scrollBoxY2 * scrollRatio2,
                constants.scrollBarWidth,
                scrollBarHeight2
              );
              clipPath.select("rect").attr("y", bw + scrollBoxY2);
            }
            if (gd._context.edits.legendPosition) {
              var xf, yf, x0, y0;
              legend.classed("cursor-move", true);
              dragElement.init({
                element: legend.node(),
                gd,
                prepFn: function(e) {
                  if (e.target === scrollBar.node()) {
                    return;
                  }
                  var transform = Drawing.getTranslate(legend);
                  x0 = transform.x;
                  y0 = transform.y;
                },
                moveFn: function(dx, dy) {
                  if (x0 !== void 0 && y0 !== void 0) {
                    var newX = x0 + dx;
                    var newY = y0 + dy;
                    Drawing.setTranslate(legend, newX, newY);
                    xf = dragElement.align(newX, legendObj._width, gs.l, gs.l + gs.w, legendObj.xanchor);
                    yf = dragElement.align(newY + legendObj._height, -legendObj._height, gs.t + gs.h, gs.t, legendObj.yanchor);
                  }
                },
                doneFn: function() {
                  if (xf !== void 0 && yf !== void 0) {
                    var obj = {};
                    obj[legendId + ".x"] = xf;
                    obj[legendId + ".y"] = yf;
                    Registry.call("_guiRelayout", gd, obj);
                  }
                },
                clickFn: function(numClicks, e) {
                  var clickedTrace = layer.selectAll("g.traces").filter(function() {
                    var bbox = this.getBoundingClientRect();
                    return e.clientX >= bbox.left && e.clientX <= bbox.right && e.clientY >= bbox.top && e.clientY <= bbox.bottom;
                  });
                  if (clickedTrace.size() > 0) {
                    clickOrDoubleClick(gd, legend, clickedTrace, numClicks, e);
                  }
                }
              });
            }
          }
        ], gd);
      }
      function getTraceWidth(d, legendObj, textGap) {
        var legendItem = d[0];
        var legendWidth = legendItem.width;
        var mode = legendObj.entrywidthmode;
        var traceLegendWidth = legendItem.trace.legendwidth || legendObj.entrywidth;
        if (mode === "fraction") return legendObj._maxWidth * traceLegendWidth;
        return textGap + (traceLegendWidth || legendWidth);
      }
      function clickOrDoubleClick(gd, legend, legendItem, numClicks, evt) {
        var trace = legendItem.data()[0][0].trace;
        var evtData = {
          event: evt,
          node: legendItem.node(),
          curveNumber: trace.index,
          expandedIndex: trace.index,
          data: gd.data,
          layout: gd.layout,
          frames: gd._transitionData._frames,
          config: gd._context,
          fullData: gd._fullData,
          fullLayout: gd._fullLayout
        };
        if (trace._group) {
          evtData.group = trace._group;
        }
        if (Registry.traceIs(trace, "pie-like")) {
          evtData.label = legendItem.datum()[0].label;
        }
        var clickVal = Events.triggerHandler(gd, "plotly_legendclick", evtData);
        if (numClicks === 1) {
          if (clickVal === false) return;
          legend._clickTimeout = setTimeout(function() {
            if (!gd._fullLayout) return;
            handleClick(legendItem, gd, numClicks);
          }, gd._context.doubleClickDelay);
        } else if (numClicks === 2) {
          if (legend._clickTimeout) clearTimeout(legend._clickTimeout);
          gd._legendMouseDownTime = 0;
          var dblClickVal = Events.triggerHandler(gd, "plotly_legenddoubleclick", evtData);
          if (dblClickVal !== false && clickVal !== false) handleClick(legendItem, gd, numClicks);
        }
      }
      function drawTexts(g, gd, legendObj) {
        var legendId = getId(legendObj);
        var legendItem = g.data()[0][0];
        var trace = legendItem.trace;
        var isPieLike = Registry.traceIs(trace, "pie-like");
        var isEditable = !legendObj._inHover && gd._context.edits.legendText && !isPieLike;
        var maxNameLength = legendObj._maxNameLength;
        var name, font;
        if (legendItem.groupTitle) {
          name = legendItem.groupTitle.text;
          font = legendItem.groupTitle.font;
        } else {
          font = legendObj.font;
          if (!legendObj.entries) {
            name = isPieLike ? legendItem.label : trace.name;
            if (trace._meta) {
              name = Lib.templateString(name, trace._meta);
            }
          } else {
            name = legendItem.text;
          }
        }
        var textEl = Lib.ensureSingle(g, "text", legendId + "text");
        textEl.attr("text-anchor", "start").call(Drawing.font, font).text(isEditable ? ensureLength(name, maxNameLength) : name);
        var textGap = legendObj.indentation + legendObj.itemwidth + constants.itemGap * 2;
        svgTextUtils.positionText(textEl, textGap, 0);
        if (isEditable) {
          textEl.call(svgTextUtils.makeEditable, { gd, text: name }).call(textLayout, g, gd, legendObj).on("edit", function(newName) {
            this.text(ensureLength(newName, maxNameLength)).call(textLayout, g, gd, legendObj);
            var fullInput = legendItem.trace._fullInput || {};
            var update = {};
            update.name = newName;
            if (fullInput._isShape) {
              return Registry.call("_guiRelayout", gd, "shapes[" + trace.index + "].name", update.name);
            } else {
              return Registry.call("_guiRestyle", gd, update, trace.index);
            }
          });
        } else {
          textLayout(textEl, g, gd, legendObj);
        }
      }
      function ensureLength(str, maxLength) {
        var targetLength = Math.max(4, maxLength);
        if (str && str.trim().length >= targetLength / 2) return str;
        str = str || "";
        for (var i = targetLength - str.length; i > 0; i--) str += " ";
        return str;
      }
      function setupTraceToggle(g, gd, legendId) {
        var doubleClickDelay = gd._context.doubleClickDelay;
        var newMouseDownTime;
        var numClicks = 1;
        var traceToggle = Lib.ensureSingle(g, "rect", legendId + "toggle", function(s) {
          if (!gd._context.staticPlot) {
            s.style("cursor", "pointer").attr("pointer-events", "all");
          }
          s.call(Color.fill, "rgba(0,0,0,0)");
        });
        if (gd._context.staticPlot) return;
        traceToggle.on("mousedown", function() {
          newMouseDownTime = (/* @__PURE__ */ new Date()).getTime();
          if (newMouseDownTime - gd._legendMouseDownTime < doubleClickDelay) {
            numClicks += 1;
          } else {
            numClicks = 1;
            gd._legendMouseDownTime = newMouseDownTime;
          }
        });
        traceToggle.on("mouseup", function() {
          if (gd._dragged || gd._editing) return;
          var legend = gd._fullLayout[legendId];
          if ((/* @__PURE__ */ new Date()).getTime() - gd._legendMouseDownTime > doubleClickDelay) {
            numClicks = Math.max(numClicks - 1, 1);
          }
          clickOrDoubleClick(gd, legend, g, numClicks, d3.event);
        });
      }
      function textLayout(s, g, gd, legendObj, aTitle) {
        if (legendObj._inHover) s.attr("data-notex", true);
        svgTextUtils.convertToTspans(s, gd, function() {
          computeTextDimensions(g, gd, legendObj, aTitle);
        });
      }
      function computeTextDimensions(g, gd, legendObj, aTitle) {
        var legendItem = g.data()[0][0];
        if (!legendObj._inHover && legendItem && !legendItem.trace.showlegend) {
          g.remove();
          return;
        }
        var mathjaxGroup = g.select("g[class*=math-group]");
        var mathjaxNode = mathjaxGroup.node();
        var legendId = getId(legendObj);
        if (!legendObj) {
          legendObj = gd._fullLayout[legendId];
        }
        var bw = legendObj.borderwidth;
        var font;
        if (aTitle === MAIN_TITLE) {
          font = legendObj.title.font;
        } else if (legendItem.groupTitle) {
          font = legendItem.groupTitle.font;
        } else {
          font = legendObj.font;
        }
        var lineHeight = font.size * LINE_SPACING;
        var height, width;
        if (mathjaxNode) {
          var mathjaxBB = Drawing.bBox(mathjaxNode);
          height = mathjaxBB.height;
          width = mathjaxBB.width;
          if (aTitle === MAIN_TITLE) {
            Drawing.setTranslate(mathjaxGroup, bw, bw + height * 0.75);
          } else {
            Drawing.setTranslate(mathjaxGroup, 0, height * 0.25);
          }
        } else {
          var cls = "." + legendId + (aTitle === MAIN_TITLE ? "title" : "") + "text";
          var textEl = g.select(cls);
          var textLines = svgTextUtils.lineCount(textEl);
          var textNode = textEl.node();
          height = lineHeight * textLines;
          width = textNode ? Drawing.bBox(textNode).width : 0;
          if (aTitle === MAIN_TITLE) {
            if (legendObj.title.side === "left") {
              width += constants.itemGap * 2;
            }
            svgTextUtils.positionText(
              textEl,
              bw + constants.titlePad,
              bw + lineHeight
            );
          } else {
            var x = constants.itemGap * 2 + legendObj.indentation + legendObj.itemwidth;
            if (legendItem.groupTitle) {
              x = constants.itemGap;
              width -= legendObj.indentation + legendObj.itemwidth;
            }
            svgTextUtils.positionText(
              textEl,
              x,
              -lineHeight * ((textLines - 1) / 2 - 0.3)
            );
          }
        }
        if (aTitle === MAIN_TITLE) {
          legendObj._titleWidth = width;
          legendObj._titleHeight = height;
        } else {
          legendItem.lineHeight = lineHeight;
          legendItem.height = Math.max(height, 16) + 3;
          legendItem.width = width;
        }
      }
      function getTitleSize(legendObj) {
        var w = 0;
        var h = 0;
        var side = legendObj.title.side;
        if (side) {
          if (side.indexOf("left") !== -1) {
            w = legendObj._titleWidth;
          }
          if (side.indexOf("top") !== -1) {
            h = legendObj._titleHeight;
          }
        }
        return [w, h];
      }
      function computeLegendDimensions(gd, groups, traces, legendObj) {
        var fullLayout = gd._fullLayout;
        var legendId = getId(legendObj);
        if (!legendObj) {
          legendObj = fullLayout[legendId];
        }
        var gs = fullLayout._size;
        var isVertical = helpers.isVertical(legendObj);
        var isGrouped = helpers.isGrouped(legendObj);
        var isFraction = legendObj.entrywidthmode === "fraction";
        var bw = legendObj.borderwidth;
        var bw2 = 2 * bw;
        var itemGap = constants.itemGap;
        var textGap = legendObj.indentation + legendObj.itemwidth + itemGap * 2;
        var endPad = 2 * (bw + itemGap);
        var yanchor = getYanchor(legendObj);
        var isBelowPlotArea = legendObj.y < 0 || legendObj.y === 0 && yanchor === "top";
        var isAbovePlotArea = legendObj.y > 1 || legendObj.y === 1 && yanchor === "bottom";
        var traceGroupGap = legendObj.tracegroupgap;
        var legendGroupWidths = {};
        legendObj._maxHeight = Math.max(
          isBelowPlotArea || isAbovePlotArea ? fullLayout.height / 2 : gs.h,
          30
        );
        var toggleRectWidth = 0;
        legendObj._width = 0;
        legendObj._height = 0;
        var titleSize = getTitleSize(legendObj);
        if (isVertical) {
          traces.each(function(d) {
            var h = d[0].height;
            Drawing.setTranslate(
              this,
              bw + titleSize[0],
              bw + titleSize[1] + legendObj._height + h / 2 + itemGap
            );
            legendObj._height += h;
            legendObj._width = Math.max(legendObj._width, d[0].width);
          });
          toggleRectWidth = textGap + legendObj._width;
          legendObj._width += itemGap + textGap + bw2;
          legendObj._height += endPad;
          if (isGrouped) {
            groups.each(function(d, i) {
              Drawing.setTranslate(this, 0, i * legendObj.tracegroupgap);
            });
            legendObj._height += (legendObj._lgroupsLength - 1) * legendObj.tracegroupgap;
          }
        } else {
          var xanchor = getXanchor(legendObj);
          var isLeftOfPlotArea = legendObj.x < 0 || legendObj.x === 0 && xanchor === "right";
          var isRightOfPlotArea = legendObj.x > 1 || legendObj.x === 1 && xanchor === "left";
          var isBeyondPlotAreaY = isAbovePlotArea || isBelowPlotArea;
          var hw = fullLayout.width / 2;
          legendObj._maxWidth = Math.max(
            isLeftOfPlotArea ? isBeyondPlotAreaY && xanchor === "left" ? gs.l + gs.w : hw : isRightOfPlotArea ? isBeyondPlotAreaY && xanchor === "right" ? gs.r + gs.w : hw : gs.w,
            2 * textGap
          );
          var maxItemWidth = 0;
          var combinedItemWidth = 0;
          traces.each(function(d) {
            var w = getTraceWidth(d, legendObj, textGap);
            maxItemWidth = Math.max(maxItemWidth, w);
            combinedItemWidth += w;
          });
          toggleRectWidth = null;
          var maxRowWidth = 0;
          if (isGrouped) {
            var maxGroupHeightInRow = 0;
            var groupOffsetX = 0;
            var groupOffsetY = 0;
            groups.each(function() {
              var maxWidthInGroup = 0;
              var offsetY2 = 0;
              d3.select(this).selectAll("g.traces").each(function(d) {
                var w = getTraceWidth(d, legendObj, textGap);
                var h = d[0].height;
                Drawing.setTranslate(
                  this,
                  titleSize[0],
                  titleSize[1] + bw + itemGap + h / 2 + offsetY2
                );
                offsetY2 += h;
                maxWidthInGroup = Math.max(maxWidthInGroup, w);
                legendGroupWidths[d[0].trace.legendgroup] = maxWidthInGroup;
              });
              var next = maxWidthInGroup + itemGap;
              if (
                // not on the first column already
                groupOffsetX > 0 && // goes beyound limit
                next + bw + groupOffsetX > legendObj._maxWidth
              ) {
                maxRowWidth = Math.max(maxRowWidth, groupOffsetX);
                groupOffsetX = 0;
                groupOffsetY += maxGroupHeightInRow + traceGroupGap;
                maxGroupHeightInRow = offsetY2;
              } else {
                maxGroupHeightInRow = Math.max(maxGroupHeightInRow, offsetY2);
              }
              Drawing.setTranslate(this, groupOffsetX, groupOffsetY);
              groupOffsetX += next;
            });
            legendObj._width = Math.max(maxRowWidth, groupOffsetX) + bw;
            legendObj._height = groupOffsetY + maxGroupHeightInRow + endPad;
          } else {
            var nTraces = traces.size();
            var oneRowLegend = combinedItemWidth + bw2 + (nTraces - 1) * itemGap < legendObj._maxWidth;
            var maxItemHeightInRow = 0;
            var offsetX = 0;
            var offsetY = 0;
            var rowWidth = 0;
            traces.each(function(d) {
              var h = d[0].height;
              var w = getTraceWidth(d, legendObj, textGap, isGrouped);
              var next = oneRowLegend ? w : maxItemWidth;
              if (!isFraction) {
                next += itemGap;
              }
              if (next + bw + offsetX - itemGap >= legendObj._maxWidth) {
                maxRowWidth = Math.max(maxRowWidth, rowWidth);
                offsetX = 0;
                offsetY += maxItemHeightInRow;
                legendObj._height += maxItemHeightInRow;
                maxItemHeightInRow = 0;
              }
              Drawing.setTranslate(
                this,
                titleSize[0] + bw + offsetX,
                titleSize[1] + bw + offsetY + h / 2 + itemGap
              );
              rowWidth = offsetX + w + itemGap;
              offsetX += next;
              maxItemHeightInRow = Math.max(maxItemHeightInRow, h);
            });
            if (oneRowLegend) {
              legendObj._width = offsetX + bw2;
              legendObj._height = maxItemHeightInRow + endPad;
            } else {
              legendObj._width = Math.max(maxRowWidth, rowWidth) + bw2;
              legendObj._height += maxItemHeightInRow + endPad;
            }
          }
        }
        legendObj._width = Math.ceil(
          Math.max(
            legendObj._width + titleSize[0],
            legendObj._titleWidth + 2 * (bw + constants.titlePad)
          )
        );
        legendObj._height = Math.ceil(
          Math.max(
            legendObj._height + titleSize[1],
            legendObj._titleHeight + 2 * (bw + constants.itemGap)
          )
        );
        legendObj._effHeight = Math.min(legendObj._height, legendObj._maxHeight);
        var edits = gd._context.edits;
        var isEditable = edits.legendText || edits.legendPosition;
        traces.each(function(d) {
          var traceToggle = d3.select(this).select("." + legendId + "toggle");
          var h = d[0].height;
          var legendgroup = d[0].trace.legendgroup;
          var traceWidth = getTraceWidth(d, legendObj, textGap);
          if (isGrouped && legendgroup !== "") {
            traceWidth = legendGroupWidths[legendgroup];
          }
          var w = isEditable ? textGap : toggleRectWidth || traceWidth;
          if (!isVertical && !isFraction) {
            w += itemGap / 2;
          }
          Drawing.setRect(traceToggle, 0, -h / 2, w, h);
        });
      }
      function expandMargin(gd, legendId, lx, ly) {
        var fullLayout = gd._fullLayout;
        var legendObj = fullLayout[legendId];
        var xanchor = getXanchor(legendObj);
        var yanchor = getYanchor(legendObj);
        var isPaperX = legendObj.xref === "paper";
        var isPaperY = legendObj.yref === "paper";
        gd._fullLayout._reservedMargin[legendId] = {};
        var sideY = legendObj.y < 0.5 ? "b" : "t";
        var sideX = legendObj.x < 0.5 ? "l" : "r";
        var possibleReservedMargins = {
          r: fullLayout.width - lx,
          l: lx + legendObj._width,
          b: fullLayout.height - ly,
          t: ly + legendObj._effHeight
        };
        if (isPaperX && isPaperY) {
          return Plots.autoMargin(gd, legendId, {
            x: legendObj.x,
            y: legendObj.y,
            l: legendObj._width * FROM_TL[xanchor],
            r: legendObj._width * FROM_BR[xanchor],
            b: legendObj._effHeight * FROM_BR[yanchor],
            t: legendObj._effHeight * FROM_TL[yanchor]
          });
        } else if (isPaperX) {
          gd._fullLayout._reservedMargin[legendId][sideY] = possibleReservedMargins[sideY];
        } else if (isPaperY) {
          gd._fullLayout._reservedMargin[legendId][sideX] = possibleReservedMargins[sideX];
        } else {
          if (legendObj.orientation === "v") {
            gd._fullLayout._reservedMargin[legendId][sideX] = possibleReservedMargins[sideX];
          } else {
            gd._fullLayout._reservedMargin[legendId][sideY] = possibleReservedMargins[sideY];
          }
        }
      }
      function getXanchor(legendObj) {
        return Lib.isRightAnchor(legendObj) ? "right" : Lib.isCenterAnchor(legendObj) ? "center" : "left";
      }
      function getYanchor(legendObj) {
        return Lib.isBottomAnchor(legendObj) ? "bottom" : Lib.isMiddleAnchor(legendObj) ? "middle" : "top";
      }
      function getId(legendObj) {
        return legendObj._id || "legend";
      }
    }
  });

  // src/components/fx/hover.js
  var require_hover = __commonJS({
    "src/components/fx/hover.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var Lib = require_lib();
      var pushUnique = Lib.pushUnique;
      var strTranslate = Lib.strTranslate;
      var strRotate = Lib.strRotate;
      var Events = require_events2();
      var svgTextUtils = require_svg_text_utils();
      var overrideCursor = require_override_cursor();
      var Drawing = require_drawing();
      var Color = require_color();
      var dragElement = require_dragelement();
      var Axes = require_axes();
      var zindexSeparator = require_constants2().zindexSeparator;
      var Registry = require_registry();
      var helpers = require_helpers2();
      var constants = require_constants();
      var legendSupplyDefaults = require_defaults3();
      var legendDraw = require_draw();
      var YANGLE = constants.YANGLE;
      var YA_RADIANS = Math.PI * YANGLE / 180;
      var YFACTOR = 1 / Math.sin(YA_RADIANS);
      var YSHIFTX = Math.cos(YA_RADIANS);
      var YSHIFTY = Math.sin(YA_RADIANS);
      var HOVERARROWSIZE = constants.HOVERARROWSIZE;
      var HOVERTEXTPAD = constants.HOVERTEXTPAD;
      var multipleHoverPoints = {
        box: true,
        ohlc: true,
        violin: true,
        candlestick: true
      };
      var cartesianScatterPoints = {
        scatter: true,
        scattergl: true,
        splom: true
      };
      function distanceSort(a, b) {
        return a.distance - b.distance;
      }
      exports.hover = function hover(gd, evt, subplot, noHoverEvent) {
        gd = Lib.getGraphDiv(gd);
        var eventTarget = evt.target;
        Lib.throttle(
          gd._fullLayout._uid + constants.HOVERID,
          constants.HOVERMINTIME,
          function() {
            _hover(gd, evt, subplot, noHoverEvent, eventTarget);
          }
        );
      };
      exports.loneHover = function loneHover(hoverItems, opts) {
        var multiHover = true;
        if (!Array.isArray(hoverItems)) {
          multiHover = false;
          hoverItems = [hoverItems];
        }
        var gd = opts.gd;
        var gTop = getTopOffset(gd);
        var gLeft = getLeftOffset(gd);
        var pointsData = hoverItems.map(function(hoverItem) {
          var _x0 = hoverItem._x0 || hoverItem.x0 || hoverItem.x || 0;
          var _x1 = hoverItem._x1 || hoverItem.x1 || hoverItem.x || 0;
          var _y0 = hoverItem._y0 || hoverItem.y0 || hoverItem.y || 0;
          var _y1 = hoverItem._y1 || hoverItem.y1 || hoverItem.y || 0;
          var eventData = hoverItem.eventData;
          if (eventData) {
            var x0 = Math.min(_x0, _x1);
            var x1 = Math.max(_x0, _x1);
            var y0 = Math.min(_y0, _y1);
            var y1 = Math.max(_y0, _y1);
            var trace = hoverItem.trace;
            if (Registry.traceIs(trace, "gl3d")) {
              var container = gd._fullLayout[trace.scene]._scene.container;
              var dx = container.offsetLeft;
              var dy = container.offsetTop;
              x0 += dx;
              x1 += dx;
              y0 += dy;
              y1 += dy;
            }
            eventData.bbox = {
              x0: x0 + gLeft,
              x1: x1 + gLeft,
              y0: y0 + gTop,
              y1: y1 + gTop
            };
            if (opts.inOut_bbox) {
              opts.inOut_bbox.push(eventData.bbox);
            }
          } else {
            eventData = false;
          }
          return {
            color: hoverItem.color || Color.defaultLine,
            x0: hoverItem.x0 || hoverItem.x || 0,
            x1: hoverItem.x1 || hoverItem.x || 0,
            y0: hoverItem.y0 || hoverItem.y || 0,
            y1: hoverItem.y1 || hoverItem.y || 0,
            xLabel: hoverItem.xLabel,
            yLabel: hoverItem.yLabel,
            zLabel: hoverItem.zLabel,
            text: hoverItem.text,
            name: hoverItem.name,
            idealAlign: hoverItem.idealAlign,
            // optional extra bits of styling
            borderColor: hoverItem.borderColor,
            fontFamily: hoverItem.fontFamily,
            fontSize: hoverItem.fontSize,
            fontColor: hoverItem.fontColor,
            fontWeight: hoverItem.fontWeight,
            fontStyle: hoverItem.fontStyle,
            fontVariant: hoverItem.fontVariant,
            nameLength: hoverItem.nameLength,
            textAlign: hoverItem.textAlign,
            // filler to make createHoverText happy
            trace: hoverItem.trace || {
              index: 0,
              hoverinfo: ""
            },
            xa: { _offset: 0 },
            ya: { _offset: 0 },
            index: 0,
            hovertemplate: hoverItem.hovertemplate || false,
            hovertemplateLabels: hoverItem.hovertemplateLabels || false,
            eventData
          };
        });
        var rotateLabels = false;
        var hoverText = createHoverText(pointsData, {
          gd,
          hovermode: "closest",
          rotateLabels,
          bgColor: opts.bgColor || Color.background,
          container: d3.select(opts.container),
          outerContainer: opts.outerContainer || opts.container
        });
        var hoverLabel = hoverText.hoverLabels;
        var tooltipSpacing = 5;
        var lastBottomY = 0;
        var anchor = 0;
        hoverLabel.sort(function(a, b) {
          return a.y0 - b.y0;
        }).each(function(d, i) {
          var topY = d.y0 - d.by / 2;
          if (topY - tooltipSpacing < lastBottomY) {
            d.offset = lastBottomY - topY + tooltipSpacing;
          } else {
            d.offset = 0;
          }
          lastBottomY = topY + d.by + d.offset;
          if (i === opts.anchorIndex || 0) anchor = d.offset;
        }).each(function(d) {
          d.offset -= anchor;
        });
        var scaleX = gd._fullLayout._invScaleX;
        var scaleY = gd._fullLayout._invScaleY;
        alignHoverText(hoverLabel, rotateLabels, scaleX, scaleY);
        return multiHover ? hoverLabel : hoverLabel.node();
      };
      function _hover(gd, evt, subplot, noHoverEvent, eventTarget) {
        if (!subplot) subplot = "xy";
        if (typeof subplot === "string") {
          subplot = subplot.split(zindexSeparator)[0];
        }
        var subplots = Array.isArray(subplot) ? subplot : [subplot];
        var spId;
        var fullLayout = gd._fullLayout;
        var hoversubplots = fullLayout.hoversubplots;
        var plots = fullLayout._plots || [];
        var plotinfo = plots[subplot];
        var hasCartesian = fullLayout._has("cartesian");
        var hovermode = evt.hovermode || fullLayout.hovermode;
        var hovermodeHasX = (hovermode || "").charAt(0) === "x";
        var hovermodeHasY = (hovermode || "").charAt(0) === "y";
        var firstXaxis;
        var firstYaxis;
        if (hasCartesian && (hovermodeHasX || hovermodeHasY) && hoversubplots === "axis") {
          var subplotsLength = subplots.length;
          for (var p = 0; p < subplotsLength; p++) {
            spId = subplots[p];
            if (plots[spId]) {
              firstXaxis = Axes.getFromId(gd, spId, "x");
              firstYaxis = Axes.getFromId(gd, spId, "y");
              var subplotsWith = (hovermodeHasX ? firstXaxis : firstYaxis)._subplotsWith;
              if (subplotsWith && subplotsWith.length) {
                for (var q = 0; q < subplotsWith.length; q++) {
                  pushUnique(subplots, subplotsWith[q]);
                }
              }
            }
          }
        }
        if (plotinfo && hoversubplots !== "single") {
          var overlayedSubplots = plotinfo.overlays.map(function(pi) {
            return pi.id;
          });
          subplots = subplots.concat(overlayedSubplots);
        }
        var len = subplots.length;
        var xaArray = new Array(len);
        var yaArray = new Array(len);
        var supportsCompare = false;
        for (var i = 0; i < len; i++) {
          spId = subplots[i];
          if (plots[spId]) {
            supportsCompare = true;
            xaArray[i] = plots[spId].xaxis;
            yaArray[i] = plots[spId].yaxis;
          } else if (fullLayout[spId] && fullLayout[spId]._subplot) {
            var _subplot = fullLayout[spId]._subplot;
            xaArray[i] = _subplot.xaxis;
            yaArray[i] = _subplot.yaxis;
          } else {
            Lib.warn("Unrecognized subplot: " + spId);
            return;
          }
        }
        if (hovermode && !supportsCompare) hovermode = "closest";
        if (["x", "y", "closest", "x unified", "y unified"].indexOf(hovermode) === -1 || !gd.calcdata || gd.querySelector(".zoombox") || gd._dragging) {
          return dragElement.unhoverRaw(gd, evt);
        }
        var hoverdistance = fullLayout.hoverdistance;
        if (hoverdistance === -1) hoverdistance = Infinity;
        var spikedistance = fullLayout.spikedistance;
        if (spikedistance === -1) spikedistance = Infinity;
        var hoverData = [];
        var searchData = [];
        var xvalArray, yvalArray;
        var itemnum, curvenum, cd, trace, subplotId, subploti, _mode, xval, yval, pointData, closedataPreviousLength;
        var spikePoints = {
          hLinePoint: null,
          vLinePoint: null
        };
        var hasOneHorizontalTrace = false;
        if (Array.isArray(evt)) {
          hovermode = "array";
          for (itemnum = 0; itemnum < evt.length; itemnum++) {
            cd = gd.calcdata[evt[itemnum].curveNumber || 0];
            if (cd) {
              trace = cd[0].trace;
              if (cd[0].trace.hoverinfo !== "skip") {
                searchData.push(cd);
                if (trace.orientation === "h") {
                  hasOneHorizontalTrace = true;
                }
              }
            }
          }
        } else {
          var zorderedCalcdata = gd.calcdata.slice();
          zorderedCalcdata.sort(function(a, b) {
            var aZorder = a[0].trace.zorder || 0;
            var bZorder = b[0].trace.zorder || 0;
            return aZorder - bZorder;
          });
          for (curvenum = 0; curvenum < zorderedCalcdata.length; curvenum++) {
            cd = zorderedCalcdata[curvenum];
            trace = cd[0].trace;
            if (trace.hoverinfo !== "skip" && helpers.isTraceInSubplots(trace, subplots)) {
              searchData.push(cd);
              if (trace.orientation === "h") {
                hasOneHorizontalTrace = true;
              }
            }
          }
          var hasUserCalledHover = !eventTarget;
          var xpx, ypx;
          if (hasUserCalledHover) {
            if ("xpx" in evt) xpx = evt.xpx;
            else xpx = xaArray[0]._length / 2;
            if ("ypx" in evt) ypx = evt.ypx;
            else ypx = yaArray[0]._length / 2;
          } else {
            if (Events.triggerHandler(gd, "plotly_beforehover", evt) === false) {
              return;
            }
            var dbb = eventTarget.getBoundingClientRect();
            xpx = evt.clientX - dbb.left;
            ypx = evt.clientY - dbb.top;
            fullLayout._calcInverseTransform(gd);
            var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(xpx, ypx);
            xpx = transformedCoords[0];
            ypx = transformedCoords[1];
            if (xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {
              return dragElement.unhoverRaw(gd, evt);
            }
          }
          evt.pointerX = xpx + xaArray[0]._offset;
          evt.pointerY = ypx + yaArray[0]._offset;
          if ("xval" in evt) xvalArray = helpers.flat(subplots, evt.xval);
          else xvalArray = helpers.p2c(xaArray, xpx);
          if ("yval" in evt) yvalArray = helpers.flat(subplots, evt.yval);
          else yvalArray = helpers.p2c(yaArray, ypx);
          if (!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {
            Lib.warn("Fx.hover failed", evt, gd);
            return dragElement.unhoverRaw(gd, evt);
          }
        }
        var distance = Infinity;
        function findHoverPoints(customXVal, customYVal) {
          for (curvenum = 0; curvenum < searchData.length; curvenum++) {
            cd = searchData[curvenum];
            if (!cd || !cd[0] || !cd[0].trace) continue;
            trace = cd[0].trace;
            if (trace.visible !== true || trace._length === 0) continue;
            if (["carpet", "contourcarpet"].indexOf(trace._module.name) !== -1) continue;
            _mode = hovermode;
            if (helpers.isUnifiedHover(_mode)) {
              _mode = _mode.charAt(0);
            }
            if (trace.type === "splom") {
              subploti = 0;
              subplotId = subplots[subploti];
            } else {
              subplotId = helpers.getSubplot(trace);
              subploti = subplots.indexOf(subplotId);
            }
            pointData = {
              // trace properties
              cd,
              trace,
              xa: xaArray[subploti],
              ya: yaArray[subploti],
              // max distances for hover and spikes - for points that want to show but do not
              // want to override other points, set distance/spikeDistance equal to max*Distance
              // and it will not get filtered out but it will be guaranteed to have a greater
              // distance than any point that calculated a real distance.
              maxHoverDistance: hoverdistance,
              maxSpikeDistance: spikedistance,
              // point properties - override all of these
              index: false,
              // point index in trace - only used by plotly.js hoverdata consumers
              distance: Math.min(distance, hoverdistance),
              // pixel distance or pseudo-distance
              // distance/pseudo-distance for spikes. This distance should always be calculated
              // as if in "closest" mode, and should only be set if this point should
              // generate a spike.
              spikeDistance: Infinity,
              // in some cases the spikes have different positioning from the hover label
              // they don't need x0/x1, just one position
              xSpike: void 0,
              ySpike: void 0,
              // where and how to display the hover label
              color: Color.defaultLine,
              // trace color
              name: trace.name,
              x0: void 0,
              x1: void 0,
              y0: void 0,
              y1: void 0,
              xLabelVal: void 0,
              yLabelVal: void 0,
              zLabelVal: void 0,
              text: void 0
            };
            if (fullLayout[subplotId]) {
              pointData.subplot = fullLayout[subplotId]._subplot;
            }
            if (fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {
              pointData.scene = fullLayout._splomScenes[trace.uid];
            }
            if (_mode === "array") {
              var selection = evt[curvenum];
              if ("pointNumber" in selection) {
                pointData.index = selection.pointNumber;
                _mode = "closest";
              } else {
                _mode = "";
                if ("xval" in selection) {
                  xval = selection.xval;
                  _mode = "x";
                }
                if ("yval" in selection) {
                  yval = selection.yval;
                  _mode = _mode ? "closest" : "y";
                }
              }
            } else if (customXVal !== void 0 && customYVal !== void 0) {
              xval = customXVal;
              yval = customYVal;
            } else {
              xval = xvalArray[subploti];
              yval = yvalArray[subploti];
            }
            closedataPreviousLength = hoverData.length;
            if (hoverdistance !== 0) {
              if (trace._module && trace._module.hoverPoints) {
                var newPoints = trace._module.hoverPoints(pointData, xval, yval, _mode, {
                  finiteRange: true,
                  hoverLayer: fullLayout._hoverlayer,
                  // options for splom when hovering on same axis
                  hoversubplots,
                  gd
                });
                if (newPoints) {
                  var newPoint;
                  for (var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {
                    newPoint = newPoints[newPointNum];
                    if (isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {
                      hoverData.push(cleanPoint(newPoint, hovermode));
                    }
                  }
                }
              } else {
                Lib.log("Unrecognized trace type in hover:", trace);
              }
            }
            if (hovermode === "closest" && hoverData.length > closedataPreviousLength) {
              hoverData.splice(0, closedataPreviousLength);
              distance = hoverData[0].distance;
            }
            if (hasCartesian && spikedistance !== 0) {
              if (hoverData.length === 0) {
                pointData.distance = spikedistance;
                pointData.index = false;
                var closestPoints = trace._module.hoverPoints(pointData, xval, yval, "closest", {
                  hoverLayer: fullLayout._hoverlayer
                });
                if (closestPoints) {
                  closestPoints = closestPoints.filter(function(point) {
                    return point.spikeDistance <= spikedistance;
                  });
                }
                if (closestPoints && closestPoints.length) {
                  var tmpPoint;
                  var closestVPoints = closestPoints.filter(function(point) {
                    return point.xa.showspikes && point.xa.spikesnap !== "hovered data";
                  });
                  if (closestVPoints.length) {
                    var closestVPt = closestVPoints[0];
                    if (isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {
                      tmpPoint = fillSpikePoint(closestVPt);
                      if (!spikePoints.vLinePoint || spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance) {
                        spikePoints.vLinePoint = tmpPoint;
                      }
                    }
                  }
                  var closestHPoints = closestPoints.filter(function(point) {
                    return point.ya.showspikes && point.ya.spikesnap !== "hovered data";
                  });
                  if (closestHPoints.length) {
                    var closestHPt = closestHPoints[0];
                    if (isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {
                      tmpPoint = fillSpikePoint(closestHPt);
                      if (!spikePoints.hLinePoint || spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance) {
                        spikePoints.hLinePoint = tmpPoint;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        findHoverPoints();
        function selectClosestPoint(pointsData, spikedistance2, spikeOnWinning2) {
          var resultPoint = null;
          var minDistance = Infinity;
          var thisSpikeDistance;
          for (var i2 = 0; i2 < pointsData.length; i2++) {
            if (firstXaxis && firstXaxis._id !== pointsData[i2].xa._id) continue;
            if (firstYaxis && firstYaxis._id !== pointsData[i2].ya._id) continue;
            thisSpikeDistance = pointsData[i2].spikeDistance;
            if (spikeOnWinning2 && i2 === 0) thisSpikeDistance = -Infinity;
            if (thisSpikeDistance <= minDistance && thisSpikeDistance <= spikedistance2) {
              resultPoint = pointsData[i2];
              minDistance = thisSpikeDistance;
            }
          }
          return resultPoint;
        }
        function fillSpikePoint(point) {
          if (!point) return null;
          return {
            xa: point.xa,
            ya: point.ya,
            x: point.xSpike !== void 0 ? point.xSpike : (point.x0 + point.x1) / 2,
            y: point.ySpike !== void 0 ? point.ySpike : (point.y0 + point.y1) / 2,
            distance: point.distance,
            spikeDistance: point.spikeDistance,
            curveNumber: point.trace.index,
            color: point.color,
            pointNumber: point.index
          };
        }
        var spikelineOpts = {
          fullLayout,
          container: fullLayout._hoverlayer,
          event: evt
        };
        var oldspikepoints = gd._spikepoints;
        var newspikepoints = {
          vLinePoint: spikePoints.vLinePoint,
          hLinePoint: spikePoints.hLinePoint
        };
        gd._spikepoints = newspikepoints;
        var sortHoverData = function() {
          var hoverDataInSubplot = hoverData.filter(function(a) {
            return firstXaxis && firstXaxis._id === a.xa._id && (firstYaxis && firstYaxis._id === a.ya._id);
          });
          var hoverDataOutSubplot = hoverData.filter(function(a) {
            return !(firstXaxis && firstXaxis._id === a.xa._id && (firstYaxis && firstYaxis._id === a.ya._id));
          });
          hoverDataInSubplot.sort(distanceSort);
          hoverDataOutSubplot.sort(distanceSort);
          hoverData = hoverDataInSubplot.concat(hoverDataOutSubplot);
          hoverData = orderRangePoints(hoverData, hovermode);
        };
        sortHoverData();
        var axLetter = hovermode.charAt(0);
        var spikeOnWinning = (axLetter === "x" || axLetter === "y") && hoverData[0] && cartesianScatterPoints[hoverData[0].trace.type];
        if (hasCartesian && spikedistance !== 0) {
          if (hoverData.length !== 0) {
            var tmpHPointData = hoverData.filter(function(point) {
              return point.ya.showspikes;
            });
            var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance, spikeOnWinning);
            spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);
            var tmpVPointData = hoverData.filter(function(point) {
              return point.xa.showspikes;
            });
            var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance, spikeOnWinning);
            spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);
          }
        }
        if (hoverData.length === 0) {
          var result = dragElement.unhoverRaw(gd, evt);
          if (hasCartesian && (spikePoints.hLinePoint !== null || spikePoints.vLinePoint !== null)) {
            if (spikesChanged(oldspikepoints)) {
              createSpikelines(gd, spikePoints, spikelineOpts);
            }
          }
          return result;
        }
        if (hasCartesian) {
          if (spikesChanged(oldspikepoints)) {
            createSpikelines(gd, spikePoints, spikelineOpts);
          }
        }
        if (helpers.isXYhover(_mode) && hoverData[0].length !== 0 && hoverData[0].trace.type !== "splom") {
          var winningPoint = hoverData[0];
          if (multipleHoverPoints[winningPoint.trace.type]) {
            hoverData = hoverData.filter(function(d) {
              return d.trace.index === winningPoint.trace.index;
            });
          } else {
            hoverData = [winningPoint];
          }
          var initLen = hoverData.length;
          var winX = getCoord("x", winningPoint, fullLayout);
          var winY = getCoord("y", winningPoint, fullLayout);
          findHoverPoints(winX, winY);
          var finalPoints = [];
          var seen = {};
          var id = 0;
          var insert = function(newHd) {
            var key = multipleHoverPoints[newHd.trace.type] ? hoverDataKey(newHd) : newHd.trace.index;
            if (!seen[key]) {
              id++;
              seen[key] = id;
              finalPoints.push(newHd);
            } else {
              var oldId = seen[key] - 1;
              var oldHd = finalPoints[oldId];
              if (oldId > 0 && Math.abs(newHd.distance) < Math.abs(oldHd.distance)) {
                finalPoints[oldId] = newHd;
              }
            }
          };
          var k;
          for (k = 0; k < initLen; k++) {
            insert(hoverData[k]);
          }
          for (k = hoverData.length - 1; k > initLen - 1; k--) {
            insert(hoverData[k]);
          }
          hoverData = finalPoints;
          sortHoverData();
        }
        var oldhoverdata = gd._hoverdata;
        var newhoverdata = [];
        var gTop = getTopOffset(gd);
        var gLeft = getLeftOffset(gd);
        for (itemnum = 0; itemnum < hoverData.length; itemnum++) {
          var pt = hoverData[itemnum];
          var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);
          if (pt.hovertemplate !== false) {
            var ht = false;
            if (pt.cd[pt.index] && pt.cd[pt.index].ht) {
              ht = pt.cd[pt.index].ht;
            }
            pt.hovertemplate = ht || pt.trace.hovertemplate || false;
          }
          if (pt.xa && pt.ya) {
            var _x0 = pt.x0 + pt.xa._offset;
            var _x1 = pt.x1 + pt.xa._offset;
            var _y0 = pt.y0 + pt.ya._offset;
            var _y1 = pt.y1 + pt.ya._offset;
            var x0 = Math.min(_x0, _x1);
            var x1 = Math.max(_x0, _x1);
            var y0 = Math.min(_y0, _y1);
            var y1 = Math.max(_y0, _y1);
            eventData.bbox = {
              x0: x0 + gLeft,
              x1: x1 + gLeft,
              y0: y0 + gTop,
              y1: y1 + gTop
            };
          }
          pt.eventData = [eventData];
          newhoverdata.push(eventData);
        }
        gd._hoverdata = newhoverdata;
        var rotateLabels = hovermode === "y" && (searchData.length > 1 || hoverData.length > 1) || hovermode === "closest" && hasOneHorizontalTrace && hoverData.length > 1;
        var bgColor = Color.combine(
          fullLayout.plot_bgcolor || Color.background,
          fullLayout.paper_bgcolor
        );
        var hoverText = createHoverText(hoverData, {
          gd,
          hovermode,
          rotateLabels,
          bgColor,
          container: fullLayout._hoverlayer,
          outerContainer: fullLayout._paper.node(),
          commonLabelOpts: fullLayout.hoverlabel,
          hoverdistance: fullLayout.hoverdistance
        });
        var hoverLabels = hoverText.hoverLabels;
        if (!helpers.isUnifiedHover(hovermode)) {
          hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, hoverText.commonLabelBoundingBox);
          alignHoverText(hoverLabels, rotateLabels, fullLayout._invScaleX, fullLayout._invScaleY);
        }
        if (eventTarget && eventTarget.tagName) {
          var hasClickToShow = Registry.getComponentMethod("annotations", "hasClickToShow")(gd, newhoverdata);
          overrideCursor(d3.select(eventTarget), hasClickToShow ? "pointer" : "");
        }
        if (!eventTarget || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;
        if (oldhoverdata) {
          gd.emit("plotly_unhover", {
            event: evt,
            points: oldhoverdata
          });
        }
        gd.emit("plotly_hover", {
          event: evt,
          points: gd._hoverdata,
          xaxes: xaArray,
          yaxes: yaArray,
          xvals: xvalArray,
          yvals: yvalArray
        });
      }
      function hoverDataKey(d) {
        return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa ? d.xa._id : "", d.ya ? d.ya._id : ""].join(",");
      }
      var EXTRA_STRING_REGEX = /<extra>([\s\S]*)<\/extra>/;
      function createHoverText(hoverData, opts) {
        var gd = opts.gd;
        var fullLayout = gd._fullLayout;
        var hovermode = opts.hovermode;
        var rotateLabels = opts.rotateLabels;
        var bgColor = opts.bgColor;
        var container = opts.container;
        var outerContainer = opts.outerContainer;
        var commonLabelOpts = opts.commonLabelOpts || {};
        if (hoverData.length === 0) return [[]];
        var fontFamily = opts.fontFamily || constants.HOVERFONT;
        var fontSize = opts.fontSize || constants.HOVERFONTSIZE;
        var fontWeight = opts.fontWeight || fullLayout.font.weight;
        var fontStyle = opts.fontStyle || fullLayout.font.style;
        var fontVariant = opts.fontVariant || fullLayout.font.variant;
        var fontTextcase = opts.fontTextcase || fullLayout.font.textcase;
        var fontLineposition = opts.fontLineposition || fullLayout.font.lineposition;
        var fontShadow = opts.fontShadow || fullLayout.font.shadow;
        var c0 = hoverData[0];
        var xa = c0.xa;
        var ya = c0.ya;
        var axLetter = hovermode.charAt(0);
        var axLabel = axLetter + "Label";
        var t0 = c0[axLabel];
        if (t0 === void 0 && xa.type === "multicategory") {
          for (var q = 0; q < hoverData.length; q++) {
            t0 = hoverData[q][axLabel];
            if (t0 !== void 0) break;
          }
        }
        var outerContainerBB = getBoundingClientRect(gd, outerContainer);
        var outerTop = outerContainerBB.top;
        var outerWidth = outerContainerBB.width;
        var outerHeight = outerContainerBB.height;
        var showCommonLabel = t0 !== void 0 && c0.distance <= opts.hoverdistance && (hovermode === "x" || hovermode === "y");
        if (showCommonLabel) {
          var allHaveZ = true;
          var i, traceHoverinfo;
          for (i = 0; i < hoverData.length; i++) {
            if (allHaveZ && hoverData[i].zLabel === void 0) allHaveZ = false;
            traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;
            if (traceHoverinfo) {
              var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split("+");
              if (parts.indexOf("all") === -1 && parts.indexOf(hovermode) === -1) {
                showCommonLabel = false;
                break;
              }
            }
          }
          if (allHaveZ) showCommonLabel = false;
        }
        var commonLabel = container.selectAll("g.axistext").data(showCommonLabel ? [0] : []);
        commonLabel.enter().append("g").classed("axistext", true);
        commonLabel.exit().remove();
        var commonLabelRect = {
          minX: 0,
          maxX: 0,
          minY: 0,
          maxY: 0
        };
        commonLabel.each(function() {
          var label = d3.select(this);
          var lpath = Lib.ensureSingle(label, "path", "", function(s) {
            s.style({ "stroke-width": "1px" });
          });
          var ltext = Lib.ensureSingle(label, "text", "", function(s) {
            s.attr("data-notex", 1);
          });
          var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;
          var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);
          var contrastColor = Color.contrast(commonBgColor);
          var commonLabelOptsFont = commonLabelOpts.font;
          var commonLabelFont = {
            weight: commonLabelOptsFont.weight || fontWeight,
            style: commonLabelOptsFont.style || fontStyle,
            variant: commonLabelOptsFont.variant || fontVariant,
            textcase: commonLabelOptsFont.textcase || fontTextcase,
            lineposition: commonLabelOptsFont.lineposition || fontLineposition,
            shadow: commonLabelOptsFont.shadow || fontShadow,
            family: commonLabelOptsFont.family || fontFamily,
            size: commonLabelOptsFont.size || fontSize,
            color: commonLabelOptsFont.color || contrastColor
          };
          lpath.style({
            fill: commonBgColor,
            stroke: commonStroke
          });
          ltext.text(t0).call(Drawing.font, commonLabelFont).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
          label.attr("transform", "");
          var tbb2 = getBoundingClientRect(gd, ltext.node());
          var lx2, ly2;
          if (hovermode === "x") {
            var topsign = xa.side === "top" ? "-" : "";
            ltext.attr("text-anchor", "middle").call(svgTextUtils.positionText, 0, xa.side === "top" ? outerTop - tbb2.bottom - HOVERARROWSIZE - HOVERTEXTPAD : outerTop - tbb2.top + HOVERARROWSIZE + HOVERTEXTPAD);
            lx2 = xa._offset + (c0.x0 + c0.x1) / 2;
            ly2 = ya._offset + (xa.side === "top" ? 0 : ya._length);
            var halfWidth = tbb2.width / 2 + HOVERTEXTPAD;
            var tooltipMidX = lx2;
            if (lx2 < halfWidth) {
              tooltipMidX = halfWidth;
            } else if (lx2 > fullLayout.width - halfWidth) {
              tooltipMidX = fullLayout.width - halfWidth;
            }
            lpath.attr("d", "M" + (lx2 - tooltipMidX) + ",0L" + (lx2 - tooltipMidX + HOVERARROWSIZE) + "," + topsign + HOVERARROWSIZE + "H" + halfWidth + "v" + topsign + (HOVERTEXTPAD * 2 + tbb2.height) + "H" + -halfWidth + "V" + topsign + HOVERARROWSIZE + "H" + (lx2 - tooltipMidX - HOVERARROWSIZE) + "Z");
            lx2 = tooltipMidX;
            commonLabelRect.minX = lx2 - halfWidth;
            commonLabelRect.maxX = lx2 + halfWidth;
            if (xa.side === "top") {
              commonLabelRect.minY = ly2 - (HOVERTEXTPAD * 2 + tbb2.height);
              commonLabelRect.maxY = ly2 - HOVERTEXTPAD;
            } else {
              commonLabelRect.minY = ly2 + HOVERTEXTPAD;
              commonLabelRect.maxY = ly2 + (HOVERTEXTPAD * 2 + tbb2.height);
            }
          } else {
            var anchor;
            var sgn;
            var leftsign;
            if (ya.side === "right") {
              anchor = "start";
              sgn = 1;
              leftsign = "";
              lx2 = xa._offset + xa._length;
            } else {
              anchor = "end";
              sgn = -1;
              leftsign = "-";
              lx2 = xa._offset;
            }
            ly2 = ya._offset + (c0.y0 + c0.y1) / 2;
            ltext.attr("text-anchor", anchor);
            lpath.attr("d", "M0,0L" + leftsign + HOVERARROWSIZE + "," + HOVERARROWSIZE + "V" + (HOVERTEXTPAD + tbb2.height / 2) + "h" + leftsign + (HOVERTEXTPAD * 2 + tbb2.width) + "V-" + (HOVERTEXTPAD + tbb2.height / 2) + "H" + leftsign + HOVERARROWSIZE + "V-" + HOVERARROWSIZE + "Z");
            commonLabelRect.minY = ly2 - (HOVERTEXTPAD + tbb2.height / 2);
            commonLabelRect.maxY = ly2 + (HOVERTEXTPAD + tbb2.height / 2);
            if (ya.side === "right") {
              commonLabelRect.minX = lx2 + HOVERARROWSIZE;
              commonLabelRect.maxX = lx2 + HOVERARROWSIZE + (HOVERTEXTPAD * 2 + tbb2.width);
            } else {
              commonLabelRect.minX = lx2 - HOVERARROWSIZE - (HOVERTEXTPAD * 2 + tbb2.width);
              commonLabelRect.maxX = lx2 - HOVERARROWSIZE;
            }
            var halfHeight = tbb2.height / 2;
            var lty = outerTop - tbb2.top - halfHeight;
            var clipId = "clip" + fullLayout._uid + "commonlabel" + ya._id;
            var clipPath;
            if (lx2 < tbb2.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE) {
              clipPath = "M-" + (HOVERARROWSIZE + HOVERTEXTPAD) + "-" + halfHeight + "h-" + (tbb2.width - HOVERTEXTPAD) + "V" + halfHeight + "h" + (tbb2.width - HOVERTEXTPAD) + "Z";
              var ltx = tbb2.width - lx2 + HOVERTEXTPAD;
              svgTextUtils.positionText(ltext, ltx, lty);
              if (anchor === "end") {
                ltext.selectAll("tspan").each(function() {
                  var s = d3.select(this);
                  var dummy = Drawing.tester.append("text").text(s.text()).call(Drawing.font, commonLabelFont);
                  var dummyBB = getBoundingClientRect(gd, dummy.node());
                  if (Math.round(dummyBB.width) < Math.round(tbb2.width)) {
                    s.attr("x", ltx - dummyBB.width);
                  }
                  dummy.remove();
                });
              }
            } else {
              svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);
              clipPath = null;
            }
            var textClip = fullLayout._topclips.selectAll("#" + clipId).data(clipPath ? [0] : []);
            textClip.enter().append("clipPath").attr("id", clipId).append("path");
            textClip.exit().remove();
            textClip.select("path").attr("d", clipPath);
            Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);
          }
          label.attr("transform", strTranslate(lx2, ly2));
        });
        if (helpers.isUnifiedHover(hovermode)) {
          container.selectAll("g.hovertext").remove();
          var groupedHoverData = hoverData.filter(function(data) {
            return data.hoverinfo !== "none";
          });
          if (groupedHoverData.length === 0) return [];
          var hoverlabel = fullLayout.hoverlabel;
          var font = hoverlabel.font;
          var mockLayoutIn = {
            showlegend: true,
            legend: {
              title: { text: t0, font },
              font,
              bgcolor: hoverlabel.bgcolor,
              bordercolor: hoverlabel.bordercolor,
              borderwidth: 1,
              tracegroupgap: 7,
              traceorder: fullLayout.legend ? fullLayout.legend.traceorder : void 0,
              orientation: "v"
            }
          };
          var mockLayoutOut = {
            font
          };
          legendSupplyDefaults(mockLayoutIn, mockLayoutOut, gd._fullData);
          var mockLegend = mockLayoutOut.legend;
          mockLegend.entries = [];
          for (var j = 0; j < groupedHoverData.length; j++) {
            var pt = groupedHoverData[j];
            if (pt.hoverinfo === "none") continue;
            var texts = getHoverLabelText(pt, true, hovermode, fullLayout, t0);
            var text = texts[0];
            var name = texts[1];
            pt.name = name;
            if (name !== "") {
              pt.text = name + " : " + text;
            } else {
              pt.text = text;
            }
            var cd = pt.cd[pt.index];
            if (cd) {
              if (cd.mc) pt.mc = cd.mc;
              if (cd.mcc) pt.mc = cd.mcc;
              if (cd.mlc) pt.mlc = cd.mlc;
              if (cd.mlcc) pt.mlc = cd.mlcc;
              if (cd.mlw) pt.mlw = cd.mlw;
              if (cd.mrc) pt.mrc = cd.mrc;
              if (cd.dir) pt.dir = cd.dir;
            }
            pt._distinct = true;
            mockLegend.entries.push([pt]);
          }
          mockLegend.entries.sort(function(a, b) {
            return a[0].trace.index - b[0].trace.index;
          });
          mockLegend.layer = container;
          mockLegend._inHover = true;
          mockLegend._groupTitleFont = hoverlabel.grouptitlefont;
          legendDraw(gd, mockLegend);
          var legendContainer = container.select("g.legend");
          var tbb = getBoundingClientRect(gd, legendContainer.node());
          var tWidth = tbb.width + 2 * HOVERTEXTPAD;
          var tHeight = tbb.height + 2 * HOVERTEXTPAD;
          var winningPoint = groupedHoverData[0];
          var avgX = (winningPoint.x0 + winningPoint.x1) / 2;
          var avgY = (winningPoint.y0 + winningPoint.y1) / 2;
          var pointWon = !(Registry.traceIs(winningPoint.trace, "bar-like") || Registry.traceIs(winningPoint.trace, "box-violin"));
          var lyBottom, lyTop;
          if (axLetter === "y") {
            if (pointWon) {
              lyTop = avgY - HOVERTEXTPAD;
              lyBottom = avgY + HOVERTEXTPAD;
            } else {
              lyTop = Math.min.apply(null, groupedHoverData.map(function(c) {
                return Math.min(c.y0, c.y1);
              }));
              lyBottom = Math.max.apply(null, groupedHoverData.map(function(c) {
                return Math.max(c.y0, c.y1);
              }));
            }
          } else {
            lyTop = lyBottom = Lib.mean(groupedHoverData.map(function(c) {
              return (c.y0 + c.y1) / 2;
            })) - tHeight / 2;
          }
          var lxRight, lxLeft;
          if (axLetter === "x") {
            if (pointWon) {
              lxRight = avgX + HOVERTEXTPAD;
              lxLeft = avgX - HOVERTEXTPAD;
            } else {
              lxRight = Math.max.apply(null, groupedHoverData.map(function(c) {
                return Math.max(c.x0, c.x1);
              }));
              lxLeft = Math.min.apply(null, groupedHoverData.map(function(c) {
                return Math.min(c.x0, c.x1);
              }));
            }
          } else {
            lxRight = lxLeft = Lib.mean(groupedHoverData.map(function(c) {
              return (c.x0 + c.x1) / 2;
            })) - tWidth / 2;
          }
          var xOffset = xa._offset;
          var yOffset = ya._offset;
          lyBottom += yOffset;
          lxRight += xOffset;
          lxLeft += xOffset - tWidth;
          lyTop += yOffset - tHeight;
          var lx, ly;
          if (lxRight + tWidth < outerWidth && lxRight >= 0) {
            lx = lxRight;
          } else if (lxLeft + tWidth < outerWidth && lxLeft >= 0) {
            lx = lxLeft;
          } else if (xOffset + tWidth < outerWidth) {
            lx = xOffset;
          } else {
            if (lxRight - avgX < avgX - lxLeft + tWidth) {
              lx = outerWidth - tWidth;
            } else {
              lx = 0;
            }
          }
          lx += HOVERTEXTPAD;
          if (lyBottom + tHeight < outerHeight && lyBottom >= 0) {
            ly = lyBottom;
          } else if (lyTop + tHeight < outerHeight && lyTop >= 0) {
            ly = lyTop;
          } else if (yOffset + tHeight < outerHeight) {
            ly = yOffset;
          } else {
            if (lyBottom - avgY < avgY - lyTop + tHeight) {
              ly = outerHeight - tHeight;
            } else {
              ly = 0;
            }
          }
          ly += HOVERTEXTPAD;
          legendContainer.attr("transform", strTranslate(lx - 1, ly - 1));
          return legendContainer;
        }
        var hoverLabels = container.selectAll("g.hovertext").data(hoverData, function(d) {
          return hoverDataKey(d);
        });
        hoverLabels.enter().append("g").classed("hovertext", true).each(function() {
          var g = d3.select(this);
          g.append("rect").call(Color.fill, Color.addOpacity(bgColor, 0.8));
          g.append("text").classed("name", true);
          g.append("path").style("stroke-width", "1px");
          g.append("text").classed("nums", true).call(Drawing.font, {
            weight: fontWeight,
            style: fontStyle,
            variant: fontVariant,
            textcase: fontTextcase,
            lineposition: fontLineposition,
            shadow: fontShadow,
            family: fontFamily,
            size: fontSize
          });
        });
        hoverLabels.exit().remove();
        hoverLabels.each(function(d) {
          var g = d3.select(this).attr("transform", "");
          var dColor = d.color;
          if (Array.isArray(dColor)) {
            dColor = dColor[d.eventData[0].pointNumber];
          }
          var color0 = d.bgcolor || dColor;
          var numsColor = Color.combine(
            Color.opacity(color0) ? color0 : Color.defaultLine,
            bgColor
          );
          var nameColor = Color.combine(
            Color.opacity(dColor) ? dColor : Color.defaultLine,
            bgColor
          );
          var contrastColor = d.borderColor || Color.contrast(numsColor);
          var texts2 = getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g);
          var text2 = texts2[0];
          var name2 = texts2[1];
          var tx = g.select("text.nums").call(Drawing.font, {
            family: d.fontFamily || fontFamily,
            size: d.fontSize || fontSize,
            color: d.fontColor || contrastColor,
            weight: d.fontWeight || fontWeight,
            style: d.fontStyle || fontStyle,
            variant: d.fontVariant || fontVariant,
            textcase: d.fontTextcase || fontTextcase,
            lineposition: d.fontLineposition || fontLineposition,
            shadow: d.fontShadow || fontShadow
          }).text(text2).attr("data-notex", 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
          var tx2 = g.select("text.name");
          var tx2width = 0;
          var tx2height = 0;
          if (name2 && name2 !== text2) {
            tx2.call(Drawing.font, {
              family: d.fontFamily || fontFamily,
              size: d.fontSize || fontSize,
              color: nameColor,
              weight: d.fontWeight || fontWeight,
              style: d.fontStyle || fontStyle,
              variant: d.fontVariant || fontVariant,
              textcase: d.fontTextcase || fontTextcase,
              lineposition: d.fontLineposition || fontLineposition,
              shadow: d.fontShadow || fontShadow
            }).text(name2).attr("data-notex", 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
            var t2bb = getBoundingClientRect(gd, tx2.node());
            tx2width = t2bb.width + 2 * HOVERTEXTPAD;
            tx2height = t2bb.height + 2 * HOVERTEXTPAD;
          } else {
            tx2.remove();
            g.select("rect").remove();
          }
          g.select("path").style({
            fill: numsColor,
            stroke: contrastColor
          });
          var htx = d.xa._offset + (d.x0 + d.x1) / 2;
          var hty = d.ya._offset + (d.y0 + d.y1) / 2;
          var dx = Math.abs(d.x1 - d.x0);
          var dy = Math.abs(d.y1 - d.y0);
          var tbb2 = getBoundingClientRect(gd, tx.node());
          var tbbWidth = tbb2.width / fullLayout._invScaleX;
          var tbbHeight = tbb2.height / fullLayout._invScaleY;
          d.ty0 = (outerTop - tbb2.top) / fullLayout._invScaleY;
          d.bx = tbbWidth + 2 * HOVERTEXTPAD;
          d.by = Math.max(tbbHeight + 2 * HOVERTEXTPAD, tx2height);
          d.anchor = "start";
          d.txwidth = tbbWidth;
          d.tx2width = tx2width;
          d.offset = 0;
          var txTotalWidth = (tbbWidth + HOVERARROWSIZE + HOVERTEXTPAD + tx2width) * fullLayout._invScaleX;
          var anchorStartOK, anchorEndOK;
          if (rotateLabels) {
            d.pos = htx;
            anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;
            anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;
            if ((d.idealAlign === "top" || !anchorStartOK) && anchorEndOK) {
              hty -= dy / 2;
              d.anchor = "end";
            } else if (anchorStartOK) {
              hty += dy / 2;
              d.anchor = "start";
            } else {
              d.anchor = "middle";
            }
            d.crossPos = hty;
          } else {
            d.pos = hty;
            anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;
            anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;
            if ((d.idealAlign === "left" || !anchorStartOK) && anchorEndOK) {
              htx -= dx / 2;
              d.anchor = "end";
            } else if (anchorStartOK) {
              htx += dx / 2;
              d.anchor = "start";
            } else {
              d.anchor = "middle";
              var txHalfWidth = txTotalWidth / 2;
              var overflowR = htx + txHalfWidth - outerWidth;
              var overflowL = htx - txHalfWidth;
              if (overflowR > 0) htx -= overflowR;
              if (overflowL < 0) htx += -overflowL;
            }
            d.crossPos = htx;
          }
          tx.attr("text-anchor", d.anchor);
          if (tx2width) tx2.attr("text-anchor", d.anchor);
          g.attr("transform", strTranslate(htx, hty) + (rotateLabels ? strRotate(YANGLE) : ""));
        });
        return {
          hoverLabels,
          commonLabelBoundingBox: commonLabelRect
        };
      }
      function getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g) {
        var name = "";
        var text = "";
        if (d.nameOverride !== void 0) d.name = d.nameOverride;
        if (d.name) {
          if (d.trace._meta) {
            d.name = Lib.templateString(d.name, d.trace._meta);
          }
          name = plainText(d.name, d.nameLength);
        }
        var h0 = hovermode.charAt(0);
        var h1 = h0 === "x" ? "y" : "x";
        if (d.zLabel !== void 0) {
          if (d.xLabel !== void 0) text += "x: " + d.xLabel + "<br>";
          if (d.yLabel !== void 0) text += "y: " + d.yLabel + "<br>";
          if (d.trace.type !== "choropleth" && d.trace.type !== "choroplethmapbox" && d.trace.type !== "choroplethmap") {
            text += (text ? "z: " : "") + d.zLabel;
          }
        } else if (showCommonLabel && d[h0 + "Label"] === t0) {
          text = d[h1 + "Label"] || "";
        } else if (d.xLabel === void 0) {
          if (d.yLabel !== void 0 && d.trace.type !== "scattercarpet") {
            text = d.yLabel;
          }
        } else if (d.yLabel === void 0) text = d.xLabel;
        else text = "(" + d.xLabel + ", " + d.yLabel + ")";
        if ((d.text || d.text === 0) && !Array.isArray(d.text)) {
          text += (text ? "<br>" : "") + d.text;
        }
        if (d.extraText !== void 0) text += (text ? "<br>" : "") + d.extraText;
        if (g && text === "" && !d.hovertemplate) {
          if (name === "") g.remove();
          text = name;
        }
        var hovertemplate = d.hovertemplate || false;
        if (hovertemplate) {
          var labels = d.hovertemplateLabels || d;
          if (d[h0 + "Label"] !== t0) {
            labels[h0 + "other"] = labels[h0 + "Val"];
            labels[h0 + "otherLabel"] = labels[h0 + "Label"];
          }
          text = Lib.hovertemplateString(
            hovertemplate,
            labels,
            fullLayout._d3locale,
            d.eventData[0] || {},
            d.trace._meta
          );
          text = text.replace(EXTRA_STRING_REGEX, function(match, extra) {
            name = plainText(extra, d.nameLength);
            return "";
          });
        }
        return [text, name];
      }
      function hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, commonLabelBoundingBox) {
        var axKey = rotateLabels ? "xa" : "ya";
        var crossAxKey = rotateLabels ? "ya" : "xa";
        var nummoves = 0;
        var axSign = 1;
        var nLabels = hoverLabels.size();
        var pointgroups = new Array(nLabels);
        var k = 0;
        var axisLabelMinX = commonLabelBoundingBox.minX;
        var axisLabelMaxX = commonLabelBoundingBox.maxX;
        var axisLabelMinY = commonLabelBoundingBox.minY;
        var axisLabelMaxY = commonLabelBoundingBox.maxY;
        var pX = function(x) {
          return x * fullLayout._invScaleX;
        };
        var pY = function(y) {
          return y * fullLayout._invScaleY;
        };
        hoverLabels.each(function(d) {
          var ax = d[axKey];
          var crossAx = d[crossAxKey];
          var axIsX = ax._id.charAt(0) === "x";
          var rng = ax.range;
          if (k === 0 && rng && rng[0] > rng[1] !== axIsX) {
            axSign = -1;
          }
          var pmin = 0;
          var pmax = axIsX ? fullLayout.width : fullLayout.height;
          if (fullLayout.hovermode === "x" || fullLayout.hovermode === "y") {
            var offsets = getHoverLabelOffsets(d, rotateLabels);
            var anchor = d.anchor;
            var horzSign = anchor === "end" ? -1 : 1;
            var labelMin;
            var labelMax;
            if (anchor === "middle") {
              labelMin = d.crossPos + (axIsX ? pY(offsets.y - d.by / 2) : pX(d.bx / 2 + d.tx2width / 2));
              labelMax = labelMin + (axIsX ? pY(d.by) : pX(d.bx));
            } else {
              if (axIsX) {
                labelMin = d.crossPos + pY(HOVERARROWSIZE + offsets.y) - pY(d.by / 2 - HOVERARROWSIZE);
                labelMax = labelMin + pY(d.by);
              } else {
                var startX = pX(horzSign * HOVERARROWSIZE + offsets.x);
                var endX = startX + pX(horzSign * d.bx);
                labelMin = d.crossPos + Math.min(startX, endX);
                labelMax = d.crossPos + Math.max(startX, endX);
              }
            }
            if (axIsX) {
              if (axisLabelMinY !== void 0 && axisLabelMaxY !== void 0 && Math.min(labelMax, axisLabelMaxY) - Math.max(labelMin, axisLabelMinY) > 1) {
                if (crossAx.side === "left") {
                  pmin = crossAx._mainLinePosition;
                  pmax = fullLayout.width;
                } else {
                  pmax = crossAx._mainLinePosition;
                }
              }
            } else {
              if (axisLabelMinX !== void 0 && axisLabelMaxX !== void 0 && Math.min(labelMax, axisLabelMaxX) - Math.max(labelMin, axisLabelMinX) > 1) {
                if (crossAx.side === "top") {
                  pmin = crossAx._mainLinePosition;
                  pmax = fullLayout.height;
                } else {
                  pmax = crossAx._mainLinePosition;
                }
              }
            }
          }
          pointgroups[k++] = [{
            datum: d,
            traceIndex: d.trace.index,
            dp: 0,
            pos: d.pos,
            posref: d.posref,
            size: d.by * (axIsX ? YFACTOR : 1) / 2,
            pmin,
            pmax
          }];
        });
        pointgroups.sort(function(a, b) {
          return a[0].posref - b[0].posref || // for equal positions, sort trace indices increasing or decreasing
          // depending on whether the axis is reversed or not... so stacked
          // traces will generally keep their order even if one trace adds
          // nothing to the stack.
          axSign * (b[0].traceIndex - a[0].traceIndex);
        });
        var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;
        function constrainGroup(grp2) {
          var minPt = grp2[0];
          var maxPt = grp2[grp2.length - 1];
          topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;
          bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;
          if (topOverlap > 0.01) {
            for (j = grp2.length - 1; j >= 0; j--) grp2[j].dp += topOverlap;
            donepositioning = false;
          }
          if (bottomOverlap < 0.01) return;
          if (topOverlap < -0.01) {
            for (j = grp2.length - 1; j >= 0; j--) grp2[j].dp -= bottomOverlap;
            donepositioning = false;
          }
          if (!donepositioning) return;
          var deleteCount = 0;
          for (i = 0; i < grp2.length; i++) {
            pti = grp2[i];
            if (pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;
          }
          for (i = grp2.length - 1; i >= 0; i--) {
            if (deleteCount <= 0) break;
            pti = grp2[i];
            if (pti.pos > minPt.pmax - 1) {
              pti.del = true;
              deleteCount--;
            }
          }
          for (i = 0; i < grp2.length; i++) {
            if (deleteCount <= 0) break;
            pti = grp2[i];
            if (pti.pos < minPt.pmin + 1) {
              pti.del = true;
              deleteCount--;
              bottomOverlap = pti.size * 2;
              for (j = grp2.length - 1; j >= 0; j--) grp2[j].dp -= bottomOverlap;
            }
          }
          for (i = grp2.length - 1; i >= 0; i--) {
            if (deleteCount <= 0) break;
            pti = grp2[i];
            if (pti.pos + pti.dp + pti.size > minPt.pmax) {
              pti.del = true;
              deleteCount--;
            }
          }
        }
        while (!donepositioning && nummoves <= nLabels) {
          nummoves++;
          donepositioning = true;
          i = 0;
          while (i < pointgroups.length - 1) {
            var g0 = pointgroups[i];
            var g1 = pointgroups[i + 1];
            var p0 = g0[g0.length - 1];
            var p1 = g1[0];
            topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;
            if (topOverlap > 0.01) {
              for (j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap;
              g0.push.apply(g0, g1);
              pointgroups.splice(i + 1, 1);
              sumdp = 0;
              for (j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;
              bottomOverlap = sumdp / g0.length;
              for (j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;
              donepositioning = false;
            } else i++;
          }
          pointgroups.forEach(constrainGroup);
        }
        for (i = pointgroups.length - 1; i >= 0; i--) {
          var grp = pointgroups[i];
          for (j = grp.length - 1; j >= 0; j--) {
            var pt = grp[j];
            var hoverPt = pt.datum;
            hoverPt.offset = pt.dp;
            hoverPt.del = pt.del;
          }
        }
      }
      function getHoverLabelOffsets(hoverLabel, rotateLabels) {
        var offsetX = 0;
        var offsetY = hoverLabel.offset;
        if (rotateLabels) {
          offsetY *= -YSHIFTY;
          offsetX = hoverLabel.offset * YSHIFTX;
        }
        return {
          x: offsetX,
          y: offsetY
        };
      }
      function getTextShiftX(hoverLabel) {
        var alignShift = { start: 1, end: -1, middle: 0 }[hoverLabel.anchor];
        var textShiftX = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);
        var text2ShiftX = textShiftX + alignShift * (hoverLabel.txwidth + HOVERTEXTPAD);
        var isMiddle = hoverLabel.anchor === "middle";
        if (isMiddle) {
          textShiftX -= hoverLabel.tx2width / 2;
          text2ShiftX += hoverLabel.txwidth / 2 + HOVERTEXTPAD;
        }
        return {
          alignShift,
          textShiftX,
          text2ShiftX
        };
      }
      function alignHoverText(hoverLabels, rotateLabels, scaleX, scaleY) {
        var pX = function(x) {
          return x * scaleX;
        };
        var pY = function(y) {
          return y * scaleY;
        };
        hoverLabels.each(function(d) {
          var g = d3.select(this);
          if (d.del) return g.remove();
          var tx = g.select("text.nums");
          var anchor = d.anchor;
          var horzSign = anchor === "end" ? -1 : 1;
          var shiftX = getTextShiftX(d);
          var offsets = getHoverLabelOffsets(d, rotateLabels);
          var offsetX = offsets.x;
          var offsetY = offsets.y;
          var isMiddle = anchor === "middle";
          g.select("path").attr("d", isMiddle ? (
            // middle aligned: rect centered on data
            "M-" + pX(d.bx / 2 + d.tx2width / 2) + "," + pY(offsetY - d.by / 2) + "h" + pX(d.bx) + "v" + pY(d.by) + "h-" + pX(d.bx) + "Z"
          ) : (
            // left or right aligned: side rect with arrow to data
            "M0,0L" + pX(horzSign * HOVERARROWSIZE + offsetX) + "," + pY(HOVERARROWSIZE + offsetY) + "v" + pY(d.by / 2 - HOVERARROWSIZE) + "h" + pX(horzSign * d.bx) + "v-" + pY(d.by) + "H" + pX(horzSign * HOVERARROWSIZE + offsetX) + "V" + pY(offsetY - HOVERARROWSIZE) + "Z"
          ));
          var posX = offsetX + shiftX.textShiftX;
          var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;
          var textAlign = d.textAlign || "auto";
          if (textAlign !== "auto") {
            if (textAlign === "left" && anchor !== "start") {
              tx.attr("text-anchor", "start");
              posX = isMiddle ? -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD : -d.bx - HOVERTEXTPAD;
            } else if (textAlign === "right" && anchor !== "end") {
              tx.attr("text-anchor", "end");
              posX = isMiddle ? d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD : d.bx + HOVERTEXTPAD;
            }
          }
          tx.call(svgTextUtils.positionText, pX(posX), pY(posY));
          if (d.tx2width) {
            g.select("text.name").call(
              svgTextUtils.positionText,
              pX(shiftX.text2ShiftX + shiftX.alignShift * HOVERTEXTPAD + offsetX),
              pY(offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD)
            );
            g.select("rect").call(
              Drawing.setRect,
              pX(shiftX.text2ShiftX + (shiftX.alignShift - 1) * d.tx2width / 2 + offsetX),
              pY(offsetY - d.by / 2 - 1),
              pX(d.tx2width),
              pY(d.by + 2)
            );
          }
        });
      }
      function cleanPoint(d, hovermode) {
        var index = d.index;
        var trace = d.trace || {};
        var cd0 = d.cd[0];
        var cd = d.cd[index] || {};
        function pass(v) {
          return v || isNumeric(v) && v === 0;
        }
        var getVal = Array.isArray(index) ? function(calcKey, traceKey) {
          var v = Lib.castOption(cd0, index, calcKey);
          return pass(v) ? v : Lib.extractOption({}, trace, "", traceKey);
        } : function(calcKey, traceKey) {
          return Lib.extractOption(cd, trace, calcKey, traceKey);
        };
        function fill(key, calcKey, traceKey) {
          var val = getVal(calcKey, traceKey);
          if (pass(val)) d[key] = val;
        }
        fill("hoverinfo", "hi", "hoverinfo");
        fill("bgcolor", "hbg", "hoverlabel.bgcolor");
        fill("borderColor", "hbc", "hoverlabel.bordercolor");
        fill("fontFamily", "htf", "hoverlabel.font.family");
        fill("fontSize", "hts", "hoverlabel.font.size");
        fill("fontColor", "htc", "hoverlabel.font.color");
        fill("fontWeight", "htw", "hoverlabel.font.weight");
        fill("fontStyle", "hty", "hoverlabel.font.style");
        fill("fontVariant", "htv", "hoverlabel.font.variant");
        fill("nameLength", "hnl", "hoverlabel.namelength");
        fill("textAlign", "hta", "hoverlabel.align");
        d.posref = hovermode === "y" || hovermode === "closest" && trace.orientation === "h" ? d.xa._offset + (d.x0 + d.x1) / 2 : d.ya._offset + (d.y0 + d.y1) / 2;
        d.x0 = Lib.constrain(d.x0, 0, d.xa._length);
        d.x1 = Lib.constrain(d.x1, 0, d.xa._length);
        d.y0 = Lib.constrain(d.y0, 0, d.ya._length);
        d.y1 = Lib.constrain(d.y1, 0, d.ya._length);
        if (d.xLabelVal !== void 0) {
          d.xLabel = "xLabel" in d ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal, trace.xhoverformat);
          d.xVal = d.xa.c2d(d.xLabelVal);
        }
        if (d.yLabelVal !== void 0) {
          d.yLabel = "yLabel" in d ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal, trace.yhoverformat);
          d.yVal = d.ya.c2d(d.yLabelVal);
        }
        if (d.zLabelVal !== void 0 && d.zLabel === void 0) {
          d.zLabel = String(d.zLabelVal);
        }
        if (!isNaN(d.xerr) && !(d.xa.type === "log" && d.xerr <= 0)) {
          var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), "hover").text;
          if (d.xerrneg !== void 0) {
            d.xLabel += " +" + xeText + " / -" + Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), "hover").text;
          } else d.xLabel += " \xB1 " + xeText;
          if (hovermode === "x") d.distance += 1;
        }
        if (!isNaN(d.yerr) && !(d.ya.type === "log" && d.yerr <= 0)) {
          var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), "hover").text;
          if (d.yerrneg !== void 0) {
            d.yLabel += " +" + yeText + " / -" + Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), "hover").text;
          } else d.yLabel += " \xB1 " + yeText;
          if (hovermode === "y") d.distance += 1;
        }
        var infomode = d.hoverinfo || d.trace.hoverinfo;
        if (infomode && infomode !== "all") {
          infomode = Array.isArray(infomode) ? infomode : infomode.split("+");
          if (infomode.indexOf("x") === -1) d.xLabel = void 0;
          if (infomode.indexOf("y") === -1) d.yLabel = void 0;
          if (infomode.indexOf("z") === -1) d.zLabel = void 0;
          if (infomode.indexOf("text") === -1) d.text = void 0;
          if (infomode.indexOf("name") === -1) d.name = void 0;
        }
        return d;
      }
      function createSpikelines(gd, closestPoints, opts) {
        var container = opts.container;
        var fullLayout = opts.fullLayout;
        var gs = fullLayout._size;
        var evt = opts.event;
        var showY = !!closestPoints.hLinePoint;
        var showX = !!closestPoints.vLinePoint;
        var xa, ya;
        container.selectAll(".spikeline").remove();
        if (!(showX || showY)) return;
        var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);
        if (showY) {
          var hLinePoint = closestPoints.hLinePoint;
          var hLinePointX, hLinePointY;
          xa = hLinePoint && hLinePoint.xa;
          ya = hLinePoint && hLinePoint.ya;
          var ySnap = ya.spikesnap;
          if (ySnap === "cursor") {
            hLinePointX = evt.pointerX;
            hLinePointY = evt.pointerY;
          } else {
            hLinePointX = xa._offset + hLinePoint.x;
            hLinePointY = ya._offset + hLinePoint.y;
          }
          var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : hLinePoint.color;
          var yMode = ya.spikemode;
          var yThickness = ya.spikethickness;
          var yColor = ya.spikecolor || dfltHLineColor;
          var xEdge = Axes.getPxPosition(gd, ya);
          var xBase, xEndSpike;
          if (yMode.indexOf("toaxis") !== -1 || yMode.indexOf("across") !== -1) {
            if (yMode.indexOf("toaxis") !== -1) {
              xBase = xEdge;
              xEndSpike = hLinePointX;
            }
            if (yMode.indexOf("across") !== -1) {
              var xAcross0 = ya._counterDomainMin;
              var xAcross1 = ya._counterDomainMax;
              if (ya.anchor === "free") {
                xAcross0 = Math.min(xAcross0, ya.position);
                xAcross1 = Math.max(xAcross1, ya.position);
              }
              xBase = gs.l + xAcross0 * gs.w;
              xEndSpike = gs.l + xAcross1 * gs.w;
            }
            container.insert("line", ":first-child").attr({
              x1: xBase,
              x2: xEndSpike,
              y1: hLinePointY,
              y2: hLinePointY,
              "stroke-width": yThickness,
              stroke: yColor,
              "stroke-dasharray": Drawing.dashStyle(ya.spikedash, yThickness)
            }).classed("spikeline", true).classed("crisp", true);
            container.insert("line", ":first-child").attr({
              x1: xBase,
              x2: xEndSpike,
              y1: hLinePointY,
              y2: hLinePointY,
              "stroke-width": yThickness + 2,
              stroke: contrastColor
            }).classed("spikeline", true).classed("crisp", true);
          }
          if (yMode.indexOf("marker") !== -1) {
            container.insert("circle", ":first-child").attr({
              cx: xEdge + (ya.side !== "right" ? yThickness : -yThickness),
              cy: hLinePointY,
              r: yThickness,
              fill: yColor
            }).classed("spikeline", true);
          }
        }
        if (showX) {
          var vLinePoint = closestPoints.vLinePoint;
          var vLinePointX, vLinePointY;
          xa = vLinePoint && vLinePoint.xa;
          ya = vLinePoint && vLinePoint.ya;
          var xSnap = xa.spikesnap;
          if (xSnap === "cursor") {
            vLinePointX = evt.pointerX;
            vLinePointY = evt.pointerY;
          } else {
            vLinePointX = xa._offset + vLinePoint.x;
            vLinePointY = ya._offset + vLinePoint.y;
          }
          var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : vLinePoint.color;
          var xMode = xa.spikemode;
          var xThickness = xa.spikethickness;
          var xColor = xa.spikecolor || dfltVLineColor;
          var yEdge = Axes.getPxPosition(gd, xa);
          var yBase, yEndSpike;
          if (xMode.indexOf("toaxis") !== -1 || xMode.indexOf("across") !== -1) {
            if (xMode.indexOf("toaxis") !== -1) {
              yBase = yEdge;
              yEndSpike = vLinePointY;
            }
            if (xMode.indexOf("across") !== -1) {
              var yAcross0 = xa._counterDomainMin;
              var yAcross1 = xa._counterDomainMax;
              if (xa.anchor === "free") {
                yAcross0 = Math.min(yAcross0, xa.position);
                yAcross1 = Math.max(yAcross1, xa.position);
              }
              yBase = gs.t + (1 - yAcross1) * gs.h;
              yEndSpike = gs.t + (1 - yAcross0) * gs.h;
            }
            container.insert("line", ":first-child").attr({
              x1: vLinePointX,
              x2: vLinePointX,
              y1: yBase,
              y2: yEndSpike,
              "stroke-width": xThickness,
              stroke: xColor,
              "stroke-dasharray": Drawing.dashStyle(xa.spikedash, xThickness)
            }).classed("spikeline", true).classed("crisp", true);
            container.insert("line", ":first-child").attr({
              x1: vLinePointX,
              x2: vLinePointX,
              y1: yBase,
              y2: yEndSpike,
              "stroke-width": xThickness + 2,
              stroke: contrastColor
            }).classed("spikeline", true).classed("crisp", true);
          }
          if (xMode.indexOf("marker") !== -1) {
            container.insert("circle", ":first-child").attr({
              cx: vLinePointX,
              cy: yEdge - (xa.side !== "top" ? xThickness : -xThickness),
              r: xThickness,
              fill: xColor
            }).classed("spikeline", true);
          }
        }
      }
      function hoverChanged(gd, evt, oldhoverdata) {
        if (!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;
        for (var i = oldhoverdata.length - 1; i >= 0; i--) {
          var oldPt = oldhoverdata[i];
          var newPt = gd._hoverdata[i];
          if (oldPt.curveNumber !== newPt.curveNumber || String(oldPt.pointNumber) !== String(newPt.pointNumber) || String(oldPt.pointNumbers) !== String(newPt.pointNumbers)) {
            return true;
          }
        }
        return false;
      }
      function spikesChanged(gd, oldspikepoints) {
        if (!oldspikepoints) return true;
        if (oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint || oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint) return true;
        return false;
      }
      function plainText(s, len) {
        return svgTextUtils.plainText(s || "", {
          len,
          allowedTags: ["br", "sub", "sup", "b", "i", "em", "s", "u"]
        });
      }
      function orderRangePoints(hoverData, hovermode) {
        var axLetter = hovermode.charAt(0);
        var first = [];
        var second = [];
        var last = [];
        for (var i = 0; i < hoverData.length; i++) {
          var d = hoverData[i];
          if (Registry.traceIs(d.trace, "bar-like") || Registry.traceIs(d.trace, "box-violin")) {
            last.push(d);
          } else if (d.trace[axLetter + "period"]) {
            second.push(d);
          } else {
            first.push(d);
          }
        }
        return first.concat(second).concat(last);
      }
      function getCoord(axLetter, winningPoint, fullLayout) {
        var ax = winningPoint[axLetter + "a"];
        var val = winningPoint[axLetter + "Val"];
        var cd0 = winningPoint.cd[0];
        if (ax.type === "category" || ax.type === "multicategory") val = ax._categoriesMap[val];
        else if (ax.type === "date") {
          var periodalignment = winningPoint.trace[axLetter + "periodalignment"];
          if (periodalignment) {
            var d = winningPoint.cd[winningPoint.index];
            var start = d[axLetter + "Start"];
            if (start === void 0) start = d[axLetter];
            var end = d[axLetter + "End"];
            if (end === void 0) end = d[axLetter];
            var diff = end - start;
            if (periodalignment === "end") {
              val += diff;
            } else if (periodalignment === "middle") {
              val += diff / 2;
            }
          }
          val = ax.d2c(val);
        }
        if (cd0 && cd0.t && cd0.t.posLetter === ax._id) {
          if (fullLayout.boxmode === "group" || fullLayout.violinmode === "group") {
            val += cd0.t.dPos;
          }
        }
        return val;
      }
      function getTopOffset(gd) {
        return gd.offsetTop + gd.clientTop;
      }
      function getLeftOffset(gd) {
        return gd.offsetLeft + gd.clientLeft;
      }
      function getBoundingClientRect(gd, node) {
        var fullLayout = gd._fullLayout;
        var rect = node.getBoundingClientRect();
        var x0 = rect.left;
        var y0 = rect.top;
        var x1 = x0 + rect.width;
        var y1 = y0 + rect.height;
        var A = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);
        var B = Lib.apply3DTransform(fullLayout._invTransform)(x1, y1);
        var Ax = A[0];
        var Ay = A[1];
        var Bx = B[0];
        var By = B[1];
        return {
          x: Ax,
          y: Ay,
          width: Bx - Ax,
          height: By - Ay,
          top: Math.min(Ay, By),
          left: Math.min(Ax, Bx),
          right: Math.max(Ax, Bx),
          bottom: Math.max(Ay, By)
        };
      }
    }
  });

  // src/components/fx/hoverlabel_defaults.js
  var require_hoverlabel_defaults = __commonJS({
    "src/components/fx/hoverlabel_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var isUnifiedHover = require_helpers2().isUnifiedHover;
      module.exports = function handleHoverLabelDefaults(contIn, contOut, coerce, opts) {
        opts = opts || {};
        var hasLegend = contOut.legend;
        function inheritFontAttr(attr) {
          if (!opts.font[attr]) {
            opts.font[attr] = hasLegend ? contOut.legend.font[attr] : contOut.font[attr];
          }
        }
        if (contOut && isUnifiedHover(contOut.hovermode)) {
          if (!opts.font) opts.font = {};
          inheritFontAttr("size");
          inheritFontAttr("family");
          inheritFontAttr("color");
          inheritFontAttr("weight");
          inheritFontAttr("style");
          inheritFontAttr("variant");
          if (hasLegend) {
            if (!opts.bgcolor) opts.bgcolor = Color.combine(contOut.legend.bgcolor, contOut.paper_bgcolor);
            if (!opts.bordercolor) opts.bordercolor = contOut.legend.bordercolor;
          } else {
            if (!opts.bgcolor) opts.bgcolor = contOut.paper_bgcolor;
          }
        }
        coerce("hoverlabel.bgcolor", opts.bgcolor);
        coerce("hoverlabel.bordercolor", opts.bordercolor);
        coerce("hoverlabel.namelength", opts.namelength);
        Lib.coerceFont(coerce, "hoverlabel.font", opts.font);
        coerce("hoverlabel.align", opts.align);
      };
    }
  });

  // src/components/fx/layout_global_defaults.js
  var require_layout_global_defaults = __commonJS({
    "src/components/fx/layout_global_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleHoverLabelDefaults = require_hoverlabel_defaults();
      var layoutAttributes = require_layout_attributes();
      module.exports = function supplyLayoutGlobalDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        handleHoverLabelDefaults(layoutIn, layoutOut, coerce);
      };
    }
  });

  // src/components/fx/defaults.js
  var require_defaults4 = __commonJS({
    "src/components/fx/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var attributes = require_attributes();
      var handleHoverLabelDefaults = require_hoverlabel_defaults();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var opts = Lib.extendFlat({}, layout.hoverlabel);
        if (traceOut.hovertemplate) opts.namelength = -1;
        handleHoverLabelDefaults(traceIn, traceOut, coerce, opts);
      };
    }
  });

  // src/components/fx/hovermode_defaults.js
  var require_hovermode_defaults = __commonJS({
    "src/components/fx/hovermode_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes();
      module.exports = function handleHoverModeDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          if (layoutOut[attr] !== void 0) return layoutOut[attr];
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        coerce("clickmode");
        coerce("hoversubplots");
        return coerce("hovermode");
      };
    }
  });

  // src/components/fx/layout_defaults.js
  var require_layout_defaults2 = __commonJS({
    "src/components/fx/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes();
      var handleHoverModeDefaults = require_hovermode_defaults();
      var handleHoverLabelDefaults = require_hoverlabel_defaults();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        var hoverMode = handleHoverModeDefaults(layoutIn, layoutOut);
        if (hoverMode) {
          coerce("hoverdistance");
          coerce("spikedistance");
        }
        var dragMode = coerce("dragmode");
        if (dragMode === "select") coerce("selectdirection");
        var hasMapbox = layoutOut._has("mapbox");
        var hasMap = layoutOut._has("map");
        var hasGeo = layoutOut._has("geo");
        var len = layoutOut._basePlotModules.length;
        if (layoutOut.dragmode === "zoom" && ((hasMapbox || hasMap || hasGeo) && len === 1 || (hasMapbox || hasMap) && hasGeo && len === 2)) {
          layoutOut.dragmode = "pan";
        }
        handleHoverLabelDefaults(layoutIn, layoutOut, coerce);
        Lib.coerceFont(coerce, "hoverlabel.grouptitlefont", layoutOut.hoverlabel.font);
      };
    }
  });

  // src/components/fx/calc.js
  var require_calc2 = __commonJS({
    "src/components/fx/calc.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      module.exports = function calc(gd) {
        var calcdata = gd.calcdata;
        var fullLayout = gd._fullLayout;
        function makeCoerceHoverInfo(trace2) {
          return function(val) {
            return Lib.coerceHoverinfo({ hoverinfo: val }, { _module: trace2._module }, fullLayout);
          };
        }
        for (var i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var trace = cd[0].trace;
          if (Registry.traceIs(trace, "pie-like")) continue;
          var fillFn = Registry.traceIs(trace, "2dMap") ? paste : Lib.fillArray;
          fillFn(trace.hoverinfo, cd, "hi", makeCoerceHoverInfo(trace));
          if (trace.hovertemplate) fillFn(trace.hovertemplate, cd, "ht");
          if (!trace.hoverlabel) continue;
          fillFn(trace.hoverlabel.bgcolor, cd, "hbg");
          fillFn(trace.hoverlabel.bordercolor, cd, "hbc");
          fillFn(trace.hoverlabel.font.size, cd, "hts");
          fillFn(trace.hoverlabel.font.color, cd, "htc");
          fillFn(trace.hoverlabel.font.family, cd, "htf");
          fillFn(trace.hoverlabel.font.weight, cd, "htw");
          fillFn(trace.hoverlabel.font.style, cd, "hty");
          fillFn(trace.hoverlabel.font.variant, cd, "htv");
          fillFn(trace.hoverlabel.namelength, cd, "hnl");
          fillFn(trace.hoverlabel.align, cd, "hta");
        }
      };
      function paste(traceAttr, cd, cdAttr, fn) {
        fn = fn || Lib.identity;
        if (Array.isArray(traceAttr)) {
          cd[0][cdAttr] = fn(traceAttr);
        }
      }
    }
  });

  // src/components/fx/click.js
  var require_click = __commonJS({
    "src/components/fx/click.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var hover = require_hover().hover;
      module.exports = function click(gd, evt, subplot) {
        var annotationsDone = Registry.getComponentMethod("annotations", "onClick")(gd, gd._hoverdata);
        if (subplot !== void 0) {
          hover(gd, evt, subplot, true);
        }
        function emitClick() {
          gd.emit("plotly_click", { points: gd._hoverdata, event: evt });
        }
        if (gd._hoverdata && evt && evt.target) {
          if (annotationsDone && annotationsDone.then) {
            annotationsDone.then(emitClick);
          } else emitClick();
          if (evt.stopImmediatePropagation) evt.stopImmediatePropagation();
        }
      };
    }
  });

  // src/components/fx/index.js
  var require_fx = __commonJS({
    "src/components/fx/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var dragElement = require_dragelement();
      var helpers = require_helpers2();
      var layoutAttributes = require_layout_attributes();
      var hoverModule = require_hover();
      module.exports = {
        moduleType: "component",
        name: "fx",
        constants: require_constants(),
        schema: {
          layout: layoutAttributes
        },
        attributes: require_attributes(),
        layoutAttributes,
        supplyLayoutGlobalDefaults: require_layout_global_defaults(),
        supplyDefaults: require_defaults4(),
        supplyLayoutDefaults: require_layout_defaults2(),
        calc: require_calc2(),
        getDistanceFunction: helpers.getDistanceFunction,
        getClosest: helpers.getClosest,
        inbox: helpers.inbox,
        quadrature: helpers.quadrature,
        appendArrayPointValue: helpers.appendArrayPointValue,
        castHoverOption,
        castHoverinfo,
        hover: hoverModule.hover,
        unhover: dragElement.unhover,
        loneHover: hoverModule.loneHover,
        loneUnhover,
        click: require_click()
      };
      function loneUnhover(containerOrSelection) {
        var selection = Lib.isD3Selection(containerOrSelection) ? containerOrSelection : d3.select(containerOrSelection);
        selection.selectAll("g.hovertext").remove();
        selection.selectAll(".spikeline").remove();
      }
      function castHoverOption(trace, ptNumber, attr) {
        return Lib.castOption(trace, ptNumber, "hoverlabel." + attr);
      }
      function castHoverinfo(trace, fullLayout, ptNumber) {
        function _coerce(val) {
          return Lib.coerceHoverinfo({ hoverinfo: val }, { _module: trace._module }, fullLayout);
        }
        return Lib.castOption(trace, ptNumber, "hoverinfo", _coerce);
      }
    }
  });

  // src/components/dragelement/helpers.js
  var require_helpers5 = __commonJS({
    "src/components/dragelement/helpers.js"(exports) {
      "use strict";
      exports.selectMode = function(dragmode) {
        return dragmode === "lasso" || dragmode === "select";
      };
      exports.drawMode = function(dragmode) {
        return dragmode === "drawclosedpath" || dragmode === "drawopenpath" || dragmode === "drawline" || dragmode === "drawrect" || dragmode === "drawcircle";
      };
      exports.openMode = function(dragmode) {
        return dragmode === "drawline" || dragmode === "drawopenpath";
      };
      exports.rectMode = function(dragmode) {
        return dragmode === "select" || dragmode === "drawline" || dragmode === "drawrect" || dragmode === "drawcircle";
      };
      exports.freeMode = function(dragmode) {
        return dragmode === "lasso" || dragmode === "drawclosedpath" || dragmode === "drawopenpath";
      };
      exports.selectingOrDrawing = function(dragmode) {
        return exports.freeMode(dragmode) || exports.rectMode(dragmode);
      };
    }
  });

  // src/lib/clear_gl_canvases.js
  var require_clear_gl_canvases = __commonJS({
    "src/lib/clear_gl_canvases.js"(exports, module) {
      "use strict";
      module.exports = function clearGlCanvases(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._glcanvas && fullLayout._glcanvas.size()) {
          fullLayout._glcanvas.each(function(d) {
            if (d.regl) d.regl.clear({ color: true, depth: true });
          });
        }
      };
    }
  });

  // src/fonts/ploticon.js
  var require_ploticon = __commonJS({
    "src/fonts/ploticon.js"(exports, module) {
      "use strict";
      module.exports = {
        undo: {
          width: 857.1,
          height: 1e3,
          path: "m857 350q0-87-34-166t-91-137-137-92-166-34q-96 0-183 41t-147 114q-4 6-4 13t5 11l76 77q6 5 14 5 9-1 13-7 41-53 100-82t126-29q58 0 110 23t92 61 61 91 22 111-22 111-61 91-92 61-110 23q-55 0-105-20t-90-57l77-77q17-16 8-38-10-23-33-23h-250q-15 0-25 11t-11 25v250q0 24 22 33 22 10 39-8l72-72q60 57 137 88t159 31q87 0 166-34t137-92 91-137 34-166z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        home: {
          width: 928.6,
          height: 1e3,
          path: "m786 296v-267q0-15-11-26t-25-10h-214v214h-143v-214h-214q-15 0-25 10t-11 26v267q0 1 0 2t0 2l321 264 321-264q1-1 1-4z m124 39l-34-41q-5-5-12-6h-2q-7 0-12 3l-386 322-386-322q-7-4-13-4-7 2-12 7l-35 41q-4 5-3 13t6 12l401 334q18 15 42 15t43-15l136-114v109q0 8 5 13t13 5h107q8 0 13-5t5-13v-227l122-102q5-5 6-12t-4-13z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        "camera-retro": {
          width: 1e3,
          height: 1e3,
          path: "m518 386q0 8-5 13t-13 5q-37 0-63-27t-26-63q0-8 5-13t13-5 12 5 5 13q0 23 16 38t38 16q8 0 13 5t5 13z m125-73q0-59-42-101t-101-42-101 42-42 101 42 101 101 42 101-42 42-101z m-572-320h858v71h-858v-71z m643 320q0 89-62 152t-152 62-151-62-63-152 63-151 151-63 152 63 62 151z m-571 358h214v72h-214v-72z m-72-107h858v143h-462l-36-71h-360v-72z m929 143v-714q0-30-21-51t-50-21h-858q-29 0-50 21t-21 51v714q0 30 21 51t50 21h858q29 0 50-21t21-51z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        zoombox: {
          width: 1e3,
          height: 1e3,
          path: "m1000-25l-250 251c40 63 63 138 63 218 0 224-182 406-407 406-224 0-406-182-406-406s183-406 407-406c80 0 155 22 218 62l250-250 125 125z m-812 250l0 438 437 0 0-438-437 0z m62 375l313 0 0-312-313 0 0 312z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        pan: {
          width: 1e3,
          height: 1e3,
          path: "m1000 350l-187 188 0-125-250 0 0 250 125 0-188 187-187-187 125 0 0-250-250 0 0 125-188-188 186-187 0 125 252 0 0-250-125 0 187-188 188 188-125 0 0 250 250 0 0-126 187 188z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        zoom_plus: {
          width: 875,
          height: 1e3,
          path: "m1 787l0-875 875 0 0 875-875 0z m687-500l-187 0 0-187-125 0 0 187-188 0 0 125 188 0 0 187 125 0 0-187 187 0 0-125z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        zoom_minus: {
          width: 875,
          height: 1e3,
          path: "m0 788l0-876 875 0 0 876-875 0z m688-500l-500 0 0 125 500 0 0-125z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        autoscale: {
          width: 1e3,
          height: 1e3,
          path: "m250 850l-187 0-63 0 0-62 0-188 63 0 0 188 187 0 0 62z m688 0l-188 0 0-62 188 0 0-188 62 0 0 188 0 62-62 0z m-875-938l0 188-63 0 0-188 0-62 63 0 187 0 0 62-187 0z m875 188l0-188-188 0 0-62 188 0 62 0 0 62 0 188-62 0z m-125 188l-1 0-93-94-156 156 156 156 92-93 2 0 0 250-250 0 0-2 93-92-156-156-156 156 94 92 0 2-250 0 0-250 0 0 93 93 157-156-157-156-93 94 0 0 0-250 250 0 0 0-94 93 156 157 156-157-93-93 0 0 250 0 0 250z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        tooltip_basic: {
          width: 1500,
          height: 1e3,
          path: "m375 725l0 0-375-375 375-374 0-1 1125 0 0 750-1125 0z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        tooltip_compare: {
          width: 1125,
          height: 1e3,
          path: "m187 786l0 2-187-188 188-187 0 0 937 0 0 373-938 0z m0-499l0 1-187-188 188-188 0 0 937 0 0 376-938-1z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        plotlylogo: {
          width: 1542,
          height: 1e3,
          path: "m0-10h182v-140h-182v140z m228 146h183v-286h-183v286z m225 714h182v-1000h-182v1000z m225-285h182v-715h-182v715z m225 142h183v-857h-183v857z m231-428h182v-429h-182v429z m225-291h183v-138h-183v138z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        "z-axis": {
          width: 1e3,
          height: 1e3,
          path: "m833 5l-17 108v41l-130-65 130-66c0 0 0 38 0 39 0-1 36-14 39-25 4-15-6-22-16-30-15-12-39-16-56-20-90-22-187-23-279-23-261 0-341 34-353 59 3 60 228 110 228 110-140-8-351-35-351-116 0-120 293-142 474-142 155 0 477 22 477 142 0 50-74 79-163 96z m-374 94c-58-5-99-21-99-40 0-24 65-43 144-43 79 0 143 19 143 43 0 19-42 34-98 40v216h87l-132 135-133-135h88v-216z m167 515h-136v1c16 16 31 34 46 52l84 109v54h-230v-71h124v-1c-16-17-28-32-44-51l-89-114v-51h245v72z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        "3d_rotate": {
          width: 1e3,
          height: 1e3,
          path: "m922 660c-5 4-9 7-14 11-359 263-580-31-580-31l-102 28 58-400c0 1 1 1 2 2 118 108 351 249 351 249s-62 27-100 42c88 83 222 183 347 122 16-8 30-17 44-27-2 1-4 2-6 4z m36-329c0 0 64 229-88 296-62 27-124 14-175-11 157-78 225-208 249-266 8-19 11-31 11-31 2 5 6 15 11 32-5-13-8-20-8-20z m-775-239c70-31 117-50 198-32-121 80-199 346-199 346l-96-15-58-12c0 0 55-226 155-287z m603 133l-317-139c0 0 4-4 19-14 7-5 24-15 24-15s-177-147-389 4c235-287 536-112 536-112l31-22 100 299-4-1z m-298-153c6-4 14-9 24-15 0 0-17 10-24 15z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        camera: {
          width: 1e3,
          height: 1e3,
          path: "m500 450c-83 0-150-67-150-150 0-83 67-150 150-150 83 0 150 67 150 150 0 83-67 150-150 150z m400 150h-120c-16 0-34 13-39 29l-31 93c-6 15-23 28-40 28h-340c-16 0-34-13-39-28l-31-94c-6-15-23-28-40-28h-120c-55 0-100-45-100-100v-450c0-55 45-100 100-100h800c55 0 100 45 100 100v450c0 55-45 100-100 100z m-400-550c-138 0-250 112-250 250 0 138 112 250 250 250 138 0 250-112 250-250 0-138-112-250-250-250z m365 380c-19 0-35 16-35 35 0 19 16 35 35 35 19 0 35-16 35-35 0-19-16-35-35-35z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        movie: {
          width: 1e3,
          height: 1e3,
          path: "m938 413l-188-125c0 37-17 71-44 94 64 38 107 107 107 187 0 121-98 219-219 219-121 0-219-98-219-219 0-61 25-117 66-156h-115c30 33 49 76 49 125 0 103-84 187-187 187s-188-84-188-187c0-57 26-107 65-141-38-22-65-62-65-109v-250c0-70 56-126 125-126h500c69 0 125 56 125 126l188-126c34 0 62 28 62 63v375c0 35-28 63-62 63z m-750 0c-69 0-125 56-125 125s56 125 125 125 125-56 125-125-56-125-125-125z m406-1c-87 0-157 70-157 157 0 86 70 156 157 156s156-70 156-156-70-157-156-157z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        question: {
          width: 857.1,
          height: 1e3,
          path: "m500 82v107q0 8-5 13t-13 5h-107q-8 0-13-5t-5-13v-107q0-8 5-13t13-5h107q8 0 13 5t5 13z m143 375q0 49-31 91t-77 65-95 23q-136 0-207-119-9-14 4-24l74-55q4-4 10-4 9 0 14 7 30 38 48 51 19 14 48 14 27 0 48-15t21-33q0-21-11-34t-38-25q-35-16-65-48t-29-70v-20q0-8 5-13t13-5h107q8 0 13 5t5 13q0 10 12 27t30 28q18 10 28 16t25 19 25 27 16 34 7 45z m214-107q0-117-57-215t-156-156-215-58-216 58-155 156-58 215 58 215 155 156 216 58 215-58 156-156 57-215z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        disk: {
          width: 857.1,
          height: 1e3,
          path: "m214-7h429v214h-429v-214z m500 0h72v500q0 8-6 21t-11 20l-157 156q-5 6-19 12t-22 5v-232q0-22-15-38t-38-16h-322q-22 0-37 16t-16 38v232h-72v-714h72v232q0 22 16 38t37 16h465q22 0 38-16t15-38v-232z m-214 518v178q0 8-5 13t-13 5h-107q-7 0-13-5t-5-13v-178q0-8 5-13t13-5h107q7 0 13 5t5 13z m357-18v-518q0-22-15-38t-38-16h-750q-23 0-38 16t-16 38v750q0 22 16 38t38 16h517q23 0 50-12t42-26l156-157q16-15 27-42t11-49z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        drawopenpath: {
          width: 70,
          height: 70,
          path: "M33.21,85.65a7.31,7.31,0,0,1-2.59-.48c-8.16-3.11-9.27-19.8-9.88-41.3-.1-3.58-.19-6.68-.35-9-.15-2.1-.67-3.48-1.43-3.79-2.13-.88-7.91,2.32-12,5.86L3,32.38c1.87-1.64,11.55-9.66,18.27-6.9,2.13.87,4.75,3.14,5.17,9,.17,2.43.26,5.59.36,9.25a224.17,224.17,0,0,0,1.5,23.4c1.54,10.76,4,12.22,4.48,12.4.84.32,2.79-.46,5.76-3.59L43,80.07C41.53,81.57,37.68,85.64,33.21,85.65ZM74.81,69a11.34,11.34,0,0,0,6.09-6.72L87.26,44.5,74.72,32,56.9,38.35c-2.37.86-5.57,3.42-6.61,6L38.65,72.14l8.42,8.43ZM55,46.27a7.91,7.91,0,0,1,3.64-3.17l14.8-5.3,8,8L76.11,60.6l-.06.19a6.37,6.37,0,0,1-3,3.43L48.25,74.59,44.62,71Zm16.57,7.82A6.9,6.9,0,1,0,64.64,61,6.91,6.91,0,0,0,71.54,54.09Zm-4.05,0a2.85,2.85,0,1,1-2.85-2.85A2.86,2.86,0,0,1,67.49,54.09Zm-4.13,5.22L60.5,56.45,44.26,72.7l2.86,2.86ZM97.83,35.67,84.14,22l-8.57,8.57L89.26,44.24Zm-13.69-8,8,8-2.85,2.85-8-8Z",
          transform: "matrix(1 0 0 1 -15 -15)"
        },
        drawclosedpath: {
          width: 90,
          height: 90,
          path: "M88.41,21.12a26.56,26.56,0,0,0-36.18,0l-2.07,2-2.07-2a26.57,26.57,0,0,0-36.18,0,23.74,23.74,0,0,0,0,34.8L48,90.12a3.22,3.22,0,0,0,4.42,0l36-34.21a23.73,23.73,0,0,0,0-34.79ZM84,51.24,50.16,83.35,16.35,51.25a17.28,17.28,0,0,1,0-25.47,20,20,0,0,1,27.3,0l4.29,4.07a3.23,3.23,0,0,0,4.44,0l4.29-4.07a20,20,0,0,1,27.3,0,17.27,17.27,0,0,1,0,25.46ZM66.76,47.68h-33v6.91h33ZM53.35,35H46.44V68h6.91Z",
          transform: "matrix(1 0 0 1 -5 -5)"
        },
        lasso: {
          width: 1031,
          height: 1e3,
          path: "m1018 538c-36 207-290 336-568 286-277-48-473-256-436-463 10-57 36-108 76-151-13-66 11-137 68-183 34-28 75-41 114-42l-55-70 0 0c-2-1-3-2-4-3-10-14-8-34 5-45 14-11 34-8 45 4 1 1 2 3 2 5l0 0 113 140c16 11 31 24 45 40 4 3 6 7 8 11 48-3 100 0 151 9 278 48 473 255 436 462z m-624-379c-80 14-149 48-197 96 42 42 109 47 156 9 33-26 47-66 41-105z m-187-74c-19 16-33 37-39 60 50-32 109-55 174-68-42-25-95-24-135 8z m360 75c-34-7-69-9-102-8 8 62-16 128-68 170-73 59-175 54-244-5-9 20-16 40-20 61-28 159 121 317 333 354s407-60 434-217c28-159-121-318-333-355z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        selectbox: {
          width: 1e3,
          height: 1e3,
          path: "m0 850l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-285l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        drawline: {
          width: 70,
          height: 70,
          path: "M60.64,62.3a11.29,11.29,0,0,0,6.09-6.72l6.35-17.72L60.54,25.31l-17.82,6.4c-2.36.86-5.57,3.41-6.6,6L24.48,65.5l8.42,8.42ZM40.79,39.63a7.89,7.89,0,0,1,3.65-3.17l14.79-5.31,8,8L61.94,54l-.06.19a6.44,6.44,0,0,1-3,3.43L34.07,68l-3.62-3.63Zm16.57,7.81a6.9,6.9,0,1,0-6.89,6.9A6.9,6.9,0,0,0,57.36,47.44Zm-4,0a2.86,2.86,0,1,1-2.85-2.85A2.86,2.86,0,0,1,53.32,47.44Zm-4.13,5.22L46.33,49.8,30.08,66.05l2.86,2.86ZM83.65,29,70,15.34,61.4,23.9,75.09,37.59ZM70,21.06l8,8-2.84,2.85-8-8ZM87,80.49H10.67V87H87Z",
          transform: "matrix(1 0 0 1 -15 -15)"
        },
        drawrect: {
          width: 80,
          height: 80,
          path: "M78,22V79H21V22H78m9-9H12V88H87V13ZM68,46.22H31V54H68ZM53,32H45.22V69H53Z",
          transform: "matrix(1 0 0 1 -10 -10)"
        },
        drawcircle: {
          width: 80,
          height: 80,
          path: "M50,84.72C26.84,84.72,8,69.28,8,50.3S26.84,15.87,50,15.87,92,31.31,92,50.3,73.16,84.72,50,84.72Zm0-60.59c-18.6,0-33.74,11.74-33.74,26.17S31.4,76.46,50,76.46,83.74,64.72,83.74,50.3,68.6,24.13,50,24.13Zm17.15,22h-34v7.11h34Zm-13.8-13H46.24v34h7.11Z",
          transform: "matrix(1 0 0 1 -10 -10)"
        },
        eraseshape: {
          width: 80,
          height: 80,
          path: "M82.77,78H31.85L6,49.57,31.85,21.14H82.77a8.72,8.72,0,0,1,8.65,8.77V69.24A8.72,8.72,0,0,1,82.77,78ZM35.46,69.84H82.77a.57.57,0,0,0,.49-.6V29.91a.57.57,0,0,0-.49-.61H35.46L17,49.57Zm32.68-34.7-24,24,5,5,24-24Zm-19,.53-5,5,24,24,5-5Z",
          transform: "matrix(1 0 0 1 -10 -10)"
        },
        spikeline: {
          width: 1e3,
          height: 1e3,
          path: "M512 409c0-57-46-104-103-104-57 0-104 47-104 104 0 57 47 103 104 103 57 0 103-46 103-103z m-327-39l92 0 0 92-92 0z m-185 0l92 0 0 92-92 0z m370-186l92 0 0 93-92 0z m0-184l92 0 0 92-92 0z",
          transform: "matrix(1.5 0 0 -1.5 0 850)"
        },
        pencil: {
          width: 1792,
          height: 1792,
          path: "M491 1536l91-91-235-235-91 91v107h128v128h107zm523-928q0-22-22-22-10 0-17 7l-542 542q-7 7-7 17 0 22 22 22 10 0 17-7l542-542q7-7 7-17zm-54-192l416 416-832 832h-416v-416zm683 96q0 53-37 90l-166 166-416-416 166-165q36-38 90-38 53 0 91 38l235 234q37 39 37 91z",
          transform: "matrix(1 0 0 1 0 1)"
        },
        newplotlylogo: {
          name: "newplotlylogo",
          svg: [
            "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 132 132'>",
            " <title>plotly-logomark</title>",
            " <g id='symbol'>",
            "  <rect fill='#000' x='0' y='0' width='132' height='132' rx='18' ry='18'/>",
            "  <circle fill='#9EF' cx='102' cy='30' r='6'/>",
            "  <circle fill='#BAC' cx='78' cy='30' r='6'/>",
            "  <circle fill='#BAC' cx='78' cy='54' r='6'/>",
            "  <circle fill='#D69' cx='54' cy='30' r='6'/>",
            "  <circle fill='#F26' cx='30' cy='30' r='6'/>",
            "  <circle fill='#F26' cx='30' cy='54' r='6'/>",
            "  <path fill='#FFF' d='M30,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,30,72Z'/>",
            "  <path fill='#FFF' d='M78,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,78,72Z'/>",
            "  <path fill='#FFF' d='M54,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,54,48Z'/>",
            "  <path fill='#FFF' d='M102,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,102,48Z'/>",
            " </g>",
            "</svg>"
          ].join("")
        }
      };
    }
  });

  // src/components/shapes/draw_newshape/constants.js
  var require_constants4 = __commonJS({
    "src/components/shapes/draw_newshape/constants.js"(exports, module) {
      "use strict";
      var CIRCLE_SIDES = 32;
      module.exports = {
        CIRCLE_SIDES,
        i000: 0,
        i090: CIRCLE_SIDES / 4,
        i180: CIRCLE_SIDES / 2,
        i270: CIRCLE_SIDES / 4 * 3,
        cos45: Math.cos(Math.PI / 4),
        sin45: Math.sin(Math.PI / 4),
        SQRT2: Math.sqrt(2)
      };
    }
  });

  // src/components/selections/helpers.js
  var require_helpers6 = __commonJS({
    "src/components/selections/helpers.js"(exports, module) {
      "use strict";
      var strTranslate = require_lib().strTranslate;
      function p2r(ax, v) {
        switch (ax.type) {
          case "log":
            return ax.p2d(v);
          case "date":
            return ax.p2r(v, 0, ax.calendar);
          default:
            return ax.p2r(v);
        }
      }
      function r2p(ax, v) {
        switch (ax.type) {
          case "log":
            return ax.d2p(v);
          case "date":
            return ax.r2p(v, 0, ax.calendar);
          default:
            return ax.r2p(v);
        }
      }
      function axValue(ax) {
        var index = ax._id.charAt(0) === "y" ? 1 : 0;
        return function(v) {
          return p2r(ax, v[index]);
        };
      }
      function getTransform(plotinfo) {
        return strTranslate(
          plotinfo.xaxis._offset,
          plotinfo.yaxis._offset
        );
      }
      module.exports = {
        p2r,
        r2p,
        axValue,
        getTransform
      };
    }
  });

  // src/components/shapes/draw_newshape/helpers.js
  var require_helpers7 = __commonJS({
    "src/components/shapes/draw_newshape/helpers.js"(exports) {
      "use strict";
      var parseSvgPath = require_parse_svg_path();
      var constants = require_constants4();
      var CIRCLE_SIDES = constants.CIRCLE_SIDES;
      var SQRT2 = constants.SQRT2;
      var cartesianHelpers = require_helpers6();
      var p2r = cartesianHelpers.p2r;
      var r2p = cartesianHelpers.r2p;
      var iC = [0, 3, 4, 5, 6, 1, 2];
      var iQS = [0, 3, 4, 1, 2];
      exports.writePaths = function(polygons) {
        var nI = polygons.length;
        if (!nI) return "M0,0Z";
        var str = "";
        for (var i = 0; i < nI; i++) {
          var nJ = polygons[i].length;
          for (var j = 0; j < nJ; j++) {
            var w = polygons[i][j][0];
            if (w === "Z") {
              str += "Z";
            } else {
              var nK = polygons[i][j].length;
              for (var k = 0; k < nK; k++) {
                var realK = k;
                if (w === "Q" || w === "S") {
                  realK = iQS[k];
                } else if (w === "C") {
                  realK = iC[k];
                }
                str += polygons[i][j][realK];
                if (k > 0 && k < nK - 1) {
                  str += ",";
                }
              }
            }
          }
        }
        return str;
      };
      exports.readPaths = function(str, gd, plotinfo, isActiveShape) {
        var cmd = parseSvgPath(str);
        var polys = [];
        var n = -1;
        var newPoly = function() {
          n++;
          polys[n] = [];
        };
        var k;
        var x = 0;
        var y = 0;
        var initX;
        var initY;
        var recStart = function() {
          initX = x;
          initY = y;
        };
        recStart();
        for (var i = 0; i < cmd.length; i++) {
          var newPos = [];
          var x1, x2, y1, y2;
          var c = cmd[i][0];
          var w = c;
          switch (c) {
            case "M":
              newPoly();
              x = +cmd[i][1];
              y = +cmd[i][2];
              newPos.push([w, x, y]);
              recStart();
              break;
            case "Q":
            case "S":
              x1 = +cmd[i][1];
              y1 = +cmd[i][2];
              x = +cmd[i][3];
              y = +cmd[i][4];
              newPos.push([w, x, y, x1, y1]);
              break;
            case "C":
              x1 = +cmd[i][1];
              y1 = +cmd[i][2];
              x2 = +cmd[i][3];
              y2 = +cmd[i][4];
              x = +cmd[i][5];
              y = +cmd[i][6];
              newPos.push([w, x, y, x1, y1, x2, y2]);
              break;
            case "T":
            case "L":
              x = +cmd[i][1];
              y = +cmd[i][2];
              newPos.push([w, x, y]);
              break;
            case "H":
              w = "L";
              x = +cmd[i][1];
              newPos.push([w, x, y]);
              break;
            case "V":
              w = "L";
              y = +cmd[i][1];
              newPos.push([w, x, y]);
              break;
            case "A":
              w = "L";
              var rx = +cmd[i][1];
              var ry = +cmd[i][2];
              if (!+cmd[i][4]) {
                rx = -rx;
                ry = -ry;
              }
              var cenX = x - rx;
              var cenY = y;
              for (k = 1; k <= CIRCLE_SIDES / 2; k++) {
                var t = 2 * Math.PI * k / CIRCLE_SIDES;
                newPos.push([
                  w,
                  cenX + rx * Math.cos(t),
                  cenY + ry * Math.sin(t)
                ]);
              }
              break;
            case "Z":
              if (x !== initX || y !== initY) {
                x = initX;
                y = initY;
                newPos.push([w, x, y]);
              }
              break;
          }
          var domain = (plotinfo || {}).domain;
          var size = gd._fullLayout._size;
          var xPixelSized = plotinfo && plotinfo.xsizemode === "pixel";
          var yPixelSized = plotinfo && plotinfo.ysizemode === "pixel";
          var noOffset = isActiveShape === false;
          for (var j = 0; j < newPos.length; j++) {
            for (k = 0; k + 2 < 7; k += 2) {
              var _x = newPos[j][k + 1];
              var _y = newPos[j][k + 2];
              if (_x === void 0 || _y === void 0) continue;
              x = _x;
              y = _y;
              if (plotinfo) {
                if (plotinfo.xaxis && plotinfo.xaxis.p2r) {
                  if (noOffset) _x -= plotinfo.xaxis._offset;
                  if (xPixelSized) {
                    _x = r2p(plotinfo.xaxis, plotinfo.xanchor) + _x;
                  } else {
                    _x = p2r(plotinfo.xaxis, _x);
                  }
                } else {
                  if (noOffset) _x -= size.l;
                  if (domain) _x = domain.x[0] + _x / size.w;
                  else _x = _x / size.w;
                }
                if (plotinfo.yaxis && plotinfo.yaxis.p2r) {
                  if (noOffset) _y -= plotinfo.yaxis._offset;
                  if (yPixelSized) {
                    _y = r2p(plotinfo.yaxis, plotinfo.yanchor) - _y;
                  } else {
                    _y = p2r(plotinfo.yaxis, _y);
                  }
                } else {
                  if (noOffset) _y -= size.t;
                  if (domain) _y = domain.y[1] - _y / size.h;
                  else _y = 1 - _y / size.h;
                }
              }
              newPos[j][k + 1] = _x;
              newPos[j][k + 2] = _y;
            }
            polys[n].push(
              newPos[j].slice()
            );
          }
        }
        return polys;
      };
      function almostEq(a, b) {
        return Math.abs(a - b) <= 1e-6;
      }
      function dist(a, b) {
        var dx = b[1] - a[1];
        var dy = b[2] - a[2];
        return Math.sqrt(
          dx * dx + dy * dy
        );
      }
      exports.pointsOnRectangle = function(cell) {
        var len = cell.length;
        if (len !== 5) return false;
        for (var j = 1; j < 3; j++) {
          var e01 = cell[0][j] - cell[1][j];
          var e32 = cell[3][j] - cell[2][j];
          if (!almostEq(e01, e32)) return false;
          var e03 = cell[0][j] - cell[3][j];
          var e12 = cell[1][j] - cell[2][j];
          if (!almostEq(e03, e12)) return false;
        }
        if (!almostEq(cell[0][1], cell[1][1]) && !almostEq(cell[0][1], cell[3][1])) return false;
        return !!(dist(cell[0], cell[1]) * dist(cell[0], cell[3]));
      };
      exports.pointsOnEllipse = function(cell) {
        var len = cell.length;
        if (len !== CIRCLE_SIDES + 1) return false;
        len = CIRCLE_SIDES;
        for (var i = 0; i < len; i++) {
          var k = (len * 2 - i) % len;
          var k2 = (len / 2 + k) % len;
          var i2 = (len / 2 + i) % len;
          if (!almostEq(
            dist(cell[i], cell[i2]),
            dist(cell[k], cell[k2])
          )) return false;
        }
        return true;
      };
      exports.handleEllipse = function(isEllipse, start, end) {
        if (!isEllipse) return [start, end];
        var pos = exports.ellipseOver({
          x0: start[0],
          y0: start[1],
          x1: end[0],
          y1: end[1]
        });
        var cx = (pos.x1 + pos.x0) / 2;
        var cy = (pos.y1 + pos.y0) / 2;
        var rx = (pos.x1 - pos.x0) / 2;
        var ry = (pos.y1 - pos.y0) / 2;
        if (!rx) rx = ry = ry / SQRT2;
        if (!ry) ry = rx = rx / SQRT2;
        var cell = [];
        for (var i = 0; i < CIRCLE_SIDES; i++) {
          var t = i * 2 * Math.PI / CIRCLE_SIDES;
          cell.push([
            cx + rx * Math.cos(t),
            cy + ry * Math.sin(t)
          ]);
        }
        return cell;
      };
      exports.ellipseOver = function(pos) {
        var x0 = pos.x0;
        var y0 = pos.y0;
        var x1 = pos.x1;
        var y1 = pos.y1;
        var dx = x1 - x0;
        var dy = y1 - y0;
        x0 -= dx;
        y0 -= dy;
        var cx = (x0 + x1) / 2;
        var cy = (y0 + y1) / 2;
        var scale = SQRT2;
        dx *= scale;
        dy *= scale;
        return {
          x0: cx - dx,
          y0: cy - dy,
          x1: cx + dx,
          y1: cy + dy
        };
      };
      exports.fixDatesForPaths = function(polygons, xaxis, yaxis) {
        var xIsDate = xaxis.type === "date";
        var yIsDate = yaxis.type === "date";
        if (!xIsDate && !yIsDate) return polygons;
        for (var i = 0; i < polygons.length; i++) {
          for (var j = 0; j < polygons[i].length; j++) {
            for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {
              if (xIsDate) polygons[i][j][k + 1] = polygons[i][j][k + 1].replace(" ", "_");
              if (yIsDate) polygons[i][j][k + 2] = polygons[i][j][k + 2].replace(" ", "_");
            }
          }
        }
        return polygons;
      };
    }
  });

  // src/components/shapes/draw_newshape/newshapes.js
  var require_newshapes = __commonJS({
    "src/components/shapes/draw_newshape/newshapes.js"(exports, module) {
      "use strict";
      var dragHelpers = require_helpers5();
      var drawMode = dragHelpers.drawMode;
      var openMode = dragHelpers.openMode;
      var constants = require_constants4();
      var i000 = constants.i000;
      var i090 = constants.i090;
      var i180 = constants.i180;
      var i270 = constants.i270;
      var cos45 = constants.cos45;
      var sin45 = constants.sin45;
      var cartesianHelpers = require_helpers6();
      var p2r = cartesianHelpers.p2r;
      var r2p = cartesianHelpers.r2p;
      var handleOutline = require_handle_outline();
      var clearOutline = handleOutline.clearOutline;
      var helpers = require_helpers7();
      var readPaths = helpers.readPaths;
      var writePaths = helpers.writePaths;
      var ellipseOver = helpers.ellipseOver;
      var fixDatesForPaths = helpers.fixDatesForPaths;
      function newShapes(outlines, dragOptions) {
        if (!outlines.length) return;
        var e = outlines[0][0];
        if (!e) return;
        var gd = dragOptions.gd;
        var isActiveShape = dragOptions.isActiveShape;
        var dragmode = dragOptions.dragmode;
        var shapes = (gd.layout || {}).shapes || [];
        if (!drawMode(dragmode) && isActiveShape !== void 0) {
          var id = gd._fullLayout._activeShapeIndex;
          if (id < shapes.length) {
            switch (gd._fullLayout.shapes[id].type) {
              case "rect":
                dragmode = "drawrect";
                break;
              case "circle":
                dragmode = "drawcircle";
                break;
              case "line":
                dragmode = "drawline";
                break;
              case "path":
                var path = shapes[id].path || "";
                if (path[path.length - 1] === "Z") {
                  dragmode = "drawclosedpath";
                } else {
                  dragmode = "drawopenpath";
                }
                break;
            }
          }
        }
        var newShape = createShapeObj(outlines, dragOptions, dragmode);
        clearOutline(gd);
        var editHelpers = dragOptions.editHelpers;
        var modifyItem = (editHelpers || {}).modifyItem;
        var allShapes = [];
        for (var q = 0; q < shapes.length; q++) {
          var beforeEdit = gd._fullLayout.shapes[q];
          allShapes[q] = beforeEdit._input;
          if (isActiveShape !== void 0 && q === gd._fullLayout._activeShapeIndex) {
            var afterEdit = newShape;
            switch (beforeEdit.type) {
              case "line":
              case "rect":
              case "circle":
                modifyItem("x0", afterEdit.x0 - (beforeEdit.x0shift || 0));
                modifyItem("x1", afterEdit.x1 - (beforeEdit.x1shift || 0));
                modifyItem("y0", afterEdit.y0 - (beforeEdit.y0shift || 0));
                modifyItem("y1", afterEdit.y1 - (beforeEdit.y1shift || 0));
                break;
              case "path":
                modifyItem("path", afterEdit.path);
                break;
            }
          }
        }
        if (isActiveShape === void 0) {
          allShapes.push(newShape);
          return allShapes;
        }
        return editHelpers ? editHelpers.getUpdateObj() : {};
      }
      function createShapeObj(outlines, dragOptions, dragmode) {
        var e = outlines[0][0];
        var gd = dragOptions.gd;
        var d = e.getAttribute("d");
        var newStyle = gd._fullLayout.newshape;
        var plotinfo = dragOptions.plotinfo;
        var isActiveShape = dragOptions.isActiveShape;
        var xaxis = plotinfo.xaxis;
        var yaxis = plotinfo.yaxis;
        var xPaper = !!plotinfo.domain || !plotinfo.xaxis;
        var yPaper = !!plotinfo.domain || !plotinfo.yaxis;
        var isOpenMode = openMode(dragmode);
        var polygons = readPaths(d, gd, plotinfo, isActiveShape);
        var newShape = {
          editable: true,
          visible: newStyle.visible,
          name: newStyle.name,
          showlegend: newStyle.showlegend,
          legend: newStyle.legend,
          legendwidth: newStyle.legendwidth,
          legendgroup: newStyle.legendgroup,
          legendgrouptitle: {
            text: newStyle.legendgrouptitle.text,
            font: newStyle.legendgrouptitle.font
          },
          legendrank: newStyle.legendrank,
          label: newStyle.label,
          xref: xPaper ? "paper" : xaxis._id,
          yref: yPaper ? "paper" : yaxis._id,
          layer: newStyle.layer,
          opacity: newStyle.opacity,
          line: {
            color: newStyle.line.color,
            width: newStyle.line.width,
            dash: newStyle.line.dash
          }
        };
        if (!isOpenMode) {
          newShape.fillcolor = newStyle.fillcolor;
          newShape.fillrule = newStyle.fillrule;
        }
        var cell;
        if (polygons.length === 1) cell = polygons[0];
        if (cell && cell.length === 5 && // ensure we only have 4 corners for a rect
        dragmode === "drawrect") {
          newShape.type = "rect";
          newShape.x0 = cell[0][1];
          newShape.y0 = cell[0][2];
          newShape.x1 = cell[2][1];
          newShape.y1 = cell[2][2];
        } else if (cell && dragmode === "drawline") {
          newShape.type = "line";
          newShape.x0 = cell[0][1];
          newShape.y0 = cell[0][2];
          newShape.x1 = cell[1][1];
          newShape.y1 = cell[1][2];
        } else if (cell && dragmode === "drawcircle") {
          newShape.type = "circle";
          var xA = cell[i000][1];
          var xB = cell[i090][1];
          var xC = cell[i180][1];
          var xD = cell[i270][1];
          var yA = cell[i000][2];
          var yB = cell[i090][2];
          var yC = cell[i180][2];
          var yD = cell[i270][2];
          var xDateOrLog = plotinfo.xaxis && (plotinfo.xaxis.type === "date" || plotinfo.xaxis.type === "log");
          var yDateOrLog = plotinfo.yaxis && (plotinfo.yaxis.type === "date" || plotinfo.yaxis.type === "log");
          if (xDateOrLog) {
            xA = r2p(plotinfo.xaxis, xA);
            xB = r2p(plotinfo.xaxis, xB);
            xC = r2p(plotinfo.xaxis, xC);
            xD = r2p(plotinfo.xaxis, xD);
          }
          if (yDateOrLog) {
            yA = r2p(plotinfo.yaxis, yA);
            yB = r2p(plotinfo.yaxis, yB);
            yC = r2p(plotinfo.yaxis, yC);
            yD = r2p(plotinfo.yaxis, yD);
          }
          var x0 = (xB + xD) / 2;
          var y0 = (yA + yC) / 2;
          var rx = (xD - xB + xC - xA) / 2;
          var ry = (yD - yB + yC - yA) / 2;
          var pos = ellipseOver({
            x0,
            y0,
            x1: x0 + rx * cos45,
            y1: y0 + ry * sin45
          });
          if (xDateOrLog) {
            pos.x0 = p2r(plotinfo.xaxis, pos.x0);
            pos.x1 = p2r(plotinfo.xaxis, pos.x1);
          }
          if (yDateOrLog) {
            pos.y0 = p2r(plotinfo.yaxis, pos.y0);
            pos.y1 = p2r(plotinfo.yaxis, pos.y1);
          }
          newShape.x0 = pos.x0;
          newShape.y0 = pos.y0;
          newShape.x1 = pos.x1;
          newShape.y1 = pos.y1;
        } else {
          newShape.type = "path";
          if (xaxis && yaxis) fixDatesForPaths(polygons, xaxis, yaxis);
          newShape.path = writePaths(polygons);
          cell = null;
        }
        return newShape;
      }
      module.exports = {
        newShapes,
        createShapeObj
      };
    }
  });

  // src/components/selections/draw_newselection/newselections.js
  var require_newselections = __commonJS({
    "src/components/selections/draw_newselection/newselections.js"(exports, module) {
      "use strict";
      var dragHelpers = require_helpers5();
      var selectMode = dragHelpers.selectMode;
      var handleOutline = require_handle_outline();
      var clearOutline = handleOutline.clearOutline;
      var helpers = require_helpers7();
      var readPaths = helpers.readPaths;
      var writePaths = helpers.writePaths;
      var fixDatesForPaths = helpers.fixDatesForPaths;
      module.exports = function newSelections(outlines, dragOptions) {
        if (!outlines.length) return;
        var e = outlines[0][0];
        if (!e) return;
        var d = e.getAttribute("d");
        var gd = dragOptions.gd;
        var newStyle = gd._fullLayout.newselection;
        var plotinfo = dragOptions.plotinfo;
        var xaxis = plotinfo.xaxis;
        var yaxis = plotinfo.yaxis;
        var isActiveSelection = dragOptions.isActiveSelection;
        var dragmode = dragOptions.dragmode;
        var selections = (gd.layout || {}).selections || [];
        if (!selectMode(dragmode) && isActiveSelection !== void 0) {
          var id = gd._fullLayout._activeSelectionIndex;
          if (id < selections.length) {
            switch (gd._fullLayout.selections[id].type) {
              case "rect":
                dragmode = "select";
                break;
              case "path":
                dragmode = "lasso";
                break;
            }
          }
        }
        var polygons = readPaths(d, gd, plotinfo, isActiveSelection);
        var newSelection = {
          xref: xaxis._id,
          yref: yaxis._id,
          opacity: newStyle.opacity,
          line: {
            color: newStyle.line.color,
            width: newStyle.line.width,
            dash: newStyle.line.dash
          }
        };
        var cell;
        if (polygons.length === 1) cell = polygons[0];
        if (cell && cell.length === 5 && // ensure we only have 4 corners for a rect
        dragmode === "select") {
          newSelection.type = "rect";
          newSelection.x0 = cell[0][1];
          newSelection.y0 = cell[0][2];
          newSelection.x1 = cell[2][1];
          newSelection.y1 = cell[2][2];
        } else {
          newSelection.type = "path";
          if (xaxis && yaxis) fixDatesForPaths(polygons, xaxis, yaxis);
          newSelection.path = writePaths(polygons);
          cell = null;
        }
        clearOutline(gd);
        var editHelpers = dragOptions.editHelpers;
        var modifyItem = (editHelpers || {}).modifyItem;
        var allSelections = [];
        for (var q = 0; q < selections.length; q++) {
          var beforeEdit = gd._fullLayout.selections[q];
          if (!beforeEdit) {
            allSelections[q] = beforeEdit;
            continue;
          }
          allSelections[q] = beforeEdit._input;
          if (isActiveSelection !== void 0 && q === gd._fullLayout._activeSelectionIndex) {
            var afterEdit = newSelection;
            switch (beforeEdit.type) {
              case "rect":
                modifyItem("x0", afterEdit.x0);
                modifyItem("x1", afterEdit.x1);
                modifyItem("y0", afterEdit.y0);
                modifyItem("y1", afterEdit.y1);
                break;
              case "path":
                modifyItem("path", afterEdit.path);
                break;
            }
          }
        }
        if (isActiveSelection === void 0) {
          allSelections.push(newSelection);
          return allSelections;
        }
        return editHelpers ? editHelpers.getUpdateObj() : {};
      };
    }
  });

  // src/components/shapes/constants.js
  var require_constants5 = __commonJS({
    "src/components/shapes/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        segmentRE: /[MLHVQCTSZ][^MLHVQCTSZ]*/g,
        paramRE: /[^\s,]+/g,
        // which numbers in each path segment are x (or y) values
        // drawn is which param is a drawn point, as opposed to a
        // control point (which doesn't count toward autorange.
        // TODO: this means curved paths could extend beyond the
        // autorange bounds. This is a bit tricky to get right
        // unless we revert to bounding boxes, but perhaps there's
        // a calculation we could do...)
        paramIsX: {
          M: { 0: true, drawn: 0 },
          L: { 0: true, drawn: 0 },
          H: { 0: true, drawn: 0 },
          V: {},
          Q: { 0: true, 2: true, drawn: 2 },
          C: { 0: true, 2: true, 4: true, drawn: 4 },
          T: { 0: true, drawn: 0 },
          S: { 0: true, 2: true, drawn: 2 },
          // A: {0: true, 5: true},
          Z: {}
        },
        paramIsY: {
          M: { 1: true, drawn: 1 },
          L: { 1: true, drawn: 1 },
          H: {},
          V: { 0: true, drawn: 0 },
          Q: { 1: true, 3: true, drawn: 3 },
          C: { 1: true, 3: true, 5: true, drawn: 5 },
          T: { 1: true, drawn: 1 },
          S: { 1: true, 3: true, drawn: 5 },
          // A: {1: true, 6: true},
          Z: {}
        },
        numParams: {
          M: 2,
          L: 2,
          H: 1,
          V: 1,
          Q: 4,
          C: 6,
          T: 2,
          S: 4,
          // A: 7,
          Z: 0
        }
      };
    }
  });

  // src/components/shapes/helpers.js
  var require_helpers8 = __commonJS({
    "src/components/shapes/helpers.js"(exports) {
      "use strict";
      var constants = require_constants5();
      var Lib = require_lib();
      var Axes = require_axes();
      exports.rangeToShapePosition = function(ax) {
        return ax.type === "log" ? ax.r2d : function(v) {
          return v;
        };
      };
      exports.shapePositionToRange = function(ax) {
        return ax.type === "log" ? ax.d2r : function(v) {
          return v;
        };
      };
      exports.decodeDate = function(convertToPx) {
        return function(v) {
          if (v.replace) v = v.replace("_", " ");
          return convertToPx(v);
        };
      };
      exports.encodeDate = function(convertToDate) {
        return function(v) {
          return convertToDate(v).replace(" ", "_");
        };
      };
      exports.extractPathCoords = function(path, paramsToUse, isRaw) {
        var extractedCoordinates = [];
        var segments = path.match(constants.segmentRE);
        segments.forEach(function(segment) {
          var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;
          if (relevantParamIdx === void 0) return;
          var params = segment.substr(1).match(constants.paramRE);
          if (!params || params.length < relevantParamIdx) return;
          var str = params[relevantParamIdx];
          var pos = isRaw ? str : Lib.cleanNumber(str);
          extractedCoordinates.push(pos);
        });
        return extractedCoordinates;
      };
      exports.getDataToPixel = function(gd, axis, shift, isVertical, refType) {
        var gs = gd._fullLayout._size;
        var dataToPixel;
        if (axis) {
          if (refType === "domain") {
            dataToPixel = function(v) {
              return axis._length * (isVertical ? 1 - v : v) + axis._offset;
            };
          } else {
            var d2r = exports.shapePositionToRange(axis);
            dataToPixel = function(v) {
              var shiftPixels = getPixelShift(axis, shift);
              return axis._offset + axis.r2p(d2r(v, true)) + shiftPixels;
            };
            if (axis.type === "date") dataToPixel = exports.decodeDate(dataToPixel);
          }
        } else if (isVertical) {
          dataToPixel = function(v) {
            return gs.t + gs.h * (1 - v);
          };
        } else {
          dataToPixel = function(v) {
            return gs.l + gs.w * v;
          };
        }
        return dataToPixel;
      };
      exports.getPixelToData = function(gd, axis, isVertical, opt) {
        var gs = gd._fullLayout._size;
        var pixelToData;
        if (axis) {
          if (opt === "domain") {
            pixelToData = function(p) {
              var q = (p - axis._offset) / axis._length;
              return isVertical ? 1 - q : q;
            };
          } else {
            var r2d = exports.rangeToShapePosition(axis);
            pixelToData = function(p) {
              return r2d(axis.p2r(p - axis._offset));
            };
          }
        } else if (isVertical) {
          pixelToData = function(p) {
            return 1 - (p - gs.t) / gs.h;
          };
        } else {
          pixelToData = function(p) {
            return (p - gs.l) / gs.w;
          };
        }
        return pixelToData;
      };
      exports.roundPositionForSharpStrokeRendering = function(pos, strokeWidth) {
        var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;
        var posValAsInt = Math.round(pos);
        return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;
      };
      exports.makeShapesOptionsAndPlotinfo = function(gd, index) {
        var options = gd._fullLayout.shapes[index] || {};
        var plotinfo = gd._fullLayout._plots[options.xref + options.yref];
        var hasPlotinfo = !!plotinfo;
        if (hasPlotinfo) {
          plotinfo._hadPlotinfo = true;
        } else {
          plotinfo = {};
          if (options.xref && options.xref !== "paper") plotinfo.xaxis = gd._fullLayout[options.xref + "axis"];
          if (options.yref && options.yref !== "paper") plotinfo.yaxis = gd._fullLayout[options.yref + "axis"];
        }
        plotinfo.xsizemode = options.xsizemode;
        plotinfo.ysizemode = options.ysizemode;
        plotinfo.xanchor = options.xanchor;
        plotinfo.yanchor = options.yanchor;
        return {
          options,
          plotinfo
        };
      };
      exports.makeSelectionsOptionsAndPlotinfo = function(gd, index) {
        var options = gd._fullLayout.selections[index] || {};
        var plotinfo = gd._fullLayout._plots[options.xref + options.yref];
        var hasPlotinfo = !!plotinfo;
        if (hasPlotinfo) {
          plotinfo._hadPlotinfo = true;
        } else {
          plotinfo = {};
          if (options.xref) plotinfo.xaxis = gd._fullLayout[options.xref + "axis"];
          if (options.yref) plotinfo.yaxis = gd._fullLayout[options.yref + "axis"];
        }
        return {
          options,
          plotinfo
        };
      };
      exports.getPathString = function(gd, options) {
        var type = options.type;
        var xRefType = Axes.getRefType(options.xref);
        var yRefType = Axes.getRefType(options.yref);
        var xa = Axes.getFromId(gd, options.xref);
        var ya = Axes.getFromId(gd, options.yref);
        var gs = gd._fullLayout._size;
        var x2r, x2p, y2r, y2p;
        var xShiftStart = getPixelShift(xa, options.x0shift);
        var xShiftEnd = getPixelShift(xa, options.x1shift);
        var yShiftStart = getPixelShift(ya, options.y0shift);
        var yShiftEnd = getPixelShift(ya, options.y1shift);
        var x0, x1, y0, y1;
        if (xa) {
          if (xRefType === "domain") {
            x2p = function(v) {
              return xa._offset + xa._length * v;
            };
          } else {
            x2r = exports.shapePositionToRange(xa);
            x2p = function(v) {
              return xa._offset + xa.r2p(x2r(v, true));
            };
          }
        } else {
          x2p = function(v) {
            return gs.l + gs.w * v;
          };
        }
        if (ya) {
          if (yRefType === "domain") {
            y2p = function(v) {
              return ya._offset + ya._length * (1 - v);
            };
          } else {
            y2r = exports.shapePositionToRange(ya);
            y2p = function(v) {
              return ya._offset + ya.r2p(y2r(v, true));
            };
          }
        } else {
          y2p = function(v) {
            return gs.t + gs.h * (1 - v);
          };
        }
        if (type === "path") {
          if (xa && xa.type === "date") x2p = exports.decodeDate(x2p);
          if (ya && ya.type === "date") y2p = exports.decodeDate(y2p);
          return convertPath(options, x2p, y2p);
        }
        if (options.xsizemode === "pixel") {
          var xAnchorPos = x2p(options.xanchor);
          x0 = xAnchorPos + options.x0 + xShiftStart;
          x1 = xAnchorPos + options.x1 + xShiftEnd;
        } else {
          x0 = x2p(options.x0) + xShiftStart;
          x1 = x2p(options.x1) + xShiftEnd;
        }
        if (options.ysizemode === "pixel") {
          var yAnchorPos = y2p(options.yanchor);
          y0 = yAnchorPos - options.y0 + yShiftStart;
          y1 = yAnchorPos - options.y1 + yShiftEnd;
        } else {
          y0 = y2p(options.y0) + yShiftStart;
          y1 = y2p(options.y1) + yShiftEnd;
        }
        if (type === "line") return "M" + x0 + "," + y0 + "L" + x1 + "," + y1;
        if (type === "rect") return "M" + x0 + "," + y0 + "H" + x1 + "V" + y1 + "H" + x0 + "Z";
        var cx = (x0 + x1) / 2;
        var cy = (y0 + y1) / 2;
        var rx = Math.abs(cx - x0);
        var ry = Math.abs(cy - y0);
        var rArc = "A" + rx + "," + ry;
        var rightPt = cx + rx + "," + cy;
        var topPt = cx + "," + (cy - ry);
        return "M" + rightPt + rArc + " 0 1,1 " + topPt + rArc + " 0 0,1 " + rightPt + "Z";
      };
      function convertPath(options, x2p, y2p) {
        var pathIn = options.path;
        var xSizemode = options.xsizemode;
        var ySizemode = options.ysizemode;
        var xAnchor = options.xanchor;
        var yAnchor = options.yanchor;
        return pathIn.replace(constants.segmentRE, function(segment) {
          var paramNumber = 0;
          var segmentType = segment.charAt(0);
          var xParams = constants.paramIsX[segmentType];
          var yParams = constants.paramIsY[segmentType];
          var nParams = constants.numParams[segmentType];
          var paramString = segment.substr(1).replace(constants.paramRE, function(param) {
            if (xParams[paramNumber]) {
              if (xSizemode === "pixel") param = x2p(xAnchor) + Number(param);
              else param = x2p(param);
            } else if (yParams[paramNumber]) {
              if (ySizemode === "pixel") param = y2p(yAnchor) - Number(param);
              else param = y2p(param);
            }
            paramNumber++;
            if (paramNumber > nParams) param = "X";
            return param;
          });
          if (paramNumber > nParams) {
            paramString = paramString.replace(/[\s,]*X.*/, "");
            Lib.log("Ignoring extra params in segment " + segment);
          }
          return segmentType + paramString;
        });
      }
      function getPixelShift(axis, shift) {
        shift = shift || 0;
        var shiftPixels = 0;
        if (shift && axis && (axis.type === "category" || axis.type === "multicategory")) {
          shiftPixels = (axis.r2p(1) - axis.r2p(0)) * shift;
        }
        return shiftPixels;
      }
    }
  });

  // src/components/shapes/display_labels.js
  var require_display_labels = __commonJS({
    "src/components/shapes/display_labels.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var svgTextUtils = require_svg_text_utils();
      var Drawing = require_drawing();
      var readPaths = require_helpers7().readPaths;
      var helpers = require_helpers8();
      var getPathString = helpers.getPathString;
      var shapeLabelTexttemplateVars = require_label_texttemplate();
      var FROM_TL = require_alignment().FROM_TL;
      module.exports = function drawLabel(gd, index, options, shapeGroup) {
        shapeGroup.selectAll(".shape-label").remove();
        if (!(options.label.text || options.label.texttemplate)) return;
        var text;
        if (options.label.texttemplate) {
          var templateValues = {};
          if (options.type !== "path") {
            var _xa = Axes.getFromId(gd, options.xref);
            var _ya = Axes.getFromId(gd, options.yref);
            for (var key in shapeLabelTexttemplateVars) {
              var val = shapeLabelTexttemplateVars[key](options, _xa, _ya);
              if (val !== void 0) templateValues[key] = val;
            }
          }
          text = Lib.texttemplateStringForShapes(
            options.label.texttemplate,
            {},
            gd._fullLayout._d3locale,
            templateValues
          );
        } else {
          text = options.label.text;
        }
        var labelGroupAttrs = {
          "data-index": index
        };
        var font = options.label.font;
        var labelTextAttrs = {
          "data-notex": 1
        };
        var labelGroup = shapeGroup.append("g").attr(labelGroupAttrs).classed("shape-label", true);
        var labelText = labelGroup.append("text").attr(labelTextAttrs).classed("shape-label-text", true).text(text);
        var shapex0, shapex1, shapey0, shapey1;
        if (options.path) {
          var d = getPathString(gd, options);
          var polygons = readPaths(d, gd);
          shapex0 = Infinity;
          shapey0 = Infinity;
          shapex1 = -Infinity;
          shapey1 = -Infinity;
          for (var i = 0; i < polygons.length; i++) {
            for (var j = 0; j < polygons[i].length; j++) {
              var p = polygons[i][j];
              for (var k = 1; k < p.length; k += 2) {
                var _x = p[k];
                var _y = p[k + 1];
                shapex0 = Math.min(shapex0, _x);
                shapex1 = Math.max(shapex1, _x);
                shapey0 = Math.min(shapey0, _y);
                shapey1 = Math.max(shapey1, _y);
              }
            }
          }
        } else {
          var xa = Axes.getFromId(gd, options.xref);
          var xShiftStart = options.x0shift;
          var xShiftEnd = options.x1shift;
          var xRefType = Axes.getRefType(options.xref);
          var ya = Axes.getFromId(gd, options.yref);
          var yShiftStart = options.y0shift;
          var yShiftEnd = options.y1shift;
          var yRefType = Axes.getRefType(options.yref);
          var x2p = function(v, shift) {
            var dataToPixel = helpers.getDataToPixel(gd, xa, shift, false, xRefType);
            return dataToPixel(v);
          };
          var y2p = function(v, shift) {
            var dataToPixel = helpers.getDataToPixel(gd, ya, shift, true, yRefType);
            return dataToPixel(v);
          };
          shapex0 = x2p(options.x0, xShiftStart);
          shapex1 = x2p(options.x1, xShiftEnd);
          shapey0 = y2p(options.y0, yShiftStart);
          shapey1 = y2p(options.y1, yShiftEnd);
        }
        var textangle = options.label.textangle;
        if (textangle === "auto") {
          if (options.type === "line") {
            textangle = calcTextAngle(shapex0, shapey0, shapex1, shapey1);
          } else {
            textangle = 0;
          }
        }
        labelText.call(function(s) {
          s.call(Drawing.font, font).attr({});
          svgTextUtils.convertToTspans(s, gd);
          return s;
        });
        var textBB = Drawing.bBox(labelText.node());
        var textPos = calcTextPosition(shapex0, shapey0, shapex1, shapey1, options, textangle, textBB);
        var textx = textPos.textx;
        var texty = textPos.texty;
        var xanchor = textPos.xanchor;
        labelText.attr({
          "text-anchor": {
            left: "start",
            center: "middle",
            right: "end"
          }[xanchor],
          y: texty,
          x: textx,
          transform: "rotate(" + textangle + "," + textx + "," + texty + ")"
        }).call(svgTextUtils.positionText, textx, texty);
      };
      function calcTextAngle(shapex0, shapey0, shapex1, shapey1) {
        var dy, dx;
        dx = Math.abs(shapex1 - shapex0);
        if (shapex1 >= shapex0) {
          dy = shapey0 - shapey1;
        } else {
          dy = shapey1 - shapey0;
        }
        return -180 / Math.PI * Math.atan2(dy, dx);
      }
      function calcTextPosition(shapex0, shapey0, shapex1, shapey1, shapeOptions, actualTextAngle, textBB) {
        var textPosition = shapeOptions.label.textposition;
        var textAngle = shapeOptions.label.textangle;
        var textPadding = shapeOptions.label.padding;
        var shapeType = shapeOptions.type;
        var textAngleRad = Math.PI / 180 * actualTextAngle;
        var sinA = Math.sin(textAngleRad);
        var cosA = Math.cos(textAngleRad);
        var xanchor = shapeOptions.label.xanchor;
        var yanchor = shapeOptions.label.yanchor;
        var textx, texty, paddingX, paddingY;
        if (shapeType === "line") {
          if (textPosition === "start") {
            textx = shapex0;
            texty = shapey0;
          } else if (textPosition === "end") {
            textx = shapex1;
            texty = shapey1;
          } else {
            textx = (shapex0 + shapex1) / 2;
            texty = (shapey0 + shapey1) / 2;
          }
          if (xanchor === "auto") {
            if (textPosition === "start") {
              if (textAngle === "auto") {
                if (shapex1 > shapex0) xanchor = "left";
                else if (shapex1 < shapex0) xanchor = "right";
                else xanchor = "center";
              } else {
                if (shapex1 > shapex0) xanchor = "right";
                else if (shapex1 < shapex0) xanchor = "left";
                else xanchor = "center";
              }
            } else if (textPosition === "end") {
              if (textAngle === "auto") {
                if (shapex1 > shapex0) xanchor = "right";
                else if (shapex1 < shapex0) xanchor = "left";
                else xanchor = "center";
              } else {
                if (shapex1 > shapex0) xanchor = "left";
                else if (shapex1 < shapex0) xanchor = "right";
                else xanchor = "center";
              }
            } else {
              xanchor = "center";
            }
          }
          var paddingConstantsX = { left: 1, center: 0, right: -1 };
          var paddingConstantsY = { bottom: -1, middle: 0, top: 1 };
          if (textAngle === "auto") {
            var paddingDirection = paddingConstantsY[yanchor];
            paddingX = -textPadding * sinA * paddingDirection;
            paddingY = textPadding * cosA * paddingDirection;
          } else {
            var paddingDirectionX = paddingConstantsX[xanchor];
            var paddingDirectionY = paddingConstantsY[yanchor];
            paddingX = textPadding * paddingDirectionX;
            paddingY = textPadding * paddingDirectionY;
          }
          textx = textx + paddingX;
          texty = texty + paddingY;
        } else {
          paddingX = textPadding + 3;
          if (textPosition.indexOf("right") !== -1) {
            textx = Math.max(shapex0, shapex1) - paddingX;
            if (xanchor === "auto") xanchor = "right";
          } else if (textPosition.indexOf("left") !== -1) {
            textx = Math.min(shapex0, shapex1) + paddingX;
            if (xanchor === "auto") xanchor = "left";
          } else {
            textx = (shapex0 + shapex1) / 2;
            if (xanchor === "auto") xanchor = "center";
          }
          if (textPosition.indexOf("top") !== -1) {
            texty = Math.min(shapey0, shapey1);
          } else if (textPosition.indexOf("bottom") !== -1) {
            texty = Math.max(shapey0, shapey1);
          } else {
            texty = (shapey0 + shapey1) / 2;
          }
          paddingY = textPadding;
          if (yanchor === "bottom") {
            texty = texty - paddingY;
          } else if (yanchor === "top") {
            texty = texty + paddingY;
          }
        }
        var shiftFraction = FROM_TL[yanchor];
        var baselineAdjust = shapeOptions.label.font.size;
        var textHeight = textBB.height;
        var xshift = (textHeight * shiftFraction - baselineAdjust) * sinA;
        var yshift = -(textHeight * shiftFraction - baselineAdjust) * cosA;
        return { textx: textx + xshift, texty: texty + yshift, xanchor };
      }
    }
  });

  // src/components/shapes/display_outlines.js
  var require_display_outlines = __commonJS({
    "src/components/shapes/display_outlines.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var dragElement = require_dragelement();
      var dragHelpers = require_helpers5();
      var drawMode = dragHelpers.drawMode;
      var selectMode = dragHelpers.selectMode;
      var Registry = require_registry();
      var Color = require_color();
      var constants = require_constants4();
      var i000 = constants.i000;
      var i090 = constants.i090;
      var i180 = constants.i180;
      var i270 = constants.i270;
      var handleOutline = require_handle_outline();
      var clearOutlineControllers = handleOutline.clearOutlineControllers;
      var helpers = require_helpers7();
      var pointsOnRectangle = helpers.pointsOnRectangle;
      var pointsOnEllipse = helpers.pointsOnEllipse;
      var writePaths = helpers.writePaths;
      var newShapes = require_newshapes().newShapes;
      var createShapeObj = require_newshapes().createShapeObj;
      var newSelections = require_newselections();
      var drawLabel = require_display_labels();
      module.exports = function displayOutlines(polygons, outlines, dragOptions, nCalls) {
        if (!nCalls) nCalls = 0;
        var gd = dragOptions.gd;
        function redraw() {
          displayOutlines(polygons, outlines, dragOptions, nCalls++);
          if (pointsOnEllipse(polygons[0]) || dragOptions.hasText) {
            update({ redrawing: true });
          }
        }
        function update(opts) {
          var updateObject = {};
          if (dragOptions.isActiveShape !== void 0) {
            dragOptions.isActiveShape = false;
            updateObject = newShapes(outlines, dragOptions);
          }
          if (dragOptions.isActiveSelection !== void 0) {
            dragOptions.isActiveSelection = false;
            updateObject = newSelections(outlines, dragOptions);
            gd._fullLayout._reselect = true;
          }
          if (Object.keys(updateObject).length) {
            Registry.call((opts || {}).redrawing ? "relayout" : "_guiRelayout", gd, updateObject);
          }
        }
        var fullLayout = gd._fullLayout;
        var zoomLayer = fullLayout._zoomlayer;
        var dragmode = dragOptions.dragmode;
        var isDrawMode = drawMode(dragmode);
        var isSelectMode = selectMode(dragmode);
        if (isDrawMode || isSelectMode) {
          gd._fullLayout._outlining = true;
        }
        clearOutlineControllers(gd);
        outlines.attr("d", writePaths(polygons));
        var vertexDragOptions;
        var groupDragOptions;
        var indexI;
        var indexJ;
        var copyPolygons;
        if (!nCalls && (dragOptions.isActiveShape || dragOptions.isActiveSelection)) {
          copyPolygons = recordPositions([], polygons);
          var g = zoomLayer.append("g").attr("class", "outline-controllers");
          addVertexControllers(g);
          addGroupControllers();
        }
        if (isDrawMode && dragOptions.hasText) {
          var shapeGroup = zoomLayer.select(".label-temp");
          var shapeOptions = createShapeObj(outlines, dragOptions, dragOptions.dragmode);
          drawLabel(gd, "label-temp", shapeOptions, shapeGroup);
        }
        function startDragVertex(evt) {
          indexI = +evt.srcElement.getAttribute("data-i");
          indexJ = +evt.srcElement.getAttribute("data-j");
          vertexDragOptions[indexI][indexJ].moveFn = moveVertexController;
        }
        function moveVertexController(dx, dy) {
          if (!polygons.length) return;
          var x0 = copyPolygons[indexI][indexJ][1];
          var y0 = copyPolygons[indexI][indexJ][2];
          var cell = polygons[indexI];
          var len = cell.length;
          if (pointsOnRectangle(cell)) {
            var _dx = dx;
            var _dy = dy;
            if (dragOptions.isActiveSelection) {
              var nextPoint = getNextPoint(cell, indexJ);
              if (nextPoint[1] === cell[indexJ][1]) {
                _dy = 0;
              } else {
                _dx = 0;
              }
            }
            for (var q = 0; q < len; q++) {
              if (q === indexJ) continue;
              var pos = cell[q];
              if (pos[1] === cell[indexJ][1]) {
                pos[1] = x0 + _dx;
              }
              if (pos[2] === cell[indexJ][2]) {
                pos[2] = y0 + _dy;
              }
            }
            cell[indexJ][1] = x0 + _dx;
            cell[indexJ][2] = y0 + _dy;
            if (!pointsOnRectangle(cell)) {
              for (var j = 0; j < len; j++) {
                for (var k = 0; k < cell[j].length; k++) {
                  cell[j][k] = copyPolygons[indexI][j][k];
                }
              }
            }
          } else {
            cell[indexJ][1] = x0 + dx;
            cell[indexJ][2] = y0 + dy;
          }
          redraw();
        }
        function endDragVertexController() {
          update();
        }
        function removeVertex() {
          if (!polygons.length) return;
          if (!polygons[indexI]) return;
          if (!polygons[indexI].length) return;
          var newPolygon = [];
          for (var j = 0; j < polygons[indexI].length; j++) {
            if (j !== indexJ) {
              newPolygon.push(
                polygons[indexI][j]
              );
            }
          }
          if (newPolygon.length > 1 && !(newPolygon.length === 2 && newPolygon[1][0] === "Z")) {
            if (indexJ === 0) {
              newPolygon[0][0] = "M";
            }
            polygons[indexI] = newPolygon;
            redraw();
            update();
          }
        }
        function clickVertexController(numClicks, evt) {
          if (numClicks === 2) {
            indexI = +evt.srcElement.getAttribute("data-i");
            indexJ = +evt.srcElement.getAttribute("data-j");
            var cell = polygons[indexI];
            if (!pointsOnRectangle(cell) && !pointsOnEllipse(cell)) {
              removeVertex();
            }
          }
        }
        function addVertexControllers(g2) {
          vertexDragOptions = [];
          for (var i = 0; i < polygons.length; i++) {
            var cell = polygons[i];
            var onRect = pointsOnRectangle(cell);
            var onEllipse = !onRect && pointsOnEllipse(cell);
            vertexDragOptions[i] = [];
            var len = cell.length;
            for (var j = 0; j < len; j++) {
              if (cell[j][0] === "Z") continue;
              if (onEllipse && j !== i000 && j !== i090 && j !== i180 && j !== i270) {
                continue;
              }
              var rectSelection = onRect && dragOptions.isActiveSelection;
              var nextPoint;
              if (rectSelection) nextPoint = getNextPoint(cell, j);
              var x = cell[j][1];
              var y = cell[j][2];
              var vertex = g2.append(rectSelection ? "rect" : "circle").attr("data-i", i).attr("data-j", j).style({
                fill: Color.background,
                stroke: Color.defaultLine,
                "stroke-width": 1,
                "shape-rendering": "crispEdges"
              });
              if (rectSelection) {
                var dx = nextPoint[1] - x;
                var dy = nextPoint[2] - y;
                var width = dy ? 5 : Math.max(Math.min(25, Math.abs(dx) - 5), 5);
                var height = dx ? 5 : Math.max(Math.min(25, Math.abs(dy) - 5), 5);
                vertex.classed(dy ? "cursor-ew-resize" : "cursor-ns-resize", true).attr("width", width).attr("height", height).attr("x", x - width / 2).attr("y", y - height / 2).attr("transform", strTranslate(dx / 2, dy / 2));
              } else {
                vertex.classed("cursor-grab", true).attr("r", 5).attr("cx", x).attr("cy", y);
              }
              vertexDragOptions[i][j] = {
                element: vertex.node(),
                gd,
                prepFn: startDragVertex,
                doneFn: endDragVertexController,
                clickFn: clickVertexController
              };
              dragElement.init(vertexDragOptions[i][j]);
            }
          }
        }
        function moveGroup(dx, dy) {
          if (!polygons.length) return;
          for (var i = 0; i < polygons.length; i++) {
            for (var j = 0; j < polygons[i].length; j++) {
              for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {
                polygons[i][j][k + 1] = copyPolygons[i][j][k + 1] + dx;
                polygons[i][j][k + 2] = copyPolygons[i][j][k + 2] + dy;
              }
            }
          }
        }
        function moveGroupController(dx, dy) {
          moveGroup(dx, dy);
          redraw();
        }
        function startDragGroupController(evt) {
          indexI = +evt.srcElement.getAttribute("data-i");
          if (!indexI) indexI = 0;
          groupDragOptions[indexI].moveFn = moveGroupController;
        }
        function endDragGroupController() {
          update();
        }
        function clickGroupController(numClicks) {
          if (numClicks === 2) {
            eraseActiveSelection(gd);
          }
        }
        function addGroupControllers() {
          groupDragOptions = [];
          if (!polygons.length) return;
          var i = 0;
          groupDragOptions[i] = {
            element: outlines[0][0],
            gd,
            prepFn: startDragGroupController,
            doneFn: endDragGroupController,
            clickFn: clickGroupController
          };
          dragElement.init(groupDragOptions[i]);
        }
      };
      function recordPositions(polygonsOut, polygonsIn) {
        for (var i = 0; i < polygonsIn.length; i++) {
          var cell = polygonsIn[i];
          polygonsOut[i] = [];
          for (var j = 0; j < cell.length; j++) {
            polygonsOut[i][j] = [];
            for (var k = 0; k < cell[j].length; k++) {
              polygonsOut[i][j][k] = cell[j][k];
            }
          }
        }
        return polygonsOut;
      }
      function getNextPoint(cell, j) {
        var x = cell[j][1];
        var y = cell[j][2];
        var len = cell.length;
        var nextJ, nextX, nextY;
        nextJ = (j + 1) % len;
        nextX = cell[nextJ][1];
        nextY = cell[nextJ][2];
        if (nextX === x && nextY === y) {
          nextJ = (j + 2) % len;
          nextX = cell[nextJ][1];
          nextY = cell[nextJ][2];
        }
        return [nextJ, nextX, nextY];
      }
      function eraseActiveSelection(gd) {
        if (!selectMode(gd._fullLayout.dragmode)) return;
        clearOutlineControllers(gd);
        var id = gd._fullLayout._activeSelectionIndex;
        var selections = (gd.layout || {}).selections || [];
        if (id < selections.length) {
          var list = [];
          for (var q = 0; q < selections.length; q++) {
            if (q !== id) {
              list.push(selections[q]);
            }
          }
          delete gd._fullLayout._activeSelectionIndex;
          var erasedSelection = gd._fullLayout.selections[id];
          gd._fullLayout._deselect = {
            xref: erasedSelection.xref,
            yref: erasedSelection.yref
          };
          Registry.call("_guiRelayout", gd, {
            selections: list
          });
        }
      }
    }
  });

  // src/components/shapes/draw.js
  var require_draw2 = __commonJS({
    "src/components/shapes/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var Axes = require_axes();
      var readPaths = require_helpers7().readPaths;
      var displayOutlines = require_display_outlines();
      var drawLabel = require_display_labels();
      var clearOutlineControllers = require_handle_outline().clearOutlineControllers;
      var Color = require_color();
      var Drawing = require_drawing();
      var arrayEditor = require_plot_template().arrayEditor;
      var dragElement = require_dragelement();
      var setCursor = require_setcursor();
      var constants = require_constants5();
      var helpers = require_helpers8();
      var getPathString = helpers.getPathString;
      module.exports = {
        draw,
        drawOne,
        eraseActiveShape,
        drawLabel
      };
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        fullLayout._shapeUpperLayer.selectAll("path").remove();
        fullLayout._shapeLowerLayer.selectAll("path").remove();
        fullLayout._shapeUpperLayer.selectAll("text").remove();
        fullLayout._shapeLowerLayer.selectAll("text").remove();
        for (var k in fullLayout._plots) {
          var shapelayer = fullLayout._plots[k].shapelayer;
          if (shapelayer) {
            shapelayer.selectAll("path").remove();
            shapelayer.selectAll("text").remove();
          }
        }
        for (var i = 0; i < fullLayout.shapes.length; i++) {
          if (fullLayout.shapes[i].visible === true) {
            drawOne(gd, i);
          }
        }
      }
      function shouldSkipEdits(gd) {
        return !!gd._fullLayout._outlining;
      }
      function couldHaveActiveShape(gd) {
        return !gd._context.edits.shapePosition;
      }
      function drawOne(gd, index) {
        gd._fullLayout._paperdiv.selectAll('.shapelayer [data-index="' + index + '"]').remove();
        var o = helpers.makeShapesOptionsAndPlotinfo(gd, index);
        var options = o.options;
        var plotinfo = o.plotinfo;
        if (!options._input || options.visible !== true) return;
        if (options.layer === "above") {
          drawShape(gd._fullLayout._shapeUpperLayer);
        } else if (options.xref === "paper" || options.yref === "paper") {
          drawShape(gd._fullLayout._shapeLowerLayer);
        } else if (options.layer === "between") {
          drawShape(plotinfo.shapelayerBetween);
        } else {
          if (plotinfo._hadPlotinfo) {
            var mainPlot = plotinfo.mainplotinfo || plotinfo;
            drawShape(mainPlot.shapelayer);
          } else {
            drawShape(gd._fullLayout._shapeLowerLayer);
          }
        }
        function drawShape(shapeLayer) {
          var d = getPathString(gd, options);
          var attrs = {
            "data-index": index,
            "fill-rule": options.fillrule,
            d
          };
          var opacity = options.opacity;
          var fillColor = options.fillcolor;
          var lineColor = options.line.width ? options.line.color : "rgba(0,0,0,0)";
          var lineWidth = options.line.width;
          var lineDash = options.line.dash;
          if (!lineWidth && options.editable === true) {
            lineWidth = 5;
            lineDash = "solid";
          }
          var isOpen = d[d.length - 1] !== "Z";
          var isActiveShape = couldHaveActiveShape(gd) && options.editable && gd._fullLayout._activeShapeIndex === index;
          if (isActiveShape) {
            fillColor = isOpen ? "rgba(0,0,0,0)" : gd._fullLayout.activeshape.fillcolor;
            opacity = gd._fullLayout.activeshape.opacity;
          }
          var shapeGroup = shapeLayer.append("g").classed("shape-group", true).attr({ "data-index": index });
          var path = shapeGroup.append("path").attr(attrs).style("opacity", opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor).call(Drawing.dashLine, lineDash, lineWidth);
          setClipPath(shapeGroup, gd, options);
          drawLabel(gd, index, options, shapeGroup);
          var editHelpers;
          if (isActiveShape || gd._context.edits.shapePosition) editHelpers = arrayEditor(gd.layout, "shapes", options);
          if (isActiveShape) {
            path.style({
              cursor: "move"
            });
            var dragOptions = {
              element: path.node(),
              plotinfo,
              gd,
              editHelpers,
              hasText: options.label.text || options.label.texttemplate,
              isActiveShape: true
              // i.e. to enable controllers
            };
            var polygons = readPaths(d, gd);
            displayOutlines(polygons, path, dragOptions);
          } else {
            if (gd._context.edits.shapePosition) {
              setupDragElement(gd, path, options, index, shapeLayer, editHelpers);
            } else if (options.editable === true) {
              path.style(
                "pointer-events",
                isOpen || Color.opacity(fillColor) * opacity <= 0.5 ? "stroke" : "all"
              );
            }
          }
          path.node().addEventListener("click", function() {
            return activateShape(gd, path);
          });
        }
      }
      function setClipPath(shapePath, gd, shapeOptions) {
        var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, "").replace(/[xyz][1-9]* *domain/g, "");
        Drawing.setClipUrl(
          shapePath,
          clipAxes ? "clip" + gd._fullLayout._uid + clipAxes : null,
          gd
        );
      }
      function setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer, editHelpers) {
        var MINWIDTH = 10;
        var MINHEIGHT = 10;
        var xPixelSized = shapeOptions.xsizemode === "pixel";
        var yPixelSized = shapeOptions.ysizemode === "pixel";
        var isLine = shapeOptions.type === "line";
        var isPath = shapeOptions.type === "path";
        var modifyItem = editHelpers.modifyItem;
        var x0, y0, x1, y1, xAnchor, yAnchor;
        var n0, s0, w0, e0, optN, optS, optW, optE;
        var pathIn;
        var shapeGroup = d3.select(shapePath.node().parentNode);
        var xa = Axes.getFromId(gd, shapeOptions.xref);
        var xRefType = Axes.getRefType(shapeOptions.xref);
        var ya = Axes.getFromId(gd, shapeOptions.yref);
        var yRefType = Axes.getRefType(shapeOptions.yref);
        var shiftXStart = shapeOptions.x0shift;
        var shiftXEnd = shapeOptions.x1shift;
        var shiftYStart = shapeOptions.y0shift;
        var shiftYEnd = shapeOptions.y1shift;
        var x2p = function(v, shift) {
          var dataToPixel = helpers.getDataToPixel(gd, xa, shift, false, xRefType);
          return dataToPixel(v);
        };
        var y2p = function(v, shift) {
          var dataToPixel = helpers.getDataToPixel(gd, ya, shift, true, yRefType);
          return dataToPixel(v);
        };
        var p2x = helpers.getPixelToData(gd, xa, false, xRefType);
        var p2y = helpers.getPixelToData(gd, ya, true, yRefType);
        var sensoryElement = obtainSensoryElement();
        var dragOptions = {
          element: sensoryElement.node(),
          gd,
          prepFn: startDrag,
          doneFn: endDrag,
          clickFn: abortDrag
        };
        var dragMode;
        dragElement.init(dragOptions);
        sensoryElement.node().onmousemove = updateDragMode;
        function obtainSensoryElement() {
          return isLine ? createLineDragHandles() : shapePath;
        }
        function createLineDragHandles() {
          var minSensoryWidth = 10;
          var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);
          var g = shapeLayer.append("g").attr("data-index", index).attr("drag-helper", true);
          g.append("path").attr("d", shapePath.attr("d")).style({
            cursor: "move",
            "stroke-width": sensoryWidth,
            "stroke-opacity": "0"
            // ensure not visible
          });
          var circleStyle = {
            "fill-opacity": "0"
            // ensure not visible
          };
          var circleRadius = Math.max(sensoryWidth / 2, minSensoryWidth);
          g.append("circle").attr({
            "data-line-point": "start-point",
            cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0, shiftXStart),
            cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0, shiftYStart),
            r: circleRadius
          }).style(circleStyle).classed("cursor-grab", true);
          g.append("circle").attr({
            "data-line-point": "end-point",
            cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1, shiftXEnd),
            cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1, shiftYEnd),
            r: circleRadius
          }).style(circleStyle).classed("cursor-grab", true);
          return g;
        }
        function updateDragMode(evt) {
          if (shouldSkipEdits(gd)) {
            dragMode = null;
            return;
          }
          if (isLine) {
            if (evt.target.tagName === "path") {
              dragMode = "move";
            } else {
              dragMode = evt.target.attributes["data-line-point"].value === "start-point" ? "resize-over-start-point" : "resize-over-end-point";
            }
          } else {
            var dragBBox = dragOptions.element.getBoundingClientRect();
            var w = dragBBox.right - dragBBox.left;
            var h = dragBBox.bottom - dragBBox.top;
            var x = evt.clientX - dragBBox.left;
            var y = evt.clientY - dragBBox.top;
            var cursor = !isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey ? dragElement.getCursor(x / w, 1 - y / h) : "move";
            setCursor(shapePath, cursor);
            dragMode = cursor.split("-")[0];
          }
        }
        function startDrag(evt) {
          if (shouldSkipEdits(gd)) return;
          if (xPixelSized) {
            xAnchor = x2p(shapeOptions.xanchor);
          }
          if (yPixelSized) {
            yAnchor = y2p(shapeOptions.yanchor);
          }
          if (shapeOptions.type === "path") {
            pathIn = shapeOptions.path;
          } else {
            x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);
            y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);
            x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);
            y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);
          }
          if (x0 < x1) {
            w0 = x0;
            optW = "x0";
            e0 = x1;
            optE = "x1";
          } else {
            w0 = x1;
            optW = "x1";
            e0 = x0;
            optE = "x0";
          }
          if (!yPixelSized && y0 < y1 || yPixelSized && y0 > y1) {
            n0 = y0;
            optN = "y0";
            s0 = y1;
            optS = "y1";
          } else {
            n0 = y1;
            optN = "y1";
            s0 = y0;
            optS = "y0";
          }
          updateDragMode(evt);
          renderVisualCues(shapeLayer, shapeOptions);
          deactivateClipPathTemporarily(shapePath, shapeOptions, gd);
          dragOptions.moveFn = dragMode === "move" ? moveShape : resizeShape;
          dragOptions.altKey = evt.altKey;
        }
        function endDrag() {
          if (shouldSkipEdits(gd)) return;
          setCursor(shapePath);
          removeVisualCues(shapeLayer);
          setClipPath(shapePath, gd, shapeOptions);
          Registry.call("_guiRelayout", gd, editHelpers.getUpdateObj());
        }
        function abortDrag() {
          if (shouldSkipEdits(gd)) return;
          removeVisualCues(shapeLayer);
        }
        function moveShape(dx, dy) {
          if (shapeOptions.type === "path") {
            var noOp = function(coord) {
              return coord;
            };
            var moveX = noOp;
            var moveY = noOp;
            if (xPixelSized) {
              modifyItem("xanchor", shapeOptions.xanchor = p2x(xAnchor + dx));
            } else {
              moveX = function moveX2(x) {
                return p2x(x2p(x) + dx);
              };
              if (xa && xa.type === "date") moveX = helpers.encodeDate(moveX);
            }
            if (yPixelSized) {
              modifyItem("yanchor", shapeOptions.yanchor = p2y(yAnchor + dy));
            } else {
              moveY = function moveY2(y) {
                return p2y(y2p(y) + dy);
              };
              if (ya && ya.type === "date") moveY = helpers.encodeDate(moveY);
            }
            modifyItem("path", shapeOptions.path = movePath(pathIn, moveX, moveY));
          } else {
            if (xPixelSized) {
              modifyItem("xanchor", shapeOptions.xanchor = p2x(xAnchor + dx));
            } else {
              modifyItem("x0", shapeOptions.x0 = p2x(x0 + dx));
              modifyItem("x1", shapeOptions.x1 = p2x(x1 + dx));
            }
            if (yPixelSized) {
              modifyItem("yanchor", shapeOptions.yanchor = p2y(yAnchor + dy));
            } else {
              modifyItem("y0", shapeOptions.y0 = p2y(y0 + dy));
              modifyItem("y1", shapeOptions.y1 = p2y(y1 + dy));
            }
          }
          shapePath.attr("d", getPathString(gd, shapeOptions));
          renderVisualCues(shapeLayer, shapeOptions);
          drawLabel(gd, index, shapeOptions, shapeGroup);
        }
        function resizeShape(dx, dy) {
          if (isPath) {
            var noOp = function(coord) {
              return coord;
            };
            var moveX = noOp;
            var moveY = noOp;
            if (xPixelSized) {
              modifyItem("xanchor", shapeOptions.xanchor = p2x(xAnchor + dx));
            } else {
              moveX = function moveX2(x) {
                return p2x(x2p(x) + dx);
              };
              if (xa && xa.type === "date") moveX = helpers.encodeDate(moveX);
            }
            if (yPixelSized) {
              modifyItem("yanchor", shapeOptions.yanchor = p2y(yAnchor + dy));
            } else {
              moveY = function moveY2(y) {
                return p2y(y2p(y) + dy);
              };
              if (ya && ya.type === "date") moveY = helpers.encodeDate(moveY);
            }
            modifyItem("path", shapeOptions.path = movePath(pathIn, moveX, moveY));
          } else if (isLine) {
            if (dragMode === "resize-over-start-point") {
              var newX0 = x0 + dx;
              var newY0 = yPixelSized ? y0 - dy : y0 + dy;
              modifyItem("x0", shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));
              modifyItem("y0", shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));
            } else if (dragMode === "resize-over-end-point") {
              var newX1 = x1 + dx;
              var newY1 = yPixelSized ? y1 - dy : y1 + dy;
              modifyItem("x1", shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));
              modifyItem("y1", shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));
            }
          } else {
            var has = function(str) {
              return dragMode.indexOf(str) !== -1;
            };
            var hasN = has("n");
            var hasS = has("s");
            var hasW = has("w");
            var hasE = has("e");
            var newN = hasN ? n0 + dy : n0;
            var newS = hasS ? s0 + dy : s0;
            var newW = hasW ? w0 + dx : w0;
            var newE = hasE ? e0 + dx : e0;
            if (yPixelSized) {
              if (hasN) newN = n0 - dy;
              if (hasS) newS = s0 - dy;
            }
            if (!yPixelSized && newS - newN > MINHEIGHT || yPixelSized && newN - newS > MINHEIGHT) {
              modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));
              modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));
            }
            if (newE - newW > MINWIDTH) {
              modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));
              modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));
            }
          }
          shapePath.attr("d", getPathString(gd, shapeOptions));
          renderVisualCues(shapeLayer, shapeOptions);
          drawLabel(gd, index, shapeOptions, shapeGroup);
        }
        function renderVisualCues(shapeLayer2, shapeOptions2) {
          if (xPixelSized || yPixelSized) {
            renderAnchor();
          }
          function renderAnchor() {
            var isNotPath = shapeOptions2.type !== "path";
            var visualCues = shapeLayer2.selectAll(".visual-cue").data([0]);
            var strokeWidth = 1;
            visualCues.enter().append("path").attr({
              fill: "#fff",
              "fill-rule": "evenodd",
              stroke: "#000",
              "stroke-width": strokeWidth
            }).classed("visual-cue", true);
            var posX = x2p(
              xPixelSized ? shapeOptions2.xanchor : Lib.midRange(
                isNotPath ? [shapeOptions2.x0, shapeOptions2.x1] : helpers.extractPathCoords(shapeOptions2.path, constants.paramIsX)
              )
            );
            var posY = y2p(
              yPixelSized ? shapeOptions2.yanchor : Lib.midRange(
                isNotPath ? [shapeOptions2.y0, shapeOptions2.y1] : helpers.extractPathCoords(shapeOptions2.path, constants.paramIsY)
              )
            );
            posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);
            posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);
            if (xPixelSized && yPixelSized) {
              var crossPath = "M" + (posX - 1 - strokeWidth) + "," + (posY - 1 - strokeWidth) + "h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z";
              visualCues.attr("d", crossPath);
            } else if (xPixelSized) {
              var vBarPath = "M" + (posX - 1 - strokeWidth) + "," + (posY - 9 - strokeWidth) + "v18 h2 v-18 Z";
              visualCues.attr("d", vBarPath);
            } else {
              var hBarPath = "M" + (posX - 9 - strokeWidth) + "," + (posY - 1 - strokeWidth) + "h18 v2 h-18 Z";
              visualCues.attr("d", hBarPath);
            }
          }
        }
        function removeVisualCues(shapeLayer2) {
          shapeLayer2.selectAll(".visual-cue").remove();
        }
        function deactivateClipPathTemporarily(shapePath2, shapeOptions2, gd2) {
          var xref = shapeOptions2.xref;
          var yref = shapeOptions2.yref;
          var xa2 = Axes.getFromId(gd2, xref);
          var ya2 = Axes.getFromId(gd2, yref);
          var clipAxes = "";
          if (xref !== "paper" && !xa2.autorange) clipAxes += xref;
          if (yref !== "paper" && !ya2.autorange) clipAxes += yref;
          Drawing.setClipUrl(
            shapePath2,
            clipAxes ? "clip" + gd2._fullLayout._uid + clipAxes : null,
            gd2
          );
        }
      }
      function movePath(pathIn, moveX, moveY) {
        return pathIn.replace(constants.segmentRE, function(segment) {
          var paramNumber = 0;
          var segmentType = segment.charAt(0);
          var xParams = constants.paramIsX[segmentType];
          var yParams = constants.paramIsY[segmentType];
          var nParams = constants.numParams[segmentType];
          var paramString = segment.substr(1).replace(constants.paramRE, function(param) {
            if (paramNumber >= nParams) return param;
            if (xParams[paramNumber]) param = moveX(param);
            else if (yParams[paramNumber]) param = moveY(param);
            paramNumber++;
            return param;
          });
          return segmentType + paramString;
        });
      }
      function activateShape(gd, path) {
        if (!couldHaveActiveShape(gd)) return;
        var element = path.node();
        var id = +element.getAttribute("data-index");
        if (id >= 0) {
          if (id === gd._fullLayout._activeShapeIndex) {
            deactivateShape(gd);
            return;
          }
          gd._fullLayout._activeShapeIndex = id;
          gd._fullLayout._deactivateShape = deactivateShape;
          draw(gd);
        }
      }
      function deactivateShape(gd) {
        if (!couldHaveActiveShape(gd)) return;
        var id = gd._fullLayout._activeShapeIndex;
        if (id >= 0) {
          clearOutlineControllers(gd);
          delete gd._fullLayout._activeShapeIndex;
          draw(gd);
        }
      }
      function eraseActiveShape(gd) {
        if (!couldHaveActiveShape(gd)) return;
        clearOutlineControllers(gd);
        var id = gd._fullLayout._activeShapeIndex;
        var shapes = (gd.layout || {}).shapes || [];
        if (id < shapes.length) {
          var list = [];
          for (var q = 0; q < shapes.length; q++) {
            if (q !== id) {
              list.push(shapes[q]);
            }
          }
          delete gd._fullLayout._activeShapeIndex;
          return Registry.call("_guiRelayout", gd, {
            shapes: list
          });
        }
      }
    }
  });

  // src/components/modebar/buttons.js
  var require_buttons = __commonJS({
    "src/components/modebar/buttons.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Plots = require_plots();
      var axisIds = require_axis_ids();
      var Icons = require_ploticon();
      var eraseActiveShape = require_draw2().eraseActiveShape;
      var Lib = require_lib();
      var _ = Lib._;
      var modeBarButtons = module.exports = {};
      modeBarButtons.toImage = {
        name: "toImage",
        title: function(gd) {
          var opts = gd._context.toImageButtonOptions || {};
          var format = opts.format || "png";
          return format === "png" ? _(gd, "Download plot as a png") : (
            // legacy text
            _(gd, "Download plot")
          );
        },
        icon: Icons.camera,
        click: function(gd) {
          var toImageButtonOptions = gd._context.toImageButtonOptions;
          var opts = { format: toImageButtonOptions.format || "png" };
          Lib.notifier(_(gd, "Taking snapshot - this may take a few seconds"), "long");
          ["filename", "width", "height", "scale"].forEach(function(key) {
            if (key in toImageButtonOptions) {
              opts[key] = toImageButtonOptions[key];
            }
          });
          Registry.call("downloadImage", gd, opts).then(function(filename) {
            Lib.notifier(_(gd, "Snapshot succeeded") + " - " + filename, "long");
          }).catch(function() {
            Lib.notifier(_(gd, "Sorry, there was a problem downloading your snapshot!"), "long");
          });
        }
      };
      modeBarButtons.sendDataToCloud = {
        name: "sendDataToCloud",
        title: function(gd) {
          return _(gd, "Edit in Chart Studio");
        },
        icon: Icons.disk,
        click: function(gd) {
          Plots.sendDataToCloud(gd);
        }
      };
      modeBarButtons.editInChartStudio = {
        name: "editInChartStudio",
        title: function(gd) {
          return _(gd, "Edit in Chart Studio");
        },
        icon: Icons.pencil,
        click: function(gd) {
          Plots.sendDataToCloud(gd);
        }
      };
      modeBarButtons.zoom2d = {
        name: "zoom2d",
        _cat: "zoom",
        title: function(gd) {
          return _(gd, "Zoom");
        },
        attr: "dragmode",
        val: "zoom",
        icon: Icons.zoombox,
        click: handleCartesian
      };
      modeBarButtons.pan2d = {
        name: "pan2d",
        _cat: "pan",
        title: function(gd) {
          return _(gd, "Pan");
        },
        attr: "dragmode",
        val: "pan",
        icon: Icons.pan,
        click: handleCartesian
      };
      modeBarButtons.select2d = {
        name: "select2d",
        _cat: "select",
        title: function(gd) {
          return _(gd, "Box Select");
        },
        attr: "dragmode",
        val: "select",
        icon: Icons.selectbox,
        click: handleCartesian
      };
      modeBarButtons.lasso2d = {
        name: "lasso2d",
        _cat: "lasso",
        title: function(gd) {
          return _(gd, "Lasso Select");
        },
        attr: "dragmode",
        val: "lasso",
        icon: Icons.lasso,
        click: handleCartesian
      };
      modeBarButtons.drawclosedpath = {
        name: "drawclosedpath",
        title: function(gd) {
          return _(gd, "Draw closed freeform");
        },
        attr: "dragmode",
        val: "drawclosedpath",
        icon: Icons.drawclosedpath,
        click: handleCartesian
      };
      modeBarButtons.drawopenpath = {
        name: "drawopenpath",
        title: function(gd) {
          return _(gd, "Draw open freeform");
        },
        attr: "dragmode",
        val: "drawopenpath",
        icon: Icons.drawopenpath,
        click: handleCartesian
      };
      modeBarButtons.drawline = {
        name: "drawline",
        title: function(gd) {
          return _(gd, "Draw line");
        },
        attr: "dragmode",
        val: "drawline",
        icon: Icons.drawline,
        click: handleCartesian
      };
      modeBarButtons.drawrect = {
        name: "drawrect",
        title: function(gd) {
          return _(gd, "Draw rectangle");
        },
        attr: "dragmode",
        val: "drawrect",
        icon: Icons.drawrect,
        click: handleCartesian
      };
      modeBarButtons.drawcircle = {
        name: "drawcircle",
        title: function(gd) {
          return _(gd, "Draw circle");
        },
        attr: "dragmode",
        val: "drawcircle",
        icon: Icons.drawcircle,
        click: handleCartesian
      };
      modeBarButtons.eraseshape = {
        name: "eraseshape",
        title: function(gd) {
          return _(gd, "Erase active shape");
        },
        icon: Icons.eraseshape,
        click: eraseActiveShape
      };
      modeBarButtons.zoomIn2d = {
        name: "zoomIn2d",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleCartesian
      };
      modeBarButtons.zoomOut2d = {
        name: "zoomOut2d",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleCartesian
      };
      modeBarButtons.autoScale2d = {
        name: "autoScale2d",
        _cat: "autoscale",
        title: function(gd) {
          return _(gd, "Autoscale");
        },
        attr: "zoom",
        val: "auto",
        icon: Icons.autoscale,
        click: handleCartesian
      };
      modeBarButtons.resetScale2d = {
        name: "resetScale2d",
        _cat: "resetscale",
        title: function(gd) {
          return _(gd, "Reset axes");
        },
        attr: "zoom",
        val: "reset",
        icon: Icons.home,
        click: handleCartesian
      };
      modeBarButtons.hoverClosestCartesian = {
        name: "hoverClosestCartesian",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Show closest data on hover");
        },
        attr: "hovermode",
        val: "closest",
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: handleCartesian
      };
      modeBarButtons.hoverCompareCartesian = {
        name: "hoverCompareCartesian",
        _cat: "hoverCompare",
        title: function(gd) {
          return _(gd, "Compare data on hover");
        },
        attr: "hovermode",
        val: function(gd) {
          return gd._fullLayout._isHoriz ? "y" : "x";
        },
        icon: Icons.tooltip_compare,
        gravity: "ne",
        click: handleCartesian
      };
      function handleCartesian(gd, ev) {
        var button = ev.currentTarget;
        var astr = button.getAttribute("data-attr");
        var val = button.getAttribute("data-val") || true;
        var fullLayout = gd._fullLayout;
        var aobj = {};
        var axList = axisIds.list(gd, null, true);
        var allSpikesEnabled = fullLayout._cartesianSpikesEnabled;
        var ax, i;
        if (astr === "zoom") {
          var mag = val === "in" ? 0.5 : 2;
          var r0 = (1 + mag) / 2;
          var r1 = (1 - mag) / 2;
          var axName;
          for (i = 0; i < axList.length; i++) {
            ax = axList[i];
            if (!ax.fixedrange) {
              axName = ax._name;
              if (val === "auto") {
                aobj[axName + ".autorange"] = true;
              } else if (val === "reset") {
                if (ax._rangeInitial0 === void 0 && ax._rangeInitial1 === void 0) {
                  aobj[axName + ".autorange"] = true;
                } else if (ax._rangeInitial0 === void 0) {
                  aobj[axName + ".autorange"] = ax._autorangeInitial;
                  aobj[axName + ".range"] = [null, ax._rangeInitial1];
                } else if (ax._rangeInitial1 === void 0) {
                  aobj[axName + ".range"] = [ax._rangeInitial0, null];
                  aobj[axName + ".autorange"] = ax._autorangeInitial;
                } else {
                  aobj[axName + ".range"] = [ax._rangeInitial0, ax._rangeInitial1];
                }
                if (ax._showSpikeInitial !== void 0) {
                  aobj[axName + ".showspikes"] = ax._showSpikeInitial;
                  if (allSpikesEnabled === "on" && !ax._showSpikeInitial) {
                    allSpikesEnabled = "off";
                  }
                }
              } else {
                var rangeNow = [
                  ax.r2l(ax.range[0]),
                  ax.r2l(ax.range[1])
                ];
                var rangeNew = [
                  r0 * rangeNow[0] + r1 * rangeNow[1],
                  r0 * rangeNow[1] + r1 * rangeNow[0]
                ];
                aobj[axName + ".range[0]"] = ax.l2r(rangeNew[0]);
                aobj[axName + ".range[1]"] = ax.l2r(rangeNew[1]);
              }
            }
          }
        } else {
          if (astr === "hovermode" && (val === "x" || val === "y")) {
            val = fullLayout._isHoriz ? "y" : "x";
            button.setAttribute("data-val", val);
          }
          aobj[astr] = val;
        }
        fullLayout._cartesianSpikesEnabled = allSpikesEnabled;
        Registry.call("_guiRelayout", gd, aobj);
      }
      modeBarButtons.zoom3d = {
        name: "zoom3d",
        _cat: "zoom",
        title: function(gd) {
          return _(gd, "Zoom");
        },
        attr: "scene.dragmode",
        val: "zoom",
        icon: Icons.zoombox,
        click: handleDrag3d
      };
      modeBarButtons.pan3d = {
        name: "pan3d",
        _cat: "pan",
        title: function(gd) {
          return _(gd, "Pan");
        },
        attr: "scene.dragmode",
        val: "pan",
        icon: Icons.pan,
        click: handleDrag3d
      };
      modeBarButtons.orbitRotation = {
        name: "orbitRotation",
        title: function(gd) {
          return _(gd, "Orbital rotation");
        },
        attr: "scene.dragmode",
        val: "orbit",
        icon: Icons["3d_rotate"],
        click: handleDrag3d
      };
      modeBarButtons.tableRotation = {
        name: "tableRotation",
        title: function(gd) {
          return _(gd, "Turntable rotation");
        },
        attr: "scene.dragmode",
        val: "turntable",
        icon: Icons["z-axis"],
        click: handleDrag3d
      };
      function handleDrag3d(gd, ev) {
        var button = ev.currentTarget;
        var attr = button.getAttribute("data-attr");
        var val = button.getAttribute("data-val") || true;
        var sceneIds = gd._fullLayout._subplots.gl3d || [];
        var layoutUpdate = {};
        var parts = attr.split(".");
        for (var i = 0; i < sceneIds.length; i++) {
          layoutUpdate[sceneIds[i] + "." + parts[1]] = val;
        }
        var val2d = val === "pan" ? val : "zoom";
        layoutUpdate.dragmode = val2d;
        Registry.call("_guiRelayout", gd, layoutUpdate);
      }
      modeBarButtons.resetCameraDefault3d = {
        name: "resetCameraDefault3d",
        _cat: "resetCameraDefault",
        title: function(gd) {
          return _(gd, "Reset camera to default");
        },
        attr: "resetDefault",
        icon: Icons.home,
        click: handleCamera3d
      };
      modeBarButtons.resetCameraLastSave3d = {
        name: "resetCameraLastSave3d",
        _cat: "resetCameraLastSave",
        title: function(gd) {
          return _(gd, "Reset camera to last save");
        },
        attr: "resetLastSave",
        icon: Icons.movie,
        click: handleCamera3d
      };
      function handleCamera3d(gd, ev) {
        var button = ev.currentTarget;
        var attr = button.getAttribute("data-attr");
        var resetLastSave = attr === "resetLastSave";
        var resetDefault = attr === "resetDefault";
        var fullLayout = gd._fullLayout;
        var sceneIds = fullLayout._subplots.gl3d || [];
        var aobj = {};
        for (var i = 0; i < sceneIds.length; i++) {
          var sceneId = sceneIds[i];
          var camera = sceneId + ".camera";
          var aspectratio = sceneId + ".aspectratio";
          var aspectmode = sceneId + ".aspectmode";
          var scene = fullLayout[sceneId]._scene;
          var didUpdate;
          if (resetLastSave) {
            aobj[camera + ".up"] = scene.viewInitial.up;
            aobj[camera + ".eye"] = scene.viewInitial.eye;
            aobj[camera + ".center"] = scene.viewInitial.center;
            didUpdate = true;
          } else if (resetDefault) {
            aobj[camera + ".up"] = null;
            aobj[camera + ".eye"] = null;
            aobj[camera + ".center"] = null;
            didUpdate = true;
          }
          if (didUpdate) {
            aobj[aspectratio + ".x"] = scene.viewInitial.aspectratio.x;
            aobj[aspectratio + ".y"] = scene.viewInitial.aspectratio.y;
            aobj[aspectratio + ".z"] = scene.viewInitial.aspectratio.z;
            aobj[aspectmode] = scene.viewInitial.aspectmode;
          }
        }
        Registry.call("_guiRelayout", gd, aobj);
      }
      modeBarButtons.hoverClosest3d = {
        name: "hoverClosest3d",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: null,
        toggle: true,
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: handleHover3d
      };
      function getNextHover3d(gd, ev) {
        var button = ev.currentTarget;
        var val = button._previousVal;
        var fullLayout = gd._fullLayout;
        var sceneIds = fullLayout._subplots.gl3d || [];
        var axes = ["xaxis", "yaxis", "zaxis"];
        var currentSpikes = {};
        var layoutUpdate = {};
        if (val) {
          layoutUpdate = val;
          button._previousVal = null;
        } else {
          for (var i = 0; i < sceneIds.length; i++) {
            var sceneId = sceneIds[i];
            var sceneLayout = fullLayout[sceneId];
            var hovermodeAStr = sceneId + ".hovermode";
            currentSpikes[hovermodeAStr] = sceneLayout.hovermode;
            layoutUpdate[hovermodeAStr] = false;
            for (var j = 0; j < 3; j++) {
              var axis = axes[j];
              var spikeAStr = sceneId + "." + axis + ".showspikes";
              layoutUpdate[spikeAStr] = false;
              currentSpikes[spikeAStr] = sceneLayout[axis].showspikes;
            }
          }
          button._previousVal = currentSpikes;
        }
        return layoutUpdate;
      }
      function handleHover3d(gd, ev) {
        var layoutUpdate = getNextHover3d(gd, ev);
        Registry.call("_guiRelayout", gd, layoutUpdate);
      }
      modeBarButtons.zoomInGeo = {
        name: "zoomInGeo",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleGeo
      };
      modeBarButtons.zoomOutGeo = {
        name: "zoomOutGeo",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleGeo
      };
      modeBarButtons.resetGeo = {
        name: "resetGeo",
        _cat: "reset",
        title: function(gd) {
          return _(gd, "Reset");
        },
        attr: "reset",
        val: null,
        icon: Icons.autoscale,
        click: handleGeo
      };
      modeBarButtons.hoverClosestGeo = {
        name: "hoverClosestGeo",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: null,
        toggle: true,
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: toggleHover
      };
      function handleGeo(gd, ev) {
        var button = ev.currentTarget;
        var attr = button.getAttribute("data-attr");
        var val = button.getAttribute("data-val") || true;
        var fullLayout = gd._fullLayout;
        var geoIds = fullLayout._subplots.geo || [];
        for (var i = 0; i < geoIds.length; i++) {
          var id = geoIds[i];
          var geoLayout = fullLayout[id];
          if (attr === "zoom") {
            var scale = geoLayout.projection.scale;
            var newScale = val === "in" ? 2 * scale : 0.5 * scale;
            Registry.call("_guiRelayout", gd, id + ".projection.scale", newScale);
          }
        }
        if (attr === "reset") {
          resetView(gd, "geo");
        }
      }
      modeBarButtons.hoverClosestPie = {
        name: "hoverClosestPie",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: "closest",
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: toggleHover
      };
      function getNextHover(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout.hovermode) return false;
        if (fullLayout._has("cartesian")) {
          return fullLayout._isHoriz ? "y" : "x";
        }
        return "closest";
      }
      function toggleHover(gd) {
        var newHover = getNextHover(gd);
        Registry.call("_guiRelayout", gd, "hovermode", newHover);
      }
      modeBarButtons.resetViewSankey = {
        name: "resetSankeyGroup",
        title: function(gd) {
          return _(gd, "Reset view");
        },
        icon: Icons.home,
        click: function(gd) {
          var aObj = {
            "node.groups": [],
            "node.x": [],
            "node.y": []
          };
          for (var i = 0; i < gd._fullData.length; i++) {
            var viewInitial = gd._fullData[i]._viewInitial;
            aObj["node.groups"].push(viewInitial.node.groups.slice());
            aObj["node.x"].push(viewInitial.node.x.slice());
            aObj["node.y"].push(viewInitial.node.y.slice());
          }
          Registry.call("restyle", gd, aObj);
        }
      };
      modeBarButtons.toggleHover = {
        name: "toggleHover",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: null,
        toggle: true,
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: function(gd, ev) {
          var layoutUpdate = getNextHover3d(gd, ev);
          layoutUpdate.hovermode = getNextHover(gd);
          Registry.call("_guiRelayout", gd, layoutUpdate);
        }
      };
      modeBarButtons.resetViews = {
        name: "resetViews",
        title: function(gd) {
          return _(gd, "Reset views");
        },
        icon: Icons.home,
        click: function(gd, ev) {
          var button = ev.currentTarget;
          button.setAttribute("data-attr", "zoom");
          button.setAttribute("data-val", "reset");
          handleCartesian(gd, ev);
          button.setAttribute("data-attr", "resetLastSave");
          handleCamera3d(gd, ev);
          resetView(gd, "geo");
          resetView(gd, "mapbox");
          resetView(gd, "map");
        }
      };
      modeBarButtons.toggleSpikelines = {
        name: "toggleSpikelines",
        title: function(gd) {
          return _(gd, "Toggle Spike Lines");
        },
        icon: Icons.spikeline,
        attr: "_cartesianSpikesEnabled",
        val: "on",
        click: function(gd) {
          var fullLayout = gd._fullLayout;
          var allSpikesEnabled = fullLayout._cartesianSpikesEnabled;
          fullLayout._cartesianSpikesEnabled = allSpikesEnabled === "on" ? "off" : "on";
          Registry.call("_guiRelayout", gd, setSpikelineVisibility(gd));
        }
      };
      function setSpikelineVisibility(gd) {
        var fullLayout = gd._fullLayout;
        var areSpikesOn = fullLayout._cartesianSpikesEnabled === "on";
        var axList = axisIds.list(gd, null, true);
        var aobj = {};
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          aobj[ax._name + ".showspikes"] = areSpikesOn ? true : ax._showSpikeInitial;
        }
        return aobj;
      }
      modeBarButtons.resetViewMapbox = {
        name: "resetViewMapbox",
        _cat: "resetView",
        title: function(gd) {
          return _(gd, "Reset view");
        },
        attr: "reset",
        icon: Icons.home,
        click: function(gd) {
          resetView(gd, "mapbox");
        }
      };
      modeBarButtons.resetViewMap = {
        name: "resetViewMap",
        _cat: "resetView",
        title: function(gd) {
          return _(gd, "Reset view");
        },
        attr: "reset",
        icon: Icons.home,
        click: function(gd) {
          resetView(gd, "map");
        }
      };
      modeBarButtons.zoomInMapbox = {
        name: "zoomInMapbox",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleMapboxZoom
      };
      modeBarButtons.zoomInMap = {
        name: "zoomInMap",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleMapZoom
      };
      modeBarButtons.zoomOutMapbox = {
        name: "zoomOutMapbox",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleMapboxZoom
      };
      modeBarButtons.zoomOutMap = {
        name: "zoomOutMap",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleMapZoom
      };
      function handleMapboxZoom(gd, ev) {
        _handleMapZoom(gd, ev, "mapbox");
      }
      function handleMapZoom(gd, ev) {
        _handleMapZoom(gd, ev, "map");
      }
      function _handleMapZoom(gd, ev, mapType) {
        var button = ev.currentTarget;
        var val = button.getAttribute("data-val");
        var fullLayout = gd._fullLayout;
        var subplotIds = fullLayout._subplots[mapType] || [];
        var scalar = 1.05;
        var aObj = {};
        for (var i = 0; i < subplotIds.length; i++) {
          var id = subplotIds[i];
          var current = fullLayout[id].zoom;
          var next = val === "in" ? scalar * current : current / scalar;
          aObj[id + ".zoom"] = next;
        }
        Registry.call("_guiRelayout", gd, aObj);
      }
      function resetView(gd, subplotType) {
        var fullLayout = gd._fullLayout;
        var subplotIds = fullLayout._subplots[subplotType] || [];
        var aObj = {};
        for (var i = 0; i < subplotIds.length; i++) {
          var id = subplotIds[i];
          var subplotObj = fullLayout[id]._subplot;
          var viewInitial = subplotObj.viewInitial;
          var viewKeys = Object.keys(viewInitial);
          for (var j = 0; j < viewKeys.length; j++) {
            var key = viewKeys[j];
            aObj[id + "." + key] = viewInitial[key];
          }
        }
        Registry.call("_guiRelayout", gd, aObj);
      }
    }
  });

  // src/components/modebar/constants.js
  var require_constants6 = __commonJS({
    "src/components/modebar/constants.js"(exports, module) {
      "use strict";
      var modeBarButtons = require_buttons();
      var buttonList = Object.keys(modeBarButtons);
      var DRAW_MODES = [
        "drawline",
        "drawopenpath",
        "drawclosedpath",
        "drawcircle",
        "drawrect",
        "eraseshape"
      ];
      var backButtons = [
        "v1hovermode",
        "hoverclosest",
        "hovercompare",
        "togglehover",
        "togglespikelines"
      ].concat(DRAW_MODES);
      var foreButtons = [];
      var addToForeButtons = function(b) {
        if (backButtons.indexOf(b._cat || b.name) !== -1) return;
        var name = b.name;
        var _cat = (b._cat || b.name).toLowerCase();
        if (foreButtons.indexOf(name) === -1) foreButtons.push(name);
        if (foreButtons.indexOf(_cat) === -1) foreButtons.push(_cat);
      };
      buttonList.forEach(function(k) {
        addToForeButtons(modeBarButtons[k]);
      });
      foreButtons.sort();
      module.exports = {
        DRAW_MODES,
        backButtons,
        foreButtons
      };
    }
  });

  // src/components/modebar/attributes.js
  var require_attributes10 = __commonJS({
    "src/components/modebar/attributes.js"(exports, module) {
      "use strict";
      var constants = require_constants6();
      module.exports = {
        editType: "modebar",
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          dflt: "h",
          editType: "modebar"
        },
        bgcolor: {
          valType: "color",
          editType: "modebar"
        },
        color: {
          valType: "color",
          editType: "modebar"
        },
        activecolor: {
          valType: "color",
          editType: "modebar"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        add: {
          valType: "string",
          arrayOk: true,
          dflt: "",
          editType: "modebar"
        },
        remove: {
          valType: "string",
          arrayOk: true,
          dflt: "",
          editType: "modebar"
        }
      };
    }
  });

  // src/components/modebar/defaults.js
  var require_defaults5 = __commonJS({
    "src/components/modebar/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var Template = require_plot_template();
      var attributes = require_attributes10();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        var containerIn = layoutIn.modebar || {};
        var containerOut = Template.newContainer(layoutOut, "modebar");
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        coerce("orientation");
        coerce("bgcolor", Color.addOpacity(layoutOut.paper_bgcolor, 0.5));
        var defaultColor = Color.contrast(Color.rgb(layoutOut.modebar.bgcolor));
        coerce("color", Color.addOpacity(defaultColor, 0.3));
        coerce("activecolor", Color.addOpacity(defaultColor, 0.7));
        coerce("uirevision", layoutOut.uirevision);
        coerce("add");
        coerce("remove");
      };
    }
  });

  // src/components/modebar/modebar.js
  var require_modebar = __commonJS({
    "src/components/modebar/modebar.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Icons = require_ploticon();
      var version = require_version().version;
      var Parser = new DOMParser();
      function ModeBar(opts) {
        this.container = opts.container;
        this.element = document.createElement("div");
        this.update(opts.graphInfo, opts.buttons);
        this.container.appendChild(this.element);
      }
      var proto = ModeBar.prototype;
      proto.update = function(graphInfo, buttons) {
        this.graphInfo = graphInfo;
        var context = this.graphInfo._context;
        var fullLayout = this.graphInfo._fullLayout;
        var modeBarId = "modebar-" + fullLayout._uid;
        this.element.setAttribute("id", modeBarId);
        this._uid = modeBarId;
        this.element.className = "modebar";
        if (context.displayModeBar === "hover") this.element.className += " modebar--hover ease-bg";
        if (fullLayout.modebar.orientation === "v") {
          this.element.className += " vertical";
          buttons = buttons.reverse();
        }
        var style = fullLayout.modebar;
        var groupSelector = "#" + modeBarId + " .modebar-group";
        document.querySelectorAll(groupSelector).forEach(function(group) {
          group.style.backgroundColor = style.bgcolor;
        });
        var needsNewButtons = !this.hasButtons(buttons);
        var needsNewLogo = this.hasLogo !== context.displaylogo;
        var needsNewLocale = this.locale !== context.locale;
        this.locale = context.locale;
        if (needsNewButtons || needsNewLogo || needsNewLocale) {
          this.removeAllButtons();
          this.updateButtons(buttons);
          if (context.watermark || context.displaylogo) {
            var logoGroup = this.getLogo();
            if (context.watermark) {
              logoGroup.className = logoGroup.className + " watermark";
            }
            if (fullLayout.modebar.orientation === "v") {
              this.element.insertBefore(logoGroup, this.element.childNodes[0]);
            } else {
              this.element.appendChild(logoGroup);
            }
            this.hasLogo = true;
          }
        }
        this.updateActiveButton();
        Lib.setStyleOnHover("#" + modeBarId + " .modebar-btn", ".active", ".icon path", "fill: " + style.activecolor, "fill: " + style.color, this.element);
      };
      proto.updateButtons = function(buttons) {
        var _this = this;
        this.buttons = buttons;
        this.buttonElements = [];
        this.buttonsNames = [];
        this.buttons.forEach(function(buttonGroup) {
          var group = _this.createGroup();
          buttonGroup.forEach(function(buttonConfig) {
            var buttonName = buttonConfig.name;
            if (!buttonName) {
              throw new Error("must provide button 'name' in button config");
            }
            if (_this.buttonsNames.indexOf(buttonName) !== -1) {
              throw new Error("button name '" + buttonName + "' is taken");
            }
            _this.buttonsNames.push(buttonName);
            var button = _this.createButton(buttonConfig);
            _this.buttonElements.push(button);
            group.appendChild(button);
          });
          _this.element.appendChild(group);
        });
      };
      proto.createGroup = function() {
        var group = document.createElement("div");
        group.className = "modebar-group";
        var style = this.graphInfo._fullLayout.modebar;
        group.style.backgroundColor = style.bgcolor;
        return group;
      };
      proto.createButton = function(config) {
        var _this = this;
        var button = document.createElement("a");
        button.setAttribute("rel", "tooltip");
        button.className = "modebar-btn";
        var title = config.title;
        if (title === void 0) title = config.name;
        else if (typeof title === "function") title = title(this.graphInfo);
        if (title || title === 0) button.setAttribute("data-title", title);
        if (config.attr !== void 0) button.setAttribute("data-attr", config.attr);
        var val = config.val;
        if (val !== void 0) {
          if (typeof val === "function") val = val(this.graphInfo);
          button.setAttribute("data-val", val);
        }
        var click = config.click;
        if (typeof click !== "function") {
          throw new Error("must provide button 'click' function in button config");
        } else {
          button.addEventListener("click", function(ev) {
            config.click(_this.graphInfo, ev);
            _this.updateActiveButton(ev.currentTarget);
          });
        }
        button.setAttribute("data-toggle", config.toggle || false);
        if (config.toggle) d3.select(button).classed("active", true);
        var icon = config.icon;
        if (typeof icon === "function") {
          button.appendChild(icon());
        } else {
          button.appendChild(this.createIcon(icon || Icons.question));
        }
        button.setAttribute("data-gravity", config.gravity || "n");
        return button;
      };
      proto.createIcon = function(thisIcon) {
        var iconHeight = isNumeric(thisIcon.height) ? Number(thisIcon.height) : thisIcon.ascent - thisIcon.descent;
        var svgNS = "http://www.w3.org/2000/svg";
        var icon;
        if (thisIcon.path) {
          icon = document.createElementNS(svgNS, "svg");
          icon.setAttribute("viewBox", [0, 0, thisIcon.width, iconHeight].join(" "));
          icon.setAttribute("class", "icon");
          var path = document.createElementNS(svgNS, "path");
          path.setAttribute("d", thisIcon.path);
          if (thisIcon.transform) {
            path.setAttribute("transform", thisIcon.transform);
          } else if (thisIcon.ascent !== void 0) {
            path.setAttribute("transform", "matrix(1 0 0 -1 0 " + thisIcon.ascent + ")");
          }
          icon.appendChild(path);
        }
        if (thisIcon.svg) {
          var svgDoc = Parser.parseFromString(thisIcon.svg, "application/xml");
          icon = svgDoc.childNodes[0];
        }
        icon.setAttribute("height", "1em");
        icon.setAttribute("width", "1em");
        return icon;
      };
      proto.updateActiveButton = function(buttonClicked) {
        var fullLayout = this.graphInfo._fullLayout;
        var dataAttrClicked = buttonClicked !== void 0 ? buttonClicked.getAttribute("data-attr") : null;
        this.buttonElements.forEach(function(button) {
          var thisval = button.getAttribute("data-val") || true;
          var dataAttr = button.getAttribute("data-attr");
          var isToggleButton = button.getAttribute("data-toggle") === "true";
          var button3 = d3.select(button);
          var updateButtonStyle = function(button2, isActive2) {
            var style = fullLayout.modebar;
            var childEl = button2.querySelector(".icon path");
            if (childEl) {
              if (isActive2 || button2.matches(":hover")) {
                childEl.style.fill = style.activecolor;
              } else {
                childEl.style.fill = style.color;
              }
            }
          };
          if (isToggleButton) {
            if (dataAttr === dataAttrClicked) {
              var isActive = !button3.classed("active");
              button3.classed("active", isActive);
              updateButtonStyle(button, isActive);
            }
          } else {
            var val = dataAttr === null ? dataAttr : Lib.nestedProperty(fullLayout, dataAttr).get();
            button3.classed("active", val === thisval);
            updateButtonStyle(button, val === thisval);
          }
        });
      };
      proto.hasButtons = function(buttons) {
        var currentButtons = this.buttons;
        if (!currentButtons) return false;
        if (buttons.length !== currentButtons.length) return false;
        for (var i = 0; i < buttons.length; ++i) {
          if (buttons[i].length !== currentButtons[i].length) return false;
          for (var j = 0; j < buttons[i].length; j++) {
            if (buttons[i][j].name !== currentButtons[i][j].name) return false;
          }
        }
        return true;
      };
      function jsVersion(str) {
        return str + " (v" + version + ")";
      }
      proto.getLogo = function() {
        var group = this.createGroup();
        var a = document.createElement("a");
        a.href = "https://plotly.com/";
        a.target = "_blank";
        a.setAttribute("data-title", jsVersion(Lib._(this.graphInfo, "Produced with Plotly.js")));
        a.className = "modebar-btn plotlyjsicon modebar-btn--logo";
        a.appendChild(this.createIcon(Icons.newplotlylogo));
        group.appendChild(a);
        return group;
      };
      proto.removeAllButtons = function() {
        while (this.element.firstChild) {
          this.element.removeChild(this.element.firstChild);
        }
        this.hasLogo = false;
      };
      proto.destroy = function() {
        Lib.removeElement(this.container.querySelector(".modebar"));
      };
      function createModeBar(gd, buttons) {
        var fullLayout = gd._fullLayout;
        var modeBar = new ModeBar({
          graphInfo: gd,
          container: fullLayout._modebardiv.node(),
          buttons
        });
        if (fullLayout._privateplot) {
          d3.select(modeBar.element).append("span").classed("badge-private float--left", true).text("PRIVATE");
        }
        return modeBar;
      }
      module.exports = createModeBar;
    }
  });

  // src/components/modebar/manage.js
  var require_manage = __commonJS({
    "src/components/modebar/manage.js"(exports, module) {
      "use strict";
      var axisIds = require_axis_ids();
      var scatterSubTypes = require_subtypes();
      var Registry = require_registry();
      var isUnifiedHover = require_helpers2().isUnifiedHover;
      var createModeBar = require_modebar();
      var modeBarButtons = require_buttons();
      var DRAW_MODES = require_constants6().DRAW_MODES;
      var extendDeep = require_lib().extendDeep;
      module.exports = function manageModeBar(gd) {
        var fullLayout = gd._fullLayout;
        var context = gd._context;
        var modeBar = fullLayout._modeBar;
        if (!context.displayModeBar && !context.watermark) {
          if (modeBar) {
            modeBar.destroy();
            delete fullLayout._modeBar;
          }
          return;
        }
        if (!Array.isArray(context.modeBarButtonsToRemove)) {
          throw new Error([
            "*modeBarButtonsToRemove* configuration options",
            "must be an array."
          ].join(" "));
        }
        if (!Array.isArray(context.modeBarButtonsToAdd)) {
          throw new Error([
            "*modeBarButtonsToAdd* configuration options",
            "must be an array."
          ].join(" "));
        }
        var customButtons = context.modeBarButtons;
        var buttonGroups;
        if (Array.isArray(customButtons) && customButtons.length) {
          buttonGroups = fillCustomButton(customButtons);
        } else if (!context.displayModeBar && context.watermark) {
          buttonGroups = [];
        } else {
          buttonGroups = getButtonGroups(gd);
        }
        if (modeBar) modeBar.update(gd, buttonGroups);
        else fullLayout._modeBar = createModeBar(gd, buttonGroups);
      };
      function getButtonGroups(gd) {
        var fullLayout = gd._fullLayout;
        var fullData = gd._fullData;
        var context = gd._context;
        function match(name, B) {
          if (typeof B === "string") {
            if (B.toLowerCase() === name.toLowerCase()) return true;
          } else {
            var v0 = B.name;
            var v1 = B._cat || B.name;
            if (v0 === name || v1 === name.toLowerCase()) return true;
          }
          return false;
        }
        var layoutAdd = fullLayout.modebar.add;
        if (typeof layoutAdd === "string") layoutAdd = [layoutAdd];
        var layoutRemove = fullLayout.modebar.remove;
        if (typeof layoutRemove === "string") layoutRemove = [layoutRemove];
        var buttonsToAdd = context.modeBarButtonsToAdd.concat(
          layoutAdd.filter(function(e) {
            for (var i2 = 0; i2 < context.modeBarButtonsToRemove.length; i2++) {
              if (match(e, context.modeBarButtonsToRemove[i2])) return false;
            }
            return true;
          })
        );
        var buttonsToRemove = context.modeBarButtonsToRemove.concat(
          layoutRemove.filter(function(e) {
            for (var i2 = 0; i2 < context.modeBarButtonsToAdd.length; i2++) {
              if (match(e, context.modeBarButtonsToAdd[i2])) return false;
            }
            return true;
          })
        );
        var hasCartesian = fullLayout._has("cartesian");
        var hasGL3D = fullLayout._has("gl3d");
        var hasGeo = fullLayout._has("geo");
        var hasPie = fullLayout._has("pie");
        var hasFunnelarea = fullLayout._has("funnelarea");
        var hasTernary = fullLayout._has("ternary");
        var hasMapbox = fullLayout._has("mapbox");
        var hasMap = fullLayout._has("map");
        var hasPolar = fullLayout._has("polar");
        var hasSmith = fullLayout._has("smith");
        var hasSankey = fullLayout._has("sankey");
        var allAxesFixed = areAllAxesFixed(fullLayout);
        var hasUnifiedHoverLabel = isUnifiedHover(fullLayout.hovermode);
        var groups = [];
        function addGroup(newGroup) {
          if (!newGroup.length) return;
          var out = [];
          for (var i2 = 0; i2 < newGroup.length; i2++) {
            var name = newGroup[i2];
            var B = modeBarButtons[name];
            var v0 = B.name.toLowerCase();
            var v1 = (B._cat || B.name).toLowerCase();
            var found = false;
            for (var q = 0; q < buttonsToRemove.length; q++) {
              var t = buttonsToRemove[q].toLowerCase();
              if (t === v0 || t === v1) {
                found = true;
                break;
              }
            }
            if (found) continue;
            out.push(modeBarButtons[name]);
          }
          groups.push(out);
        }
        var commonGroup = ["toImage"];
        if (context.showEditInChartStudio) commonGroup.push("editInChartStudio");
        else if (context.showSendToCloud) commonGroup.push("sendDataToCloud");
        addGroup(commonGroup);
        var zoomGroup = [];
        var hoverGroup = [];
        var resetGroup = [];
        var dragModeGroup = [];
        if ((hasCartesian || hasPie || hasFunnelarea || hasTernary) + hasGeo + hasGL3D + hasMapbox + hasMap + hasPolar + hasSmith > 1) {
          hoverGroup = ["toggleHover"];
          resetGroup = ["resetViews"];
        } else if (hasGeo) {
          zoomGroup = ["zoomInGeo", "zoomOutGeo"];
          hoverGroup = ["hoverClosestGeo"];
          resetGroup = ["resetGeo"];
        } else if (hasGL3D) {
          hoverGroup = ["hoverClosest3d"];
          resetGroup = ["resetCameraDefault3d", "resetCameraLastSave3d"];
        } else if (hasMapbox) {
          zoomGroup = ["zoomInMapbox", "zoomOutMapbox"];
          hoverGroup = ["toggleHover"];
          resetGroup = ["resetViewMapbox"];
        } else if (hasMap) {
          zoomGroup = ["zoomInMap", "zoomOutMap"];
          hoverGroup = ["toggleHover"];
          resetGroup = ["resetViewMap"];
        } else if (hasPie) {
          hoverGroup = ["hoverClosestPie"];
        } else if (hasSankey) {
          hoverGroup = ["hoverClosestCartesian", "hoverCompareCartesian"];
          resetGroup = ["resetViewSankey"];
        } else {
          hoverGroup = ["toggleHover"];
        }
        if (hasCartesian) {
          hoverGroup.push("toggleSpikelines", "hoverClosestCartesian", "hoverCompareCartesian");
        }
        if (hasNoHover(fullData) || hasUnifiedHoverLabel) {
          hoverGroup = [];
        }
        if (hasCartesian && !allAxesFixed) {
          zoomGroup = ["zoomIn2d", "zoomOut2d", "autoScale2d"];
          if (resetGroup[0] !== "resetViews") resetGroup = ["resetScale2d"];
        }
        if (hasGL3D) {
          dragModeGroup = ["zoom3d", "pan3d", "orbitRotation", "tableRotation"];
        } else if (hasCartesian && !allAxesFixed || hasTernary) {
          dragModeGroup = ["zoom2d", "pan2d"];
        } else if (hasMapbox || hasMap || hasGeo) {
          dragModeGroup = ["pan2d"];
        } else if (hasPolar) {
          dragModeGroup = ["zoom2d"];
        }
        if (isSelectable(fullData)) {
          dragModeGroup.push("select2d", "lasso2d");
        }
        var enabledHoverGroup = [];
        var enableHover = function(a) {
          if (enabledHoverGroup.indexOf(a) !== -1) return;
          if (hoverGroup.indexOf(a) !== -1) {
            enabledHoverGroup.push(a);
          }
        };
        if (Array.isArray(buttonsToAdd)) {
          var newList = [];
          for (var i = 0; i < buttonsToAdd.length; i++) {
            var b = buttonsToAdd[i];
            if (typeof b === "string") {
              b = b.toLowerCase();
              if (DRAW_MODES.indexOf(b) !== -1) {
                if (fullLayout._has("mapbox") || fullLayout._has("map") || // draw shapes in paper coordinate (could be improved in future to support data coordinate, when there is no pitch)
                fullLayout._has("cartesian")) {
                  dragModeGroup.push(b);
                }
              } else if (b === "togglespikelines") {
                enableHover("toggleSpikelines");
              } else if (b === "togglehover") {
                enableHover("toggleHover");
              } else if (b === "hovercompare") {
                enableHover("hoverCompareCartesian");
              } else if (b === "hoverclosest") {
                enableHover("hoverClosestCartesian");
                enableHover("hoverClosestGeo");
                enableHover("hoverClosest3d");
                enableHover("hoverClosestPie");
              } else if (b === "v1hovermode") {
                enableHover("hoverClosestCartesian");
                enableHover("hoverCompareCartesian");
                enableHover("hoverClosestGeo");
                enableHover("hoverClosest3d");
                enableHover("hoverClosestPie");
              }
            } else newList.push(b);
          }
          buttonsToAdd = newList;
        }
        addGroup(dragModeGroup);
        addGroup(zoomGroup.concat(resetGroup));
        addGroup(enabledHoverGroup);
        return appendButtonsToGroups(groups, buttonsToAdd);
      }
      function areAllAxesFixed(fullLayout) {
        var axList = axisIds.list({ _fullLayout: fullLayout }, null, true);
        for (var i = 0; i < axList.length; i++) {
          if (!axList[i].fixedrange) {
            return false;
          }
        }
        return true;
      }
      function isSelectable(fullData) {
        var selectable = false;
        for (var i = 0; i < fullData.length; i++) {
          if (selectable) break;
          var trace = fullData[i];
          if (!trace._module || !trace._module.selectPoints) continue;
          if (Registry.traceIs(trace, "scatter-like")) {
            if (scatterSubTypes.hasMarkers(trace) || scatterSubTypes.hasText(trace)) {
              selectable = true;
            }
          } else if (Registry.traceIs(trace, "box-violin")) {
            if (trace.boxpoints === "all" || trace.points === "all") {
              selectable = true;
            }
          } else {
            selectable = true;
          }
        }
        return selectable;
      }
      function hasNoHover(fullData) {
        for (var i = 0; i < fullData.length; i++) {
          if (!Registry.traceIs(fullData[i], "noHover")) return false;
        }
        return true;
      }
      function appendButtonsToGroups(groups, buttons) {
        if (buttons.length) {
          if (Array.isArray(buttons[0])) {
            for (var i = 0; i < buttons.length; i++) {
              groups.push(buttons[i]);
            }
          } else groups.push(buttons);
        }
        return groups;
      }
      function fillCustomButton(originalModeBarButtons) {
        var customButtons = extendDeep([], originalModeBarButtons);
        for (var i = 0; i < customButtons.length; i++) {
          var buttonGroup = customButtons[i];
          for (var j = 0; j < buttonGroup.length; j++) {
            var button = buttonGroup[j];
            if (typeof button === "string") {
              if (modeBarButtons[button] !== void 0) {
                customButtons[i][j] = modeBarButtons[button];
              } else {
                throw new Error([
                  "*modeBarButtons* configuration options",
                  "invalid button name"
                ].join(" "));
              }
            }
          }
        }
        return customButtons;
      }
    }
  });

  // src/components/modebar/index.js
  var require_modebar2 = __commonJS({
    "src/components/modebar/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "modebar",
        layoutAttributes: require_attributes10(),
        supplyLayoutDefaults: require_defaults5(),
        manage: require_manage()
      };
    }
  });

  // src/plots/cartesian/scale_zoom.js
  var require_scale_zoom = __commonJS({
    "src/plots/cartesian/scale_zoom.js"(exports, module) {
      "use strict";
      var FROM_BL = require_alignment().FROM_BL;
      module.exports = function scaleZoom(ax, factor, centerFraction) {
        if (centerFraction === void 0) {
          centerFraction = FROM_BL[ax.constraintoward || "center"];
        }
        var rangeLinear = [ax.r2l(ax.range[0]), ax.r2l(ax.range[1])];
        var center = rangeLinear[0] + (rangeLinear[1] - rangeLinear[0]) * centerFraction;
        ax.range = ax._input.range = [
          ax.l2r(center + (rangeLinear[0] - center) * factor),
          ax.l2r(center + (rangeLinear[1] - center) * factor)
        ];
        ax.setScale();
      };
    }
  });

  // src/plots/cartesian/constraints.js
  var require_constraints = __commonJS({
    "src/plots/cartesian/constraints.js"(exports) {
      "use strict";
      var Lib = require_lib();
      var autorange = require_autorange();
      var id2name = require_axis_ids().id2name;
      var layoutAttributes = require_layout_attributes4();
      var scaleZoom = require_scale_zoom();
      var setConvert = require_set_convert();
      var ALMOST_EQUAL = require_numerical().ALMOST_EQUAL;
      var FROM_BL = require_alignment().FROM_BL;
      exports.handleDefaults = function(layoutIn, layoutOut, opts) {
        var axIds = opts.axIds;
        var axHasImage = opts.axHasImage;
        var constraintGroups = layoutOut._axisConstraintGroups = [];
        var matchGroups = layoutOut._axisMatchGroups = [];
        var i, group, axId, axName, axIn, axOut, attr, val;
        for (i = 0; i < axIds.length; i++) {
          axName = id2name(axIds[i]);
          axIn = layoutIn[axName];
          axOut = layoutOut[axName];
          handleOneAxDefaults(axIn, axOut, {
            axIds,
            layoutOut,
            hasImage: axHasImage[axName]
          });
        }
        function stash(groups, stashAttr) {
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            for (axId in group) {
              layoutOut[id2name(axId)][stashAttr] = group;
            }
          }
        }
        stash(matchGroups, "_matchGroup");
        for (i = 0; i < constraintGroups.length; i++) {
          group = constraintGroups[i];
          for (axId in group) {
            axOut = layoutOut[id2name(axId)];
            if (axOut.fixedrange) {
              for (var axId2 in group) {
                var axName2 = id2name(axId2);
                if ((layoutIn[axName2] || {}).fixedrange === false) {
                  Lib.warn(
                    "fixedrange was specified as false for axis " + axName2 + " but was overridden because another axis in its constraint group has fixedrange true"
                  );
                }
                layoutOut[axName2].fixedrange = true;
              }
              break;
            }
          }
        }
        i = 0;
        while (i < constraintGroups.length) {
          group = constraintGroups[i];
          for (axId in group) {
            axOut = layoutOut[id2name(axId)];
            if (axOut._matchGroup && Object.keys(axOut._matchGroup).length === Object.keys(group).length) {
              constraintGroups.splice(i, 1);
              i--;
            }
            break;
          }
          i++;
        }
        stash(constraintGroups, "_constraintGroup");
        var matchAttrs = [
          "constrain",
          "range",
          "autorange",
          "rangemode",
          "rangebreaks",
          "categoryorder",
          "categoryarray"
        ];
        var hasRange = false;
        var hasDayOfWeekBreaks = false;
        function setAttrVal() {
          val = axOut[attr];
          if (attr === "rangebreaks") {
            hasDayOfWeekBreaks = axOut._hasDayOfWeekBreaks;
          }
        }
        for (i = 0; i < matchGroups.length; i++) {
          group = matchGroups[i];
          for (var j = 0; j < matchAttrs.length; j++) {
            attr = matchAttrs[j];
            val = null;
            var baseAx;
            for (axId in group) {
              axName = id2name(axId);
              axIn = layoutIn[axName];
              axOut = layoutOut[axName];
              if (!(attr in axOut)) {
                continue;
              }
              if (!axOut.matches) {
                baseAx = axOut;
                if (attr in axIn) {
                  setAttrVal();
                  break;
                }
              }
              if (val === null && attr in axIn) {
                setAttrVal();
              }
            }
            if (attr === "range" && val && axIn.range && axIn.range.length === 2 && axIn.range[0] !== null && axIn.range[1] !== null) {
              hasRange = true;
            }
            if (attr === "autorange" && val === null && hasRange) {
              val = false;
            }
            if (val === null && attr in baseAx) {
              val = baseAx[attr];
            }
            if (val !== null) {
              for (axId in group) {
                axOut = layoutOut[id2name(axId)];
                axOut[attr] = attr === "range" ? val.slice() : val;
                if (attr === "rangebreaks") {
                  axOut._hasDayOfWeekBreaks = hasDayOfWeekBreaks;
                  setConvert(axOut, layoutOut);
                }
              }
            }
          }
        }
      };
      function handleOneAxDefaults(axIn, axOut, opts) {
        var axIds = opts.axIds;
        var layoutOut = opts.layoutOut;
        var hasImage = opts.hasImage;
        var constraintGroups = layoutOut._axisConstraintGroups;
        var matchGroups = layoutOut._axisMatchGroups;
        var axId = axOut._id;
        var axLetter = axId.charAt(0);
        var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};
        var thisID = axOut._id;
        var isX = thisID.charAt(0) === "x";
        axOut._matchGroup = null;
        axOut._constraintGroup = null;
        function coerce(attr, dflt) {
          return Lib.coerce(axIn, axOut, layoutAttributes, attr, dflt);
        }
        coerce("constrain", hasImage ? "domain" : "range");
        Lib.coerce(axIn, axOut, {
          constraintoward: {
            valType: "enumerated",
            values: isX ? ["left", "center", "right"] : ["bottom", "middle", "top"],
            dflt: isX ? "center" : "middle"
          }
        }, "constraintoward");
        var thisType = axOut.type;
        var i, idi;
        var linkableAxes = [];
        for (i = 0; i < axIds.length; i++) {
          idi = axIds[i];
          if (idi === thisID) continue;
          var axi = layoutOut[id2name(idi)];
          if (axi.type === thisType) {
            linkableAxes.push(idi);
          }
        }
        var thisGroup = getConstraintGroup(constraintGroups, thisID);
        if (thisGroup) {
          var linkableAxesNoLoops = [];
          for (i = 0; i < linkableAxes.length; i++) {
            idi = linkableAxes[i];
            if (!thisGroup[idi]) linkableAxesNoLoops.push(idi);
          }
          linkableAxes = linkableAxesNoLoops;
        }
        var canLink = linkableAxes.length;
        var matches, scaleanchor;
        if (canLink && (axIn.matches || splomStash.matches)) {
          matches = Lib.coerce(axIn, axOut, {
            matches: {
              valType: "enumerated",
              values: linkableAxes,
              dflt: linkableAxes.indexOf(splomStash.matches) !== -1 ? splomStash.matches : void 0
            }
          }, "matches");
        }
        var scaleanchorDflt = hasImage && !isX ? axOut.anchor : void 0;
        if (canLink && !matches && (axIn.scaleanchor || scaleanchorDflt)) {
          scaleanchor = Lib.coerce(axIn, axOut, {
            scaleanchor: {
              valType: "enumerated",
              values: linkableAxes.concat([false])
            }
          }, "scaleanchor", scaleanchorDflt);
        }
        if (matches) {
          axOut._matchGroup = updateConstraintGroups(matchGroups, thisID, matches, 1);
          var matchedAx = layoutOut[id2name(matches)];
          var matchRatio = extent(layoutOut, axOut) / extent(layoutOut, matchedAx);
          if (isX !== (matches.charAt(0) === "x")) {
            matchRatio = (isX ? "x" : "y") + matchRatio;
          }
          updateConstraintGroups(constraintGroups, thisID, matches, matchRatio);
        } else if (axIn.matches && axIds.indexOf(axIn.matches) !== -1) {
          Lib.warn("ignored " + axOut._name + '.matches: "' + axIn.matches + '" to avoid an infinite loop');
        }
        if (scaleanchor) {
          var scaleratio = coerce("scaleratio");
          if (!scaleratio) scaleratio = axOut.scaleratio = 1;
          updateConstraintGroups(constraintGroups, thisID, scaleanchor, scaleratio);
        } else if (axIn.scaleanchor && axIds.indexOf(axIn.scaleanchor) !== -1) {
          Lib.warn("ignored " + axOut._name + '.scaleanchor: "' + axIn.scaleanchor + '" to avoid either an infinite loop and possibly inconsistent scaleratios, or because this axis declares a *matches* constraint.');
        }
      }
      function extent(layoutOut, ax) {
        var domain = ax.domain;
        if (!domain) {
          domain = layoutOut[id2name(ax.overlaying)].domain;
        }
        return domain[1] - domain[0];
      }
      function getConstraintGroup(groups, thisID) {
        for (var i = 0; i < groups.length; i++) {
          if (groups[i][thisID]) {
            return groups[i];
          }
        }
        return null;
      }
      function updateConstraintGroups(constraintGroups, thisID, thatID, scaleratio) {
        var i, j, groupi, keyj, thisGroupIndex;
        var thisGroup = getConstraintGroup(constraintGroups, thisID);
        if (thisGroup === null) {
          thisGroup = {};
          thisGroup[thisID] = 1;
          thisGroupIndex = constraintGroups.length;
          constraintGroups.push(thisGroup);
        } else {
          thisGroupIndex = constraintGroups.indexOf(thisGroup);
        }
        var thisGroupKeys = Object.keys(thisGroup);
        for (i = 0; i < constraintGroups.length; i++) {
          groupi = constraintGroups[i];
          if (i !== thisGroupIndex && groupi[thatID]) {
            var baseScale = groupi[thatID];
            for (j = 0; j < thisGroupKeys.length; j++) {
              keyj = thisGroupKeys[j];
              groupi[keyj] = multiplyScales(baseScale, multiplyScales(scaleratio, thisGroup[keyj]));
            }
            constraintGroups.splice(thisGroupIndex, 1);
            return;
          }
        }
        if (scaleratio !== 1) {
          for (j = 0; j < thisGroupKeys.length; j++) {
            var key = thisGroupKeys[j];
            thisGroup[key] = multiplyScales(scaleratio, thisGroup[key]);
          }
        }
        thisGroup[thatID] = 1;
      }
      function multiplyScales(a, b) {
        var aPrefix = "";
        var bPrefix = "";
        var aLen, bLen;
        if (typeof a === "string") {
          aPrefix = a.match(/^[xy]*/)[0];
          aLen = aPrefix.length;
          a = +a.substr(aLen);
        }
        if (typeof b === "string") {
          bPrefix = b.match(/^[xy]*/)[0];
          bLen = bPrefix.length;
          b = +b.substr(bLen);
        }
        var c = a * b;
        if (!aLen && !bLen) {
          return c;
        }
        if (!aLen || !bLen || aPrefix.charAt(0) === bPrefix.charAt(0)) {
          return aPrefix + bPrefix + a * b;
        }
        if (aLen === bLen) {
          return c;
        }
        return (aLen > bLen ? aPrefix.substr(bLen) : bPrefix.substr(aLen)) + c;
      }
      function finalRatios(group, fullLayout) {
        var size = fullLayout._size;
        var yRatio = size.h / size.w;
        var out = {};
        var keys = Object.keys(group);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var val = group[key];
          if (typeof val === "string") {
            var prefix = val.match(/^[xy]*/)[0];
            var pLen = prefix.length;
            val = +val.substr(pLen);
            var mult = prefix.charAt(0) === "y" ? yRatio : 1 / yRatio;
            for (var j = 0; j < pLen; j++) {
              val *= mult;
            }
          }
          out[key] = val;
        }
        return out;
      }
      exports.enforce = function enforce(gd) {
        var fullLayout = gd._fullLayout;
        var constraintGroups = fullLayout._axisConstraintGroups || [];
        var i, j, group, axisID, ax, normScale, mode, factor;
        for (i = 0; i < constraintGroups.length; i++) {
          group = finalRatios(constraintGroups[i], fullLayout);
          var axisIDs = Object.keys(group);
          var minScale = Infinity;
          var maxScale = 0;
          var matchScale = Infinity;
          var normScales = {};
          var axes = {};
          var hasAnyDomainConstraint = false;
          for (j = 0; j < axisIDs.length; j++) {
            axisID = axisIDs[j];
            axes[axisID] = ax = fullLayout[id2name(axisID)];
            if (ax._inputDomain) ax.domain = ax._inputDomain.slice();
            else ax._inputDomain = ax.domain.slice();
            if (!ax._inputRange) ax._inputRange = ax.range.slice();
            ax.setScale();
            normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];
            minScale = Math.min(minScale, normScale);
            if (ax.constrain === "domain" || !ax._constraintShrinkable) {
              matchScale = Math.min(matchScale, normScale);
            }
            delete ax._constraintShrinkable;
            maxScale = Math.max(maxScale, normScale);
            if (ax.constrain === "domain") hasAnyDomainConstraint = true;
          }
          if (minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue;
          for (j = 0; j < axisIDs.length; j++) {
            axisID = axisIDs[j];
            normScale = normScales[axisID];
            ax = axes[axisID];
            mode = ax.constrain;
            if (normScale !== matchScale || mode === "domain") {
              factor = normScale / matchScale;
              if (mode === "range") {
                scaleZoom(ax, factor);
              } else {
                var inputDomain = ax._inputDomain;
                var domainShrunk = (ax.domain[1] - ax.domain[0]) / (inputDomain[1] - inputDomain[0]);
                var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) / (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));
                factor /= domainShrunk;
                if (factor * rangeShrunk < 1) {
                  ax.domain = ax._input.domain = inputDomain.slice();
                  scaleZoom(ax, factor);
                  continue;
                }
                if (rangeShrunk < 1) {
                  ax.range = ax._input.range = ax._inputRange.slice();
                  factor *= rangeShrunk;
                }
                if (ax.autorange) {
                  var rl0 = ax.r2l(ax.range[0]);
                  var rl1 = ax.r2l(ax.range[1]);
                  var rangeCenter = (rl0 + rl1) / 2;
                  var rangeMin = rangeCenter;
                  var rangeMax = rangeCenter;
                  var halfRange = Math.abs(rl1 - rangeCenter);
                  var outerMin = rangeCenter - halfRange * factor * 1.0001;
                  var outerMax = rangeCenter + halfRange * factor * 1.0001;
                  var getPadMin = autorange.makePadFn(fullLayout, ax, 0);
                  var getPadMax = autorange.makePadFn(fullLayout, ax, 1);
                  updateDomain(ax, factor);
                  var m = Math.abs(ax._m);
                  var extremes = autorange.concatExtremes(gd, ax);
                  var minArray = extremes.min;
                  var maxArray = extremes.max;
                  var newVal;
                  var k;
                  for (k = 0; k < minArray.length; k++) {
                    newVal = minArray[k].val - getPadMin(minArray[k]) / m;
                    if (newVal > outerMin && newVal < rangeMin) {
                      rangeMin = newVal;
                    }
                  }
                  for (k = 0; k < maxArray.length; k++) {
                    newVal = maxArray[k].val + getPadMax(maxArray[k]) / m;
                    if (newVal < outerMax && newVal > rangeMax) {
                      rangeMax = newVal;
                    }
                  }
                  var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);
                  factor /= domainExpand;
                  rangeMin = ax.l2r(rangeMin);
                  rangeMax = ax.l2r(rangeMax);
                  ax.range = ax._input.range = rl0 < rl1 ? [rangeMin, rangeMax] : [rangeMax, rangeMin];
                }
                updateDomain(ax, factor);
              }
            }
          }
        }
      };
      exports.getAxisGroup = function getAxisGroup(fullLayout, axId) {
        var matchGroups = fullLayout._axisMatchGroups;
        for (var i = 0; i < matchGroups.length; i++) {
          var group = matchGroups[i];
          if (group[axId]) return "g" + i;
        }
        return axId;
      };
      exports.clean = function clean(gd, ax) {
        if (ax._inputDomain) {
          var isConstrained = false;
          var axId = ax._id;
          var constraintGroups = gd._fullLayout._axisConstraintGroups;
          for (var j = 0; j < constraintGroups.length; j++) {
            if (constraintGroups[j][axId]) {
              isConstrained = true;
              break;
            }
          }
          if (!isConstrained || ax.constrain !== "domain") {
            ax._input.domain = ax.domain = ax._inputDomain;
            delete ax._inputDomain;
          }
        }
      };
      function updateDomain(ax, factor) {
        var inputDomain = ax._inputDomain;
        var centerFraction = FROM_BL[ax.constraintoward];
        var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;
        ax.domain = ax._input.domain = [
          center + (inputDomain[0] - center) / factor,
          center + (inputDomain[1] - center) / factor
        ];
        ax.setScale();
      }
    }
  });

  // src/plot_api/subroutines.js
  var require_subroutines = __commonJS({
    "src/plot_api/subroutines.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Lib = require_lib();
      var svgTextUtils = require_svg_text_utils();
      var clearGlCanvases = require_clear_gl_canvases();
      var Color = require_color();
      var Drawing = require_drawing();
      var Titles = require_titles();
      var ModeBar = require_modebar2();
      var Axes = require_axes();
      var alignmentConstants = require_alignment();
      var axisConstraints = require_constraints();
      var enforceAxisConstraints = axisConstraints.enforce;
      var cleanAxisConstraints = axisConstraints.clean;
      var doAutoRange = require_autorange().doAutoRange;
      var SVG_TEXT_ANCHOR_START = "start";
      var SVG_TEXT_ANCHOR_MIDDLE = "middle";
      var SVG_TEXT_ANCHOR_END = "end";
      var zindexSeparator = require_constants2().zindexSeparator;
      exports.layoutStyles = function(gd) {
        return Lib.syncOrAsync([Plots.doAutoMargin, lsInner], gd);
      };
      function overlappingDomain(xDomain, yDomain, domains) {
        for (var i = 0; i < domains.length; i++) {
          var existingX = domains[i][0];
          var existingY = domains[i][1];
          if (existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {
            continue;
          }
          if (existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {
            return true;
          }
        }
        return false;
      }
      function lsInner(gd) {
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var pad = gs.p;
        var axList = Axes.list(gd, "", true);
        var i, subplot, plotinfo, ax, xa, ya;
        fullLayout._paperdiv.style({
          width: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroWidth && !gd.layout.width ? "100%" : fullLayout.width + "px",
          height: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroHeight && !gd.layout.height ? "100%" : fullLayout.height + "px"
        }).selectAll(".main-svg").call(Drawing.setSize, fullLayout.width, fullLayout.height);
        gd._context.setBackground(gd, fullLayout.paper_bgcolor);
        exports.drawMainTitle(gd);
        ModeBar.manage(gd);
        if (!fullLayout._has("cartesian")) {
          return Plots.previousPromises(gd);
        }
        function getLinePosition(ax2, counterAx2, side) {
          var lwHalf = ax2._lw / 2;
          if (ax2._id.charAt(0) === "x") {
            if (!counterAx2) return gs.t + gs.h * (1 - (ax2.position || 0)) + lwHalf % 1;
            else if (side === "top") return counterAx2._offset - pad - lwHalf;
            return counterAx2._offset + counterAx2._length + pad + lwHalf;
          }
          if (!counterAx2) return gs.l + gs.w * (ax2.position || 0) + lwHalf % 1;
          else if (side === "right") return counterAx2._offset + counterAx2._length + pad + lwHalf;
          return counterAx2._offset - pad - lwHalf;
        }
        for (i = 0; i < axList.length; i++) {
          ax = axList[i];
          var counterAx = ax._anchorAxis;
          ax._linepositions = {};
          ax._lw = Drawing.crispRound(gd, ax.linewidth, 1);
          ax._mainLinePosition = getLinePosition(ax, counterAx, ax.side);
          ax._mainMirrorPosition = ax.mirror && counterAx ? getLinePosition(
            ax,
            counterAx,
            alignmentConstants.OPPOSITE_SIDE[ax.side]
          ) : null;
        }
        var lowerBackgroundIDs = [];
        var backgroundIds = [];
        var lowerDomains = [];
        var noNeedForBg = Color.opacity(fullLayout.paper_bgcolor) === 1 && Color.opacity(fullLayout.plot_bgcolor) === 1 && fullLayout.paper_bgcolor === fullLayout.plot_bgcolor;
        for (subplot in fullLayout._plots) {
          plotinfo = fullLayout._plots[subplot];
          if (plotinfo.mainplot) {
            if (plotinfo.bg) {
              plotinfo.bg.remove();
            }
            plotinfo.bg = void 0;
          } else {
            var xDomain = plotinfo.xaxis.domain;
            var yDomain = plotinfo.yaxis.domain;
            var plotgroup = plotinfo.plotgroup;
            if (overlappingDomain(xDomain, yDomain, lowerDomains) && subplot.indexOf(zindexSeparator) === -1) {
              var pgNode = plotgroup.node();
              var plotgroupBg = plotinfo.bg = Lib.ensureSingle(plotgroup, "rect", "bg");
              pgNode.insertBefore(plotgroupBg.node(), pgNode.childNodes[0]);
              backgroundIds.push(subplot);
            } else {
              plotgroup.select("rect.bg").remove();
              lowerDomains.push([xDomain, yDomain]);
              if (!noNeedForBg) {
                lowerBackgroundIDs.push(subplot);
                backgroundIds.push(subplot);
              }
            }
          }
        }
        var lowerBackgrounds = fullLayout._bgLayer.selectAll(".bg").data(lowerBackgroundIDs);
        lowerBackgrounds.enter().append("rect").classed("bg", true);
        lowerBackgrounds.exit().remove();
        lowerBackgrounds.each(function(subplot2) {
          fullLayout._plots[subplot2].bg = d3.select(this);
        });
        for (i = 0; i < backgroundIds.length; i++) {
          plotinfo = fullLayout._plots[backgroundIds[i]];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          if (plotinfo.bg && xa._offset !== void 0 && ya._offset !== void 0) {
            plotinfo.bg.call(
              Drawing.setRect,
              xa._offset - pad,
              ya._offset - pad,
              xa._length + 2 * pad,
              ya._length + 2 * pad
            ).call(Color.fill, fullLayout.plot_bgcolor).style("stroke-width", 0);
          }
        }
        if (!fullLayout._hasOnlyLargeSploms) {
          for (subplot in fullLayout._plots) {
            plotinfo = fullLayout._plots[subplot];
            xa = plotinfo.xaxis;
            ya = plotinfo.yaxis;
            var clipId = plotinfo.clipId = "clip" + fullLayout._uid + subplot + "plot";
            var plotClip = Lib.ensureSingleById(fullLayout._clips, "clipPath", clipId, function(s) {
              s.classed("plotclip", true).append("rect");
            });
            plotinfo.clipRect = plotClip.select("rect").attr({
              width: xa._length,
              height: ya._length
            });
            Drawing.setTranslate(plotinfo.plot, xa._offset, ya._offset);
            var plotClipId;
            var layerClipId;
            if (plotinfo._hasClipOnAxisFalse) {
              plotClipId = null;
              layerClipId = clipId;
            } else {
              plotClipId = clipId;
              layerClipId = null;
            }
            Drawing.setClipUrl(plotinfo.plot, plotClipId, gd);
            plotinfo.layerClipId = layerClipId;
          }
        }
        var xLinesXLeft, xLinesXRight, xLinesYBottom, xLinesYTop, leftYLineWidth, rightYLineWidth;
        var yLinesYBottom, yLinesYTop, yLinesXLeft, yLinesXRight, connectYBottom, connectYTop;
        var extraSubplot;
        function xLinePath(y) {
          return "M" + xLinesXLeft + "," + y + "H" + xLinesXRight;
        }
        function xLinePathFree(y) {
          return "M" + xa._offset + "," + y + "h" + xa._length;
        }
        function yLinePath(x) {
          return "M" + x + "," + yLinesYTop + "V" + yLinesYBottom;
        }
        function yLinePathFree(x) {
          if (ya._shift !== void 0) {
            x += ya._shift;
          }
          return "M" + x + "," + ya._offset + "v" + ya._length;
        }
        function mainPath(ax2, pathFn, pathFnFree) {
          if (!ax2.showline || subplot !== ax2._mainSubplot) return "";
          if (!ax2._anchorAxis) return pathFnFree(ax2._mainLinePosition);
          var out = pathFn(ax2._mainLinePosition);
          if (ax2.mirror) out += pathFn(ax2._mainMirrorPosition);
          return out;
        }
        for (subplot in fullLayout._plots) {
          plotinfo = fullLayout._plots[subplot];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          var xPath = "M0,0";
          if (shouldShowLinesOrTicks(xa, subplot)) {
            leftYLineWidth = findCounterAxisLineWidth(xa, "left", ya, axList);
            xLinesXLeft = xa._offset - (leftYLineWidth ? pad + leftYLineWidth : 0);
            rightYLineWidth = findCounterAxisLineWidth(xa, "right", ya, axList);
            xLinesXRight = xa._offset + xa._length + (rightYLineWidth ? pad + rightYLineWidth : 0);
            xLinesYBottom = getLinePosition(xa, ya, "bottom");
            xLinesYTop = getLinePosition(xa, ya, "top");
            extraSubplot = !xa._anchorAxis || subplot !== xa._mainSubplot;
            if (extraSubplot && (xa.mirror === "allticks" || xa.mirror === "all")) {
              xa._linepositions[subplot] = [xLinesYBottom, xLinesYTop];
            }
            xPath = mainPath(xa, xLinePath, xLinePathFree);
            if (extraSubplot && xa.showline && (xa.mirror === "all" || xa.mirror === "allticks")) {
              xPath += xLinePath(xLinesYBottom) + xLinePath(xLinesYTop);
            }
            plotinfo.xlines.style("stroke-width", xa._lw + "px").call(Color.stroke, xa.showline ? xa.linecolor : "rgba(0,0,0,0)");
          }
          plotinfo.xlines.attr("d", xPath);
          var yPath = "M0,0";
          if (shouldShowLinesOrTicks(ya, subplot)) {
            connectYBottom = findCounterAxisLineWidth(ya, "bottom", xa, axList);
            yLinesYBottom = ya._offset + ya._length + (connectYBottom ? pad : 0);
            connectYTop = findCounterAxisLineWidth(ya, "top", xa, axList);
            yLinesYTop = ya._offset - (connectYTop ? pad : 0);
            yLinesXLeft = getLinePosition(ya, xa, "left");
            yLinesXRight = getLinePosition(ya, xa, "right");
            extraSubplot = !ya._anchorAxis || subplot !== ya._mainSubplot;
            if (extraSubplot && (ya.mirror === "allticks" || ya.mirror === "all")) {
              ya._linepositions[subplot] = [yLinesXLeft, yLinesXRight];
            }
            yPath = mainPath(ya, yLinePath, yLinePathFree);
            if (extraSubplot && ya.showline && (ya.mirror === "all" || ya.mirror === "allticks")) {
              yPath += yLinePath(yLinesXLeft) + yLinePath(yLinesXRight);
            }
            plotinfo.ylines.style("stroke-width", ya._lw + "px").call(Color.stroke, ya.showline ? ya.linecolor : "rgba(0,0,0,0)");
          }
          plotinfo.ylines.attr("d", yPath);
        }
        Axes.makeClipPaths(gd);
        return Plots.previousPromises(gd);
      }
      function shouldShowLinesOrTicks(ax, subplot) {
        return (ax.ticks || ax.showline) && (subplot === ax._mainSubplot || ax.mirror === "all" || ax.mirror === "allticks");
      }
      function shouldShowLineThisSide(ax, side, counterAx) {
        if (!counterAx.showline || !counterAx._lw) return false;
        if (counterAx.mirror === "all" || counterAx.mirror === "allticks") return true;
        var anchorAx = counterAx._anchorAxis;
        if (!anchorAx) return false;
        var sideIndex = alignmentConstants.FROM_BL[side];
        if (counterAx.side === side) {
          return anchorAx.domain[sideIndex] === ax.domain[sideIndex];
        }
        return counterAx.mirror && anchorAx.domain[1 - sideIndex] === ax.domain[1 - sideIndex];
      }
      function findCounterAxisLineWidth(ax, side, counterAx, axList) {
        if (shouldShowLineThisSide(ax, side, counterAx)) {
          return counterAx._lw;
        }
        for (var i = 0; i < axList.length; i++) {
          var axi = axList[i];
          if (axi._mainAxis === counterAx._mainAxis && shouldShowLineThisSide(ax, side, axi)) {
            return axi._lw;
          }
        }
        return 0;
      }
      exports.drawMainTitle = function(gd) {
        var title = gd._fullLayout.title;
        var fullLayout = gd._fullLayout;
        var textAnchor = getMainTitleTextAnchor(fullLayout);
        var dy = getMainTitleDy(fullLayout);
        var y = getMainTitleY(fullLayout, dy);
        var x = getMainTitleX(fullLayout, textAnchor);
        Titles.draw(gd, "gtitle", {
          propContainer: fullLayout,
          propName: "title.text",
          subtitlePropName: "title.subtitle.text",
          placeholder: fullLayout._dfltTitle.plot,
          subtitlePlaceholder: fullLayout._dfltTitle.subtitle,
          attributes: {
            x,
            y,
            "text-anchor": textAnchor,
            dy
          }
        });
        if (title.text && title.automargin) {
          var titleObj = d3.selectAll(".gtitle");
          var titleHeight = Drawing.bBox(d3.selectAll(".g-gtitle").node()).height;
          var pushMargin = needsMarginPush(gd, title, titleHeight);
          if (pushMargin > 0) {
            applyTitleAutoMargin(gd, y, pushMargin, titleHeight);
            titleObj.attr({
              x,
              y,
              "text-anchor": textAnchor,
              dy: getMainTitleDyAdj(title.yanchor)
            }).call(svgTextUtils.positionText, x, y);
            var extraLines = (title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
            if (extraLines) {
              var delta = alignmentConstants.LINE_SPACING * extraLines + alignmentConstants.MID_SHIFT;
              if (title.y === 0) {
                delta = -delta;
              }
              titleObj.selectAll(".line").each(function() {
                var newDy = +this.getAttribute("dy").slice(0, -2) - delta + "em";
                this.setAttribute("dy", newDy);
              });
            }
            var subtitleObj = d3.selectAll(".gtitle-subtitle");
            if (subtitleObj.node()) {
              var titleBB = titleObj.node().getBBox();
              var titleBottom = titleBB.y + titleBB.height;
              var subtitleY = titleBottom + Titles.SUBTITLE_PADDING_EM * title.subtitle.font.size;
              subtitleObj.attr({
                x,
                y: subtitleY,
                "text-anchor": textAnchor,
                dy: getMainTitleDyAdj(title.yanchor)
              }).call(svgTextUtils.positionText, x, subtitleY);
            }
          }
        }
      };
      function isOutsideContainer(gd, title, position, y, titleHeight) {
        var plotHeight = title.yref === "paper" ? gd._fullLayout._size.h : gd._fullLayout.height;
        var yPosTop = Lib.isTopAnchor(title) ? y : y - titleHeight;
        var yPosRel = position === "b" ? plotHeight - yPosTop : yPosTop;
        if (Lib.isTopAnchor(title) && position === "t" || Lib.isBottomAnchor(title) && position === "b") {
          return false;
        } else {
          return yPosRel < titleHeight;
        }
      }
      function containerPushVal(position, titleY, titleYanchor, height, titleDepth) {
        var push = 0;
        if (titleYanchor === "middle") {
          push += titleDepth / 2;
        }
        if (position === "t") {
          if (titleYanchor === "top") {
            push += titleDepth;
          }
          push += height - titleY * height;
        } else {
          if (titleYanchor === "bottom") {
            push += titleDepth;
          }
          push += titleY * height;
        }
        return push;
      }
      function needsMarginPush(gd, title, titleHeight) {
        var titleY = title.y;
        var titleYanchor = title.yanchor;
        var position = titleY > 0.5 ? "t" : "b";
        var curMargin = gd._fullLayout.margin[position];
        var pushMargin = 0;
        if (title.yref === "paper") {
          pushMargin = titleHeight + title.pad.t + title.pad.b;
        } else if (title.yref === "container") {
          pushMargin = containerPushVal(position, titleY, titleYanchor, gd._fullLayout.height, titleHeight) + title.pad.t + title.pad.b;
        }
        if (pushMargin > curMargin) {
          return pushMargin;
        }
        return 0;
      }
      function applyTitleAutoMargin(gd, y, pushMargin, titleHeight) {
        var titleID = "title.automargin";
        var title = gd._fullLayout.title;
        var position = title.y > 0.5 ? "t" : "b";
        var push = {
          x: title.x,
          y: title.y,
          t: 0,
          b: 0
        };
        var reservedPush = {};
        if (title.yref === "paper" && isOutsideContainer(gd, title, position, y, titleHeight)) {
          push[position] = pushMargin;
        } else if (title.yref === "container") {
          reservedPush[position] = pushMargin;
          gd._fullLayout._reservedMargin[titleID] = reservedPush;
        }
        Plots.allowAutoMargin(gd, titleID);
        Plots.autoMargin(gd, titleID, push);
      }
      function getMainTitleX(fullLayout, textAnchor) {
        var title = fullLayout.title;
        var gs = fullLayout._size;
        var hPadShift = 0;
        if (textAnchor === SVG_TEXT_ANCHOR_START) {
          hPadShift = title.pad.l;
        } else if (textAnchor === SVG_TEXT_ANCHOR_END) {
          hPadShift = -title.pad.r;
        }
        switch (title.xref) {
          case "paper":
            return gs.l + gs.w * title.x + hPadShift;
          case "container":
          default:
            return fullLayout.width * title.x + hPadShift;
        }
      }
      function getMainTitleY(fullLayout, dy) {
        var title = fullLayout.title;
        var gs = fullLayout._size;
        var vPadShift = 0;
        if (dy === "0em" || !dy) {
          vPadShift = -title.pad.b;
        } else if (dy === alignmentConstants.CAP_SHIFT + "em") {
          vPadShift = title.pad.t;
        }
        if (title.y === "auto") {
          return gs.t / 2;
        } else {
          switch (title.yref) {
            case "paper":
              return gs.t + gs.h - gs.h * title.y + vPadShift;
            case "container":
            default:
              return fullLayout.height - fullLayout.height * title.y + vPadShift;
          }
        }
      }
      function getMainTitleDyAdj(yanchor) {
        if (yanchor === "top") {
          return alignmentConstants.CAP_SHIFT + 0.3 + "em";
        } else if (yanchor === "bottom") {
          return "-0.3em";
        } else {
          return alignmentConstants.MID_SHIFT + "em";
        }
      }
      function getMainTitleTextAnchor(fullLayout) {
        var title = fullLayout.title;
        var textAnchor = SVG_TEXT_ANCHOR_MIDDLE;
        if (Lib.isRightAnchor(title)) {
          textAnchor = SVG_TEXT_ANCHOR_END;
        } else if (Lib.isLeftAnchor(title)) {
          textAnchor = SVG_TEXT_ANCHOR_START;
        }
        return textAnchor;
      }
      function getMainTitleDy(fullLayout) {
        var title = fullLayout.title;
        var dy = "0em";
        if (Lib.isTopAnchor(title)) {
          dy = alignmentConstants.CAP_SHIFT + "em";
        } else if (Lib.isMiddleAnchor(title)) {
          dy = alignmentConstants.MID_SHIFT + "em";
        }
        return dy;
      }
      exports.doTraceStyle = function(gd) {
        var calcdata = gd.calcdata;
        var editStyleCalls = [];
        var i;
        for (i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var cd0 = cd[0] || {};
          var trace = cd0.trace || {};
          var _module = trace._module || {};
          var arraysToCalcdata = _module.arraysToCalcdata;
          if (arraysToCalcdata) arraysToCalcdata(cd, trace);
          var editStyle = _module.editStyle;
          if (editStyle) editStyleCalls.push({ fn: editStyle, cd0 });
        }
        if (editStyleCalls.length) {
          for (i = 0; i < editStyleCalls.length; i++) {
            var edit = editStyleCalls[i];
            edit.fn(gd, edit.cd0);
          }
          clearGlCanvases(gd);
          exports.redrawReglTraces(gd);
        }
        Plots.style(gd);
        Registry.getComponentMethod("legend", "draw")(gd);
        return Plots.previousPromises(gd);
      };
      exports.doColorBars = function(gd) {
        Registry.getComponentMethod("colorbar", "draw")(gd);
        return Plots.previousPromises(gd);
      };
      exports.layoutReplot = function(gd) {
        var layout = gd.layout;
        gd.layout = void 0;
        return Registry.call("_doPlot", gd, "", layout);
      };
      exports.doLegend = function(gd) {
        Registry.getComponentMethod("legend", "draw")(gd);
        return Plots.previousPromises(gd);
      };
      exports.doTicksRelayout = function(gd) {
        Axes.draw(gd, "redraw");
        if (gd._fullLayout._hasOnlyLargeSploms) {
          Registry.subplotsRegistry.splom.updateGrid(gd);
          clearGlCanvases(gd);
          exports.redrawReglTraces(gd);
        }
        exports.drawMainTitle(gd);
        return Plots.previousPromises(gd);
      };
      exports.doModeBar = function(gd) {
        var fullLayout = gd._fullLayout;
        ModeBar.manage(gd);
        for (var i = 0; i < fullLayout._basePlotModules.length; i++) {
          var updateFx = fullLayout._basePlotModules[i].updateFx;
          if (updateFx) updateFx(gd);
        }
        return Plots.previousPromises(gd);
      };
      exports.doCamera = function(gd) {
        var fullLayout = gd._fullLayout;
        var sceneIds = fullLayout._subplots.gl3d;
        for (var i = 0; i < sceneIds.length; i++) {
          var sceneLayout = fullLayout[sceneIds[i]];
          var scene = sceneLayout._scene;
          scene.setViewport(sceneLayout);
        }
      };
      exports.drawData = function(gd) {
        var fullLayout = gd._fullLayout;
        clearGlCanvases(gd);
        var basePlotModules = fullLayout._basePlotModules;
        for (var i = 0; i < basePlotModules.length; i++) {
          basePlotModules[i].plot(gd);
        }
        exports.redrawReglTraces(gd);
        Plots.style(gd);
        Registry.getComponentMethod("selections", "draw")(gd);
        Registry.getComponentMethod("shapes", "draw")(gd);
        Registry.getComponentMethod("annotations", "draw")(gd);
        Registry.getComponentMethod("images", "draw")(gd);
        fullLayout._replotting = false;
        return Plots.previousPromises(gd);
      };
      exports.redrawReglTraces = function(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._has("regl")) {
          var fullData = gd._fullData;
          var cartesianIds = [];
          var polarIds = [];
          var i, sp;
          if (fullLayout._hasOnlyLargeSploms) {
            fullLayout._splomGrid.draw();
          }
          for (i = 0; i < fullData.length; i++) {
            var trace = fullData[i];
            if (trace.visible === true && trace._length !== 0) {
              if (trace.type === "splom") {
                fullLayout._splomScenes[trace.uid].draw();
              } else if (trace.type === "scattergl") {
                Lib.pushUnique(cartesianIds, trace.xaxis + trace.yaxis);
              } else if (trace.type === "scatterpolargl") {
                Lib.pushUnique(polarIds, trace.subplot);
              }
            }
          }
          for (i = 0; i < cartesianIds.length; i++) {
            sp = fullLayout._plots[cartesianIds[i]];
            if (sp._scene) sp._scene.draw();
          }
          for (i = 0; i < polarIds.length; i++) {
            sp = fullLayout[polarIds[i]]._subplot;
            if (sp._scene) sp._scene.draw();
          }
        }
      };
      exports.doAutoRangeAndConstraints = function(gd) {
        var axList = Axes.list(gd, "", true);
        var ax;
        var autoRangeDone = {};
        for (var i = 0; i < axList.length; i++) {
          ax = axList[i];
          if (!autoRangeDone[ax._id]) {
            autoRangeDone[ax._id] = 1;
            cleanAxisConstraints(gd, ax);
            doAutoRange(gd, ax);
            var matchGroup = ax._matchGroup;
            if (matchGroup) {
              for (var id2 in matchGroup) {
                var ax2 = Axes.getFromId(gd, id2);
                doAutoRange(gd, ax2, ax.range);
                autoRangeDone[id2] = 1;
              }
            }
          }
        }
        enforceAxisConstraints(gd);
      };
      exports.finalDraw = function(gd) {
        Registry.getComponentMethod("rangeslider", "draw")(gd);
        Registry.getComponentMethod("rangeselector", "draw")(gd);
      };
      exports.drawMarginPushers = function(gd) {
        Registry.getComponentMethod("legend", "draw")(gd);
        Registry.getComponentMethod("rangeselector", "draw")(gd);
        Registry.getComponentMethod("sliders", "draw")(gd);
        Registry.getComponentMethod("updatemenus", "draw")(gd);
        Registry.getComponentMethod("colorbar", "draw")(gd);
      };
    }
  });

  // src/components/selections/draw.js
  var require_draw3 = __commonJS({
    "src/components/selections/draw.js"(exports, module) {
      "use strict";
      var readPaths = require_helpers7().readPaths;
      var displayOutlines = require_display_outlines();
      var clearOutlineControllers = require_handle_outline().clearOutlineControllers;
      var Color = require_color();
      var Drawing = require_drawing();
      var arrayEditor = require_plot_template().arrayEditor;
      var helpers = require_helpers8();
      var getPathString = helpers.getPathString;
      module.exports = {
        draw,
        drawOne,
        activateLastSelection
      };
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        clearOutlineControllers(gd);
        fullLayout._selectionLayer.selectAll("path").remove();
        for (var k in fullLayout._plots) {
          var selectionLayer = fullLayout._plots[k].selectionLayer;
          if (selectionLayer) selectionLayer.selectAll("path").remove();
        }
        for (var i = 0; i < fullLayout.selections.length; i++) {
          drawOne(gd, i);
        }
      }
      function couldHaveActiveSelection(gd) {
        return gd._context.editSelection;
      }
      function drawOne(gd, index) {
        gd._fullLayout._paperdiv.selectAll('.selectionlayer [data-index="' + index + '"]').remove();
        var o = helpers.makeSelectionsOptionsAndPlotinfo(gd, index);
        var options = o.options;
        var plotinfo = o.plotinfo;
        if (!options._input) return;
        drawSelection(gd._fullLayout._selectionLayer);
        function drawSelection(selectionLayer) {
          var d = getPathString(gd, options);
          var attrs = {
            "data-index": index,
            "fill-rule": "evenodd",
            d
          };
          var opacity = options.opacity;
          var fillColor = "rgba(0,0,0,0)";
          var lineColor = options.line.color || Color.contrast(gd._fullLayout.plot_bgcolor);
          var lineWidth = options.line.width;
          var lineDash = options.line.dash;
          if (!lineWidth) {
            lineWidth = 5;
            lineDash = "solid";
          }
          var isActiveSelection = couldHaveActiveSelection(gd) && gd._fullLayout._activeSelectionIndex === index;
          if (isActiveSelection) {
            fillColor = gd._fullLayout.activeselection.fillcolor;
            opacity = gd._fullLayout.activeselection.opacity;
          }
          var allPaths = [];
          for (var sensory = 1; sensory >= 0; sensory--) {
            var path = selectionLayer.append("path").attr(attrs).style("opacity", sensory ? 0.1 : opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor).call(
              Drawing.dashLine,
              sensory ? "solid" : lineDash,
              sensory ? 4 + lineWidth : lineWidth
            );
            setClipPath(path, gd, options);
            if (isActiveSelection) {
              var editHelpers = arrayEditor(gd.layout, "selections", options);
              path.style({
                cursor: "move"
              });
              var dragOptions = {
                element: path.node(),
                plotinfo,
                gd,
                editHelpers,
                isActiveSelection: true
                // i.e. to enable controllers
              };
              var polygons = readPaths(d, gd);
              displayOutlines(polygons, path, dragOptions);
            } else {
              path.style("pointer-events", sensory ? "all" : "none");
            }
            allPaths[sensory] = path;
          }
          var forePath = allPaths[0];
          var backPath = allPaths[1];
          backPath.node().addEventListener("click", function() {
            return activateSelection(gd, forePath);
          });
        }
      }
      function setClipPath(selectionPath, gd, selectionOptions) {
        var clipAxes = selectionOptions.xref + selectionOptions.yref;
        Drawing.setClipUrl(
          selectionPath,
          "clip" + gd._fullLayout._uid + clipAxes,
          gd
        );
      }
      function activateSelection(gd, path) {
        if (!couldHaveActiveSelection(gd)) return;
        var element = path.node();
        var id = +element.getAttribute("data-index");
        if (id >= 0) {
          if (id === gd._fullLayout._activeSelectionIndex) {
            deactivateSelection(gd);
            return;
          }
          gd._fullLayout._activeSelectionIndex = id;
          gd._fullLayout._deactivateSelection = deactivateSelection;
          draw(gd);
        }
      }
      function activateLastSelection(gd) {
        if (!couldHaveActiveSelection(gd)) return;
        var id = gd._fullLayout.selections.length - 1;
        gd._fullLayout._activeSelectionIndex = id;
        gd._fullLayout._deactivateSelection = deactivateSelection;
        draw(gd);
      }
      function deactivateSelection(gd) {
        if (!couldHaveActiveSelection(gd)) return;
        var id = gd._fullLayout._activeSelectionIndex;
        if (id >= 0) {
          clearOutlineControllers(gd);
          delete gd._fullLayout._activeSelectionIndex;
          draw(gd);
        }
      }
    }
  });

  // node_modules/polybooljs/lib/build-log.js
  var require_build_log = __commonJS({
    "node_modules/polybooljs/lib/build-log.js"(exports, module) {
      function BuildLog() {
        var my;
        var nextSegmentId = 0;
        var curVert = false;
        function push(type, data) {
          my.list.push({
            type,
            data: data ? JSON.parse(JSON.stringify(data)) : void 0
          });
          return my;
        }
        my = {
          list: [],
          segmentId: function() {
            return nextSegmentId++;
          },
          checkIntersection: function(seg1, seg2) {
            return push("check", { seg1, seg2 });
          },
          segmentChop: function(seg, end) {
            push("div_seg", { seg, pt: end });
            return push("chop", { seg, pt: end });
          },
          statusRemove: function(seg) {
            return push("pop_seg", { seg });
          },
          segmentUpdate: function(seg) {
            return push("seg_update", { seg });
          },
          segmentNew: function(seg, primary) {
            return push("new_seg", { seg, primary });
          },
          segmentRemove: function(seg) {
            return push("rem_seg", { seg });
          },
          tempStatus: function(seg, above, below) {
            return push("temp_status", { seg, above, below });
          },
          rewind: function(seg) {
            return push("rewind", { seg });
          },
          status: function(seg, above, below) {
            return push("status", { seg, above, below });
          },
          vert: function(x) {
            if (x === curVert)
              return my;
            curVert = x;
            return push("vert", { x });
          },
          log: function(data) {
            if (typeof data !== "string")
              data = JSON.stringify(data, false, "  ");
            return push("log", { txt: data });
          },
          reset: function() {
            return push("reset");
          },
          selected: function(segs) {
            return push("selected", { segs });
          },
          chainStart: function(seg) {
            return push("chain_start", { seg });
          },
          chainRemoveHead: function(index, pt) {
            return push("chain_rem_head", { index, pt });
          },
          chainRemoveTail: function(index, pt) {
            return push("chain_rem_tail", { index, pt });
          },
          chainNew: function(pt1, pt2) {
            return push("chain_new", { pt1, pt2 });
          },
          chainMatch: function(index) {
            return push("chain_match", { index });
          },
          chainClose: function(index) {
            return push("chain_close", { index });
          },
          chainAddHead: function(index, pt) {
            return push("chain_add_head", { index, pt });
          },
          chainAddTail: function(index, pt) {
            return push("chain_add_tail", { index, pt });
          },
          chainConnect: function(index1, index2) {
            return push("chain_con", { index1, index2 });
          },
          chainReverse: function(index) {
            return push("chain_rev", { index });
          },
          chainJoin: function(index1, index2) {
            return push("chain_join", { index1, index2 });
          },
          done: function() {
            return push("done");
          }
        };
        return my;
      }
      module.exports = BuildLog;
    }
  });

  // node_modules/polybooljs/lib/epsilon.js
  var require_epsilon = __commonJS({
    "node_modules/polybooljs/lib/epsilon.js"(exports, module) {
      function Epsilon(eps) {
        if (typeof eps !== "number")
          eps = 1e-10;
        var my = {
          epsilon: function(v) {
            if (typeof v === "number")
              eps = v;
            return eps;
          },
          pointAboveOrOnLine: function(pt, left, right) {
            var Ax = left[0];
            var Ay = left[1];
            var Bx = right[0];
            var By = right[1];
            var Cx = pt[0];
            var Cy = pt[1];
            return (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;
          },
          pointBetween: function(p, left, right) {
            var d_py_ly = p[1] - left[1];
            var d_rx_lx = right[0] - left[0];
            var d_px_lx = p[0] - left[0];
            var d_ry_ly = right[1] - left[1];
            var dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;
            if (dot < eps)
              return false;
            var sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;
            if (dot - sqlen > -eps)
              return false;
            return true;
          },
          pointsSameX: function(p1, p2) {
            return Math.abs(p1[0] - p2[0]) < eps;
          },
          pointsSameY: function(p1, p2) {
            return Math.abs(p1[1] - p2[1]) < eps;
          },
          pointsSame: function(p1, p2) {
            return my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);
          },
          pointsCompare: function(p1, p2) {
            if (my.pointsSameX(p1, p2))
              return my.pointsSameY(p1, p2) ? 0 : p1[1] < p2[1] ? -1 : 1;
            return p1[0] < p2[0] ? -1 : 1;
          },
          pointsCollinear: function(pt1, pt2, pt3) {
            var dx1 = pt1[0] - pt2[0];
            var dy1 = pt1[1] - pt2[1];
            var dx2 = pt2[0] - pt3[0];
            var dy2 = pt2[1] - pt3[1];
            return Math.abs(dx1 * dy2 - dx2 * dy1) < eps;
          },
          linesIntersect: function(a0, a1, b0, b1) {
            var adx = a1[0] - a0[0];
            var ady = a1[1] - a0[1];
            var bdx = b1[0] - b0[0];
            var bdy = b1[1] - b0[1];
            var axb = adx * bdy - ady * bdx;
            if (Math.abs(axb) < eps)
              return false;
            var dx = a0[0] - b0[0];
            var dy = a0[1] - b0[1];
            var A = (bdx * dy - bdy * dx) / axb;
            var B = (adx * dy - ady * dx) / axb;
            var ret = {
              alongA: 0,
              alongB: 0,
              pt: [
                a0[0] + A * adx,
                a0[1] + A * ady
              ]
            };
            if (A <= -eps)
              ret.alongA = -2;
            else if (A < eps)
              ret.alongA = -1;
            else if (A - 1 <= -eps)
              ret.alongA = 0;
            else if (A - 1 < eps)
              ret.alongA = 1;
            else
              ret.alongA = 2;
            if (B <= -eps)
              ret.alongB = -2;
            else if (B < eps)
              ret.alongB = -1;
            else if (B - 1 <= -eps)
              ret.alongB = 0;
            else if (B - 1 < eps)
              ret.alongB = 1;
            else
              ret.alongB = 2;
            return ret;
          },
          pointInsideRegion: function(pt, region) {
            var x = pt[0];
            var y = pt[1];
            var last_x = region[region.length - 1][0];
            var last_y = region[region.length - 1][1];
            var inside = false;
            for (var i = 0; i < region.length; i++) {
              var curr_x = region[i][0];
              var curr_y = region[i][1];
              if (curr_y - y > eps != last_y - y > eps && (last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)
                inside = !inside;
              last_x = curr_x;
              last_y = curr_y;
            }
            return inside;
          }
        };
        return my;
      }
      module.exports = Epsilon;
    }
  });

  // node_modules/polybooljs/lib/linked-list.js
  var require_linked_list = __commonJS({
    "node_modules/polybooljs/lib/linked-list.js"(exports, module) {
      var LinkedList = {
        create: function() {
          var my = {
            root: { root: true, next: null },
            exists: function(node) {
              if (node === null || node === my.root)
                return false;
              return true;
            },
            isEmpty: function() {
              return my.root.next === null;
            },
            getHead: function() {
              return my.root.next;
            },
            insertBefore: function(node, check) {
              var last = my.root;
              var here = my.root.next;
              while (here !== null) {
                if (check(here)) {
                  node.prev = here.prev;
                  node.next = here;
                  here.prev.next = node;
                  here.prev = node;
                  return;
                }
                last = here;
                here = here.next;
              }
              last.next = node;
              node.prev = last;
              node.next = null;
            },
            findTransition: function(check) {
              var prev = my.root;
              var here = my.root.next;
              while (here !== null) {
                if (check(here))
                  break;
                prev = here;
                here = here.next;
              }
              return {
                before: prev === my.root ? null : prev,
                after: here,
                insert: function(node) {
                  node.prev = prev;
                  node.next = here;
                  prev.next = node;
                  if (here !== null)
                    here.prev = node;
                  return node;
                }
              };
            }
          };
          return my;
        },
        node: function(data) {
          data.prev = null;
          data.next = null;
          data.remove = function() {
            data.prev.next = data.next;
            if (data.next)
              data.next.prev = data.prev;
            data.prev = null;
            data.next = null;
          };
          return data;
        }
      };
      module.exports = LinkedList;
    }
  });

  // node_modules/polybooljs/lib/intersecter.js
  var require_intersecter = __commonJS({
    "node_modules/polybooljs/lib/intersecter.js"(exports, module) {
      var LinkedList = require_linked_list();
      function Intersecter(selfIntersection, eps, buildLog) {
        function segmentNew(start, end) {
          return {
            id: buildLog ? buildLog.segmentId() : -1,
            start,
            end,
            myFill: {
              above: null,
              // is there fill above us?
              below: null
              // is there fill below us?
            },
            otherFill: null
          };
        }
        function segmentCopy(start, end, seg) {
          return {
            id: buildLog ? buildLog.segmentId() : -1,
            start,
            end,
            myFill: {
              above: seg.myFill.above,
              below: seg.myFill.below
            },
            otherFill: null
          };
        }
        var event_root = LinkedList.create();
        function eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2) {
          var comp = eps.pointsCompare(p1_1, p2_1);
          if (comp !== 0)
            return comp;
          if (eps.pointsSame(p1_2, p2_2))
            return 0;
          if (p1_isStart !== p2_isStart)
            return p1_isStart ? 1 : -1;
          return eps.pointAboveOrOnLine(
            p1_2,
            p2_isStart ? p2_1 : p2_2,
            // order matters
            p2_isStart ? p2_2 : p2_1
          ) ? 1 : -1;
        }
        function eventAdd(ev, other_pt) {
          event_root.insertBefore(ev, function(here) {
            var comp = eventCompare(
              ev.isStart,
              ev.pt,
              other_pt,
              here.isStart,
              here.pt,
              here.other.pt
            );
            return comp < 0;
          });
        }
        function eventAddSegmentStart(seg, primary) {
          var ev_start = LinkedList.node({
            isStart: true,
            pt: seg.start,
            seg,
            primary,
            other: null,
            status: null
          });
          eventAdd(ev_start, seg.end);
          return ev_start;
        }
        function eventAddSegmentEnd(ev_start, seg, primary) {
          var ev_end = LinkedList.node({
            isStart: false,
            pt: seg.end,
            seg,
            primary,
            other: ev_start,
            status: null
          });
          ev_start.other = ev_end;
          eventAdd(ev_end, ev_start.pt);
        }
        function eventAddSegment(seg, primary) {
          var ev_start = eventAddSegmentStart(seg, primary);
          eventAddSegmentEnd(ev_start, seg, primary);
          return ev_start;
        }
        function eventUpdateEnd(ev, end) {
          if (buildLog)
            buildLog.segmentChop(ev.seg, end);
          ev.other.remove();
          ev.seg.end = end;
          ev.other.pt = end;
          eventAdd(ev.other, ev.pt);
        }
        function eventDivide(ev, pt) {
          var ns = segmentCopy(pt, ev.seg.end, ev.seg);
          eventUpdateEnd(ev, pt);
          return eventAddSegment(ns, ev.primary);
        }
        function calculate(primaryPolyInverted, secondaryPolyInverted) {
          var status_root = LinkedList.create();
          function statusCompare(ev1, ev2) {
            var a1 = ev1.seg.start;
            var a2 = ev1.seg.end;
            var b1 = ev2.seg.start;
            var b2 = ev2.seg.end;
            if (eps.pointsCollinear(a1, b1, b2)) {
              if (eps.pointsCollinear(a2, b1, b2))
                return 1;
              return eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;
            }
            return eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;
          }
          function statusFindSurrounding(ev2) {
            return status_root.findTransition(function(here) {
              var comp = statusCompare(ev2, here.ev);
              return comp > 0;
            });
          }
          function checkIntersection(ev1, ev2) {
            var seg1 = ev1.seg;
            var seg2 = ev2.seg;
            var a1 = seg1.start;
            var a2 = seg1.end;
            var b1 = seg2.start;
            var b2 = seg2.end;
            if (buildLog)
              buildLog.checkIntersection(seg1, seg2);
            var i = eps.linesIntersect(a1, a2, b1, b2);
            if (i === false) {
              if (!eps.pointsCollinear(a1, a2, b1))
                return false;
              if (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))
                return false;
              var a1_equ_b1 = eps.pointsSame(a1, b1);
              var a2_equ_b2 = eps.pointsSame(a2, b2);
              if (a1_equ_b1 && a2_equ_b2)
                return ev2;
              var a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);
              var a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);
              if (a1_equ_b1) {
                if (a2_between) {
                  eventDivide(ev2, a2);
                } else {
                  eventDivide(ev1, b2);
                }
                return ev2;
              } else if (a1_between) {
                if (!a2_equ_b2) {
                  if (a2_between) {
                    eventDivide(ev2, a2);
                  } else {
                    eventDivide(ev1, b2);
                  }
                }
                eventDivide(ev2, a1);
              }
            } else {
              if (i.alongA === 0) {
                if (i.alongB === -1)
                  eventDivide(ev1, b1);
                else if (i.alongB === 0)
                  eventDivide(ev1, i.pt);
                else if (i.alongB === 1)
                  eventDivide(ev1, b2);
              }
              if (i.alongB === 0) {
                if (i.alongA === -1)
                  eventDivide(ev2, a1);
                else if (i.alongA === 0)
                  eventDivide(ev2, i.pt);
                else if (i.alongA === 1)
                  eventDivide(ev2, a2);
              }
            }
            return false;
          }
          var segments = [];
          while (!event_root.isEmpty()) {
            var ev = event_root.getHead();
            if (buildLog)
              buildLog.vert(ev.pt[0]);
            if (ev.isStart) {
              let checkBothIntersections2 = function() {
                if (above) {
                  var eve2 = checkIntersection(ev, above);
                  if (eve2)
                    return eve2;
                }
                if (below)
                  return checkIntersection(ev, below);
                return false;
              };
              var checkBothIntersections = checkBothIntersections2;
              if (buildLog)
                buildLog.segmentNew(ev.seg, ev.primary);
              var surrounding = statusFindSurrounding(ev);
              var above = surrounding.before ? surrounding.before.ev : null;
              var below = surrounding.after ? surrounding.after.ev : null;
              if (buildLog) {
                buildLog.tempStatus(
                  ev.seg,
                  above ? above.seg : false,
                  below ? below.seg : false
                );
              }
              var eve = checkBothIntersections2();
              if (eve) {
                if (selfIntersection) {
                  var toggle;
                  if (ev.seg.myFill.below === null)
                    toggle = true;
                  else
                    toggle = ev.seg.myFill.above !== ev.seg.myFill.below;
                  if (toggle)
                    eve.seg.myFill.above = !eve.seg.myFill.above;
                } else {
                  eve.seg.otherFill = ev.seg.myFill;
                }
                if (buildLog)
                  buildLog.segmentUpdate(eve.seg);
                ev.other.remove();
                ev.remove();
              }
              if (event_root.getHead() !== ev) {
                if (buildLog)
                  buildLog.rewind(ev.seg);
                continue;
              }
              if (selfIntersection) {
                var toggle;
                if (ev.seg.myFill.below === null)
                  toggle = true;
                else
                  toggle = ev.seg.myFill.above !== ev.seg.myFill.below;
                if (!below) {
                  ev.seg.myFill.below = primaryPolyInverted;
                } else {
                  ev.seg.myFill.below = below.seg.myFill.above;
                }
                if (toggle)
                  ev.seg.myFill.above = !ev.seg.myFill.below;
                else
                  ev.seg.myFill.above = ev.seg.myFill.below;
              } else {
                if (ev.seg.otherFill === null) {
                  var inside;
                  if (!below) {
                    inside = ev.primary ? secondaryPolyInverted : primaryPolyInverted;
                  } else {
                    if (ev.primary === below.primary)
                      inside = below.seg.otherFill.above;
                    else
                      inside = below.seg.myFill.above;
                  }
                  ev.seg.otherFill = {
                    above: inside,
                    below: inside
                  };
                }
              }
              if (buildLog) {
                buildLog.status(
                  ev.seg,
                  above ? above.seg : false,
                  below ? below.seg : false
                );
              }
              ev.other.status = surrounding.insert(LinkedList.node({ ev }));
            } else {
              var st = ev.status;
              if (st === null) {
                throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");
              }
              if (status_root.exists(st.prev) && status_root.exists(st.next))
                checkIntersection(st.prev.ev, st.next.ev);
              if (buildLog)
                buildLog.statusRemove(st.ev.seg);
              st.remove();
              if (!ev.primary) {
                var s = ev.seg.myFill;
                ev.seg.myFill = ev.seg.otherFill;
                ev.seg.otherFill = s;
              }
              segments.push(ev.seg);
            }
            event_root.getHead().remove();
          }
          if (buildLog)
            buildLog.done();
          return segments;
        }
        if (!selfIntersection) {
          return {
            calculate: function(segments1, inverted1, segments2, inverted2) {
              segments1.forEach(function(seg) {
                eventAddSegment(segmentCopy(seg.start, seg.end, seg), true);
              });
              segments2.forEach(function(seg) {
                eventAddSegment(segmentCopy(seg.start, seg.end, seg), false);
              });
              return calculate(inverted1, inverted2);
            }
          };
        }
        return {
          addRegion: function(region) {
            var pt1;
            var pt2 = region[region.length - 1];
            for (var i = 0; i < region.length; i++) {
              pt1 = pt2;
              pt2 = region[i];
              var forward = eps.pointsCompare(pt1, pt2);
              if (forward === 0)
                continue;
              eventAddSegment(
                segmentNew(
                  forward < 0 ? pt1 : pt2,
                  forward < 0 ? pt2 : pt1
                ),
                true
              );
            }
          },
          calculate: function(inverted) {
            return calculate(inverted, false);
          }
        };
      }
      module.exports = Intersecter;
    }
  });

  // node_modules/polybooljs/lib/segment-chainer.js
  var require_segment_chainer = __commonJS({
    "node_modules/polybooljs/lib/segment-chainer.js"(exports, module) {
      function SegmentChainer(segments, eps, buildLog) {
        var chains = [];
        var regions = [];
        segments.forEach(function(seg) {
          var pt1 = seg.start;
          var pt2 = seg.end;
          if (eps.pointsSame(pt1, pt2)) {
            console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");
            return;
          }
          if (buildLog)
            buildLog.chainStart(seg);
          var first_match = {
            index: 0,
            matches_head: false,
            matches_pt1: false
          };
          var second_match = {
            index: 0,
            matches_head: false,
            matches_pt1: false
          };
          var next_match = first_match;
          function setMatch(index2, matches_head, matches_pt1) {
            next_match.index = index2;
            next_match.matches_head = matches_head;
            next_match.matches_pt1 = matches_pt1;
            if (next_match === first_match) {
              next_match = second_match;
              return false;
            }
            next_match = null;
            return true;
          }
          for (var i = 0; i < chains.length; i++) {
            var chain = chains[i];
            var head = chain[0];
            var head2 = chain[1];
            var tail = chain[chain.length - 1];
            var tail2 = chain[chain.length - 2];
            if (eps.pointsSame(head, pt1)) {
              if (setMatch(i, true, true))
                break;
            } else if (eps.pointsSame(head, pt2)) {
              if (setMatch(i, true, false))
                break;
            } else if (eps.pointsSame(tail, pt1)) {
              if (setMatch(i, false, true))
                break;
            } else if (eps.pointsSame(tail, pt2)) {
              if (setMatch(i, false, false))
                break;
            }
          }
          if (next_match === first_match) {
            chains.push([pt1, pt2]);
            if (buildLog)
              buildLog.chainNew(pt1, pt2);
            return;
          }
          if (next_match === second_match) {
            if (buildLog)
              buildLog.chainMatch(first_match.index);
            var index = first_match.index;
            var pt = first_match.matches_pt1 ? pt2 : pt1;
            var addToHead = first_match.matches_head;
            var chain = chains[index];
            var grow = addToHead ? chain[0] : chain[chain.length - 1];
            var grow2 = addToHead ? chain[1] : chain[chain.length - 2];
            var oppo = addToHead ? chain[chain.length - 1] : chain[0];
            var oppo2 = addToHead ? chain[chain.length - 2] : chain[1];
            if (eps.pointsCollinear(grow2, grow, pt)) {
              if (addToHead) {
                if (buildLog)
                  buildLog.chainRemoveHead(first_match.index, pt);
                chain.shift();
              } else {
                if (buildLog)
                  buildLog.chainRemoveTail(first_match.index, pt);
                chain.pop();
              }
              grow = grow2;
            }
            if (eps.pointsSame(oppo, pt)) {
              chains.splice(index, 1);
              if (eps.pointsCollinear(oppo2, oppo, grow)) {
                if (addToHead) {
                  if (buildLog)
                    buildLog.chainRemoveTail(first_match.index, grow);
                  chain.pop();
                } else {
                  if (buildLog)
                    buildLog.chainRemoveHead(first_match.index, grow);
                  chain.shift();
                }
              }
              if (buildLog)
                buildLog.chainClose(first_match.index);
              regions.push(chain);
              return;
            }
            if (addToHead) {
              if (buildLog)
                buildLog.chainAddHead(first_match.index, pt);
              chain.unshift(pt);
            } else {
              if (buildLog)
                buildLog.chainAddTail(first_match.index, pt);
              chain.push(pt);
            }
            return;
          }
          function reverseChain(index2) {
            if (buildLog)
              buildLog.chainReverse(index2);
            chains[index2].reverse();
          }
          function appendChain(index1, index2) {
            var chain1 = chains[index1];
            var chain2 = chains[index2];
            var tail3 = chain1[chain1.length - 1];
            var tail22 = chain1[chain1.length - 2];
            var head3 = chain2[0];
            var head22 = chain2[1];
            if (eps.pointsCollinear(tail22, tail3, head3)) {
              if (buildLog)
                buildLog.chainRemoveTail(index1, tail3);
              chain1.pop();
              tail3 = tail22;
            }
            if (eps.pointsCollinear(tail3, head3, head22)) {
              if (buildLog)
                buildLog.chainRemoveHead(index2, head3);
              chain2.shift();
            }
            if (buildLog)
              buildLog.chainJoin(index1, index2);
            chains[index1] = chain1.concat(chain2);
            chains.splice(index2, 1);
          }
          var F = first_match.index;
          var S = second_match.index;
          if (buildLog)
            buildLog.chainConnect(F, S);
          var reverseF = chains[F].length < chains[S].length;
          if (first_match.matches_head) {
            if (second_match.matches_head) {
              if (reverseF) {
                reverseChain(F);
                appendChain(F, S);
              } else {
                reverseChain(S);
                appendChain(S, F);
              }
            } else {
              appendChain(S, F);
            }
          } else {
            if (second_match.matches_head) {
              appendChain(F, S);
            } else {
              if (reverseF) {
                reverseChain(F);
                appendChain(S, F);
              } else {
                reverseChain(S);
                appendChain(F, S);
              }
            }
          }
        });
        return regions;
      }
      module.exports = SegmentChainer;
    }
  });

  // node_modules/polybooljs/lib/segment-selector.js
  var require_segment_selector = __commonJS({
    "node_modules/polybooljs/lib/segment-selector.js"(exports, module) {
      function select(segments, selection, buildLog) {
        var result = [];
        segments.forEach(function(seg) {
          var index = (seg.myFill.above ? 8 : 0) + (seg.myFill.below ? 4 : 0) + (seg.otherFill && seg.otherFill.above ? 2 : 0) + (seg.otherFill && seg.otherFill.below ? 1 : 0);
          if (selection[index] !== 0) {
            result.push({
              id: buildLog ? buildLog.segmentId() : -1,
              start: seg.start,
              end: seg.end,
              myFill: {
                above: selection[index] === 1,
                // 1 if filled above
                below: selection[index] === 2
                // 2 if filled below
              },
              otherFill: null
            });
          }
        });
        if (buildLog)
          buildLog.selected(result);
        return result;
      }
      var SegmentSelector = {
        union: function(segments, buildLog) {
          return select(segments, [
            0,
            2,
            1,
            0,
            2,
            2,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
          ], buildLog);
        },
        intersect: function(segments, buildLog) {
          return select(segments, [
            0,
            0,
            0,
            0,
            0,
            2,
            0,
            2,
            0,
            0,
            1,
            1,
            0,
            2,
            1,
            0
          ], buildLog);
        },
        difference: function(segments, buildLog) {
          return select(segments, [
            0,
            0,
            0,
            0,
            2,
            0,
            2,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            0
          ], buildLog);
        },
        differenceRev: function(segments, buildLog) {
          return select(segments, [
            0,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            0,
            2,
            0,
            0,
            0,
            0
          ], buildLog);
        },
        xor: function(segments, buildLog) {
          return select(segments, [
            0,
            2,
            1,
            0,
            2,
            0,
            0,
            1,
            1,
            0,
            0,
            2,
            0,
            1,
            2,
            0
          ], buildLog);
        }
      };
      module.exports = SegmentSelector;
    }
  });

  // node_modules/polybooljs/lib/geojson.js
  var require_geojson = __commonJS({
    "node_modules/polybooljs/lib/geojson.js"(exports, module) {
      var GeoJSON = {
        // convert a GeoJSON object to a PolyBool polygon
        toPolygon: function(PolyBool, geojson) {
          function GeoPoly(coords) {
            if (coords.length <= 0)
              return PolyBool.segments({ inverted: false, regions: [] });
            function LineString(ls) {
              var reg = ls.slice(0, ls.length - 1);
              return PolyBool.segments({ inverted: false, regions: [reg] });
            }
            var out2 = LineString(coords[0]);
            for (var i2 = 1; i2 < coords.length; i2++)
              out2 = PolyBool.selectDifference(PolyBool.combine(out2, LineString(coords[i2])));
            return out2;
          }
          if (geojson.type === "Polygon") {
            return PolyBool.polygon(GeoPoly(geojson.coordinates));
          } else if (geojson.type === "MultiPolygon") {
            var out = PolyBool.segments({ inverted: false, regions: [] });
            for (var i = 0; i < geojson.coordinates.length; i++)
              out = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));
            return PolyBool.polygon(out);
          }
          throw new Error("PolyBool: Cannot convert GeoJSON object to PolyBool polygon");
        },
        // convert a PolyBool polygon to a GeoJSON object
        fromPolygon: function(PolyBool, eps, poly) {
          poly = PolyBool.polygon(PolyBool.segments(poly));
          function regionInsideRegion(r1, r2) {
            return eps.pointInsideRegion([
              (r1[0][0] + r1[1][0]) * 0.5,
              (r1[0][1] + r1[1][1]) * 0.5
            ], r2);
          }
          function newNode(region2) {
            return {
              region: region2,
              children: []
            };
          }
          var roots = newNode(null);
          function addChild(root, region2) {
            for (var i2 = 0; i2 < root.children.length; i2++) {
              var child = root.children[i2];
              if (regionInsideRegion(region2, child.region)) {
                addChild(child, region2);
                return;
              }
            }
            var node = newNode(region2);
            for (var i2 = 0; i2 < root.children.length; i2++) {
              var child = root.children[i2];
              if (regionInsideRegion(child.region, region2)) {
                node.children.push(child);
                root.children.splice(i2, 1);
                i2--;
              }
            }
            root.children.push(node);
          }
          for (var i = 0; i < poly.regions.length; i++) {
            var region = poly.regions[i];
            if (region.length < 3)
              continue;
            addChild(roots, region);
          }
          function forceWinding(region2, clockwise) {
            var winding = 0;
            var last_x = region2[region2.length - 1][0];
            var last_y = region2[region2.length - 1][1];
            var copy = [];
            for (var i2 = 0; i2 < region2.length; i2++) {
              var curr_x = region2[i2][0];
              var curr_y = region2[i2][1];
              copy.push([curr_x, curr_y]);
              winding += curr_y * last_x - curr_x * last_y;
              last_x = curr_x;
              last_y = curr_y;
            }
            var isclockwise = winding < 0;
            if (isclockwise !== clockwise)
              copy.reverse();
            copy.push([copy[0][0], copy[0][1]]);
            return copy;
          }
          var geopolys = [];
          function addExterior(node) {
            var poly2 = [forceWinding(node.region, false)];
            geopolys.push(poly2);
            for (var i2 = 0; i2 < node.children.length; i2++)
              poly2.push(getInterior(node.children[i2]));
          }
          function getInterior(node) {
            for (var i2 = 0; i2 < node.children.length; i2++)
              addExterior(node.children[i2]);
            return forceWinding(node.region, true);
          }
          for (var i = 0; i < roots.children.length; i++)
            addExterior(roots.children[i]);
          if (geopolys.length <= 0)
            return { type: "Polygon", coordinates: [] };
          if (geopolys.length == 1)
            return { type: "Polygon", coordinates: geopolys[0] };
          return {
            // otherwise, use a GeoJSON MultiPolygon
            type: "MultiPolygon",
            coordinates: geopolys
          };
        }
      };
      module.exports = GeoJSON;
    }
  });

  // node_modules/polybooljs/index.js
  var require_polybooljs = __commonJS({
    "node_modules/polybooljs/index.js"(exports, module) {
      var BuildLog = require_build_log();
      var Epsilon = require_epsilon();
      var Intersecter = require_intersecter();
      var SegmentChainer = require_segment_chainer();
      var SegmentSelector = require_segment_selector();
      var GeoJSON = require_geojson();
      var buildLog = false;
      var epsilon = Epsilon();
      var PolyBool;
      PolyBool = {
        // getter/setter for buildLog
        buildLog: function(bl) {
          if (bl === true)
            buildLog = BuildLog();
          else if (bl === false)
            buildLog = false;
          return buildLog === false ? false : buildLog.list;
        },
        // getter/setter for epsilon
        epsilon: function(v) {
          return epsilon.epsilon(v);
        },
        // core API
        segments: function(poly) {
          var i = Intersecter(true, epsilon, buildLog);
          poly.regions.forEach(i.addRegion);
          return {
            segments: i.calculate(poly.inverted),
            inverted: poly.inverted
          };
        },
        combine: function(segments1, segments2) {
          var i3 = Intersecter(false, epsilon, buildLog);
          return {
            combined: i3.calculate(
              segments1.segments,
              segments1.inverted,
              segments2.segments,
              segments2.inverted
            ),
            inverted1: segments1.inverted,
            inverted2: segments2.inverted
          };
        },
        selectUnion: function(combined) {
          return {
            segments: SegmentSelector.union(combined.combined, buildLog),
            inverted: combined.inverted1 || combined.inverted2
          };
        },
        selectIntersect: function(combined) {
          return {
            segments: SegmentSelector.intersect(combined.combined, buildLog),
            inverted: combined.inverted1 && combined.inverted2
          };
        },
        selectDifference: function(combined) {
          return {
            segments: SegmentSelector.difference(combined.combined, buildLog),
            inverted: combined.inverted1 && !combined.inverted2
          };
        },
        selectDifferenceRev: function(combined) {
          return {
            segments: SegmentSelector.differenceRev(combined.combined, buildLog),
            inverted: !combined.inverted1 && combined.inverted2
          };
        },
        selectXor: function(combined) {
          return {
            segments: SegmentSelector.xor(combined.combined, buildLog),
            inverted: combined.inverted1 !== combined.inverted2
          };
        },
        polygon: function(segments) {
          return {
            regions: SegmentChainer(segments.segments, epsilon, buildLog),
            inverted: segments.inverted
          };
        },
        // GeoJSON converters
        polygonFromGeoJSON: function(geojson) {
          return GeoJSON.toPolygon(PolyBool, geojson);
        },
        polygonToGeoJSON: function(poly) {
          return GeoJSON.fromPolygon(PolyBool, epsilon, poly);
        },
        // helper functions for common operations
        union: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectUnion);
        },
        intersect: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectIntersect);
        },
        difference: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectDifference);
        },
        differenceRev: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectDifferenceRev);
        },
        xor: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectXor);
        }
      };
      function operate(poly1, poly2, selector) {
        var seg1 = PolyBool.segments(poly1);
        var seg2 = PolyBool.segments(poly2);
        var comb = PolyBool.combine(seg1, seg2);
        var seg3 = selector(comb);
        return PolyBool.polygon(seg3);
      }
      if (typeof window === "object")
        window.PolyBool = PolyBool;
      module.exports = PolyBool;
    }
  });

  // node_modules/point-in-polygon/nested.js
  var require_nested = __commonJS({
    "node_modules/point-in-polygon/nested.js"(exports, module) {
      module.exports = function pointInPolygonNested(point, vs, start, end) {
        var x = point[0], y = point[1];
        var inside = false;
        if (start === void 0) start = 0;
        if (end === void 0) end = vs.length;
        var len = end - start;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[i + start][0], yi = vs[i + start][1];
          var xj = vs[j + start][0], yj = vs[j + start][1];
          var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      };
    }
  });

  // src/lib/polygon.js
  var require_polygon = __commonJS({
    "src/lib/polygon.js"(exports, module) {
      "use strict";
      var dot = require_matrix().dot;
      var BADNUM = require_numerical().BADNUM;
      var polygon = module.exports = {};
      polygon.tester = function tester(ptsIn) {
        var pts = ptsIn.slice();
        var xmin = pts[0][0];
        var xmax = xmin;
        var ymin = pts[0][1];
        var ymax = ymin;
        var i;
        if (pts[pts.length - 1][0] !== pts[0][0] || pts[pts.length - 1][1] !== pts[0][1]) {
          pts.push(pts[0]);
        }
        for (i = 1; i < pts.length; i++) {
          xmin = Math.min(xmin, pts[i][0]);
          xmax = Math.max(xmax, pts[i][0]);
          ymin = Math.min(ymin, pts[i][1]);
          ymax = Math.max(ymax, pts[i][1]);
        }
        var isRect = false;
        var rectFirstEdgeTest;
        if (pts.length === 5) {
          if (pts[0][0] === pts[1][0]) {
            if (pts[2][0] === pts[3][0] && pts[0][1] === pts[3][1] && pts[1][1] === pts[2][1]) {
              isRect = true;
              rectFirstEdgeTest = function(pt) {
                return pt[0] === pts[0][0];
              };
            }
          } else if (pts[0][1] === pts[1][1]) {
            if (pts[2][1] === pts[3][1] && pts[0][0] === pts[3][0] && pts[1][0] === pts[2][0]) {
              isRect = true;
              rectFirstEdgeTest = function(pt) {
                return pt[1] === pts[0][1];
              };
            }
          }
        }
        function rectContains(pt, omitFirstEdge) {
          var x = pt[0];
          var y = pt[1];
          if (x === BADNUM || x < xmin || x > xmax || y === BADNUM || y < ymin || y > ymax) {
            return false;
          }
          if (omitFirstEdge && rectFirstEdgeTest(pt)) return false;
          return true;
        }
        function contains(pt, omitFirstEdge) {
          var x = pt[0];
          var y = pt[1];
          if (x === BADNUM || x < xmin || x > xmax || y === BADNUM || y < ymin || y > ymax) {
            return false;
          }
          var imax = pts.length;
          var x1 = pts[0][0];
          var y1 = pts[0][1];
          var crossings = 0;
          var i2;
          var x0;
          var y0;
          var xmini;
          var ycross;
          for (i2 = 1; i2 < imax; i2++) {
            x0 = x1;
            y0 = y1;
            x1 = pts[i2][0];
            y1 = pts[i2][1];
            xmini = Math.min(x0, x1);
            if (x < xmini || x > Math.max(x0, x1) || y > Math.max(y0, y1)) {
              continue;
            } else if (y < Math.min(y0, y1)) {
              if (x !== xmini) crossings++;
            } else {
              if (x1 === x0) ycross = y;
              else ycross = y0 + (x - x0) * (y1 - y0) / (x1 - x0);
              if (y === ycross) {
                if (i2 === 1 && omitFirstEdge) return false;
                return true;
              }
              if (y <= ycross && x !== xmini) crossings++;
            }
          }
          return crossings % 2 === 1;
        }
        var degenerate = true;
        var lastPt = pts[0];
        for (i = 1; i < pts.length; i++) {
          if (lastPt[0] !== pts[i][0] || lastPt[1] !== pts[i][1]) {
            degenerate = false;
            break;
          }
        }
        return {
          xmin,
          xmax,
          ymin,
          ymax,
          pts,
          contains: isRect ? rectContains : contains,
          isRect,
          degenerate
        };
      };
      polygon.isSegmentBent = function isSegmentBent(pts, start, end, tolerance) {
        var startPt = pts[start];
        var segment = [pts[end][0] - startPt[0], pts[end][1] - startPt[1]];
        var segmentSquared = dot(segment, segment);
        var segmentLen = Math.sqrt(segmentSquared);
        var unitPerp = [-segment[1] / segmentLen, segment[0] / segmentLen];
        var i;
        var part;
        var partParallel;
        for (i = start + 1; i < end; i++) {
          part = [pts[i][0] - startPt[0], pts[i][1] - startPt[1]];
          partParallel = dot(part, segment);
          if (partParallel < 0 || partParallel > segmentSquared || Math.abs(dot(part, unitPerp)) > tolerance) return true;
        }
        return false;
      };
      polygon.filter = function filter(pts, tolerance) {
        var ptsFiltered = [pts[0]];
        var doneRawIndex = 0;
        var doneFilteredIndex = 0;
        function addPt(pt) {
          pts.push(pt);
          var prevFilterLen = ptsFiltered.length;
          var iLast = doneRawIndex;
          ptsFiltered.splice(doneFilteredIndex + 1);
          for (var i = iLast + 1; i < pts.length; i++) {
            if (i === pts.length - 1 || polygon.isSegmentBent(pts, iLast, i + 1, tolerance)) {
              ptsFiltered.push(pts[i]);
              if (ptsFiltered.length < prevFilterLen - 2) {
                doneRawIndex = i;
                doneFilteredIndex = ptsFiltered.length - 1;
              }
              iLast = i;
            }
          }
        }
        if (pts.length > 1) {
          var lastPt = pts.pop();
          addPt(lastPt);
        }
        return {
          addPt,
          raw: pts,
          filtered: ptsFiltered
        };
      };
    }
  });

  // src/components/selections/constants.js
  var require_constants7 = __commonJS({
    "src/components/selections/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // max pixels off straight before a lasso select line counts as bent
        BENDPX: 1.5,
        // smallest dimension allowed for a select box
        MINSELECT: 12,
        // throttling limit (ms) for selectPoints calls
        SELECTDELAY: 100,
        // cache ID suffix for throttle
        SELECTID: "-select"
      };
    }
  });

  // src/components/selections/select.js
  var require_select = __commonJS({
    "src/components/selections/select.js"(exports, module) {
      "use strict";
      var polybool = require_polybooljs();
      var pointInPolygon = require_nested();
      var Registry = require_registry();
      var dashStyle = require_drawing().dashStyle;
      var Color = require_color();
      var Fx = require_fx();
      var makeEventData = require_helpers2().makeEventData;
      var dragHelpers = require_helpers5();
      var freeMode = dragHelpers.freeMode;
      var rectMode = dragHelpers.rectMode;
      var drawMode = dragHelpers.drawMode;
      var openMode = dragHelpers.openMode;
      var selectMode = dragHelpers.selectMode;
      var shapeHelpers = require_helpers8();
      var shapeConstants = require_constants5();
      var displayOutlines = require_display_outlines();
      var clearOutline = require_handle_outline().clearOutline;
      var newShapeHelpers = require_helpers7();
      var handleEllipse = newShapeHelpers.handleEllipse;
      var readPaths = newShapeHelpers.readPaths;
      var newShapes = require_newshapes().newShapes;
      var newSelections = require_newselections();
      var activateLastSelection = require_draw3().activateLastSelection;
      var Lib = require_lib();
      var ascending = Lib.sorterAsc;
      var libPolygon = require_polygon();
      var throttle = require_throttle();
      var getFromId = require_axis_ids().getFromId;
      var clearGlCanvases = require_clear_gl_canvases();
      var redrawReglTraces = require_subroutines().redrawReglTraces;
      var constants = require_constants7();
      var MINSELECT = constants.MINSELECT;
      var filteredPolygon = libPolygon.filter;
      var polygonTester = libPolygon.tester;
      var helpers = require_helpers6();
      var p2r = helpers.p2r;
      var axValue = helpers.axValue;
      var getTransform = helpers.getTransform;
      function hasSubplot(dragOptions) {
        return dragOptions.subplot !== void 0;
      }
      function prepSelect(evt, startX, startY, dragOptions, mode) {
        var isCartesian = !hasSubplot(dragOptions);
        var isFreeMode = freeMode(mode);
        var isRectMode = rectMode(mode);
        var isOpenMode = openMode(mode);
        var isDrawMode = drawMode(mode);
        var isSelectMode = selectMode(mode);
        var isLine = mode === "drawline";
        var isEllipse = mode === "drawcircle";
        var isLineOrEllipse = isLine || isEllipse;
        var gd = dragOptions.gd;
        var fullLayout = gd._fullLayout;
        var immediateSelect = isSelectMode && fullLayout.newselection.mode === "immediate" && isCartesian;
        var zoomLayer = fullLayout._zoomlayer;
        var dragBBox = dragOptions.element.getBoundingClientRect();
        var plotinfo = dragOptions.plotinfo;
        var transform = getTransform(plotinfo);
        var x0 = startX - dragBBox.left;
        var y0 = startY - dragBBox.top;
        fullLayout._calcInverseTransform(gd);
        var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);
        x0 = transformedCoords[0];
        y0 = transformedCoords[1];
        var scaleX = fullLayout._invScaleX;
        var scaleY = fullLayout._invScaleY;
        var x1 = x0;
        var y1 = y0;
        var path0 = "M" + x0 + "," + y0;
        var xAxis = dragOptions.xaxes[0];
        var yAxis = dragOptions.yaxes[0];
        var pw = xAxis._length;
        var ph = yAxis._length;
        var subtract = evt.altKey && !(drawMode(mode) && isOpenMode);
        var filterPoly, selectionTesters, mergedPolygons, currentPolygon;
        var i, searchInfo, eventData;
        coerceSelectionsCache(evt, gd, dragOptions);
        if (isFreeMode) {
          filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);
        }
        var outlines = zoomLayer.selectAll("path.select-outline-" + plotinfo.id).data([1]);
        var newStyle = isDrawMode ? fullLayout.newshape : fullLayout.newselection;
        if (isDrawMode) {
          dragOptions.hasText = newStyle.label.text || newStyle.label.texttemplate;
        }
        var fillC = isDrawMode && !isOpenMode ? newStyle.fillcolor : "rgba(0,0,0,0)";
        var strokeC = newStyle.line.color || (isCartesian ? Color.contrast(gd._fullLayout.plot_bgcolor) : "#7f7f7f");
        outlines.enter().append("path").attr("class", "select-outline select-outline-" + plotinfo.id).style({
          opacity: isDrawMode ? newStyle.opacity / 2 : 1,
          "stroke-dasharray": dashStyle(newStyle.line.dash, newStyle.line.width),
          "stroke-width": newStyle.line.width + "px",
          "shape-rendering": "crispEdges"
        }).call(Color.stroke, strokeC).call(Color.fill, fillC).attr("fill-rule", "evenodd").classed("cursor-move", isDrawMode ? true : false).attr("transform", transform).attr("d", path0 + "Z");
        var corners = zoomLayer.append("path").attr("class", "zoombox-corners").style({
          fill: Color.background,
          stroke: Color.defaultLine,
          "stroke-width": 1
        }).attr("transform", transform).attr("d", "M0,0Z");
        if (isDrawMode && dragOptions.hasText) {
          var shapeGroup = zoomLayer.select(".label-temp");
          if (shapeGroup.empty()) {
            shapeGroup = zoomLayer.append("g").classed("label-temp", true).classed("select-outline", true).style({ opacity: 0.8 });
          }
        }
        var throttleID = fullLayout._uid + constants.SELECTID;
        var selection = [];
        var searchTraces = determineSearchTraces(
          gd,
          dragOptions.xaxes,
          dragOptions.yaxes,
          dragOptions.subplot
        );
        if (immediateSelect && !evt.shiftKey) {
          dragOptions._clearSubplotSelections = function() {
            if (!isCartesian) return;
            var xRef = xAxis._id;
            var yRef = yAxis._id;
            deselectSubplot(gd, xRef, yRef, searchTraces);
            var selections = (gd.layout || {}).selections || [];
            var list = [];
            var selectionErased = false;
            for (var q = 0; q < selections.length; q++) {
              var s = fullLayout.selections[q];
              if (!s || s.xref !== xRef || s.yref !== yRef) {
                list.push(selections[q]);
              } else {
                selectionErased = true;
              }
            }
            if (selectionErased) {
              gd._fullLayout._noEmitSelectedAtStart = true;
              Registry.call("_guiRelayout", gd, {
                selections: list
              });
            }
          };
        }
        var fillRangeItems = getFillRangeItems(dragOptions);
        dragOptions.moveFn = function(dx0, dy0) {
          if (dragOptions._clearSubplotSelections) {
            dragOptions._clearSubplotSelections();
            dragOptions._clearSubplotSelections = void 0;
          }
          x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));
          y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));
          var dx = Math.abs(x1 - x0);
          var dy = Math.abs(y1 - y0);
          if (isRectMode) {
            var direction;
            var start, end;
            if (isSelectMode) {
              var q = fullLayout.selectdirection;
              if (q === "any") {
                if (dy < Math.min(dx * 0.6, MINSELECT)) {
                  direction = "h";
                } else if (dx < Math.min(dy * 0.6, MINSELECT)) {
                  direction = "v";
                } else {
                  direction = "d";
                }
              } else {
                direction = q;
              }
              switch (direction) {
                case "h":
                  start = isEllipse ? ph / 2 : 0;
                  end = ph;
                  break;
                case "v":
                  start = isEllipse ? pw / 2 : 0;
                  end = pw;
                  break;
              }
            }
            if (isDrawMode) {
              switch (fullLayout.newshape.drawdirection) {
                case "vertical":
                  direction = "h";
                  start = isEllipse ? ph / 2 : 0;
                  end = ph;
                  break;
                case "horizontal":
                  direction = "v";
                  start = isEllipse ? pw / 2 : 0;
                  end = pw;
                  break;
                case "ortho":
                  if (dx < dy) {
                    direction = "h";
                    start = y0;
                    end = y1;
                  } else {
                    direction = "v";
                    start = x0;
                    end = x1;
                  }
                  break;
                default:
                  direction = "d";
              }
            }
            if (direction === "h") {
              currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x1, start], [x1, end]) : (
                // using x1 instead of x0 allows adjusting the line while drawing
                [[x0, start], [x0, end], [x1, end], [x1, start]]
              );
              currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);
              currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);
              currentPolygon.ymin = Math.min(start, end);
              currentPolygon.ymax = Math.max(start, end);
              corners.attr("d", "M" + currentPolygon.xmin + "," + (y0 - MINSELECT) + "h-4v" + 2 * MINSELECT + "h4ZM" + (currentPolygon.xmax - 1) + "," + (y0 - MINSELECT) + "h4v" + 2 * MINSELECT + "h-4Z");
            } else if (direction === "v") {
              currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [start, y1], [end, y1]) : (
                // using y1 instead of y0 allows adjusting the line while drawing
                [[start, y0], [start, y1], [end, y1], [end, y0]]
              );
              currentPolygon.xmin = Math.min(start, end);
              currentPolygon.xmax = Math.max(start, end);
              currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);
              currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);
              corners.attr("d", "M" + (x0 - MINSELECT) + "," + currentPolygon.ymin + "v-4h" + 2 * MINSELECT + "v4ZM" + (x0 - MINSELECT) + "," + (currentPolygon.ymax - 1) + "v4h" + 2 * MINSELECT + "v-4Z");
            } else if (direction === "d") {
              currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x0, y0], [x1, y1]) : [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];
              currentPolygon.xmin = Math.min(x0, x1);
              currentPolygon.xmax = Math.max(x0, x1);
              currentPolygon.ymin = Math.min(y0, y1);
              currentPolygon.ymax = Math.max(y0, y1);
              corners.attr("d", "M0,0Z");
            }
          } else if (isFreeMode) {
            filterPoly.addPt([x1, y1]);
            currentPolygon = filterPoly.filtered;
          }
          if (dragOptions.selectionDefs && dragOptions.selectionDefs.length) {
            mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);
            currentPolygon.subtract = subtract;
            selectionTesters = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));
          } else {
            mergedPolygons = [currentPolygon];
            selectionTesters = polygonTester(currentPolygon);
          }
          displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);
          if (isSelectMode) {
            var _res = reselect(gd, false);
            var extraPoints = _res.eventData ? _res.eventData.points.slice() : [];
            _res = reselect(gd, false, selectionTesters, searchTraces, dragOptions);
            selectionTesters = _res.selectionTesters;
            eventData = _res.eventData;
            var poly;
            if (filterPoly) {
              poly = filterPoly.filtered;
            } else {
              poly = castMultiPolygon(mergedPolygons);
            }
            throttle.throttle(
              throttleID,
              constants.SELECTDELAY,
              function() {
                selection = _doSelect(selectionTesters, searchTraces);
                var newPoints = selection.slice();
                for (var w = 0; w < extraPoints.length; w++) {
                  var p = extraPoints[w];
                  var found = false;
                  for (var u = 0; u < newPoints.length; u++) {
                    if (newPoints[u].curveNumber === p.curveNumber && newPoints[u].pointNumber === p.pointNumber) {
                      found = true;
                      break;
                    }
                  }
                  if (!found) newPoints.push(p);
                }
                if (newPoints.length) {
                  if (!eventData) eventData = {};
                  eventData.points = newPoints;
                }
                fillRangeItems(eventData, poly);
                emitSelecting(gd, eventData);
              }
            );
          }
        };
        dragOptions.clickFn = function(numClicks, evt2) {
          corners.remove();
          if (gd._fullLayout._activeShapeIndex >= 0) {
            gd._fullLayout._deactivateShape(gd);
            return;
          }
          if (isDrawMode) return;
          var clickmode = fullLayout.clickmode;
          throttle.done(throttleID).then(function() {
            throttle.clear(throttleID);
            if (numClicks === 2) {
              outlines.remove();
              for (i = 0; i < searchTraces.length; i++) {
                searchInfo = searchTraces[i];
                searchInfo._module.selectPoints(searchInfo, false);
              }
              updateSelectedState(gd, searchTraces);
              clearSelectionsCache(dragOptions);
              emitDeselect(gd);
              if (searchTraces.length) {
                var clickedXaxis = searchTraces[0].xaxis;
                var clickedYaxis = searchTraces[0].yaxis;
                if (clickedXaxis && clickedYaxis) {
                  var subSelections = [];
                  var allSelections = gd._fullLayout.selections;
                  for (var k = 0; k < allSelections.length; k++) {
                    var s = allSelections[k];
                    if (!s) continue;
                    if (s.xref !== clickedXaxis._id || s.yref !== clickedYaxis._id) {
                      subSelections.push(s);
                    }
                  }
                  if (subSelections.length < allSelections.length) {
                    gd._fullLayout._noEmitSelectedAtStart = true;
                    Registry.call("_guiRelayout", gd, {
                      selections: subSelections
                    });
                  }
                }
              }
            } else {
              if (clickmode.indexOf("select") > -1) {
                selectOnClick(
                  evt2,
                  gd,
                  dragOptions.xaxes,
                  dragOptions.yaxes,
                  dragOptions.subplot,
                  dragOptions,
                  outlines
                );
              }
              if (clickmode === "event") {
                emitSelected(gd, void 0);
              }
            }
            Fx.click(gd, evt2, plotinfo.id);
          }).catch(Lib.error);
        };
        dragOptions.doneFn = function() {
          corners.remove();
          throttle.done(throttleID).then(function() {
            throttle.clear(throttleID);
            if (!immediateSelect && currentPolygon && dragOptions.selectionDefs) {
              currentPolygon.subtract = subtract;
              dragOptions.selectionDefs.push(currentPolygon);
              dragOptions.mergedPolygons.length = 0;
              [].push.apply(dragOptions.mergedPolygons, mergedPolygons);
            }
            if (immediateSelect || isDrawMode) {
              clearSelectionsCache(dragOptions, immediateSelect);
            }
            if (dragOptions.doneFnCompleted) {
              dragOptions.doneFnCompleted(selection);
            }
            if (isSelectMode) {
              emitSelected(gd, eventData);
            }
          }).catch(Lib.error);
        };
      }
      function selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {
        var hoverData = gd._hoverdata;
        var fullLayout = gd._fullLayout;
        var clickmode = fullLayout.clickmode;
        var sendEvents = clickmode.indexOf("event") > -1;
        var selection = [];
        var searchTraces, searchInfo, currentSelectionDef, selectionTesters, traceSelection;
        var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;
        if (isHoverDataSet(hoverData)) {
          coerceSelectionsCache(evt, gd, dragOptions);
          searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);
          var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);
          var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0;
          if (isBinnedTrace ? isOnlyThisBinSelected(searchTraces, clickedPtInfo) : isOnlyOnePointSelected(searchTraces) && (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {
            if (polygonOutlines) polygonOutlines.remove();
            for (i = 0; i < searchTraces.length; i++) {
              searchInfo = searchTraces[i];
              searchInfo._module.selectPoints(searchInfo, false);
            }
            updateSelectedState(gd, searchTraces);
            clearSelectionsCache(dragOptions);
            if (sendEvents) {
              emitDeselect(gd);
            }
          } else {
            subtract = evt.shiftKey && (pointOrBinSelected !== void 0 ? pointOrBinSelected : isPointOrBinSelected(clickedPtInfo));
            currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);
            var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);
            selectionTesters = multiTester(allSelectionDefs, selectionTesters);
            for (i = 0; i < searchTraces.length; i++) {
              traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTesters);
              thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);
              if (selection.length) {
                for (var j = 0; j < thisTracesSelection.length; j++) {
                  selection.push(thisTracesSelection[j]);
                }
              } else selection = thisTracesSelection;
            }
            eventData = { points: selection };
            updateSelectedState(gd, searchTraces, eventData);
            if (currentSelectionDef && dragOptions) {
              dragOptions.selectionDefs.push(currentSelectionDef);
            }
            if (polygonOutlines) {
              var polygons = dragOptions.mergedPolygons;
              var isOpenMode = openMode(dragOptions.dragmode);
              displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);
            }
            if (sendEvents) {
              emitSelected(gd, eventData);
            }
          }
        }
      }
      function newPointSelectionDef(pointNumber, searchInfo, subtract) {
        return {
          pointNumber,
          searchInfo,
          subtract: !!subtract
        };
      }
      function isPointSelectionDef(o) {
        return "pointNumber" in o && "searchInfo" in o;
      }
      function newPointNumTester(pointSelectionDef) {
        return {
          xmin: 0,
          xmax: 0,
          ymin: 0,
          ymax: 0,
          pts: [],
          contains: function(pt, omitFirstEdge, pointNumber, searchInfo) {
            var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace.index;
            var idxActualTrace = searchInfo.cd[0].trace.index;
            return idxActualTrace === idxWantedTrace && pointNumber === pointSelectionDef.pointNumber;
          },
          isRect: false,
          degenerate: false,
          subtract: !!pointSelectionDef.subtract
        };
      }
      function multiTester(list) {
        if (!list.length) return;
        var testers = [];
        var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];
        var xmax = xmin;
        var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];
        var ymax = ymin;
        for (var i = 0; i < list.length; i++) {
          if (isPointSelectionDef(list[i])) {
            testers.push(newPointNumTester(list[i]));
          } else {
            var tester = polygonTester(list[i]);
            tester.subtract = !!list[i].subtract;
            testers.push(tester);
            xmin = Math.min(xmin, tester.xmin);
            xmax = Math.max(xmax, tester.xmax);
            ymin = Math.min(ymin, tester.ymin);
            ymax = Math.max(ymax, tester.ymax);
          }
        }
        function contains(pt, arg, pointNumber, searchInfo) {
          var contained = false;
          for (var i2 = 0; i2 < testers.length; i2++) {
            if (testers[i2].contains(pt, arg, pointNumber, searchInfo)) {
              contained = !testers[i2].subtract;
            }
          }
          return contained;
        }
        return {
          xmin,
          xmax,
          ymin,
          ymax,
          pts: [],
          contains,
          isRect: false,
          degenerate: false
        };
      }
      function coerceSelectionsCache(evt, gd, dragOptions) {
        var fullLayout = gd._fullLayout;
        var plotinfo = dragOptions.plotinfo;
        var dragmode = dragOptions.dragmode;
        var selectingOnSameSubplot = fullLayout._lastSelectedSubplot && fullLayout._lastSelectedSubplot === plotinfo.id;
        var hasModifierKey = (evt.shiftKey || evt.altKey) && !(drawMode(dragmode) && openMode(dragmode));
        if (selectingOnSameSubplot && hasModifierKey && plotinfo.selection && plotinfo.selection.selectionDefs && !dragOptions.selectionDefs) {
          dragOptions.selectionDefs = plotinfo.selection.selectionDefs;
          dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;
        } else if (!hasModifierKey || !plotinfo.selection) {
          clearSelectionsCache(dragOptions);
        }
        if (!selectingOnSameSubplot) {
          clearOutline(gd);
          fullLayout._lastSelectedSubplot = plotinfo.id;
        }
      }
      function hasActiveShape(gd) {
        return gd._fullLayout._activeShapeIndex >= 0;
      }
      function hasActiveSelection(gd) {
        return gd._fullLayout._activeSelectionIndex >= 0;
      }
      function clearSelectionsCache(dragOptions, immediateSelect) {
        var dragmode = dragOptions.dragmode;
        var plotinfo = dragOptions.plotinfo;
        var gd = dragOptions.gd;
        if (hasActiveShape(gd)) {
          gd._fullLayout._deactivateShape(gd);
        }
        if (hasActiveSelection(gd)) {
          gd._fullLayout._deactivateSelection(gd);
        }
        var fullLayout = gd._fullLayout;
        var zoomLayer = fullLayout._zoomlayer;
        var isDrawMode = drawMode(dragmode);
        var isSelectMode = selectMode(dragmode);
        if (isDrawMode || isSelectMode) {
          var outlines = zoomLayer.selectAll(".select-outline-" + plotinfo.id);
          if (outlines && gd._fullLayout._outlining) {
            var shapes;
            if (isDrawMode) {
              shapes = newShapes(outlines, dragOptions);
            }
            if (shapes) {
              Registry.call("_guiRelayout", gd, {
                shapes
              });
            }
            var selections;
            if (isSelectMode && !hasSubplot(dragOptions)) {
              selections = newSelections(outlines, dragOptions);
            }
            if (selections) {
              gd._fullLayout._noEmitSelectedAtStart = true;
              Registry.call("_guiRelayout", gd, {
                selections
              }).then(function() {
                if (immediateSelect) {
                  activateLastSelection(gd);
                }
              });
            }
            gd._fullLayout._outlining = false;
          }
        }
        plotinfo.selection = {};
        plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];
        plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];
      }
      function getAxId(ax) {
        return ax._id;
      }
      function determineSearchTraces(gd, xAxes, yAxes, subplot) {
        if (!gd.calcdata) return [];
        var searchTraces = [];
        var xAxisIds = xAxes.map(getAxId);
        var yAxisIds = yAxes.map(getAxId);
        var cd, trace, i;
        for (i = 0; i < gd.calcdata.length; i++) {
          cd = gd.calcdata[i];
          trace = cd[0].trace;
          if (trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;
          if (hasSubplot({ subplot }) && (trace.subplot === subplot || trace.geo === subplot)) {
            searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));
          } else if (trace.type === "splom") {
            if (trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {
              var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);
              info.scene = gd._fullLayout._splomScenes[trace.uid];
              searchTraces.push(info);
            }
          } else if (trace.type === "sankey") {
            var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);
            searchTraces.push(sankeyInfo);
          } else {
            if (xAxisIds.indexOf(trace.xaxis) === -1 && (!trace._xA || !trace._xA.overlaying)) continue;
            if (yAxisIds.indexOf(trace.yaxis) === -1 && (!trace._yA || !trace._yA.overlaying)) continue;
            searchTraces.push(createSearchInfo(
              trace._module,
              cd,
              getFromId(gd, trace.xaxis),
              getFromId(gd, trace.yaxis)
            ));
          }
        }
        return searchTraces;
      }
      function createSearchInfo(module2, calcData, xaxis, yaxis) {
        return {
          _module: module2,
          cd: calcData,
          xaxis,
          yaxis
        };
      }
      function isHoverDataSet(hoverData) {
        return hoverData && Array.isArray(hoverData) && hoverData[0].hoverOnBox !== true;
      }
      function extractClickedPtInfo(hoverData, searchTraces) {
        var hoverDatum = hoverData[0];
        var pointNumber = -1;
        var pointNumbers = [];
        var searchInfo, i;
        for (i = 0; i < searchTraces.length; i++) {
          searchInfo = searchTraces[i];
          if (hoverDatum.fullData.index === searchInfo.cd[0].trace.index) {
            if (hoverDatum.hoverOnBox === true) {
              break;
            }
            if (hoverDatum.pointNumber !== void 0) {
              pointNumber = hoverDatum.pointNumber;
            } else if (hoverDatum.binNumber !== void 0) {
              pointNumber = hoverDatum.binNumber;
              pointNumbers = hoverDatum.pointNumbers;
            }
            break;
          }
        }
        return {
          pointNumber,
          pointNumbers,
          searchInfo
        };
      }
      function isPointOrBinSelected(clickedPtInfo) {
        var trace = clickedPtInfo.searchInfo.cd[0].trace;
        var ptNum = clickedPtInfo.pointNumber;
        var ptNums = clickedPtInfo.pointNumbers;
        var ptNumsSet = ptNums.length > 0;
        var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum;
        return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;
      }
      function isOnlyThisBinSelected(searchTraces, clickedPtInfo) {
        var tracesWithSelectedPts = [];
        var searchInfo, trace, isSameTrace, i;
        for (i = 0; i < searchTraces.length; i++) {
          searchInfo = searchTraces[i];
          if (searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {
            tracesWithSelectedPts.push(searchInfo);
          }
        }
        if (tracesWithSelectedPts.length === 1) {
          isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;
          if (isSameTrace) {
            trace = clickedPtInfo.searchInfo.cd[0].trace;
            if (trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {
              for (i = 0; i < clickedPtInfo.pointNumbers.length; i++) {
                if (trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {
                  return false;
                }
              }
              return true;
            }
          }
        }
        return false;
      }
      function isOnlyOnePointSelected(searchTraces) {
        var len = 0;
        var searchInfo, trace, i;
        for (i = 0; i < searchTraces.length; i++) {
          searchInfo = searchTraces[i];
          trace = searchInfo.cd[0].trace;
          if (trace.selectedpoints) {
            if (trace.selectedpoints.length > 1) return false;
            len += trace.selectedpoints.length;
            if (len > 1) return false;
          }
        }
        return len === 1;
      }
      function updateSelectedState(gd, searchTraces, eventData) {
        var i;
        for (i = 0; i < searchTraces.length; i++) {
          var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;
          var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};
          if (tracePreGUI.selectedpoints === void 0) {
            tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;
          }
        }
        var trace;
        if (eventData) {
          var pts = eventData.points || [];
          for (i = 0; i < searchTraces.length; i++) {
            trace = searchTraces[i].cd[0].trace;
            trace._input.selectedpoints = trace._fullInput.selectedpoints = [];
            if (trace._fullInput !== trace) trace.selectedpoints = [];
          }
          for (var k = 0; k < pts.length; k++) {
            var pt = pts[k];
            var data = pt.data;
            var fullData = pt.fullData;
            var pointIndex = pt.pointIndex;
            var pointIndices = pt.pointIndices;
            if (pointIndices) {
              [].push.apply(data.selectedpoints, pointIndices);
              if (trace._fullInput !== trace) {
                [].push.apply(fullData.selectedpoints, pointIndices);
              }
            } else {
              data.selectedpoints.push(pointIndex);
              if (trace._fullInput !== trace) {
                fullData.selectedpoints.push(pointIndex);
              }
            }
          }
        } else {
          for (i = 0; i < searchTraces.length; i++) {
            trace = searchTraces[i].cd[0].trace;
            delete trace.selectedpoints;
            delete trace._input.selectedpoints;
            if (trace._fullInput !== trace) {
              delete trace._fullInput.selectedpoints;
            }
          }
        }
        updateReglSelectedState(gd, searchTraces);
      }
      function updateReglSelectedState(gd, searchTraces) {
        var hasRegl = false;
        for (var i = 0; i < searchTraces.length; i++) {
          var searchInfo = searchTraces[i];
          var cd = searchInfo.cd;
          if (Registry.traceIs(cd[0].trace, "regl")) {
            hasRegl = true;
          }
          var _module = searchInfo._module;
          var fn = _module.styleOnSelect || _module.style;
          if (fn) {
            fn(gd, cd, cd[0].node3);
            if (cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);
          }
        }
        if (hasRegl) {
          clearGlCanvases(gd);
          redrawReglTraces(gd);
        }
      }
      function mergePolygons(list, poly, subtract) {
        var fn = subtract ? polybool.difference : polybool.union;
        var res = fn({
          regions: list
        }, {
          regions: [poly]
        });
        var allPolygons = res.regions.reverse();
        for (var i = 0; i < allPolygons.length; i++) {
          var polygon = allPolygons[i];
          polygon.subtract = getSubtract(polygon, allPolygons.slice(0, i));
        }
        return allPolygons;
      }
      function fillSelectionItem(selection, searchInfo) {
        if (Array.isArray(selection)) {
          var cd = searchInfo.cd;
          var trace = searchInfo.cd[0].trace;
          for (var i = 0; i < selection.length; i++) {
            selection[i] = makeEventData(selection[i], trace, cd);
          }
        }
        return selection;
      }
      function convertPoly(polygonsIn, isOpenMode) {
        var polygonsOut = [];
        for (var i = 0; i < polygonsIn.length; i++) {
          polygonsOut[i] = [];
          for (var j = 0; j < polygonsIn[i].length; j++) {
            polygonsOut[i][j] = [];
            polygonsOut[i][j][0] = j ? "L" : "M";
            for (var k = 0; k < polygonsIn[i][j].length; k++) {
              polygonsOut[i][j].push(
                polygonsIn[i][j][k]
              );
            }
          }
          if (!isOpenMode) {
            polygonsOut[i].push([
              "Z",
              polygonsOut[i][0][1],
              // initial x
              polygonsOut[i][0][2]
              // initial y
            ]);
          }
        }
        return polygonsOut;
      }
      function _doSelect(selectionTesters, searchTraces) {
        var allSelections = [];
        var thisSelection;
        var traceSelections = [];
        var traceSelection;
        for (var i = 0; i < searchTraces.length; i++) {
          var searchInfo = searchTraces[i];
          traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTesters);
          traceSelections.push(traceSelection);
          thisSelection = fillSelectionItem(traceSelection, searchInfo);
          allSelections = allSelections.concat(thisSelection);
        }
        return allSelections;
      }
      function reselect(gd, mayEmitSelected, selectionTesters, searchTraces, dragOptions) {
        var hadSearchTraces = !!searchTraces;
        var plotinfo, xRef, yRef;
        if (dragOptions) {
          plotinfo = dragOptions.plotinfo;
          xRef = dragOptions.xaxes[0]._id;
          yRef = dragOptions.yaxes[0]._id;
        }
        var allSelections = [];
        var allSearchTraces = [];
        var layoutPolygons = getLayoutPolygons(gd);
        var fullLayout = gd._fullLayout;
        if (plotinfo) {
          var zoomLayer = fullLayout._zoomlayer;
          var mode = fullLayout.dragmode;
          var isDrawMode = drawMode(mode);
          var isSelectMode = selectMode(mode);
          if (isDrawMode || isSelectMode) {
            var xaxis = getFromId(gd, xRef, "x");
            var yaxis = getFromId(gd, yRef, "y");
            if (xaxis && yaxis) {
              var outlines = zoomLayer.selectAll(".select-outline-" + plotinfo.id);
              if (outlines && gd._fullLayout._outlining) {
                if (outlines.length) {
                  var e = outlines[0][0];
                  var d = e.getAttribute("d");
                  var outlinePolys = readPaths(d, gd, plotinfo);
                  var draftPolygons = [];
                  for (var u = 0; u < outlinePolys.length; u++) {
                    var p = outlinePolys[u];
                    var polygon = [];
                    for (var t = 0; t < p.length; t++) {
                      polygon.push([
                        convert(xaxis, p[t][1]),
                        convert(yaxis, p[t][2])
                      ]);
                    }
                    polygon.xref = xRef;
                    polygon.yref = yRef;
                    polygon.subtract = getSubtract(polygon, draftPolygons);
                    draftPolygons.push(polygon);
                  }
                  layoutPolygons = layoutPolygons.concat(draftPolygons);
                }
              }
            }
          }
        }
        var subplots = xRef && yRef ? [xRef + yRef] : fullLayout._subplots.cartesian;
        epmtySplomSelectionBatch(gd);
        var seenSplom = {};
        for (var i = 0; i < subplots.length; i++) {
          var subplot = subplots[i];
          var yAt = subplot.indexOf("y");
          var _xRef = subplot.slice(0, yAt);
          var _yRef = subplot.slice(yAt);
          var _selectionTesters = xRef && yRef ? selectionTesters : void 0;
          _selectionTesters = addTester(layoutPolygons, _xRef, _yRef, _selectionTesters);
          if (_selectionTesters) {
            var _searchTraces = searchTraces;
            if (!hadSearchTraces) {
              var _xA = getFromId(gd, _xRef, "x");
              var _yA = getFromId(gd, _yRef, "y");
              _searchTraces = determineSearchTraces(
                gd,
                [_xA],
                [_yA],
                subplot
              );
              for (var w = 0; w < _searchTraces.length; w++) {
                var s = _searchTraces[w];
                var cd0 = s.cd[0];
                var trace = cd0.trace;
                if (s._module.name === "scattergl" && !cd0.t.xpx) {
                  var x = trace.x;
                  var y = trace.y;
                  var len = trace._length;
                  cd0.t.xpx = [];
                  cd0.t.ypx = [];
                  for (var j = 0; j < len; j++) {
                    cd0.t.xpx[j] = _xA.c2p(x[j]);
                    cd0.t.ypx[j] = _yA.c2p(y[j]);
                  }
                }
                if (s._module.name === "splom") {
                  if (!seenSplom[trace.uid]) {
                    seenSplom[trace.uid] = true;
                  }
                }
              }
            }
            var selection = _doSelect(_selectionTesters, _searchTraces);
            allSelections = allSelections.concat(selection);
            allSearchTraces = allSearchTraces.concat(_searchTraces);
          }
        }
        var eventData = { points: allSelections };
        updateSelectedState(gd, allSearchTraces, eventData);
        var clickmode = fullLayout.clickmode;
        var sendEvents = clickmode.indexOf("event") > -1 && mayEmitSelected;
        if (!plotinfo && // get called from plot_api & plots
        mayEmitSelected) {
          var activePolygons = getLayoutPolygons(gd, true);
          if (activePolygons.length) {
            var xref = activePolygons[0].xref;
            var yref = activePolygons[0].yref;
            if (xref && yref) {
              var poly = castMultiPolygon(activePolygons);
              var fillRangeItems = makeFillRangeItems([
                getFromId(gd, xref, "x"),
                getFromId(gd, yref, "y")
              ]);
              fillRangeItems(eventData, poly);
            }
          }
          if (gd._fullLayout._noEmitSelectedAtStart) {
            gd._fullLayout._noEmitSelectedAtStart = false;
          } else {
            if (sendEvents) emitSelected(gd, eventData);
          }
          fullLayout._reselect = false;
        }
        if (!plotinfo && // get called from plot_api & plots
        fullLayout._deselect) {
          var deselect = fullLayout._deselect;
          xRef = deselect.xref;
          yRef = deselect.yref;
          if (!subplotSelected(xRef, yRef, allSearchTraces)) {
            deselectSubplot(gd, xRef, yRef, searchTraces);
          }
          if (sendEvents) {
            if (eventData.points.length) {
              emitSelected(gd, eventData);
            } else {
              emitDeselect(gd);
            }
          }
          fullLayout._deselect = false;
        }
        return {
          eventData,
          selectionTesters
        };
      }
      function epmtySplomSelectionBatch(gd) {
        var cd = gd.calcdata;
        if (!cd) return;
        for (var i = 0; i < cd.length; i++) {
          var cd0 = cd[i][0];
          var trace = cd0.trace;
          var splomScenes = gd._fullLayout._splomScenes;
          if (splomScenes) {
            var scene = splomScenes[trace.uid];
            if (scene) {
              scene.selectBatch = [];
            }
          }
        }
      }
      function subplotSelected(xRef, yRef, searchTraces) {
        for (var i = 0; i < searchTraces.length; i++) {
          var s = searchTraces[i];
          if (s.xaxis && s.xaxis._id === xRef && (s.yaxis && s.yaxis._id === yRef)) {
            return true;
          }
        }
        return false;
      }
      function deselectSubplot(gd, xRef, yRef, searchTraces) {
        searchTraces = determineSearchTraces(
          gd,
          [getFromId(gd, xRef, "x")],
          [getFromId(gd, yRef, "y")],
          xRef + yRef
        );
        for (var k = 0; k < searchTraces.length; k++) {
          var searchInfo = searchTraces[k];
          searchInfo._module.selectPoints(searchInfo, false);
        }
        updateSelectedState(gd, searchTraces);
      }
      function addTester(layoutPolygons, xRef, yRef, selectionTesters) {
        var mergedPolygons;
        for (var i = 0; i < layoutPolygons.length; i++) {
          var currentPolygon = layoutPolygons[i];
          if (xRef !== currentPolygon.xref || yRef !== currentPolygon.yref) continue;
          if (mergedPolygons) {
            var subtract = !!currentPolygon.subtract;
            mergedPolygons = mergePolygons(mergedPolygons, currentPolygon, subtract);
            selectionTesters = multiTester(mergedPolygons);
          } else {
            mergedPolygons = [currentPolygon];
            selectionTesters = polygonTester(currentPolygon);
          }
        }
        return selectionTesters;
      }
      function getLayoutPolygons(gd, onlyActiveOnes) {
        var allPolygons = [];
        var fullLayout = gd._fullLayout;
        var allSelections = fullLayout.selections;
        var len = allSelections.length;
        for (var i = 0; i < len; i++) {
          if (onlyActiveOnes && i !== fullLayout._activeSelectionIndex) continue;
          var selection = allSelections[i];
          if (!selection) continue;
          var xref = selection.xref;
          var yref = selection.yref;
          var xaxis = getFromId(gd, xref, "x");
          var yaxis = getFromId(gd, yref, "y");
          var xmin, xmax, ymin, ymax;
          var polygon;
          if (selection.type === "rect") {
            polygon = [];
            var x0 = convert(xaxis, selection.x0);
            var x1 = convert(xaxis, selection.x1);
            var y0 = convert(yaxis, selection.y0);
            var y1 = convert(yaxis, selection.y1);
            polygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];
            xmin = Math.min(x0, x1);
            xmax = Math.max(x0, x1);
            ymin = Math.min(y0, y1);
            ymax = Math.max(y0, y1);
            polygon.xmin = xmin;
            polygon.xmax = xmax;
            polygon.ymin = ymin;
            polygon.ymax = ymax;
            polygon.xref = xref;
            polygon.yref = yref;
            polygon.subtract = false;
            polygon.isRect = true;
            allPolygons.push(polygon);
          } else if (selection.type === "path") {
            var segments = selection.path.split("Z");
            var multiPolygons = [];
            for (var j = 0; j < segments.length; j++) {
              var path = segments[j];
              if (!path) continue;
              path += "Z";
              var allX = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsX, "raw");
              var allY = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsY, "raw");
              xmin = Infinity;
              xmax = -Infinity;
              ymin = Infinity;
              ymax = -Infinity;
              polygon = [];
              for (var k = 0; k < allX.length; k++) {
                var x = convert(xaxis, allX[k]);
                var y = convert(yaxis, allY[k]);
                polygon.push([x, y]);
                xmin = Math.min(x, xmin);
                xmax = Math.max(x, xmax);
                ymin = Math.min(y, ymin);
                ymax = Math.max(y, ymax);
              }
              polygon.xmin = xmin;
              polygon.xmax = xmax;
              polygon.ymin = ymin;
              polygon.ymax = ymax;
              polygon.xref = xref;
              polygon.yref = yref;
              polygon.subtract = getSubtract(polygon, multiPolygons);
              multiPolygons.push(polygon);
              allPolygons.push(polygon);
            }
          }
        }
        return allPolygons;
      }
      function getSubtract(polygon, previousPolygons) {
        var subtract = false;
        for (var i = 0; i < previousPolygons.length; i++) {
          var previousPolygon = previousPolygons[i];
          for (var k = 0; k < polygon.length; k++) {
            if (pointInPolygon(polygon[k], previousPolygon)) {
              subtract = !subtract;
              break;
            }
          }
        }
        return subtract;
      }
      function convert(ax, d) {
        if (ax.type === "date") d = d.replace("_", " ");
        return ax.type === "log" ? ax.c2p(d) : ax.r2p(d, null, ax.calendar);
      }
      function castMultiPolygon(allPolygons) {
        var len = allPolygons.length;
        var p = [];
        for (var i = 0; i < len; i++) {
          var polygon = allPolygons[i];
          p = p.concat(polygon);
          p = p.concat([polygon[0]]);
        }
        return computeRectAndRanges(p);
      }
      function computeRectAndRanges(poly) {
        poly.isRect = poly.length === 5 && poly[0][0] === poly[4][0] && poly[0][1] === poly[4][1] && (poly[0][0] === poly[1][0] && poly[2][0] === poly[3][0] && poly[0][1] === poly[3][1] && poly[1][1] === poly[2][1]) || poly[0][1] === poly[1][1] && poly[2][1] === poly[3][1] && poly[0][0] === poly[3][0] && poly[1][0] === poly[2][0];
        if (poly.isRect) {
          poly.xmin = Math.min(poly[0][0], poly[2][0]);
          poly.xmax = Math.max(poly[0][0], poly[2][0]);
          poly.ymin = Math.min(poly[0][1], poly[2][1]);
          poly.ymax = Math.max(poly[0][1], poly[2][1]);
        }
        return poly;
      }
      function makeFillRangeItems(allAxes) {
        return function(eventData, poly) {
          var range;
          var lassoPoints;
          for (var i = 0; i < allAxes.length; i++) {
            var ax = allAxes[i];
            var id = ax._id;
            var axLetter = id.charAt(0);
            if (poly.isRect) {
              if (!range) range = {};
              var min = poly[axLetter + "min"];
              var max = poly[axLetter + "max"];
              if (min !== void 0 && max !== void 0) {
                range[id] = [
                  p2r(ax, min),
                  p2r(ax, max)
                ].sort(ascending);
              }
            } else {
              if (!lassoPoints) lassoPoints = {};
              lassoPoints[id] = poly.map(axValue(ax));
            }
          }
          if (range) {
            eventData.range = range;
          }
          if (lassoPoints) {
            eventData.lassoPoints = lassoPoints;
          }
        };
      }
      function getFillRangeItems(dragOptions) {
        var plotinfo = dragOptions.plotinfo;
        return plotinfo.fillRangeItems || // allow subplots (i.e. geo, mapbox, map, sankey) to override fillRangeItems routine
        makeFillRangeItems(dragOptions.xaxes.concat(dragOptions.yaxes));
      }
      function emitSelecting(gd, eventData) {
        gd.emit("plotly_selecting", eventData);
      }
      function emitSelected(gd, eventData) {
        if (eventData) {
          eventData.selections = (gd.layout || {}).selections || [];
        }
        gd.emit("plotly_selected", eventData);
      }
      function emitDeselect(gd) {
        gd.emit("plotly_deselect", null);
      }
      module.exports = {
        reselect,
        prepSelect,
        clearOutline,
        clearSelectionsCache,
        selectOnClick
      };
    }
  });

  // src/components/annotations/arrow_paths.js
  var require_arrow_paths = __commonJS({
    "src/components/annotations/arrow_paths.js"(exports, module) {
      "use strict";
      module.exports = [
        // no arrow
        {
          path: "",
          backoff: 0
        },
        // wide with flat back
        {
          path: "M-2.4,-3V3L0.6,0Z",
          backoff: 0.6
        },
        // narrower with flat back
        {
          path: "M-3.7,-2.5V2.5L1.3,0Z",
          backoff: 1.3
        },
        // barbed
        {
          path: "M-4.45,-3L-1.65,-0.2V0.2L-4.45,3L1.55,0Z",
          backoff: 1.55
        },
        // wide line-drawn
        {
          path: "M-2.2,-2.2L-0.2,-0.2V0.2L-2.2,2.2L-1.4,3L1.6,0L-1.4,-3Z",
          backoff: 1.6
        },
        // narrower line-drawn
        {
          path: "M-4.4,-2.1L-0.6,-0.2V0.2L-4.4,2.1L-4,3L2,0L-4,-3Z",
          backoff: 2
        },
        // circle
        {
          path: "M2,0A2,2 0 1,1 0,-2A2,2 0 0,1 2,0Z",
          backoff: 0,
          noRotate: true
        },
        // square
        {
          path: "M2,2V-2H-2V2Z",
          backoff: 0,
          noRotate: true
        }
      ];
    }
  });

  // src/constants/axis_placeable_objects.js
  var require_axis_placeable_objects = __commonJS({
    "src/constants/axis_placeable_objects.js"(exports, module) {
      "use strict";
      module.exports = {
        axisRefDescription: function(axisname, lower, upper) {
          return [
            "If set to a",
            axisname,
            "axis id (e.g. *" + axisname + "* or",
            "*" + axisname + "2*), the `" + axisname + "` position refers to a",
            axisname,
            "coordinate. If set to *paper*, the `" + axisname + "`",
            "position refers to the distance from the",
            lower,
            "of the plotting",
            "area in normalized coordinates where *0* (*1*) corresponds to the",
            lower,
            "(" + upper + "). If set to a",
            axisname,
            "axis ID followed by",
            "*domain* (separated by a space), the position behaves like for",
            "*paper*, but refers to the distance in fractions of the domain",
            "length from the",
            lower,
            "of the domain of that axis: e.g.,",
            "*" + axisname + "2 domain* refers to the domain of the second",
            axisname,
            " axis and a",
            axisname,
            "position of 0.5 refers to the",
            "point between the",
            lower,
            "and the",
            upper,
            "of the domain of the",
            "second",
            axisname,
            "axis."
          ].join(" ");
        }
      };
    }
  });

  // src/components/annotations/attributes.js
  var require_attributes11 = __commonJS({
    "src/components/annotations/attributes.js"(exports, module) {
      "use strict";
      var ARROWPATHS = require_arrow_paths();
      var fontAttrs = require_font_attributes();
      var cartesianConstants = require_constants2();
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      module.exports = templatedArray("annotation", {
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "calc+arraydraw"
        },
        text: {
          valType: "string",
          editType: "calc+arraydraw"
        },
        textangle: {
          valType: "angle",
          dflt: 0,
          editType: "calc+arraydraw"
        },
        font: fontAttrs({
          editType: "calc+arraydraw",
          colorEditType: "arraydraw"
        }),
        width: {
          valType: "number",
          min: 1,
          dflt: null,
          editType: "calc+arraydraw"
        },
        height: {
          valType: "number",
          min: 1,
          dflt: null,
          editType: "calc+arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "arraydraw"
        },
        align: {
          valType: "enumerated",
          values: ["left", "center", "right"],
          dflt: "center",
          editType: "arraydraw"
        },
        valign: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"],
          dflt: "middle",
          editType: "arraydraw"
        },
        bgcolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)",
          editType: "arraydraw"
        },
        bordercolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)",
          editType: "arraydraw"
        },
        borderpad: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        // arrow
        showarrow: {
          valType: "boolean",
          dflt: true,
          editType: "calc+arraydraw"
        },
        arrowcolor: {
          valType: "color",
          editType: "arraydraw"
        },
        arrowhead: {
          valType: "integer",
          min: 0,
          max: ARROWPATHS.length,
          dflt: 1,
          editType: "arraydraw"
        },
        startarrowhead: {
          valType: "integer",
          min: 0,
          max: ARROWPATHS.length,
          dflt: 1,
          editType: "arraydraw"
        },
        arrowside: {
          valType: "flaglist",
          flags: ["end", "start"],
          extras: ["none"],
          dflt: "end",
          editType: "arraydraw"
        },
        arrowsize: {
          valType: "number",
          min: 0.3,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        startarrowsize: {
          valType: "number",
          min: 0.3,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        arrowwidth: {
          valType: "number",
          min: 0.1,
          editType: "calc+arraydraw"
        },
        standoff: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "calc+arraydraw"
        },
        startstandoff: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "calc+arraydraw"
        },
        ax: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        ay: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        axref: {
          valType: "enumerated",
          dflt: "pixel",
          values: [
            "pixel",
            cartesianConstants.idRegex.x.toString()
          ],
          editType: "calc"
        },
        ayref: {
          valType: "enumerated",
          dflt: "pixel",
          values: [
            "pixel",
            cartesianConstants.idRegex.y.toString()
          ],
          editType: "calc"
        },
        // positioning
        xref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.x.toString()
          ],
          editType: "calc"
        },
        x: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "auto",
          editType: "calc+arraydraw"
        },
        xshift: {
          valType: "number",
          dflt: 0,
          editType: "calc+arraydraw"
        },
        yref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.y.toString()
          ],
          editType: "calc"
        },
        y: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "auto",
          editType: "calc+arraydraw"
        },
        yshift: {
          valType: "number",
          dflt: 0,
          editType: "calc+arraydraw"
        },
        clicktoshow: {
          valType: "enumerated",
          values: [false, "onoff", "onout"],
          dflt: false,
          editType: "arraydraw"
        },
        xclick: {
          valType: "any",
          editType: "arraydraw"
        },
        yclick: {
          valType: "any",
          editType: "arraydraw"
        },
        hovertext: {
          valType: "string",
          editType: "arraydraw"
        },
        hoverlabel: {
          bgcolor: {
            valType: "color",
            editType: "arraydraw"
          },
          bordercolor: {
            valType: "color",
            editType: "arraydraw"
          },
          font: fontAttrs({
            editType: "arraydraw"
          }),
          editType: "arraydraw"
        },
        captureevents: {
          valType: "boolean",
          editType: "arraydraw"
        },
        editType: "calc"
      });
    }
  });

  // src/traces/scatter/constants.js
  var require_constants8 = __commonJS({
    "src/traces/scatter/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        PTS_LINESONLY: 20,
        // fixed parameters of clustering and clipping algorithms
        // fraction of clustering tolerance "so close we don't even consider it a new point"
        minTolerance: 0.2,
        // how fast does clustering tolerance increase as you get away from the visible region
        toleranceGrowth: 10,
        // number of viewport sizes away from the visible region
        // at which we clip all lines to the perimeter
        maxScreensAway: 20,
        eventDataKeys: []
      };
    }
  });

  // src/traces/scatter/fillcolor_attribute.js
  var require_fillcolor_attribute = __commonJS({
    "src/traces/scatter/fillcolor_attribute.js"(exports, module) {
      "use strict";
      module.exports = function makeFillcolorAttr(hasFillgradient) {
        return {
          valType: "color",
          editType: "style",
          anim: true
        };
      };
    }
  });

  // src/traces/scatter/attributes.js
  var require_attributes12 = __commonJS({
    "src/traces/scatter/attributes.js"(exports, module) {
      "use strict";
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var texttemplateAttrs = require_template_attributes().texttemplateAttrs;
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var colorScaleAttrs = require_attributes8();
      var fontAttrs = require_font_attributes();
      var dash = require_attributes4().dash;
      var pattern = require_attributes4().pattern;
      var Drawing = require_drawing();
      var constants = require_constants8();
      var extendFlat = require_extend().extendFlat;
      var makeFillcolorAttr = require_fillcolor_attribute();
      function axisPeriod(axis) {
        return {
          valType: "any",
          dflt: 0,
          editType: "calc"
        };
      }
      function axisPeriod0(axis) {
        return {
          valType: "any",
          editType: "calc"
        };
      }
      function axisPeriodAlignment(axis) {
        return {
          valType: "enumerated",
          values: [
            "start",
            "middle",
            "end"
          ],
          dflt: "middle",
          editType: "calc"
        };
      }
      module.exports = {
        x: {
          valType: "data_array",
          editType: "calc+clearAxisTypes",
          anim: true
        },
        x0: {
          valType: "any",
          dflt: 0,
          editType: "calc+clearAxisTypes",
          anim: true
        },
        dx: {
          valType: "number",
          dflt: 1,
          editType: "calc",
          anim: true
        },
        y: {
          valType: "data_array",
          editType: "calc+clearAxisTypes",
          anim: true
        },
        y0: {
          valType: "any",
          dflt: 0,
          editType: "calc+clearAxisTypes",
          anim: true
        },
        dy: {
          valType: "number",
          dflt: 1,
          editType: "calc",
          anim: true
        },
        xperiod: axisPeriod("x"),
        yperiod: axisPeriod("y"),
        xperiod0: axisPeriod0("x0"),
        yperiod0: axisPeriod0("y0"),
        xperiodalignment: axisPeriodAlignment("x"),
        yperiodalignment: axisPeriodAlignment("y"),
        xhoverformat: axisHoverFormat("x"),
        yhoverformat: axisHoverFormat("y"),
        offsetgroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        alignmentgroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        stackgroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          editType: "calc"
        },
        groupnorm: {
          valType: "enumerated",
          values: ["", "fraction", "percent"],
          dflt: "",
          editType: "calc"
        },
        stackgaps: {
          valType: "enumerated",
          values: ["infer zero", "interpolate"],
          dflt: "infer zero",
          editType: "calc"
        },
        text: {
          valType: "string",
          dflt: "",
          arrayOk: true,
          editType: "calc"
        },
        texttemplate: texttemplateAttrs({}, {}),
        hovertext: {
          valType: "string",
          dflt: "",
          arrayOk: true,
          editType: "style"
        },
        mode: {
          valType: "flaglist",
          flags: ["lines", "markers", "text"],
          extras: ["none"],
          editType: "calc"
        },
        hoveron: {
          valType: "flaglist",
          flags: ["points", "fills"],
          editType: "style"
        },
        hovertemplate: hovertemplateAttrs({}, {
          keys: constants.eventDataKeys
        }),
        line: {
          color: {
            valType: "color",
            editType: "style",
            anim: true
          },
          width: {
            valType: "number",
            min: 0,
            dflt: 2,
            editType: "style",
            anim: true
          },
          shape: {
            valType: "enumerated",
            values: ["linear", "spline", "hv", "vh", "hvh", "vhv"],
            dflt: "linear",
            editType: "plot"
          },
          smoothing: {
            valType: "number",
            min: 0,
            max: 1.3,
            dflt: 1,
            editType: "plot"
          },
          dash: extendFlat({}, dash, { editType: "style" }),
          backoff: {
            // we want to have a similar option for the start of the line
            valType: "number",
            min: 0,
            dflt: "auto",
            arrayOk: true,
            editType: "plot"
          },
          simplify: {
            valType: "boolean",
            dflt: true,
            editType: "plot"
          },
          editType: "plot"
        },
        connectgaps: {
          valType: "boolean",
          dflt: false,
          editType: "calc"
        },
        cliponaxis: {
          valType: "boolean",
          dflt: true,
          editType: "plot"
        },
        fill: {
          valType: "enumerated",
          values: ["none", "tozeroy", "tozerox", "tonexty", "tonextx", "toself", "tonext"],
          editType: "calc"
        },
        fillcolor: makeFillcolorAttr(true),
        fillgradient: extendFlat({
          type: {
            valType: "enumerated",
            values: ["radial", "horizontal", "vertical", "none"],
            dflt: "none",
            editType: "calc"
          },
          start: {
            valType: "number",
            editType: "calc"
          },
          stop: {
            valType: "number",
            editType: "calc"
          },
          colorscale: {
            valType: "colorscale",
            editType: "style"
          },
          editType: "calc"
        }),
        fillpattern: pattern,
        marker: extendFlat(
          {
            symbol: {
              valType: "enumerated",
              values: Drawing.symbolList,
              dflt: "circle",
              arrayOk: true,
              editType: "style"
            },
            opacity: {
              valType: "number",
              min: 0,
              max: 1,
              arrayOk: true,
              editType: "style",
              anim: true
            },
            angle: {
              valType: "angle",
              dflt: 0,
              arrayOk: true,
              editType: "plot",
              anim: false
              // TODO: possibly set to true in future
            },
            angleref: {
              valType: "enumerated",
              values: ["previous", "up"],
              dflt: "up",
              editType: "plot",
              anim: false
            },
            standoff: {
              valType: "number",
              min: 0,
              dflt: 0,
              arrayOk: true,
              editType: "plot",
              anim: true
            },
            size: {
              valType: "number",
              min: 0,
              dflt: 6,
              arrayOk: true,
              editType: "calc",
              anim: true
            },
            maxdisplayed: {
              valType: "number",
              min: 0,
              dflt: 0,
              editType: "plot"
            },
            sizeref: {
              valType: "number",
              dflt: 1,
              editType: "calc"
            },
            sizemin: {
              valType: "number",
              min: 0,
              dflt: 0,
              editType: "calc"
            },
            sizemode: {
              valType: "enumerated",
              values: ["diameter", "area"],
              dflt: "diameter",
              editType: "calc"
            },
            line: extendFlat(
              {
                width: {
                  valType: "number",
                  min: 0,
                  arrayOk: true,
                  editType: "style",
                  anim: true
                },
                editType: "calc"
              },
              colorScaleAttrs("marker.line", { anim: true })
            ),
            gradient: {
              type: {
                valType: "enumerated",
                values: ["radial", "horizontal", "vertical", "none"],
                arrayOk: true,
                dflt: "none",
                editType: "calc"
              },
              color: {
                valType: "color",
                arrayOk: true,
                editType: "calc"
              },
              editType: "calc"
            },
            editType: "calc"
          },
          colorScaleAttrs("marker", { anim: true })
        ),
        selected: {
          marker: {
            opacity: {
              valType: "number",
              min: 0,
              max: 1,
              editType: "style"
            },
            color: {
              valType: "color",
              editType: "style"
            },
            size: {
              valType: "number",
              min: 0,
              editType: "style"
            },
            editType: "style"
          },
          textfont: {
            color: {
              valType: "color",
              editType: "style"
            },
            editType: "style"
          },
          editType: "style"
        },
        unselected: {
          marker: {
            opacity: {
              valType: "number",
              min: 0,
              max: 1,
              editType: "style"
            },
            color: {
              valType: "color",
              editType: "style"
            },
            size: {
              valType: "number",
              min: 0,
              editType: "style"
            },
            editType: "style"
          },
          textfont: {
            color: {
              valType: "color",
              editType: "style"
            },
            editType: "style"
          },
          editType: "style"
        },
        textposition: {
          valType: "enumerated",
          values: [
            "top left",
            "top center",
            "top right",
            "middle left",
            "middle center",
            "middle right",
            "bottom left",
            "bottom center",
            "bottom right"
          ],
          dflt: "middle center",
          arrayOk: true,
          editType: "calc"
        },
        textfont: fontAttrs({
          editType: "calc",
          colorEditType: "style",
          arrayOk: true
        }),
        zorder: {
          valType: "integer",
          dflt: 0,
          editType: "plot"
        }
      };
    }
  });

  // src/components/selections/attributes.js
  var require_attributes13 = __commonJS({
    "src/components/selections/attributes.js"(exports, module) {
      "use strict";
      var annAttrs = require_attributes11();
      var scatterLineAttrs = require_attributes12().line;
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      module.exports = overrideAll(templatedArray("selection", {
        type: {
          valType: "enumerated",
          values: ["rect", "path"]
        },
        xref: extendFlat({}, annAttrs.xref, {}),
        yref: extendFlat({}, annAttrs.yref, {}),
        x0: {
          valType: "any"
        },
        x1: {
          valType: "any"
        },
        y0: {
          valType: "any"
        },
        y1: {
          valType: "any"
        },
        path: {
          valType: "string",
          editType: "arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0.7,
          editType: "arraydraw"
        },
        line: {
          color: scatterLineAttrs.color,
          width: extendFlat({}, scatterLineAttrs.width, {
            min: 1,
            dflt: 1
          }),
          dash: extendFlat({}, dash, {
            dflt: "dot"
          })
        }
      }), "arraydraw", "from-root");
    }
  });

  // src/components/selections/defaults.js
  var require_defaults6 = __commonJS({
    "src/components/selections/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes13();
      var helpers = require_helpers8();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name: "selections",
          handleItemDefaults: handleSelectionDefaults
        });
        var selections = layoutOut.selections;
        for (var i = 0; i < selections.length; i++) {
          var selection = selections[i];
          if (!selection) continue;
          if (selection.path === void 0) {
            if (selection.x0 === void 0 || selection.x1 === void 0 || selection.y0 === void 0 || selection.y1 === void 0) {
              layoutOut.selections[i] = null;
            }
          }
        }
      };
      function handleSelectionDefaults(selectionIn, selectionOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(selectionIn, selectionOut, attributes, attr, dflt);
        }
        var path = coerce("path");
        var dfltType = path ? "path" : "rect";
        var selectionType = coerce("type", dfltType);
        var noPath = selectionType !== "path";
        if (noPath) delete selectionOut.path;
        coerce("opacity");
        coerce("line.color");
        coerce("line.width");
        coerce("line.dash");
        var axLetters = ["x", "y"];
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var gdMock = { _fullLayout: fullLayout };
          var ax;
          var pos2r;
          var r2pos;
          var axRef = Axes.coerceRef(selectionIn, selectionOut, gdMock, axLetter);
          ax = Axes.getFromId(gdMock, axRef);
          ax._selectionIndices.push(selectionOut._index);
          r2pos = helpers.rangeToShapePosition(ax);
          pos2r = helpers.shapePositionToRange(ax);
          if (noPath) {
            var attr0 = axLetter + "0";
            var attr1 = axLetter + "1";
            var in0 = selectionIn[attr0];
            var in1 = selectionIn[attr1];
            selectionIn[attr0] = pos2r(selectionIn[attr0], true);
            selectionIn[attr1] = pos2r(selectionIn[attr1], true);
            Axes.coercePosition(selectionOut, gdMock, coerce, axRef, attr0);
            Axes.coercePosition(selectionOut, gdMock, coerce, axRef, attr1);
            var p0 = selectionOut[attr0];
            var p1 = selectionOut[attr1];
            if (p0 !== void 0 && p1 !== void 0) {
              selectionOut[attr0] = r2pos(p0);
              selectionOut[attr1] = r2pos(p1);
              selectionIn[attr0] = in0;
              selectionIn[attr1] = in1;
            }
          }
        }
        if (noPath) {
          Lib.noneOrAll(selectionIn, selectionOut, ["x0", "x1", "y0", "y1"]);
        }
      }
    }
  });

  // src/components/selections/draw_newselection/defaults.js
  var require_defaults7 = __commonJS({
    "src/components/selections/draw_newselection/defaults.js"(exports, module) {
      "use strict";
      module.exports = function supplyDrawNewSelectionDefaults(layoutIn, layoutOut, coerce) {
        coerce("newselection.mode");
        var newselectionLineWidth = coerce("newselection.line.width");
        if (newselectionLineWidth) {
          coerce("newselection.line.color");
          coerce("newselection.line.dash");
        }
        coerce("activeselection.fillcolor");
        coerce("activeselection.opacity");
      };
    }
  });

  // src/plots/cartesian/include_components.js
  var require_include_components = __commonJS({
    "src/plots/cartesian/include_components.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var axisIds = require_axis_ids();
      module.exports = function makeIncludeComponents(containerArrayName) {
        return function includeComponents(layoutIn, layoutOut) {
          var array = layoutIn[containerArrayName];
          if (!Array.isArray(array)) return;
          var Cartesian = Registry.subplotsRegistry.cartesian;
          var idRegex = Cartesian.idRegex;
          var subplots = layoutOut._subplots;
          var xaList = subplots.xaxis;
          var yaList = subplots.yaxis;
          var cartesianList = subplots.cartesian;
          var hasCartesian = layoutOut._has("cartesian");
          for (var i = 0; i < array.length; i++) {
            var itemi = array[i];
            if (!Lib.isPlainObject(itemi)) continue;
            var xref = axisIds.cleanId(itemi.xref, "x", false);
            var yref = axisIds.cleanId(itemi.yref, "y", false);
            var hasXref = idRegex.x.test(xref);
            var hasYref = idRegex.y.test(yref);
            if (hasXref || hasYref) {
              if (!hasCartesian) Lib.pushUnique(layoutOut._basePlotModules, Cartesian);
              var newAxis = false;
              if (hasXref && xaList.indexOf(xref) === -1) {
                xaList.push(xref);
                newAxis = true;
              }
              if (hasYref && yaList.indexOf(yref) === -1) {
                yaList.push(yref);
                newAxis = true;
              }
              if (newAxis && hasXref && hasYref) {
                cartesianList.push(xref + yref);
              }
            }
          }
        };
      };
    }
  });

  // src/components/selections/index.js
  var require_selections = __commonJS({
    "src/components/selections/index.js"(exports, module) {
      "use strict";
      var drawModule = require_draw3();
      var select = require_select();
      module.exports = {
        moduleType: "component",
        name: "selections",
        layoutAttributes: require_attributes13(),
        supplyLayoutDefaults: require_defaults6(),
        supplyDrawNewSelectionDefaults: require_defaults7(),
        includeBasePlot: require_include_components()("selections"),
        draw: drawModule.draw,
        drawOne: drawModule.drawOne,
        reselect: select.reselect,
        prepSelect: select.prepSelect,
        clearOutline: select.clearOutline,
        clearSelectionsCache: select.clearSelectionsCache,
        selectOnClick: select.selectOnClick
      };
    }
  });

  // src/plots/cartesian/dragbox.js
  var require_dragbox = __commonJS({
    "src/plots/cartesian/dragbox.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var numberFormat = Lib.numberFormat;
      var tinycolor = require_tinycolor();
      var supportsPassive = require_has_passive_events();
      var Registry = require_registry();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var Color = require_color();
      var Drawing = require_drawing();
      var Fx = require_fx();
      var Axes = require_axes();
      var setCursor = require_setcursor();
      var dragElement = require_dragelement();
      var helpers = require_helpers5();
      var selectingOrDrawing = helpers.selectingOrDrawing;
      var freeMode = helpers.freeMode;
      var FROM_TL = require_alignment().FROM_TL;
      var clearGlCanvases = require_clear_gl_canvases();
      var redrawReglTraces = require_subroutines().redrawReglTraces;
      var Plots = require_plots();
      var getFromId = require_axis_ids().getFromId;
      var prepSelect = require_selections().prepSelect;
      var clearOutline = require_selections().clearOutline;
      var selectOnClick = require_selections().selectOnClick;
      var scaleZoom = require_scale_zoom();
      var constants = require_constants2();
      var MINDRAG = constants.MINDRAG;
      var MINZOOM = constants.MINZOOM;
      var SHOWZOOMOUTTIP = true;
      function makeDragBox(gd, plotinfo, x, y, w, h, ns, ew) {
        var zoomlayer = gd._fullLayout._zoomlayer;
        var isMainDrag = ns + ew === "nsew";
        var singleEnd = (ns + ew).length === 1;
        var xa0, ya0;
        var xaHash, yaHash;
        var xaxes, yaxes;
        var xs, ys;
        var pw, ph;
        var links;
        var matches;
        var xActive, yActive;
        var allFixedRanges;
        var editX, editY;
        var hasScatterGl, hasSplom, hasSVG;
        var updates;
        var scaleX;
        var scaleY;
        x += plotinfo.yaxis._shift;
        function recomputeAxisLists() {
          xa0 = plotinfo.xaxis;
          ya0 = plotinfo.yaxis;
          pw = xa0._length;
          ph = ya0._length;
          xs = xa0._offset;
          ys = ya0._offset;
          xaHash = {};
          xaHash[xa0._id] = xa0;
          yaHash = {};
          yaHash[ya0._id] = ya0;
          if (ns && ew) {
            var overlays = plotinfo.overlays;
            for (var i = 0; i < overlays.length; i++) {
              var xa = overlays[i].xaxis;
              xaHash[xa._id] = xa;
              var ya = overlays[i].yaxis;
              yaHash[ya._id] = ya;
            }
          }
          xaxes = hashValues(xaHash);
          yaxes = hashValues(yaHash);
          xActive = isDirectionActive(xaxes, ew);
          yActive = isDirectionActive(yaxes, ns);
          allFixedRanges = !yActive && !xActive;
          matches = calcLinks(gd, gd._fullLayout._axisMatchGroups, xaHash, yaHash);
          links = calcLinks(gd, gd._fullLayout._axisConstraintGroups, xaHash, yaHash, matches);
          var spConstrained = links.isSubplotConstrained || matches.isSubplotConstrained;
          editX = ew || spConstrained;
          editY = ns || spConstrained;
          var fullLayout = gd._fullLayout;
          hasScatterGl = fullLayout._has("scattergl");
          hasSplom = fullLayout._has("splom");
          hasSVG = fullLayout._has("svg");
        }
        recomputeAxisLists();
        var cursor = getDragCursor(yActive + xActive, gd._fullLayout.dragmode, isMainDrag);
        var dragger = makeRectDragger(plotinfo, ns + ew + "drag", cursor, x, y, w, h);
        if (allFixedRanges && !isMainDrag) {
          dragger.onmousedown = null;
          dragger.style.pointerEvents = "none";
          return dragger;
        }
        var dragOptions = {
          element: dragger,
          gd,
          plotinfo
        };
        dragOptions.prepFn = function(e, startX, startY) {
          var dragModePrev = dragOptions.dragmode;
          var dragModeNow = gd._fullLayout.dragmode;
          if (dragModeNow !== dragModePrev) {
            dragOptions.dragmode = dragModeNow;
          }
          recomputeAxisLists();
          scaleX = gd._fullLayout._invScaleX;
          scaleY = gd._fullLayout._invScaleY;
          if (!allFixedRanges) {
            if (isMainDrag) {
              if (e.shiftKey) {
                if (dragModeNow === "pan") dragModeNow = "zoom";
                else if (!selectingOrDrawing(dragModeNow)) dragModeNow = "pan";
              } else if (e.ctrlKey) {
                dragModeNow = "pan";
              }
            } else {
              dragModeNow = "pan";
            }
          }
          if (freeMode(dragModeNow)) dragOptions.minDrag = 1;
          else dragOptions.minDrag = void 0;
          if (selectingOrDrawing(dragModeNow)) {
            dragOptions.xaxes = xaxes;
            dragOptions.yaxes = yaxes;
            prepSelect(e, startX, startY, dragOptions, dragModeNow);
          } else {
            dragOptions.clickFn = clickFn;
            if (selectingOrDrawing(dragModePrev)) {
              clearAndResetSelect();
            }
            if (!allFixedRanges) {
              if (dragModeNow === "zoom") {
                dragOptions.moveFn = zoomMove;
                dragOptions.doneFn = zoomDone;
                dragOptions.minDrag = 1;
                zoomPrep(e, startX, startY);
              } else if (dragModeNow === "pan") {
                dragOptions.moveFn = plotDrag;
                dragOptions.doneFn = dragTail;
              }
            }
          }
          gd._fullLayout._redrag = function() {
            var dragDataNow = gd._dragdata;
            if (dragDataNow && dragDataNow.element === dragger) {
              var dragModeNow2 = gd._fullLayout.dragmode;
              if (!selectingOrDrawing(dragModeNow2)) {
                recomputeAxisLists();
                updateSubplots([0, 0, pw, ph]);
                dragOptions.moveFn(dragDataNow.dx, dragDataNow.dy);
              }
            }
          };
        };
        function clearAndResetSelect() {
          dragOptions.plotinfo.selection = false;
          clearOutline(gd);
        }
        function clickFn(numClicks, evt) {
          var gd2 = dragOptions.gd;
          if (gd2._fullLayout._activeShapeIndex >= 0) {
            gd2._fullLayout._deactivateShape(gd2);
            return;
          }
          var clickmode = gd2._fullLayout.clickmode;
          removeZoombox(gd2);
          if (numClicks === 2 && !singleEnd) doubleClick();
          if (isMainDrag) {
            if (clickmode.indexOf("select") > -1) {
              selectOnClick(evt, gd2, xaxes, yaxes, plotinfo.id, dragOptions);
            }
            if (clickmode.indexOf("event") > -1) {
              Fx.click(gd2, evt, plotinfo.id);
            }
          } else if (numClicks === 1 && singleEnd) {
            var ax = ns ? ya0 : xa0;
            var end = ns === "s" || ew === "w" ? 0 : 1;
            var attrStr = ax._name + ".range[" + end + "]";
            var initialText = getEndText(ax, end);
            var hAlign = "left";
            var vAlign = "middle";
            if (ax.fixedrange) return;
            if (ns) {
              vAlign = ns === "n" ? "top" : "bottom";
              if (ax.side === "right") hAlign = "right";
            } else if (ew === "e") hAlign = "right";
            if (gd2._context.showAxisRangeEntryBoxes) {
              d3.select(dragger).call(svgTextUtils.makeEditable, {
                gd: gd2,
                immediate: true,
                background: gd2._fullLayout.paper_bgcolor,
                text: String(initialText),
                fill: ax.tickfont ? ax.tickfont.color : "#444",
                horizontalAlign: hAlign,
                verticalAlign: vAlign
              }).on("edit", function(text) {
                var v = ax.d2r(text);
                if (v !== void 0) {
                  Registry.call("_guiRelayout", gd2, attrStr, v);
                }
              });
            }
          }
        }
        dragElement.init(dragOptions);
        var x0, y0;
        var box;
        var lum;
        var path0;
        var dimmed;
        var zoomMode;
        var zb;
        var corners;
        var zoomDragged;
        function zoomPrep(e, startX, startY) {
          var dragBBox = dragger.getBoundingClientRect();
          x0 = startX - dragBBox.left;
          y0 = startY - dragBBox.top;
          gd._fullLayout._calcInverseTransform(gd);
          var transformedCoords = Lib.apply3DTransform(gd._fullLayout._invTransform)(x0, y0);
          x0 = transformedCoords[0];
          y0 = transformedCoords[1];
          box = { l: x0, r: x0, w: 0, t: y0, b: y0, h: 0 };
          lum = gd._hmpixcount ? gd._hmlumcount / gd._hmpixcount : tinycolor(gd._fullLayout.plot_bgcolor).getLuminance();
          path0 = "M0,0H" + pw + "V" + ph + "H0V0";
          dimmed = false;
          zoomMode = "xy";
          zoomDragged = false;
          zb = makeZoombox(zoomlayer, lum, xs, ys, path0);
          corners = makeCorners(zoomlayer, xs, ys);
        }
        function zoomMove(dx0, dy0) {
          if (gd._transitioningWithDuration) {
            return false;
          }
          var x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));
          var y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));
          var dx = Math.abs(x1 - x0);
          var dy = Math.abs(y1 - y0);
          box.l = Math.min(x0, x1);
          box.r = Math.max(x0, x1);
          box.t = Math.min(y0, y1);
          box.b = Math.max(y0, y1);
          function noZoom() {
            zoomMode = "";
            box.r = box.l;
            box.t = box.b;
            corners.attr("d", "M0,0Z");
          }
          if (links.isSubplotConstrained) {
            if (dx > MINZOOM || dy > MINZOOM) {
              zoomMode = "xy";
              if (dx / pw > dy / ph) {
                dy = dx * ph / pw;
                if (y0 > y1) box.t = y0 - dy;
                else box.b = y0 + dy;
              } else {
                dx = dy * pw / ph;
                if (x0 > x1) box.l = x0 - dx;
                else box.r = x0 + dx;
              }
              corners.attr("d", xyCorners(box));
            } else {
              noZoom();
            }
          } else if (matches.isSubplotConstrained) {
            if (dx > MINZOOM || dy > MINZOOM) {
              zoomMode = "xy";
              var r0 = Math.min(box.l / pw, (ph - box.b) / ph);
              var r1 = Math.max(box.r / pw, (ph - box.t) / ph);
              box.l = r0 * pw;
              box.r = r1 * pw;
              box.b = (1 - r0) * ph;
              box.t = (1 - r1) * ph;
              corners.attr("d", xyCorners(box));
            } else {
              noZoom();
            }
          } else if (!yActive || dy < Math.min(Math.max(dx * 0.6, MINDRAG), MINZOOM)) {
            if (dx < MINDRAG || !xActive) {
              noZoom();
            } else {
              box.t = 0;
              box.b = ph;
              zoomMode = "x";
              corners.attr("d", xCorners(box, y0));
            }
          } else if (!xActive || dx < Math.min(dy * 0.6, MINZOOM)) {
            box.l = 0;
            box.r = pw;
            zoomMode = "y";
            corners.attr("d", yCorners(box, x0));
          } else {
            zoomMode = "xy";
            corners.attr("d", xyCorners(box));
          }
          box.w = box.r - box.l;
          box.h = box.b - box.t;
          if (zoomMode) zoomDragged = true;
          gd._dragged = zoomDragged;
          updateZoombox(zb, corners, box, path0, dimmed, lum);
          computeZoomUpdates();
          gd.emit("plotly_relayouting", updates);
          dimmed = true;
        }
        function computeZoomUpdates() {
          updates = {};
          if (zoomMode === "xy" || zoomMode === "x") {
            zoomAxRanges(xaxes, box.l / pw, box.r / pw, updates, links.xaxes);
            updateMatchedAxRange("x", updates);
          }
          if (zoomMode === "xy" || zoomMode === "y") {
            zoomAxRanges(yaxes, (ph - box.b) / ph, (ph - box.t) / ph, updates, links.yaxes);
            updateMatchedAxRange("y", updates);
          }
        }
        function zoomDone() {
          computeZoomUpdates();
          removeZoombox(gd);
          dragTail();
          showDoubleClickNotifier(gd);
        }
        var scrollViewBox = [0, 0, pw, ph];
        var redrawTimer = null;
        var REDRAWDELAY = constants.REDRAWDELAY;
        var mainplot = plotinfo.mainplot ? gd._fullLayout._plots[plotinfo.mainplot] : plotinfo;
        function zoomWheel(e) {
          if (!gd._context._scrollZoom.cartesian && !gd._fullLayout._enablescrollzoom) {
            return;
          }
          clearAndResetSelect();
          if (gd._transitioningWithDuration) {
            e.preventDefault();
            e.stopPropagation();
            return;
          }
          recomputeAxisLists();
          clearTimeout(redrawTimer);
          var wheelDelta = -e.deltaY;
          if (!isFinite(wheelDelta)) wheelDelta = e.wheelDelta / 10;
          if (!isFinite(wheelDelta)) {
            Lib.log("Did not find wheel motion attributes: ", e);
            return;
          }
          var zoom = Math.exp(-Math.min(Math.max(wheelDelta, -20), 20) / 200);
          var gbb = mainplot.draglayer.select(".nsewdrag").node().getBoundingClientRect();
          var xfrac = (e.clientX - gbb.left) / gbb.width;
          var yfrac = (gbb.bottom - e.clientY) / gbb.height;
          var i;
          function zoomWheelOneAxis(ax, centerFraction, zoom2) {
            if (ax.fixedrange) return;
            var axRange = Lib.simpleMap(ax.range, ax.r2l);
            var v0 = axRange[0] + (axRange[1] - axRange[0]) * centerFraction;
            function doZoom(v) {
              return ax.l2r(v0 + (v - v0) * zoom2);
            }
            ax.range = axRange.map(doZoom);
          }
          if (editX) {
            if (!ew) xfrac = 0.5;
            for (i = 0; i < xaxes.length; i++) {
              zoomWheelOneAxis(xaxes[i], xfrac, zoom);
            }
            updateMatchedAxRange("x");
            scrollViewBox[2] *= zoom;
            scrollViewBox[0] += scrollViewBox[2] * xfrac * (1 / zoom - 1);
          }
          if (editY) {
            if (!ns) yfrac = 0.5;
            for (i = 0; i < yaxes.length; i++) {
              zoomWheelOneAxis(yaxes[i], yfrac, zoom);
            }
            updateMatchedAxRange("y");
            scrollViewBox[3] *= zoom;
            scrollViewBox[1] += scrollViewBox[3] * (1 - yfrac) * (1 / zoom - 1);
          }
          updateSubplots(scrollViewBox);
          ticksAndAnnotations();
          gd.emit("plotly_relayouting", updates);
          redrawTimer = setTimeout(function() {
            if (!gd._fullLayout) return;
            scrollViewBox = [0, 0, pw, ph];
            dragTail();
          }, REDRAWDELAY);
          e.preventDefault();
          return;
        }
        if (ns.length * ew.length !== 1) {
          attachWheelEventHandler(dragger, zoomWheel);
        }
        function plotDrag(dx, dy) {
          dx = dx * scaleX;
          dy = dy * scaleY;
          if (gd._transitioningWithDuration) {
            return;
          }
          gd._fullLayout._replotting = true;
          if (xActive === "ew" || yActive === "ns") {
            var spDx = xActive ? -dx : 0;
            var spDy = yActive ? -dy : 0;
            if (matches.isSubplotConstrained) {
              if (xActive && yActive) {
                var frac = (dx / pw - dy / ph) / 2;
                dx = frac * pw;
                dy = -frac * ph;
                spDx = -dx;
                spDy = -dy;
              }
              if (yActive) {
                spDx = -spDy * pw / ph;
              } else {
                spDy = -spDx * ph / pw;
              }
            }
            if (xActive) {
              dragAxList(xaxes, dx);
              updateMatchedAxRange("x");
            }
            if (yActive) {
              dragAxList(yaxes, dy);
              updateMatchedAxRange("y");
            }
            updateSubplots([spDx, spDy, pw, ph]);
            ticksAndAnnotations();
            gd.emit("plotly_relayouting", updates);
            return;
          }
          function dz(axArray, end, d) {
            var otherEnd = 1 - end;
            var movedAx;
            var newLinearizedEnd;
            for (var i2 = 0; i2 < axArray.length; i2++) {
              var axi = axArray[i2];
              if (axi.fixedrange) continue;
              movedAx = axi;
              newLinearizedEnd = axi._rl[otherEnd] + (axi._rl[end] - axi._rl[otherEnd]) / dZoom(d / axi._length);
              var newEnd = axi.l2r(newLinearizedEnd);
              if (newEnd !== false && newEnd !== void 0) axi.range[end] = newEnd;
            }
            return movedAx._length * (movedAx._rl[end] - newLinearizedEnd) / (movedAx._rl[end] - movedAx._rl[otherEnd]);
          }
          var dxySign = xActive === "w" === (yActive === "n") ? 1 : -1;
          if (xActive && yActive && (links.isSubplotConstrained || matches.isSubplotConstrained)) {
            var dxyFraction = (dx / pw + dxySign * dy / ph) / 2;
            dx = dxyFraction * pw;
            dy = dxySign * dxyFraction * ph;
          }
          var xStart, yStart;
          if (xActive === "w") dx = dz(xaxes, 0, dx);
          else if (xActive === "e") dx = dz(xaxes, 1, -dx);
          else if (!xActive) dx = 0;
          if (yActive === "n") dy = dz(yaxes, 1, dy);
          else if (yActive === "s") dy = dz(yaxes, 0, -dy);
          else if (!yActive) dy = 0;
          xStart = xActive === "w" ? dx : 0;
          yStart = yActive === "n" ? dy : 0;
          if (links.isSubplotConstrained && !matches.isSubplotConstrained || // NW or SE on matching axes - create a symmetric zoom
          matches.isSubplotConstrained && xActive && yActive && dxySign > 0) {
            var i;
            if (matches.isSubplotConstrained || !xActive && yActive.length === 1) {
              for (i = 0; i < xaxes.length; i++) {
                xaxes[i].range = xaxes[i]._r.slice();
                scaleZoom(xaxes[i], 1 - dy / ph);
              }
              dx = dy * pw / ph;
              xStart = dx / 2;
            }
            if (matches.isSubplotConstrained || !yActive && xActive.length === 1) {
              for (i = 0; i < yaxes.length; i++) {
                yaxes[i].range = yaxes[i]._r.slice();
                scaleZoom(yaxes[i], 1 - dx / pw);
              }
              dy = dx * ph / pw;
              yStart = dy / 2;
            }
          }
          if (!matches.isSubplotConstrained || !yActive) {
            updateMatchedAxRange("x");
          }
          if (!matches.isSubplotConstrained || !xActive) {
            updateMatchedAxRange("y");
          }
          var xSize = pw - dx;
          var ySize = ph - dy;
          if (matches.isSubplotConstrained && !(xActive && yActive)) {
            if (xActive) {
              yStart = xStart ? 0 : dx * ph / pw;
              ySize = xSize * ph / pw;
            } else {
              xStart = yStart ? 0 : dy * pw / ph;
              xSize = ySize * pw / ph;
            }
          }
          updateSubplots([xStart, yStart, xSize, ySize]);
          ticksAndAnnotations();
          gd.emit("plotly_relayouting", updates);
        }
        function updateMatchedAxRange(axLetter, out) {
          var matchedAxes = matches.isSubplotConstrained ? { x: yaxes, y: xaxes }[axLetter] : matches[axLetter + "axes"];
          var constrainedAxes = matches.isSubplotConstrained ? { x: xaxes, y: yaxes }[axLetter] : [];
          for (var i = 0; i < matchedAxes.length; i++) {
            var ax = matchedAxes[i];
            var axId = ax._id;
            var axId2 = matches.xLinks[axId] || matches.yLinks[axId];
            var ax2 = constrainedAxes[0] || xaHash[axId2] || yaHash[axId2];
            if (ax2) {
              if (out) {
                out[ax._name + ".range[0]"] = out[ax2._name + ".range[0]"];
                out[ax._name + ".range[1]"] = out[ax2._name + ".range[1]"];
              } else {
                ax.range = ax2.range.slice();
              }
            }
          }
        }
        function ticksAndAnnotations() {
          var activeAxIds = [];
          var i;
          function pushActiveAxIds(axList) {
            for (i = 0; i < axList.length; i++) {
              if (!axList[i].fixedrange) activeAxIds.push(axList[i]._id);
            }
          }
          function pushActiveAxIdsSynced(axList, axisType) {
            for (i = 0; i < axList.length; i++) {
              var axListI = axList[i];
              var axListIType = axListI[axisType];
              if (!axListI.fixedrange && axListIType.tickmode === "sync") activeAxIds.push(axListIType._id);
            }
          }
          if (editX) {
            pushActiveAxIds(xaxes);
            pushActiveAxIds(links.xaxes);
            pushActiveAxIds(matches.xaxes);
            pushActiveAxIdsSynced(plotinfo.overlays, "xaxis");
          }
          if (editY) {
            pushActiveAxIds(yaxes);
            pushActiveAxIds(links.yaxes);
            pushActiveAxIds(matches.yaxes);
            pushActiveAxIdsSynced(plotinfo.overlays, "yaxis");
          }
          updates = {};
          for (i = 0; i < activeAxIds.length; i++) {
            var axId = activeAxIds[i];
            var ax = getFromId(gd, axId);
            Axes.drawOne(gd, ax, { skipTitle: true });
            updates[ax._name + ".range[0]"] = ax.range[0];
            updates[ax._name + ".range[1]"] = ax.range[1];
          }
          Axes.redrawComponents(gd, activeAxIds);
        }
        function doubleClick() {
          if (gd._transitioningWithDuration) return;
          var doubleClickConfig = gd._context.doubleClick;
          var axList = [];
          if (xActive) axList = axList.concat(xaxes);
          if (yActive) axList = axList.concat(yaxes);
          if (matches.xaxes) axList = axList.concat(matches.xaxes);
          if (matches.yaxes) axList = axList.concat(matches.yaxes);
          var attrs = {};
          var ax, i;
          if (doubleClickConfig === "reset+autosize") {
            doubleClickConfig = "autosize";
            for (i = 0; i < axList.length; i++) {
              ax = axList[i];
              var r0 = ax._rangeInitial0;
              var r1 = ax._rangeInitial1;
              var hasRangeInitial = r0 !== void 0 || r1 !== void 0;
              if (hasRangeInitial && (r0 !== void 0 && r0 !== ax.range[0] || r1 !== void 0 && r1 !== ax.range[1]) || !hasRangeInitial && ax.autorange !== true) {
                doubleClickConfig = "reset";
                break;
              }
            }
          }
          if (doubleClickConfig === "autosize") {
            for (i = 0; i < axList.length; i++) {
              ax = axList[i];
              if (!ax.fixedrange) attrs[ax._name + ".autorange"] = true;
            }
          } else if (doubleClickConfig === "reset") {
            if (xActive || links.isSubplotConstrained) axList = axList.concat(links.xaxes);
            if (yActive && !links.isSubplotConstrained) axList = axList.concat(links.yaxes);
            if (links.isSubplotConstrained) {
              if (!xActive) axList = axList.concat(xaxes);
              else if (!yActive) axList = axList.concat(yaxes);
            }
            for (i = 0; i < axList.length; i++) {
              ax = axList[i];
              if (!ax.fixedrange) {
                var axName = ax._name;
                var autorangeInitial = ax._autorangeInitial;
                if (ax._rangeInitial0 === void 0 && ax._rangeInitial1 === void 0) {
                  attrs[axName + ".autorange"] = true;
                } else if (ax._rangeInitial0 === void 0) {
                  attrs[axName + ".autorange"] = autorangeInitial;
                  attrs[axName + ".range"] = [null, ax._rangeInitial1];
                } else if (ax._rangeInitial1 === void 0) {
                  attrs[axName + ".range"] = [ax._rangeInitial0, null];
                  attrs[axName + ".autorange"] = autorangeInitial;
                } else {
                  attrs[axName + ".range"] = [ax._rangeInitial0, ax._rangeInitial1];
                }
              }
            }
          }
          gd.emit("plotly_doubleclick", null);
          Registry.call("_guiRelayout", gd, attrs);
        }
        function dragTail() {
          updateSubplots([0, 0, pw, ph]);
          Lib.syncOrAsync([
            Plots.previousPromises,
            function() {
              gd._fullLayout._replotting = false;
              Registry.call("_guiRelayout", gd, updates);
            }
          ], gd);
        }
        function updateSubplots(viewBox) {
          var fullLayout = gd._fullLayout;
          var plotinfos = fullLayout._plots;
          var subplots = fullLayout._subplots.cartesian;
          var i, sp, xa, ya;
          if (hasSplom) {
            Registry.subplotsRegistry.splom.drag(gd);
          }
          if (hasScatterGl) {
            for (i = 0; i < subplots.length; i++) {
              sp = plotinfos[subplots[i]];
              xa = sp.xaxis;
              ya = sp.yaxis;
              if (sp._scene) {
                if (xa.limitRange) xa.limitRange();
                if (ya.limitRange) ya.limitRange();
                var xrng = Lib.simpleMap(xa.range, xa.r2l);
                var yrng = Lib.simpleMap(ya.range, ya.r2l);
                sp._scene.update({ range: [xrng[0], yrng[0], xrng[1], yrng[1]] });
              }
            }
          }
          if (hasSplom || hasScatterGl) {
            clearGlCanvases(gd);
            redrawReglTraces(gd);
          }
          if (hasSVG) {
            var xScaleFactor = viewBox[2] / xa0._length;
            var yScaleFactor = viewBox[3] / ya0._length;
            for (i = 0; i < subplots.length; i++) {
              sp = plotinfos[subplots[i]];
              xa = sp.xaxis;
              ya = sp.yaxis;
              var editX2 = (editX || matches.isSubplotConstrained) && !xa.fixedrange && xaHash[xa._id];
              var editY2 = (editY || matches.isSubplotConstrained) && !ya.fixedrange && yaHash[ya._id];
              var xScaleFactor2, yScaleFactor2;
              var clipDx, clipDy;
              if (editX2) {
                xScaleFactor2 = xScaleFactor;
                clipDx = ew || matches.isSubplotConstrained ? viewBox[0] : getShift(xa, xScaleFactor2);
              } else if (matches.xaHash[xa._id]) {
                xScaleFactor2 = xScaleFactor;
                clipDx = viewBox[0] * xa._length / xa0._length;
              } else if (matches.yaHash[xa._id]) {
                xScaleFactor2 = yScaleFactor;
                clipDx = yActive === "ns" ? -viewBox[1] * xa._length / ya0._length : getShift(xa, xScaleFactor2, { n: "top", s: "bottom" }[yActive]);
              } else {
                xScaleFactor2 = getLinkedScaleFactor(xa, xScaleFactor, yScaleFactor);
                clipDx = scaleAndGetShift(xa, xScaleFactor2);
              }
              if (xScaleFactor2 > 1 && (xa.maxallowed !== void 0 && editX === (xa.range[0] < xa.range[1] ? "e" : "w") || xa.minallowed !== void 0 && editX === (xa.range[0] < xa.range[1] ? "w" : "e"))) {
                xScaleFactor2 = 1;
                clipDx = 0;
              }
              if (editY2) {
                yScaleFactor2 = yScaleFactor;
                clipDy = ns || matches.isSubplotConstrained ? viewBox[1] : getShift(ya, yScaleFactor2);
              } else if (matches.yaHash[ya._id]) {
                yScaleFactor2 = yScaleFactor;
                clipDy = viewBox[1] * ya._length / ya0._length;
              } else if (matches.xaHash[ya._id]) {
                yScaleFactor2 = xScaleFactor;
                clipDy = xActive === "ew" ? -viewBox[0] * ya._length / xa0._length : getShift(ya, yScaleFactor2, { e: "right", w: "left" }[xActive]);
              } else {
                yScaleFactor2 = getLinkedScaleFactor(ya, xScaleFactor, yScaleFactor);
                clipDy = scaleAndGetShift(ya, yScaleFactor2);
              }
              if (yScaleFactor2 > 1 && (ya.maxallowed !== void 0 && editY === (ya.range[0] < ya.range[1] ? "n" : "s") || ya.minallowed !== void 0 && editY === (ya.range[0] < ya.range[1] ? "s" : "n"))) {
                yScaleFactor2 = 1;
                clipDy = 0;
              }
              if (!xScaleFactor2 && !yScaleFactor2) {
                continue;
              }
              if (!xScaleFactor2) xScaleFactor2 = 1;
              if (!yScaleFactor2) yScaleFactor2 = 1;
              var plotDx = xa._offset - clipDx / xScaleFactor2;
              var plotDy = ya._offset - clipDy / yScaleFactor2;
              sp.clipRect.call(Drawing.setTranslate, clipDx, clipDy).call(Drawing.setScale, xScaleFactor2, yScaleFactor2);
              sp.plot.call(Drawing.setTranslate, plotDx, plotDy).call(Drawing.setScale, 1 / xScaleFactor2, 1 / yScaleFactor2);
              if (xScaleFactor2 !== sp.xScaleFactor || yScaleFactor2 !== sp.yScaleFactor) {
                Drawing.setPointGroupScale(sp.zoomScalePts, xScaleFactor2, yScaleFactor2);
                Drawing.setTextPointsScale(sp.zoomScaleTxt, xScaleFactor2, yScaleFactor2);
              }
              Drawing.hideOutsideRangePoints(sp.clipOnAxisFalseTraces, sp);
              sp.xScaleFactor = xScaleFactor2;
              sp.yScaleFactor = yScaleFactor2;
            }
          }
        }
        function getLinkedScaleFactor(ax, xScaleFactor, yScaleFactor) {
          if (ax.fixedrange) return 0;
          if (editX && links.xaHash[ax._id]) {
            return xScaleFactor;
          }
          if (editY && (links.isSubplotConstrained ? links.xaHash : links.yaHash)[ax._id]) {
            return yScaleFactor;
          }
          return 0;
        }
        function scaleAndGetShift(ax, scaleFactor) {
          if (scaleFactor) {
            ax.range = ax._r.slice();
            scaleZoom(ax, scaleFactor);
            return getShift(ax, scaleFactor);
          }
          return 0;
        }
        function getShift(ax, scaleFactor, from) {
          return ax._length * (1 - scaleFactor) * FROM_TL[from || ax.constraintoward || "middle"];
        }
        return dragger;
      }
      function makeDragger(plotinfo, nodeName, dragClass, cursor) {
        var dragger3 = Lib.ensureSingle(plotinfo.draglayer, nodeName, dragClass, function(s) {
          s.classed("drag", true).style({ fill: "transparent", "stroke-width": 0 }).attr("data-subplot", plotinfo.id);
        });
        dragger3.call(setCursor, cursor);
        return dragger3.node();
      }
      function makeRectDragger(plotinfo, dragClass, cursor, x, y, w, h) {
        var dragger = makeDragger(plotinfo, "rect", dragClass, cursor);
        d3.select(dragger).call(Drawing.setRect, x, y, w, h);
        return dragger;
      }
      function isDirectionActive(axList, activeVal) {
        for (var i = 0; i < axList.length; i++) {
          if (!axList[i].fixedrange) return activeVal;
        }
        return "";
      }
      function getEndText(ax, end) {
        var initialVal = ax.range[end];
        var diff = Math.abs(initialVal - ax.range[1 - end]);
        var dig;
        if (ax.type === "date") {
          return initialVal;
        } else if (ax.type === "log") {
          dig = Math.ceil(Math.max(0, -Math.log(diff) / Math.LN10)) + 3;
          return numberFormat("." + dig + "g")(Math.pow(10, initialVal));
        } else {
          dig = Math.floor(Math.log(Math.abs(initialVal)) / Math.LN10) - Math.floor(Math.log(diff) / Math.LN10) + 4;
          return numberFormat("." + String(dig) + "g")(initialVal);
        }
      }
      function zoomAxRanges(axList, r0Fraction, r1Fraction, updates, linkedAxes) {
        for (var i = 0; i < axList.length; i++) {
          var axi = axList[i];
          if (axi.fixedrange) continue;
          if (axi.rangebreaks) {
            var isY = axi._id.charAt(0) === "y";
            var r0F = isY ? 1 - r0Fraction : r0Fraction;
            var r1F = isY ? 1 - r1Fraction : r1Fraction;
            updates[axi._name + ".range[0]"] = axi.l2r(axi.p2l(r0F * axi._length));
            updates[axi._name + ".range[1]"] = axi.l2r(axi.p2l(r1F * axi._length));
          } else {
            var axRangeLinear0 = axi._rl[0];
            var axRangeLinearSpan = axi._rl[1] - axRangeLinear0;
            updates[axi._name + ".range[0]"] = axi.l2r(axRangeLinear0 + axRangeLinearSpan * r0Fraction);
            updates[axi._name + ".range[1]"] = axi.l2r(axRangeLinear0 + axRangeLinearSpan * r1Fraction);
          }
        }
        if (linkedAxes && linkedAxes.length) {
          var linkedR0Fraction = (r0Fraction + (1 - r1Fraction)) / 2;
          zoomAxRanges(linkedAxes, linkedR0Fraction, 1 - linkedR0Fraction, updates, []);
        }
      }
      function dragAxList(axList, pix) {
        for (var i = 0; i < axList.length; i++) {
          var axi = axList[i];
          if (!axi.fixedrange) {
            if (axi.rangebreaks) {
              var p0 = 0;
              var p1 = axi._length;
              var d0 = axi.p2l(p0 + pix) - axi.p2l(p0);
              var d1 = axi.p2l(p1 + pix) - axi.p2l(p1);
              var delta = (d0 + d1) / 2;
              axi.range = [
                axi.l2r(axi._rl[0] - delta),
                axi.l2r(axi._rl[1] - delta)
              ];
            } else {
              axi.range = [
                axi.l2r(axi._rl[0] - pix / axi._m),
                axi.l2r(axi._rl[1] - pix / axi._m)
              ];
            }
            if (axi.limitRange) axi.limitRange();
          }
        }
      }
      function dZoom(d) {
        return 1 - (d >= 0 ? Math.min(d, 0.9) : 1 / (1 / Math.max(d, -0.3) + 3.222));
      }
      function getDragCursor(nsew, dragmode, isMainDrag) {
        if (!nsew) return "pointer";
        if (nsew === "nsew") {
          if (isMainDrag) return "";
          if (dragmode === "pan") return "move";
          return "crosshair";
        }
        return nsew.toLowerCase() + "-resize";
      }
      function makeZoombox(zoomlayer, lum, xs, ys, path0) {
        return zoomlayer.append("path").attr("class", "zoombox").style({
          fill: lum > 0.2 ? "rgba(0,0,0,0)" : "rgba(255,255,255,0)",
          "stroke-width": 0
        }).attr("transform", strTranslate(xs, ys)).attr("d", path0 + "Z");
      }
      function makeCorners(zoomlayer, xs, ys) {
        return zoomlayer.append("path").attr("class", "zoombox-corners").style({
          fill: Color.background,
          stroke: Color.defaultLine,
          "stroke-width": 1,
          opacity: 0
        }).attr("transform", strTranslate(xs, ys)).attr("d", "M0,0Z");
      }
      function updateZoombox(zb, corners, box, path0, dimmed, lum) {
        zb.attr(
          "d",
          path0 + "M" + box.l + "," + box.t + "v" + box.h + "h" + box.w + "v-" + box.h + "h-" + box.w + "Z"
        );
        transitionZoombox(zb, corners, dimmed, lum);
      }
      function transitionZoombox(zb, corners, dimmed, lum) {
        if (!dimmed) {
          zb.transition().style("fill", lum > 0.2 ? "rgba(0,0,0,0.4)" : "rgba(255,255,255,0.3)").duration(200);
          corners.transition().style("opacity", 1).duration(200);
        }
      }
      function removeZoombox(gd) {
        d3.select(gd).selectAll(".zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners").remove();
      }
      function showDoubleClickNotifier(gd) {
        if (SHOWZOOMOUTTIP && gd.data && gd._context.showTips) {
          Lib.notifier(Lib._(gd, "Double-click to zoom back out"), "long");
          SHOWZOOMOUTTIP = false;
        }
      }
      function xCorners(box, y0) {
        return "M" + (box.l - 0.5) + "," + (y0 - MINZOOM - 0.5) + "h-3v" + (2 * MINZOOM + 1) + "h3ZM" + (box.r + 0.5) + "," + (y0 - MINZOOM - 0.5) + "h3v" + (2 * MINZOOM + 1) + "h-3Z";
      }
      function yCorners(box, x0) {
        return "M" + (x0 - MINZOOM - 0.5) + "," + (box.t - 0.5) + "v-3h" + (2 * MINZOOM + 1) + "v3ZM" + (x0 - MINZOOM - 0.5) + "," + (box.b + 0.5) + "v3h" + (2 * MINZOOM + 1) + "v-3Z";
      }
      function xyCorners(box) {
        var clen = Math.floor(Math.min(box.b - box.t, box.r - box.l, MINZOOM) / 2);
        return "M" + (box.l - 3.5) + "," + (box.t - 0.5 + clen) + "h3v" + -clen + "h" + clen + "v-3h-" + (clen + 3) + "ZM" + (box.r + 3.5) + "," + (box.t - 0.5 + clen) + "h-3v" + -clen + "h" + -clen + "v-3h" + (clen + 3) + "ZM" + (box.r + 3.5) + "," + (box.b + 0.5 - clen) + "h-3v" + clen + "h" + -clen + "v3h" + (clen + 3) + "ZM" + (box.l - 3.5) + "," + (box.b + 0.5 - clen) + "h3v" + clen + "h" + clen + "v3h-" + (clen + 3) + "Z";
      }
      function calcLinks(gd, groups, xaHash, yaHash, exclude) {
        var isSubplotConstrained = false;
        var xLinks = {};
        var yLinks = {};
        var xID, yID, xLinkID, yLinkID;
        var xExclude = (exclude || {}).xaHash;
        var yExclude = (exclude || {}).yaHash;
        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          for (xID in xaHash) {
            if (group[xID]) {
              for (xLinkID in group) {
                if (!(exclude && (xExclude[xLinkID] || yExclude[xLinkID])) && !(xLinkID.charAt(0) === "x" ? xaHash : yaHash)[xLinkID]) {
                  xLinks[xLinkID] = xID;
                }
              }
              for (yID in yaHash) {
                if (!(exclude && (xExclude[yID] || yExclude[yID])) && group[yID]) {
                  isSubplotConstrained = true;
                }
              }
            }
          }
          for (yID in yaHash) {
            if (group[yID]) {
              for (yLinkID in group) {
                if (!(exclude && (xExclude[yLinkID] || yExclude[yLinkID])) && !(yLinkID.charAt(0) === "x" ? xaHash : yaHash)[yLinkID]) {
                  yLinks[yLinkID] = yID;
                }
              }
            }
          }
        }
        if (isSubplotConstrained) {
          Lib.extendFlat(xLinks, yLinks);
          yLinks = {};
        }
        var xaHashLinked = {};
        var xaxesLinked = [];
        for (xLinkID in xLinks) {
          var xa = getFromId(gd, xLinkID);
          xaxesLinked.push(xa);
          xaHashLinked[xa._id] = xa;
        }
        var yaHashLinked = {};
        var yaxesLinked = [];
        for (yLinkID in yLinks) {
          var ya = getFromId(gd, yLinkID);
          yaxesLinked.push(ya);
          yaHashLinked[ya._id] = ya;
        }
        return {
          xaHash: xaHashLinked,
          yaHash: yaHashLinked,
          xaxes: xaxesLinked,
          yaxes: yaxesLinked,
          xLinks,
          yLinks,
          isSubplotConstrained
        };
      }
      function attachWheelEventHandler(element, handler) {
        if (!supportsPassive) {
          if (element.onwheel !== void 0) element.onwheel = handler;
          else if (element.onmousewheel !== void 0) element.onmousewheel = handler;
          else if (!element.isAddedWheelEvent) {
            element.isAddedWheelEvent = true;
            element.addEventListener("wheel", handler, { passive: false });
          }
        } else {
          var wheelEventName = element.onwheel !== void 0 ? "wheel" : "mousewheel";
          if (element._onwheel) {
            element.removeEventListener(wheelEventName, element._onwheel);
          }
          element._onwheel = handler;
          element.addEventListener(wheelEventName, handler, { passive: false });
        }
      }
      function hashValues(hash) {
        var out = [];
        for (var k in hash) out.push(hash[k]);
        return out;
      }
      module.exports = {
        makeDragBox,
        makeDragger,
        makeRectDragger,
        makeZoombox,
        makeCorners,
        updateZoombox,
        xyCorners,
        transitionZoombox,
        removeZoombox,
        showDoubleClickNotifier,
        attachWheelEventHandler
      };
    }
  });

  // src/plots/cartesian/graph_interact.js
  var require_graph_interact = __commonJS({
    "src/plots/cartesian/graph_interact.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Fx = require_fx();
      var dragElement = require_dragelement();
      var setCursor = require_setcursor();
      var makeDragBox = require_dragbox().makeDragBox;
      var DRAGGERSIZE = require_constants2().DRAGGERSIZE;
      exports.initInteractions = function initInteractions(gd) {
        var fullLayout = gd._fullLayout;
        if (gd._context.staticPlot) {
          d3.select(gd).selectAll(".drag").remove();
          return;
        }
        if (!fullLayout._has("cartesian") && !fullLayout._has("splom")) return;
        var subplots = Object.keys(fullLayout._plots || {}).sort(function(a, b) {
          if ((fullLayout._plots[a].mainplot && true) === (fullLayout._plots[b].mainplot && true)) {
            var aParts = a.split("y");
            var bParts = b.split("y");
            return aParts[0] === bParts[0] ? Number(aParts[1] || 1) - Number(bParts[1] || 1) : Number(aParts[0] || 1) - Number(bParts[0] || 1);
          }
          return fullLayout._plots[a].mainplot ? 1 : -1;
        });
        subplots.forEach(function(subplot) {
          var plotinfo = fullLayout._plots[subplot];
          var xa = plotinfo.xaxis;
          var ya = plotinfo.yaxis;
          if (!plotinfo.mainplot) {
            var maindrag = makeDragBox(
              gd,
              plotinfo,
              xa._offset,
              ya._offset,
              xa._length,
              ya._length,
              "ns",
              "ew"
            );
            maindrag.onmousemove = function(evt) {
              gd._fullLayout._rehover = function() {
                if (gd._fullLayout._hoversubplot === subplot && gd._fullLayout._plots[subplot]) {
                  Fx.hover(gd, evt, subplot);
                }
              };
              Fx.hover(gd, evt, subplot);
              gd._fullLayout._lasthover = maindrag;
              gd._fullLayout._hoversubplot = subplot;
            };
            maindrag.onmouseout = function(evt) {
              if (gd._dragging) return;
              gd._fullLayout._hoversubplot = null;
              dragElement.unhover(gd, evt);
            };
            if (gd._context.showAxisDragHandles) {
              makeDragBox(
                gd,
                plotinfo,
                xa._offset - DRAGGERSIZE,
                ya._offset - DRAGGERSIZE,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "n",
                "w"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length,
                ya._offset - DRAGGERSIZE,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "n",
                "e"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset - DRAGGERSIZE,
                ya._offset + ya._length,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "s",
                "w"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length,
                ya._offset + ya._length,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "s",
                "e"
              );
            }
          }
          if (gd._context.showAxisDragHandles) {
            if (subplot === xa._mainSubplot) {
              var y0 = xa._mainLinePosition;
              if (xa.side === "top") y0 -= DRAGGERSIZE;
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length * 0.1,
                y0,
                xa._length * 0.8,
                DRAGGERSIZE,
                "",
                "ew"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset,
                y0,
                xa._length * 0.1,
                DRAGGERSIZE,
                "",
                "w"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length * 0.9,
                y0,
                xa._length * 0.1,
                DRAGGERSIZE,
                "",
                "e"
              );
            }
            if (subplot === ya._mainSubplot) {
              var x0 = ya._mainLinePosition;
              if (ya.side !== "right") x0 -= DRAGGERSIZE;
              makeDragBox(
                gd,
                plotinfo,
                x0,
                ya._offset + ya._length * 0.1,
                DRAGGERSIZE,
                ya._length * 0.8,
                "ns",
                ""
              );
              makeDragBox(
                gd,
                plotinfo,
                x0,
                ya._offset + ya._length * 0.9,
                DRAGGERSIZE,
                ya._length * 0.1,
                "s",
                ""
              );
              makeDragBox(
                gd,
                plotinfo,
                x0,
                ya._offset,
                DRAGGERSIZE,
                ya._length * 0.1,
                "n",
                ""
              );
            }
          }
        });
        var hoverLayer = fullLayout._hoverlayer.node();
        hoverLayer.onmousemove = function(evt) {
          evt.target = gd._fullLayout._lasthover;
          Fx.hover(gd, evt, fullLayout._hoversubplot);
        };
        hoverLayer.onclick = function(evt) {
          evt.target = gd._fullLayout._lasthover;
          Fx.click(gd, evt);
        };
        hoverLayer.onmousedown = function(evt) {
          gd._fullLayout._lasthover.onmousedown(evt);
        };
        exports.updateFx(gd);
      };
      exports.updateFx = function(gd) {
        var fullLayout = gd._fullLayout;
        var cursor = fullLayout.dragmode === "pan" ? "move" : "crosshair";
        setCursor(fullLayout._draggers, cursor);
      };
    }
  });

  // src/plot_api/container_array_match.js
  var require_container_array_match = __commonJS({
    "src/plot_api/container_array_match.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      module.exports = function containerArrayMatch(astr) {
        var rootContainers = Registry.layoutArrayContainers;
        var regexpContainers = Registry.layoutArrayRegexes;
        var rootPart = astr.split("[")[0];
        var arrayStr;
        var match;
        for (var i = 0; i < regexpContainers.length; i++) {
          match = astr.match(regexpContainers[i]);
          if (match && match.index === 0) {
            arrayStr = match[0];
            break;
          }
        }
        if (!arrayStr) arrayStr = rootContainers[rootContainers.indexOf(rootPart)];
        if (!arrayStr) return false;
        var tail = astr.substr(arrayStr.length);
        if (!tail) return { array: arrayStr, index: "", property: "" };
        match = tail.match(/^\[(0|[1-9][0-9]*)\](\.(.+))?$/);
        if (!match) return false;
        return { array: arrayStr, index: Number(match[1]), property: match[3] || "" };
      };
    }
  });

  // src/plot_api/manage_arrays.js
  var require_manage_arrays = __commonJS({
    "src/plot_api/manage_arrays.js"(exports) {
      "use strict";
      var isPlainObject = require_is_plain_object();
      var noop = require_noop();
      var Loggers = require_loggers();
      var sorterAsc = require_search().sorterAsc;
      var Registry = require_registry();
      exports.containerArrayMatch = require_container_array_match();
      var isAddVal = exports.isAddVal = function isAddVal2(val) {
        return val === "add" || isPlainObject(val);
      };
      var isRemoveVal = exports.isRemoveVal = function isRemoveVal2(val) {
        return val === null || val === "remove";
      };
      exports.applyContainerArrayChanges = function applyContainerArrayChanges(gd, np, edits, flags, _nestedProperty) {
        var componentType = np.astr;
        var supplyComponentDefaults = Registry.getComponentMethod(componentType, "supplyLayoutDefaults");
        var draw = Registry.getComponentMethod(componentType, "draw");
        var drawOne = Registry.getComponentMethod(componentType, "drawOne");
        var replotLater = flags.replot || flags.recalc || supplyComponentDefaults === noop || draw === noop;
        var layout = gd.layout;
        var fullLayout = gd._fullLayout;
        if (edits[""]) {
          if (Object.keys(edits).length > 1) {
            Loggers.warn(
              "Full array edits are incompatible with other edits",
              componentType
            );
          }
          var fullVal = edits[""][""];
          if (isRemoveVal(fullVal)) np.set(null);
          else if (Array.isArray(fullVal)) np.set(fullVal);
          else {
            Loggers.warn("Unrecognized full array edit value", componentType, fullVal);
            return true;
          }
          if (replotLater) return false;
          supplyComponentDefaults(layout, fullLayout);
          draw(gd);
          return true;
        }
        var componentNums = Object.keys(edits).map(Number).sort(sorterAsc);
        var componentArrayIn = np.get();
        var componentArray = componentArrayIn || [];
        var componentArrayFull = _nestedProperty(fullLayout, componentType).get();
        var deletes = [];
        var firstIndexChange = -1;
        var maxIndex = componentArray.length;
        var i;
        var j;
        var componentNum;
        var objEdits;
        var objKeys;
        var objVal;
        var adding, prefix;
        for (i = 0; i < componentNums.length; i++) {
          componentNum = componentNums[i];
          objEdits = edits[componentNum];
          objKeys = Object.keys(objEdits);
          objVal = objEdits[""], adding = isAddVal(objVal);
          if (componentNum < 0 || componentNum > componentArray.length - (adding ? 0 : 1)) {
            Loggers.warn("index out of range", componentType, componentNum);
            continue;
          }
          if (objVal !== void 0) {
            if (objKeys.length > 1) {
              Loggers.warn(
                "Insertion & removal are incompatible with edits to the same index.",
                componentType,
                componentNum
              );
            }
            if (isRemoveVal(objVal)) {
              deletes.push(componentNum);
            } else if (adding) {
              if (objVal === "add") objVal = {};
              componentArray.splice(componentNum, 0, objVal);
              if (componentArrayFull) componentArrayFull.splice(componentNum, 0, {});
            } else {
              Loggers.warn(
                "Unrecognized full object edit value",
                componentType,
                componentNum,
                objVal
              );
            }
            if (firstIndexChange === -1) firstIndexChange = componentNum;
          } else {
            for (j = 0; j < objKeys.length; j++) {
              prefix = componentType + "[" + componentNum + "].";
              _nestedProperty(componentArray[componentNum], objKeys[j], prefix).set(objEdits[objKeys[j]]);
            }
          }
        }
        for (i = deletes.length - 1; i >= 0; i--) {
          componentArray.splice(deletes[i], 1);
          if (componentArrayFull) componentArrayFull.splice(deletes[i], 1);
        }
        if (!componentArray.length) np.set(null);
        else if (!componentArrayIn) np.set(componentArray);
        if (replotLater) return false;
        supplyComponentDefaults(layout, fullLayout);
        if (drawOne !== noop) {
          var indicesToDraw;
          if (firstIndexChange === -1) {
            indicesToDraw = componentNums;
          } else {
            maxIndex = Math.max(componentArray.length, maxIndex);
            indicesToDraw = [];
            for (i = 0; i < componentNums.length; i++) {
              componentNum = componentNums[i];
              if (componentNum >= firstIndexChange) break;
              indicesToDraw.push(componentNum);
            }
            for (i = firstIndexChange; i < maxIndex; i++) {
              indicesToDraw.push(i);
            }
          }
          for (i = 0; i < indicesToDraw.length; i++) {
            drawOne(gd, indicesToDraw[i]);
          }
        } else draw(gd);
        return true;
      };
    }
  });

  // src/plot_api/helpers.js
  var require_helpers9 = __commonJS({
    "src/plot_api/helpers.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var m4FromQuat = require_fromQuat();
      var Registry = require_registry();
      var Lib = require_lib();
      var Plots = require_plots();
      var AxisIds = require_axis_ids();
      var Color = require_color();
      var cleanId = AxisIds.cleanId;
      var getFromTrace = AxisIds.getFromTrace;
      var traceIs = Registry.traceIs;
      exports.clearPromiseQueue = function(gd) {
        if (Array.isArray(gd._promises) && gd._promises.length > 0) {
          Lib.log("Clearing previous rejected promises from queue.");
        }
        gd._promises = [];
      };
      exports.cleanLayout = function(layout) {
        var i, j;
        if (!layout) layout = {};
        if (layout.xaxis1) {
          if (!layout.xaxis) layout.xaxis = layout.xaxis1;
          delete layout.xaxis1;
        }
        if (layout.yaxis1) {
          if (!layout.yaxis) layout.yaxis = layout.yaxis1;
          delete layout.yaxis1;
        }
        if (layout.scene1) {
          if (!layout.scene) layout.scene = layout.scene1;
          delete layout.scene1;
        }
        var axisAttrRegex = (Plots.subplotsRegistry.cartesian || {}).attrRegex;
        var polarAttrRegex = (Plots.subplotsRegistry.polar || {}).attrRegex;
        var ternaryAttrRegex = (Plots.subplotsRegistry.ternary || {}).attrRegex;
        var sceneAttrRegex = (Plots.subplotsRegistry.gl3d || {}).attrRegex;
        var keys = Object.keys(layout);
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (axisAttrRegex && axisAttrRegex.test(key)) {
            var ax = layout[key];
            if (ax.anchor && ax.anchor !== "free") {
              ax.anchor = cleanId(ax.anchor);
            }
            if (ax.overlaying) ax.overlaying = cleanId(ax.overlaying);
            if (!ax.type) {
              if (ax.isdate) ax.type = "date";
              else if (ax.islog) ax.type = "log";
              else if (ax.isdate === false && ax.islog === false) ax.type = "linear";
            }
            if (ax.autorange === "withzero" || ax.autorange === "tozero") {
              ax.autorange = true;
              ax.rangemode = "tozero";
            }
            if (ax.insiderange) delete ax.range;
            delete ax.islog;
            delete ax.isdate;
            delete ax.categories;
            if (emptyContainer(ax, "domain")) delete ax.domain;
          }
        }
        var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;
        for (i = 0; i < annotationsLen; i++) {
          var ann = layout.annotations[i];
          if (!Lib.isPlainObject(ann)) continue;
          cleanAxRef(ann, "xref");
          cleanAxRef(ann, "yref");
        }
        var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;
        for (i = 0; i < shapesLen; i++) {
          var shape = layout.shapes[i];
          if (!Lib.isPlainObject(shape)) continue;
          cleanAxRef(shape, "xref");
          cleanAxRef(shape, "yref");
        }
        var imagesLen = Array.isArray(layout.images) ? layout.images.length : 0;
        for (i = 0; i < imagesLen; i++) {
          var image = layout.images[i];
          if (!Lib.isPlainObject(image)) continue;
          cleanAxRef(image, "xref");
          cleanAxRef(image, "yref");
        }
        var legend = layout.legend;
        if (legend) {
          if (legend.x > 3) {
            legend.x = 1.02;
            legend.xanchor = "left";
          } else if (legend.x < -2) {
            legend.x = -0.02;
            legend.xanchor = "right";
          }
          if (legend.y > 3) {
            legend.y = 1.02;
            legend.yanchor = "bottom";
          } else if (legend.y < -2) {
            legend.y = -0.02;
            legend.yanchor = "top";
          }
        }
        if (layout.dragmode === "rotate") layout.dragmode = "orbit";
        Color.clean(layout);
        if (layout.template && layout.template.layout) {
          exports.cleanLayout(layout.template.layout);
        }
        return layout;
      };
      function cleanAxRef(container, attr) {
        var valIn = container[attr];
        var axLetter = attr.charAt(0);
        if (valIn && valIn !== "paper") {
          container[attr] = cleanId(valIn, axLetter, true);
        }
      }
      exports.cleanData = function(data) {
        for (var tracei = 0; tracei < data.length; tracei++) {
          var trace = data[tracei];
          var i;
          if (trace.type === "histogramy" && "xbins" in trace && !("ybins" in trace)) {
            trace.ybins = trace.xbins;
            delete trace.xbins;
          }
          if (trace.type === "histogramy") exports.swapXYData(trace);
          if (trace.type === "histogramx" || trace.type === "histogramy") {
            trace.type = "histogram";
          }
          if ("scl" in trace && !("colorscale" in trace)) {
            trace.colorscale = trace.scl;
            delete trace.scl;
          }
          if ("reversescl" in trace && !("reversescale" in trace)) {
            trace.reversescale = trace.reversescl;
            delete trace.reversescl;
          }
          if (trace.xaxis) trace.xaxis = cleanId(trace.xaxis, "x");
          if (trace.yaxis) trace.yaxis = cleanId(trace.yaxis, "y");
          if (traceIs(trace, "gl3d") && trace.scene) {
            trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);
          }
          if (!traceIs(trace, "pie-like") && !traceIs(trace, "bar-like")) {
            if (Array.isArray(trace.textposition)) {
              for (i = 0; i < trace.textposition.length; i++) {
                trace.textposition[i] = cleanTextPosition(trace.textposition[i]);
              }
            } else if (trace.textposition) {
              trace.textposition = cleanTextPosition(trace.textposition);
            }
          }
          var _module = Registry.getModule(trace);
          if (_module && _module.colorbar) {
            var containerName = _module.colorbar.container;
            var container = containerName ? trace[containerName] : trace;
            if (container && container.colorscale) {
              if (container.colorscale === "YIGnBu") container.colorscale = "YlGnBu";
              if (container.colorscale === "YIOrRd") container.colorscale = "YlOrRd";
            }
          }
          if (trace.type === "surface" && Lib.isPlainObject(trace.contours)) {
            var dims = ["x", "y", "z"];
            for (i = 0; i < dims.length; i++) {
              var opts = trace.contours[dims[i]];
              if (!Lib.isPlainObject(opts)) continue;
              if (opts.highlightColor) {
                opts.highlightcolor = opts.highlightColor;
                delete opts.highlightColor;
              }
              if (opts.highlightWidth) {
                opts.highlightwidth = opts.highlightWidth;
                delete opts.highlightWidth;
              }
            }
          }
          if (trace.type === "candlestick" || trace.type === "ohlc") {
            var increasingShowlegend = (trace.increasing || {}).showlegend !== false;
            var decreasingShowlegend = (trace.decreasing || {}).showlegend !== false;
            var increasingName = cleanFinanceDir(trace.increasing);
            var decreasingName = cleanFinanceDir(trace.decreasing);
            if (increasingName !== false && decreasingName !== false) {
              var newName = commonPrefix(
                increasingName,
                decreasingName,
                increasingShowlegend,
                decreasingShowlegend
              );
              if (newName) trace.name = newName;
            } else if ((increasingName || decreasingName) && !trace.name) {
              trace.name = increasingName || decreasingName;
            }
          }
          if (emptyContainer(trace, "line")) delete trace.line;
          if ("marker" in trace) {
            if (emptyContainer(trace.marker, "line")) delete trace.marker.line;
            if (emptyContainer(trace, "marker")) delete trace.marker;
          }
          Color.clean(trace);
          if (trace.autobinx) {
            delete trace.autobinx;
            delete trace.xbins;
          }
          if (trace.autobiny) {
            delete trace.autobiny;
            delete trace.ybins;
          }
        }
      };
      function cleanFinanceDir(dirContainer) {
        if (!Lib.isPlainObject(dirContainer)) return false;
        var dirName = dirContainer.name;
        delete dirContainer.name;
        delete dirContainer.showlegend;
        return (typeof dirName === "string" || typeof dirName === "number") && String(dirName);
      }
      function commonPrefix(name1, name2, show1, show2) {
        if (show1 && !show2) return name1;
        if (show2 && !show1) return name2;
        if (!name1.trim()) return name2;
        if (!name2.trim()) return name1;
        var minLen = Math.min(name1.length, name2.length);
        var i;
        for (i = 0; i < minLen; i++) {
          if (name1.charAt(i) !== name2.charAt(i)) break;
        }
        var out = name1.substr(0, i);
        return out.trim();
      }
      function cleanTextPosition(textposition) {
        var posY = "middle";
        var posX = "center";
        if (typeof textposition === "string") {
          if (textposition.indexOf("top") !== -1) posY = "top";
          else if (textposition.indexOf("bottom") !== -1) posY = "bottom";
          if (textposition.indexOf("left") !== -1) posX = "left";
          else if (textposition.indexOf("right") !== -1) posX = "right";
        }
        return posY + " " + posX;
      }
      function emptyContainer(outer, innerStr) {
        return innerStr in outer && typeof outer[innerStr] === "object" && Object.keys(outer[innerStr]).length === 0;
      }
      exports.swapXYData = function(trace) {
        var i;
        Lib.swapAttrs(trace, ["?", "?0", "d?", "?bins", "nbins?", "autobin?", "?src", "error_?"]);
        if (Array.isArray(trace.z) && Array.isArray(trace.z[0])) {
          if (trace.transpose) delete trace.transpose;
          else trace.transpose = true;
        }
        if (trace.error_x && trace.error_y) {
          var errorY = trace.error_y;
          var copyYstyle = "copy_ystyle" in errorY ? errorY.copy_ystyle : !(errorY.color || errorY.thickness || errorY.width);
          Lib.swapAttrs(trace, ["error_?.copy_ystyle"]);
          if (copyYstyle) {
            Lib.swapAttrs(trace, ["error_?.color", "error_?.thickness", "error_?.width"]);
          }
        }
        if (typeof trace.hoverinfo === "string") {
          var hoverInfoParts = trace.hoverinfo.split("+");
          for (i = 0; i < hoverInfoParts.length; i++) {
            if (hoverInfoParts[i] === "x") hoverInfoParts[i] = "y";
            else if (hoverInfoParts[i] === "y") hoverInfoParts[i] = "x";
          }
          trace.hoverinfo = hoverInfoParts.join("+");
        }
      };
      exports.coerceTraceIndices = function(gd, traceIndices) {
        if (isNumeric(traceIndices)) {
          return [traceIndices];
        } else if (!Array.isArray(traceIndices) || !traceIndices.length) {
          return gd.data.map(function(_, i2) {
            return i2;
          });
        } else if (Array.isArray(traceIndices)) {
          var traceIndicesOut = [];
          for (var i = 0; i < traceIndices.length; i++) {
            if (Lib.isIndex(traceIndices[i], gd.data.length)) {
              traceIndicesOut.push(traceIndices[i]);
            } else {
              Lib.warn("trace index (", traceIndices[i], ") is not a number or is out of bounds");
            }
          }
          return traceIndicesOut;
        }
        return traceIndices;
      };
      exports.manageArrayContainers = function(np, newVal, undoit) {
        var obj = np.obj;
        var parts = np.parts;
        var pLength = parts.length;
        var pLast = parts[pLength - 1];
        var pLastIsNumber = isNumeric(pLast);
        if (pLastIsNumber && newVal === null) {
          var contPath = parts.slice(0, pLength - 1).join(".");
          var cont = Lib.nestedProperty(obj, contPath).get();
          cont.splice(pLast, 1);
        } else if (pLastIsNumber && np.get() === void 0) {
          if (np.get() === void 0) undoit[np.astr] = null;
          np.set(newVal);
        } else {
          np.set(newVal);
        }
      };
      var ATTR_TAIL_RE = /(\.[^\[\]\.]+|\[[^\[\]\.]+\])$/;
      function getParent(attr) {
        var tail = attr.search(ATTR_TAIL_RE);
        if (tail > 0) return attr.substr(0, tail);
      }
      exports.hasParent = function(aobj, attr) {
        var attrParent = getParent(attr);
        while (attrParent) {
          if (attrParent in aobj) return true;
          attrParent = getParent(attrParent);
        }
        return false;
      };
      var axLetters = ["x", "y", "z"];
      exports.clearAxisTypes = function(gd, traces, layoutUpdate) {
        for (var i = 0; i < traces.length; i++) {
          var trace = gd._fullData[i];
          for (var j = 0; j < 3; j++) {
            var ax = getFromTrace(gd, trace, axLetters[j]);
            if (ax && ax.type !== "log") {
              var axAttr = ax._name;
              var sceneName = ax._id.substr(1);
              if (sceneName.substr(0, 5) === "scene") {
                if (layoutUpdate[sceneName] !== void 0) continue;
                axAttr = sceneName + "." + axAttr;
              }
              var typeAttr = axAttr + ".type";
              if (layoutUpdate[axAttr] === void 0 && layoutUpdate[typeAttr] === void 0) {
                Lib.nestedProperty(gd.layout, typeAttr).set(null);
              }
            }
          }
        }
      };
    }
  });

  // src/plot_api/plot_api.js
  var require_plot_api = __commonJS({
    "src/plot_api/plot_api.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var hasHover = require_has_hover();
      var Lib = require_lib();
      var nestedProperty = Lib.nestedProperty;
      var Events = require_events2();
      var Queue = require_queue();
      var Registry = require_registry();
      var PlotSchema = require_plot_schema();
      var Plots = require_plots();
      var Axes = require_axes();
      var handleRangeDefaults = require_range_defaults();
      var cartesianLayoutAttributes = require_layout_attributes4();
      var Drawing = require_drawing();
      var Color = require_color();
      var initInteractions = require_graph_interact().initInteractions;
      var xmlnsNamespaces = require_xmlns_namespaces();
      var clearOutline = require_selections().clearOutline;
      var dfltConfig = require_plot_config().dfltConfig;
      var manageArrays = require_manage_arrays();
      var helpers = require_helpers9();
      var subroutines = require_subroutines();
      var editTypes = require_edit_types();
      var AX_NAME_PATTERN = require_constants2().AX_NAME_PATTERN;
      var numericNameWarningCount = 0;
      var numericNameWarningCountLimit = 5;
      function _doPlot(gd, data, layout, config) {
        var frames;
        gd = Lib.getGraphDiv(gd);
        Events.init(gd);
        if (Lib.isPlainObject(data)) {
          var obj = data;
          data = obj.data;
          layout = obj.layout;
          config = obj.config;
          frames = obj.frames;
        }
        var okToPlot = Events.triggerHandler(gd, "plotly_beforeplot", [data, layout, config]);
        if (okToPlot === false) return Promise.reject();
        if (!data && !layout && !Lib.isPlotDiv(gd)) {
          Lib.warn("Calling _doPlot as if redrawing but this container doesn't yet have a plot.", gd);
        }
        function addFrames2() {
          if (frames) {
            return exports.addFrames(gd, frames);
          }
        }
        setPlotContext(gd, config);
        if (!layout) layout = {};
        d3.select(gd).classed("js-plotly-plot", true);
        Drawing.makeTester();
        if (!Array.isArray(gd._promises)) gd._promises = [];
        var graphWasEmpty = (gd.data || []).length === 0 && Array.isArray(data);
        if (Array.isArray(data)) {
          helpers.cleanData(data);
          if (graphWasEmpty) gd.data = data;
          else gd.data.push.apply(gd.data, data);
          gd.empty = false;
        }
        if (!gd.layout || graphWasEmpty) {
          gd.layout = helpers.cleanLayout(layout);
        }
        Plots.supplyDefaults(gd);
        var fullLayout = gd._fullLayout;
        var hasCartesian = fullLayout._has("cartesian");
        fullLayout._replotting = true;
        if (graphWasEmpty || fullLayout._shouldCreateBgLayer) {
          makePlotFramework(gd);
          if (fullLayout._shouldCreateBgLayer) {
            delete fullLayout._shouldCreateBgLayer;
          }
        }
        Drawing.initGradients(gd);
        Drawing.initPatterns(gd);
        if (graphWasEmpty) Axes.saveShowSpikeInitial(gd);
        var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;
        if (recalc) Plots.doCalcdata(gd);
        for (var i = 0; i < gd.calcdata.length; i++) {
          gd.calcdata[i][0].trace = gd._fullData[i];
        }
        if (gd._context.responsive) {
          if (!gd._responsiveChartHandler) {
            gd._responsiveChartHandler = function() {
              if (!Lib.isHidden(gd)) Plots.resize(gd);
            };
            window.addEventListener("resize", gd._responsiveChartHandler);
          }
        } else {
          Lib.clearResponsive(gd);
        }
        var oldMargins = Lib.extendFlat({}, fullLayout._size);
        var drawFrameworkCalls = 0;
        function drawFramework() {
          var basePlotModules = fullLayout._basePlotModules;
          for (var i2 = 0; i2 < basePlotModules.length; i2++) {
            if (basePlotModules[i2].drawFramework) {
              basePlotModules[i2].drawFramework(gd);
            }
          }
          if (!fullLayout._glcanvas && fullLayout._has("gl")) {
            fullLayout._glcanvas = fullLayout._glcontainer.selectAll(".gl-canvas").data([{
              key: "contextLayer",
              context: true,
              pick: false
            }, {
              key: "focusLayer",
              context: false,
              pick: false
            }, {
              key: "pickLayer",
              context: false,
              pick: true
            }], function(d) {
              return d.key;
            });
            fullLayout._glcanvas.enter().append("canvas").attr("class", function(d) {
              return "gl-canvas gl-canvas-" + d.key.replace("Layer", "");
            }).style({
              position: "absolute",
              top: 0,
              left: 0,
              overflow: "visible",
              "pointer-events": "none"
            });
          }
          var plotGlPixelRatio = gd._context.plotGlPixelRatio;
          if (fullLayout._glcanvas) {
            fullLayout._glcanvas.attr("width", fullLayout.width * plotGlPixelRatio).attr("height", fullLayout.height * plotGlPixelRatio).style("width", fullLayout.width + "px").style("height", fullLayout.height + "px");
            var regl = fullLayout._glcanvas.data()[0].regl;
            if (regl) {
              if (Math.floor(fullLayout.width * plotGlPixelRatio) !== regl._gl.drawingBufferWidth || Math.floor(fullLayout.height * plotGlPixelRatio) !== regl._gl.drawingBufferHeight) {
                var msg = "WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.";
                if (drawFrameworkCalls) {
                  Lib.error(msg);
                } else {
                  Lib.log(msg + " Clearing graph and plotting again.");
                  Plots.cleanPlot([], {}, gd._fullData, fullLayout);
                  Plots.supplyDefaults(gd);
                  fullLayout = gd._fullLayout;
                  Plots.doCalcdata(gd);
                  drawFrameworkCalls++;
                  return drawFramework();
                }
              }
            }
          }
          if (fullLayout.modebar.orientation === "h") {
            fullLayout._modebardiv.style("height", null).style("width", "100%");
          } else {
            fullLayout._modebardiv.style("width", null).style("height", fullLayout.height + "px");
          }
          return Plots.previousPromises(gd);
        }
        function marginPushers() {
          Plots.clearAutoMarginIds(gd);
          subroutines.drawMarginPushers(gd);
          Axes.allowAutoMargin(gd);
          if (gd._fullLayout.title.text && gd._fullLayout.title.automargin) Plots.allowAutoMargin(gd, "title.automargin");
          if (fullLayout._has("pie")) {
            var fullData = gd._fullData;
            for (var i2 = 0; i2 < fullData.length; i2++) {
              var trace = fullData[i2];
              if (trace.type === "pie" && trace.automargin) {
                Plots.allowAutoMargin(gd, "pie." + trace.uid + ".automargin");
              }
            }
          }
          Plots.doAutoMargin(gd);
          return Plots.previousPromises(gd);
        }
        function marginPushersAgain() {
          if (!Plots.didMarginChange(oldMargins, fullLayout._size)) return;
          return Lib.syncOrAsync([
            marginPushers,
            subroutines.layoutStyles
          ], gd);
        }
        function positionAndAutorange() {
          if (!recalc) {
            doAutoRangeAndConstraints();
            return;
          }
          return Lib.syncOrAsync([
            Registry.getComponentMethod("shapes", "calcAutorange"),
            Registry.getComponentMethod("annotations", "calcAutorange"),
            doAutoRangeAndConstraints
          ], gd);
        }
        function doAutoRangeAndConstraints() {
          if (gd._transitioning) return;
          subroutines.doAutoRangeAndConstraints(gd);
          if (graphWasEmpty) Axes.saveRangeInitial(gd);
          Registry.getComponentMethod("rangeslider", "calcAutorange")(gd);
        }
        function drawAxes() {
          return Axes.draw(gd, graphWasEmpty ? "" : "redraw");
        }
        var seq = [
          Plots.previousPromises,
          addFrames2,
          drawFramework,
          marginPushers,
          marginPushersAgain
        ];
        if (hasCartesian) seq.push(positionAndAutorange);
        seq.push(subroutines.layoutStyles);
        if (hasCartesian) {
          seq.push(
            drawAxes,
            function insideTickLabelsAutorange(gd2) {
              var insideTickLabelsUpdaterange = gd2._fullLayout._insideTickLabelsUpdaterange;
              if (insideTickLabelsUpdaterange) {
                gd2._fullLayout._insideTickLabelsUpdaterange = void 0;
                return relayout(gd2, insideTickLabelsUpdaterange).then(function() {
                  Axes.saveRangeInitial(gd2, true);
                });
              }
            }
          );
        }
        seq.push(
          subroutines.drawData,
          subroutines.finalDraw,
          initInteractions,
          Plots.addLinks,
          Plots.rehover,
          Plots.redrag,
          Plots.reselect,
          // TODO: doAutoMargin is only needed here for axis automargin, which
          // happens outside of marginPushers where all the other automargins are
          // calculated. Would be much better to separate margin calculations from
          // component drawing - see https://github.com/plotly/plotly.js/issues/2704
          Plots.doAutoMargin,
          Plots.previousPromises
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve();
        return plotDone.then(function() {
          emitAfterPlot(gd);
          return gd;
        });
      }
      function emitAfterPlot(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._redrawFromAutoMarginCount) {
          fullLayout._redrawFromAutoMarginCount--;
        } else {
          gd.emit("plotly_afterplot");
        }
      }
      function setPlotConfig(obj) {
        return Lib.extendFlat(dfltConfig, obj);
      }
      function setBackground(gd, bgColor) {
        try {
          gd._fullLayout._paper.style("background", bgColor);
        } catch (e) {
          Lib.error(e);
        }
      }
      function opaqueSetBackground(gd, bgColor) {
        var blend = Color.combine(bgColor, "white");
        setBackground(gd, blend);
      }
      function setPlotContext(gd, config) {
        if (!gd._context) {
          gd._context = Lib.extendDeep({}, dfltConfig);
          var base = d3.select("base");
          gd._context._baseUrl = base.size() && base.attr("href") ? window.location.href.split("#")[0] : "";
        }
        var context = gd._context;
        var i, keys, key;
        if (config) {
          keys = Object.keys(config);
          for (i = 0; i < keys.length; i++) {
            key = keys[i];
            if (key === "editable" || key === "edits") continue;
            if (key in context) {
              if (key === "setBackground" && config[key] === "opaque") {
                context[key] = opaqueSetBackground;
              } else {
                context[key] = config[key];
              }
            }
          }
          var editable = config.editable;
          if (editable !== void 0) {
            context.editable = editable;
            keys = Object.keys(context.edits);
            for (i = 0; i < keys.length; i++) {
              context.edits[keys[i]] = editable;
            }
          }
          if (config.edits) {
            keys = Object.keys(config.edits);
            for (i = 0; i < keys.length; i++) {
              key = keys[i];
              if (key in context.edits) {
                context.edits[key] = config.edits[key];
              }
            }
          }
          context._exportedPlot = config._exportedPlot;
        }
        if (context.staticPlot) {
          context.editable = false;
          context.edits = {};
          context.autosizable = false;
          context.scrollZoom = false;
          context.doubleClick = false;
          context.showTips = false;
          context.showLink = false;
          context.displayModeBar = false;
        }
        if (context.displayModeBar === "hover" && !hasHover) {
          context.displayModeBar = true;
        }
        if (context.setBackground === "transparent" || typeof context.setBackground !== "function") {
          context.setBackground = setBackground;
        }
        context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;
        context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;
        var szIn = context.scrollZoom;
        var szOut = context._scrollZoom = {};
        if (szIn === true) {
          szOut.cartesian = 1;
          szOut.gl3d = 1;
          szOut.geo = 1;
          szOut.mapbox = 1;
          szOut.map = 1;
        } else if (typeof szIn === "string") {
          var parts = szIn.split("+");
          for (i = 0; i < parts.length; i++) {
            szOut[parts[i]] = 1;
          }
        } else if (szIn !== false) {
          szOut.gl3d = 1;
          szOut.geo = 1;
          szOut.mapbox = 1;
          szOut.map = 1;
        }
      }
      function redraw(gd) {
        gd = Lib.getGraphDiv(gd);
        if (!Lib.isPlotDiv(gd)) {
          throw new Error("This element is not a Plotly plot: " + gd);
        }
        helpers.cleanData(gd.data);
        helpers.cleanLayout(gd.layout);
        gd.calcdata = void 0;
        return exports._doPlot(gd).then(function() {
          gd.emit("plotly_redraw");
          return gd;
        });
      }
      function newPlot(gd, data, layout, config) {
        gd = Lib.getGraphDiv(gd);
        Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});
        Plots.purge(gd);
        return exports._doPlot(gd, data, layout, config);
      }
      function positivifyIndices(indices, maxIndex) {
        var parentLength = maxIndex + 1;
        var positiveIndices = [];
        var i;
        var index;
        for (i = 0; i < indices.length; i++) {
          index = indices[i];
          if (index < 0) {
            positiveIndices.push(parentLength + index);
          } else {
            positiveIndices.push(index);
          }
        }
        return positiveIndices;
      }
      function assertIndexArray(gd, indices, arrayName) {
        var i, index;
        for (i = 0; i < indices.length; i++) {
          index = indices[i];
          if (index !== parseInt(index, 10)) {
            throw new Error("all values in " + arrayName + " must be integers");
          }
          if (index >= gd.data.length || index < -gd.data.length) {
            throw new Error(arrayName + " must be valid indices for gd.data.");
          }
          if (indices.indexOf(index, i + 1) > -1 || index >= 0 && indices.indexOf(-gd.data.length + index) > -1 || index < 0 && indices.indexOf(gd.data.length + index) > -1) {
            throw new Error("each index in " + arrayName + " must be unique.");
          }
        }
      }
      function checkMoveTracesArgs(gd, currentIndices, newIndices) {
        if (!Array.isArray(gd.data)) {
          throw new Error("gd.data must be an array.");
        }
        if (typeof currentIndices === "undefined") {
          throw new Error("currentIndices is a required argument.");
        } else if (!Array.isArray(currentIndices)) {
          currentIndices = [currentIndices];
        }
        assertIndexArray(gd, currentIndices, "currentIndices");
        if (typeof newIndices !== "undefined" && !Array.isArray(newIndices)) {
          newIndices = [newIndices];
        }
        if (typeof newIndices !== "undefined") {
          assertIndexArray(gd, newIndices, "newIndices");
        }
        if (typeof newIndices !== "undefined" && currentIndices.length !== newIndices.length) {
          throw new Error("current and new indices must be of equal length.");
        }
      }
      function checkAddTracesArgs(gd, traces, newIndices) {
        var i, value;
        if (!Array.isArray(gd.data)) {
          throw new Error("gd.data must be an array.");
        }
        if (typeof traces === "undefined") {
          throw new Error("traces must be defined.");
        }
        if (!Array.isArray(traces)) {
          traces = [traces];
        }
        for (i = 0; i < traces.length; i++) {
          value = traces[i];
          if (typeof value !== "object" || (Array.isArray(value) || value === null)) {
            throw new Error("all values in traces array must be non-array objects");
          }
        }
        if (typeof newIndices !== "undefined" && !Array.isArray(newIndices)) {
          newIndices = [newIndices];
        }
        if (typeof newIndices !== "undefined" && newIndices.length !== traces.length) {
          throw new Error(
            "if indices is specified, traces.length must equal indices.length"
          );
        }
      }
      function assertExtendTracesArgs(gd, update2, indices, maxPoints) {
        var maxPointsIsObject = Lib.isPlainObject(maxPoints);
        if (!Array.isArray(gd.data)) {
          throw new Error("gd.data must be an array");
        }
        if (!Lib.isPlainObject(update2)) {
          throw new Error("update must be a key:value object");
        }
        if (typeof indices === "undefined") {
          throw new Error("indices must be an integer or array of integers");
        }
        assertIndexArray(gd, indices, "indices");
        for (var key in update2) {
          if (!Array.isArray(update2[key]) || update2[key].length !== indices.length) {
            throw new Error("attribute " + key + " must be an array of length equal to indices array length");
          }
          if (maxPointsIsObject && (!(key in maxPoints) || !Array.isArray(maxPoints[key]) || maxPoints[key].length !== update2[key].length)) {
            throw new Error("when maxPoints is set as a key:value object it must contain a 1:1 corrispondence with the keys and number of traces in the update object");
          }
        }
      }
      function getExtendProperties(gd, update2, indices, maxPoints) {
        var maxPointsIsObject = Lib.isPlainObject(maxPoints);
        var updateProps = [];
        var trace, target, prop, insert, maxp;
        if (!Array.isArray(indices)) indices = [indices];
        indices = positivifyIndices(indices, gd.data.length - 1);
        for (var key in update2) {
          for (var j = 0; j < indices.length; j++) {
            trace = gd.data[indices[j]];
            prop = nestedProperty(trace, key);
            target = prop.get();
            insert = update2[key][j];
            if (!Lib.isArrayOrTypedArray(insert)) {
              throw new Error("attribute: " + key + " index: " + j + " must be an array");
            }
            if (!Lib.isArrayOrTypedArray(target)) {
              throw new Error("cannot extend missing or non-array attribute: " + key);
            }
            if (target.constructor !== insert.constructor) {
              throw new Error("cannot extend array with an array of a different type: " + key);
            }
            maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;
            if (!isNumeric(maxp)) maxp = -1;
            updateProps.push({
              prop,
              target,
              insert,
              maxp: Math.floor(maxp)
            });
          }
        }
        return updateProps;
      }
      function spliceTraces(gd, update2, indices, maxPoints, updateArray) {
        assertExtendTracesArgs(gd, update2, indices, maxPoints);
        var updateProps = getExtendProperties(gd, update2, indices, maxPoints);
        var undoUpdate = {};
        var undoPoints = {};
        for (var i = 0; i < updateProps.length; i++) {
          var prop = updateProps[i].prop;
          var maxp = updateProps[i].maxp;
          var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);
          prop.set(out[0]);
          if (!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];
          undoUpdate[prop.astr].push(out[1]);
          if (!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];
          undoPoints[prop.astr].push(updateProps[i].target.length);
        }
        return { update: undoUpdate, maxPoints: undoPoints };
      }
      function concatTypedArray(arr0, arr1) {
        var arr2 = new arr0.constructor(arr0.length + arr1.length);
        arr2.set(arr0);
        arr2.set(arr1, arr0.length);
        return arr2;
      }
      function extendTraces(gd, update2, indices, maxPoints) {
        gd = Lib.getGraphDiv(gd);
        function updateArray(target, insert, maxp) {
          var newArray, remainder;
          if (Lib.isTypedArray(target)) {
            if (maxp < 0) {
              var none = new target.constructor(0);
              var both = concatTypedArray(target, insert);
              if (maxp < 0) {
                newArray = both;
                remainder = none;
              } else {
                newArray = none;
                remainder = both;
              }
            } else {
              newArray = new target.constructor(maxp);
              remainder = new target.constructor(target.length + insert.length - maxp);
              if (maxp === insert.length) {
                newArray.set(insert);
                remainder.set(target);
              } else if (maxp < insert.length) {
                var numberOfItemsFromInsert = insert.length - maxp;
                newArray.set(insert.subarray(numberOfItemsFromInsert));
                remainder.set(target);
                remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);
              } else {
                var numberOfItemsFromTarget = maxp - insert.length;
                var targetBegin = target.length - numberOfItemsFromTarget;
                newArray.set(target.subarray(targetBegin));
                newArray.set(insert, numberOfItemsFromTarget);
                remainder.set(target.subarray(0, targetBegin));
              }
            }
          } else {
            newArray = target.concat(insert);
            remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(0, newArray.length - maxp) : [];
          }
          return [newArray, remainder];
        }
        var undo = spliceTraces(gd, update2, indices, maxPoints, updateArray);
        var promise = exports.redraw(gd);
        var undoArgs = [gd, undo.update, indices, undo.maxPoints];
        Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);
        return promise;
      }
      function prependTraces(gd, update2, indices, maxPoints) {
        gd = Lib.getGraphDiv(gd);
        function updateArray(target, insert, maxp) {
          var newArray, remainder;
          if (Lib.isTypedArray(target)) {
            if (maxp <= 0) {
              var none = new target.constructor(0);
              var both = concatTypedArray(insert, target);
              if (maxp < 0) {
                newArray = both;
                remainder = none;
              } else {
                newArray = none;
                remainder = both;
              }
            } else {
              newArray = new target.constructor(maxp);
              remainder = new target.constructor(target.length + insert.length - maxp);
              if (maxp === insert.length) {
                newArray.set(insert);
                remainder.set(target);
              } else if (maxp < insert.length) {
                var numberOfItemsFromInsert = insert.length - maxp;
                newArray.set(insert.subarray(0, numberOfItemsFromInsert));
                remainder.set(insert.subarray(numberOfItemsFromInsert));
                remainder.set(target, numberOfItemsFromInsert);
              } else {
                var numberOfItemsFromTarget = maxp - insert.length;
                newArray.set(insert);
                newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);
                remainder.set(target.subarray(numberOfItemsFromTarget));
              }
            }
          } else {
            newArray = insert.concat(target);
            remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(maxp, newArray.length) : [];
          }
          return [newArray, remainder];
        }
        var undo = spliceTraces(gd, update2, indices, maxPoints, updateArray);
        var promise = exports.redraw(gd);
        var undoArgs = [gd, undo.update, indices, undo.maxPoints];
        Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);
        return promise;
      }
      function addTraces(gd, traces, newIndices) {
        gd = Lib.getGraphDiv(gd);
        var currentIndices = [];
        var undoFunc = exports.deleteTraces;
        var redoFunc = addTraces;
        var undoArgs = [gd, currentIndices];
        var redoArgs = [gd, traces];
        var i;
        var promise;
        checkAddTracesArgs(gd, traces, newIndices);
        if (!Array.isArray(traces)) {
          traces = [traces];
        }
        traces = traces.map(function(trace) {
          return Lib.extendFlat({}, trace);
        });
        helpers.cleanData(traces);
        for (i = 0; i < traces.length; i++) {
          gd.data.push(traces[i]);
        }
        for (i = 0; i < traces.length; i++) {
          currentIndices.push(-traces.length + i);
        }
        if (typeof newIndices === "undefined") {
          promise = exports.redraw(gd);
          Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
          return promise;
        }
        if (!Array.isArray(newIndices)) {
          newIndices = [newIndices];
        }
        try {
          checkMoveTracesArgs(gd, currentIndices, newIndices);
        } catch (error) {
          gd.data.splice(gd.data.length - traces.length, traces.length);
          throw error;
        }
        Queue.startSequence(gd);
        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        promise = exports.moveTraces(gd, currentIndices, newIndices);
        Queue.stopSequence(gd);
        return promise;
      }
      function deleteTraces(gd, indices) {
        gd = Lib.getGraphDiv(gd);
        var traces = [];
        var undoFunc = exports.addTraces;
        var redoFunc = deleteTraces;
        var undoArgs = [gd, traces, indices];
        var redoArgs = [gd, indices];
        var i;
        var deletedTrace;
        if (typeof indices === "undefined") {
          throw new Error("indices must be an integer or array of integers.");
        } else if (!Array.isArray(indices)) {
          indices = [indices];
        }
        assertIndexArray(gd, indices, "indices");
        indices = positivifyIndices(indices, gd.data.length - 1);
        indices.sort(Lib.sorterDes);
        for (i = 0; i < indices.length; i += 1) {
          deletedTrace = gd.data.splice(indices[i], 1)[0];
          traces.push(deletedTrace);
        }
        var promise = exports.redraw(gd);
        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return promise;
      }
      function moveTraces(gd, currentIndices, newIndices) {
        gd = Lib.getGraphDiv(gd);
        var newData = [];
        var movingTraceMap = [];
        var undoFunc = moveTraces;
        var redoFunc = moveTraces;
        var undoArgs = [gd, newIndices, currentIndices];
        var redoArgs = [gd, currentIndices, newIndices];
        var i;
        checkMoveTracesArgs(gd, currentIndices, newIndices);
        currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];
        if (typeof newIndices === "undefined") {
          newIndices = [];
          for (i = 0; i < currentIndices.length; i++) {
            newIndices.push(-currentIndices.length + i);
          }
        }
        newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];
        currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);
        newIndices = positivifyIndices(newIndices, gd.data.length - 1);
        for (i = 0; i < gd.data.length; i++) {
          if (currentIndices.indexOf(i) === -1) {
            newData.push(gd.data[i]);
          }
        }
        for (i = 0; i < currentIndices.length; i++) {
          movingTraceMap.push({ newIndex: newIndices[i], trace: gd.data[currentIndices[i]] });
        }
        movingTraceMap.sort(function(a, b) {
          return a.newIndex - b.newIndex;
        });
        for (i = 0; i < movingTraceMap.length; i += 1) {
          newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);
        }
        gd.data = newData;
        var promise = exports.redraw(gd);
        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return promise;
      }
      function restyle(gd, astr, val, _traces) {
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        var aobj = {};
        if (typeof astr === "string") aobj[astr] = val;
        else if (Lib.isPlainObject(astr)) {
          aobj = Lib.extendFlat({}, astr);
          if (_traces === void 0) _traces = val;
        } else {
          Lib.warn("Restyle fail.", astr, val, _traces);
          return Promise.reject();
        }
        if (Object.keys(aobj).length) gd.changed = true;
        var traces = helpers.coerceTraceIndices(gd, _traces);
        var specs = _restyle(gd, aobj, traces);
        var flags = specs.flags;
        if (flags.calc) gd.calcdata = void 0;
        if (flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});
        var seq = [];
        if (flags.fullReplot) {
          seq.push(exports._doPlot);
        } else {
          seq.push(Plots.previousPromises);
          Plots.supplyDefaults(gd);
          if (flags.markerSize) {
            Plots.doCalcdata(gd);
            addAxRangeSequence(seq);
          }
          if (flags.style) seq.push(subroutines.doTraceStyle);
          if (flags.colorbars) seq.push(subroutines.doColorBars);
          seq.push(emitAfterPlot);
        }
        seq.push(
          Plots.rehover,
          Plots.redrag,
          Plots.reselect
        );
        Queue.add(
          gd,
          restyle,
          [gd, specs.undoit, specs.traces],
          restyle,
          [gd, specs.redoit, specs.traces]
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve();
        return plotDone.then(function() {
          gd.emit("plotly_restyle", specs.eventData);
          return gd;
        });
      }
      function undefinedToNull(val) {
        if (val === void 0) return null;
        return val;
      }
      function makeNP(preGUI, guiEditFlag) {
        if (!guiEditFlag) return nestedProperty;
        return function(container, attr, prefix) {
          var np = nestedProperty(container, attr);
          var npSet = np.set;
          np.set = function(val) {
            var fullAttr = (prefix || "") + attr;
            storeCurrent(fullAttr, np.get(), val, preGUI);
            npSet(val);
          };
          return np;
        };
      }
      function storeCurrent(attr, val, newVal, preGUI) {
        if (Array.isArray(val) || Array.isArray(newVal)) {
          var arrayVal = Array.isArray(val) ? val : [];
          var arrayNew = Array.isArray(newVal) ? newVal : [];
          var maxLen = Math.max(arrayVal.length, arrayNew.length);
          for (var i = 0; i < maxLen; i++) {
            storeCurrent(attr + "[" + i + "]", arrayVal[i], arrayNew[i], preGUI);
          }
        } else if (Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {
          var objVal = Lib.isPlainObject(val) ? val : {};
          var objNew = Lib.isPlainObject(newVal) ? newVal : {};
          var objBoth = Lib.extendFlat({}, objVal, objNew);
          for (var key in objBoth) {
            storeCurrent(attr + "." + key, objVal[key], objNew[key], preGUI);
          }
        } else if (preGUI[attr] === void 0) {
          preGUI[attr] = undefinedToNull(val);
        }
      }
      function _storeDirectGUIEdit(container, preGUI, edits) {
        for (var attr in edits) {
          var np = nestedProperty(container, attr);
          storeCurrent(attr, np.get(), edits[attr], preGUI);
        }
      }
      function _restyle(gd, aobj, traces) {
        var fullLayout = gd._fullLayout;
        var fullData = gd._fullData;
        var data = gd.data;
        var guiEditFlag = fullLayout._guiEditing;
        var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);
        var eventData = Lib.extendDeepAll({}, aobj);
        var i;
        var flags = editTypes.traceFlags();
        var redoit = {};
        var undoit = {};
        var axlist;
        function a0() {
          return traces.map(function() {
            return void 0;
          });
        }
        function addToAxlist(axid) {
          var axName = Axes.id2name(axid);
          if (axlist.indexOf(axName) === -1) axlist.push(axName);
        }
        function autorangeAttr(axName) {
          return "LAYOUT" + axName + ".autorange";
        }
        function rangeAttr(axName) {
          return "LAYOUT" + axName + ".range";
        }
        function getFullTrace(traceIndex) {
          for (var j = traceIndex; j < fullData.length; j++) {
            if (fullData[j]._input === data[traceIndex]) return fullData[j];
          }
        }
        function doextra(attr, val, i2) {
          if (Array.isArray(attr)) {
            attr.forEach(function(a) {
              doextra(a, val, i2);
            });
            return;
          }
          if (attr in aobj || helpers.hasParent(aobj, attr)) return;
          var extraparam;
          if (attr.substr(0, 6) === "LAYOUT") {
            extraparam = layoutNP(gd.layout, attr.replace("LAYOUT", ""));
          } else {
            var tracei = traces[i2];
            var preGUI2 = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];
            extraparam = makeNP(preGUI2, guiEditFlag)(data[tracei], attr);
          }
          if (!(attr in undoit)) {
            undoit[attr] = a0();
          }
          if (undoit[attr][i2] === void 0) {
            undoit[attr][i2] = undefinedToNull(extraparam.get());
          }
          if (val !== void 0) {
            extraparam.set(val);
          }
        }
        function allBins(binAttr) {
          return function(j) {
            return fullData[j][binAttr];
          };
        }
        function arrayBins(binAttr) {
          return function(vij, j) {
            return vij === false ? fullData[traces[j]][binAttr] : null;
          };
        }
        for (var ai in aobj) {
          if (helpers.hasParent(aobj, ai)) {
            throw new Error("cannot set " + ai + " and a parent attribute simultaneously");
          }
          var vi = aobj[ai];
          var cont;
          var contFull;
          var param;
          var oldVal;
          var newVal;
          var valObject;
          if (ai === "autobinx" || ai === "autobiny") {
            ai = ai.charAt(ai.length - 1) + "bins";
            if (Array.isArray(vi)) vi = vi.map(arrayBins(ai));
            else if (vi === false) vi = traces.map(allBins(ai));
            else vi = null;
          }
          redoit[ai] = vi;
          if (ai.substr(0, 6) === "LAYOUT") {
            param = layoutNP(gd.layout, ai.replace("LAYOUT", ""));
            undoit[ai] = [undefinedToNull(param.get())];
            param.set(Array.isArray(vi) ? vi[0] : vi);
            flags.calc = true;
            continue;
          }
          undoit[ai] = a0();
          for (i = 0; i < traces.length; i++) {
            cont = data[traces[i]];
            contFull = getFullTrace(traces[i]);
            var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];
            param = makeNP(preGUI, guiEditFlag)(cont, ai);
            oldVal = param.get();
            newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;
            if (newVal === void 0) continue;
            var finalPart = param.parts[param.parts.length - 1];
            var prefix = ai.substr(0, ai.length - finalPart.length - 1);
            var prefixDot = prefix ? prefix + "." : "";
            var innerContFull = prefix ? nestedProperty(contFull, prefix).get() : contFull;
            valObject = PlotSchema.getTraceValObject(contFull, param.parts);
            if (valObject && valObject.impliedEdits && newVal !== null) {
              for (var impliedKey in valObject.impliedEdits) {
                doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);
              }
            } else if ((finalPart === "thicknessmode" || finalPart === "lenmode") && oldVal !== newVal && (newVal === "fraction" || newVal === "pixels") && innerContFull) {
              var gs = fullLayout._size;
              var orient = innerContFull.orient;
              var topOrBottom = orient === "top" || orient === "bottom";
              if (finalPart === "thicknessmode") {
                var thicknorm = topOrBottom ? gs.h : gs.w;
                doextra(prefixDot + "thickness", innerContFull.thickness * (newVal === "fraction" ? 1 / thicknorm : thicknorm), i);
              } else {
                var lennorm = topOrBottom ? gs.w : gs.h;
                doextra(prefixDot + "len", innerContFull.len * (newVal === "fraction" ? 1 / lennorm : lennorm), i);
              }
            } else if (ai === "type" && (newVal === "pie" !== (oldVal === "pie") || newVal === "funnelarea" !== (oldVal === "funnelarea"))) {
              var labelsTo = "x";
              var valuesTo = "y";
              if ((newVal === "bar" || oldVal === "bar") && cont.orientation === "h") {
                labelsTo = "y";
                valuesTo = "x";
              }
              Lib.swapAttrs(cont, ["?", "?src"], "labels", labelsTo);
              Lib.swapAttrs(cont, ["d?", "?0"], "label", labelsTo);
              Lib.swapAttrs(cont, ["?", "?src"], "values", valuesTo);
              if (oldVal === "pie" || oldVal === "funnelarea") {
                nestedProperty(cont, "marker.color").set(nestedProperty(cont, "marker.colors").get());
                fullLayout._pielayer.selectAll("g.trace").remove();
              } else if (Registry.traceIs(cont, "cartesian")) {
                nestedProperty(cont, "marker.colors").set(nestedProperty(cont, "marker.color").get());
              }
            }
            undoit[ai][i] = undefinedToNull(oldVal);
            var swapAttrs = [
              "swapxy",
              "swapxyaxes",
              "orientation",
              "orientationaxes"
            ];
            if (swapAttrs.indexOf(ai) !== -1) {
              if (ai === "orientation") {
                param.set(newVal);
                var defaultOrientation = cont.x && !cont.y ? "h" : "v";
                if ((param.get() || defaultOrientation) === contFull.orientation) {
                  continue;
                }
              } else if (ai === "orientationaxes") {
                cont.orientation = { v: "h", h: "v" }[contFull.orientation];
              }
              helpers.swapXYData(cont);
              flags.calc = flags.clearAxisTypes = true;
            } else if (Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {
              helpers.manageArrayContainers(param, newVal, undoit);
              flags.calc = true;
            } else {
              if (valObject) {
                if (valObject.arrayOk && !Registry.traceIs(contFull, "regl") && (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))) {
                  flags.calc = true;
                } else editTypes.update(flags, valObject);
              } else {
                flags.calc = true;
              }
              param.set(newVal);
            }
          }
          if (["swapxyaxes", "orientationaxes"].indexOf(ai) !== -1) {
            Axes.swap(gd, traces);
          }
          if (ai === "orientationaxes") {
            var hovermode = nestedProperty(gd.layout, "hovermode");
            var h = hovermode.get();
            if (h === "x") {
              hovermode.set("y");
            } else if (h === "y") {
              hovermode.set("x");
            } else if (h === "x unified") {
              hovermode.set("y unified");
            } else if (h === "y unified") {
              hovermode.set("x unified");
            }
          }
          if (["orientation", "type"].indexOf(ai) !== -1) {
            axlist = [];
            for (i = 0; i < traces.length; i++) {
              var trace = data[traces[i]];
              if (Registry.traceIs(trace, "cartesian")) {
                addToAxlist(trace.xaxis || "x");
                addToAxlist(trace.yaxis || "y");
              }
            }
            doextra(axlist.map(autorangeAttr), true, 0);
            doextra(axlist.map(rangeAttr), [0, 1], 0);
          }
        }
        if (flags.calc || flags.plot) {
          flags.fullReplot = true;
        }
        return {
          flags,
          undoit,
          redoit,
          traces,
          eventData: Lib.extendDeepNoArrays([], [eventData, traces])
        };
      }
      function relayout(gd, astr, val) {
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        var aobj = {};
        if (typeof astr === "string") {
          aobj[astr] = val;
        } else if (Lib.isPlainObject(astr)) {
          aobj = Lib.extendFlat({}, astr);
        } else {
          Lib.warn("Relayout fail.", astr, val);
          return Promise.reject();
        }
        if (Object.keys(aobj).length) gd.changed = true;
        var specs = _relayout(gd, aobj);
        var flags = specs.flags;
        if (flags.calc) gd.calcdata = void 0;
        var seq = [Plots.previousPromises];
        if (flags.layoutReplot) {
          seq.push(subroutines.layoutReplot);
        } else if (Object.keys(aobj).length) {
          axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);
          if (flags.legend) seq.push(subroutines.doLegend);
          if (flags.layoutstyle) seq.push(subroutines.layoutStyles);
          if (flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);
          if (flags.ticks) seq.push(subroutines.doTicksRelayout);
          if (flags.modebar) seq.push(subroutines.doModeBar);
          if (flags.camera) seq.push(subroutines.doCamera);
          if (flags.colorbars) seq.push(subroutines.doColorBars);
          seq.push(emitAfterPlot);
        }
        seq.push(
          Plots.rehover,
          Plots.redrag,
          Plots.reselect
        );
        Queue.add(
          gd,
          relayout,
          [gd, specs.undoit],
          relayout,
          [gd, specs.redoit]
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
        return plotDone.then(function() {
          gd.emit("plotly_relayout", specs.eventData);
          return gd;
        });
      }
      function axRangeSupplyDefaultsByPass(gd, flags, specs) {
        var fullLayout = gd._fullLayout;
        if (!flags.axrange) return false;
        for (var k in flags) {
          if (k !== "axrange" && flags[k]) return false;
        }
        var axIn, axOut;
        var coerce = function(attr, dflt) {
          return Lib.coerce(axIn, axOut, cartesianLayoutAttributes, attr, dflt);
        };
        var options = {};
        for (var axId in specs.rangesAltered) {
          var axName = Axes.id2name(axId);
          axIn = gd.layout[axName];
          axOut = fullLayout[axName];
          handleRangeDefaults(axIn, axOut, coerce, options);
          if (axOut._matchGroup) {
            for (var axId2 in axOut._matchGroup) {
              if (axId2 !== axId) {
                var ax2 = fullLayout[Axes.id2name(axId2)];
                ax2.autorange = axOut.autorange;
                ax2.range = axOut.range.slice();
                ax2._input.range = axOut.range.slice();
              }
            }
          }
        }
        return true;
      }
      function addAxRangeSequence(seq, rangesAltered) {
        var drawAxes = rangesAltered ? function(gd) {
          var axIds = [];
          var skipTitle = true;
          for (var id in rangesAltered) {
            var ax = Axes.getFromId(gd, id);
            axIds.push(id);
            if ((ax.ticklabelposition || "").indexOf("inside") !== -1) {
              if (ax._anchorAxis) {
                axIds.push(ax._anchorAxis._id);
              }
            }
            if (ax._matchGroup) {
              for (var id2 in ax._matchGroup) {
                if (!rangesAltered[id2]) {
                  axIds.push(id2);
                }
              }
            }
          }
          return Axes.draw(gd, axIds, { skipTitle });
        } : function(gd) {
          return Axes.draw(gd, "redraw");
        };
        seq.push(
          clearOutline,
          subroutines.doAutoRangeAndConstraints,
          drawAxes,
          subroutines.drawData,
          subroutines.finalDraw
        );
      }
      var AX_RANGE_RE = /^[xyz]axis[0-9]*\.range(\[[0|1]\])?$/;
      var AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\.autorange$/;
      var AX_DOMAIN_RE = /^[xyz]axis[0-9]*\.domain(\[[0|1]\])?$/;
      function _relayout(gd, aobj) {
        var layout = gd.layout;
        var fullLayout = gd._fullLayout;
        var guiEditFlag = fullLayout._guiEditing;
        var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);
        var keys = Object.keys(aobj);
        var axes = Axes.list(gd);
        var eventData = Lib.extendDeepAll({}, aobj);
        var arrayEdits = {};
        var arrayStr, i, j;
        keys = Object.keys(aobj);
        for (i = 0; i < keys.length; i++) {
          if (keys[i].indexOf("allaxes") === 0) {
            for (j = 0; j < axes.length; j++) {
              var scene = axes[j]._id.substr(1);
              var axisAttr = scene.indexOf("scene") !== -1 ? scene + "." : "";
              var newkey = keys[i].replace("allaxes", axisAttr + axes[j]._name);
              if (!aobj[newkey]) aobj[newkey] = aobj[keys[i]];
            }
            delete aobj[keys[i]];
          }
        }
        var flags = editTypes.layoutFlags();
        var redoit = {};
        var undoit = {};
        function doextra(attr, val) {
          if (Array.isArray(attr)) {
            attr.forEach(function(a) {
              doextra(a, val);
            });
            return;
          }
          if (attr in aobj || helpers.hasParent(aobj, attr)) return;
          var p2 = layoutNP(layout, attr);
          if (!(attr in undoit)) {
            undoit[attr] = undefinedToNull(p2.get());
          }
          if (val !== void 0) p2.set(val);
        }
        var rangesAltered = {};
        var ax;
        function recordAlteredAxis(pleafPlus2) {
          var axId2 = Axes.name2id(pleafPlus2.split(".")[0]);
          rangesAltered[axId2] = 1;
          return axId2;
        }
        for (var ai in aobj) {
          if (helpers.hasParent(aobj, ai)) {
            throw new Error("cannot set " + ai + " and a parent attribute simultaneously");
          }
          var p = layoutNP(layout, ai);
          var vi = aobj[ai];
          var plen = p.parts.length;
          var pend = plen - 1;
          while (pend > 0 && typeof p.parts[pend] !== "string") pend--;
          var pleaf = p.parts[pend];
          var pleafPlus = p.parts[pend - 1] + "." + pleaf;
          var ptrunk = p.parts.slice(0, pend).join(".");
          var parentIn = nestedProperty(gd.layout, ptrunk).get();
          var parentFull = nestedProperty(fullLayout, ptrunk).get();
          var vOld = p.get();
          if (vi === void 0) continue;
          redoit[ai] = vi;
          undoit[ai] = pleaf === "reverse" ? vi : undefinedToNull(vOld);
          var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);
          if (valObject && valObject.impliedEdits && vi !== null) {
            for (var impliedKey in valObject.impliedEdits) {
              doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);
            }
          }
          if (["width", "height"].indexOf(ai) !== -1) {
            if (vi) {
              doextra("autosize", null);
              var oppositeAttr = ai === "height" ? "width" : "height";
              doextra(oppositeAttr, fullLayout[oppositeAttr]);
            } else {
              fullLayout[ai] = gd._initialAutoSize[ai];
            }
          } else if (ai === "autosize") {
            doextra("width", vi ? null : fullLayout.width);
            doextra("height", vi ? null : fullLayout.height);
          } else if (pleafPlus.match(AX_RANGE_RE)) {
            recordAlteredAxis(pleafPlus);
            nestedProperty(fullLayout, ptrunk + "._inputRange").set(null);
          } else if (pleafPlus.match(AX_AUTORANGE_RE)) {
            recordAlteredAxis(pleafPlus);
            nestedProperty(fullLayout, ptrunk + "._inputRange").set(null);
            var axFull = nestedProperty(fullLayout, ptrunk).get();
            if (axFull._inputDomain) {
              axFull._input.domain = axFull._inputDomain.slice();
            }
          } else if (pleafPlus.match(AX_DOMAIN_RE)) {
            nestedProperty(fullLayout, ptrunk + "._inputDomain").set(null);
          }
          if (pleaf === "type") {
            ax = parentIn;
            var toLog = parentFull.type === "linear" && vi === "log";
            var fromLog = parentFull.type === "log" && vi === "linear";
            if (toLog || fromLog) {
              if (!ax || !ax.range) {
                doextra(ptrunk + ".autorange", true);
              } else if (!parentFull.autorange) {
                var r0 = ax.range[0];
                var r1 = ax.range[1];
                if (toLog) {
                  if (r0 <= 0 && r1 <= 0) {
                    doextra(ptrunk + ".autorange", true);
                  }
                  if (r0 <= 0) r0 = r1 / 1e6;
                  else if (r1 <= 0) r1 = r0 / 1e6;
                  doextra(ptrunk + ".range[0]", Math.log(r0) / Math.LN10);
                  doextra(ptrunk + ".range[1]", Math.log(r1) / Math.LN10);
                } else {
                  doextra(ptrunk + ".range[0]", Math.pow(10, r0));
                  doextra(ptrunk + ".range[1]", Math.pow(10, r1));
                }
              } else if (toLog) {
                ax.range = ax.range[1] > ax.range[0] ? [1, 2] : [2, 1];
              }
              if (Array.isArray(fullLayout._subplots.polar) && fullLayout._subplots.polar.length && fullLayout[p.parts[0]] && p.parts[1] === "radialaxis") {
                delete fullLayout[p.parts[0]]._subplot.viewInitial["radialaxis.range"];
              }
              Registry.getComponentMethod("annotations", "convertCoords")(gd, parentFull, vi, doextra);
              Registry.getComponentMethod("images", "convertCoords")(gd, parentFull, vi, doextra);
            } else {
              doextra(ptrunk + ".autorange", true);
              doextra(ptrunk + ".range", null);
            }
            nestedProperty(fullLayout, ptrunk + "._inputRange").set(null);
          } else if (pleaf.match(AX_NAME_PATTERN)) {
            var fullProp = nestedProperty(fullLayout, ai).get();
            var newType = (vi || {}).type;
            if (!newType || newType === "-") newType = "linear";
            Registry.getComponentMethod("annotations", "convertCoords")(gd, fullProp, newType, doextra);
            Registry.getComponentMethod("images", "convertCoords")(gd, fullProp, newType, doextra);
          }
          var containerArrayMatch = manageArrays.containerArrayMatch(ai);
          if (containerArrayMatch) {
            arrayStr = containerArrayMatch.array;
            i = containerArrayMatch.index;
            var propStr = containerArrayMatch.property;
            var updateValObject = valObject || { editType: "calc" };
            if (i !== "" && propStr === "") {
              if (manageArrays.isAddVal(vi)) {
                undoit[ai] = null;
              } else if (manageArrays.isRemoveVal(vi)) {
                undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];
              } else {
                Lib.warn("unrecognized full object value", aobj);
              }
            }
            editTypes.update(flags, updateValObject);
            if (!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};
            var objEdits = arrayEdits[arrayStr][i];
            if (!objEdits) objEdits = arrayEdits[arrayStr][i] = {};
            objEdits[propStr] = vi;
            delete aobj[ai];
          } else if (pleaf === "reverse") {
            if (parentIn.range) parentIn.range.reverse();
            else {
              doextra(ptrunk + ".autorange", true);
              parentIn.range = [1, 0];
            }
            if (parentFull.autorange) flags.calc = true;
            else flags.plot = true;
          } else {
            if (ai === "dragmode" && (vi === false && vOld !== false || vi !== false && vOld === false)) {
              flags.plot = true;
            } else if (fullLayout._has("scatter-like") && fullLayout._has("regl") && (ai === "dragmode" && (vi === "lasso" || vi === "select") && !(vOld === "lasso" || vOld === "select"))) {
              flags.plot = true;
            } else if (valObject) editTypes.update(flags, valObject);
            else flags.calc = true;
            p.set(vi);
          }
        }
        for (arrayStr in arrayEdits) {
          var finished = manageArrays.applyContainerArrayChanges(
            gd,
            layoutNP(layout, arrayStr),
            arrayEdits[arrayStr],
            flags,
            layoutNP
          );
          if (!finished) flags.plot = true;
        }
        for (var axId in rangesAltered) {
          ax = Axes.getFromId(gd, axId);
          var group = ax && ax._constraintGroup;
          if (group) {
            flags.calc = true;
            for (var groupAxId in group) {
              if (!rangesAltered[groupAxId]) {
                Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;
              }
            }
          }
        }
        if (updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;
        var shapes = fullLayout.shapes;
        for (i = 0; i < shapes.length; i++) {
          if (shapes[i].showlegend) {
            flags.calc = true;
            break;
          }
        }
        if (flags.plot || flags.calc) {
          flags.layoutReplot = true;
        }
        return {
          flags,
          rangesAltered,
          undoit,
          redoit,
          eventData
        };
      }
      function updateAutosize(gd) {
        var fullLayout = gd._fullLayout;
        var oldWidth = fullLayout.width;
        var oldHeight = fullLayout.height;
        if (gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);
        return fullLayout.width !== oldWidth || fullLayout.height !== oldHeight;
      }
      function update(gd, traceUpdate, layoutUpdate, _traces) {
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        if (!Lib.isPlainObject(traceUpdate)) traceUpdate = {};
        if (!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};
        if (Object.keys(traceUpdate).length) gd.changed = true;
        if (Object.keys(layoutUpdate).length) gd.changed = true;
        var traces = helpers.coerceTraceIndices(gd, _traces);
        var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);
        var restyleFlags = restyleSpecs.flags;
        var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));
        var relayoutFlags = relayoutSpecs.flags;
        if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = void 0;
        if (restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);
        var seq = [];
        if (relayoutFlags.layoutReplot) {
          seq.push(subroutines.layoutReplot);
        } else if (restyleFlags.fullReplot) {
          seq.push(exports._doPlot);
        } else {
          seq.push(Plots.previousPromises);
          axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);
          if (restyleFlags.style) seq.push(subroutines.doTraceStyle);
          if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);
          if (relayoutFlags.legend) seq.push(subroutines.doLegend);
          if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);
          if (relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);
          if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
          if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);
          if (relayoutFlags.camera) seq.push(subroutines.doCamera);
          seq.push(emitAfterPlot);
        }
        seq.push(
          Plots.rehover,
          Plots.redrag,
          Plots.reselect
        );
        Queue.add(
          gd,
          update,
          [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces],
          update,
          [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
        return plotDone.then(function() {
          gd.emit("plotly_update", {
            data: restyleSpecs.eventData,
            layout: relayoutSpecs.eventData
          });
          return gd;
        });
      }
      function guiEdit(func) {
        return function wrappedEdit(gd) {
          gd._fullLayout._guiEditing = true;
          var p = func.apply(null, arguments);
          gd._fullLayout._guiEditing = false;
          return p;
        };
      }
      var layoutUIControlPatterns = [
        { pattern: /^hiddenlabels/, attr: "legend.uirevision" },
        { pattern: /^((x|y)axis\d*)\.((auto)?range|title\.text)/ },
        // showspikes and modes include those nested inside scenes
        { pattern: /axis\d*\.showspikes$/, attr: "modebar.uirevision" },
        { pattern: /(hover|drag)mode$/, attr: "modebar.uirevision" },
        { pattern: /^(scene\d*)\.camera/ },
        { pattern: /^(geo\d*)\.(projection|center|fitbounds)/ },
        { pattern: /^(ternary\d*\.[abc]axis)\.(min|title\.text)$/ },
        { pattern: /^(polar\d*\.radialaxis)\.((auto)?range|angle|title\.text)/ },
        { pattern: /^(polar\d*\.angularaxis)\.rotation/ },
        { pattern: /^(mapbox\d*)\.(center|zoom|bearing|pitch)/ },
        { pattern: /^(map\d*)\.(center|zoom|bearing|pitch)/ },
        { pattern: /^legend\.(x|y)$/, attr: "editrevision" },
        { pattern: /^(shapes|annotations)/, attr: "editrevision" },
        { pattern: /^title\.text$/, attr: "editrevision" }
      ];
      var traceUIControlPatterns = [
        { pattern: /^selectedpoints$/, attr: "selectionrevision" },
        // "visible" includes trace.transforms[i].styles[j].value.visible
        { pattern: /(^|value\.)visible$/, attr: "legend.uirevision" },
        { pattern: /^dimensions\[\d+\]\.constraintrange/ },
        { pattern: /^node\.(x|y|groups)/ },
        // for Sankey nodes
        { pattern: /^level$/ },
        // for Sunburst, Treemap and Icicle traces
        // below this you must be in editable: true mode
        // TODO: I still put name and title with `trace.uirevision`
        // reasonable or should these be `editrevision`?
        // Also applies to axis titles up in the layout section
        // "name" also includes transform.styles
        { pattern: /(^|value\.)name$/ },
        // including nested colorbar attributes (ie marker.colorbar)
        { pattern: /colorbar\.title\.text$/ },
        { pattern: /colorbar\.(x|y)$/, attr: "editrevision" }
      ];
      function findUIPattern(key, patternSpecs) {
        for (var i = 0; i < patternSpecs.length; i++) {
          var spec = patternSpecs[i];
          var match = key.match(spec.pattern);
          if (match) {
            var head = match[1] || "";
            return { head, tail: key.substr(head.length + 1), attr: spec.attr };
          }
        }
      }
      function getNewRev(revAttr, container) {
        var newRev = nestedProperty(container, revAttr).get();
        if (newRev !== void 0) return newRev;
        var parts = revAttr.split(".");
        parts.pop();
        while (parts.length > 1) {
          parts.pop();
          newRev = nestedProperty(container, parts.join(".") + ".uirevision").get();
          if (newRev !== void 0) return newRev;
        }
        return container.uirevision;
      }
      function getFullTraceIndexFromUid(uid, fullData) {
        for (var i = 0; i < fullData.length; i++) {
          if (fullData[i]._fullInput.uid === uid) return i;
        }
        return -1;
      }
      function getTraceIndexFromUid(uid, data, tracei) {
        for (var i = 0; i < data.length; i++) {
          if (data[i].uid === uid) return i;
        }
        return !data[tracei] || data[tracei].uid ? -1 : tracei;
      }
      function valsMatch(v1, v2) {
        var v1IsObj = Lib.isPlainObject(v1);
        var v1IsArray = Array.isArray(v1);
        if (v1IsObj || v1IsArray) {
          return (v1IsObj && Lib.isPlainObject(v2) || v1IsArray && Array.isArray(v2)) && JSON.stringify(v1) === JSON.stringify(v2);
        }
        return v1 === v2;
      }
      function applyUIRevisions(data, layout, oldFullData, oldFullLayout) {
        var layoutPreGUI = oldFullLayout._preGUI;
        var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal, head, tail;
        var bothInheritAutorange = [];
        var newAutorangeIn = {};
        var newRangeAccepted = {};
        for (key in layoutPreGUI) {
          match = findUIPattern(key, layoutUIControlPatterns);
          if (match) {
            head = match.head;
            tail = match.tail;
            revAttr = match.attr || head + ".uirevision";
            oldRev = nestedProperty(oldFullLayout, revAttr).get();
            newRev = oldRev && getNewRev(revAttr, layout);
            if (newRev && newRev === oldRev) {
              preGUIVal = layoutPreGUI[key];
              if (preGUIVal === null) preGUIVal = void 0;
              newNP = nestedProperty(layout, key);
              newVal = newNP.get();
              if (valsMatch(newVal, preGUIVal)) {
                if (newVal === void 0 && tail === "autorange") {
                  bothInheritAutorange.push(head);
                }
                newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));
                continue;
              } else if (tail === "autorange" || tail.substr(0, 6) === "range[") {
                var pre0 = layoutPreGUI[head + ".range[0]"];
                var pre1 = layoutPreGUI[head + ".range[1]"];
                var preAuto = layoutPreGUI[head + ".autorange"];
                if (preAuto || preAuto === null && pre0 === null && pre1 === null) {
                  if (!(head in newAutorangeIn)) {
                    var newContainer = nestedProperty(layout, head).get();
                    newAutorangeIn[head] = newContainer && (newContainer.autorange || newContainer.autorange !== false && (!newContainer.range || newContainer.range.length !== 2));
                  }
                  if (newAutorangeIn[head]) {
                    newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));
                    continue;
                  }
                }
              }
            }
          } else {
            Lib.warn("unrecognized GUI edit: " + key);
          }
          delete layoutPreGUI[key];
          if (match && match.tail.substr(0, 6) === "range[") {
            newRangeAccepted[match.head] = 1;
          }
        }
        for (var i = 0; i < bothInheritAutorange.length; i++) {
          var axAttr = bothInheritAutorange[i];
          if (newRangeAccepted[axAttr]) {
            var newAx = nestedProperty(layout, axAttr).get();
            if (newAx) delete newAx.autorange;
          }
        }
        var allTracePreGUI = oldFullLayout._tracePreGUI;
        for (var uid in allTracePreGUI) {
          var tracePreGUI = allTracePreGUI[uid];
          var newTrace = null;
          var fullInput;
          for (key in tracePreGUI) {
            if (!newTrace) {
              var fulli = getFullTraceIndexFromUid(uid, oldFullData);
              if (fulli < 0) {
                delete allTracePreGUI[uid];
                break;
              }
              var fullTrace = oldFullData[fulli];
              fullInput = fullTrace._fullInput;
              var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);
              if (newTracei < 0) {
                delete allTracePreGUI[uid];
                break;
              }
              newTrace = data[newTracei];
            }
            match = findUIPattern(key, traceUIControlPatterns);
            if (match) {
              if (match.attr) {
                oldRev = nestedProperty(oldFullLayout, match.attr).get();
                newRev = oldRev && getNewRev(match.attr, layout);
              } else {
                oldRev = fullInput.uirevision;
                newRev = newTrace.uirevision;
                if (newRev === void 0) newRev = layout.uirevision;
              }
              if (newRev && newRev === oldRev) {
                preGUIVal = tracePreGUI[key];
                if (preGUIVal === null) preGUIVal = void 0;
                newNP = nestedProperty(newTrace, key);
                newVal = newNP.get();
                if (valsMatch(newVal, preGUIVal)) {
                  newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));
                  continue;
                }
              }
            } else {
              Lib.warn("unrecognized GUI edit: " + key + " in trace uid " + uid);
            }
            delete tracePreGUI[key];
          }
        }
      }
      function react(gd, data, layout, config) {
        var frames, plotDone;
        function addFrames2() {
          return exports.addFrames(gd, frames);
        }
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        var oldFullData = gd._fullData;
        var oldFullLayout = gd._fullLayout;
        if (!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {
          plotDone = exports.newPlot(gd, data, layout, config);
        } else {
          if (Lib.isPlainObject(data)) {
            var obj = data;
            data = obj.data;
            layout = obj.layout;
            config = obj.config;
            frames = obj.frames;
          }
          var configChanged = false;
          if (config) {
            var oldConfig = Lib.extendDeep({}, gd._context);
            gd._context = void 0;
            setPlotContext(gd, config);
            configChanged = diffConfig(oldConfig, gd._context);
          }
          gd.data = data || [];
          helpers.cleanData(gd.data);
          gd.layout = layout || {};
          helpers.cleanLayout(gd.layout);
          applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);
          Plots.supplyDefaults(gd, { skipUpdateCalc: true });
          var newFullData = gd._fullData;
          var newFullLayout = gd._fullLayout;
          var immutable = newFullLayout.datarevision === void 0;
          var transition = newFullLayout.transition;
          var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);
          var newDataRevision = relayoutFlags.newDataRevision;
          var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);
          if (updateAutosize(gd)) relayoutFlags.layoutReplot = true;
          if (restyleFlags.calc || relayoutFlags.calc) {
            gd.calcdata = void 0;
            var allNames = Object.getOwnPropertyNames(newFullLayout);
            for (var q = 0; q < allNames.length; q++) {
              var name = allNames[q];
              var start = name.substring(0, 5);
              if (start === "xaxis" || start === "yaxis") {
                var emptyCategories = newFullLayout[name]._emptyCategories;
                if (emptyCategories) emptyCategories();
              }
            }
          } else {
            Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);
          }
          var seq = [];
          if (frames) {
            gd._transitionData = {};
            Plots.createTransitionData(gd);
            seq.push(addFrames2);
          }
          if (newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {
            if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
            Plots.doCalcdata(gd);
            subroutines.doAutoRangeAndConstraints(gd);
            seq.push(function() {
              return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);
            });
          } else if (restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {
            gd._fullLayout._skipDefaults = true;
            seq.push(exports._doPlot);
          } else {
            for (var componentType in relayoutFlags.arrays) {
              var indices = relayoutFlags.arrays[componentType];
              if (indices.length) {
                var drawOne = Registry.getComponentMethod(componentType, "drawOne");
                if (drawOne !== Lib.noop) {
                  for (var i = 0; i < indices.length; i++) {
                    drawOne(gd, indices[i]);
                  }
                } else {
                  var draw = Registry.getComponentMethod(componentType, "draw");
                  if (draw === Lib.noop) {
                    throw new Error("cannot draw components: " + componentType);
                  }
                  draw(gd);
                }
              }
            }
            seq.push(Plots.previousPromises);
            if (restyleFlags.style) seq.push(subroutines.doTraceStyle);
            if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);
            if (relayoutFlags.legend) seq.push(subroutines.doLegend);
            if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);
            if (relayoutFlags.axrange) addAxRangeSequence(seq);
            if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
            if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);
            if (relayoutFlags.camera) seq.push(subroutines.doCamera);
            seq.push(emitAfterPlot);
          }
          seq.push(
            Plots.rehover,
            Plots.redrag,
            Plots.reselect
          );
          plotDone = Lib.syncOrAsync(seq, gd);
          if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
        }
        return plotDone.then(function() {
          gd.emit("plotly_react", {
            data,
            layout
          });
          return gd;
        });
      }
      function diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {
        var sameTraceLength = oldFullData.length === newFullData.length;
        if (!transition && !sameTraceLength) {
          return {
            fullReplot: true,
            calc: true
          };
        }
        var flags = editTypes.traceFlags();
        flags.arrays = {};
        flags.nChanges = 0;
        flags.nChangesAnim = 0;
        var i, trace;
        function getTraceValObject(parts) {
          var out = PlotSchema.getTraceValObject(trace, parts);
          if (!trace._module.animatable && out.anim) {
            out.anim = false;
          }
          return out;
        }
        var diffOpts = {
          getValObject: getTraceValObject,
          flags,
          immutable,
          transition,
          newDataRevision,
          gd
        };
        var seenUIDs = {};
        for (i = 0; i < oldFullData.length; i++) {
          if (newFullData[i]) {
            trace = newFullData[i]._fullInput;
            if (seenUIDs[trace.uid]) continue;
            seenUIDs[trace.uid] = 1;
            getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);
          }
        }
        if (flags.calc || flags.plot) {
          flags.fullReplot = true;
        }
        if (transition && flags.nChanges && flags.nChangesAnim) {
          flags.anim = flags.nChanges === flags.nChangesAnim && sameTraceLength ? "all" : "some";
        }
        return flags;
      }
      function diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {
        var flags = editTypes.layoutFlags();
        flags.arrays = {};
        flags.rangesAltered = {};
        flags.nChanges = 0;
        flags.nChangesAnim = 0;
        function getLayoutValObject(parts) {
          return PlotSchema.getLayoutValObject(newFullLayout, parts);
        }
        for (var key in newFullLayout) {
          if (!key.startsWith("xaxis") && !key.startsWith("yaxis")) {
            continue;
          }
          if (!oldFullLayout[key]) {
            continue;
          }
          var newDomain = newFullLayout[key].domain;
          var oldDomain = oldFullLayout[key].domain;
          var oldInputDomain = oldFullLayout[key]._inputDomain;
          if (oldFullLayout[key]._inputDomain) {
            if (newDomain[0] === oldInputDomain[0] && newDomain[1] === oldInputDomain[1]) {
              newFullLayout[key].domain = oldFullLayout[key].domain;
            } else if (newDomain[0] !== oldDomain[0] || newDomain[1] !== oldDomain[1]) {
              newFullLayout[key]._inputDomain = null;
            }
          }
        }
        var diffOpts = {
          getValObject: getLayoutValObject,
          flags,
          immutable,
          transition,
          gd
        };
        getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);
        if (flags.plot || flags.calc) {
          flags.layoutReplot = true;
        }
        if (transition && flags.nChanges && flags.nChangesAnim) {
          flags.anim = flags.nChanges === flags.nChangesAnim ? "all" : "some";
        }
        return flags;
      }
      function getDiffFlags(oldContainer, newContainer, outerparts, opts) {
        var valObject, key, astr;
        var getValObject = opts.getValObject;
        var flags = opts.flags;
        var immutable = opts.immutable;
        var inArray = opts.inArray;
        var arrayIndex = opts.arrayIndex;
        function changed() {
          var editType = valObject.editType;
          if (inArray && editType.indexOf("arraydraw") !== -1) {
            Lib.pushUnique(flags.arrays[inArray], arrayIndex);
            return;
          }
          editTypes.update(flags, valObject);
          if (editType !== "none") {
            flags.nChanges++;
          }
          if (opts.transition && valObject.anim) {
            flags.nChangesAnim++;
          }
          if (AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {
            flags.rangesAltered[outerparts[0]] = 1;
          }
          if (key === "datarevision") {
            flags.newDataRevision = 1;
          }
        }
        function valObjectCanBeDataArray(valObject2) {
          return valObject2.valType === "data_array" || valObject2.arrayOk;
        }
        for (key in oldContainer) {
          if (flags.calc && !opts.transition) return;
          var oldVal = oldContainer[key];
          var newVal = newContainer[key];
          var parts = outerparts.concat(key);
          astr = parts.join(".");
          if (key.charAt(0) === "_" || typeof oldVal === "function" || oldVal === newVal) continue;
          if ((key === "tick0" || key === "dtick") && outerparts[0] !== "geo") {
            var tickMode = newContainer.tickmode;
            if (tickMode === "auto" || tickMode === "array" || !tickMode) continue;
          }
          if (key === "range" && newContainer.autorange) continue;
          if ((key === "zmin" || key === "zmax") && newContainer.type === "contourcarpet") continue;
          valObject = getValObject(parts);
          if (!valObject) continue;
          if (valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;
          var valType = valObject.valType;
          var i;
          var canBeDataArray = valObjectCanBeDataArray(valObject);
          var wasArray = Array.isArray(oldVal);
          var nowArray = Array.isArray(newVal);
          if (wasArray && nowArray) {
            var inputKey = "_input_" + key;
            var oldValIn = oldContainer[inputKey];
            var newValIn = newContainer[inputKey];
            if (Array.isArray(oldValIn) && oldValIn === newValIn) continue;
          }
          if (newVal === void 0) {
            if (canBeDataArray && wasArray) flags.calc = true;
            else changed();
          } else if (valObject._isLinkedToArray) {
            var arrayEditIndices = [];
            var extraIndices = false;
            if (!inArray) flags.arrays[key] = arrayEditIndices;
            var minLen = Math.min(oldVal.length, newVal.length);
            var maxLen = Math.max(oldVal.length, newVal.length);
            if (minLen !== maxLen) {
              if (valObject.editType === "arraydraw") {
                extraIndices = true;
              } else {
                changed();
                continue;
              }
            }
            for (i = 0; i < minLen; i++) {
              getDiffFlags(
                oldVal[i],
                newVal[i],
                parts.concat(i),
                // add array indices, but not if we're already in an array
                Lib.extendFlat({ inArray: key, arrayIndex: i }, opts)
              );
            }
            if (extraIndices) {
              for (i = minLen; i < maxLen; i++) {
                arrayEditIndices.push(i);
              }
            }
          } else if (!valType && Lib.isPlainObject(oldVal)) {
            getDiffFlags(oldVal, newVal, parts, opts);
          } else if (canBeDataArray) {
            if (wasArray && nowArray) {
              if (immutable) {
                flags.calc = true;
              }
              if (immutable || opts.newDataRevision) {
                changed();
              }
            } else if (wasArray !== nowArray) {
              flags.calc = true;
            } else changed();
          } else if (wasArray && nowArray) {
            if (oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {
              changed();
            }
          } else {
            changed();
          }
        }
        for (key in newContainer) {
          if (!(key in oldContainer || key.charAt(0) === "_" || typeof newContainer[key] === "function")) {
            valObject = getValObject(outerparts.concat(key));
            if (valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {
              flags.calc = true;
              return;
            } else changed();
          }
        }
      }
      function diffConfig(oldConfig, newConfig) {
        var key;
        for (key in oldConfig) {
          if (key.charAt(0) === "_") continue;
          var oldVal = oldConfig[key];
          var newVal = newConfig[key];
          if (oldVal !== newVal) {
            if (Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {
              if (diffConfig(oldVal, newVal)) {
                return true;
              }
            } else if (Array.isArray(oldVal) && Array.isArray(newVal)) {
              if (oldVal.length !== newVal.length) {
                return true;
              }
              for (var i = 0; i < oldVal.length; i++) {
                if (oldVal[i] !== newVal[i]) {
                  if (Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {
                    if (diffConfig(oldVal[i], newVal[i])) {
                      return true;
                    }
                  } else {
                    return true;
                  }
                }
              }
            } else {
              return true;
            }
          }
        }
      }
      function animate(gd, frameOrGroupNameOrFrameList, animationOpts) {
        gd = Lib.getGraphDiv(gd);
        if (!Lib.isPlotDiv(gd)) {
          throw new Error(
            "This element is not a Plotly plot: " + gd + ". It's likely that you've failed to create a plot before animating it. For more details, see https://plotly.com/javascript/animations/"
          );
        }
        var trans = gd._transitionData;
        if (!trans._frameQueue) {
          trans._frameQueue = [];
        }
        animationOpts = Plots.supplyAnimationDefaults(animationOpts);
        var transitionOpts = animationOpts.transition;
        var frameOpts = animationOpts.frame;
        if (trans._frameWaitingCnt === void 0) {
          trans._frameWaitingCnt = 0;
        }
        function getTransitionOpts(i) {
          if (Array.isArray(transitionOpts)) {
            if (i >= transitionOpts.length) {
              return transitionOpts[0];
            } else {
              return transitionOpts[i];
            }
          } else {
            return transitionOpts;
          }
        }
        function getFrameOpts(i) {
          if (Array.isArray(frameOpts)) {
            if (i >= frameOpts.length) {
              return frameOpts[0];
            } else {
              return frameOpts[i];
            }
          } else {
            return frameOpts;
          }
        }
        function callbackOnNthTime(cb, n) {
          var cnt = 0;
          return function() {
            if (cb && ++cnt === n) {
              return cb();
            }
          };
        }
        return new Promise(function(resolve, reject) {
          function discardExistingFrames() {
            if (trans._frameQueue.length === 0) {
              return;
            }
            while (trans._frameQueue.length) {
              var next = trans._frameQueue.pop();
              if (next.onInterrupt) {
                next.onInterrupt();
              }
            }
            gd.emit("plotly_animationinterrupted", []);
          }
          function queueFrames(frameList2) {
            if (frameList2.length === 0) return;
            for (var i2 = 0; i2 < frameList2.length; i2++) {
              var computedFrame;
              if (frameList2[i2].type === "byname") {
                computedFrame = Plots.computeFrame(gd, frameList2[i2].name);
              } else {
                computedFrame = frameList2[i2].data;
              }
              var frameOpts2 = getFrameOpts(i2);
              var transitionOpts2 = getTransitionOpts(i2);
              transitionOpts2.duration = Math.min(transitionOpts2.duration, frameOpts2.duration);
              var nextFrame2 = {
                frame: computedFrame,
                name: frameList2[i2].name,
                frameOpts: frameOpts2,
                transitionOpts: transitionOpts2
              };
              if (i2 === frameList2.length - 1) {
                nextFrame2.onComplete = callbackOnNthTime(resolve, 2);
                nextFrame2.onInterrupt = reject;
              }
              trans._frameQueue.push(nextFrame2);
            }
            if (animationOpts.mode === "immediate") {
              trans._lastFrameAt = -Infinity;
            }
            if (!trans._animationRaf) {
              beginAnimationLoop();
            }
          }
          function stopAnimationLoop() {
            gd.emit("plotly_animated");
            window.cancelAnimationFrame(trans._animationRaf);
            trans._animationRaf = null;
          }
          function nextFrame() {
            if (trans._currentFrame && trans._currentFrame.onComplete) {
              trans._currentFrame.onComplete();
            }
            var newFrame = trans._currentFrame = trans._frameQueue.shift();
            if (newFrame) {
              var stringName = newFrame.name ? newFrame.name.toString() : null;
              gd._fullLayout._currentFrame = stringName;
              trans._lastFrameAt = Date.now();
              trans._timeToNext = newFrame.frameOpts.duration;
              Plots.transition(
                gd,
                newFrame.frame.data,
                newFrame.frame.layout,
                helpers.coerceTraceIndices(gd, newFrame.frame.traces),
                newFrame.frameOpts,
                newFrame.transitionOpts
              ).then(function() {
                if (newFrame.onComplete) {
                  newFrame.onComplete();
                }
              });
              gd.emit("plotly_animatingframe", {
                name: stringName,
                frame: newFrame.frame,
                animation: {
                  frame: newFrame.frameOpts,
                  transition: newFrame.transitionOpts
                }
              });
            } else {
              stopAnimationLoop();
            }
          }
          function beginAnimationLoop() {
            gd.emit("plotly_animating");
            trans._lastFrameAt = -Infinity;
            trans._timeToNext = 0;
            trans._runningTransitions = 0;
            trans._currentFrame = null;
            var doFrame = function() {
              trans._animationRaf = window.requestAnimationFrame(doFrame);
              if (Date.now() - trans._lastFrameAt > trans._timeToNext) {
                nextFrame();
              }
            };
            doFrame();
          }
          var configCounter = 0;
          function setTransitionConfig(frame2) {
            if (Array.isArray(transitionOpts)) {
              if (configCounter >= transitionOpts.length) {
                frame2.transitionOpts = transitionOpts[configCounter];
              } else {
                frame2.transitionOpts = transitionOpts[0];
              }
            } else {
              frame2.transitionOpts = transitionOpts;
            }
            configCounter++;
            return frame2;
          }
          var i, frame;
          var frameList = [];
          var allFrames = frameOrGroupNameOrFrameList === void 0 || frameOrGroupNameOrFrameList === null;
          var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);
          var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);
          if (isSingleFrame) {
            frameList.push({
              type: "object",
              data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))
            });
          } else if (allFrames || ["string", "number"].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {
            for (i = 0; i < trans._frames.length; i++) {
              frame = trans._frames[i];
              if (!frame) continue;
              if (allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {
                frameList.push({
                  type: "byname",
                  name: String(frame.name),
                  data: setTransitionConfig({ name: frame.name })
                });
              }
            }
          } else if (isFrameArray) {
            for (i = 0; i < frameOrGroupNameOrFrameList.length; i++) {
              var frameOrName = frameOrGroupNameOrFrameList[i];
              if (["number", "string"].indexOf(typeof frameOrName) !== -1) {
                frameOrName = String(frameOrName);
                frameList.push({
                  type: "byname",
                  name: frameOrName,
                  data: setTransitionConfig({ name: frameOrName })
                });
              } else if (Lib.isPlainObject(frameOrName)) {
                frameList.push({
                  type: "object",
                  data: setTransitionConfig(Lib.extendFlat({}, frameOrName))
                });
              }
            }
          }
          for (i = 0; i < frameList.length; i++) {
            frame = frameList[i];
            if (frame.type === "byname" && !trans._frameHash[frame.data.name]) {
              Lib.warn('animate failure: frame not found: "' + frame.data.name + '"');
              reject();
              return;
            }
          }
          if (["next", "immediate"].indexOf(animationOpts.mode) !== -1) {
            discardExistingFrames();
          }
          if (animationOpts.direction === "reverse") {
            frameList.reverse();
          }
          var currentFrame = gd._fullLayout._currentFrame;
          if (currentFrame && animationOpts.fromcurrent) {
            var idx = -1;
            for (i = 0; i < frameList.length; i++) {
              frame = frameList[i];
              if (frame.type === "byname" && frame.name === currentFrame) {
                idx = i;
                break;
              }
            }
            if (idx > 0 && idx < frameList.length - 1) {
              var filteredFrameList = [];
              for (i = 0; i < frameList.length; i++) {
                frame = frameList[i];
                if (frameList[i].type !== "byname" || i > idx) {
                  filteredFrameList.push(frame);
                }
              }
              frameList = filteredFrameList;
            }
          }
          if (frameList.length > 0) {
            queueFrames(frameList);
          } else {
            gd.emit("plotly_animated");
            resolve();
          }
        });
      }
      function addFrames(gd, frameList, indices) {
        gd = Lib.getGraphDiv(gd);
        if (frameList === null || frameList === void 0) {
          return Promise.resolve();
        }
        if (!Lib.isPlotDiv(gd)) {
          throw new Error(
            "This element is not a Plotly plot: " + gd + ". It's likely that you've failed to create a plot before adding frames. For more details, see https://plotly.com/javascript/animations/"
          );
        }
        var i, frame, j, idx;
        var _frames = gd._transitionData._frames;
        var _frameHash = gd._transitionData._frameHash;
        if (!Array.isArray(frameList)) {
          throw new Error("addFrames failure: frameList must be an Array of frame definitions" + frameList);
        }
        var bigIndex = _frames.length + frameList.length * 2;
        var insertions = [];
        var _frameHashLocal = {};
        for (i = frameList.length - 1; i >= 0; i--) {
          if (!Lib.isPlainObject(frameList[i])) continue;
          var lookupName = frameList[i].name;
          var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;
          var newName = frameList[i].name;
          var collisionPresent = _frameHash[name] || _frameHashLocal[name];
          if (name && newName && typeof newName === "number" && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {
            numericNameWarningCount++;
            Lib.warn('addFrames: overwriting frame "' + (_frameHash[name] || _frameHashLocal[name]).name + '" with a frame whose name of type "number" also equates to "' + name + '". This is valid but may potentially lead to unexpected behavior since all plotly.js frame names are stored internally as strings.');
            if (numericNameWarningCount === numericNameWarningCountLimit) {
              Lib.warn("addFrames: This API call has yielded too many of these warnings. For the rest of this call, further warnings about numeric frame names will be suppressed.");
            }
          }
          _frameHashLocal[lookupName] = { name: lookupName };
          insertions.push({
            frame: Plots.supplyFrameDefaults(frameList[i]),
            index: indices && indices[i] !== void 0 && indices[i] !== null ? indices[i] : bigIndex + i
          });
        }
        insertions.sort(function(a, b) {
          if (a.index > b.index) return -1;
          if (a.index < b.index) return 1;
          return 0;
        });
        var ops = [];
        var revops = [];
        var frameCount = _frames.length;
        for (i = insertions.length - 1; i >= 0; i--) {
          frame = insertions[i].frame;
          if (typeof frame.name === "number") {
            Lib.warn("Warning: addFrames accepts frames with numeric names, but the numbers areimplicitly cast to strings");
          }
          if (!frame.name) {
            while (_frameHash[frame.name = "frame " + gd._transitionData._counter++]) ;
          }
          if (_frameHash[frame.name]) {
            for (j = 0; j < _frames.length; j++) {
              if ((_frames[j] || {}).name === frame.name) break;
            }
            ops.push({ type: "replace", index: j, value: frame });
            revops.unshift({ type: "replace", index: j, value: _frames[j] });
          } else {
            idx = Math.max(0, Math.min(insertions[i].index, frameCount));
            ops.push({ type: "insert", index: idx, value: frame });
            revops.unshift({ type: "delete", index: idx });
            frameCount++;
          }
        }
        var undoFunc = Plots.modifyFrames;
        var redoFunc = Plots.modifyFrames;
        var undoArgs = [gd, revops];
        var redoArgs = [gd, ops];
        if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return Plots.modifyFrames(gd, ops);
      }
      function deleteFrames(gd, frameList) {
        gd = Lib.getGraphDiv(gd);
        if (!Lib.isPlotDiv(gd)) {
          throw new Error("This element is not a Plotly plot: " + gd);
        }
        var i, idx;
        var _frames = gd._transitionData._frames;
        var ops = [];
        var revops = [];
        if (!frameList) {
          frameList = [];
          for (i = 0; i < _frames.length; i++) {
            frameList.push(i);
          }
        }
        frameList = frameList.slice();
        frameList.sort();
        for (i = frameList.length - 1; i >= 0; i--) {
          idx = frameList[i];
          ops.push({ type: "delete", index: idx });
          revops.unshift({ type: "insert", index: idx, value: _frames[idx] });
        }
        var undoFunc = Plots.modifyFrames;
        var redoFunc = Plots.modifyFrames;
        var undoArgs = [gd, revops];
        var redoArgs = [gd, ops];
        if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return Plots.modifyFrames(gd, ops);
      }
      function purge(gd) {
        gd = Lib.getGraphDiv(gd);
        var fullLayout = gd._fullLayout || {};
        var fullData = gd._fullData || [];
        Plots.cleanPlot([], {}, fullData, fullLayout);
        Plots.purge(gd);
        Events.purge(gd);
        if (fullLayout._container) fullLayout._container.remove();
        delete gd._context;
        return gd;
      }
      function calcInverseTransform(gd) {
        var fullLayout = gd._fullLayout;
        var newBBox = gd.getBoundingClientRect();
        if (Lib.equalDomRects(newBBox, fullLayout._lastBBox)) return;
        var m = fullLayout._invTransform = Lib.inverseTransformMatrix(Lib.getFullTransformMatrix(gd));
        fullLayout._invScaleX = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);
        fullLayout._invScaleY = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);
        fullLayout._lastBBox = newBBox;
      }
      function makePlotFramework(gd) {
        var gd3 = d3.select(gd);
        var fullLayout = gd._fullLayout;
        fullLayout._calcInverseTransform = calcInverseTransform;
        fullLayout._calcInverseTransform(gd);
        fullLayout._container = gd3.selectAll(".plot-container").data([0]);
        fullLayout._container.enter().insert("div", ":first-child").classed("plot-container", true).classed("plotly", true).style({
          width: "100%",
          height: "100%"
        });
        fullLayout._paperdiv = fullLayout._container.selectAll(".svg-container").data([0]);
        fullLayout._paperdiv.enter().append("div").classed("user-select-none", true).classed("svg-container", true).style("position", "relative");
        fullLayout._glcontainer = fullLayout._paperdiv.selectAll(".gl-container").data([{}]);
        fullLayout._glcontainer.enter().append("div").classed("gl-container", true);
        fullLayout._paperdiv.selectAll(".main-svg").remove();
        fullLayout._paperdiv.select(".modebar-container").remove();
        fullLayout._paper = fullLayout._paperdiv.insert("svg", ":first-child").classed("main-svg", true);
        fullLayout._toppaper = fullLayout._paperdiv.append("svg").classed("main-svg", true);
        fullLayout._modebardiv = fullLayout._paperdiv.append("div");
        delete fullLayout._modeBar;
        fullLayout._hoverpaper = fullLayout._paperdiv.append("svg").classed("main-svg", true);
        if (!fullLayout._uid) {
          var otherUids = {};
          d3.selectAll("defs").each(function() {
            if (this.id) otherUids[this.id.split("-")[1]] = 1;
          });
          fullLayout._uid = Lib.randstr(otherUids);
        }
        fullLayout._paperdiv.selectAll(".main-svg").attr(xmlnsNamespaces.svgAttrs);
        fullLayout._defs = fullLayout._paper.append("defs").attr("id", "defs-" + fullLayout._uid);
        fullLayout._clips = fullLayout._defs.append("g").classed("clips", true);
        fullLayout._topdefs = fullLayout._toppaper.append("defs").attr("id", "topdefs-" + fullLayout._uid);
        fullLayout._topclips = fullLayout._topdefs.append("g").classed("clips", true);
        fullLayout._bgLayer = fullLayout._paper.append("g").classed("bglayer", true);
        fullLayout._draggers = fullLayout._paper.append("g").classed("draglayer", true);
        var layerBelow = fullLayout._paper.append("g").classed("layer-below", true);
        fullLayout._imageLowerLayer = layerBelow.append("g").classed("imagelayer", true);
        fullLayout._shapeLowerLayer = layerBelow.append("g").classed("shapelayer", true);
        fullLayout._cartesianlayer = fullLayout._paper.append("g").classed("cartesianlayer", true);
        fullLayout._polarlayer = fullLayout._paper.append("g").classed("polarlayer", true);
        fullLayout._smithlayer = fullLayout._paper.append("g").classed("smithlayer", true);
        fullLayout._ternarylayer = fullLayout._paper.append("g").classed("ternarylayer", true);
        fullLayout._geolayer = fullLayout._paper.append("g").classed("geolayer", true);
        fullLayout._funnelarealayer = fullLayout._paper.append("g").classed("funnelarealayer", true);
        fullLayout._pielayer = fullLayout._paper.append("g").classed("pielayer", true);
        fullLayout._iciclelayer = fullLayout._paper.append("g").classed("iciclelayer", true);
        fullLayout._treemaplayer = fullLayout._paper.append("g").classed("treemaplayer", true);
        fullLayout._sunburstlayer = fullLayout._paper.append("g").classed("sunburstlayer", true);
        fullLayout._indicatorlayer = fullLayout._toppaper.append("g").classed("indicatorlayer", true);
        fullLayout._glimages = fullLayout._paper.append("g").classed("glimages", true);
        var layerAbove = fullLayout._toppaper.append("g").classed("layer-above", true);
        fullLayout._imageUpperLayer = layerAbove.append("g").classed("imagelayer", true);
        fullLayout._shapeUpperLayer = layerAbove.append("g").classed("shapelayer", true);
        fullLayout._selectionLayer = fullLayout._toppaper.append("g").classed("selectionlayer", true);
        fullLayout._infolayer = fullLayout._toppaper.append("g").classed("infolayer", true);
        fullLayout._menulayer = fullLayout._toppaper.append("g").classed("menulayer", true);
        fullLayout._zoomlayer = fullLayout._toppaper.append("g").classed("zoomlayer", true);
        fullLayout._hoverlayer = fullLayout._hoverpaper.append("g").classed("hoverlayer", true);
        fullLayout._modebardiv.classed("modebar-container", true).style("position", "absolute").style("top", "0px").style("right", "0px");
        gd.emit("plotly_framework");
      }
      exports.animate = animate;
      exports.addFrames = addFrames;
      exports.deleteFrames = deleteFrames;
      exports.addTraces = addTraces;
      exports.deleteTraces = deleteTraces;
      exports.extendTraces = extendTraces;
      exports.moveTraces = moveTraces;
      exports.prependTraces = prependTraces;
      exports.newPlot = newPlot;
      exports._doPlot = _doPlot;
      exports.purge = purge;
      exports.react = react;
      exports.redraw = redraw;
      exports.relayout = relayout;
      exports.restyle = restyle;
      exports.setPlotConfig = setPlotConfig;
      exports.update = update;
      exports._guiRelayout = guiEdit(relayout);
      exports._guiRestyle = guiEdit(restyle);
      exports._guiUpdate = guiEdit(update);
      exports._storeDirectGUIEdit = _storeDirectGUIEdit;
    }
  });

  // src/snapshot/helpers.js
  var require_helpers10 = __commonJS({
    "src/snapshot/helpers.js"(exports) {
      "use strict";
      var Registry = require_registry();
      exports.getDelay = function(fullLayout) {
        if (!fullLayout._has) return 0;
        return fullLayout._has("gl3d") || fullLayout._has("mapbox") || fullLayout._has("map") ? 500 : 0;
      };
      exports.getRedrawFunc = function(gd) {
        return function() {
          Registry.getComponentMethod("colorbar", "draw")(gd);
        };
      };
      exports.encodeSVG = function(svg) {
        return "data:image/svg+xml," + encodeURIComponent(svg);
      };
      exports.encodeJSON = function(json) {
        return "data:application/json," + encodeURIComponent(json);
      };
      var DOM_URL = window.URL || window.webkitURL;
      exports.createObjectURL = function(blob) {
        return DOM_URL.createObjectURL(blob);
      };
      exports.revokeObjectURL = function(url) {
        return DOM_URL.revokeObjectURL(url);
      };
      exports.createBlob = function(url, format) {
        if (format === "svg") {
          return new window.Blob([url], { type: "image/svg+xml;charset=utf-8" });
        } else if (format === "full-json") {
          return new window.Blob([url], { type: "application/json;charset=utf-8" });
        } else {
          var binary = fixBinary(window.atob(url));
          return new window.Blob([binary], { type: "image/" + format });
        }
      };
      exports.octetStream = function(s) {
        document.location.href = "data:application/octet-stream" + s;
      };
      function fixBinary(b) {
        var len = b.length;
        var buf = new ArrayBuffer(len);
        var arr = new Uint8Array(buf);
        for (var i = 0; i < len; i++) {
          arr[i] = b.charCodeAt(i);
        }
        return buf;
      }
      exports.IMAGE_URL_PREFIX = /^data:image\/\w+;base64,/;
    }
  });

  // src/snapshot/tosvg.js
  var require_tosvg = __commonJS({
    "src/snapshot/tosvg.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var Drawing = require_drawing();
      var Color = require_color();
      var xmlnsNamespaces = require_xmlns_namespaces();
      var DOUBLEQUOTE_REGEX = /"/g;
      var DUMMY_SUB = "TOBESTRIPPED";
      var DUMMY_REGEX = new RegExp('("' + DUMMY_SUB + ")|(" + DUMMY_SUB + '")', "g");
      function htmlEntityDecode(s) {
        var hiddenDiv = d3.select("body").append("div").style({ display: "none" }).html("");
        var replaced = s.replace(/(&[^;]*;)/gi, function(d) {
          if (d === "&lt;") {
            return "&#60;";
          }
          if (d === "&rt;") {
            return "&#62;";
          }
          if (d.indexOf("<") !== -1 || d.indexOf(">") !== -1) {
            return "";
          }
          return hiddenDiv.html(d).text();
        });
        hiddenDiv.remove();
        return replaced;
      }
      function xmlEntityEncode(str) {
        return str.replace(/&(?!\w+;|\#[0-9]+;| \#x[0-9A-F]+;)/g, "&amp;");
      }
      module.exports = function toSVG(gd, format, scale) {
        var fullLayout = gd._fullLayout;
        var svg = fullLayout._paper;
        var toppaper = fullLayout._toppaper;
        var width = fullLayout.width;
        var height = fullLayout.height;
        var i;
        svg.insert("rect", ":first-child").call(Drawing.setRect, 0, 0, width, height).call(Color.fill, fullLayout.paper_bgcolor);
        var basePlotModules = fullLayout._basePlotModules || [];
        for (i = 0; i < basePlotModules.length; i++) {
          var _module = basePlotModules[i];
          if (_module.toSVG) _module.toSVG(gd);
        }
        if (toppaper) {
          var nodes = toppaper.node().childNodes;
          var topGroups = Array.prototype.slice.call(nodes);
          for (i = 0; i < topGroups.length; i++) {
            var topGroup = topGroups[i];
            if (topGroup.childNodes.length) svg.node().appendChild(topGroup);
          }
        }
        if (fullLayout._draggers) {
          fullLayout._draggers.remove();
        }
        svg.node().style.background = "";
        svg.selectAll("text").attr({ "data-unformatted": null, "data-math": null }).each(function() {
          var txt = d3.select(this);
          if (this.style.visibility === "hidden" || this.style.display === "none") {
            txt.remove();
            return;
          } else {
            txt.style({ visibility: null, display: null });
          }
          var ff = this.style.fontFamily;
          if (ff && ff.indexOf('"') !== -1) {
            txt.style("font-family", ff.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
          }
          var fw = this.style.fontWeight;
          if (fw && (fw === "normal" || fw === "400")) {
            txt.style("font-weight", void 0);
          }
          var fs = this.style.fontStyle;
          if (fs && fs === "normal") {
            txt.style("font-style", void 0);
          }
          var fv = this.style.fontVariant;
          if (fv && fv === "normal") {
            txt.style("font-variant", void 0);
          }
        });
        svg.selectAll(".gradient_filled,.pattern_filled").each(function() {
          var pt = d3.select(this);
          var fill = this.style.fill;
          if (fill && fill.indexOf("url(") !== -1) {
            pt.style("fill", fill.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
          }
          var stroke = this.style.stroke;
          if (stroke && stroke.indexOf("url(") !== -1) {
            pt.style("stroke", stroke.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
          }
        });
        if (format === "pdf" || format === "eps") {
          svg.selectAll("#MathJax_SVG_glyphs path").attr("stroke-width", 0);
        }
        if (format === "svg" && scale) {
          svg.attr("width", scale * width);
          svg.attr("height", scale * height);
          svg.attr("viewBox", "0 0 " + width + " " + height);
        }
        var s = new window.XMLSerializer().serializeToString(svg.node());
        s = htmlEntityDecode(s);
        s = xmlEntityEncode(s);
        s = s.replace(DUMMY_REGEX, "'");
        return s;
      };
    }
  });

  // src/snapshot/svgtoimg.js
  var require_svgtoimg = __commonJS({
    "src/snapshot/svgtoimg.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var EventEmitter = require_events().EventEmitter;
      var helpers = require_helpers10();
      function svgToImg(opts) {
        var ev = opts.emitter || new EventEmitter();
        var promise = new Promise(function(resolve, reject) {
          var Image2 = window.Image;
          var svg = opts.svg;
          var format = opts.format || "png";
          var canvas = opts.canvas;
          var scale = opts.scale || 1;
          var w0 = opts.width || 300;
          var h0 = opts.height || 150;
          var w1 = scale * w0;
          var h1 = scale * h0;
          var ctx = canvas.getContext("2d", { willReadFrequently: true });
          var img = new Image2();
          var svgBlob, url;
          if (format === "svg" || Lib.isSafari()) {
            url = helpers.encodeSVG(svg);
          } else {
            svgBlob = helpers.createBlob(svg, "svg");
            url = helpers.createObjectURL(svgBlob);
          }
          canvas.width = w1;
          canvas.height = h1;
          img.onload = function() {
            var imgData;
            svgBlob = null;
            helpers.revokeObjectURL(url);
            if (format !== "svg") {
              ctx.drawImage(img, 0, 0, w1, h1);
            }
            switch (format) {
              case "jpeg":
                imgData = canvas.toDataURL("image/jpeg");
                break;
              case "png":
                imgData = canvas.toDataURL("image/png");
                break;
              case "webp":
                imgData = canvas.toDataURL("image/webp");
                break;
              case "svg":
                imgData = url;
                break;
              default:
                var errorMsg = "Image format is not jpeg, png, svg or webp.";
                reject(new Error(errorMsg));
                if (!opts.promise) {
                  return ev.emit("error", errorMsg);
                }
            }
            resolve(imgData);
            if (!opts.promise) {
              ev.emit("success", imgData);
            }
          };
          img.onerror = function(err) {
            svgBlob = null;
            helpers.revokeObjectURL(url);
            reject(err);
            if (!opts.promise) {
              return ev.emit("error", err);
            }
          };
          img.src = url;
        });
        if (opts.promise) {
          return promise;
        }
        return ev;
      }
      module.exports = svgToImg;
    }
  });

  // src/plot_api/to_image.js
  var require_to_image = __commonJS({
    "src/plot_api/to_image.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var plotApi = require_plot_api();
      var plots = require_plots();
      var Lib = require_lib();
      var helpers = require_helpers10();
      var toSVG = require_tosvg();
      var svgToImg = require_svgtoimg();
      var version = require_version().version;
      var attrs = {
        format: {
          valType: "enumerated",
          values: ["png", "jpeg", "webp", "svg", "full-json"],
          dflt: "png"
        },
        width: {
          valType: "number",
          min: 1
        },
        height: {
          valType: "number",
          min: 1
        },
        scale: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        setBackground: {
          valType: "any",
          dflt: false
        },
        imageDataOnly: {
          valType: "boolean",
          dflt: false
        }
      };
      function toImage(gd, opts) {
        opts = opts || {};
        var data;
        var layout;
        var config;
        var fullLayout;
        if (Lib.isPlainObject(gd)) {
          data = gd.data || [];
          layout = gd.layout || {};
          config = gd.config || {};
          fullLayout = {};
        } else {
          gd = Lib.getGraphDiv(gd);
          data = Lib.extendDeep([], gd.data);
          layout = Lib.extendDeep({}, gd.layout);
          config = gd._context;
          fullLayout = gd._fullLayout || {};
        }
        function isImpliedOrValid(attr) {
          return !(attr in opts) || Lib.validate(opts[attr], attrs[attr]);
        }
        if (!isImpliedOrValid("width") && opts.width !== null || !isImpliedOrValid("height") && opts.height !== null) {
          throw new Error("Height and width should be pixel values.");
        }
        if (!isImpliedOrValid("format")) {
          throw new Error("Export format is not " + Lib.join2(attrs.format.values, ", ", " or ") + ".");
        }
        var fullOpts = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts, fullOpts, attrs, attr, dflt);
        }
        var format = coerce("format");
        var width = coerce("width");
        var height = coerce("height");
        var scale = coerce("scale");
        var setBackground = coerce("setBackground");
        var imageDataOnly = coerce("imageDataOnly");
        var clonedGd = document.createElement("div");
        clonedGd.style.position = "absolute";
        clonedGd.style.left = "-5000px";
        document.body.appendChild(clonedGd);
        var layoutImage = Lib.extendFlat({}, layout);
        if (width) {
          layoutImage.width = width;
        } else if (opts.width === null && isNumeric(fullLayout.width)) {
          layoutImage.width = fullLayout.width;
        }
        if (height) {
          layoutImage.height = height;
        } else if (opts.height === null && isNumeric(fullLayout.height)) {
          layoutImage.height = fullLayout.height;
        }
        var configImage = Lib.extendFlat({}, config, {
          _exportedPlot: true,
          staticPlot: true,
          setBackground
        });
        var redrawFunc = helpers.getRedrawFunc(clonedGd);
        function wait() {
          return new Promise(function(resolve) {
            setTimeout(resolve, helpers.getDelay(clonedGd._fullLayout));
          });
        }
        function convert() {
          return new Promise(function(resolve, reject) {
            var svg = toSVG(clonedGd, format, scale);
            var width2 = clonedGd._fullLayout.width;
            var height2 = clonedGd._fullLayout.height;
            function cleanup() {
              plotApi.purge(clonedGd);
              document.body.removeChild(clonedGd);
            }
            if (format === "full-json") {
              var json = plots.graphJson(clonedGd, false, "keepdata", "object", true, true);
              json.version = version;
              json = JSON.stringify(json);
              cleanup();
              if (imageDataOnly) {
                return resolve(json);
              } else {
                return resolve(helpers.encodeJSON(json));
              }
            }
            cleanup();
            if (format === "svg") {
              if (imageDataOnly) {
                return resolve(svg);
              } else {
                return resolve(helpers.encodeSVG(svg));
              }
            }
            var canvas = document.createElement("canvas");
            canvas.id = Lib.randstr();
            svgToImg({
              format,
              width: width2,
              height: height2,
              scale,
              canvas,
              svg,
              // ask svgToImg to return a Promise
              //  rather than EventEmitter
              //  leave EventEmitter for backward
              //  compatibility
              promise: true
            }).then(resolve).catch(reject);
          });
        }
        function urlToImageData(url) {
          if (imageDataOnly) {
            return url.replace(helpers.IMAGE_URL_PREFIX, "");
          } else {
            return url;
          }
        }
        return new Promise(function(resolve, reject) {
          plotApi.newPlot(clonedGd, data, layoutImage, configImage).then(redrawFunc).then(wait).then(convert).then(function(url) {
            resolve(urlToImageData(url));
          }).catch(function(err) {
            reject(err);
          });
        });
      }
      module.exports = toImage;
    }
  });

  // src/plot_api/validate.js
  var require_validate = __commonJS({
    "src/plot_api/validate.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Plots = require_plots();
      var PlotSchema = require_plot_schema();
      var dfltConfig = require_plot_config().dfltConfig;
      var isPlainObject = Lib.isPlainObject;
      var isArray = Array.isArray;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      module.exports = function validate(data, layout) {
        if (data === void 0) data = [];
        if (layout === void 0) layout = {};
        var schema = PlotSchema.get();
        var errorList = [];
        var gd = { _context: Lib.extendFlat({}, dfltConfig) };
        var dataIn, layoutIn;
        if (isArray(data)) {
          gd.data = Lib.extendDeep([], data);
          dataIn = data;
        } else {
          gd.data = [];
          dataIn = [];
          errorList.push(format("array", "data"));
        }
        if (isPlainObject(layout)) {
          gd.layout = Lib.extendDeep({}, layout);
          layoutIn = layout;
        } else {
          gd.layout = {};
          layoutIn = {};
          if (arguments.length > 1) {
            errorList.push(format("object", "layout"));
          }
        }
        Plots.supplyDefaults(gd);
        var dataOut = gd._fullData;
        var len = dataIn.length;
        for (var i = 0; i < len; i++) {
          var traceIn = dataIn[i];
          var base = ["data", i];
          if (!isPlainObject(traceIn)) {
            errorList.push(format("object", base));
            continue;
          }
          var traceOut = dataOut[i];
          var traceType = traceOut.type;
          var traceSchema = schema.traces[traceType].attributes;
          traceSchema.type = {
            valType: "enumerated",
            values: [traceType]
          };
          if (traceOut.visible === false && traceIn.visible !== false) {
            errorList.push(format("invisible", base));
          }
          crawl(traceIn, traceOut, traceSchema, errorList, base);
        }
        var layoutOut = gd._fullLayout;
        var layoutSchema = fillLayoutSchema(schema, dataOut);
        crawl(layoutIn, layoutOut, layoutSchema, errorList, "layout");
        return errorList.length === 0 ? void 0 : errorList;
      };
      function crawl(objIn, objOut, schema, list, base, path) {
        path = path || [];
        var keys = Object.keys(objIn);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var p = path.slice();
          p.push(k);
          var valIn = objIn[k];
          var valOut = objOut[k];
          var nestedSchema = getNestedSchema(schema, k);
          var nestedValType = (nestedSchema || {}).valType;
          var isInfoArray = nestedValType === "info_array";
          var isColorscale = nestedValType === "colorscale";
          var items = (nestedSchema || {}).items;
          if (!isInSchema(schema, k)) {
            list.push(format("schema", base, p));
          } else if (isPlainObject(valIn) && isPlainObject(valOut) && nestedValType !== "any") {
            crawl(valIn, valOut, nestedSchema, list, base, p);
          } else if (isInfoArray && isArray(valIn)) {
            if (valIn.length > valOut.length) {
              list.push(format("unused", base, p.concat(valOut.length)));
            }
            var len = valOut.length;
            var arrayItems = Array.isArray(items);
            if (arrayItems) len = Math.min(len, items.length);
            var m, n, item, valInPart, valOutPart;
            if (nestedSchema.dimensions === 2) {
              for (n = 0; n < len; n++) {
                if (isArray(valIn[n])) {
                  if (valIn[n].length > valOut[n].length) {
                    list.push(format("unused", base, p.concat(n, valOut[n].length)));
                  }
                  var len2 = valOut[n].length;
                  for (m = 0; m < (arrayItems ? Math.min(len2, items[n].length) : len2); m++) {
                    item = arrayItems ? items[n][m] : items;
                    valInPart = valIn[n][m];
                    valOutPart = valOut[n][m];
                    if (!Lib.validate(valInPart, item)) {
                      list.push(format("value", base, p.concat(n, m), valInPart));
                    } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {
                      list.push(format("dynamic", base, p.concat(n, m), valInPart, valOutPart));
                    }
                  }
                } else {
                  list.push(format("array", base, p.concat(n), valIn[n]));
                }
              }
            } else {
              for (n = 0; n < len; n++) {
                item = arrayItems ? items[n] : items;
                valInPart = valIn[n];
                valOutPart = valOut[n];
                if (!Lib.validate(valInPart, item)) {
                  list.push(format("value", base, p.concat(n), valInPart));
                } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {
                  list.push(format("dynamic", base, p.concat(n), valInPart, valOutPart));
                }
              }
            }
          } else if (nestedSchema.items && !isInfoArray && isArray(valIn)) {
            var _nestedSchema = items[Object.keys(items)[0]];
            var indexList = [];
            var j, _p;
            for (j = 0; j < valOut.length; j++) {
              var _index = valOut[j]._index || j;
              _p = p.slice();
              _p.push(_index);
              if (isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {
                indexList.push(_index);
                var valInj = valIn[_index];
                var valOutj = valOut[j];
                if (isPlainObject(valInj) && valInj.visible !== false && valOutj.visible === false) {
                  list.push(format("invisible", base, _p));
                } else crawl(valInj, valOutj, _nestedSchema, list, base, _p);
              }
            }
            for (j = 0; j < valIn.length; j++) {
              _p = p.slice();
              _p.push(j);
              if (!isPlainObject(valIn[j])) {
                list.push(format("object", base, _p, valIn[j]));
              } else if (indexList.indexOf(j) === -1) {
                list.push(format("unused", base, _p));
              }
            }
          } else if (!isPlainObject(valIn) && isPlainObject(valOut)) {
            list.push(format("object", base, p, valIn));
          } else if (!isArrayOrTypedArray(valIn) && isArrayOrTypedArray(valOut) && !isInfoArray && !isColorscale) {
            list.push(format("array", base, p, valIn));
          } else if (!(k in objOut)) {
            list.push(format("unused", base, p, valIn));
          } else if (!Lib.validate(valIn, nestedSchema)) {
            list.push(format("value", base, p, valIn));
          } else if (nestedSchema.valType === "enumerated" && (nestedSchema.coerceNumber && valIn !== +valOut || valIn !== valOut)) {
            list.push(format("dynamic", base, p, valIn, valOut));
          }
        }
        return list;
      }
      function fillLayoutSchema(schema, dataOut) {
        var layoutSchema = schema.layout.layoutAttributes;
        for (var i = 0; i < dataOut.length; i++) {
          var traceOut = dataOut[i];
          var traceSchema = schema.traces[traceOut.type];
          var traceLayoutAttr = traceSchema.layoutAttributes;
          if (traceLayoutAttr) {
            if (traceOut.subplot) {
              Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt], traceLayoutAttr);
            } else {
              Lib.extendFlat(layoutSchema, traceLayoutAttr);
            }
          }
        }
        return layoutSchema;
      }
      var code2msgFunc = {
        object: function(base, astr) {
          var prefix;
          if (base === "layout" && astr === "") prefix = "The layout argument";
          else if (base[0] === "data" && astr === "") {
            prefix = "Trace " + base[1] + " in the data argument";
          } else prefix = inBase(base) + "key " + astr;
          return prefix + " must be linked to an object container";
        },
        array: function(base, astr) {
          var prefix;
          if (base === "data") prefix = "The data argument";
          else prefix = inBase(base) + "key " + astr;
          return prefix + " must be linked to an array container";
        },
        schema: function(base, astr) {
          return inBase(base) + "key " + astr + " is not part of the schema";
        },
        unused: function(base, astr, valIn) {
          var target = isPlainObject(valIn) ? "container" : "key";
          return inBase(base) + target + " " + astr + " did not get coerced";
        },
        dynamic: function(base, astr, valIn, valOut) {
          return [
            inBase(base) + "key",
            astr,
            "(set to '" + valIn + "')",
            "got reset to",
            "'" + valOut + "'",
            "during defaults."
          ].join(" ");
        },
        invisible: function(base, astr) {
          return (astr ? inBase(base) + "item " + astr : "Trace " + base[1]) + " got defaulted to be not visible";
        },
        value: function(base, astr, valIn) {
          return [
            inBase(base) + "key " + astr,
            "is set to an invalid value (" + valIn + ")"
          ].join(" ");
        }
      };
      function inBase(base) {
        if (isArray(base)) return "In data trace " + base[1] + ", ";
        return "In " + base + ", ";
      }
      function format(code, base, path, valIn, valOut) {
        path = path || "";
        var container, trace;
        if (isArray(base)) {
          container = base[0];
          trace = base[1];
        } else {
          container = base;
          trace = null;
        }
        var astr = convertPathToAttributeString(path);
        var msg = code2msgFunc[code](base, astr, valIn, valOut);
        Lib.log(msg);
        return {
          code,
          container,
          trace,
          path,
          astr,
          msg
        };
      }
      function isInSchema(schema, key) {
        var parts = splitKey(key);
        var keyMinusId = parts.keyMinusId;
        var id = parts.id;
        if (keyMinusId in schema && schema[keyMinusId]._isSubplotObj && id) {
          return true;
        }
        return key in schema;
      }
      function getNestedSchema(schema, key) {
        if (key in schema) return schema[key];
        var parts = splitKey(key);
        return schema[parts.keyMinusId];
      }
      var idRegex = Lib.counterRegex("([a-z]+)");
      function splitKey(key) {
        var idMatch = key.match(idRegex);
        return {
          keyMinusId: idMatch && idMatch[1],
          id: idMatch && idMatch[2]
        };
      }
      function convertPathToAttributeString(path) {
        if (!isArray(path)) return String(path);
        var astr = "";
        for (var i = 0; i < path.length; i++) {
          var p = path[i];
          if (typeof p === "number") {
            astr = astr.substr(0, astr.length - 1) + "[" + p + "]";
          } else {
            astr += p;
          }
          if (i < path.length - 1) astr += ".";
        }
        return astr;
      }
    }
  });

  // src/snapshot/filesaver.js
  var require_filesaver = __commonJS({
    "src/snapshot/filesaver.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var helpers = require_helpers10();
      function fileSaver(url, name, format) {
        var saveLink = document.createElement("a");
        var canUseSaveLink = "download" in saveLink;
        var promise = new Promise(function(resolve, reject) {
          var blob;
          var objectUrl;
          if (canUseSaveLink) {
            blob = helpers.createBlob(url, format);
            objectUrl = helpers.createObjectURL(blob);
            saveLink.href = objectUrl;
            saveLink.download = name;
            document.body.appendChild(saveLink);
            saveLink.click();
            document.body.removeChild(saveLink);
            helpers.revokeObjectURL(objectUrl);
            blob = null;
            return resolve(name);
          }
          if (Lib.isSafari()) {
            var prefix = format === "svg" ? "," : ";base64,";
            helpers.octetStream(prefix + encodeURIComponent(url));
            return resolve(name);
          }
          reject(new Error("download error"));
        });
        return promise;
      }
      module.exports = fileSaver;
    }
  });

  // src/snapshot/download.js
  var require_download = __commonJS({
    "src/snapshot/download.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var toImage = require_to_image();
      var fileSaver = require_filesaver();
      var helpers = require_helpers10();
      function downloadImage(gd, opts) {
        var _gd;
        if (!Lib.isPlainObject(gd)) _gd = Lib.getGraphDiv(gd);
        opts = opts || {};
        opts.format = opts.format || "png";
        opts.width = opts.width || null;
        opts.height = opts.height || null;
        opts.imageDataOnly = true;
        return new Promise(function(resolve, reject) {
          if (_gd && _gd._snapshotInProgress) {
            reject(new Error("Snapshotting already in progress."));
          }
          if (_gd) _gd._snapshotInProgress = true;
          var promise = toImage(gd, opts);
          var filename = opts.filename || gd.fn || "newplot";
          filename += "." + opts.format.replace("-", ".");
          promise.then(function(result) {
            if (_gd) _gd._snapshotInProgress = false;
            return fileSaver(result, filename, opts.format);
          }).then(function(name) {
            resolve(name);
          }).catch(function(err) {
            if (_gd) _gd._snapshotInProgress = false;
            reject(err);
          });
        });
      }
      module.exports = downloadImage;
    }
  });

  // src/plot_api/template_api.js
  var require_template_api = __commonJS({
    "src/plot_api/template_api.js"(exports) {
      "use strict";
      var Lib = require_lib();
      var isPlainObject = Lib.isPlainObject;
      var PlotSchema = require_plot_schema();
      var Plots = require_plots();
      var plotAttributes = require_attributes2();
      var Template = require_plot_template();
      var dfltConfig = require_plot_config().dfltConfig;
      exports.makeTemplate = function(figure) {
        figure = Lib.isPlainObject(figure) ? figure : Lib.getGraphDiv(figure);
        figure = Lib.extendDeep({ _context: dfltConfig }, { data: figure.data, layout: figure.layout });
        Plots.supplyDefaults(figure);
        var data = figure.data || [];
        var layout = figure.layout || {};
        layout._basePlotModules = figure._fullLayout._basePlotModules;
        layout._modules = figure._fullLayout._modules;
        var template = {
          data: {},
          layout: {}
        };
        data.forEach(function(trace) {
          var traceTemplate = {};
          walkStyleKeys(trace, traceTemplate, getTraceInfo.bind(null, trace));
          var traceType2 = Lib.coerce(trace, {}, plotAttributes, "type");
          var typeTemplates2 = template.data[traceType2];
          if (!typeTemplates2) typeTemplates2 = template.data[traceType2] = [];
          typeTemplates2.push(traceTemplate);
        });
        walkStyleKeys(layout, template.layout, getLayoutInfo.bind(null, layout));
        delete template.layout.template;
        var oldTemplate = layout.template;
        if (isPlainObject(oldTemplate)) {
          var oldLayoutTemplate = oldTemplate.layout;
          var i, traceType, oldTypeTemplates, oldTypeLen, typeTemplates, typeLen;
          if (isPlainObject(oldLayoutTemplate)) {
            mergeTemplates(oldLayoutTemplate, template.layout);
          }
          var oldDataTemplate = oldTemplate.data;
          if (isPlainObject(oldDataTemplate)) {
            for (traceType in template.data) {
              oldTypeTemplates = oldDataTemplate[traceType];
              if (Array.isArray(oldTypeTemplates)) {
                typeTemplates = template.data[traceType];
                typeLen = typeTemplates.length;
                oldTypeLen = oldTypeTemplates.length;
                for (i = 0; i < typeLen; i++) {
                  mergeTemplates(oldTypeTemplates[i % oldTypeLen], typeTemplates[i]);
                }
                for (i = typeLen; i < oldTypeLen; i++) {
                  typeTemplates.push(Lib.extendDeep({}, oldTypeTemplates[i]));
                }
              }
            }
            for (traceType in oldDataTemplate) {
              if (!(traceType in template.data)) {
                template.data[traceType] = Lib.extendDeep([], oldDataTemplate[traceType]);
              }
            }
          }
        }
        return template;
      };
      function mergeTemplates(oldTemplate, newTemplate) {
        oldTemplate = Lib.extendDeep({}, oldTemplate);
        var oldKeys = Object.keys(oldTemplate).sort();
        var i, j;
        function mergeOne(oldVal2, newVal, key3) {
          if (isPlainObject(newVal) && isPlainObject(oldVal2)) {
            mergeTemplates(oldVal2, newVal);
          } else if (Array.isArray(newVal) && Array.isArray(oldVal2)) {
            var templater = Template.arrayTemplater({ _template: oldTemplate }, key3);
            for (j = 0; j < newVal.length; j++) {
              var item = newVal[j];
              var oldItem = templater.newItem(item)._template;
              if (oldItem) mergeTemplates(oldItem, item);
            }
            var defaultItems = templater.defaultItems();
            for (j = 0; j < defaultItems.length; j++) newVal.push(defaultItems[j]._template);
            for (j = 0; j < newVal.length; j++) delete newVal[j].templateitemname;
          }
        }
        for (i = 0; i < oldKeys.length; i++) {
          var key = oldKeys[i];
          var oldVal = oldTemplate[key];
          if (key in newTemplate) {
            mergeOne(oldVal, newTemplate[key], key);
          } else newTemplate[key] = oldVal;
          if (getBaseKey(key) === key) {
            for (var key2 in newTemplate) {
              var baseKey2 = getBaseKey(key2);
              if (key2 !== baseKey2 && baseKey2 === key && !(key2 in oldTemplate)) {
                mergeOne(oldVal, newTemplate[key2], key);
              }
            }
          }
        }
      }
      function getBaseKey(key) {
        return key.replace(/[0-9]+$/, "");
      }
      function walkStyleKeys(parent, templateOut, getAttributeInfo, path, basePath) {
        var pathAttr = basePath && getAttributeInfo(basePath);
        for (var key in parent) {
          var child = parent[key];
          var nextPath = getNextPath(parent, key, path);
          var nextBasePath = getNextPath(parent, key, basePath);
          var attr = getAttributeInfo(nextBasePath);
          if (!attr) {
            var baseKey = getBaseKey(key);
            if (baseKey !== key) {
              nextBasePath = getNextPath(parent, baseKey, basePath);
              attr = getAttributeInfo(nextBasePath);
            }
          }
          if (pathAttr && pathAttr === attr) continue;
          if (!attr || attr._noTemplating || attr.valType === "data_array" || attr.arrayOk && Array.isArray(child)) {
            continue;
          }
          if (!attr.valType && isPlainObject(child)) {
            walkStyleKeys(child, templateOut, getAttributeInfo, nextPath, nextBasePath);
          } else if (attr._isLinkedToArray && Array.isArray(child)) {
            var dfltDone = false;
            var namedIndex = 0;
            var usedNames = {};
            for (var i = 0; i < child.length; i++) {
              var item = child[i];
              if (isPlainObject(item)) {
                var name = item.name;
                if (name) {
                  if (!usedNames[name]) {
                    walkStyleKeys(
                      item,
                      templateOut,
                      getAttributeInfo,
                      getNextPath(child, namedIndex, nextPath),
                      getNextPath(child, namedIndex, nextBasePath)
                    );
                    namedIndex++;
                    usedNames[name] = 1;
                  }
                } else if (!dfltDone) {
                  var dfltKey = Template.arrayDefaultKey(key);
                  var dfltPath = getNextPath(parent, dfltKey, path);
                  var pathInArray = getNextPath(child, namedIndex, nextPath);
                  walkStyleKeys(
                    item,
                    templateOut,
                    getAttributeInfo,
                    pathInArray,
                    getNextPath(child, namedIndex, nextBasePath)
                  );
                  var itemPropInArray = Lib.nestedProperty(templateOut, pathInArray);
                  var dfltProp = Lib.nestedProperty(templateOut, dfltPath);
                  dfltProp.set(itemPropInArray.get());
                  itemPropInArray.set(null);
                  dfltDone = true;
                }
              }
            }
          } else {
            var templateProp = Lib.nestedProperty(templateOut, nextPath);
            templateProp.set(child);
          }
        }
      }
      function getLayoutInfo(layout, path) {
        return PlotSchema.getLayoutValObject(
          layout,
          Lib.nestedProperty({}, path).parts
        );
      }
      function getTraceInfo(trace, path) {
        return PlotSchema.getTraceValObject(
          trace,
          Lib.nestedProperty({}, path).parts
        );
      }
      function getNextPath(parent, key, path) {
        var nextPath;
        if (!path) nextPath = key;
        else if (Array.isArray(parent)) nextPath = path + "[" + key + "]";
        else nextPath = path + "." + key;
        return nextPath;
      }
      exports.validateTemplate = function(figureIn, template) {
        var figure = Lib.extendDeep({}, {
          _context: dfltConfig,
          data: figureIn.data,
          layout: figureIn.layout
        });
        var layout = figure.layout || {};
        if (!isPlainObject(template)) template = layout.template || {};
        var layoutTemplate = template.layout;
        var dataTemplate = template.data;
        var errorList = [];
        figure.layout = layout;
        figure.layout.template = template;
        Plots.supplyDefaults(figure);
        var fullLayout = figure._fullLayout;
        var fullData = figure._fullData;
        var layoutPaths = {};
        function crawlLayoutForContainers(obj, paths) {
          for (var key in obj) {
            if (key.charAt(0) !== "_" && isPlainObject(obj[key])) {
              var baseKey = getBaseKey(key);
              var nextPaths = [];
              var i2;
              for (i2 = 0; i2 < paths.length; i2++) {
                nextPaths.push(getNextPath(obj, key, paths[i2]));
                if (baseKey !== key) nextPaths.push(getNextPath(obj, baseKey, paths[i2]));
              }
              for (i2 = 0; i2 < nextPaths.length; i2++) {
                layoutPaths[nextPaths[i2]] = 1;
              }
              crawlLayoutForContainers(obj[key], nextPaths);
            }
          }
        }
        function crawlLayoutTemplateForContainers(obj, path) {
          for (var key in obj) {
            if (key.indexOf("defaults") === -1 && isPlainObject(obj[key])) {
              var nextPath = getNextPath(obj, key, path);
              if (layoutPaths[nextPath]) {
                crawlLayoutTemplateForContainers(obj[key], nextPath);
              } else {
                errorList.push({ code: "unused", path: nextPath });
              }
            }
          }
        }
        if (!isPlainObject(layoutTemplate)) {
          errorList.push({ code: "layout" });
        } else {
          crawlLayoutForContainers(fullLayout, ["layout"]);
          crawlLayoutTemplateForContainers(layoutTemplate, "layout");
        }
        if (!isPlainObject(dataTemplate)) {
          errorList.push({ code: "data" });
        } else {
          var typeCount = {};
          var traceType;
          for (var i = 0; i < fullData.length; i++) {
            var fullTrace = fullData[i];
            traceType = fullTrace.type;
            typeCount[traceType] = (typeCount[traceType] || 0) + 1;
            if (!fullTrace._fullInput._template) {
              errorList.push({
                code: "missing",
                index: fullTrace.index,
                traceType
              });
            }
          }
          for (traceType in dataTemplate) {
            var templateCount = dataTemplate[traceType].length;
            var dataCount = typeCount[traceType] || 0;
            if (templateCount > dataCount) {
              errorList.push({
                code: "unused",
                traceType,
                templateCount,
                dataCount
              });
            } else if (dataCount > templateCount) {
              errorList.push({
                code: "reused",
                traceType,
                templateCount,
                dataCount
              });
            }
          }
        }
        function crawlForMissingTemplates(obj, path) {
          for (var key in obj) {
            if (key.charAt(0) === "_") continue;
            var val = obj[key];
            var nextPath = getNextPath(obj, key, path);
            if (isPlainObject(val)) {
              if (Array.isArray(obj) && val._template === false && val.templateitemname) {
                errorList.push({
                  code: "missing",
                  path: nextPath,
                  templateitemname: val.templateitemname
                });
              }
              crawlForMissingTemplates(val, nextPath);
            } else if (Array.isArray(val) && hasPlainObject(val)) {
              crawlForMissingTemplates(val, nextPath);
            }
          }
        }
        crawlForMissingTemplates({ data: fullData, layout: fullLayout }, "");
        if (errorList.length) return errorList.map(format);
      };
      function hasPlainObject(arr) {
        for (var i = 0; i < arr.length; i++) {
          if (isPlainObject(arr[i])) return true;
        }
      }
      function format(opts) {
        var msg;
        switch (opts.code) {
          case "data":
            msg = "The template has no key data.";
            break;
          case "layout":
            msg = "The template has no key layout.";
            break;
          case "missing":
            if (opts.path) {
              msg = "There are no templates for item " + opts.path + " with name " + opts.templateitemname;
            } else {
              msg = "There are no templates for trace " + opts.index + ", of type " + opts.traceType + ".";
            }
            break;
          case "unused":
            if (opts.path) {
              msg = "The template item at " + opts.path + " was not used in constructing the plot.";
            } else if (opts.dataCount) {
              msg = "Some of the templates of type " + opts.traceType + " were not used. The template has " + opts.templateCount + " traces, the data only has " + opts.dataCount + " of this type.";
            } else {
              msg = "The template has " + opts.templateCount + " traces of type " + opts.traceType + " but there are none in the data.";
            }
            break;
          case "reused":
            msg = "Some of the templates of type " + opts.traceType + " were used more than once. The template has " + opts.templateCount + " traces, the data has " + opts.dataCount + " of this type.";
            break;
        }
        opts.msg = msg;
        return opts;
      }
    }
  });

  // src/plot_api/index.js
  var require_plot_api2 = __commonJS({
    "src/plot_api/index.js"(exports) {
      "use strict";
      var main = require_plot_api();
      exports._doPlot = main._doPlot;
      exports.newPlot = main.newPlot;
      exports.restyle = main.restyle;
      exports.relayout = main.relayout;
      exports.redraw = main.redraw;
      exports.update = main.update;
      exports._guiRestyle = main._guiRestyle;
      exports._guiRelayout = main._guiRelayout;
      exports._guiUpdate = main._guiUpdate;
      exports._storeDirectGUIEdit = main._storeDirectGUIEdit;
      exports.react = main.react;
      exports.extendTraces = main.extendTraces;
      exports.prependTraces = main.prependTraces;
      exports.addTraces = main.addTraces;
      exports.deleteTraces = main.deleteTraces;
      exports.moveTraces = main.moveTraces;
      exports.purge = main.purge;
      exports.addFrames = main.addFrames;
      exports.deleteFrames = main.deleteFrames;
      exports.animate = main.animate;
      exports.setPlotConfig = main.setPlotConfig;
      var getGraphDiv = require_dom().getGraphDiv;
      var eraseActiveShape = require_draw2().eraseActiveShape;
      exports.deleteActiveShape = function(gd) {
        return eraseActiveShape(getGraphDiv(gd));
      };
      exports.toImage = require_to_image();
      exports.validate = require_validate();
      exports.downloadImage = require_download();
      var templateApi = require_template_api();
      exports.makeTemplate = templateApi.makeTemplate;
      exports.validateTemplate = templateApi.validateTemplate;
    }
  });

  // src/traces/scatter/xy_defaults.js
  var require_xy_defaults = __commonJS({
    "src/traces/scatter/xy_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      module.exports = function handleXYDefaults(traceIn, traceOut, layout, coerce) {
        var x = coerce("x");
        var y = coerce("y");
        var len;
        var handleCalendarDefaults = Registry.getComponentMethod("calendars", "handleTraceDefaults");
        handleCalendarDefaults(traceIn, traceOut, ["x", "y"], layout);
        if (x) {
          var xlen = Lib.minRowLength(x);
          if (y) {
            len = Math.min(xlen, Lib.minRowLength(y));
          } else {
            len = xlen;
            coerce("y0");
            coerce("dy");
          }
        } else {
          if (!y) return 0;
          len = Lib.minRowLength(y);
          coerce("x0");
          coerce("dx");
        }
        traceOut._length = len;
        return len;
      };
    }
  });

  // src/traces/scatter/period_defaults.js
  var require_period_defaults = __commonJS({
    "src/traces/scatter/period_defaults.js"(exports, module) {
      "use strict";
      var dateTick0 = require_lib().dateTick0;
      var numConstants = require_numerical();
      var ONEWEEK = numConstants.ONEWEEK;
      function getPeriod0Dflt(period, calendar) {
        if (period % ONEWEEK === 0) {
          return dateTick0(calendar, 1);
        }
        return dateTick0(calendar, 0);
      }
      module.exports = function handlePeriodDefaults(traceIn, traceOut, layout, coerce, opts) {
        if (!opts) {
          opts = {
            x: true,
            y: true
          };
        }
        if (opts.x) {
          var xperiod = coerce("xperiod");
          if (xperiod) {
            coerce("xperiod0", getPeriod0Dflt(xperiod, traceOut.xcalendar));
            coerce("xperiodalignment");
          }
        }
        if (opts.y) {
          var yperiod = coerce("yperiod");
          if (yperiod) {
            coerce("yperiod0", getPeriod0Dflt(yperiod, traceOut.ycalendar));
            coerce("yperiodalignment");
          }
        }
      };
    }
  });

  // src/traces/scatter/stack_defaults.js
  var require_stack_defaults = __commonJS({
    "src/traces/scatter/stack_defaults.js"(exports, module) {
      "use strict";
      var perStackAttrs = ["orientation", "groupnorm", "stackgaps"];
      module.exports = function handleStackDefaults(traceIn, traceOut, layout, coerce) {
        var stackOpts = layout._scatterStackOpts;
        var stackGroup = coerce("stackgroup");
        if (stackGroup) {
          var subplot = traceOut.xaxis + traceOut.yaxis;
          var subplotStackOpts = stackOpts[subplot];
          if (!subplotStackOpts) subplotStackOpts = stackOpts[subplot] = {};
          var groupOpts = subplotStackOpts[stackGroup];
          var firstTrace = false;
          if (groupOpts) {
            groupOpts.traces.push(traceOut);
          } else {
            groupOpts = subplotStackOpts[stackGroup] = {
              // keep track of trace indices for use during stacking calculations
              // this will be filled in during `calc` and used during `crossTraceCalc`
              // so it's OK if we don't recreate it during a non-calc edit
              traceIndices: [],
              // Hold on to the whole set of prior traces
              // First one is most important, so we can clear defaults
              // there if we find explicit values only in later traces.
              // We're only going to *use* the values stored in groupOpts,
              // but for the editor and validate we want things self-consistent
              // The full set of traces is used only to fix `fill` default if
              // we find `orientation: 'h'` beyond the first trace
              traces: [traceOut]
            };
            firstTrace = true;
          }
          var dflts = {
            orientation: traceOut.x && !traceOut.y ? "h" : "v"
          };
          for (var i = 0; i < perStackAttrs.length; i++) {
            var attr = perStackAttrs[i];
            var attrFound = attr + "Found";
            if (!groupOpts[attrFound]) {
              var traceHasAttr = traceIn[attr] !== void 0;
              var isOrientation = attr === "orientation";
              if (traceHasAttr || firstTrace) {
                groupOpts[attr] = coerce(attr, dflts[attr]);
                if (isOrientation) {
                  groupOpts.fillDflt = groupOpts[attr] === "h" ? "tonextx" : "tonexty";
                }
                if (traceHasAttr) {
                  groupOpts[attrFound] = true;
                  if (!firstTrace) {
                    delete groupOpts.traces[0][attr];
                    if (isOrientation) {
                      for (var j = 0; j < groupOpts.traces.length - 1; j++) {
                        var trace2 = groupOpts.traces[j];
                        if (trace2._input.fill !== trace2.fill) {
                          trace2.fill = groupOpts.fillDflt;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          return groupOpts;
        }
      };
    }
  });

  // src/traces/scatter/marker_defaults.js
  var require_marker_defaults = __commonJS({
    "src/traces/scatter/marker_defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var hasColorscale = require_helpers().hasColorscale;
      var colorscaleDefaults = require_defaults2();
      var subTypes = require_subtypes();
      module.exports = function markerDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {
        var isBubble = subTypes.isBubble(traceIn);
        var lineColor = (traceIn.line || {}).color;
        var defaultMLC;
        opts = opts || {};
        if (lineColor) defaultColor = lineColor;
        coerce("marker.symbol");
        coerce("marker.opacity", isBubble ? 0.7 : 1);
        coerce("marker.size");
        if (!opts.noAngle) {
          coerce("marker.angle");
          if (!opts.noAngleRef) {
            coerce("marker.angleref");
          }
          if (!opts.noStandOff) {
            coerce("marker.standoff");
          }
        }
        coerce("marker.color", defaultColor);
        if (hasColorscale(traceIn, "marker")) {
          colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "marker.", cLetter: "c" });
        }
        if (!opts.noSelect) {
          coerce("selected.marker.color");
          coerce("unselected.marker.color");
          coerce("selected.marker.size");
          coerce("unselected.marker.size");
        }
        if (!opts.noLine) {
          if (lineColor && !Array.isArray(lineColor) && traceOut.marker.color !== lineColor) {
            defaultMLC = lineColor;
          } else if (isBubble) defaultMLC = Color.background;
          else defaultMLC = Color.defaultLine;
          coerce("marker.line.color", defaultMLC);
          if (hasColorscale(traceIn, "marker.line")) {
            colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "marker.line.", cLetter: "c" });
          }
          coerce("marker.line.width", isBubble ? 1 : 0);
        }
        if (isBubble) {
          coerce("marker.sizeref");
          coerce("marker.sizemin");
          coerce("marker.sizemode");
        }
        if (opts.gradient) {
          var gradientType = coerce("marker.gradient.type");
          if (gradientType !== "none") {
            coerce("marker.gradient.color");
          }
        }
      };
    }
  });

  // src/traces/scatter/line_defaults.js
  var require_line_defaults = __commonJS({
    "src/traces/scatter/line_defaults.js"(exports, module) {
      "use strict";
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var hasColorscale = require_helpers().hasColorscale;
      var colorscaleDefaults = require_defaults2();
      module.exports = function lineDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {
        if (!opts) opts = {};
        var markerColor = (traceIn.marker || {}).color;
        if (markerColor && markerColor._inputArray) markerColor = markerColor._inputArray;
        coerce("line.color", defaultColor);
        if (hasColorscale(traceIn, "line")) {
          colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "line.", cLetter: "c" });
        } else {
          var lineColorDflt = (isArrayOrTypedArray(markerColor) ? false : markerColor) || defaultColor;
          coerce("line.color", lineColorDflt);
        }
        coerce("line.width");
        if (!opts.noDash) coerce("line.dash");
        if (opts.backoff) coerce("line.backoff");
      };
    }
  });

  // src/traces/scatter/line_shape_defaults.js
  var require_line_shape_defaults = __commonJS({
    "src/traces/scatter/line_shape_defaults.js"(exports, module) {
      "use strict";
      module.exports = function handleLineShapeDefaults(traceIn, traceOut, coerce) {
        var shape = coerce("line.shape");
        if (shape === "spline") coerce("line.smoothing");
      };
    }
  });

  // src/traces/scatter/text_defaults.js
  var require_text_defaults = __commonJS({
    "src/traces/scatter/text_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function(traceIn, traceOut, layout, coerce, opts) {
        opts = opts || {};
        coerce("textposition");
        Lib.coerceFont(coerce, "textfont", opts.font || layout.font, opts);
        if (!opts.noSelect) {
          coerce("selected.textfont.color");
          coerce("unselected.textfont.color");
        }
      };
    }
  });

  // src/traces/scatter/fillcolor_defaults.js
  var require_fillcolor_defaults = __commonJS({
    "src/traces/scatter/fillcolor_defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      function averageColors(colorscale) {
        var color = Color.interpolate(colorscale[0][1], colorscale[1][1], 0.5);
        for (var i = 2; i < colorscale.length; i++) {
          var averageColorI = Color.interpolate(colorscale[i - 1][1], colorscale[i][1], 0.5);
          color = Color.interpolate(color, averageColorI, colorscale[i - 1][0] / colorscale[i][0]);
        }
        return color;
      }
      module.exports = function fillColorDefaults(traceIn, traceOut, defaultColor, coerce, opts) {
        if (!opts) opts = {};
        var inheritColorFromMarker = false;
        if (traceOut.marker) {
          var markerColor = traceOut.marker.color;
          var markerLineColor = (traceOut.marker.line || {}).color;
          if (markerColor && !isArrayOrTypedArray(markerColor)) {
            inheritColorFromMarker = markerColor;
          } else if (markerLineColor && !isArrayOrTypedArray(markerLineColor)) {
            inheritColorFromMarker = markerLineColor;
          }
        }
        var averageGradientColor;
        if (opts.moduleHasFillgradient) {
          var gradientOrientation = coerce("fillgradient.type");
          if (gradientOrientation !== "none") {
            coerce("fillgradient.start");
            coerce("fillgradient.stop");
            var gradientColorscale = coerce("fillgradient.colorscale");
            if (gradientColorscale) {
              averageGradientColor = averageColors(gradientColorscale);
            }
          }
        }
        coerce("fillcolor", Color.addOpacity(
          (traceOut.line || {}).color || inheritColorFromMarker || averageGradientColor || defaultColor,
          0.5
        ));
      };
    }
  });

  // src/traces/scatter/defaults.js
  var require_defaults8 = __commonJS({
    "src/traces/scatter/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      var attributes = require_attributes12();
      var constants = require_constants8();
      var subTypes = require_subtypes();
      var handleXYDefaults = require_xy_defaults();
      var handlePeriodDefaults = require_period_defaults();
      var handleStackDefaults = require_stack_defaults();
      var handleMarkerDefaults = require_marker_defaults();
      var handleLineDefaults = require_line_defaults();
      var handleLineShapeDefaults = require_line_shape_defaults();
      var handleTextDefaults = require_text_defaults();
      var handleFillColorDefaults = require_fillcolor_defaults();
      var coercePattern = require_lib().coercePattern;
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var len = handleXYDefaults(traceIn, traceOut, layout, coerce);
        if (!len) traceOut.visible = false;
        if (!traceOut.visible) return;
        handlePeriodDefaults(traceIn, traceOut, layout, coerce);
        coerce("xhoverformat");
        coerce("yhoverformat");
        coerce("zorder");
        var stackGroupOpts = handleStackDefaults(traceIn, traceOut, layout, coerce);
        if (layout.scattermode === "group" && traceOut.orientation === void 0) {
          coerce("orientation", "v");
        }
        var defaultMode = !stackGroupOpts && len < constants.PTS_LINESONLY ? "lines+markers" : "lines";
        coerce("text");
        coerce("hovertext");
        coerce("mode", defaultMode);
        if (subTypes.hasMarkers(traceOut)) {
          handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce, { gradient: true });
        }
        if (subTypes.hasLines(traceOut)) {
          handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce, { backoff: true });
          handleLineShapeDefaults(traceIn, traceOut, coerce);
          coerce("connectgaps");
          coerce("line.simplify");
        }
        if (subTypes.hasText(traceOut)) {
          coerce("texttemplate");
          handleTextDefaults(traceIn, traceOut, layout, coerce);
        }
        var dfltHoverOn = [];
        if (subTypes.hasMarkers(traceOut) || subTypes.hasText(traceOut)) {
          coerce("cliponaxis");
          coerce("marker.maxdisplayed");
          dfltHoverOn.push("points");
        }
        coerce("fill", stackGroupOpts ? stackGroupOpts.fillDflt : "none");
        if (traceOut.fill !== "none") {
          handleFillColorDefaults(traceIn, traceOut, defaultColor, coerce, {
            moduleHasFillgradient: true
          });
          if (!subTypes.hasLines(traceOut)) handleLineShapeDefaults(traceIn, traceOut, coerce);
          coercePattern(coerce, "fillpattern", traceOut.fillcolor, false);
        }
        var lineColor = (traceOut.line || {}).color;
        var markerColor = (traceOut.marker || {}).color;
        if (traceOut.fill === "tonext" || traceOut.fill === "toself") {
          dfltHoverOn.push("fills");
        }
        coerce("hoveron", dfltHoverOn.join("+") || "points");
        if (traceOut.hoveron !== "fills") coerce("hovertemplate");
        var errorBarsSupplyDefaults = Registry.getComponentMethod("errorbars", "supplyDefaults");
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, { axis: "y" });
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, { axis: "x", inherit: "y" });
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
      };
    }
  });

  // src/traces/scatter/grouping_defaults.js
  var require_grouping_defaults = __commonJS({
    "src/traces/scatter/grouping_defaults.js"(exports, module) {
      "use strict";
      var getAxisGroup = require_constraints().getAxisGroup;
      module.exports = function handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce, barmode) {
        var orientation = traceOut.orientation;
        var posAxId = traceOut[{ v: "x", h: "y" }[orientation] + "axis"];
        var groupId = getAxisGroup(fullLayout, posAxId) + orientation;
        var alignmentOpts = fullLayout._alignmentOpts || {};
        var alignmentgroup = coerce("alignmentgroup");
        var alignmentGroups = alignmentOpts[groupId];
        if (!alignmentGroups) alignmentGroups = alignmentOpts[groupId] = {};
        var alignmentGroupOpts = alignmentGroups[alignmentgroup];
        if (alignmentGroupOpts) {
          alignmentGroupOpts.traces.push(traceOut);
        } else {
          alignmentGroupOpts = alignmentGroups[alignmentgroup] = {
            traces: [traceOut],
            alignmentIndex: Object.keys(alignmentGroups).length,
            offsetGroups: {}
          };
        }
        var offsetgroup = coerce("offsetgroup") || "";
        var offsetGroups = alignmentGroupOpts.offsetGroups;
        var offsetGroupOpts = offsetGroups[offsetgroup];
        traceOut._offsetIndex = 0;
        if (barmode !== "group" || offsetgroup) {
          if (!offsetGroupOpts) {
            offsetGroupOpts = offsetGroups[offsetgroup] = {
              offsetIndex: Object.keys(offsetGroups).length
            };
          }
          traceOut._offsetIndex = offsetGroupOpts.offsetIndex;
        }
      };
    }
  });

  // src/traces/scatter/cross_trace_defaults.js
  var require_cross_trace_defaults2 = __commonJS({
    "src/traces/scatter/cross_trace_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleGroupingDefaults = require_grouping_defaults();
      var attributes = require_attributes12();
      module.exports = function crossTraceDefaults(fullData, fullLayout) {
        var traceIn, traceOut, i;
        var scattermode = fullLayout.scattermode;
        function coerce(attr) {
          return Lib.coerce(traceOut._input, traceOut, attributes, attr);
        }
        if (fullLayout.scattermode === "group") {
          for (i = 0; i < fullData.length; i++) {
            traceOut = fullData[i];
            if (traceOut.type === "scatter") {
              traceIn = traceOut._input;
              handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce, scattermode);
            }
          }
        }
        for (i = 0; i < fullData.length; i++) {
          var tracei = fullData[i];
          if (tracei.type !== "scatter") continue;
          var filli = tracei.fill;
          if (filli === "none" || filli === "toself") continue;
          tracei.opacity = void 0;
          if (filli === "tonexty" || filli === "tonextx") {
            for (var j = i - 1; j >= 0; j--) {
              var tracej = fullData[j];
              if (tracej.type === "scatter" && tracej.xaxis === tracei.xaxis && tracej.yaxis === tracei.yaxis) {
                tracej.opacity = void 0;
                break;
              }
            }
          }
        }
      };
    }
  });

  // src/traces/scatter/layout_defaults.js
  var require_layout_defaults3 = __commonJS({
    "src/traces/scatter/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes3();
      module.exports = function(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        var groupBarmode = layoutOut.barmode === "group";
        if (layoutOut.scattermode === "group") {
          coerce("scattergap", groupBarmode ? layoutOut.bargap : 0.2);
        }
      };
    }
  });

  // src/plots/cartesian/align_period.js
  var require_align_period = __commonJS({
    "src/plots/cartesian/align_period.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var dateTime2ms = Lib.dateTime2ms;
      var incrementMonth = Lib.incrementMonth;
      var constants = require_numerical();
      var ONEAVGMONTH = constants.ONEAVGMONTH;
      module.exports = function alignPeriod(trace, ax, axLetter, vals) {
        if (ax.type !== "date") return { vals };
        var alignment = trace[axLetter + "periodalignment"];
        if (!alignment) return { vals };
        var period = trace[axLetter + "period"];
        var mPeriod;
        if (isNumeric(period)) {
          period = +period;
          if (period <= 0) return { vals };
        } else if (typeof period === "string" && period.charAt(0) === "M") {
          var n = +period.substring(1);
          if (n > 0 && Math.round(n) === n) {
            mPeriod = n;
          } else return { vals };
        }
        var calendar = ax.calendar;
        var isStart = "start" === alignment;
        var isEnd = "end" === alignment;
        var period0 = trace[axLetter + "period0"];
        var base = dateTime2ms(period0, calendar) || 0;
        var newVals = [];
        var starts = [];
        var ends = [];
        var len = vals.length;
        for (var i = 0; i < len; i++) {
          var v = vals[i];
          var nEstimated, startTime, endTime;
          if (mPeriod) {
            nEstimated = Math.round((v - base) / (mPeriod * ONEAVGMONTH));
            endTime = incrementMonth(base, mPeriod * nEstimated, calendar);
            while (endTime > v) {
              endTime = incrementMonth(endTime, -mPeriod, calendar);
            }
            while (endTime <= v) {
              endTime = incrementMonth(endTime, mPeriod, calendar);
            }
            startTime = incrementMonth(endTime, -mPeriod, calendar);
          } else {
            nEstimated = Math.round((v - base) / period);
            endTime = base + nEstimated * period;
            while (endTime > v) {
              endTime -= period;
            }
            while (endTime <= v) {
              endTime += period;
            }
            startTime = endTime - period;
          }
          newVals[i] = isStart ? startTime : isEnd ? endTime : (startTime + endTime) / 2;
          starts[i] = startTime;
          ends[i] = endTime;
        }
        return {
          vals: newVals,
          starts,
          ends
        };
      };
    }
  });

  // src/traces/scatter/colorscale_calc.js
  var require_colorscale_calc = __commonJS({
    "src/traces/scatter/colorscale_calc.js"(exports, module) {
      "use strict";
      var hasColorscale = require_helpers().hasColorscale;
      var calcColorscale = require_calc();
      var subTypes = require_subtypes();
      module.exports = function calcMarkerColorscale(gd, trace) {
        if (subTypes.hasLines(trace) && hasColorscale(trace, "line")) {
          calcColorscale(gd, trace, {
            vals: trace.line.color,
            containerStr: "line",
            cLetter: "c"
          });
        }
        if (subTypes.hasMarkers(trace)) {
          if (hasColorscale(trace, "marker")) {
            calcColorscale(gd, trace, {
              vals: trace.marker.color,
              containerStr: "marker",
              cLetter: "c"
            });
          }
          if (hasColorscale(trace, "marker.line")) {
            calcColorscale(gd, trace, {
              vals: trace.marker.line.color,
              containerStr: "marker.line",
              cLetter: "c"
            });
          }
        }
      };
    }
  });

  // src/traces/scatter/arrays_to_calcdata.js
  var require_arrays_to_calcdata = __commonJS({
    "src/traces/scatter/arrays_to_calcdata.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function arraysToCalcdata(cd, trace) {
        for (var i = 0; i < cd.length; i++) cd[i].i = i;
        Lib.mergeArray(trace.text, cd, "tx");
        Lib.mergeArray(trace.texttemplate, cd, "txt");
        Lib.mergeArray(trace.hovertext, cd, "htx");
        Lib.mergeArray(trace.customdata, cd, "data");
        Lib.mergeArray(trace.textposition, cd, "tp");
        if (trace.textfont) {
          Lib.mergeArrayCastPositive(trace.textfont.size, cd, "ts");
          Lib.mergeArray(trace.textfont.color, cd, "tc");
          Lib.mergeArray(trace.textfont.family, cd, "tf");
          Lib.mergeArray(trace.textfont.weight, cd, "tw");
          Lib.mergeArray(trace.textfont.style, cd, "ty");
          Lib.mergeArray(trace.textfont.variant, cd, "tv");
          Lib.mergeArray(trace.textfont.textcase, cd, "tC");
          Lib.mergeArray(trace.textfont.lineposition, cd, "tE");
          Lib.mergeArray(trace.textfont.shadow, cd, "tS");
        }
        var marker = trace.marker;
        if (marker) {
          Lib.mergeArrayCastPositive(marker.size, cd, "ms");
          Lib.mergeArrayCastPositive(marker.opacity, cd, "mo");
          Lib.mergeArray(marker.symbol, cd, "mx");
          Lib.mergeArray(marker.angle, cd, "ma");
          Lib.mergeArray(marker.standoff, cd, "mf");
          Lib.mergeArray(marker.color, cd, "mc");
          var markerLine = marker.line;
          if (marker.line) {
            Lib.mergeArray(markerLine.color, cd, "mlc");
            Lib.mergeArrayCastPositive(markerLine.width, cd, "mlw");
          }
          var markerGradient = marker.gradient;
          if (markerGradient && markerGradient.type !== "none") {
            Lib.mergeArray(markerGradient.type, cd, "mgt");
            Lib.mergeArray(markerGradient.color, cd, "mgc");
          }
        }
      };
    }
  });

  // src/traces/scatter/calc_selection.js
  var require_calc_selection = __commonJS({
    "src/traces/scatter/calc_selection.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function calcSelection(cd, trace) {
        if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {
          Lib.tagSelected(cd, trace);
        }
      };
    }
  });

  // src/traces/scatter/calc.js
  var require_calc3 = __commonJS({
    "src/traces/scatter/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Axes = require_axes();
      var alignPeriod = require_align_period();
      var BADNUM = require_numerical().BADNUM;
      var subTypes = require_subtypes();
      var calcColorscale = require_colorscale_calc();
      var arraysToCalcdata = require_arrays_to_calcdata();
      var calcSelection = require_calc_selection();
      function calc(gd, trace) {
        var fullLayout = gd._fullLayout;
        var xa = trace._xA = Axes.getFromId(gd, trace.xaxis || "x", "x");
        var ya = trace._yA = Axes.getFromId(gd, trace.yaxis || "y", "y");
        var origX = xa.makeCalcdata(trace, "x");
        var origY = ya.makeCalcdata(trace, "y");
        var xObj = alignPeriod(trace, xa, "x", origX);
        var yObj = alignPeriod(trace, ya, "y", origY);
        var x = xObj.vals;
        var y = yObj.vals;
        var serieslen = trace._length;
        var cd = new Array(serieslen);
        var ids = trace.ids;
        var stackGroupOpts = getStackOpts(trace, fullLayout, xa, ya);
        var interpolateGaps = false;
        var isV, i, j, k, interpolate, vali;
        setFirstScatter(fullLayout, trace);
        var xAttr = "x";
        var yAttr = "y";
        var posAttr;
        if (stackGroupOpts) {
          Lib.pushUnique(stackGroupOpts.traceIndices, trace.index);
          isV = stackGroupOpts.orientation === "v";
          if (isV) {
            yAttr = "s";
            posAttr = "x";
          } else {
            xAttr = "s";
            posAttr = "y";
          }
          interpolate = stackGroupOpts.stackgaps === "interpolate";
        } else {
          var ppad = calcMarkerSize(trace, serieslen);
          calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);
        }
        var hasPeriodX = !!trace.xperiodalignment;
        var hasPeriodY = !!trace.yperiodalignment;
        for (i = 0; i < serieslen; i++) {
          var cdi = cd[i] = {};
          var xValid = isNumeric(x[i]);
          var yValid = isNumeric(y[i]);
          if (xValid && yValid) {
            cdi[xAttr] = x[i];
            cdi[yAttr] = y[i];
            if (hasPeriodX) {
              cdi.orig_x = origX[i];
              cdi.xEnd = xObj.ends[i];
              cdi.xStart = xObj.starts[i];
            }
            if (hasPeriodY) {
              cdi.orig_y = origY[i];
              cdi.yEnd = yObj.ends[i];
              cdi.yStart = yObj.starts[i];
            }
          } else if (stackGroupOpts && (isV ? xValid : yValid)) {
            cdi[posAttr] = isV ? x[i] : y[i];
            cdi.gap = true;
            if (interpolate) {
              cdi.s = BADNUM;
              interpolateGaps = true;
            } else {
              cdi.s = 0;
            }
          } else {
            cdi[xAttr] = cdi[yAttr] = BADNUM;
          }
          if (ids) {
            cdi.id = String(ids[i]);
          }
        }
        arraysToCalcdata(cd, trace);
        calcColorscale(gd, trace);
        calcSelection(cd, trace);
        if (stackGroupOpts) {
          i = 0;
          while (i < cd.length) {
            if (cd[i][posAttr] === BADNUM) {
              cd.splice(i, 1);
            } else i++;
          }
          Lib.sort(cd, function(a, b) {
            return a[posAttr] - b[posAttr] || a.i - b.i;
          });
          if (interpolateGaps) {
            i = 0;
            while (i < cd.length - 1 && cd[i].gap) {
              i++;
            }
            vali = cd[i].s;
            if (!vali) vali = cd[i].s = 0;
            for (j = 0; j < i; j++) {
              cd[j].s = vali;
            }
            k = cd.length - 1;
            while (k > i && cd[k].gap) {
              k--;
            }
            vali = cd[k].s;
            for (j = cd.length - 1; j > k; j--) {
              cd[j].s = vali;
            }
            while (i < k) {
              i++;
              if (cd[i].gap) {
                j = i + 1;
                while (cd[j].gap) {
                  j++;
                }
                var pos0 = cd[i - 1][posAttr];
                var size0 = cd[i - 1].s;
                var m = (cd[j].s - size0) / (cd[j][posAttr] - pos0);
                while (i < j) {
                  cd[i].s = size0 + (cd[i][posAttr] - pos0) * m;
                  i++;
                }
              }
            }
          }
        }
        return cd;
      }
      function calcAxisExpansion(gd, trace, xa, ya, x, y, ppad) {
        var serieslen = trace._length;
        var fullLayout = gd._fullLayout;
        var xId = xa._id;
        var yId = ya._id;
        var firstScatter = fullLayout._firstScatter[firstScatterGroup(trace)] === trace.uid;
        var stackOrientation = (getStackOpts(trace, fullLayout, xa, ya) || {}).orientation;
        var fill = trace.fill;
        xa._minDtick = 0;
        ya._minDtick = 0;
        var xOptions = { padded: true };
        var yOptions = { padded: true };
        if (ppad) {
          xOptions.ppad = yOptions.ppad = ppad;
        }
        var openEnded = serieslen < 2 || x[0] !== x[serieslen - 1] || y[0] !== y[serieslen - 1];
        if (openEnded && (fill === "tozerox" || fill === "tonextx" && (firstScatter || stackOrientation === "h"))) {
          xOptions.tozero = true;
        } else if (!(trace.error_y || {}).visible && // if no error bars, markers or text, or fill to y=0 remove x padding
        (fill === "tonexty" || fill === "tozeroy" || !subTypes.hasMarkers(trace) && !subTypes.hasText(trace))) {
          xOptions.padded = false;
          xOptions.ppad = 0;
        }
        if (openEnded && (fill === "tozeroy" || fill === "tonexty" && (firstScatter || stackOrientation === "v"))) {
          yOptions.tozero = true;
        } else if (fill === "tonextx" || fill === "tozerox") {
          yOptions.padded = false;
        }
        if (xId) trace._extremes[xId] = Axes.findExtremes(xa, x, xOptions);
        if (yId) trace._extremes[yId] = Axes.findExtremes(ya, y, yOptions);
      }
      function calcMarkerSize(trace, serieslen) {
        if (!subTypes.hasMarkers(trace)) return;
        var marker = trace.marker;
        var sizeref = 1.6 * (trace.marker.sizeref || 1);
        var markerTrans;
        if (trace.marker.sizemode === "area") {
          markerTrans = function(v) {
            return Math.max(Math.sqrt((v || 0) / sizeref), 3);
          };
        } else {
          markerTrans = function(v) {
            return Math.max((v || 0) / sizeref, 3);
          };
        }
        if (Lib.isArrayOrTypedArray(marker.size)) {
          var ax = { type: "linear" };
          Axes.setConvert(ax);
          var s = ax.makeCalcdata(trace.marker, "size");
          var sizeOut = new Array(serieslen);
          for (var i = 0; i < serieslen; i++) {
            sizeOut[i] = markerTrans(s[i]);
          }
          return sizeOut;
        } else {
          return markerTrans(marker.size);
        }
      }
      function setFirstScatter(fullLayout, trace) {
        var group = firstScatterGroup(trace);
        var firstScatter = fullLayout._firstScatter;
        if (!firstScatter[group]) firstScatter[group] = trace.uid;
      }
      function firstScatterGroup(trace) {
        var stackGroup = trace.stackgroup;
        return trace.xaxis + trace.yaxis + trace.type + (stackGroup ? "-" + stackGroup : "");
      }
      function getStackOpts(trace, fullLayout, xa, ya) {
        var stackGroup = trace.stackgroup;
        if (!stackGroup) return;
        var stackOpts = fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup];
        var stackAx = stackOpts.orientation === "v" ? ya : xa;
        if (stackAx.type === "linear" || stackAx.type === "log") return stackOpts;
      }
      module.exports = {
        calc,
        calcMarkerSize,
        calcAxisExpansion,
        setFirstScatter,
        getStackOpts
      };
    }
  });

  // src/traces/bar/sieve.js
  var require_sieve = __commonJS({
    "src/traces/bar/sieve.js"(exports, module) {
      "use strict";
      module.exports = Sieve;
      var distinctVals = require_lib().distinctVals;
      function Sieve(traces, opts) {
        this.traces = traces;
        this.sepNegVal = opts.sepNegVal;
        this.overlapNoMerge = opts.overlapNoMerge;
        var width1 = Infinity;
        var axLetter = opts.posAxis._id.charAt(0);
        var positions = [];
        for (var i = 0; i < traces.length; i++) {
          var trace = traces[i];
          for (var j = 0; j < trace.length; j++) {
            var bar = trace[j];
            var pos = bar.p;
            if (pos === void 0) {
              pos = bar[axLetter];
            }
            if (pos !== void 0) positions.push(pos);
          }
          if (trace[0] && trace[0].width1) {
            width1 = Math.min(trace[0].width1, width1);
          }
        }
        this.positions = positions;
        var dv = distinctVals(positions);
        this.distinctPositions = dv.vals;
        if (dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;
        else this.minDiff = Math.min(dv.minDiff, width1);
        var type = (opts.posAxis || {}).type;
        if (type === "category" || type === "multicategory") {
          this.minDiff = 1;
        }
        this.binWidth = this.minDiff;
        this.bins = {};
      }
      Sieve.prototype.put = function put(position, group, value) {
        var label = this.getLabel(position, group, value);
        var oldValue = this.bins[label] || 0;
        this.bins[label] = oldValue + value;
        return oldValue;
      };
      Sieve.prototype.get = function get(position, group, value) {
        var label = this.getLabel(position, group, value);
        return this.bins[label] || 0;
      };
      Sieve.prototype.getLabel = function getLabel(position, group, value) {
        var prefix = value < 0 && this.sepNegVal ? "v" : "^";
        var label = this.overlapNoMerge ? position : Math.round(position / this.binWidth);
        return prefix + label + "g" + group;
      };
    }
  });

  // src/traces/bar/cross_trace_calc.js
  var require_cross_trace_calc = __commonJS({
    "src/traces/bar/cross_trace_calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var BADNUM = require_numerical().BADNUM;
      var Registry = require_registry();
      var Axes = require_axes();
      var getAxisGroup = require_constraints().getAxisGroup;
      var Sieve = require_sieve();
      function crossTraceCalc(gd, plotinfo) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var fullLayout = gd._fullLayout;
        var fullTraces = gd._fullData;
        var calcTraces = gd.calcdata;
        var calcTracesHorz = [];
        var calcTracesVert = [];
        for (var i = 0; i < fullTraces.length; i++) {
          var fullTrace = fullTraces[i];
          if (fullTrace.visible === true && Registry.traceIs(fullTrace, "bar") && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {
            if (fullTrace.orientation === "h") {
              calcTracesHorz.push(calcTraces[i]);
            } else {
              calcTracesVert.push(calcTraces[i]);
            }
            if (fullTrace._computePh) {
              var cd = gd.calcdata[i];
              for (var j = 0; j < cd.length; j++) {
                if (typeof cd[j].ph0 === "function") cd[j].ph0 = cd[j].ph0();
                if (typeof cd[j].ph1 === "function") cd[j].ph1 = cd[j].ph1();
              }
            }
          }
        }
        var opts = {
          xCat: xa.type === "category" || xa.type === "multicategory",
          yCat: ya.type === "category" || ya.type === "multicategory",
          mode: fullLayout.barmode,
          norm: fullLayout.barnorm,
          gap: fullLayout.bargap,
          groupgap: fullLayout.bargroupgap
        };
        setGroupPositions(gd, xa, ya, calcTracesVert, opts);
        setGroupPositions(gd, ya, xa, calcTracesHorz, opts);
      }
      function setGroupPositions(gd, pa, sa, calcTraces, opts) {
        if (!calcTraces.length) return;
        var excluded;
        var included;
        var i, calcTrace, fullTrace;
        initBase(sa, calcTraces);
        switch (opts.mode) {
          case "overlay":
            setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces, opts);
            break;
          case "group":
            excluded = [];
            included = [];
            for (i = 0; i < calcTraces.length; i++) {
              calcTrace = calcTraces[i];
              fullTrace = calcTrace[0].trace;
              if (fullTrace.offset === void 0) included.push(calcTrace);
              else excluded.push(calcTrace);
            }
            if (included.length) {
              setGroupPositionsInGroupMode(gd, pa, sa, included, opts);
            }
            if (excluded.length) {
              setGroupPositionsInOverlayMode(gd, pa, sa, excluded, opts);
            }
            break;
          case "stack":
          case "relative":
            excluded = [];
            included = [];
            for (i = 0; i < calcTraces.length; i++) {
              calcTrace = calcTraces[i];
              fullTrace = calcTrace[0].trace;
              if (fullTrace.base === void 0) included.push(calcTrace);
              else excluded.push(calcTrace);
            }
            standardizeCornerradius(included);
            if (included.length) {
              setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);
            }
            if (excluded.length) {
              setGroupPositionsInOverlayMode(gd, pa, sa, excluded, opts);
            }
            break;
        }
        setCornerradius(calcTraces);
        collectExtents(calcTraces, pa);
      }
      function setCornerradius(calcTraces) {
        var i, calcTrace, fullTrace, t, cr, crValue, crForm;
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          t = calcTrace[0].t;
          if (t.cornerradiusvalue === void 0) {
            cr = fullTrace.marker ? fullTrace.marker.cornerradius : void 0;
            if (cr !== void 0) {
              crValue = isNumeric(cr) ? +cr : +cr.slice(0, -1);
              crForm = isNumeric(cr) ? "px" : "%";
              t.cornerradiusvalue = crValue;
              t.cornerradiusform = crForm;
            }
          }
        }
      }
      function standardizeCornerradius(calcTraces) {
        if (calcTraces.length < 2) return;
        var i, calcTrace, fullTrace, t;
        var cr, crValue, crForm;
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          cr = fullTrace.marker ? fullTrace.marker.cornerradius : void 0;
          if (cr !== void 0) break;
        }
        if (cr !== void 0) {
          crValue = isNumeric(cr) ? +cr : +cr.slice(0, -1);
          crForm = isNumeric(cr) ? "px" : "%";
          for (i = 0; i < calcTraces.length; i++) {
            calcTrace = calcTraces[i];
            t = calcTrace[0].t;
            t.cornerradiusvalue = crValue;
            t.cornerradiusform = crForm;
          }
        }
      }
      function initBase(sa, calcTraces) {
        var i, j;
        for (i = 0; i < calcTraces.length; i++) {
          var cd = calcTraces[i];
          var trace = cd[0].trace;
          var base = trace.type === "funnel" ? trace._base : trace.base;
          var b;
          var scalendar = trace.orientation === "h" ? trace.xcalendar : trace.ycalendar;
          var d2c = sa.type === "category" || sa.type === "multicategory" ? function() {
            return null;
          } : sa.d2c;
          if (isArrayOrTypedArray(base)) {
            for (j = 0; j < Math.min(base.length, cd.length); j++) {
              b = d2c(base[j], 0, scalendar);
              if (isNumeric(b)) {
                cd[j].b = +b;
                cd[j].hasB = 1;
              } else cd[j].b = 0;
            }
            for (; j < cd.length; j++) {
              cd[j].b = 0;
            }
          } else {
            b = d2c(base, 0, scalendar);
            var hasBase = isNumeric(b);
            b = hasBase ? b : 0;
            for (j = 0; j < cd.length; j++) {
              cd[j].b = b;
              if (hasBase) cd[j].hasB = 1;
            }
          }
        }
      }
      function setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces, opts) {
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var sieve = new Sieve([calcTrace], {
            posAxis: pa,
            sepNegVal: false,
            overlapNoMerge: !opts.norm
          });
          setOffsetAndWidth(gd, pa, sieve, opts);
          if (opts.norm) {
            sieveBars(sieve);
            normalizeBars(sa, sieve, opts);
          } else {
            setBaseAndTop(sa, sieve);
          }
        }
      }
      function setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {
        var sieve = new Sieve(calcTraces, {
          posAxis: pa,
          sepNegVal: false,
          overlapNoMerge: !opts.norm
        });
        setOffsetAndWidth(gd, pa, sieve, opts);
        unhideBarsWithinTrace(sieve, pa);
        if (opts.norm) {
          sieveBars(sieve);
          normalizeBars(sa, sieve, opts);
        } else {
          setBaseAndTop(sa, sieve);
        }
      }
      function setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {
        var sieve = new Sieve(calcTraces, {
          posAxis: pa,
          sepNegVal: opts.mode === "relative",
          overlapNoMerge: !(opts.norm || opts.mode === "stack" || opts.mode === "relative")
        });
        setOffsetAndWidth(gd, pa, sieve, opts);
        stackBars(sa, sieve, opts);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var offsetIndex = calcTrace[0].t.offsetindex;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              var isOutmostBar = bar.b + bar.s === sieve.get(bar.p, offsetIndex, bar.s);
              if (isOutmostBar) bar._outmost = true;
            }
          }
        }
        if (opts.norm) normalizeBars(sa, sieve, opts);
      }
      function setOffsetAndWidth(gd, pa, sieve, opts) {
        var fullLayout = gd._fullLayout;
        var positions = sieve.positions;
        var distinctPositions = sieve.distinctPositions;
        var minDiff = sieve.minDiff;
        var calcTraces = sieve.traces;
        var nTraces = calcTraces.length;
        var overlap = positions.length !== distinctPositions.length;
        var barGroupWidth = minDiff * (1 - opts.gap);
        var barWidthPlusGap;
        var barWidth;
        var offsetFromCenter;
        var alignmentGroups;
        if (pa._id === "angularaxis") {
          barWidthPlusGap = barGroupWidth;
          barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));
          offsetFromCenter = -barWidth / 2;
        } else {
          var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;
          alignmentGroups = fullLayout._alignmentOpts[groupId] || {};
        }
        for (var i = 0; i < nTraces; i++) {
          var calcTrace = calcTraces[i];
          var trace = calcTrace[0].trace;
          if (pa._id !== "angularaxis") {
            var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};
            var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;
            if (nOffsetGroups) {
              barWidthPlusGap = barGroupWidth / nOffsetGroups;
            } else {
              barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;
            }
            barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));
            if (nOffsetGroups) {
              offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;
            } else {
              offsetFromCenter = overlap ? ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 : -barWidth / 2;
            }
          }
          var t = calcTrace[0].t;
          t.barwidth = barWidth;
          t.offsetindex = trace._offsetIndex || 0;
          t.poffset = offsetFromCenter;
          t.bargroupwidth = barGroupWidth;
          t.bardelta = minDiff;
        }
        sieve.binWidth = calcTraces[0][0].t.barwidth / 100;
        applyAttributes(sieve);
        setBarCenterAndWidth(pa, sieve);
        if (pa._id === "angularaxis") {
          updatePositionAxis(pa, sieve);
        } else {
          updatePositionAxis(pa, sieve, overlap);
        }
      }
      function applyAttributes(sieve) {
        var calcTraces = sieve.traces;
        var i, j;
        for (i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var calcTrace0 = calcTrace[0];
          var fullTrace = calcTrace0.trace;
          var t = calcTrace0.t;
          var offset = fullTrace._offset || fullTrace.offset;
          var initialPoffset = t.poffset;
          var newPoffset;
          if (isArrayOrTypedArray(offset)) {
            newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);
            for (j = 0; j < newPoffset.length; j++) {
              if (!isNumeric(newPoffset[j])) {
                newPoffset[j] = initialPoffset;
              }
            }
            for (j = newPoffset.length; j < calcTrace.length; j++) {
              newPoffset.push(initialPoffset);
            }
            t.poffset = newPoffset;
          } else if (offset !== void 0) {
            t.poffset = offset;
          }
          var width = fullTrace._width || fullTrace.width;
          var initialBarwidth = t.barwidth;
          if (isArrayOrTypedArray(width)) {
            var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);
            for (j = 0; j < newBarwidth.length; j++) {
              if (!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;
            }
            for (j = newBarwidth.length; j < calcTrace.length; j++) {
              newBarwidth.push(initialBarwidth);
            }
            t.barwidth = newBarwidth;
            if (offset === void 0) {
              newPoffset = [];
              for (j = 0; j < calcTrace.length; j++) {
                newPoffset.push(
                  initialPoffset + (initialBarwidth - newBarwidth[j]) / 2
                );
              }
              t.poffset = newPoffset;
            }
          } else if (width !== void 0) {
            t.barwidth = width;
            if (offset === void 0) {
              t.poffset = initialPoffset + (initialBarwidth - width) / 2;
            }
          }
        }
      }
      function setBarCenterAndWidth(pa, sieve) {
        var calcTraces = sieve.traces;
        var pLetter = getAxisLetter(pa);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var t = calcTrace[0].t;
          var poffset = t.poffset;
          var poffsetIsArray = isArrayOrTypedArray(poffset);
          var barwidth = t.barwidth;
          var barwidthIsArray = isArrayOrTypedArray(barwidth);
          for (var j = 0; j < calcTrace.length; j++) {
            var calcBar = calcTrace[j];
            var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;
            if (calcBar.p === void 0) {
              calcBar.p = calcBar[pLetter];
              calcBar["orig_" + pLetter] = calcBar[pLetter];
            }
            var delta = (poffsetIsArray ? poffset[j] : poffset) + width / 2;
            calcBar[pLetter] = calcBar.p + delta;
          }
        }
      }
      function updatePositionAxis(pa, sieve, allowMinDtick) {
        var calcTraces = sieve.traces;
        var minDiff = sieve.minDiff;
        var vpad = minDiff / 2;
        Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var calcTrace0 = calcTrace[0];
          var fullTrace = calcTrace0.trace;
          var pts = [];
          var bar, l, r, j;
          for (j = 0; j < calcTrace.length; j++) {
            bar = calcTrace[j];
            l = bar.p - vpad;
            r = bar.p + vpad;
            pts.push(l, r);
          }
          if (fullTrace.width || fullTrace.offset) {
            var t = calcTrace0.t;
            var poffset = t.poffset;
            var barwidth = t.barwidth;
            var poffsetIsArray = isArrayOrTypedArray(poffset);
            var barwidthIsArray = isArrayOrTypedArray(barwidth);
            for (j = 0; j < calcTrace.length; j++) {
              bar = calcTrace[j];
              var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;
              var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;
              l = bar.p + calcBarOffset;
              r = l + calcBarWidth;
              pts.push(l, r);
            }
          }
          fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, { padded: false });
        }
      }
      function setBaseAndTop(sa, sieve) {
        var calcTraces = sieve.traces;
        var sLetter = getAxisLetter(sa);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var fullTrace = calcTrace[0].trace;
          var isScatter = fullTrace.type === "scatter";
          var isVertical = fullTrace.orientation === "v";
          var pts = [];
          var tozero = false;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            var base = isScatter ? 0 : bar.b;
            var top = isScatter ? isVertical ? bar.y : bar.x : base + bar.s;
            bar[sLetter] = top;
            pts.push(top);
            if (bar.hasB) pts.push(base);
            if (!bar.hasB || !bar.b) {
              tozero = true;
            }
          }
          fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
            tozero,
            padded: true
          });
        }
      }
      function stackBars(sa, sieve, opts) {
        var sLetter = getAxisLetter(sa);
        var calcTraces = sieve.traces;
        var calcTrace;
        var fullTrace;
        var isFunnel;
        var i, j;
        var bar;
        var offsetIndex;
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          if (fullTrace.type === "funnel") {
            offsetIndex = calcTrace[0].t.offsetindex;
            for (j = 0; j < calcTrace.length; j++) {
              bar = calcTrace[j];
              if (bar.s !== BADNUM) {
                sieve.put(bar.p, offsetIndex, -0.5 * bar.s);
              }
            }
          }
        }
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          isFunnel = fullTrace.type === "funnel";
          offsetIndex = fullTrace.type === "barpolar" ? 0 : calcTrace[0].t.offsetindex;
          var pts = [];
          for (j = 0; j < calcTrace.length; j++) {
            bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              var value;
              if (isFunnel) {
                value = bar.s;
              } else {
                value = bar.s + bar.b;
              }
              var base = sieve.put(bar.p, offsetIndex, value);
              var top = base + value;
              bar.b = base;
              bar[sLetter] = top;
              if (!opts.norm) {
                pts.push(top);
                if (bar.hasB) {
                  pts.push(base);
                }
              }
            }
          }
          if (!opts.norm) {
            fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
              // N.B. we don't stack base with 'base',
              // so set tozero:true always!
              tozero: true,
              padded: true
            });
          }
        }
      }
      function sieveBars(sieve) {
        var calcTraces = sieve.traces;
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var offsetIndex = calcTrace[0].t.offsetindex;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              sieve.put(bar.p, offsetIndex, bar.b + bar.s);
            }
          }
        }
      }
      function unhideBarsWithinTrace(sieve, pa) {
        var calcTraces = sieve.traces;
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var fullTrace = calcTrace[0].trace;
          var offsetIndex = calcTrace[0].t.offsetindex;
          if (fullTrace.base === void 0) {
            var inTraceSieve = new Sieve([calcTrace], {
              posAxis: pa,
              sepNegVal: true,
              overlapNoMerge: true
            });
            for (var j = 0; j < calcTrace.length; j++) {
              var bar = calcTrace[j];
              if (bar.p !== BADNUM) {
                var base = inTraceSieve.put(bar.p, offsetIndex, bar.b + bar.s);
                if (base) bar.b = base;
              }
            }
          }
        }
      }
      function normalizeBars(sa, sieve, opts) {
        var calcTraces = sieve.traces;
        var sLetter = getAxisLetter(sa);
        var sTop = opts.norm === "fraction" ? 1 : 100;
        var sTiny = sTop / 1e9;
        var sMin = sa.l2c(sa.c2l(0));
        var sMax = opts.mode === "stack" ? sTop : sMin;
        function needsPadding(v) {
          return isNumeric(sa.c2l(v)) && (v < sMin - sTiny || v > sMax + sTiny || !isNumeric(sMin));
        }
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var offsetIndex = calcTrace[0].t.offsetindex;
          var fullTrace = calcTrace[0].trace;
          var pts = [];
          var tozero = false;
          var padded = false;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              var scale = Math.abs(sTop / sieve.get(bar.p, offsetIndex, bar.s));
              bar.b *= scale;
              bar.s *= scale;
              var base = bar.b;
              var top = base + bar.s;
              bar[sLetter] = top;
              pts.push(top);
              padded = padded || needsPadding(top);
              if (bar.hasB) {
                pts.push(base);
                padded = padded || needsPadding(base);
              }
              if (!bar.hasB || !bar.b) {
                tozero = true;
              }
            }
          }
          fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
            tozero,
            padded
          });
        }
      }
      function setHelperValuesForRoundedCorners(calcTraces, sMinByPos, sMaxByPos, pa) {
        var pLetter = getAxisLetter(pa);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            var pos = bar[pLetter];
            bar._sMin = sMinByPos[pos];
            bar._sMax = sMaxByPos[pos];
          }
        }
      }
      function collectExtents(calcTraces, pa) {
        var pLetter = getAxisLetter(pa);
        var extents = {};
        var i, j, cd;
        var pMin = Infinity;
        var pMax = -Infinity;
        for (i = 0; i < calcTraces.length; i++) {
          cd = calcTraces[i];
          for (j = 0; j < cd.length; j++) {
            var p = cd[j].p;
            if (isNumeric(p)) {
              pMin = Math.min(pMin, p);
              pMax = Math.max(pMax, p);
            }
          }
        }
        var roundFactor = 1e4 / (pMax - pMin);
        var round = extents.round = function(p2) {
          return String(Math.round(roundFactor * (p2 - pMin)));
        };
        var sMinByPos = {};
        var sMaxByPos = {};
        var anyTraceHasCornerradius = calcTraces.some(function(x) {
          var trace = x[0].trace;
          return "marker" in trace && trace.marker.cornerradius;
        });
        for (i = 0; i < calcTraces.length; i++) {
          cd = calcTraces[i];
          cd[0].t.extents = extents;
          var poffset = cd[0].t.poffset;
          var poffsetIsArray = isArrayOrTypedArray(poffset);
          for (j = 0; j < cd.length; j++) {
            var di = cd[j];
            var p0 = di[pLetter] - di.w / 2;
            if (isNumeric(p0)) {
              var p1 = di[pLetter] + di.w / 2;
              var pVal = round(di.p);
              if (extents[pVal]) {
                extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];
              } else {
                extents[pVal] = [p0, p1];
              }
            }
            di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);
            di.p1 = di.p0 + di.w;
            di.s0 = di.b;
            di.s1 = di.s0 + di.s;
            if (anyTraceHasCornerradius) {
              var sMin = Math.min(di.s0, di.s1) || 0;
              var sMax = Math.max(di.s0, di.s1) || 0;
              var pos = di[pLetter];
              sMinByPos[pos] = pos in sMinByPos ? Math.min(sMinByPos[pos], sMin) : sMin;
              sMaxByPos[pos] = pos in sMaxByPos ? Math.max(sMaxByPos[pos], sMax) : sMax;
            }
          }
        }
        if (anyTraceHasCornerradius) {
          setHelperValuesForRoundedCorners(calcTraces, sMinByPos, sMaxByPos, pa);
        }
      }
      function getAxisLetter(ax) {
        return ax._id.charAt(0);
      }
      module.exports = {
        crossTraceCalc,
        setGroupPositions
      };
    }
  });

  // src/traces/scatter/cross_trace_calc.js
  var require_cross_trace_calc2 = __commonJS({
    "src/traces/scatter/cross_trace_calc.js"(exports, module) {
      "use strict";
      var calc = require_calc3();
      var setGroupPositions = require_cross_trace_calc().setGroupPositions;
      function groupCrossTraceCalc(gd, plotinfo) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var fullLayout = gd._fullLayout;
        var fullTraces = gd._fullData;
        var calcTraces = gd.calcdata;
        var calcTracesHorz = [];
        var calcTracesVert = [];
        for (var i = 0; i < fullTraces.length; i++) {
          var fullTrace = fullTraces[i];
          if (fullTrace.visible === true && fullTrace.type === "scatter" && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {
            if (fullTrace.orientation === "h") {
              calcTracesHorz.push(calcTraces[i]);
            } else if (fullTrace.orientation === "v") {
              calcTracesVert.push(calcTraces[i]);
            }
          }
        }
        var opts = {
          mode: fullLayout.scattermode,
          gap: fullLayout.scattergap
        };
        setGroupPositions(gd, xa, ya, calcTracesVert, opts);
        setGroupPositions(gd, ya, xa, calcTracesHorz, opts);
      }
      module.exports = function crossTraceCalc(gd, plotinfo) {
        if (gd._fullLayout.scattermode === "group") {
          groupCrossTraceCalc(gd, plotinfo);
        }
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var subplot = xa._id + ya._id;
        var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];
        if (!subplotStackOpts) return;
        var calcTraces = gd.calcdata;
        var i, j, k, i2, cd, cd0, posj, sumj, norm;
        var groupOpts, interpolate, groupnorm, posAttr, valAttr;
        var hasAnyBlanks;
        for (var stackGroup in subplotStackOpts) {
          groupOpts = subplotStackOpts[stackGroup];
          var indices = groupOpts.traceIndices;
          if (!indices.length) continue;
          interpolate = groupOpts.stackgaps === "interpolate";
          groupnorm = groupOpts.groupnorm;
          if (groupOpts.orientation === "v") {
            posAttr = "x";
            valAttr = "y";
          } else {
            posAttr = "y";
            valAttr = "x";
          }
          hasAnyBlanks = new Array(indices.length);
          for (i = 0; i < hasAnyBlanks.length; i++) {
            hasAnyBlanks[i] = false;
          }
          cd0 = calcTraces[indices[0]];
          var allPositions = new Array(cd0.length);
          for (i = 0; i < cd0.length; i++) {
            allPositions[i] = cd0[i][posAttr];
          }
          for (i = 1; i < indices.length; i++) {
            cd = calcTraces[indices[i]];
            for (j = k = 0; j < cd.length; j++) {
              posj = cd[j][posAttr];
              for (; posj > allPositions[k] && k < allPositions.length; k++) {
                insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);
                j++;
              }
              if (posj !== allPositions[k]) {
                for (i2 = 0; i2 < i; i2++) {
                  insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);
                }
                allPositions.splice(k, 0, posj);
              }
              k++;
            }
            for (; k < allPositions.length; k++) {
              insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);
              j++;
            }
          }
          var serieslen = allPositions.length;
          for (j = 0; j < cd0.length; j++) {
            sumj = cd0[j][valAttr] = cd0[j].s;
            for (i = 1; i < indices.length; i++) {
              cd = calcTraces[indices[i]];
              cd[0].trace._rawLength = cd[0].trace._length;
              cd[0].trace._length = serieslen;
              sumj += cd[j].s;
              cd[j][valAttr] = sumj;
            }
            if (groupnorm) {
              norm = (groupnorm === "fraction" ? sumj : sumj / 100) || 1;
              for (i = 0; i < indices.length; i++) {
                var cdj = calcTraces[indices[i]][j];
                cdj[valAttr] /= norm;
                cdj.sNorm = cdj.s / norm;
              }
            }
          }
          for (i = 0; i < indices.length; i++) {
            cd = calcTraces[indices[i]];
            var trace = cd[0].trace;
            var ppad = calc.calcMarkerSize(trace, trace._rawLength);
            var arrayPad = Array.isArray(ppad);
            if (ppad && hasAnyBlanks[i] || arrayPad) {
              var ppadRaw = ppad;
              ppad = new Array(serieslen);
              for (j = 0; j < serieslen; j++) {
                ppad[j] = cd[j].gap ? 0 : arrayPad ? ppadRaw[cd[j].i] : ppadRaw;
              }
            }
            var x = new Array(serieslen);
            var y = new Array(serieslen);
            for (j = 0; j < serieslen; j++) {
              x[j] = cd[j].x;
              y[j] = cd[j].y;
            }
            calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);
            cd[0].t.orientation = groupOpts.orientation;
          }
        }
      };
      function insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {
        hasAnyBlanks[traceIndex] = true;
        var newEntry = {
          i: null,
          gap: true,
          s: 0
        };
        newEntry[posAttr] = position;
        calcTrace.splice(index, 0, newEntry);
        if (index && position === calcTrace[index - 1][posAttr]) {
          var prevEntry = calcTrace[index - 1];
          newEntry.s = prevEntry.s;
          newEntry.i = prevEntry.i;
          newEntry.gap = prevEntry.gap;
        } else if (interpolate) {
          newEntry.s = getInterp(calcTrace, index, position, posAttr);
        }
        if (!index) {
          calcTrace[0].t = calcTrace[1].t;
          calcTrace[0].trace = calcTrace[1].trace;
          delete calcTrace[1].t;
          delete calcTrace[1].trace;
        }
      }
      function getInterp(calcTrace, index, position, posAttr) {
        var pt0 = calcTrace[index - 1];
        var pt1 = calcTrace[index + 1];
        if (!pt1) return pt0.s;
        if (!pt0) return pt1.s;
        return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);
      }
    }
  });

  // src/traces/scatter/line_points.js
  var require_line_points = __commonJS({
    "src/traces/scatter/line_points.js"(exports, module) {
      "use strict";
      var Drawing = require_drawing();
      var numConstants = require_numerical();
      var BADNUM = numConstants.BADNUM;
      var LOG_CLIP = numConstants.LOG_CLIP;
      var LOG_CLIP_PLUS = LOG_CLIP + 0.5;
      var LOG_CLIP_MINUS = LOG_CLIP - 0.5;
      var Lib = require_lib();
      var segmentsIntersect = Lib.segmentsIntersect;
      var constrain = Lib.constrain;
      var constants = require_constants8();
      module.exports = function linePoints(d, opts) {
        var trace = opts.trace || {};
        var xa = opts.xaxis;
        var ya = opts.yaxis;
        var xLog = xa.type === "log";
        var yLog = ya.type === "log";
        var xLen = xa._length;
        var yLen = ya._length;
        var backoff = opts.backoff;
        var marker = trace.marker;
        var connectGaps = opts.connectGaps;
        var baseTolerance = opts.baseTolerance;
        var shape = opts.shape;
        var linear = shape === "linear";
        var fill = trace.fill && trace.fill !== "none";
        var segments = [];
        var minTolerance = constants.minTolerance;
        var len = d.length;
        var pts = new Array(len);
        var pti = 0;
        var i;
        var clusterStartPt, clusterEndPt, clusterHighPt, clusterLowPt;
        var thisPt;
        var clusterHighFirst;
        var clusterUnitVector;
        var thisVector;
        var clusterRefDist, clusterHighVal, clusterLowVal, thisVal;
        var clusterMinDeviation, clusterMaxDeviation, thisDeviation;
        function getPt(index) {
          var di = d[index];
          if (!di) return false;
          var x = opts.linearized ? xa.l2p(di.x) : xa.c2p(di.x);
          var y = opts.linearized ? ya.l2p(di.y) : ya.c2p(di.y);
          if (x === BADNUM) {
            if (xLog) x = xa.c2p(di.x, true);
            if (x === BADNUM) return false;
            if (yLog && y === BADNUM) {
              x *= Math.abs(xa._m * yLen * (xa._m > 0 ? LOG_CLIP_PLUS : LOG_CLIP_MINUS) / (ya._m * xLen * (ya._m > 0 ? LOG_CLIP_PLUS : LOG_CLIP_MINUS)));
            }
            x *= 1e3;
          }
          if (y === BADNUM) {
            if (yLog) y = ya.c2p(di.y, true);
            if (y === BADNUM) return false;
            y *= 1e3;
          }
          return [x, y];
        }
        function crossesViewport(xFrac0, yFrac0, xFrac1, yFrac1) {
          var dx = xFrac1 - xFrac0;
          var dy = yFrac1 - yFrac0;
          var dx0 = 0.5 - xFrac0;
          var dy0 = 0.5 - yFrac0;
          var norm2 = dx * dx + dy * dy;
          var dot = dx * dx0 + dy * dy0;
          if (dot > 0 && dot < norm2) {
            var cross = dx0 * dy - dy0 * dx;
            if (cross * cross < norm2) return true;
          }
        }
        var latestXFrac, latestYFrac;
        function getTolerance(pt, nextPt2) {
          var xFrac = pt[0] / xLen;
          var yFrac = pt[1] / yLen;
          var offScreenFraction = Math.max(0, -xFrac, xFrac - 1, -yFrac, yFrac - 1);
          if (offScreenFraction && latestXFrac !== void 0 && crossesViewport(xFrac, yFrac, latestXFrac, latestYFrac)) {
            offScreenFraction = 0;
          }
          if (offScreenFraction && nextPt2 && crossesViewport(xFrac, yFrac, nextPt2[0] / xLen, nextPt2[1] / yLen)) {
            offScreenFraction = 0;
          }
          return (1 + constants.toleranceGrowth * offScreenFraction) * baseTolerance;
        }
        function ptDist(pt1, pt2) {
          var dx = pt1[0] - pt2[0];
          var dy = pt1[1] - pt2[1];
          return Math.sqrt(dx * dx + dy * dy);
        }
        var maxScreensAway = constants.maxScreensAway;
        var xEdge0 = -xLen * maxScreensAway;
        var xEdge1 = xLen * (1 + maxScreensAway);
        var yEdge0 = -yLen * maxScreensAway;
        var yEdge1 = yLen * (1 + maxScreensAway);
        var edges = [
          [xEdge0, yEdge0, xEdge1, yEdge0],
          [xEdge1, yEdge0, xEdge1, yEdge1],
          [xEdge1, yEdge1, xEdge0, yEdge1],
          [xEdge0, yEdge1, xEdge0, yEdge0]
        ];
        var xEdge, yEdge, lastXEdge, lastYEdge, lastFarPt, edgePt;
        function getLinearEdgeIntersections(pt1, pt2) {
          var out = [];
          var ptCount = 0;
          for (var i2 = 0; i2 < 4; i2++) {
            var edge = edges[i2];
            var ptInt = segmentsIntersect(
              pt1[0],
              pt1[1],
              pt2[0],
              pt2[1],
              edge[0],
              edge[1],
              edge[2],
              edge[3]
            );
            if (ptInt && (!ptCount || Math.abs(ptInt.x - out[0][0]) > 1 || Math.abs(ptInt.y - out[0][1]) > 1)) {
              ptInt = [ptInt.x, ptInt.y];
              if (ptCount && ptDist(ptInt, pt1) < ptDist(out[0], pt1)) out.unshift(ptInt);
              else out.push(ptInt);
              ptCount++;
            }
          }
          return out;
        }
        function onlyConstrainedPoint(pt) {
          if (pt[0] < xEdge0 || pt[0] > xEdge1 || pt[1] < yEdge0 || pt[1] > yEdge1) {
            return [constrain(pt[0], xEdge0, xEdge1), constrain(pt[1], yEdge0, yEdge1)];
          }
        }
        function sameEdge(pt1, pt2) {
          if (pt1[0] === pt2[0] && (pt1[0] === xEdge0 || pt1[0] === xEdge1)) return true;
          if (pt1[1] === pt2[1] && (pt1[1] === yEdge0 || pt1[1] === yEdge1)) return true;
        }
        function getHVEdgeIntersections(pt1, pt2) {
          var out = [];
          var ptInt1 = onlyConstrainedPoint(pt1);
          var ptInt2 = onlyConstrainedPoint(pt2);
          if (ptInt1 && ptInt2 && sameEdge(ptInt1, ptInt2)) return out;
          if (ptInt1) out.push(ptInt1);
          if (ptInt2) out.push(ptInt2);
          return out;
        }
        function getABAEdgeIntersections(dim, limit0, limit1) {
          return function(pt1, pt2) {
            var ptInt1 = onlyConstrainedPoint(pt1);
            var ptInt2 = onlyConstrainedPoint(pt2);
            var out = [];
            if (ptInt1 && ptInt2 && sameEdge(ptInt1, ptInt2)) return out;
            if (ptInt1) out.push(ptInt1);
            if (ptInt2) out.push(ptInt2);
            var midShift = 2 * Lib.constrain((pt1[dim] + pt2[dim]) / 2, limit0, limit1) - ((ptInt1 || pt1)[dim] + (ptInt2 || pt2)[dim]);
            if (midShift) {
              var ptToAlter;
              if (ptInt1 && ptInt2) {
                ptToAlter = midShift > 0 === ptInt1[dim] > ptInt2[dim] ? ptInt1 : ptInt2;
              } else ptToAlter = ptInt1 || ptInt2;
              ptToAlter[dim] += midShift;
            }
            return out;
          };
        }
        var getEdgeIntersections;
        if (shape === "linear" || shape === "spline") {
          getEdgeIntersections = getLinearEdgeIntersections;
        } else if (shape === "hv" || shape === "vh") {
          getEdgeIntersections = getHVEdgeIntersections;
        } else if (shape === "hvh") getEdgeIntersections = getABAEdgeIntersections(0, xEdge0, xEdge1);
        else if (shape === "vhv") getEdgeIntersections = getABAEdgeIntersections(1, yEdge0, yEdge1);
        function getClosestCorner(pt1, pt2) {
          var dx = pt2[0] - pt1[0];
          var m = (pt2[1] - pt1[1]) / dx;
          var b = (pt1[1] * pt2[0] - pt2[1] * pt1[0]) / dx;
          if (b > 0) return [m > 0 ? xEdge0 : xEdge1, yEdge1];
          else return [m > 0 ? xEdge1 : xEdge0, yEdge0];
        }
        function updateEdge(pt) {
          var x = pt[0];
          var y = pt[1];
          var xSame = x === pts[pti - 1][0];
          var ySame = y === pts[pti - 1][1];
          if (xSame && ySame) return;
          if (pti > 1) {
            var xSame2 = x === pts[pti - 2][0];
            var ySame2 = y === pts[pti - 2][1];
            if (xSame && (x === xEdge0 || x === xEdge1) && xSame2) {
              if (ySame2) pti--;
              else pts[pti - 1] = pt;
            } else if (ySame && (y === yEdge0 || y === yEdge1) && ySame2) {
              if (xSame2) pti--;
              else pts[pti - 1] = pt;
            } else pts[pti++] = pt;
          } else pts[pti++] = pt;
        }
        function updateEdgesForReentry(pt) {
          if (pts[pti - 1][0] !== pt[0] && pts[pti - 1][1] !== pt[1]) {
            updateEdge([lastXEdge, lastYEdge]);
          }
          updateEdge(pt);
          lastFarPt = null;
          lastXEdge = lastYEdge = 0;
        }
        var arrayMarker = Lib.isArrayOrTypedArray(marker);
        function addPt(pt) {
          if (pt && backoff) {
            pt.i = i;
            pt.d = d;
            pt.trace = trace;
            pt.marker = arrayMarker ? marker[pt.i] : marker;
            pt.backoff = backoff;
          }
          latestXFrac = pt[0] / xLen;
          latestYFrac = pt[1] / yLen;
          xEdge = pt[0] < xEdge0 ? xEdge0 : pt[0] > xEdge1 ? xEdge1 : 0;
          yEdge = pt[1] < yEdge0 ? yEdge0 : pt[1] > yEdge1 ? yEdge1 : 0;
          if (xEdge || yEdge) {
            if (!pti) {
              pts[pti++] = [xEdge || pt[0], yEdge || pt[1]];
            } else if (lastFarPt) {
              var intersections = getEdgeIntersections(lastFarPt, pt);
              if (intersections.length > 1) {
                updateEdgesForReentry(intersections[0]);
                pts[pti++] = intersections[1];
              }
            } else {
              edgePt = getEdgeIntersections(pts[pti - 1], pt)[0];
              pts[pti++] = edgePt;
            }
            var lastPt = pts[pti - 1];
            if (xEdge && yEdge && (lastPt[0] !== xEdge || lastPt[1] !== yEdge)) {
              if (lastFarPt) {
                if (lastXEdge !== xEdge && lastYEdge !== yEdge) {
                  if (lastXEdge && lastYEdge) {
                    updateEdge(getClosestCorner(lastFarPt, pt));
                  } else {
                    updateEdge([lastXEdge || xEdge, lastYEdge || yEdge]);
                  }
                } else if (lastXEdge && lastYEdge) {
                  updateEdge([lastXEdge, lastYEdge]);
                }
              }
              updateEdge([xEdge, yEdge]);
            } else if (lastXEdge - xEdge && lastYEdge - yEdge) {
              updateEdge([xEdge || lastXEdge, yEdge || lastYEdge]);
            }
            lastFarPt = pt;
            lastXEdge = xEdge;
            lastYEdge = yEdge;
          } else {
            if (lastFarPt) {
              updateEdgesForReentry(getEdgeIntersections(lastFarPt, pt)[0]);
            }
            pts[pti++] = pt;
          }
        }
        for (i = 0; i < len; i++) {
          clusterStartPt = getPt(i);
          if (!clusterStartPt) continue;
          pti = 0;
          lastFarPt = null;
          addPt(clusterStartPt);
          for (i++; i < len; i++) {
            clusterHighPt = getPt(i);
            if (!clusterHighPt) {
              if (connectGaps) continue;
              else break;
            }
            if (!linear || !opts.simplify) {
              addPt(clusterHighPt);
              continue;
            }
            var nextPt = getPt(i + 1);
            clusterRefDist = ptDist(clusterHighPt, clusterStartPt);
            if (!(fill && (pti === 0 || pti === len - 1)) && clusterRefDist < getTolerance(clusterHighPt, nextPt) * minTolerance) continue;
            clusterUnitVector = [
              (clusterHighPt[0] - clusterStartPt[0]) / clusterRefDist,
              (clusterHighPt[1] - clusterStartPt[1]) / clusterRefDist
            ];
            clusterLowPt = clusterStartPt;
            clusterHighVal = clusterRefDist;
            clusterLowVal = clusterMinDeviation = clusterMaxDeviation = 0;
            clusterHighFirst = false;
            clusterEndPt = clusterHighPt;
            for (i++; i < d.length; i++) {
              thisPt = nextPt;
              nextPt = getPt(i + 1);
              if (!thisPt) {
                if (connectGaps) continue;
                else break;
              }
              thisVector = [
                thisPt[0] - clusterStartPt[0],
                thisPt[1] - clusterStartPt[1]
              ];
              thisDeviation = thisVector[0] * clusterUnitVector[1] - thisVector[1] * clusterUnitVector[0];
              clusterMinDeviation = Math.min(clusterMinDeviation, thisDeviation);
              clusterMaxDeviation = Math.max(clusterMaxDeviation, thisDeviation);
              if (clusterMaxDeviation - clusterMinDeviation > getTolerance(thisPt, nextPt)) break;
              clusterEndPt = thisPt;
              thisVal = thisVector[0] * clusterUnitVector[0] + thisVector[1] * clusterUnitVector[1];
              if (thisVal > clusterHighVal) {
                clusterHighVal = thisVal;
                clusterHighPt = thisPt;
                clusterHighFirst = false;
              } else if (thisVal < clusterLowVal) {
                clusterLowVal = thisVal;
                clusterLowPt = thisPt;
                clusterHighFirst = true;
              }
            }
            if (clusterHighFirst) {
              addPt(clusterHighPt);
              if (clusterEndPt !== clusterLowPt) addPt(clusterLowPt);
            } else {
              if (clusterLowPt !== clusterStartPt) addPt(clusterLowPt);
              if (clusterEndPt !== clusterHighPt) addPt(clusterHighPt);
            }
            addPt(clusterEndPt);
            if (i >= d.length || !thisPt) break;
            addPt(thisPt);
            clusterStartPt = thisPt;
          }
          if (lastFarPt) updateEdge([lastXEdge || lastFarPt[0], lastYEdge || lastFarPt[1]]);
          segments.push(pts.slice(0, pti));
        }
        var lastShapeChar = shape.slice(shape.length - 1);
        if (backoff && lastShapeChar !== "h" && lastShapeChar !== "v") {
          var trimmed = false;
          var n = -1;
          var newSegments = [];
          for (var j = 0; j < segments.length; j++) {
            for (var k = 0; k < segments[j].length - 1; k++) {
              var start = segments[j][k];
              var end = segments[j][k + 1];
              var xy = Drawing.applyBackoff(end, start);
              if (xy[0] !== end[0] || xy[1] !== end[1]) {
                trimmed = true;
              }
              if (!newSegments[n + 1]) {
                n++;
                newSegments[n] = [
                  start,
                  [xy[0], xy[1]]
                ];
              }
            }
          }
          return trimmed ? newSegments : segments;
        }
        return segments;
      };
    }
  });

  // src/traces/scatter/link_traces.js
  var require_link_traces = __commonJS({
    "src/traces/scatter/link_traces.js"(exports, module) {
      "use strict";
      var LINKEDFILLS = { tonextx: 1, tonexty: 1, tonext: 1 };
      module.exports = function linkTraces(gd, plotinfo, cdscatter) {
        var trace, i, group, prevtrace, groupIndex;
        var groupIndices = {};
        var needsSort = false;
        var prevGroupIndex = -1;
        var nextGroupIndex = 0;
        var prevUnstackedGroupIndex = -1;
        for (i = 0; i < cdscatter.length; i++) {
          trace = cdscatter[i][0].trace;
          group = trace.stackgroup || "";
          if (group) {
            if (group in groupIndices) {
              groupIndex = groupIndices[group];
            } else {
              groupIndex = groupIndices[group] = nextGroupIndex;
              nextGroupIndex++;
            }
          } else if (trace.fill in LINKEDFILLS && prevUnstackedGroupIndex >= 0) {
            groupIndex = prevUnstackedGroupIndex;
          } else {
            groupIndex = prevUnstackedGroupIndex = nextGroupIndex;
            nextGroupIndex++;
          }
          if (groupIndex < prevGroupIndex) needsSort = true;
          trace._groupIndex = prevGroupIndex = groupIndex;
        }
        var cdscatterSorted = cdscatter.slice();
        if (needsSort) {
          cdscatterSorted.sort(function(a, b) {
            var traceA = a[0].trace;
            var traceB = b[0].trace;
            return traceA._groupIndex - traceB._groupIndex || traceA.index - traceB.index;
          });
        }
        var prevtraces = {};
        for (i = 0; i < cdscatterSorted.length; i++) {
          trace = cdscatterSorted[i][0].trace;
          group = trace.stackgroup || "";
          if (trace.visible === true) {
            trace._nexttrace = null;
            if (trace.fill in LINKEDFILLS) {
              prevtrace = prevtraces[group];
              trace._prevtrace = prevtrace || null;
              if (prevtrace) {
                prevtrace._nexttrace = trace;
              }
            }
            trace._ownfill = trace.fill && (trace.fill.substr(0, 6) === "tozero" || trace.fill === "toself" || trace.fill.substr(0, 2) === "to" && !trace._prevtrace);
            prevtraces[group] = trace;
          } else {
            trace._prevtrace = trace._nexttrace = trace._ownfill = null;
          }
        }
        return cdscatterSorted;
      };
    }
  });

  // src/traces/scatter/plot.js
  var require_plot = __commonJS({
    "src/traces/scatter/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var ensureSingle = Lib.ensureSingle;
      var identity = Lib.identity;
      var Drawing = require_drawing();
      var subTypes = require_subtypes();
      var linePoints = require_line_points();
      var linkTraces = require_link_traces();
      var polygonTester = require_polygon().tester;
      module.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {
        var join, onComplete;
        var isFullReplot = !transitionOpts;
        var hasTransition = !!transitionOpts && transitionOpts.duration > 0;
        var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);
        join = scatterLayer.selectAll("g.trace").data(cdscatterSorted, function(d) {
          return d[0].trace.uid;
        });
        join.enter().append("g").attr("class", function(d) {
          return "trace scatter trace" + d[0].trace.uid;
        }).style("stroke-miterlimit", 2);
        join.order();
        createFills(gd, join, plotinfo);
        if (hasTransition) {
          if (makeOnCompleteCallback) {
            onComplete = makeOnCompleteCallback();
          }
          var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each("end", function() {
            onComplete && onComplete();
          }).each("interrupt", function() {
            onComplete && onComplete();
          });
          transition.each(function() {
            scatterLayer.selectAll("g.trace").each(function(d, i) {
              plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);
            });
          });
        } else {
          join.each(function(d, i) {
            plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);
          });
        }
        if (isFullReplot) {
          join.exit().remove();
        }
        scatterLayer.selectAll("path:not([d])").remove();
      };
      function createFills(gd, traceJoin, plotinfo) {
        traceJoin.each(function(d) {
          var fills = ensureSingle(d3.select(this), "g", "fills");
          Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);
          var trace = d[0].trace;
          var fillData = [];
          if (trace._ownfill) fillData.push("_ownFill");
          if (trace._nexttrace) fillData.push("_nextFill");
          var fillJoin = fills.selectAll("g").data(fillData, identity);
          fillJoin.enter().append("g");
          fillJoin.exit().each(function(d2) {
            trace[d2] = null;
          }).remove();
          fillJoin.order().each(function(d2) {
            trace[d2] = ensureSingle(d3.select(this), "path", "js-fill");
          });
        });
      }
      function plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {
        var isStatic = gd._context.staticPlot;
        var i;
        selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);
        var hasTransition = !!transitionOpts && transitionOpts.duration > 0;
        function transition(selection) {
          return hasTransition ? selection.transition() : selection;
        }
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var trace = cdscatter[0].trace;
        var line = trace.line;
        var tr = d3.select(element);
        var errorBarGroup = ensureSingle(tr, "g", "errorbars");
        var lines = ensureSingle(tr, "g", "lines");
        var points = ensureSingle(tr, "g", "points");
        var text = ensureSingle(tr, "g", "text");
        Registry.getComponentMethod("errorbars", "plot")(gd, errorBarGroup, plotinfo, transitionOpts);
        if (trace.visible !== true) return;
        transition(tr).style("opacity", trace.opacity);
        var ownFillEl3, tonext;
        var ownFillDir = trace.fill.charAt(trace.fill.length - 1);
        if (ownFillDir !== "x" && ownFillDir !== "y") ownFillDir = "";
        var fillAxisIndex, fillAxisZero;
        if (ownFillDir === "y") {
          fillAxisIndex = 1;
          fillAxisZero = ya.c2p(0, true);
        } else if (ownFillDir === "x") {
          fillAxisIndex = 0;
          fillAxisZero = xa.c2p(0, true);
        }
        cdscatter[0][plotinfo.isRangePlot ? "nodeRangePlot3" : "node3"] = tr;
        var prevRevpath = "";
        var prevPolygons = [];
        var prevtrace = trace._prevtrace;
        var prevFillsegments = null;
        var prevFillElement = null;
        if (prevtrace) {
          prevRevpath = prevtrace._prevRevpath || "";
          tonext = prevtrace._nextFill;
          prevPolygons = prevtrace._ownPolygons;
          prevFillsegments = prevtrace._fillsegments;
          prevFillElement = prevtrace._fillElement;
        }
        var thispath;
        var thisrevpath;
        var fullpath = "";
        var revpath = "";
        var pathfn, revpathbase, revpathfn;
        var pt0, lastSegment, pt1;
        var thisPolygons = [];
        trace._polygons = [];
        var fillsegments = [];
        var segments = [];
        var makeUpdate = Lib.noop;
        ownFillEl3 = trace._ownFill;
        if (subTypes.hasLines(trace) || trace.fill !== "none") {
          if (tonext) {
            tonext.datum(cdscatter);
          }
          if (["hv", "vh", "hvh", "vhv"].indexOf(line.shape) !== -1) {
            pathfn = Drawing.steps(line.shape);
            revpathbase = Drawing.steps(
              line.shape.split("").reverse().join("")
            );
          } else if (line.shape === "spline") {
            pathfn = revpathbase = function(pts2) {
              var pLast = pts2[pts2.length - 1];
              if (pts2.length > 1 && pts2[0][0] === pLast[0] && pts2[0][1] === pLast[1]) {
                return Drawing.smoothclosed(pts2.slice(1), line.smoothing);
              } else {
                return Drawing.smoothopen(pts2, line.smoothing);
              }
            };
          } else {
            pathfn = revpathbase = function(pts2) {
              return "M" + pts2.join("L");
            };
          }
          revpathfn = function(pts2) {
            return revpathbase(pts2.reverse());
          };
          segments = linePoints(cdscatter, {
            xaxis: xa,
            yaxis: ya,
            trace,
            connectGaps: trace.connectgaps,
            baseTolerance: Math.max(line.width || 1, 3) / 4,
            shape: line.shape,
            backoff: line.backoff,
            simplify: line.simplify,
            fill: trace.fill
          });
          fillsegments = new Array(segments.length);
          var fillsegmentCount = 0;
          for (i = 0; i < segments.length; i++) {
            var curpoints;
            var pts = segments[i];
            if (!curpoints || !ownFillDir) {
              curpoints = pts.slice();
              fillsegments[fillsegmentCount] = curpoints;
              fillsegmentCount++;
            } else {
              curpoints.push.apply(curpoints, pts);
            }
          }
          trace._fillElement = null;
          trace._fillExclusionElement = prevFillElement;
          trace._fillsegments = fillsegments.slice(0, fillsegmentCount);
          fillsegments = trace._fillsegments;
          if (segments.length) {
            pt0 = segments[0][0].slice();
            lastSegment = segments[segments.length - 1];
            pt1 = lastSegment[lastSegment.length - 1].slice();
          }
          makeUpdate = function(isEnter) {
            return function(pts2) {
              thispath = pathfn(pts2);
              thisrevpath = revpathfn(pts2);
              if (!fullpath) {
                fullpath = thispath;
                revpath = thisrevpath;
              } else if (ownFillDir) {
                fullpath += "L" + thispath.substr(1);
                revpath = thisrevpath + ("L" + revpath.substr(1));
              } else {
                fullpath += "Z" + thispath;
                revpath = thisrevpath + "Z" + revpath;
              }
              if (subTypes.hasLines(trace)) {
                var el = d3.select(this);
                el.datum(cdscatter);
                if (isEnter) {
                  transition(el.style("opacity", 0).attr("d", thispath).call(Drawing.lineGroupStyle)).style("opacity", 1);
                } else {
                  var sel = transition(el);
                  sel.attr("d", thispath);
                  Drawing.singleLineStyle(cdscatter, sel);
                }
              }
            };
          };
        }
        var lineJoin = lines.selectAll(".js-line").data(segments);
        transition(lineJoin.exit()).style("opacity", 0).remove();
        lineJoin.each(makeUpdate(false));
        lineJoin.enter().append("path").classed("js-line", true).style("vector-effect", isStatic ? "none" : "non-scaling-stroke").call(Drawing.lineGroupStyle).each(makeUpdate(true));
        Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);
        function clearFill(selection) {
          transition(selection).attr("d", "M0,0Z");
        }
        var makeSelfPolygons = function() {
          var polygons = new Array(fillsegments.length);
          for (i = 0; i < fillsegments.length; i++) {
            polygons[i] = polygonTester(fillsegments[i]);
          }
          return polygons;
        };
        var makePolygonsToPrevious = function(prevFillsegments2) {
          var polygons, i2;
          if (!prevFillsegments2 || prevFillsegments2.length === 0) {
            polygons = new Array(fillsegments.length);
            for (i2 = 0; i2 < fillsegments.length; i2++) {
              var pt02 = fillsegments[i2][0].slice();
              var pt12 = fillsegments[i2][fillsegments[i2].length - 1].slice();
              pt02[fillAxisIndex] = pt12[fillAxisIndex] = fillAxisZero;
              var zeropoints = [pt12, pt02];
              var polypoints = zeropoints.concat(fillsegments[i2]);
              polygons[i2] = polygonTester(polypoints);
            }
          } else {
            polygons = new Array(prevFillsegments2.length - 1 + fillsegments.length);
            for (i2 = 0; i2 < prevFillsegments2.length - 1; i2++) {
              polygons[i2] = polygonTester(prevFillsegments2[i2]);
            }
            var reversedPrevFillsegment = prevFillsegments2[prevFillsegments2.length - 1].slice();
            reversedPrevFillsegment.reverse();
            for (i2 = 0; i2 < fillsegments.length; i2++) {
              polygons[prevFillsegments2.length - 1 + i2] = polygonTester(fillsegments[i2].concat(reversedPrevFillsegment));
            }
          }
          return polygons;
        };
        if (segments.length) {
          if (ownFillEl3) {
            ownFillEl3.datum(cdscatter);
            if (pt0 && pt1) {
              if (ownFillDir) {
                pt0[fillAxisIndex] = pt1[fillAxisIndex] = fillAxisZero;
                transition(ownFillEl3).attr("d", "M" + pt1 + "L" + pt0 + "L" + fullpath.substr(1)).call(Drawing.singleFillStyle, gd);
                thisPolygons = makePolygonsToPrevious(null);
              } else {
                transition(ownFillEl3).attr("d", fullpath + "Z").call(Drawing.singleFillStyle, gd);
                thisPolygons = makeSelfPolygons();
              }
            }
            trace._polygons = thisPolygons;
            trace._fillElement = ownFillEl3;
          } else if (tonext) {
            if (trace.fill.substr(0, 6) === "tonext" && fullpath && prevRevpath) {
              if (trace.fill === "tonext") {
                transition(tonext).attr("d", fullpath + "Z" + prevRevpath + "Z").call(Drawing.singleFillStyle, gd);
                thisPolygons = makeSelfPolygons();
                trace._polygons = thisPolygons.concat(prevPolygons);
              } else {
                transition(tonext).attr("d", fullpath + "L" + prevRevpath.substr(1) + "Z").call(Drawing.singleFillStyle, gd);
                thisPolygons = makePolygonsToPrevious(prevFillsegments);
                trace._polygons = thisPolygons;
              }
              trace._fillElement = tonext;
            } else {
              clearFill(tonext);
            }
          }
          trace._prevRevpath = revpath;
        } else {
          if (ownFillEl3) clearFill(ownFillEl3);
          else if (tonext) clearFill(tonext);
          trace._prevRevpath = null;
        }
        trace._ownPolygons = thisPolygons;
        function visFilter(d) {
          return d.filter(function(v) {
            return !v.gap && v.vis;
          });
        }
        function visFilterWithGaps(d) {
          return d.filter(function(v) {
            return v.vis;
          });
        }
        function gapFilter(d) {
          return d.filter(function(v) {
            return !v.gap;
          });
        }
        function keyFunc(d) {
          return d.id;
        }
        function getKeyFunc(trace2) {
          if (trace2.ids) {
            return keyFunc;
          }
        }
        function hideFilter() {
          return false;
        }
        function makePoints(points2, text2, cdscatter2) {
          var join, selection, hasNode;
          var trace2 = cdscatter2[0].trace;
          var showMarkers = subTypes.hasMarkers(trace2);
          var showText = subTypes.hasText(trace2);
          var keyFunc2 = getKeyFunc(trace2);
          var markerFilter = hideFilter;
          var textFilter = hideFilter;
          if (showMarkers || showText) {
            var showFilter = identity;
            var stackGroup = trace2.stackgroup;
            var isInferZero = stackGroup && gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === "infer zero";
            if (trace2.marker.maxdisplayed || trace2._needsCull) {
              showFilter = isInferZero ? visFilterWithGaps : visFilter;
            } else if (stackGroup && !isInferZero) {
              showFilter = gapFilter;
            }
            if (showMarkers) markerFilter = showFilter;
            if (showText) textFilter = showFilter;
          }
          selection = points2.selectAll("path.point");
          join = selection.data(markerFilter, keyFunc2);
          var enter = join.enter().append("path").classed("point", true);
          if (hasTransition) {
            enter.call(Drawing.pointStyle, trace2, gd).call(Drawing.translatePoints, xa, ya).style("opacity", 0).transition().style("opacity", 1);
          }
          join.order();
          var styleFns;
          if (showMarkers) {
            styleFns = Drawing.makePointStyleFns(trace2);
          }
          join.each(function(d) {
            var el = d3.select(this);
            var sel = transition(el);
            hasNode = Drawing.translatePoint(d, sel, xa, ya);
            if (hasNode) {
              Drawing.singlePointStyle(d, sel, trace2, styleFns, gd);
              if (plotinfo.layerClipId) {
                Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace2.xcalendar, trace2.ycalendar);
              }
              if (trace2.customdata) {
                el.classed("plotly-customdata", d.data !== null && d.data !== void 0);
              }
            } else {
              sel.remove();
            }
          });
          if (hasTransition) {
            join.exit().transition().style("opacity", 0).remove();
          } else {
            join.exit().remove();
          }
          selection = text2.selectAll("g");
          join = selection.data(textFilter, keyFunc2);
          join.enter().append("g").classed("textpoint", true).append("text");
          join.order();
          join.each(function(d) {
            var g = d3.select(this);
            var sel = transition(g.select("text"));
            hasNode = Drawing.translatePoint(d, sel, xa, ya);
            if (hasNode) {
              if (plotinfo.layerClipId) {
                Drawing.hideOutsideRangePoint(d, g, xa, ya, trace2.xcalendar, trace2.ycalendar);
              }
            } else {
              g.remove();
            }
          });
          join.selectAll("text").call(Drawing.textPointStyle, trace2, gd).each(function(d) {
            var x = xa.c2p(d.x);
            var y = ya.c2p(d.y);
            d3.select(this).selectAll("tspan.line").each(function() {
              transition(d3.select(this)).attr({ x, y });
            });
          });
          join.exit().remove();
        }
        points.datum(cdscatter);
        text.datum(cdscatter);
        makePoints(points, text, cdscatter);
        var hasClipOnAxisFalse = trace.cliponaxis === false;
        var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;
        Drawing.setClipUrl(points, clipUrl, gd);
        Drawing.setClipUrl(text, clipUrl, gd);
      }
      function selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));
        var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));
        var trace = cdscatter[0].trace;
        if (!subTypes.hasMarkers(trace)) return;
        var mnum = trace.marker.maxdisplayed;
        if (mnum === 0) return;
        var cd = cdscatter.filter(function(v) {
          return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];
        });
        var inc = Math.ceil(cd.length / mnum);
        var tnum = 0;
        cdscatterAll.forEach(function(cdj, j) {
          var tracei = cdj[0].trace;
          if (subTypes.hasMarkers(tracei) && tracei.marker.maxdisplayed > 0 && j < idx) {
            tnum++;
          }
        });
        var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1);
        cdscatter.forEach(function(v) {
          delete v.vis;
        });
        cd.forEach(function(v, i) {
          if (Math.round((i + i0) % inc) === 0) v.vis = true;
        });
      }
    }
  });

  // src/traces/scatter/marker_colorbar.js
  var require_marker_colorbar = __commonJS({
    "src/traces/scatter/marker_colorbar.js"(exports, module) {
      "use strict";
      module.exports = {
        container: "marker",
        min: "cmin",
        max: "cmax"
      };
    }
  });

  // src/traces/scatter/format_labels.js
  var require_format_labels = __commonJS({
    "src/traces/scatter/format_labels.js"(exports, module) {
      "use strict";
      var Axes = require_axes();
      module.exports = function formatLabels(cdi, trace, fullLayout) {
        var labels = {};
        var mockGd = { _fullLayout: fullLayout };
        var xa = Axes.getFromTrace(mockGd, trace, "x");
        var ya = Axes.getFromTrace(mockGd, trace, "y");
        var x = cdi.orig_x;
        if (x === void 0) x = cdi.x;
        var y = cdi.orig_y;
        if (y === void 0) y = cdi.y;
        labels.xLabel = Axes.tickText(xa, xa.c2l(x), true).text;
        labels.yLabel = Axes.tickText(ya, ya.c2l(y), true).text;
        return labels;
      };
    }
  });

  // src/traces/scatter/style.js
  var require_style2 = __commonJS({
    "src/traces/scatter/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Drawing = require_drawing();
      var Registry = require_registry();
      function style(gd) {
        var s = d3.select(gd).selectAll("g.trace.scatter");
        s.style("opacity", function(d) {
          return d[0].trace.opacity;
        });
        s.selectAll("g.points").each(function(d) {
          var sel = d3.select(this);
          var trace = d.trace || d[0].trace;
          stylePoints(sel, trace, gd);
        });
        s.selectAll("g.text").each(function(d) {
          var sel = d3.select(this);
          var trace = d.trace || d[0].trace;
          styleText(sel, trace, gd);
        });
        s.selectAll("g.trace path.js-line").call(Drawing.lineGroupStyle);
        s.selectAll("g.trace path.js-fill").call(Drawing.fillGroupStyle, gd, false);
        Registry.getComponentMethod("errorbars", "style")(s);
      }
      function stylePoints(sel, trace, gd) {
        Drawing.pointStyle(sel.selectAll("path.point"), trace, gd);
      }
      function styleText(sel, trace, gd) {
        Drawing.textPointStyle(sel.selectAll("text"), trace, gd);
      }
      function styleOnSelect(gd, cd, sel) {
        var trace = cd[0].trace;
        if (trace.selectedpoints) {
          Drawing.selectedPointStyle(sel.selectAll("path.point"), trace);
          Drawing.selectedTextStyle(sel.selectAll("text"), trace);
        } else {
          stylePoints(sel, trace, gd);
          styleText(sel, trace, gd);
        }
      }
      module.exports = {
        style,
        stylePoints,
        styleText,
        styleOnSelect
      };
    }
  });

  // src/traces/scatter/get_trace_color.js
  var require_get_trace_color = __commonJS({
    "src/traces/scatter/get_trace_color.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var subtypes = require_subtypes();
      module.exports = function getTraceColor(trace, di) {
        var lc, tc;
        if (trace.mode === "lines") {
          lc = trace.line.color;
          return lc && Color.opacity(lc) ? lc : trace.fillcolor;
        } else if (trace.mode === "none") {
          return trace.fill ? trace.fillcolor : "";
        } else {
          var mc = di.mcc || (trace.marker || {}).color;
          var mlc = di.mlcc || ((trace.marker || {}).line || {}).color;
          tc = mc && Color.opacity(mc) ? mc : mlc && Color.opacity(mlc) && (di.mlw || ((trace.marker || {}).line || {}).width) ? mlc : "";
          if (tc) {
            if (Color.opacity(tc) < 0.3) {
              return Color.addOpacity(tc, 0.3);
            } else return tc;
          } else {
            lc = (trace.line || {}).color;
            return lc && Color.opacity(lc) && subtypes.hasLines(trace) && trace.line.width ? lc : trace.fillcolor;
          }
        }
      };
    }
  });

  // src/traces/scatter/hover.js
  var require_hover2 = __commonJS({
    "src/traces/scatter/hover.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Fx = require_fx();
      var Registry = require_registry();
      var getTraceColor = require_get_trace_color();
      var Color = require_color();
      var fillText = Lib.fillText;
      module.exports = function hoverPoints(pointData, xval, yval, hovermode) {
        var cd = pointData.cd;
        var trace = cd[0].trace;
        var xa = pointData.xa;
        var ya = pointData.ya;
        var xpx = xa.c2p(xval);
        var ypx = ya.c2p(yval);
        var pt = [xpx, ypx];
        var hoveron = trace.hoveron || "";
        var minRad = trace.mode.indexOf("markers") !== -1 ? 3 : 0.5;
        var xPeriod = !!trace.xperiodalignment;
        var yPeriod = !!trace.yperiodalignment;
        if (hoveron.indexOf("points") !== -1) {
          var dx = function(di2) {
            if (xPeriod) {
              var x0 = xa.c2p(di2.xStart);
              var x1 = xa.c2p(di2.xEnd);
              return xpx >= Math.min(x0, x1) && xpx <= Math.max(x0, x1) ? 0 : Infinity;
            }
            var rad2 = Math.max(3, di2.mrc || 0);
            var kink = 1 - 1 / rad2;
            var dxRaw = Math.abs(xa.c2p(di2.x) - xpx);
            return dxRaw < rad2 ? kink * dxRaw / rad2 : dxRaw - rad2 + kink;
          };
          var dy = function(di2) {
            if (yPeriod) {
              var y0 = ya.c2p(di2.yStart);
              var y1 = ya.c2p(di2.yEnd);
              return ypx >= Math.min(y0, y1) && ypx <= Math.max(y0, y1) ? 0 : Infinity;
            }
            var rad2 = Math.max(3, di2.mrc || 0);
            var kink = 1 - 1 / rad2;
            var dyRaw = Math.abs(ya.c2p(di2.y) - ypx);
            return dyRaw < rad2 ? kink * dyRaw / rad2 : dyRaw - rad2 + kink;
          };
          var dxy = function(di2) {
            var rad2 = Math.max(minRad, di2.mrc || 0);
            var dx2 = xa.c2p(di2.x) - xpx;
            var dy2 = ya.c2p(di2.y) - ypx;
            return Math.max(Math.sqrt(dx2 * dx2 + dy2 * dy2) - rad2, 1 - minRad / rad2);
          };
          var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);
          Fx.getClosest(cd, distfn, pointData);
          if (pointData.index !== false) {
            var di = cd[pointData.index];
            var xc = xa.c2p(di.x, true);
            var yc = ya.c2p(di.y, true);
            var rad = di.mrc || 1;
            pointData.index = di.i;
            var orientation = cd[0].t.orientation;
            var sizeVal = orientation && (di.sNorm || di.s);
            var xLabelVal = orientation === "h" ? sizeVal : di.orig_x !== void 0 ? di.orig_x : di.x;
            var yLabelVal = orientation === "v" ? sizeVal : di.orig_y !== void 0 ? di.orig_y : di.y;
            Lib.extendFlat(pointData, {
              color: getTraceColor(trace, di),
              x0: xc - rad,
              x1: xc + rad,
              xLabelVal,
              y0: yc - rad,
              y1: yc + rad,
              yLabelVal,
              spikeDistance: dxy(di),
              hovertemplate: trace.hovertemplate
            });
            fillText(di, trace, pointData);
            Registry.getComponentMethod("errorbars", "hoverInfo")(di, trace, pointData);
            return [pointData];
          }
        }
        function isHoverPointInFillElement(el) {
          if (!el) {
            return false;
          }
          var svgElement = el.node();
          try {
            var domPoint = new DOMPoint(pt[0], pt[1]);
            return svgElement.isPointInFill(domPoint);
          } catch (TypeError2) {
            var svgPoint = svgElement.ownerSVGElement.createSVGPoint();
            svgPoint.x = pt[0];
            svgPoint.y = pt[1];
            return svgElement.isPointInFill(svgPoint);
          }
        }
        function getHoverLabelPosition(polygons) {
          var i;
          var polygonsIn = [];
          var xmin = Infinity;
          var xmax = -Infinity;
          var ymin = Infinity;
          var ymax = -Infinity;
          var yPos;
          for (i = 0; i < polygons.length; i++) {
            var polygon = polygons[i];
            if (polygon.contains(pt)) {
              polygonsIn.push(polygon);
              ymin = Math.min(ymin, polygon.ymin);
              ymax = Math.max(ymax, polygon.ymax);
            }
          }
          if (polygonsIn.length === 0) {
            return null;
          }
          ymin = Math.max(ymin, 0);
          ymax = Math.min(ymax, ya._length);
          yPos = (ymin + ymax) / 2;
          var j, pts, xAtYPos, x0, x1, y0, y1;
          for (i = 0; i < polygonsIn.length; i++) {
            pts = polygonsIn[i].pts;
            for (j = 1; j < pts.length; j++) {
              y0 = pts[j - 1][1];
              y1 = pts[j][1];
              if (y0 > yPos !== y1 >= yPos) {
                x0 = pts[j - 1][0];
                x1 = pts[j][0];
                if (y1 - y0) {
                  xAtYPos = x0 + (x1 - x0) * (yPos - y0) / (y1 - y0);
                  xmin = Math.min(xmin, xAtYPos);
                  xmax = Math.max(xmax, xAtYPos);
                }
              }
            }
          }
          xmin = Math.max(xmin, 0);
          xmax = Math.min(xmax, xa._length);
          return {
            x0: xmin,
            x1: xmax,
            y0: yPos,
            y1: yPos
          };
        }
        if (hoveron.indexOf("fills") !== -1 && trace._fillElement) {
          var inside = isHoverPointInFillElement(trace._fillElement) && !isHoverPointInFillElement(trace._fillExclusionElement);
          if (inside) {
            var hoverLabelCoords = getHoverLabelPosition(trace._polygons);
            if (hoverLabelCoords === null) {
              hoverLabelCoords = {
                x0: pt[0],
                x1: pt[0],
                y0: pt[1],
                y1: pt[1]
              };
            }
            var color = Color.defaultLine;
            if (Color.opacity(trace.fillcolor)) color = trace.fillcolor;
            else if (Color.opacity((trace.line || {}).color)) {
              color = trace.line.color;
            }
            Lib.extendFlat(pointData, {
              // never let a 2D override 1D type as closest point
              // also: no spikeDistance, it's not allowed for fills
              distance: pointData.maxHoverDistance,
              x0: hoverLabelCoords.x0,
              x1: hoverLabelCoords.x1,
              y0: hoverLabelCoords.y0,
              y1: hoverLabelCoords.y1,
              color,
              hovertemplate: false
            });
            delete pointData.index;
            if (trace.text && !Lib.isArrayOrTypedArray(trace.text)) {
              pointData.text = String(trace.text);
            } else pointData.text = trace.name;
            return [pointData];
          }
        }
      };
    }
  });

  // src/traces/scatter/select.js
  var require_select2 = __commonJS({
    "src/traces/scatter/select.js"(exports, module) {
      "use strict";
      var subtypes = require_subtypes();
      module.exports = function selectPoints(searchInfo, selectionTester) {
        var cd = searchInfo.cd;
        var xa = searchInfo.xaxis;
        var ya = searchInfo.yaxis;
        var selection = [];
        var trace = cd[0].trace;
        var i;
        var di;
        var x;
        var y;
        var hasOnlyLines = !subtypes.hasMarkers(trace) && !subtypes.hasText(trace);
        if (hasOnlyLines) return [];
        if (selectionTester === false) {
          for (i = 0; i < cd.length; i++) {
            cd[i].selected = 0;
          }
        } else {
          for (i = 0; i < cd.length; i++) {
            di = cd[i];
            x = xa.c2p(di.x);
            y = ya.c2p(di.y);
            if (di.i !== null && selectionTester.contains([x, y], false, i, searchInfo)) {
              selection.push({
                pointNumber: di.i,
                x: xa.c2d(di.x),
                y: ya.c2d(di.y)
              });
              di.selected = 1;
            } else {
              di.selected = 0;
            }
          }
        }
        return selection;
      };
    }
  });

  // src/plots/cartesian/attributes.js
  var require_attributes14 = __commonJS({
    "src/plots/cartesian/attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        xaxis: {
          valType: "subplotid",
          dflt: "x",
          editType: "calc+clearAxisTypes"
        },
        yaxis: {
          valType: "subplotid",
          dflt: "y",
          editType: "calc+clearAxisTypes"
        }
      };
    }
  });

  // src/plots/cartesian/type_defaults.js
  var require_type_defaults = __commonJS({
    "src/plots/cartesian/type_defaults.js"(exports, module) {
      "use strict";
      var traceIs = require_registry().traceIs;
      var autoType = require_axis_autotype();
      module.exports = function handleTypeDefaults(containerIn, containerOut, coerce, options) {
        coerce("autotypenumbers", options.autotypenumbersDflt);
        var axType = coerce("type", (options.splomStash || {}).type);
        if (axType === "-") {
          setAutoType(containerOut, options.data);
          if (containerOut.type === "-") {
            containerOut.type = "linear";
          } else {
            containerIn.type = containerOut.type;
          }
        }
      };
      function setAutoType(ax, data) {
        if (ax.type !== "-") return;
        var id = ax._id;
        var axLetter = id.charAt(0);
        var i;
        if (id.indexOf("scene") !== -1) id = axLetter;
        var d0 = getFirstNonEmptyTrace(data, id, axLetter);
        if (!d0) return;
        if (d0.type === "histogram" && axLetter === { v: "y", h: "x" }[d0.orientation || "v"]) {
          ax.type = "linear";
          return;
        }
        var calAttr = axLetter + "calendar";
        var calendar = d0[calAttr];
        var opts = { noMultiCategory: !traceIs(d0, "cartesian") || traceIs(d0, "noMultiCategory") };
        if (d0.type === "box" && d0._hasPreCompStats && axLetter === { h: "x", v: "y" }[d0.orientation || "v"]) {
          opts.noMultiCategory = true;
        }
        opts.autotypenumbers = ax.autotypenumbers;
        if (isBoxWithoutPositionCoords(d0, axLetter)) {
          var posLetter = getBoxPosLetter(d0);
          var boxPositions = [];
          for (i = 0; i < data.length; i++) {
            var trace = data[i];
            if (!traceIs(trace, "box-violin") || (trace[axLetter + "axis"] || axLetter) !== id) continue;
            if (trace[posLetter] !== void 0) boxPositions.push(trace[posLetter][0]);
            else if (trace.name !== void 0) boxPositions.push(trace.name);
            else boxPositions.push("text");
            if (trace[calAttr] !== calendar) calendar = void 0;
          }
          ax.type = autoType(boxPositions, calendar, opts);
        } else if (d0.type === "splom") {
          var dimensions = d0.dimensions;
          var dim = dimensions[d0._axesDim[id]];
          if (dim.visible) ax.type = autoType(dim.values, calendar, opts);
        } else {
          ax.type = autoType(d0[axLetter] || [d0[axLetter + "0"]], calendar, opts);
        }
      }
      function getFirstNonEmptyTrace(data, id, axLetter) {
        for (var i = 0; i < data.length; i++) {
          var trace = data[i];
          if (trace.type === "splom" && trace._length > 0 && (trace["_" + axLetter + "axes"] || {})[id]) {
            return trace;
          }
          if ((trace[axLetter + "axis"] || axLetter) === id) {
            if (isBoxWithoutPositionCoords(trace, axLetter)) {
              return trace;
            } else if ((trace[axLetter] || []).length || trace[axLetter + "0"]) {
              return trace;
            }
          }
        }
      }
      function getBoxPosLetter(trace) {
        return { v: "x", h: "y" }[trace.orientation || "v"];
      }
      function isBoxWithoutPositionCoords(trace, axLetter) {
        var posLetter = getBoxPosLetter(trace);
        var isBox = traceIs(trace, "box-violin");
        var isCandlestick = traceIs(trace._fullInput || {}, "candlestick");
        return isBox && !isCandlestick && axLetter === posLetter && trace[posLetter] === void 0 && trace[posLetter + "0"] === void 0;
      }
    }
  });

  // src/plots/cartesian/category_order_defaults.js
  var require_category_order_defaults = __commonJS({
    "src/plots/cartesian/category_order_defaults.js"(exports, module) {
      "use strict";
      var isTypedArraySpec = require_array().isTypedArraySpec;
      function findCategories(ax, opts) {
        var dataAttr = opts.dataAttr || ax._id.charAt(0);
        var lookup = {};
        var axData;
        var i, j;
        if (opts.axData) {
          axData = opts.axData;
        } else {
          axData = [];
          for (i = 0; i < opts.data.length; i++) {
            var trace = opts.data[i];
            if (trace[dataAttr + "axis"] === ax._id) {
              axData.push(trace);
            }
          }
        }
        for (i = 0; i < axData.length; i++) {
          var vals = axData[i][dataAttr];
          for (j = 0; j < vals.length; j++) {
            var v = vals[j];
            if (v !== null && v !== void 0) {
              lookup[v] = 1;
            }
          }
        }
        return Object.keys(lookup);
      }
      module.exports = function handleCategoryOrderDefaults(containerIn, containerOut, coerce, opts) {
        if (containerOut.type !== "category") return;
        var arrayIn = containerIn.categoryarray;
        var isValidArray = Array.isArray(arrayIn) && arrayIn.length > 0 || isTypedArraySpec(arrayIn);
        var orderDefault;
        if (isValidArray) orderDefault = "array";
        var order = coerce("categoryorder", orderDefault);
        var array;
        if (order === "array") {
          array = coerce("categoryarray");
        }
        if (!isValidArray && order === "array") {
          order = containerOut.categoryorder = "trace";
        }
        if (order === "trace") {
          containerOut._initialCategories = [];
        } else if (order === "array") {
          containerOut._initialCategories = array.slice();
        } else {
          array = findCategories(containerOut, opts).sort();
          if (order === "category ascending") {
            containerOut._initialCategories = array;
          } else if (order === "category descending") {
            containerOut._initialCategories = array.reverse();
          }
        }
      };
    }
  });

  // src/plots/cartesian/line_grid_defaults.js
  var require_line_grid_defaults = __commonJS({
    "src/plots/cartesian/line_grid_defaults.js"(exports, module) {
      "use strict";
      var colorMix = require_tinycolor().mix;
      var colorAttrs = require_attributes3();
      var Lib = require_lib();
      module.exports = function handleLineGridDefaults(containerIn, containerOut, coerce, opts) {
        opts = opts || {};
        var dfltColor = opts.dfltColor;
        function coerce2(attr, dflt) {
          return Lib.coerce2(containerIn, containerOut, opts.attributes, attr, dflt);
        }
        var lineColor = coerce2("linecolor", dfltColor);
        var lineWidth = coerce2("linewidth");
        var showLine = coerce("showline", opts.showLine || !!lineColor || !!lineWidth);
        if (!showLine) {
          delete containerOut.linecolor;
          delete containerOut.linewidth;
        }
        var gridColorDflt = colorMix(dfltColor, opts.bgColor, opts.blend || colorAttrs.lightFraction).toRgbString();
        var gridColor = coerce2("gridcolor", gridColorDflt);
        var gridWidth = coerce2("gridwidth");
        var gridDash = coerce2("griddash");
        var showGridLines = coerce(
          "showgrid",
          opts.showGrid || !!gridColor || !!gridWidth || !!gridDash
        );
        if (!showGridLines) {
          delete containerOut.gridcolor;
          delete containerOut.gridwidth;
          delete containerOut.griddash;
        }
        if (opts.hasMinor) {
          var minorGridColorDflt = colorMix(containerOut.gridcolor, opts.bgColor, 67).toRgbString();
          var minorGridColor = coerce2("minor.gridcolor", minorGridColorDflt);
          var minorGridWidth = coerce2("minor.gridwidth", containerOut.gridwidth || 1);
          var minorGridDash = coerce2("minor.griddash", containerOut.griddash || "solid");
          var minorShowGridLines = coerce(
            "minor.showgrid",
            !!minorGridColor || !!minorGridWidth || !!minorGridDash
          );
          if (!minorShowGridLines) {
            delete containerOut.minor.gridcolor;
            delete containerOut.minor.gridwidth;
            delete containerOut.minor.griddash;
          }
        }
        if (!opts.noZeroLine) {
          var zeroLineColor = coerce2("zerolinecolor", dfltColor);
          var zeroLineWidth = coerce2("zerolinewidth");
          var showZeroLine = coerce("zeroline", opts.showGrid || !!zeroLineColor || !!zeroLineWidth);
          if (!showZeroLine) {
            delete containerOut.zerolinecolor;
            delete containerOut.zerolinewidth;
          }
        }
      };
    }
  });

  // src/plots/cartesian/axis_defaults.js
  var require_axis_defaults = __commonJS({
    "src/plots/cartesian/axis_defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Registry = require_registry();
      var Lib = require_lib();
      var Template = require_plot_template();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var layoutAttributes = require_layout_attributes4();
      var handleTickValueDefaults = require_tick_value_defaults();
      var handleTickMarkDefaults = require_tick_mark_defaults();
      var handleTickLabelDefaults = require_tick_label_defaults();
      var handlePrefixSuffixDefaults = require_prefix_suffix_defaults();
      var handleCategoryOrderDefaults = require_category_order_defaults();
      var handleLineGridDefaults = require_line_grid_defaults();
      var handleRangeDefaults = require_range_defaults();
      var setConvert = require_set_convert();
      var DAY_OF_WEEK = require_constants2().WEEKDAY_PATTERN;
      var HOUR = require_constants2().HOUR_PATTERN;
      module.exports = function handleAxisDefaults(containerIn, containerOut, coerce, options, layoutOut) {
        var letter = options.letter;
        var font = options.font || {};
        var splomStash = options.splomStash || {};
        var visible = coerce("visible", !options.visibleDflt);
        var axTemplate = containerOut._template || {};
        var axType = containerOut.type || axTemplate.type || "-";
        var ticklabelmode;
        if (axType === "date") {
          var handleCalendarDefaults = Registry.getComponentMethod("calendars", "handleDefaults");
          handleCalendarDefaults(containerIn, containerOut, "calendar", options.calendar);
          if (!options.noTicklabelmode) {
            ticklabelmode = coerce("ticklabelmode");
          }
        }
        if (!options.noTicklabelindex && (axType === "date" || axType === "linear")) {
          coerce("ticklabelindex");
        }
        var ticklabelposition = "";
        if (!options.noTicklabelposition || axType === "multicategory") {
          ticklabelposition = Lib.coerce(containerIn, containerOut, {
            ticklabelposition: {
              valType: "enumerated",
              dflt: "outside",
              values: ticklabelmode === "period" ? ["outside", "inside"] : letter === "x" ? [
                "outside",
                "inside",
                "outside left",
                "inside left",
                "outside right",
                "inside right"
              ] : [
                "outside",
                "inside",
                "outside top",
                "inside top",
                "outside bottom",
                "inside bottom"
              ]
            }
          }, "ticklabelposition");
        }
        if (!options.noTicklabeloverflow) {
          coerce(
            "ticklabeloverflow",
            ticklabelposition.indexOf("inside") !== -1 ? "hide past domain" : axType === "category" || axType === "multicategory" ? "allow" : "hide past div"
          );
        }
        setConvert(containerOut, layoutOut);
        handleRangeDefaults(containerIn, containerOut, coerce, options);
        handleCategoryOrderDefaults(containerIn, containerOut, coerce, options);
        if (axType !== "category" && !options.noHover) coerce("hoverformat");
        var dfltColor = coerce("color");
        var dfltFontColor = dfltColor !== layoutAttributes.color.dflt ? dfltColor : font.color;
        var dfltTitle = splomStash.label || layoutOut._dfltTitle[letter];
        handlePrefixSuffixDefaults(containerIn, containerOut, coerce, axType, options);
        if (!visible) return containerOut;
        coerce("title.text", dfltTitle);
        Lib.coerceFont(coerce, "title.font", font, { overrideDflt: {
          size: Lib.bigFont(font.size),
          color: dfltFontColor
        } });
        handleTickValueDefaults(containerIn, containerOut, coerce, axType);
        var hasMinor = options.hasMinor;
        if (hasMinor) {
          Template.newContainer(containerOut, "minor");
          handleTickValueDefaults(containerIn, containerOut, coerce, axType, { isMinor: true });
        }
        handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options);
        handleTickMarkDefaults(containerIn, containerOut, coerce, options);
        if (hasMinor) {
          var keepIsMinor = options.isMinor;
          options.isMinor = true;
          handleTickMarkDefaults(containerIn, containerOut, coerce, options);
          options.isMinor = keepIsMinor;
        }
        handleLineGridDefaults(containerIn, containerOut, coerce, {
          dfltColor,
          bgColor: options.bgColor,
          showGrid: options.showGrid,
          hasMinor,
          attributes: layoutAttributes
        });
        if (hasMinor && !containerOut.minor.ticks && !containerOut.minor.showgrid) {
          delete containerOut.minor;
        }
        if (containerOut.showline || containerOut.ticks) coerce("mirror");
        var isMultiCategory = axType === "multicategory";
        if (!options.noTickson && (axType === "category" || isMultiCategory) && (containerOut.ticks || containerOut.showgrid)) {
          var ticksonDflt;
          if (isMultiCategory) ticksonDflt = "boundaries";
          var tickson = coerce("tickson", ticksonDflt);
          if (tickson === "boundaries") {
            delete containerOut.ticklabelposition;
          }
        }
        if (isMultiCategory) {
          var showDividers = coerce("showdividers");
          if (showDividers) {
            coerce("dividercolor");
            coerce("dividerwidth");
          }
        }
        if (axType === "date") {
          handleArrayContainerDefaults(containerIn, containerOut, {
            name: "rangebreaks",
            inclusionAttr: "enabled",
            handleItemDefaults: rangebreaksDefaults
          });
          if (!containerOut.rangebreaks.length) {
            delete containerOut.rangebreaks;
          } else {
            for (var k = 0; k < containerOut.rangebreaks.length; k++) {
              if (containerOut.rangebreaks[k].pattern === DAY_OF_WEEK) {
                containerOut._hasDayOfWeekBreaks = true;
                break;
              }
            }
            setConvert(containerOut, layoutOut);
            if (layoutOut._has("scattergl") || layoutOut._has("splom")) {
              for (var i = 0; i < options.data.length; i++) {
                var trace = options.data[i];
                if (trace.type === "scattergl" || trace.type === "splom") {
                  trace.visible = false;
                  Lib.warn(trace.type + " traces do not work on axes with rangebreaks. Setting trace " + trace.index + " to `visible: false`.");
                }
              }
            }
          }
        }
        return containerOut;
      };
      function rangebreaksDefaults(itemIn, itemOut, containerOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(itemIn, itemOut, layoutAttributes.rangebreaks, attr, dflt);
        }
        var enabled = coerce("enabled");
        if (enabled) {
          var bnds = coerce("bounds");
          if (bnds && bnds.length >= 2) {
            var dfltPattern = "";
            var i, q;
            if (bnds.length === 2) {
              for (i = 0; i < 2; i++) {
                q = indexOfDay(bnds[i]);
                if (q) {
                  dfltPattern = DAY_OF_WEEK;
                  break;
                }
              }
            }
            var pattern = coerce("pattern", dfltPattern);
            if (pattern === DAY_OF_WEEK) {
              for (i = 0; i < 2; i++) {
                q = indexOfDay(bnds[i]);
                if (q) {
                  itemOut.bounds[i] = bnds[i] = q - 1;
                }
              }
            }
            if (pattern) {
              for (i = 0; i < 2; i++) {
                q = bnds[i];
                switch (pattern) {
                  case DAY_OF_WEEK:
                    if (!isNumeric(q)) {
                      itemOut.enabled = false;
                      return;
                    }
                    q = +q;
                    if (q !== Math.floor(q) || // don't accept fractional days for mow
                    q < 0 || q >= 7) {
                      itemOut.enabled = false;
                      return;
                    }
                    itemOut.bounds[i] = bnds[i] = q;
                    break;
                  case HOUR:
                    if (!isNumeric(q)) {
                      itemOut.enabled = false;
                      return;
                    }
                    q = +q;
                    if (q < 0 || q > 24) {
                      itemOut.enabled = false;
                      return;
                    }
                    itemOut.bounds[i] = bnds[i] = q;
                    break;
                }
              }
            }
            if (containerOut.autorange === false) {
              var rng = containerOut.range;
              if (rng[0] < rng[1]) {
                if (bnds[0] < rng[0] && bnds[1] > rng[1]) {
                  itemOut.enabled = false;
                  return;
                }
              } else if (bnds[0] > rng[0] && bnds[1] < rng[1]) {
                itemOut.enabled = false;
                return;
              }
            }
          } else {
            var values = coerce("values");
            if (values && values.length) {
              coerce("dvalue");
            } else {
              itemOut.enabled = false;
              return;
            }
          }
        }
      }
      var dayStrToNum = {
        sun: 1,
        mon: 2,
        tue: 3,
        wed: 4,
        thu: 5,
        fri: 6,
        sat: 7
      };
      function indexOfDay(v) {
        if (typeof v !== "string") return;
        return dayStrToNum[v.substr(0, 3).toLowerCase()];
      }
    }
  });

  // src/plots/cartesian/position_defaults.js
  var require_position_defaults = __commonJS({
    "src/plots/cartesian/position_defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      module.exports = function handlePositionDefaults(containerIn, containerOut, coerce, options) {
        var counterAxes = options.counterAxes || [];
        var overlayableAxes = options.overlayableAxes || [];
        var letter = options.letter;
        var grid = options.grid;
        var overlayingDomain = options.overlayingDomain;
        var dfltAnchor, dfltDomain, dfltSide, dfltPosition, dfltShift, dfltAutomargin;
        if (grid) {
          dfltDomain = grid._domains[letter][grid._axisMap[containerOut._id]];
          dfltAnchor = grid._anchors[containerOut._id];
          if (dfltDomain) {
            dfltSide = grid[letter + "side"].split(" ")[0];
            dfltPosition = grid.domain[letter][dfltSide === "right" || dfltSide === "top" ? 1 : 0];
          }
        }
        dfltDomain = dfltDomain || [0, 1];
        dfltAnchor = dfltAnchor || (isNumeric(containerIn.position) ? "free" : counterAxes[0] || "free");
        dfltSide = dfltSide || (letter === "x" ? "bottom" : "left");
        dfltPosition = dfltPosition || 0;
        dfltShift = 0;
        dfltAutomargin = false;
        var anchor = Lib.coerce(containerIn, containerOut, {
          anchor: {
            valType: "enumerated",
            values: ["free"].concat(counterAxes),
            dflt: dfltAnchor
          }
        }, "anchor");
        var side = Lib.coerce(containerIn, containerOut, {
          side: {
            valType: "enumerated",
            values: letter === "x" ? ["bottom", "top"] : ["left", "right"],
            dflt: dfltSide
          }
        }, "side");
        if (anchor === "free") {
          if (letter === "y") {
            var autoshift = coerce("autoshift");
            if (autoshift) {
              dfltPosition = side === "left" ? overlayingDomain[0] : overlayingDomain[1];
              dfltAutomargin = containerOut.automargin ? containerOut.automargin : true;
              dfltShift = side === "left" ? -3 : 3;
            }
            coerce("shift", dfltShift);
          }
          coerce("position", dfltPosition);
        }
        coerce("automargin", dfltAutomargin);
        var overlaying = false;
        if (overlayableAxes.length) {
          overlaying = Lib.coerce(containerIn, containerOut, {
            overlaying: {
              valType: "enumerated",
              values: [false].concat(overlayableAxes),
              dflt: false
            }
          }, "overlaying");
        }
        if (!overlaying) {
          var domain = coerce("domain", dfltDomain);
          if (domain[0] > domain[1] - 1 / 4096) containerOut.domain = dfltDomain;
          Lib.noneOrAll(containerIn.domain, containerOut.domain, dfltDomain);
          if (containerOut.tickmode === "sync") {
            containerOut.tickmode = "auto";
          }
        }
        coerce("layer");
        return containerOut;
      };
    }
  });

  // src/plots/cartesian/layout_defaults.js
  var require_layout_defaults4 = __commonJS({
    "src/plots/cartesian/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var isUnifiedHover = require_helpers2().isUnifiedHover;
      var handleHoverModeDefaults = require_hovermode_defaults();
      var Template = require_plot_template();
      var basePlotLayoutAttributes = require_layout_attributes2();
      var layoutAttributes = require_layout_attributes4();
      var handleTypeDefaults = require_type_defaults();
      var handleAxisDefaults = require_axis_defaults();
      var constraints = require_constraints();
      var handlePositionDefaults = require_position_defaults();
      var axisIds = require_axis_ids();
      var id2name = axisIds.id2name;
      var name2id = axisIds.name2id;
      var AX_ID_PATTERN = require_constants2().AX_ID_PATTERN;
      var Registry = require_registry();
      var traceIs = Registry.traceIs;
      var getComponentMethod = Registry.getComponentMethod;
      function appendList(cont, k, item) {
        if (Array.isArray(cont[k])) cont[k].push(item);
        else cont[k] = [item];
      }
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
        var autotypenumbersDflt = layoutOut.autotypenumbers;
        var ax2traces = {};
        var xaMayHide = {};
        var yaMayHide = {};
        var xaMustDisplay = {};
        var yaMustDisplay = {};
        var yaMustNotReverse = {};
        var yaMayReverse = {};
        var axHasImage = {};
        var outerTicks = {};
        var noGrids = {};
        var i, j;
        for (i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          if (!traceIs(trace, "cartesian")) continue;
          var xaName;
          if (trace.xaxis) {
            xaName = id2name(trace.xaxis);
            appendList(ax2traces, xaName, trace);
          } else if (trace.xaxes) {
            for (j = 0; j < trace.xaxes.length; j++) {
              appendList(ax2traces, id2name(trace.xaxes[j]), trace);
            }
          }
          var yaName;
          if (trace.yaxis) {
            yaName = id2name(trace.yaxis);
            appendList(ax2traces, yaName, trace);
          } else if (trace.yaxes) {
            for (j = 0; j < trace.yaxes.length; j++) {
              appendList(ax2traces, id2name(trace.yaxes[j]), trace);
            }
          }
          if (trace.type === "funnel") {
            if (trace.orientation === "h") {
              if (xaName) xaMayHide[xaName] = true;
              if (yaName) yaMayReverse[yaName] = true;
            } else {
              if (yaName) yaMayHide[yaName] = true;
            }
          } else if (trace.type === "image") {
            if (yaName) axHasImage[yaName] = true;
            if (xaName) axHasImage[xaName] = true;
          } else {
            if (yaName) {
              yaMustDisplay[yaName] = true;
              yaMustNotReverse[yaName] = true;
            }
            if (!traceIs(trace, "carpet") || trace.type === "carpet" && !trace._cheater) {
              if (xaName) xaMustDisplay[xaName] = true;
            }
          }
          if (trace.type === "carpet" && trace._cheater) {
            if (xaName) xaMayHide[xaName] = true;
          }
          if (traceIs(trace, "2dMap")) {
            outerTicks[xaName] = true;
            outerTicks[yaName] = true;
          }
          if (traceIs(trace, "oriented")) {
            var positionAxis = trace.orientation === "h" ? yaName : xaName;
            noGrids[positionAxis] = true;
          }
        }
        var subplots = layoutOut._subplots;
        var xIds = subplots.xaxis;
        var yIds = subplots.yaxis;
        var xNames = Lib.simpleMap(xIds, id2name);
        var yNames = Lib.simpleMap(yIds, id2name);
        var axNames = xNames.concat(yNames);
        var plotBgColor = Color.background;
        if (xIds.length && yIds.length) {
          plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, "plot_bgcolor");
        }
        var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);
        var axName;
        var axId;
        var axLetter;
        var axLayoutIn;
        var axLayoutOut;
        function newAxLayoutOut() {
          var traces = ax2traces[axName] || [];
          axLayoutOut._traceIndices = traces.map(function(t) {
            return t.index;
          });
          axLayoutOut._annIndices = [];
          axLayoutOut._shapeIndices = [];
          axLayoutOut._selectionIndices = [];
          axLayoutOut._imgIndices = [];
          axLayoutOut._subplotsWith = [];
          axLayoutOut._counterAxes = [];
          axLayoutOut._name = axLayoutOut._attr = axName;
          axLayoutOut._id = axId;
        }
        function coerce(attr, dflt) {
          return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);
        }
        function coerce2(attr, dflt) {
          return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);
        }
        function getCounterAxes(axLetter2) {
          return axLetter2 === "x" ? yIds : xIds;
        }
        function getOverlayableAxes(axLetter2, axName2) {
          var list = axLetter2 === "x" ? xNames : yNames;
          var out = [];
          for (var j2 = 0; j2 < list.length; j2++) {
            var axName22 = list[j2];
            if (axName22 !== axName2 && !(layoutIn[axName22] || {}).overlaying) {
              out.push(name2id(axName22));
            }
          }
          return out;
        }
        var counterAxes = { x: getCounterAxes("x"), y: getCounterAxes("y") };
        var allAxisIds = counterAxes.x.concat(counterAxes.y);
        var missingMatchedAxisIdsLookup = {};
        var missingMatchedAxisIds = [];
        function addMissingMatchedAxis() {
          var matchesIn = axLayoutIn.matches;
          if (AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {
            missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;
            missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);
          }
        }
        var hovermode = handleHoverModeDefaults(layoutIn, layoutOut);
        var unifiedHover = isUnifiedHover(hovermode);
        for (i = 0; i < axNames.length; i++) {
          axName = axNames[i];
          axId = name2id(axName);
          axLetter = axName.charAt(0);
          if (!Lib.isPlainObject(layoutIn[axName])) {
            layoutIn[axName] = {};
          }
          axLayoutIn = layoutIn[axName];
          axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + "axis");
          newAxLayoutOut();
          var visibleDflt = axLetter === "x" && !xaMustDisplay[axName] && xaMayHide[axName] || axLetter === "y" && !yaMustDisplay[axName] && yaMayHide[axName];
          var reverseDflt = axLetter === "y" && (!yaMustNotReverse[axName] && yaMayReverse[axName] || axHasImage[axName]);
          var defaultOptions = {
            hasMinor: true,
            letter: axLetter,
            font: layoutOut.font,
            outerTicks: outerTicks[axName],
            showGrid: !noGrids[axName],
            data: ax2traces[axName] || [],
            bgColor,
            calendar: layoutOut.calendar,
            automargin: true,
            visibleDflt,
            reverseDflt,
            autotypenumbersDflt,
            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId],
            noAutotickangles: axLetter === "y"
          };
          coerce("uirevision", layoutOut.uirevision);
          handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);
          handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);
          var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);
          var spikecolor = coerce2("spikecolor", unifiedHover ? axLayoutOut.color : void 0);
          var spikethickness = coerce2("spikethickness", unifiedHover ? 1.5 : void 0);
          var spikedash = coerce2("spikedash", unifiedHover ? "dot" : void 0);
          var spikemode = coerce2("spikemode", unifiedHover ? "across" : void 0);
          var spikesnap = coerce2("spikesnap");
          var showSpikes = coerce("showspikes", !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);
          if (!showSpikes) {
            delete axLayoutOut.spikecolor;
            delete axLayoutOut.spikethickness;
            delete axLayoutOut.spikedash;
            delete axLayoutOut.spikemode;
            delete axLayoutOut.spikesnap;
          }
          var overlayingAxis = id2name(axLayoutIn.overlaying);
          var overlayingAnchorDomain = [0, 1];
          if (layoutOut[overlayingAxis] !== void 0) {
            var overlayingAnchor = id2name(layoutOut[overlayingAxis].anchor);
            if (layoutOut[overlayingAnchor] !== void 0) {
              overlayingAnchorDomain = layoutOut[overlayingAnchor].domain;
            }
          }
          handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {
            letter: axLetter,
            counterAxes: counterAxes[axLetter],
            overlayableAxes: getOverlayableAxes(axLetter, axName),
            grid: layoutOut.grid,
            overlayingDomain: overlayingAnchorDomain
          });
          coerce("title.standoff");
          addMissingMatchedAxis();
          axLayoutOut._input = axLayoutIn;
        }
        i = 0;
        while (i < missingMatchedAxisIds.length) {
          axId = missingMatchedAxisIds[i++];
          axName = id2name(axId);
          axLetter = axName.charAt(0);
          if (!Lib.isPlainObject(layoutIn[axName])) {
            layoutIn[axName] = {};
          }
          axLayoutIn = layoutIn[axName];
          axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + "axis");
          newAxLayoutOut();
          var defaultOptions2 = {
            letter: axLetter,
            font: layoutOut.font,
            outerTicks: outerTicks[axName],
            showGrid: !noGrids[axName],
            data: [],
            bgColor,
            calendar: layoutOut.calendar,
            automargin: true,
            visibleDflt: false,
            reverseDflt: false,
            autotypenumbersDflt,
            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]
          };
          coerce("uirevision", layoutOut.uirevision);
          axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || "linear";
          handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);
          handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {
            letter: axLetter,
            counterAxes: counterAxes[axLetter],
            overlayableAxes: getOverlayableAxes(axLetter, axName),
            grid: layoutOut.grid
          });
          coerce("fixedrange");
          addMissingMatchedAxis();
          axLayoutOut._input = axLayoutIn;
        }
        var rangeSliderDefaults = getComponentMethod("rangeslider", "handleDefaults");
        var rangeSelectorDefaults = getComponentMethod("rangeselector", "handleDefaults");
        for (i = 0; i < xNames.length; i++) {
          axName = xNames[i];
          axLayoutIn = layoutIn[axName];
          axLayoutOut = layoutOut[axName];
          rangeSliderDefaults(layoutIn, layoutOut, axName);
          if (axLayoutOut.type === "date") {
            rangeSelectorDefaults(
              axLayoutIn,
              axLayoutOut,
              layoutOut,
              yNames,
              axLayoutOut.calendar
            );
          }
          coerce("fixedrange");
        }
        for (i = 0; i < yNames.length; i++) {
          axName = yNames[i];
          axLayoutIn = layoutIn[axName];
          axLayoutOut = layoutOut[axName];
          var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];
          var fixedRangeDflt = getComponentMethod("rangeslider", "isVisible")(anchoredAxis);
          coerce("fixedrange", fixedRangeDflt);
        }
        constraints.handleDefaults(layoutIn, layoutOut, {
          axIds: allAxisIds.concat(missingMatchedAxisIds).sort(axisIds.idSort),
          axHasImage
        });
      };
    }
  });

  // src/plots/cartesian/transition_axes.js
  var require_transition_axes = __commonJS({
    "src/plots/cartesian/transition_axes.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var Drawing = require_drawing();
      var Axes = require_axes();
      module.exports = function transitionAxes(gd, edits, transitionOpts, makeOnCompleteCallback) {
        var fullLayout = gd._fullLayout;
        if (edits.length === 0) {
          Axes.redrawComponents(gd);
          return;
        }
        function unsetSubplotTransform(subplot) {
          var xa = subplot.xaxis;
          var ya = subplot.yaxis;
          fullLayout._defs.select("#" + subplot.clipId + "> rect").call(Drawing.setTranslate, 0, 0).call(Drawing.setScale, 1, 1);
          subplot.plot.call(Drawing.setTranslate, xa._offset, ya._offset).call(Drawing.setScale, 1, 1);
          var traceGroups = subplot.plot.selectAll(".scatterlayer .trace");
          traceGroups.selectAll(".point").call(Drawing.setPointGroupScale, 1, 1);
          traceGroups.selectAll(".textpoint").call(Drawing.setTextPointsScale, 1, 1);
          traceGroups.call(Drawing.hideOutsideRangePoints, subplot);
        }
        function updateSubplot(edit, progress) {
          var plotinfo = edit.plotinfo;
          var xa = plotinfo.xaxis;
          var ya = plotinfo.yaxis;
          var xlen = xa._length;
          var ylen = ya._length;
          var editX = !!edit.xr1;
          var editY = !!edit.yr1;
          var viewBox = [];
          if (editX) {
            var xr0 = Lib.simpleMap(edit.xr0, xa.r2l);
            var xr1 = Lib.simpleMap(edit.xr1, xa.r2l);
            var dx0 = xr0[1] - xr0[0];
            var dx1 = xr1[1] - xr1[0];
            viewBox[0] = (xr0[0] * (1 - progress) + progress * xr1[0] - xr0[0]) / (xr0[1] - xr0[0]) * xlen;
            viewBox[2] = xlen * (1 - progress + progress * dx1 / dx0);
            xa.range[0] = xa.l2r(xr0[0] * (1 - progress) + progress * xr1[0]);
            xa.range[1] = xa.l2r(xr0[1] * (1 - progress) + progress * xr1[1]);
          } else {
            viewBox[0] = 0;
            viewBox[2] = xlen;
          }
          if (editY) {
            var yr0 = Lib.simpleMap(edit.yr0, ya.r2l);
            var yr1 = Lib.simpleMap(edit.yr1, ya.r2l);
            var dy0 = yr0[1] - yr0[0];
            var dy1 = yr1[1] - yr1[0];
            viewBox[1] = (yr0[1] * (1 - progress) + progress * yr1[1] - yr0[1]) / (yr0[0] - yr0[1]) * ylen;
            viewBox[3] = ylen * (1 - progress + progress * dy1 / dy0);
            ya.range[0] = xa.l2r(yr0[0] * (1 - progress) + progress * yr1[0]);
            ya.range[1] = ya.l2r(yr0[1] * (1 - progress) + progress * yr1[1]);
          } else {
            viewBox[1] = 0;
            viewBox[3] = ylen;
          }
          Axes.drawOne(gd, xa, { skipTitle: true });
          Axes.drawOne(gd, ya, { skipTitle: true });
          Axes.redrawComponents(gd, [xa._id, ya._id]);
          var xScaleFactor = editX ? xlen / viewBox[2] : 1;
          var yScaleFactor = editY ? ylen / viewBox[3] : 1;
          var clipDx = editX ? viewBox[0] : 0;
          var clipDy = editY ? viewBox[1] : 0;
          var fracDx = editX ? viewBox[0] / viewBox[2] * xlen : 0;
          var fracDy = editY ? viewBox[1] / viewBox[3] * ylen : 0;
          var plotDx = xa._offset - fracDx;
          var plotDy = ya._offset - fracDy;
          plotinfo.clipRect.call(Drawing.setTranslate, clipDx, clipDy).call(Drawing.setScale, 1 / xScaleFactor, 1 / yScaleFactor);
          plotinfo.plot.call(Drawing.setTranslate, plotDx, plotDy).call(Drawing.setScale, xScaleFactor, yScaleFactor);
          Drawing.setPointGroupScale(plotinfo.zoomScalePts, 1 / xScaleFactor, 1 / yScaleFactor);
          Drawing.setTextPointsScale(plotinfo.zoomScaleTxt, 1 / xScaleFactor, 1 / yScaleFactor);
        }
        var onComplete;
        if (makeOnCompleteCallback) {
          onComplete = makeOnCompleteCallback();
        }
        function transitionComplete() {
          var aobj = {};
          for (var i = 0; i < edits.length; i++) {
            var edit = edits[i];
            var xa = edit.plotinfo.xaxis;
            var ya = edit.plotinfo.yaxis;
            if (edit.xr1) aobj[xa._name + ".range"] = edit.xr1.slice();
            if (edit.yr1) aobj[ya._name + ".range"] = edit.yr1.slice();
          }
          onComplete && onComplete();
          return Registry.call("relayout", gd, aobj).then(function() {
            for (var i2 = 0; i2 < edits.length; i2++) {
              unsetSubplotTransform(edits[i2].plotinfo);
            }
          });
        }
        function transitionInterrupt() {
          var aobj = {};
          for (var i = 0; i < edits.length; i++) {
            var edit = edits[i];
            var xa = edit.plotinfo.xaxis;
            var ya = edit.plotinfo.yaxis;
            if (edit.xr0) aobj[xa._name + ".range"] = edit.xr0.slice();
            if (edit.yr0) aobj[ya._name + ".range"] = edit.yr0.slice();
          }
          return Registry.call("relayout", gd, aobj).then(function() {
            for (var i2 = 0; i2 < edits.length; i2++) {
              unsetSubplotTransform(edits[i2].plotinfo);
            }
          });
        }
        var t1, t2, raf;
        var easeFn = d3.ease(transitionOpts.easing);
        gd._transitionData._interruptCallbacks.push(function() {
          window.cancelAnimationFrame(raf);
          raf = null;
          return transitionInterrupt();
        });
        function doFrame() {
          t2 = Date.now();
          var tInterp = Math.min(1, (t2 - t1) / transitionOpts.duration);
          var progress = easeFn(tInterp);
          for (var i = 0; i < edits.length; i++) {
            updateSubplot(edits[i], progress);
          }
          if (t2 - t1 > transitionOpts.duration) {
            transitionComplete();
            raf = window.cancelAnimationFrame(doFrame);
          } else {
            raf = window.requestAnimationFrame(doFrame);
          }
        }
        t1 = Date.now();
        raf = window.requestAnimationFrame(doFrame);
        return Promise.resolve();
      };
    }
  });

  // src/plots/cartesian/index.js
  var require_cartesian = __commonJS({
    "src/plots/cartesian/index.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var Plots = require_plots();
      var Drawing = require_drawing();
      var getModuleCalcData = require_get_data().getModuleCalcData;
      var axisIds = require_axis_ids();
      var constants = require_constants2();
      var xmlnsNamespaces = require_xmlns_namespaces();
      var ensureSingle = Lib.ensureSingle;
      function ensureSingleAndAddDatum(parent, nodeType, className) {
        return Lib.ensureSingle(parent, nodeType, className, function(s) {
          s.datum(className);
        });
      }
      var zindexSeparator = constants.zindexSeparator;
      exports.name = "cartesian";
      exports.attr = ["xaxis", "yaxis"];
      exports.idRoot = ["x", "y"];
      exports.idRegex = constants.idRegex;
      exports.attrRegex = constants.attrRegex;
      exports.attributes = require_attributes14();
      exports.layoutAttributes = require_layout_attributes4();
      exports.supplyLayoutDefaults = require_layout_defaults4();
      exports.transitionAxes = require_transition_axes();
      exports.finalizeSubplots = function(layoutIn, layoutOut) {
        var subplots = layoutOut._subplots;
        var xList = subplots.xaxis;
        var yList = subplots.yaxis;
        var spSVG = subplots.cartesian;
        var spAll = spSVG;
        var allX = {};
        var allY = {};
        var i, xi, yi;
        for (i = 0; i < spAll.length; i++) {
          var parts = spAll[i].split("y");
          allX[parts[0]] = 1;
          allY["y" + parts[1]] = 1;
        }
        for (i = 0; i < xList.length; i++) {
          xi = xList[i];
          if (!allX[xi]) {
            yi = (layoutIn[axisIds.id2name(xi)] || {}).anchor;
            if (!constants.idRegex.y.test(yi)) yi = "y";
            spSVG.push(xi + yi);
            spAll.push(xi + yi);
            if (!allY[yi]) {
              allY[yi] = 1;
              Lib.pushUnique(yList, yi);
            }
          }
        }
        for (i = 0; i < yList.length; i++) {
          yi = yList[i];
          if (!allY[yi]) {
            xi = (layoutIn[axisIds.id2name(yi)] || {}).anchor;
            if (!constants.idRegex.x.test(xi)) xi = "x";
            spSVG.push(xi + yi);
            spAll.push(xi + yi);
            if (!allX[xi]) {
              allX[xi] = 1;
              Lib.pushUnique(xList, xi);
            }
          }
        }
        if (!spAll.length) {
          xi = "";
          yi = "";
          for (var ki in layoutIn) {
            if (constants.attrRegex.test(ki)) {
              var axLetter = ki.charAt(0);
              if (axLetter === "x") {
                if (!xi || +ki.substr(5) < +xi.substr(5)) {
                  xi = ki;
                }
              } else if (!yi || +ki.substr(5) < +yi.substr(5)) {
                yi = ki;
              }
            }
          }
          xi = xi ? axisIds.name2id(xi) : "x";
          yi = yi ? axisIds.name2id(yi) : "y";
          xList.push(xi);
          yList.push(yi);
          spSVG.push(xi + yi);
        }
      };
      exports.plot = function(gd, traces, transitionOpts, makeOnCompleteCallback) {
        var fullLayout = gd._fullLayout;
        var subplots = fullLayout._subplots.cartesian;
        var calcdata = gd.calcdata;
        var i;
        if (!Array.isArray(traces)) {
          traces = [];
          for (i = 0; i < calcdata.length; i++) traces.push(i);
        }
        var zindices = fullLayout._zindices;
        for (var z = 0; z < zindices.length; z++) {
          var zorder = zindices[z];
          for (i = 0; i < subplots.length; i++) {
            var subplot = subplots[i];
            var subplotInfo = fullLayout._plots[subplot];
            if (z > 0) {
              var idWithZ = subplotInfo.id;
              if (idWithZ.indexOf(zindexSeparator) !== -1) continue;
              idWithZ += zindexSeparator + (z + 1);
              subplotInfo = Lib.extendFlat({}, subplotInfo, {
                id: idWithZ,
                plot: fullLayout._cartesianlayer.selectAll(".subplot").select("." + idWithZ)
              });
            }
            var cdSubplot = [];
            var pcd;
            for (var j = 0; j < calcdata.length; j++) {
              var cd = calcdata[j];
              var trace = cd[0].trace;
              if (zorder !== (trace.zorder || 0)) continue;
              if (trace.xaxis + trace.yaxis === subplot) {
                if (traces.indexOf(trace.index) !== -1 || trace.carpet) {
                  if (pcd && pcd[0].trace.xaxis + pcd[0].trace.yaxis === subplot && ["tonextx", "tonexty", "tonext"].indexOf(trace.fill) !== -1 && cdSubplot.indexOf(pcd) === -1) {
                    cdSubplot.push(pcd);
                  }
                  cdSubplot.push(cd);
                }
                pcd = cd;
              }
            }
            plotOne(gd, subplotInfo, cdSubplot, transitionOpts, makeOnCompleteCallback);
          }
        }
      };
      function plotOne(gd, plotinfo, cdSubplot, transitionOpts, makeOnCompleteCallback) {
        var traceLayerClasses = constants.traceLayerClasses;
        var fullLayout = gd._fullLayout;
        var zindices = fullLayout._zindices;
        var modules = fullLayout._modules;
        var _module, cdModuleAndOthers, cdModule;
        var layerData = [];
        var zoomScaleQueryParts = [];
        for (var z = 0; z < zindices.length; z++) {
          var zorder = zindices[z];
          for (var i = 0; i < modules.length; i++) {
            _module = modules[i];
            var name = _module.name;
            var categories = Registry.modules[name].categories;
            if (categories.svg) {
              var classBaseName = _module.layerName || name + "layer";
              var className = classBaseName + (z ? Number(z) + 1 : "");
              var plotMethod = _module.plot;
              cdModuleAndOthers = getModuleCalcData(cdSubplot, plotMethod, zorder);
              cdModule = cdModuleAndOthers[0];
              cdSubplot = cdModuleAndOthers[1];
              if (cdModule.length) {
                layerData.push({
                  i: traceLayerClasses.indexOf(classBaseName),
                  zindex: z,
                  className,
                  plotMethod,
                  cdModule
                });
              }
              if (categories.zoomScale) {
                zoomScaleQueryParts.push("." + className);
              }
            }
          }
        }
        layerData.sort(function(a, b) {
          return (a.zindex || 0) - (b.zindex || 0) || a.i - b.i;
        });
        var layers = plotinfo.plot.selectAll("g.mlayer").data(layerData, function(d) {
          return d.className;
        });
        layers.enter().append("g").attr("class", function(d) {
          return d.className;
        }).classed("mlayer", true).classed("rangeplot", plotinfo.isRangePlot);
        layers.exit().remove();
        layers.order();
        layers.each(function(d) {
          var sel = d3.select(this);
          var className2 = d.className;
          d.plotMethod(
            gd,
            plotinfo,
            d.cdModule,
            sel,
            transitionOpts,
            makeOnCompleteCallback
          );
          if (constants.clipOnAxisFalseQuery.indexOf("." + className2) === -1) {
            Drawing.setClipUrl(sel, plotinfo.layerClipId, gd);
          }
        });
        if (fullLayout._has("scattergl")) {
          _module = Registry.getModule("scattergl");
          cdModule = getModuleCalcData(cdSubplot, _module)[0];
          _module.plot(gd, plotinfo, cdModule);
        }
        if (!gd._context.staticPlot) {
          if (plotinfo._hasClipOnAxisFalse) {
            plotinfo.clipOnAxisFalseTraces = plotinfo.plot.selectAll(constants.clipOnAxisFalseQuery.join(",")).selectAll(".trace");
          }
          if (zoomScaleQueryParts.length) {
            var traces = plotinfo.plot.selectAll(zoomScaleQueryParts.join(",")).selectAll(".trace");
            plotinfo.zoomScalePts = traces.selectAll("path.point");
            plotinfo.zoomScaleTxt = traces.selectAll(".textpoint");
          }
        }
      }
      exports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var oldPlots = oldFullLayout._plots || {};
        var newPlots = newFullLayout._plots || {};
        var oldSubplotList = oldFullLayout._subplots || {};
        var plotinfo;
        var i, k;
        if (oldFullLayout._hasOnlyLargeSploms && !newFullLayout._hasOnlyLargeSploms) {
          for (k in oldPlots) {
            plotinfo = oldPlots[k];
            if (plotinfo.plotgroup) plotinfo.plotgroup.remove();
          }
        }
        var hadGl = oldFullLayout._has && oldFullLayout._has("gl");
        var hasGl = newFullLayout._has && newFullLayout._has("gl");
        if (hadGl && !hasGl) {
          for (k in oldPlots) {
            plotinfo = oldPlots[k];
            if (plotinfo._scene) plotinfo._scene.destroy();
          }
        }
        if (oldSubplotList.xaxis && oldSubplotList.yaxis) {
          var oldAxIDs = axisIds.listIds({ _fullLayout: oldFullLayout });
          for (i = 0; i < oldAxIDs.length; i++) {
            var oldAxId = oldAxIDs[i];
            if (!newFullLayout[axisIds.id2name(oldAxId)]) {
              oldFullLayout._infolayer.selectAll(".g-" + oldAxId + "title").remove();
            }
          }
        }
        var hadCartesian = oldFullLayout._has && oldFullLayout._has("cartesian");
        var hasCartesian = newFullLayout._has && newFullLayout._has("cartesian");
        if (hadCartesian && !hasCartesian) {
          purgeSubplotLayers(oldFullLayout._cartesianlayer.selectAll(".subplot"), oldFullLayout);
          oldFullLayout._defs.selectAll(".axesclip").remove();
          delete oldFullLayout._axisConstraintGroups;
          delete oldFullLayout._axisMatchGroups;
        } else if (oldSubplotList.cartesian) {
          for (i = 0; i < oldSubplotList.cartesian.length; i++) {
            var oldSubplotId = oldSubplotList.cartesian[i];
            if (oldSubplotId.indexOf(zindexSeparator) !== -1) continue;
            if (!newPlots[oldSubplotId]) {
              var selector = "." + oldSubplotId + ",." + oldSubplotId + "-x,." + oldSubplotId + "-y";
              oldFullLayout._cartesianlayer.selectAll(selector).remove();
              removeSubplotExtras(oldSubplotId, oldFullLayout);
            }
          }
        }
      };
      exports.drawFramework = function(gd) {
        var fullLayout = gd._fullLayout;
        var calcdata = gd.calcdata;
        var i;
        var traceZorderGroups = {};
        for (i = 0; i < calcdata.length; i++) {
          var cdi = calcdata[i][0];
          var trace = cdi.trace;
          var zi = trace.zorder || 0;
          if (!traceZorderGroups[zi]) traceZorderGroups[zi] = [];
          traceZorderGroups[zi].push(cdi);
        }
        var zindices = Object.keys(traceZorderGroups).map(Number).sort(Lib.sorterAsc);
        if (!zindices.length) zindices = [0];
        fullLayout._zindices = zindices;
        var initialSubplotData = makeSubplotData(gd);
        var len = initialSubplotData.length;
        var subplotData = [];
        for (i = 0; i < len; i++) {
          subplotData[i] = initialSubplotData[i].slice();
        }
        for (var z = 1; z < zindices.length; z++) {
          var newSubplotData = [];
          for (i = 0; i < len; i++) {
            newSubplotData[i] = initialSubplotData[i].slice();
            newSubplotData[i][0] += zindexSeparator + (z + 1);
          }
          subplotData = subplotData.concat(newSubplotData);
        }
        var subplotLayers = fullLayout._cartesianlayer.selectAll(".subplot").data(subplotData, String);
        subplotLayers.enter().append("g").attr("class", function(d) {
          return "subplot " + d[0];
        });
        subplotLayers.order();
        subplotLayers.exit().call(purgeSubplotLayers, fullLayout);
        subplotLayers.each(function(d) {
          var id = d[0];
          var posZ = id.indexOf(zindexSeparator);
          var hasZ = posZ !== -1;
          var idWithoutZ = hasZ ? id.slice(0, posZ) : id;
          var plotinfo = fullLayout._plots[id];
          if (!plotinfo) {
            plotinfo = Lib.extendFlat({}, fullLayout._plots[idWithoutZ]);
            if (plotinfo) {
              plotinfo.id = id;
              fullLayout._plots[id] = plotinfo;
              fullLayout._subplots.cartesian.push(id);
            }
          }
          if (plotinfo) {
            plotinfo.plotgroup = d3.select(this);
            makeSubplotLayer(gd, plotinfo);
            if (!hasZ) {
              plotinfo.draglayer = ensureSingle(fullLayout._draggers, "g", id);
            }
          }
        });
      };
      exports.rangePlot = function(gd, plotinfo, cdSubplot) {
        makeSubplotLayer(gd, plotinfo);
        plotOne(gd, plotinfo, cdSubplot);
        Plots.style(gd);
      };
      function makeSubplotData(gd) {
        var fullLayout = gd._fullLayout;
        var numZ = fullLayout._zindices.length;
        var ids = fullLayout._subplots.cartesian;
        var len = ids.length;
        var i, j, id, plotinfo, xa, ya;
        var regulars = [];
        var overlays = [];
        for (i = 0; i < len; i++) {
          id = ids[i];
          plotinfo = fullLayout._plots[id];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          var xa2 = xa._mainAxis;
          var ya2 = ya._mainAxis;
          var mainplot = xa2._id + ya2._id;
          var mainplotinfo = fullLayout._plots[mainplot];
          plotinfo.overlays = [];
          if (mainplot !== id && mainplotinfo) {
            plotinfo.mainplot = mainplot;
            plotinfo.mainplotinfo = mainplotinfo;
            overlays.push(id);
          } else {
            plotinfo.mainplot = void 0;
            plotinfo.mainplotinfo = void 0;
            regulars.push(id);
          }
        }
        for (i = 0; i < overlays.length; i++) {
          id = overlays[i];
          plotinfo = fullLayout._plots[id];
          plotinfo.mainplotinfo.overlays.push(plotinfo);
        }
        var subplotIds = regulars.concat(overlays);
        var subplotData = [];
        for (i = 0; i < len; i++) {
          id = subplotIds[i];
          plotinfo = fullLayout._plots[id];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          var d = [];
          for (var z = 1; z <= numZ; z++) {
            var zStr = "";
            if (z > 1) zStr += zindexSeparator + z;
            d.push(id + zStr);
            for (j = 0; j < plotinfo.overlays.length; j++) {
              d.push(plotinfo.overlays[j].id + zStr);
            }
          }
          d = d.concat([
            xa.layer,
            ya.layer,
            xa.overlaying || "",
            ya.overlaying || ""
          ]);
          subplotData.push(d);
        }
        return subplotData;
      }
      function makeSubplotLayer(gd, plotinfo) {
        var fullLayout = gd._fullLayout;
        var plotgroup = plotinfo.plotgroup;
        var id = plotinfo.id;
        var posZ = id.indexOf(zindexSeparator);
        var hasZ = posZ !== -1;
        var xLayer = constants.layerValue2layerClass[plotinfo.xaxis.layer];
        var yLayer = constants.layerValue2layerClass[plotinfo.yaxis.layer];
        var hasOnlyLargeSploms = fullLayout._hasOnlyLargeSploms;
        var hasMultipleZ = fullLayout._zindices.length > 1;
        var mainplotinfo = plotinfo.mainplotinfo;
        if (!plotinfo.mainplot || hasMultipleZ) {
          if (hasOnlyLargeSploms) {
            plotinfo.xlines = ensureSingle(plotgroup, "path", "xlines-above");
            plotinfo.ylines = ensureSingle(plotgroup, "path", "ylines-above");
            plotinfo.xaxislayer = ensureSingle(plotgroup, "g", "xaxislayer-above");
            plotinfo.yaxislayer = ensureSingle(plotgroup, "g", "yaxislayer-above");
          } else {
            if (!hasZ) {
              var backLayer = ensureSingle(plotgroup, "g", "layer-subplot");
              plotinfo.shapelayer = ensureSingle(backLayer, "g", "shapelayer");
              plotinfo.imagelayer = ensureSingle(backLayer, "g", "imagelayer");
              if (mainplotinfo && hasMultipleZ) {
                plotinfo.minorGridlayer = mainplotinfo.minorGridlayer;
                plotinfo.gridlayer = mainplotinfo.gridlayer;
                plotinfo.zerolinelayer = mainplotinfo.zerolinelayer;
              } else {
                plotinfo.minorGridlayer = ensureSingle(plotgroup, "g", "minor-gridlayer");
                plotinfo.gridlayer = ensureSingle(plotgroup, "g", "gridlayer");
                plotinfo.zerolinelayer = ensureSingle(plotgroup, "g", "zerolinelayer");
              }
              var betweenLayer = ensureSingle(plotgroup, "g", "layer-between");
              plotinfo.shapelayerBetween = ensureSingle(betweenLayer, "g", "shapelayer");
              plotinfo.imagelayerBetween = ensureSingle(betweenLayer, "g", "imagelayer");
              ensureSingle(plotgroup, "path", "xlines-below");
              ensureSingle(plotgroup, "path", "ylines-below");
              plotinfo.overlinesBelow = ensureSingle(plotgroup, "g", "overlines-below");
              ensureSingle(plotgroup, "g", "xaxislayer-below");
              ensureSingle(plotgroup, "g", "yaxislayer-below");
              plotinfo.overaxesBelow = ensureSingle(plotgroup, "g", "overaxes-below");
            }
            plotinfo.overplot = ensureSingle(plotgroup, "g", "overplot");
            plotinfo.plot = ensureSingle(plotinfo.overplot, "g", id);
            if (!hasZ) {
              plotinfo.xlines = ensureSingle(plotgroup, "path", "xlines-above");
              plotinfo.ylines = ensureSingle(plotgroup, "path", "ylines-above");
              plotinfo.overlinesAbove = ensureSingle(plotgroup, "g", "overlines-above");
              ensureSingle(plotgroup, "g", "xaxislayer-above");
              ensureSingle(plotgroup, "g", "yaxislayer-above");
              plotinfo.overaxesAbove = ensureSingle(plotgroup, "g", "overaxes-above");
              plotinfo.xlines = plotgroup.select(".xlines-" + xLayer);
              plotinfo.ylines = plotgroup.select(".ylines-" + yLayer);
              plotinfo.xaxislayer = plotgroup.select(".xaxislayer-" + xLayer);
              plotinfo.yaxislayer = plotgroup.select(".yaxislayer-" + yLayer);
            }
          }
        } else {
          var mainplotgroup = mainplotinfo.plotgroup;
          var xId = id + "-x";
          var yId = id + "-y";
          plotinfo.minorGridlayer = mainplotinfo.minorGridlayer;
          plotinfo.gridlayer = mainplotinfo.gridlayer;
          plotinfo.zerolinelayer = mainplotinfo.zerolinelayer;
          ensureSingle(mainplotinfo.overlinesBelow, "path", xId);
          ensureSingle(mainplotinfo.overlinesBelow, "path", yId);
          ensureSingle(mainplotinfo.overaxesBelow, "g", xId);
          ensureSingle(mainplotinfo.overaxesBelow, "g", yId);
          plotinfo.plot = ensureSingle(mainplotinfo.overplot, "g", id);
          ensureSingle(mainplotinfo.overlinesAbove, "path", xId);
          ensureSingle(mainplotinfo.overlinesAbove, "path", yId);
          ensureSingle(mainplotinfo.overaxesAbove, "g", xId);
          ensureSingle(mainplotinfo.overaxesAbove, "g", yId);
          plotinfo.xlines = mainplotgroup.select(".overlines-" + xLayer).select("." + xId);
          plotinfo.ylines = mainplotgroup.select(".overlines-" + yLayer).select("." + yId);
          plotinfo.xaxislayer = mainplotgroup.select(".overaxes-" + xLayer).select("." + xId);
          plotinfo.yaxislayer = mainplotgroup.select(".overaxes-" + yLayer).select("." + yId);
        }
        if (!hasZ) {
          if (!hasOnlyLargeSploms) {
            ensureSingleAndAddDatum(plotinfo.minorGridlayer, "g", plotinfo.xaxis._id);
            ensureSingleAndAddDatum(plotinfo.minorGridlayer, "g", plotinfo.yaxis._id);
            plotinfo.minorGridlayer.selectAll("g").map(function(d) {
              return d[0];
            }).sort(axisIds.idSort);
            ensureSingleAndAddDatum(plotinfo.gridlayer, "g", plotinfo.xaxis._id);
            ensureSingleAndAddDatum(plotinfo.gridlayer, "g", plotinfo.yaxis._id);
            plotinfo.gridlayer.selectAll("g").map(function(d) {
              return d[0];
            }).sort(axisIds.idSort);
          }
          plotinfo.xlines.style("fill", "none").classed("crisp", true);
          plotinfo.ylines.style("fill", "none").classed("crisp", true);
        }
      }
      function purgeSubplotLayers(layers, fullLayout) {
        if (!layers) return;
        var overlayIdsToRemove = {};
        layers.each(function(d) {
          var id = d[0];
          var plotgroup = d3.select(this);
          plotgroup.remove();
          removeSubplotExtras(id, fullLayout);
          overlayIdsToRemove[id] = true;
        });
        for (var k in fullLayout._plots) {
          var subplotInfo = fullLayout._plots[k];
          var overlays = subplotInfo.overlays || [];
          for (var j = 0; j < overlays.length; j++) {
            var overlayInfo = overlays[j];
            if (overlayIdsToRemove[overlayInfo.id]) {
              overlayInfo.plot.selectAll(".trace").remove();
            }
          }
        }
      }
      function removeSubplotExtras(subplotId, fullLayout) {
        fullLayout._draggers.selectAll("g." + subplotId).remove();
        fullLayout._defs.select("#clip" + fullLayout._uid + subplotId + "plot").remove();
      }
      exports.toSVG = function(gd) {
        var imageRoot = gd._fullLayout._glimages;
        var root = d3.select(gd).selectAll(".svg-container");
        var canvases = root.filter(function(d, i) {
          return i === root.size() - 1;
        }).selectAll(".gl-canvas-context, .gl-canvas-focus");
        function canvasToImage() {
          var canvas = this;
          var imageData = canvas.toDataURL("image/png");
          var image = imageRoot.append("svg:image");
          image.attr({
            xmlns: xmlnsNamespaces.svg,
            "xlink:href": imageData,
            preserveAspectRatio: "none",
            x: 0,
            y: 0,
            width: canvas.style.width,
            height: canvas.style.height
          });
        }
        canvases.each(canvasToImage);
      };
      exports.updateFx = require_graph_interact().updateFx;
    }
  });

  // src/traces/scatter/index.js
  var require_scatter = __commonJS({
    "src/traces/scatter/index.js"(exports, module) {
      "use strict";
      var subtypes = require_subtypes();
      module.exports = {
        hasLines: subtypes.hasLines,
        hasMarkers: subtypes.hasMarkers,
        hasText: subtypes.hasText,
        isBubble: subtypes.isBubble,
        attributes: require_attributes12(),
        layoutAttributes: require_layout_attributes3(),
        supplyDefaults: require_defaults8(),
        crossTraceDefaults: require_cross_trace_defaults2(),
        supplyLayoutDefaults: require_layout_defaults3(),
        calc: require_calc3().calc,
        crossTraceCalc: require_cross_trace_calc2(),
        arraysToCalcdata: require_arrays_to_calcdata(),
        plot: require_plot(),
        colorbar: require_marker_colorbar(),
        formatLabels: require_format_labels(),
        style: require_style2().style,
        styleOnSelect: require_style2().styleOnSelect,
        hoverPoints: require_hover2(),
        selectPoints: require_select2(),
        animatable: true,
        moduleType: "trace",
        name: "scatter",
        basePlotModule: require_cartesian(),
        categories: [
          "cartesian",
          "svg",
          "symbols",
          "errorBarsOK",
          "showLegend",
          "scatter-like",
          "zoomScale"
        ],
        meta: {}
      };
    }
  });

  // src/components/annotations/draw_arrow_head.js
  var require_draw_arrow_head = __commonJS({
    "src/components/annotations/draw_arrow_head.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Color = require_color();
      var ARROWPATHS = require_arrow_paths();
      var Lib = require_lib();
      var strScale = Lib.strScale;
      var strRotate = Lib.strRotate;
      var strTranslate = Lib.strTranslate;
      module.exports = function drawArrowHead(el3, ends, options) {
        var el = el3.node();
        var headStyle = ARROWPATHS[options.arrowhead || 0];
        var startHeadStyle = ARROWPATHS[options.startarrowhead || 0];
        var scale = (options.arrowwidth || 1) * (options.arrowsize || 1);
        var startScale = (options.arrowwidth || 1) * (options.startarrowsize || 1);
        var doStart = ends.indexOf("start") >= 0;
        var doEnd = ends.indexOf("end") >= 0;
        var backOff = headStyle.backoff * scale + options.standoff;
        var startBackOff = startHeadStyle.backoff * startScale + options.startstandoff;
        var start, end, startRot, endRot;
        if (el.nodeName === "line") {
          start = { x: +el3.attr("x1"), y: +el3.attr("y1") };
          end = { x: +el3.attr("x2"), y: +el3.attr("y2") };
          var dx = start.x - end.x;
          var dy = start.y - end.y;
          startRot = Math.atan2(dy, dx);
          endRot = startRot + Math.PI;
          if (backOff && startBackOff) {
            if (backOff + startBackOff > Math.sqrt(dx * dx + dy * dy)) {
              hideLine();
              return;
            }
          }
          if (backOff) {
            if (backOff * backOff > dx * dx + dy * dy) {
              hideLine();
              return;
            }
            var backOffX = backOff * Math.cos(startRot);
            var backOffY = backOff * Math.sin(startRot);
            end.x += backOffX;
            end.y += backOffY;
            el3.attr({ x2: end.x, y2: end.y });
          }
          if (startBackOff) {
            if (startBackOff * startBackOff > dx * dx + dy * dy) {
              hideLine();
              return;
            }
            var startBackOffX = startBackOff * Math.cos(startRot);
            var startbackOffY = startBackOff * Math.sin(startRot);
            start.x -= startBackOffX;
            start.y -= startbackOffY;
            el3.attr({ x1: start.x, y1: start.y });
          }
        } else if (el.nodeName === "path") {
          var pathlen = el.getTotalLength();
          var dashArray = "";
          if (pathlen < backOff + startBackOff) {
            hideLine();
            return;
          }
          var start0 = el.getPointAtLength(0);
          var dstart = el.getPointAtLength(0.1);
          startRot = Math.atan2(start0.y - dstart.y, start0.x - dstart.x);
          start = el.getPointAtLength(Math.min(startBackOff, pathlen));
          dashArray = "0px," + startBackOff + "px,";
          var end0 = el.getPointAtLength(pathlen);
          var dend = el.getPointAtLength(pathlen - 0.1);
          endRot = Math.atan2(end0.y - dend.y, end0.x - dend.x);
          end = el.getPointAtLength(Math.max(0, pathlen - backOff));
          var shortening = dashArray ? startBackOff + backOff : backOff;
          dashArray += pathlen - shortening + "px," + pathlen + "px";
          el3.style("stroke-dasharray", dashArray);
        }
        function hideLine() {
          el3.style("stroke-dasharray", "0px,100px");
        }
        function drawhead(arrowHeadStyle, p, rot, arrowScale) {
          if (!arrowHeadStyle.path) return;
          if (arrowHeadStyle.noRotate) rot = 0;
          d3.select(el.parentNode).append("path").attr({
            class: el3.attr("class"),
            d: arrowHeadStyle.path,
            transform: strTranslate(p.x, p.y) + strRotate(rot * 180 / Math.PI) + strScale(arrowScale)
          }).style({
            fill: Color.rgb(options.arrowcolor),
            "stroke-width": 0
          });
        }
        if (doStart) drawhead(startHeadStyle, start, startRot, startScale);
        if (doEnd) drawhead(headStyle, end, endRot, scale);
      };
    }
  });

  // src/components/annotations/draw.js
  var require_draw4 = __commonJS({
    "src/components/annotations/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Axes = require_axes();
      var Color = require_color();
      var Drawing = require_drawing();
      var Fx = require_fx();
      var svgTextUtils = require_svg_text_utils();
      var setCursor = require_setcursor();
      var dragElement = require_dragelement();
      var arrayEditor = require_plot_template().arrayEditor;
      var drawArrowHead = require_draw_arrow_head();
      module.exports = {
        draw,
        drawOne,
        drawRaw
      };
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        fullLayout._infolayer.selectAll(".annotation").remove();
        for (var i = 0; i < fullLayout.annotations.length; i++) {
          if (fullLayout.annotations[i].visible) {
            drawOne(gd, i);
          }
        }
        return Plots.previousPromises(gd);
      }
      function drawOne(gd, index) {
        var fullLayout = gd._fullLayout;
        var options = fullLayout.annotations[index] || {};
        var xa = Axes.getFromId(gd, options.xref);
        var ya = Axes.getFromId(gd, options.yref);
        if (xa) xa.setScale();
        if (ya) ya.setScale();
        drawRaw(gd, options, index, false, xa, ya);
      }
      function shiftPosition(axa, dAx, axLetter, gs, options) {
        var optAx = options[axLetter];
        var axRef = options[axLetter + "ref"];
        var vertical = axLetter.indexOf("y") !== -1;
        var axDomainRef = Axes.getRefType(axRef) === "domain";
        var gsDim = vertical ? gs.h : gs.w;
        if (axa) {
          if (axDomainRef) {
            return optAx + (vertical ? -dAx : dAx) / axa._length;
          } else {
            return axa.p2r(axa.r2p(optAx) + dAx);
          }
        } else {
          return optAx + (vertical ? -dAx : dAx) / gsDim;
        }
      }
      function drawRaw(gd, options, index, subplotId, xa, ya) {
        var fullLayout = gd._fullLayout;
        var gs = gd._fullLayout._size;
        var edits = gd._context.edits;
        var className, containerStr;
        if (subplotId) {
          className = "annotation-" + subplotId;
          containerStr = subplotId + ".annotations";
        } else {
          className = "annotation";
          containerStr = "annotations";
        }
        var editHelpers = arrayEditor(gd.layout, containerStr, options);
        var modifyBase = editHelpers.modifyBase;
        var modifyItem = editHelpers.modifyItem;
        var getUpdateObj = editHelpers.getUpdateObj;
        fullLayout._infolayer.selectAll("." + className + '[data-index="' + index + '"]').remove();
        var annClipID = "clip" + fullLayout._uid + "_ann" + index;
        if (!options._input || options.visible === false) {
          d3.selectAll("#" + annClipID).remove();
          return;
        }
        var annPosPx = { x: {}, y: {} };
        var textangle = +options.textangle || 0;
        var annGroup = fullLayout._infolayer.append("g").classed(className, true).attr("data-index", String(index)).style("opacity", options.opacity);
        var annTextGroup = annGroup.append("g").classed("annotation-text-g", true);
        var editTextPosition = edits[options.showarrow ? "annotationTail" : "annotationPosition"];
        var textEvents = options.captureevents || edits.annotationText || editTextPosition;
        function makeEventData(initialEvent) {
          var eventData = {
            index,
            annotation: options._input,
            fullAnnotation: options,
            event: initialEvent
          };
          if (subplotId) {
            eventData.subplotId = subplotId;
          }
          return eventData;
        }
        var annTextGroupInner = annTextGroup.append("g").style("pointer-events", textEvents ? "all" : null).call(setCursor, "pointer").on("click", function() {
          gd._dragging = false;
          gd.emit("plotly_clickannotation", makeEventData(d3.event));
        });
        if (options.hovertext) {
          annTextGroupInner.on("mouseover", function() {
            var hoverOptions = options.hoverlabel;
            var hoverFont = hoverOptions.font;
            var bBox = this.getBoundingClientRect();
            var bBoxRef = gd.getBoundingClientRect();
            Fx.loneHover({
              x0: bBox.left - bBoxRef.left,
              x1: bBox.right - bBoxRef.left,
              y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,
              text: options.hovertext,
              color: hoverOptions.bgcolor,
              borderColor: hoverOptions.bordercolor,
              fontFamily: hoverFont.family,
              fontSize: hoverFont.size,
              fontColor: hoverFont.color,
              fontWeight: hoverFont.weight,
              fontStyle: hoverFont.style,
              fontVariant: hoverFont.variant,
              fontShadow: hoverFont.fontShadow,
              fontLineposition: hoverFont.fontLineposition,
              fontTextcase: hoverFont.fontTextcase
            }, {
              container: fullLayout._hoverlayer.node(),
              outerContainer: fullLayout._paper.node(),
              gd
            });
          }).on("mouseout", function() {
            Fx.loneUnhover(fullLayout._hoverlayer.node());
          });
        }
        var borderwidth = options.borderwidth;
        var borderpad = options.borderpad;
        var borderfull = borderwidth + borderpad;
        var annTextBG = annTextGroupInner.append("rect").attr("class", "bg").style("stroke-width", borderwidth + "px").call(Color.stroke, options.bordercolor).call(Color.fill, options.bgcolor);
        var isSizeConstrained = options.width || options.height;
        var annTextClip = fullLayout._topclips.selectAll("#" + annClipID).data(isSizeConstrained ? [0] : []);
        annTextClip.enter().append("clipPath").classed("annclip", true).attr("id", annClipID).append("rect");
        annTextClip.exit().remove();
        var font = options.font;
        var text = fullLayout._meta ? Lib.templateString(options.text, fullLayout._meta) : options.text;
        var annText = annTextGroupInner.append("text").classed("annotation-text", true).text(text);
        function textLayout(s) {
          s.call(Drawing.font, font).attr({
            "text-anchor": {
              left: "start",
              right: "end"
            }[options.align] || "middle"
          });
          svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);
          return s;
        }
        function drawGraphicalElements() {
          var anchor3 = annText.selectAll("a");
          if (anchor3.size() === 1 && anchor3.text() === annText.text()) {
            var wholeLink = annTextGroupInner.insert("a", ":first-child").attr({
              "xlink:xlink:href": anchor3.attr("xlink:href"),
              "xlink:xlink:show": anchor3.attr("xlink:show")
            }).style({ cursor: "pointer" });
            wholeLink.node().appendChild(annTextBG.node());
          }
          var mathjaxGroup = annTextGroupInner.select(".annotation-text-math-group");
          var hasMathjax = !mathjaxGroup.empty();
          var anntextBB = Drawing.bBox(
            (hasMathjax ? mathjaxGroup : annText).node()
          );
          var textWidth = anntextBB.width;
          var textHeight = anntextBB.height;
          var annWidth = options.width || textWidth;
          var annHeight = options.height || textHeight;
          var outerWidth = Math.round(annWidth + 2 * borderfull);
          var outerHeight = Math.round(annHeight + 2 * borderfull);
          function shiftFraction(v, anchor2) {
            if (anchor2 === "auto") {
              if (v < 1 / 3) anchor2 = "left";
              else if (v > 2 / 3) anchor2 = "right";
              else anchor2 = "center";
            }
            return {
              center: 0,
              middle: 0,
              left: 0.5,
              bottom: -0.5,
              right: -0.5,
              top: 0.5
            }[anchor2];
          }
          var annotationIsOffscreen = false;
          var letters = ["x", "y"];
          for (var i = 0; i < letters.length; i++) {
            var axLetter = letters[i];
            var axRef = options[axLetter + "ref"] || axLetter;
            var tailRef = options["a" + axLetter + "ref"];
            var ax = { x: xa, y: ya }[axLetter];
            var dimAngle = (textangle + (axLetter === "x" ? 0 : -90)) * Math.PI / 180;
            var annSizeFromWidth = outerWidth * Math.cos(dimAngle);
            var annSizeFromHeight = outerHeight * Math.sin(dimAngle);
            var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);
            var anchor = options[axLetter + "anchor"];
            var overallShift = options[axLetter + "shift"] * (axLetter === "x" ? 1 : -1);
            var posPx = annPosPx[axLetter];
            var basePx;
            var textPadShift;
            var alignPosition;
            var autoAlignFraction;
            var textShift;
            var axRefType = Axes.getRefType(axRef);
            if (ax && axRefType !== "domain") {
              var posFraction = ax.r2fraction(options[axLetter]);
              if (posFraction < 0 || posFraction > 1) {
                if (tailRef === axRef) {
                  posFraction = ax.r2fraction(options["a" + axLetter]);
                  if (posFraction < 0 || posFraction > 1) {
                    annotationIsOffscreen = true;
                  }
                } else {
                  annotationIsOffscreen = true;
                }
              }
              basePx = ax._offset + ax.r2p(options[axLetter]);
              autoAlignFraction = 0.5;
            } else {
              var axRefTypeEqDomain = axRefType === "domain";
              if (axLetter === "x") {
                alignPosition = options[axLetter];
                basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.l + gs.w * alignPosition;
              } else {
                alignPosition = 1 - options[axLetter];
                basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.t + gs.h * alignPosition;
              }
              autoAlignFraction = options.showarrow ? 0.5 : alignPosition;
            }
            if (options.showarrow) {
              posPx.head = basePx;
              var arrowLength = options["a" + axLetter];
              textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) - annSizeFromHeight * shiftFraction(0.5, options.yanchor);
              if (tailRef === axRef) {
                var tailRefType = Axes.getRefType(tailRef);
                if (tailRefType === "domain") {
                  if (axLetter === "y") {
                    arrowLength = 1 - arrowLength;
                  }
                  posPx.tail = ax._offset + ax._length * arrowLength;
                } else if (tailRefType === "paper") {
                  if (axLetter === "y") {
                    arrowLength = 1 - arrowLength;
                    posPx.tail = gs.t + gs.h * arrowLength;
                  } else {
                    posPx.tail = gs.l + gs.w * arrowLength;
                  }
                } else {
                  posPx.tail = ax._offset + ax.r2p(arrowLength);
                }
                textPadShift = textShift;
              } else {
                posPx.tail = basePx + arrowLength;
                textPadShift = textShift + arrowLength;
              }
              posPx.text = posPx.tail + textShift;
              var maxPx = fullLayout[axLetter === "x" ? "width" : "height"];
              if (axRef === "paper") {
                posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);
              }
              if (tailRef === "pixel") {
                var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);
                var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;
                if (shiftPlus > 0) {
                  posPx.tail += shiftPlus;
                  posPx.text += shiftPlus;
                } else if (shiftMinus > 0) {
                  posPx.tail -= shiftMinus;
                  posPx.text -= shiftMinus;
                }
              }
              posPx.tail += overallShift;
              posPx.head += overallShift;
            } else {
              textShift = annSize * shiftFraction(autoAlignFraction, anchor);
              textPadShift = textShift;
              posPx.text = basePx + textShift;
            }
            posPx.text += overallShift;
            textShift += overallShift;
            textPadShift += overallShift;
            options["_" + axLetter + "padplus"] = annSize / 2 + textPadShift;
            options["_" + axLetter + "padminus"] = annSize / 2 - textPadShift;
            options["_" + axLetter + "size"] = annSize;
            options["_" + axLetter + "shift"] = textShift;
          }
          if (annotationIsOffscreen) {
            annTextGroupInner.remove();
            return;
          }
          var xShift = 0;
          var yShift = 0;
          if (options.align !== "left") {
            xShift = (annWidth - textWidth) * (options.align === "center" ? 0.5 : 1);
          }
          if (options.valign !== "top") {
            yShift = (annHeight - textHeight) * (options.valign === "middle" ? 0.5 : 1);
          }
          if (hasMathjax) {
            mathjaxGroup.select("svg").attr({
              x: borderfull + xShift - 1,
              y: borderfull + yShift
            }).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);
          } else {
            var texty = borderfull + yShift - anntextBB.top;
            var textx = borderfull + xShift - anntextBB.left;
            annText.call(svgTextUtils.positionText, textx, texty).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);
          }
          annTextClip.select("rect").call(
            Drawing.setRect,
            borderfull,
            borderfull,
            annWidth,
            annHeight
          );
          annTextBG.call(
            Drawing.setRect,
            borderwidth / 2,
            borderwidth / 2,
            outerWidth - borderwidth,
            outerHeight - borderwidth
          );
          annTextGroupInner.call(
            Drawing.setTranslate,
            Math.round(annPosPx.x.text - outerWidth / 2),
            Math.round(annPosPx.y.text - outerHeight / 2)
          );
          annTextGroup.attr({ transform: "rotate(" + textangle + "," + annPosPx.x.text + "," + annPosPx.y.text + ")" });
          var drawArrow = function(dx, dy) {
            annGroup.selectAll(".annotation-arrow-g").remove();
            var headX = annPosPx.x.head;
            var headY = annPosPx.y.head;
            var tailX = annPosPx.x.tail + dx;
            var tailY = annPosPx.y.tail + dy;
            var textX = annPosPx.x.text + dx;
            var textY = annPosPx.y.text + dy;
            var transform = Lib.rotationXYMatrix(textangle, textX, textY);
            var applyTransform = Lib.apply2DTransform(transform);
            var applyTransform2 = Lib.apply2DTransform2(transform);
            var width = +annTextBG.attr("width");
            var height = +annTextBG.attr("height");
            var xLeft = textX - 0.5 * width;
            var xRight = xLeft + width;
            var yTop = textY - 0.5 * height;
            var yBottom = yTop + height;
            var edges = [
              [xLeft, yTop, xLeft, yBottom],
              [xLeft, yBottom, xRight, yBottom],
              [xRight, yBottom, xRight, yTop],
              [xRight, yTop, xLeft, yTop]
            ].map(applyTransform2);
            if (edges.reduce(function(a, x) {
              return a ^ !!Lib.segmentsIntersect(
                headX,
                headY,
                headX + 1e6,
                headY + 1e6,
                x[0],
                x[1],
                x[2],
                x[3]
              );
            }, false)) {
              return;
            }
            edges.forEach(function(x) {
              var p = Lib.segmentsIntersect(
                tailX,
                tailY,
                headX,
                headY,
                x[0],
                x[1],
                x[2],
                x[3]
              );
              if (p) {
                tailX = p.x;
                tailY = p.y;
              }
            });
            var strokewidth = options.arrowwidth;
            var arrowColor = options.arrowcolor;
            var arrowSide = options.arrowside;
            var arrowGroup = annGroup.append("g").style({ opacity: Color.opacity(arrowColor) }).classed("annotation-arrow-g", true);
            var arrow = arrowGroup.append("path").attr("d", "M" + tailX + "," + tailY + "L" + headX + "," + headY).style("stroke-width", strokewidth + "px").call(Color.stroke, Color.rgb(arrowColor));
            drawArrowHead(arrow, arrowSide, options);
            if (edits.annotationPosition && arrow.node().parentNode && !subplotId) {
              var arrowDragHeadX = headX;
              var arrowDragHeadY = headY;
              if (options.standoff) {
                var arrowLength2 = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));
                arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength2;
                arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength2;
              }
              var arrowDrag = arrowGroup.append("path").classed("annotation-arrow", true).classed("anndrag", true).classed("cursor-move", true).attr({
                d: "M3,3H-3V-3H3ZM0,0L" + (tailX - arrowDragHeadX) + "," + (tailY - arrowDragHeadY),
                transform: strTranslate(arrowDragHeadX, arrowDragHeadY)
              }).style("stroke-width", strokewidth + 6 + "px").call(Color.stroke, "rgba(0,0,0,0)").call(Color.fill, "rgba(0,0,0,0)");
              var annx0, anny0;
              dragElement.init({
                element: arrowDrag.node(),
                gd,
                prepFn: function() {
                  var pos = Drawing.getTranslate(annTextGroupInner);
                  annx0 = pos.x;
                  anny0 = pos.y;
                  if (xa && xa.autorange) {
                    modifyBase(xa._name + ".autorange", true);
                  }
                  if (ya && ya.autorange) {
                    modifyBase(ya._name + ".autorange", true);
                  }
                },
                moveFn: function(dx2, dy2) {
                  var annxy0 = applyTransform(annx0, anny0);
                  var xcenter = annxy0[0] + dx2;
                  var ycenter = annxy0[1] + dy2;
                  annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);
                  modifyItem(
                    "x",
                    shiftPosition(xa, dx2, "x", gs, options)
                  );
                  modifyItem(
                    "y",
                    shiftPosition(ya, dy2, "y", gs, options)
                  );
                  if (options.axref === options.xref) {
                    modifyItem("ax", shiftPosition(xa, dx2, "ax", gs, options));
                  }
                  if (options.ayref === options.yref) {
                    modifyItem("ay", shiftPosition(ya, dy2, "ay", gs, options));
                  }
                  arrowGroup.attr("transform", strTranslate(dx2, dy2));
                  annTextGroup.attr({
                    transform: "rotate(" + textangle + "," + xcenter + "," + ycenter + ")"
                  });
                },
                doneFn: function() {
                  Registry.call("_guiRelayout", gd, getUpdateObj());
                  var notesBox = document.querySelector(".js-notes-box-panel");
                  if (notesBox) notesBox.redraw(notesBox.selectedObj);
                }
              });
            }
          };
          if (options.showarrow) drawArrow(0, 0);
          if (editTextPosition) {
            var baseTextTransform;
            dragElement.init({
              element: annTextGroupInner.node(),
              gd,
              prepFn: function() {
                baseTextTransform = annTextGroup.attr("transform");
              },
              moveFn: function(dx, dy) {
                var csr = "pointer";
                if (options.showarrow) {
                  if (options.axref === options.xref) {
                    modifyItem("ax", shiftPosition(xa, dx, "ax", gs, options));
                  } else {
                    modifyItem("ax", options.ax + dx);
                  }
                  if (options.ayref === options.yref) {
                    modifyItem("ay", shiftPosition(ya, dy, "ay", gs.w, options));
                  } else {
                    modifyItem("ay", options.ay + dy);
                  }
                  drawArrow(dx, dy);
                } else if (!subplotId) {
                  var xUpdate, yUpdate;
                  if (xa) {
                    xUpdate = shiftPosition(xa, dx, "x", gs, options);
                  } else {
                    var widthFraction = options._xsize / gs.w;
                    var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;
                    xUpdate = dragElement.align(
                      xLeft + dx / gs.w,
                      widthFraction,
                      0,
                      1,
                      options.xanchor
                    );
                  }
                  if (ya) {
                    yUpdate = shiftPosition(ya, dy, "y", gs, options);
                  } else {
                    var heightFraction = options._ysize / gs.h;
                    var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;
                    yUpdate = dragElement.align(
                      yBottom - dy / gs.h,
                      heightFraction,
                      0,
                      1,
                      options.yanchor
                    );
                  }
                  modifyItem("x", xUpdate);
                  modifyItem("y", yUpdate);
                  if (!xa || !ya) {
                    csr = dragElement.getCursor(
                      xa ? 0.5 : xUpdate,
                      ya ? 0.5 : yUpdate,
                      options.xanchor,
                      options.yanchor
                    );
                  }
                } else return;
                annTextGroup.attr({
                  transform: strTranslate(dx, dy) + baseTextTransform
                });
                setCursor(annTextGroupInner, csr);
              },
              clickFn: function(_, initialEvent) {
                if (options.captureevents) {
                  gd.emit("plotly_clickannotation", makeEventData(initialEvent));
                }
              },
              doneFn: function() {
                setCursor(annTextGroupInner);
                Registry.call("_guiRelayout", gd, getUpdateObj());
                var notesBox = document.querySelector(".js-notes-box-panel");
                if (notesBox) notesBox.redraw(notesBox.selectedObj);
              }
            });
          }
        }
        if (edits.annotationText) {
          annText.call(svgTextUtils.makeEditable, { delegate: annTextGroupInner, gd }).call(textLayout).on("edit", function(_text) {
            options.text = _text;
            this.call(textLayout);
            modifyItem("text", _text);
            if (xa && xa.autorange) {
              modifyBase(xa._name + ".autorange", true);
            }
            if (ya && ya.autorange) {
              modifyBase(ya._name + ".autorange", true);
            }
            Registry.call("_guiRelayout", gd, getUpdateObj());
          });
        } else annText.call(textLayout);
      }
    }
  });

  // src/components/annotations/click.js
  var require_click2 = __commonJS({
    "src/components/annotations/click.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      var arrayEditor = require_plot_template().arrayEditor;
      module.exports = {
        hasClickToShow,
        onClick
      };
      function hasClickToShow(gd, hoverData) {
        var sets = getToggleSets(gd, hoverData);
        return sets.on.length > 0 || sets.explicitOff.length > 0;
      }
      function onClick(gd, hoverData) {
        var toggleSets = getToggleSets(gd, hoverData);
        var onSet = toggleSets.on;
        var offSet = toggleSets.off.concat(toggleSets.explicitOff);
        var update = {};
        var annotationsOut = gd._fullLayout.annotations;
        var i, editHelpers;
        if (!(onSet.length || offSet.length)) return;
        for (i = 0; i < onSet.length; i++) {
          editHelpers = arrayEditor(gd.layout, "annotations", annotationsOut[onSet[i]]);
          editHelpers.modifyItem("visible", true);
          Lib.extendFlat(update, editHelpers.getUpdateObj());
        }
        for (i = 0; i < offSet.length; i++) {
          editHelpers = arrayEditor(gd.layout, "annotations", annotationsOut[offSet[i]]);
          editHelpers.modifyItem("visible", false);
          Lib.extendFlat(update, editHelpers.getUpdateObj());
        }
        return Registry.call("update", gd, {}, update);
      }
      function getToggleSets(gd, hoverData) {
        var annotations = gd._fullLayout.annotations;
        var onSet = [];
        var offSet = [];
        var explicitOffSet = [];
        var hoverLen = (hoverData || []).length;
        var i, j, anni, showMode, pointj, xa, ya, toggleType;
        for (i = 0; i < annotations.length; i++) {
          anni = annotations[i];
          showMode = anni.clicktoshow;
          if (showMode) {
            for (j = 0; j < hoverLen; j++) {
              pointj = hoverData[j];
              xa = pointj.xaxis;
              ya = pointj.yaxis;
              if (xa._id === anni.xref && ya._id === anni.yref && xa.d2r(pointj.x) === clickData2r(anni._xclick, xa) && ya.d2r(pointj.y) === clickData2r(anni._yclick, ya)) {
                if (anni.visible) {
                  if (showMode === "onout") toggleType = offSet;
                  else toggleType = explicitOffSet;
                } else {
                  toggleType = onSet;
                }
                toggleType.push(i);
                break;
              }
            }
            if (j === hoverLen) {
              if (anni.visible && showMode === "onout") offSet.push(i);
            }
          }
        }
        return { on: onSet, off: offSet, explicitOff: explicitOffSet };
      }
      function clickData2r(d, ax) {
        return ax.type === "log" ? ax.l2r(d) : ax.d2r(d);
      }
    }
  });

  // src/components/annotations/common_defaults.js
  var require_common_defaults = __commonJS({
    "src/components/annotations/common_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      module.exports = function handleAnnotationCommonDefaults(annIn, annOut, fullLayout, coerce) {
        coerce("opacity");
        var bgColor = coerce("bgcolor");
        var borderColor = coerce("bordercolor");
        var borderOpacity = Color.opacity(borderColor);
        coerce("borderpad");
        var borderWidth = coerce("borderwidth");
        var showArrow = coerce("showarrow");
        coerce("text", showArrow ? " " : fullLayout._dfltTitle.annotation);
        coerce("textangle");
        Lib.coerceFont(coerce, "font", fullLayout.font);
        coerce("width");
        coerce("align");
        var h = coerce("height");
        if (h) coerce("valign");
        if (showArrow) {
          var arrowside = coerce("arrowside");
          var arrowhead;
          var arrowsize;
          if (arrowside.indexOf("end") !== -1) {
            arrowhead = coerce("arrowhead");
            arrowsize = coerce("arrowsize");
          }
          if (arrowside.indexOf("start") !== -1) {
            coerce("startarrowhead", arrowhead);
            coerce("startarrowsize", arrowsize);
          }
          coerce("arrowcolor", borderOpacity ? annOut.bordercolor : Color.defaultLine);
          coerce("arrowwidth", (borderOpacity && borderWidth || 1) * 2);
          coerce("standoff");
          coerce("startstandoff");
        }
        var hoverText = coerce("hovertext");
        var globalHoverLabel = fullLayout.hoverlabel || {};
        if (hoverText) {
          var hoverBG = coerce(
            "hoverlabel.bgcolor",
            globalHoverLabel.bgcolor || (Color.opacity(bgColor) ? Color.rgb(bgColor) : Color.defaultLine)
          );
          var hoverBorder = coerce(
            "hoverlabel.bordercolor",
            globalHoverLabel.bordercolor || Color.contrast(hoverBG)
          );
          var fontDflt = Lib.extendFlat({}, globalHoverLabel.font);
          if (!fontDflt.color) {
            fontDflt.color = hoverBorder;
          }
          Lib.coerceFont(coerce, "hoverlabel.font", fontDflt);
        }
        coerce("captureevents", !!hoverText);
      };
    }
  });

  // src/components/annotations/defaults.js
  var require_defaults9 = __commonJS({
    "src/components/annotations/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var handleAnnotationCommonDefaults = require_common_defaults();
      var attributes = require_attributes11();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name: "annotations",
          handleItemDefaults: handleAnnotationDefaults
        });
      };
      function handleAnnotationDefaults(annIn, annOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(annIn, annOut, attributes, attr, dflt);
        }
        var visible = coerce("visible");
        var clickToShow = coerce("clicktoshow");
        if (!(visible || clickToShow)) return;
        handleAnnotationCommonDefaults(annIn, annOut, fullLayout, coerce);
        var showArrow = annOut.showarrow;
        var axLetters = ["x", "y"];
        var arrowPosDflt = [-10, -30];
        var gdMock = { _fullLayout: fullLayout };
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var axRef = Axes.coerceRef(annIn, annOut, gdMock, axLetter, "", "paper");
          if (axRef !== "paper") {
            var ax = Axes.getFromId(gdMock, axRef);
            ax._annIndices.push(annOut._index);
          }
          Axes.coercePosition(annOut, gdMock, coerce, axRef, axLetter, 0.5);
          if (showArrow) {
            var arrowPosAttr = "a" + axLetter;
            var aaxRef = Axes.coerceRef(
              annIn,
              annOut,
              gdMock,
              arrowPosAttr,
              "pixel",
              ["pixel", "paper"]
            );
            if (aaxRef !== "pixel" && aaxRef !== axRef) {
              aaxRef = annOut[arrowPosAttr] = "pixel";
            }
            var aDflt = aaxRef === "pixel" ? arrowPosDflt[i] : 0.4;
            Axes.coercePosition(annOut, gdMock, coerce, aaxRef, arrowPosAttr, aDflt);
          }
          coerce(axLetter + "anchor");
          coerce(axLetter + "shift");
        }
        Lib.noneOrAll(annIn, annOut, ["x", "y"]);
        if (showArrow) {
          Lib.noneOrAll(annIn, annOut, ["ax", "ay"]);
        }
        if (clickToShow) {
          var xClick = coerce("xclick");
          var yClick = coerce("yclick");
          annOut._xclick = xClick === void 0 ? annOut.x : Axes.cleanPosition(xClick, gdMock, annOut.xref);
          annOut._yclick = yClick === void 0 ? annOut.y : Axes.cleanPosition(yClick, gdMock, annOut.yref);
        }
      }
    }
  });

  // src/components/annotations/calc_autorange.js
  var require_calc_autorange = __commonJS({
    "src/components/annotations/calc_autorange.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var draw = require_draw4().draw;
      module.exports = function calcAutorange(gd) {
        var fullLayout = gd._fullLayout;
        var annotationList = Lib.filterVisible(fullLayout.annotations);
        if (annotationList.length && gd._fullData.length) {
          return Lib.syncOrAsync([draw, annAutorange], gd);
        }
      };
      function annAutorange(gd) {
        var fullLayout = gd._fullLayout;
        Lib.filterVisible(fullLayout.annotations).forEach(function(ann) {
          var xa = Axes.getFromId(gd, ann.xref);
          var ya = Axes.getFromId(gd, ann.yref);
          var xRefType = Axes.getRefType(ann.xref);
          var yRefType = Axes.getRefType(ann.yref);
          ann._extremes = {};
          if (xRefType === "range") calcAxisExpansion(ann, xa);
          if (yRefType === "range") calcAxisExpansion(ann, ya);
        });
      }
      function calcAxisExpansion(ann, ax) {
        var axId = ax._id;
        var letter = axId.charAt(0);
        var pos = ann[letter];
        var apos = ann["a" + letter];
        var ref = ann[letter + "ref"];
        var aref = ann["a" + letter + "ref"];
        var padplus = ann["_" + letter + "padplus"];
        var padminus = ann["_" + letter + "padminus"];
        var shift = { x: 1, y: -1 }[letter] * ann[letter + "shift"];
        var headSize = 3 * ann.arrowsize * ann.arrowwidth || 0;
        var headPlus = headSize + shift;
        var headMinus = headSize - shift;
        var startHeadSize = 3 * ann.startarrowsize * ann.arrowwidth || 0;
        var startHeadPlus = startHeadSize + shift;
        var startHeadMinus = startHeadSize - shift;
        var extremes;
        if (aref === ref) {
          var extremeArrowHead = Axes.findExtremes(ax, [ax.r2c(pos)], {
            ppadplus: headPlus,
            ppadminus: headMinus
          });
          var extremeText = Axes.findExtremes(ax, [ax.r2c(apos)], {
            ppadplus: Math.max(padplus, startHeadPlus),
            ppadminus: Math.max(padminus, startHeadMinus)
          });
          extremes = {
            min: [extremeArrowHead.min[0], extremeText.min[0]],
            max: [extremeArrowHead.max[0], extremeText.max[0]]
          };
        } else {
          startHeadPlus = apos ? startHeadPlus + apos : startHeadPlus;
          startHeadMinus = apos ? startHeadMinus - apos : startHeadMinus;
          extremes = Axes.findExtremes(ax, [ax.r2c(pos)], {
            ppadplus: Math.max(padplus, headPlus, startHeadPlus),
            ppadminus: Math.max(padminus, headMinus, startHeadMinus)
          });
        }
        ann._extremes[axId] = extremes;
      }
    }
  });

  // src/components/annotations/convert_coords.js
  var require_convert_coords = __commonJS({
    "src/components/annotations/convert_coords.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var toLogRange = require_to_log_range();
      module.exports = function convertCoords(gd, ax, newType, doExtra) {
        ax = ax || {};
        var toLog = newType === "log" && ax.type === "linear";
        var fromLog = newType === "linear" && ax.type === "log";
        if (!(toLog || fromLog)) return;
        var annotations = gd._fullLayout.annotations;
        var axLetter = ax._id.charAt(0);
        var ann;
        var attrPrefix;
        function convert(attr) {
          var currentVal = ann[attr];
          var newVal = null;
          if (toLog) newVal = toLogRange(currentVal, ax.range);
          else newVal = Math.pow(10, currentVal);
          if (!isNumeric(newVal)) newVal = null;
          doExtra(attrPrefix + attr, newVal);
        }
        for (var i = 0; i < annotations.length; i++) {
          ann = annotations[i];
          attrPrefix = "annotations[" + i + "].";
          if (ann[axLetter + "ref"] === ax._id) convert(axLetter);
          if (ann["a" + axLetter + "ref"] === ax._id) convert("a" + axLetter);
        }
      };
    }
  });

  // src/components/annotations/index.js
  var require_annotations = __commonJS({
    "src/components/annotations/index.js"(exports, module) {
      "use strict";
      var drawModule = require_draw4();
      var clickModule = require_click2();
      module.exports = {
        moduleType: "component",
        name: "annotations",
        layoutAttributes: require_attributes11(),
        supplyLayoutDefaults: require_defaults9(),
        includeBasePlot: require_include_components()("annotations"),
        calcAutorange: require_calc_autorange(),
        draw: drawModule.draw,
        drawOne: drawModule.drawOne,
        drawRaw: drawModule.drawRaw,
        hasClickToShow: clickModule.hasClickToShow,
        onClick: clickModule.onClick,
        convertCoords: require_convert_coords()
      };
    }
  });

  // src/components/annotations3d/attributes.js
  var require_attributes15 = __commonJS({
    "src/components/annotations3d/attributes.js"(exports, module) {
      "use strict";
      var annAttrs = require_attributes11();
      var overrideAll = require_edit_types().overrideAll;
      var templatedArray = require_plot_template().templatedArray;
      module.exports = overrideAll(templatedArray("annotation", {
        visible: annAttrs.visible,
        x: {
          valType: "any"
        },
        y: {
          valType: "any"
        },
        z: {
          valType: "any"
        },
        ax: {
          valType: "number"
        },
        ay: {
          valType: "number"
        },
        xanchor: annAttrs.xanchor,
        xshift: annAttrs.xshift,
        yanchor: annAttrs.yanchor,
        yshift: annAttrs.yshift,
        text: annAttrs.text,
        textangle: annAttrs.textangle,
        font: annAttrs.font,
        width: annAttrs.width,
        height: annAttrs.height,
        opacity: annAttrs.opacity,
        align: annAttrs.align,
        valign: annAttrs.valign,
        bgcolor: annAttrs.bgcolor,
        bordercolor: annAttrs.bordercolor,
        borderpad: annAttrs.borderpad,
        borderwidth: annAttrs.borderwidth,
        showarrow: annAttrs.showarrow,
        arrowcolor: annAttrs.arrowcolor,
        arrowhead: annAttrs.arrowhead,
        startarrowhead: annAttrs.startarrowhead,
        arrowside: annAttrs.arrowside,
        arrowsize: annAttrs.arrowsize,
        startarrowsize: annAttrs.startarrowsize,
        arrowwidth: annAttrs.arrowwidth,
        standoff: annAttrs.standoff,
        startstandoff: annAttrs.startstandoff,
        hovertext: annAttrs.hovertext,
        hoverlabel: annAttrs.hoverlabel,
        captureevents: annAttrs.captureevents
        // maybes later?
        // clicktoshow: annAttrs.clicktoshow,
        // xclick: annAttrs.xclick,
        // yclick: annAttrs.yclick,
        // not needed!
        // axref: 'pixel'
        // ayref: 'pixel'
        // xref: 'x'
        // yref: 'y
        // zref: 'z'
      }), "calc", "from-root");
    }
  });

  // src/components/annotations3d/defaults.js
  var require_defaults10 = __commonJS({
    "src/components/annotations3d/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var handleAnnotationCommonDefaults = require_common_defaults();
      var attributes = require_attributes15();
      module.exports = function handleDefaults(sceneLayoutIn, sceneLayoutOut, opts) {
        handleArrayContainerDefaults(sceneLayoutIn, sceneLayoutOut, {
          name: "annotations",
          handleItemDefaults: handleAnnotationDefaults,
          fullLayout: opts.fullLayout
        });
      };
      function handleAnnotationDefaults(annIn, annOut, sceneLayout, opts) {
        function coerce(attr, dflt) {
          return Lib.coerce(annIn, annOut, attributes, attr, dflt);
        }
        function coercePosition(axLetter) {
          var axName = axLetter + "axis";
          var gdMock = { _fullLayout: {} };
          gdMock._fullLayout[axName] = sceneLayout[axName];
          return Axes.coercePosition(annOut, gdMock, coerce, axLetter, axLetter, 0.5);
        }
        var visible = coerce("visible");
        if (!visible) return;
        handleAnnotationCommonDefaults(annIn, annOut, opts.fullLayout, coerce);
        coercePosition("x");
        coercePosition("y");
        coercePosition("z");
        Lib.noneOrAll(annIn, annOut, ["x", "y", "z"]);
        annOut.xref = "x";
        annOut.yref = "y";
        annOut.zref = "z";
        coerce("xanchor");
        coerce("yanchor");
        coerce("xshift");
        coerce("yshift");
        if (annOut.showarrow) {
          annOut.axref = "pixel";
          annOut.ayref = "pixel";
          coerce("ax", -10);
          coerce("ay", -30);
          Lib.noneOrAll(annIn, annOut, ["ax", "ay"]);
        }
      }
    }
  });

  // src/components/annotations3d/convert.js
  var require_convert = __commonJS({
    "src/components/annotations3d/convert.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      module.exports = function convert(scene) {
        var fullSceneLayout = scene.fullSceneLayout;
        var anns = fullSceneLayout.annotations;
        for (var i = 0; i < anns.length; i++) {
          mockAnnAxes(anns[i], scene);
        }
        scene.fullLayout._infolayer.selectAll(".annotation-" + scene.id).remove();
      };
      function mockAnnAxes(ann, scene) {
        var fullSceneLayout = scene.fullSceneLayout;
        var domain = fullSceneLayout.domain;
        var size = scene.fullLayout._size;
        var base = {
          // this gets fill in on render
          pdata: null,
          // to get setConvert to not execute cleanly
          type: "linear",
          // don't try to update them on `editable: true`
          autorange: false,
          // set infinite range so that annotation draw routine
          // does not try to remove 'outside-range' annotations,
          // this case is handled in the render loop
          range: [-Infinity, Infinity]
        };
        ann._xa = {};
        Lib.extendFlat(ann._xa, base);
        Axes.setConvert(ann._xa);
        ann._xa._offset = size.l + domain.x[0] * size.w;
        ann._xa.l2p = function() {
          return 0.5 * (1 + ann._pdata[0] / ann._pdata[3]) * size.w * (domain.x[1] - domain.x[0]);
        };
        ann._ya = {};
        Lib.extendFlat(ann._ya, base);
        Axes.setConvert(ann._ya);
        ann._ya._offset = size.t + (1 - domain.y[1]) * size.h;
        ann._ya.l2p = function() {
          return 0.5 * (1 - ann._pdata[1] / ann._pdata[3]) * size.h * (domain.y[1] - domain.y[0]);
        };
      }
    }
  });

  // src/plots/gl3d/project.js
  var require_project = __commonJS({
    "src/plots/gl3d/project.js"(exports, module) {
      "use strict";
      function xformMatrix(m, v) {
        var out = [0, 0, 0, 0];
        var i, j;
        for (i = 0; i < 4; ++i) {
          for (j = 0; j < 4; ++j) {
            out[j] += m[4 * i + j] * v[i];
          }
        }
        return out;
      }
      function project(camera, v) {
        var p = xformMatrix(
          camera.projection,
          xformMatrix(
            camera.view,
            xformMatrix(camera.model, [v[0], v[1], v[2], 1])
          )
        );
        return p;
      }
      module.exports = project;
    }
  });

  // src/components/annotations3d/draw.js
  var require_draw5 = __commonJS({
    "src/components/annotations3d/draw.js"(exports, module) {
      "use strict";
      var drawRaw = require_draw4().drawRaw;
      var project = require_project();
      var axLetters = ["x", "y", "z"];
      module.exports = function draw(scene) {
        var fullSceneLayout = scene.fullSceneLayout;
        var dataScale = scene.dataScale;
        var anns = fullSceneLayout.annotations;
        for (var i = 0; i < anns.length; i++) {
          var ann = anns[i];
          var annotationIsOffscreen = false;
          for (var j = 0; j < 3; j++) {
            var axLetter = axLetters[j];
            var pos = ann[axLetter];
            var ax = fullSceneLayout[axLetter + "axis"];
            var posFraction = ax.r2fraction(pos);
            if (posFraction < 0 || posFraction > 1) {
              annotationIsOffscreen = true;
              break;
            }
          }
          if (annotationIsOffscreen) {
            scene.fullLayout._infolayer.select(".annotation-" + scene.id + '[data-index="' + i + '"]').remove();
          } else {
            ann._pdata = project(scene.glplot.cameraParams, [
              fullSceneLayout.xaxis.r2l(ann.x) * dataScale[0],
              fullSceneLayout.yaxis.r2l(ann.y) * dataScale[1],
              fullSceneLayout.zaxis.r2l(ann.z) * dataScale[2]
            ]);
            drawRaw(scene.graphDiv, ann, i, scene.id, ann._xa, ann._ya);
          }
        }
      };
    }
  });

  // src/components/annotations3d/index.js
  var require_annotations3d = __commonJS({
    "src/components/annotations3d/index.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      module.exports = {
        moduleType: "component",
        name: "annotations3d",
        schema: {
          subplots: {
            scene: { annotations: require_attributes15() }
          }
        },
        layoutAttributes: require_attributes15(),
        handleDefaults: require_defaults10(),
        includeBasePlot: includeGL3D,
        convert: require_convert(),
        draw: require_draw5()
      };
      function includeGL3D(layoutIn, layoutOut) {
        var GL3D = Registry.subplotsRegistry.gl3d;
        if (!GL3D) return;
        var attrRegex = GL3D.attrRegex;
        var keys = Object.keys(layoutIn);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (attrRegex.test(k) && (layoutIn[k].annotations || []).length) {
            Lib.pushUnique(layoutOut._basePlotModules, GL3D);
            Lib.pushUnique(layoutOut._subplots.gl3d, k);
          }
        }
      }
    }
  });

  // src/components/shapes/attributes.js
  var require_attributes16 = __commonJS({
    "src/components/shapes/attributes.js"(exports, module) {
      "use strict";
      var annAttrs = require_attributes11();
      var fontAttrs = require_font_attributes();
      var scatterLineAttrs = require_attributes12().line;
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      var basePlotAttributes = require_attributes2();
      var shapeTexttemplateAttrs = require_template_attributes().shapeTexttemplateAttrs;
      var shapeLabelTexttemplateVars = require_label_texttemplate();
      module.exports = templatedArray("shape", {
        visible: extendFlat({}, basePlotAttributes.visible, {
          editType: "calc+arraydraw"
        }),
        showlegend: {
          valType: "boolean",
          dflt: false,
          editType: "calc+arraydraw"
        },
        legend: extendFlat({}, basePlotAttributes.legend, {
          editType: "calc+arraydraw"
        }),
        legendgroup: extendFlat({}, basePlotAttributes.legendgroup, {
          editType: "calc+arraydraw"
        }),
        legendgrouptitle: {
          text: extendFlat({}, basePlotAttributes.legendgrouptitle.text, {
            editType: "calc+arraydraw"
          }),
          font: fontAttrs({
            editType: "calc+arraydraw"
          }),
          editType: "calc+arraydraw"
        },
        legendrank: extendFlat({}, basePlotAttributes.legendrank, {
          editType: "calc+arraydraw"
        }),
        legendwidth: extendFlat({}, basePlotAttributes.legendwidth, {
          editType: "calc+arraydraw"
        }),
        type: {
          valType: "enumerated",
          values: ["circle", "rect", "path", "line"],
          editType: "calc+arraydraw"
        },
        layer: {
          valType: "enumerated",
          values: ["below", "above", "between"],
          dflt: "above",
          editType: "arraydraw"
        },
        xref: extendFlat({}, annAttrs.xref, {}),
        xsizemode: {
          valType: "enumerated",
          values: ["scaled", "pixel"],
          dflt: "scaled",
          editType: "calc+arraydraw"
        },
        xanchor: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        x0: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        x1: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        x0shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        x1shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        yref: extendFlat({}, annAttrs.yref, {}),
        ysizemode: {
          valType: "enumerated",
          values: ["scaled", "pixel"],
          dflt: "scaled",
          editType: "calc+arraydraw"
        },
        yanchor: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        y0: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        y1: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        y0shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        y1shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        path: {
          valType: "string",
          editType: "calc+arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "arraydraw"
        },
        line: {
          color: extendFlat({}, scatterLineAttrs.color, { editType: "arraydraw" }),
          width: extendFlat({}, scatterLineAttrs.width, { editType: "calc+arraydraw" }),
          dash: extendFlat({}, dash, { editType: "arraydraw" }),
          editType: "calc+arraydraw"
        },
        fillcolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)",
          editType: "arraydraw"
        },
        fillrule: {
          valType: "enumerated",
          values: ["evenodd", "nonzero"],
          dflt: "evenodd",
          editType: "arraydraw"
        },
        editable: {
          valType: "boolean",
          dflt: false,
          editType: "calc+arraydraw"
        },
        label: {
          text: {
            valType: "string",
            dflt: "",
            editType: "arraydraw"
          },
          texttemplate: shapeTexttemplateAttrs({}, { keys: Object.keys(shapeLabelTexttemplateVars) }),
          font: fontAttrs({
            editType: "calc+arraydraw",
            colorEditType: "arraydraw"
          }),
          textposition: {
            valType: "enumerated",
            values: [
              "top left",
              "top center",
              "top right",
              "middle left",
              "middle center",
              "middle right",
              "bottom left",
              "bottom center",
              "bottom right",
              "start",
              "middle",
              "end"
            ],
            editType: "arraydraw"
          },
          textangle: {
            valType: "angle",
            dflt: "auto",
            editType: "calc+arraydraw"
          },
          xanchor: {
            valType: "enumerated",
            values: ["auto", "left", "center", "right"],
            dflt: "auto",
            editType: "calc+arraydraw"
          },
          yanchor: {
            valType: "enumerated",
            values: ["top", "middle", "bottom"],
            editType: "calc+arraydraw"
          },
          padding: {
            valType: "number",
            dflt: 3,
            min: 0,
            editType: "arraydraw"
          },
          editType: "arraydraw"
        },
        editType: "arraydraw"
      });
    }
  });

  // src/components/shapes/defaults.js
  var require_defaults11 = __commonJS({
    "src/components/shapes/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes16();
      var helpers = require_helpers8();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name: "shapes",
          handleItemDefaults: handleShapeDefaults
        });
      };
      function dfltLabelYanchor(isLine, labelTextPosition) {
        return isLine ? "bottom" : labelTextPosition.indexOf("top") !== -1 ? "top" : labelTextPosition.indexOf("bottom") !== -1 ? "bottom" : "middle";
      }
      function handleShapeDefaults(shapeIn, shapeOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(shapeIn, shapeOut, attributes, attr, dflt);
        }
        shapeOut._isShape = true;
        var visible = coerce("visible");
        if (!visible) return;
        var showlegend = coerce("showlegend");
        if (showlegend) {
          coerce("legend");
          coerce("legendwidth");
          coerce("legendgroup");
          coerce("legendgrouptitle.text");
          Lib.coerceFont(coerce, "legendgrouptitle.font");
          coerce("legendrank");
        }
        var path = coerce("path");
        var dfltType = path ? "path" : "rect";
        var shapeType = coerce("type", dfltType);
        var noPath = shapeType !== "path";
        if (noPath) delete shapeOut.path;
        coerce("editable");
        coerce("layer");
        coerce("opacity");
        coerce("fillcolor");
        coerce("fillrule");
        var lineWidth = coerce("line.width");
        if (lineWidth) {
          coerce("line.color");
          coerce("line.dash");
        }
        var xSizeMode = coerce("xsizemode");
        var ySizeMode = coerce("ysizemode");
        var axLetters = ["x", "y"];
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var attrAnchor = axLetter + "anchor";
          var sizeMode = axLetter === "x" ? xSizeMode : ySizeMode;
          var gdMock = { _fullLayout: fullLayout };
          var ax;
          var pos2r;
          var r2pos;
          var axRef = Axes.coerceRef(
            shapeIn,
            shapeOut,
            gdMock,
            axLetter,
            void 0,
            "paper"
          );
          var axRefType = Axes.getRefType(axRef);
          if (axRefType === "range") {
            ax = Axes.getFromId(gdMock, axRef);
            ax._shapeIndices.push(shapeOut._index);
            r2pos = helpers.rangeToShapePosition(ax);
            pos2r = helpers.shapePositionToRange(ax);
            if (ax.type === "category" || ax.type === "multicategory") {
              coerce(axLetter + "0shift");
              coerce(axLetter + "1shift");
            }
          } else {
            pos2r = r2pos = Lib.identity;
          }
          if (noPath) {
            var dflt0 = 0.25;
            var dflt1 = 0.75;
            var attr0 = axLetter + "0";
            var attr1 = axLetter + "1";
            var in0 = shapeIn[attr0];
            var in1 = shapeIn[attr1];
            shapeIn[attr0] = pos2r(shapeIn[attr0], true);
            shapeIn[attr1] = pos2r(shapeIn[attr1], true);
            if (sizeMode === "pixel") {
              coerce(attr0, 0);
              coerce(attr1, 10);
            } else {
              Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr0, dflt0);
              Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr1, dflt1);
            }
            shapeOut[attr0] = r2pos(shapeOut[attr0]);
            shapeOut[attr1] = r2pos(shapeOut[attr1]);
            shapeIn[attr0] = in0;
            shapeIn[attr1] = in1;
          }
          if (sizeMode === "pixel") {
            var inAnchor = shapeIn[attrAnchor];
            shapeIn[attrAnchor] = pos2r(shapeIn[attrAnchor], true);
            Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attrAnchor, 0.25);
            shapeOut[attrAnchor] = r2pos(shapeOut[attrAnchor]);
            shapeIn[attrAnchor] = inAnchor;
          }
        }
        if (noPath) {
          Lib.noneOrAll(shapeIn, shapeOut, ["x0", "x1", "y0", "y1"]);
        }
        var isLine = shapeType === "line";
        var labelTextTemplate, labelText;
        if (noPath) {
          labelTextTemplate = coerce("label.texttemplate");
        }
        if (!labelTextTemplate) {
          labelText = coerce("label.text");
        }
        if (labelText || labelTextTemplate) {
          coerce("label.textangle");
          var labelTextPosition = coerce("label.textposition", isLine ? "middle" : "middle center");
          coerce("label.xanchor");
          coerce("label.yanchor", dfltLabelYanchor(isLine, labelTextPosition));
          coerce("label.padding");
          Lib.coerceFont(coerce, "label.font", fullLayout.font);
        }
      }
    }
  });

  // src/components/shapes/draw_newshape/defaults.js
  var require_defaults12 = __commonJS({
    "src/components/shapes/draw_newshape/defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var Lib = require_lib();
      function dfltLabelYanchor(isLine, labelTextPosition) {
        return isLine ? "bottom" : labelTextPosition.indexOf("top") !== -1 ? "top" : labelTextPosition.indexOf("bottom") !== -1 ? "bottom" : "middle";
      }
      module.exports = function supplyDrawNewShapeDefaults(layoutIn, layoutOut, coerce) {
        coerce("newshape.visible");
        coerce("newshape.name");
        coerce("newshape.showlegend");
        coerce("newshape.legend");
        coerce("newshape.legendwidth");
        coerce("newshape.legendgroup");
        coerce("newshape.legendgrouptitle.text");
        Lib.coerceFont(coerce, "newshape.legendgrouptitle.font");
        coerce("newshape.legendrank");
        coerce("newshape.drawdirection");
        coerce("newshape.layer");
        coerce("newshape.fillcolor");
        coerce("newshape.fillrule");
        coerce("newshape.opacity");
        var newshapeLineWidth = coerce("newshape.line.width");
        if (newshapeLineWidth) {
          var bgcolor = (layoutIn || {}).plot_bgcolor || "#FFF";
          coerce("newshape.line.color", Color.contrast(bgcolor));
          coerce("newshape.line.dash");
        }
        var isLine = layoutIn.dragmode === "drawline";
        var labelText = coerce("newshape.label.text");
        var labelTextTemplate = coerce("newshape.label.texttemplate");
        if (labelText || labelTextTemplate) {
          coerce("newshape.label.textangle");
          var labelTextPosition = coerce("newshape.label.textposition", isLine ? "middle" : "middle center");
          coerce("newshape.label.xanchor");
          coerce("newshape.label.yanchor", dfltLabelYanchor(isLine, labelTextPosition));
          coerce("newshape.label.padding");
          Lib.coerceFont(coerce, "newshape.label.font", layoutOut.font);
        }
        coerce("activeshape.fillcolor");
        coerce("activeshape.opacity");
      };
    }
  });

  // src/components/shapes/calc_autorange.js
  var require_calc_autorange2 = __commonJS({
    "src/components/shapes/calc_autorange.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var constants = require_constants5();
      var helpers = require_helpers8();
      module.exports = function calcAutorange(gd) {
        var fullLayout = gd._fullLayout;
        var shapeList = Lib.filterVisible(fullLayout.shapes);
        if (!shapeList.length || !gd._fullData.length) return;
        for (var i = 0; i < shapeList.length; i++) {
          var shape = shapeList[i];
          shape._extremes = {};
          var ax;
          var bounds;
          var xRefType = Axes.getRefType(shape.xref);
          var yRefType = Axes.getRefType(shape.yref);
          if (shape.xref !== "paper" && xRefType !== "domain") {
            ax = Axes.getFromId(gd, shape.xref);
            bounds = shapeBounds(ax, shape, constants.paramIsX);
            if (bounds) {
              shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));
            }
          }
          if (shape.yref !== "paper" && yRefType !== "domain") {
            ax = Axes.getFromId(gd, shape.yref);
            bounds = shapeBounds(ax, shape, constants.paramIsY);
            if (bounds) {
              shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));
            }
          }
        }
      };
      function calcXPaddingOptions(shape) {
        return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);
      }
      function calcYPaddingOptions(shape) {
        return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);
      }
      function calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {
        var ppad = lineWidth / 2;
        var axisDirectionReverted = isYAxis;
        if (sizeMode === "pixel") {
          var coords = path ? helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) : [v0, v1];
          var maxValue = Lib.aggNums(Math.max, null, coords);
          var minValue = Lib.aggNums(Math.min, null, coords);
          var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;
          var afterPad = maxValue > 0 ? maxValue + ppad : ppad;
          return {
            ppad,
            ppadplus: axisDirectionReverted ? beforePad : afterPad,
            ppadminus: axisDirectionReverted ? afterPad : beforePad
          };
        } else {
          return { ppad };
        }
      }
      function shapeBounds(ax, shape, paramsToUse) {
        var dim = ax._id.charAt(0) === "x" ? "x" : "y";
        var isCategory = ax.type === "category" || ax.type === "multicategory";
        var v0;
        var v1;
        var shiftStart = 0;
        var shiftEnd = 0;
        var convertVal = isCategory ? ax.r2c : ax.d2c;
        var isSizeModeScale = shape[dim + "sizemode"] === "scaled";
        if (isSizeModeScale) {
          v0 = shape[dim + "0"];
          v1 = shape[dim + "1"];
          if (isCategory) {
            shiftStart = shape[dim + "0shift"];
            shiftEnd = shape[dim + "1shift"];
          }
        } else {
          v0 = shape[dim + "anchor"];
          v1 = shape[dim + "anchor"];
        }
        if (v0 !== void 0) return [convertVal(v0) + shiftStart, convertVal(v1) + shiftEnd];
        if (!shape.path) return;
        var min = Infinity;
        var max = -Infinity;
        var segments = shape.path.match(constants.segmentRE);
        var i;
        var segment;
        var drawnParam;
        var params;
        var val;
        if (ax.type === "date") convertVal = helpers.decodeDate(convertVal);
        for (i = 0; i < segments.length; i++) {
          segment = segments[i];
          drawnParam = paramsToUse[segment.charAt(0)].drawn;
          if (drawnParam === void 0) continue;
          params = segments[i].substr(1).match(constants.paramRE);
          if (!params || params.length < drawnParam) continue;
          val = convertVal(params[drawnParam]);
          if (val < min) min = val;
          if (val > max) max = val;
        }
        if (max >= min) return [min, max];
      }
    }
  });

  // src/components/shapes/index.js
  var require_shapes = __commonJS({
    "src/components/shapes/index.js"(exports, module) {
      "use strict";
      var drawModule = require_draw2();
      module.exports = {
        moduleType: "component",
        name: "shapes",
        layoutAttributes: require_attributes16(),
        supplyLayoutDefaults: require_defaults11(),
        supplyDrawNewShapeDefaults: require_defaults12(),
        includeBasePlot: require_include_components()("shapes"),
        calcAutorange: require_calc_autorange2(),
        draw: drawModule.draw,
        drawOne: drawModule.drawOne
      };
    }
  });

  // src/components/images/attributes.js
  var require_attributes17 = __commonJS({
    "src/components/images/attributes.js"(exports, module) {
      "use strict";
      var cartesianConstants = require_constants2();
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      module.exports = templatedArray("image", {
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "arraydraw"
        },
        source: {
          valType: "string",
          editType: "arraydraw"
        },
        layer: {
          valType: "enumerated",
          values: ["below", "above"],
          dflt: "above",
          editType: "arraydraw"
        },
        sizex: {
          valType: "number",
          dflt: 0,
          editType: "arraydraw"
        },
        sizey: {
          valType: "number",
          dflt: 0,
          editType: "arraydraw"
        },
        sizing: {
          valType: "enumerated",
          values: ["fill", "contain", "stretch"],
          dflt: "contain",
          editType: "arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "arraydraw"
        },
        x: {
          valType: "any",
          dflt: 0,
          editType: "arraydraw"
        },
        y: {
          valType: "any",
          dflt: 0,
          editType: "arraydraw"
        },
        xanchor: {
          valType: "enumerated",
          values: ["left", "center", "right"],
          dflt: "left",
          editType: "arraydraw"
        },
        yanchor: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"],
          dflt: "top",
          editType: "arraydraw"
        },
        xref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.x.toString()
          ],
          dflt: "paper",
          editType: "arraydraw"
        },
        yref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.y.toString()
          ],
          dflt: "paper",
          editType: "arraydraw"
        },
        editType: "arraydraw"
      });
    }
  });

  // src/components/images/defaults.js
  var require_defaults13 = __commonJS({
    "src/components/images/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes17();
      var name = "images";
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        var opts = {
          name,
          handleItemDefaults: imageDefaults
        };
        handleArrayContainerDefaults(layoutIn, layoutOut, opts);
      };
      function imageDefaults(imageIn, imageOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(imageIn, imageOut, attributes, attr, dflt);
        }
        var source = coerce("source");
        var visible = coerce("visible", !!source);
        if (!visible) return imageOut;
        coerce("layer");
        coerce("xanchor");
        coerce("yanchor");
        coerce("sizex");
        coerce("sizey");
        coerce("sizing");
        coerce("opacity");
        var gdMock = { _fullLayout: fullLayout };
        var axLetters = ["x", "y"];
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var axRef = Axes.coerceRef(imageIn, imageOut, gdMock, axLetter, "paper", void 0);
          if (axRef !== "paper") {
            var ax = Axes.getFromId(gdMock, axRef);
            ax._imgIndices.push(imageOut._index);
          }
          Axes.coercePosition(imageOut, gdMock, coerce, axRef, axLetter, 0);
        }
        return imageOut;
      }
    }
  });

  // src/components/images/draw.js
  var require_draw6 = __commonJS({
    "src/components/images/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Drawing = require_drawing();
      var Axes = require_axes();
      var axisIds = require_axis_ids();
      var xmlnsNamespaces = require_xmlns_namespaces();
      module.exports = function draw(gd) {
        var fullLayout = gd._fullLayout;
        var imageDataAbove = [];
        var imageDataSubplot = {};
        var imageDataBelow = [];
        var subplot;
        var i;
        for (i = 0; i < fullLayout.images.length; i++) {
          var img = fullLayout.images[i];
          if (img.visible) {
            if (img.layer === "below" && img.xref !== "paper" && img.yref !== "paper") {
              subplot = axisIds.ref2id(img.xref) + axisIds.ref2id(img.yref);
              var plotinfo = fullLayout._plots[subplot];
              if (!plotinfo) {
                imageDataBelow.push(img);
                continue;
              }
              if (plotinfo.mainplot) {
                subplot = plotinfo.mainplot.id;
              }
              if (!imageDataSubplot[subplot]) {
                imageDataSubplot[subplot] = [];
              }
              imageDataSubplot[subplot].push(img);
            } else if (img.layer === "above") {
              imageDataAbove.push(img);
            } else {
              imageDataBelow.push(img);
            }
          }
        }
        var anchors = {
          x: {
            left: { sizing: "xMin", offset: 0 },
            center: { sizing: "xMid", offset: -1 / 2 },
            right: { sizing: "xMax", offset: -1 }
          },
          y: {
            top: { sizing: "YMin", offset: 0 },
            middle: { sizing: "YMid", offset: -1 / 2 },
            bottom: { sizing: "YMax", offset: -1 }
          }
        };
        function setImage(d) {
          var thisImage = d3.select(this);
          if (this._imgSrc === d.source) {
            return;
          }
          thisImage.attr("xmlns", xmlnsNamespaces.svg);
          if (!gd._context.staticPlot || d.source && d.source.slice(0, 5) === "data:") {
            thisImage.attr("xlink:href", d.source);
            this._imgSrc = d.source;
          } else {
            var imagePromise = new Promise(function(resolve) {
              var img2 = new Image();
              this.img = img2;
              img2.setAttribute("crossOrigin", "anonymous");
              img2.onerror = errorHandler;
              img2.onload = function() {
                var canvas = document.createElement("canvas");
                canvas.width = this.width;
                canvas.height = this.height;
                var ctx = canvas.getContext("2d", { willReadFrequently: true });
                ctx.drawImage(this, 0, 0);
                var dataURL = canvas.toDataURL("image/png");
                thisImage.attr("xlink:href", dataURL);
                resolve();
              };
              thisImage.on("error", errorHandler);
              img2.src = d.source;
              this._imgSrc = d.source;
              function errorHandler() {
                thisImage.remove();
                resolve();
              }
            }.bind(this));
            gd._promises.push(imagePromise);
          }
        }
        function applyAttributes(d) {
          var thisImage = d3.select(this);
          var xa = Axes.getFromId(gd, d.xref);
          var ya = Axes.getFromId(gd, d.yref);
          var xIsDomain = Axes.getRefType(d.xref) === "domain";
          var yIsDomain = Axes.getRefType(d.yref) === "domain";
          var size = fullLayout._size;
          var width, height;
          if (xa !== void 0) {
            width = typeof d.xref === "string" && xIsDomain ? xa._length * d.sizex : Math.abs(xa.l2p(d.sizex) - xa.l2p(0));
          } else {
            width = d.sizex * size.w;
          }
          if (ya !== void 0) {
            height = typeof d.yref === "string" && yIsDomain ? ya._length * d.sizey : Math.abs(ya.l2p(d.sizey) - ya.l2p(0));
          } else {
            height = d.sizey * size.h;
          }
          var xOffset = width * anchors.x[d.xanchor].offset;
          var yOffset = height * anchors.y[d.yanchor].offset;
          var sizing = anchors.x[d.xanchor].sizing + anchors.y[d.yanchor].sizing;
          var xPos, yPos;
          if (xa !== void 0) {
            xPos = typeof d.xref === "string" && xIsDomain ? xa._length * d.x + xa._offset : xa.r2p(d.x) + xa._offset;
          } else {
            xPos = d.x * size.w + size.l;
          }
          xPos += xOffset;
          if (ya !== void 0) {
            yPos = typeof d.yref === "string" && yIsDomain ? (
              // consistent with "paper" yref value, where positive values
              // move up the page
              ya._length * (1 - d.y) + ya._offset
            ) : ya.r2p(d.y) + ya._offset;
          } else {
            yPos = size.h - d.y * size.h + size.t;
          }
          yPos += yOffset;
          switch (d.sizing) {
            case "fill":
              sizing += " slice";
              break;
            case "stretch":
              sizing = "none";
              break;
          }
          thisImage.attr({
            x: xPos,
            y: yPos,
            width,
            height,
            preserveAspectRatio: sizing,
            opacity: d.opacity
          });
          var xId = xa && Axes.getRefType(d.xref) !== "domain" ? xa._id : "";
          var yId = ya && Axes.getRefType(d.yref) !== "domain" ? ya._id : "";
          var clipAxes = xId + yId;
          Drawing.setClipUrl(
            thisImage,
            clipAxes ? "clip" + fullLayout._uid + clipAxes : null,
            gd
          );
        }
        function imgDataFunc(d) {
          return [d.xref, d.x, d.sizex, d.yref, d.y, d.sizey].join("_");
        }
        function imgSort(a, b) {
          return a._index - b._index;
        }
        var imagesBelow = fullLayout._imageLowerLayer.selectAll("image").data(imageDataBelow, imgDataFunc);
        var imagesAbove = fullLayout._imageUpperLayer.selectAll("image").data(imageDataAbove, imgDataFunc);
        imagesBelow.enter().append("image");
        imagesAbove.enter().append("image");
        imagesBelow.exit().remove();
        imagesAbove.exit().remove();
        imagesBelow.each(function(d) {
          setImage.bind(this)(d);
          applyAttributes.bind(this)(d);
        });
        imagesAbove.each(function(d) {
          setImage.bind(this)(d);
          applyAttributes.bind(this)(d);
        });
        imagesBelow.sort(imgSort);
        imagesAbove.sort(imgSort);
        var allSubplots = Object.keys(fullLayout._plots);
        for (i = 0; i < allSubplots.length; i++) {
          subplot = allSubplots[i];
          var subplotObj = fullLayout._plots[subplot];
          if (!subplotObj.imagelayer) continue;
          var imagesOnSubplot = subplotObj.imagelayer.selectAll("image").data(imageDataSubplot[subplot] || [], imgDataFunc);
          imagesOnSubplot.enter().append("image");
          imagesOnSubplot.exit().remove();
          imagesOnSubplot.each(function(d) {
            setImage.bind(this)(d);
            applyAttributes.bind(this)(d);
          });
          imagesOnSubplot.sort(imgSort);
        }
      };
    }
  });

  // src/components/images/convert_coords.js
  var require_convert_coords2 = __commonJS({
    "src/components/images/convert_coords.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var toLogRange = require_to_log_range();
      module.exports = function convertCoords(gd, ax, newType, doExtra) {
        ax = ax || {};
        var toLog = newType === "log" && ax.type === "linear";
        var fromLog = newType === "linear" && ax.type === "log";
        if (!(toLog || fromLog)) return;
        var images = gd._fullLayout.images;
        var axLetter = ax._id.charAt(0);
        var image;
        var attrPrefix;
        for (var i = 0; i < images.length; i++) {
          image = images[i];
          attrPrefix = "images[" + i + "].";
          if (image[axLetter + "ref"] === ax._id) {
            var currentPos = image[axLetter];
            var currentSize = image["size" + axLetter];
            var newPos = null;
            var newSize = null;
            if (toLog) {
              newPos = toLogRange(currentPos, ax.range);
              var dx = currentSize / Math.pow(10, newPos) / 2;
              newSize = 2 * Math.log(dx + Math.sqrt(1 + dx * dx)) / Math.LN10;
            } else {
              newPos = Math.pow(10, currentPos);
              newSize = newPos * (Math.pow(10, currentSize / 2) - Math.pow(10, -currentSize / 2));
            }
            if (!isNumeric(newPos)) {
              newPos = null;
              newSize = null;
            } else if (!isNumeric(newSize)) newSize = null;
            doExtra(attrPrefix + axLetter, newPos);
            doExtra(attrPrefix + "size" + axLetter, newSize);
          }
        }
      };
    }
  });

  // src/components/images/index.js
  var require_images = __commonJS({
    "src/components/images/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "images",
        layoutAttributes: require_attributes17(),
        supplyLayoutDefaults: require_defaults13(),
        includeBasePlot: require_include_components()("images"),
        draw: require_draw6(),
        convertCoords: require_convert_coords2()
      };
    }
  });

  // src/components/updatemenus/constants.js
  var require_constants9 = __commonJS({
    "src/components/updatemenus/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // layout attribute name
        name: "updatemenus",
        // class names
        containerClassName: "updatemenu-container",
        headerGroupClassName: "updatemenu-header-group",
        headerClassName: "updatemenu-header",
        headerArrowClassName: "updatemenu-header-arrow",
        dropdownButtonGroupClassName: "updatemenu-dropdown-button-group",
        dropdownButtonClassName: "updatemenu-dropdown-button",
        buttonClassName: "updatemenu-button",
        itemRectClassName: "updatemenu-item-rect",
        itemTextClassName: "updatemenu-item-text",
        // DOM attribute name in button group keeping track
        // of active update menu
        menuIndexAttrName: "updatemenu-active-index",
        // id root pass to Plots.autoMargin
        autoMarginIdRoot: "updatemenu-",
        // options when 'active: -1'
        blankHeaderOpts: { label: "  " },
        // min item width / height
        minWidth: 30,
        minHeight: 30,
        // padding around item text
        textPadX: 24,
        arrowPadX: 16,
        // item rect radii
        rx: 2,
        ry: 2,
        // item  text x offset off left edge
        textOffsetX: 12,
        // item  text y offset (w.r.t. middle)
        textOffsetY: 3,
        // arrow offset off right edge
        arrowOffsetX: 4,
        // gap between header and buttons
        gapButtonHeader: 5,
        // gap between between buttons
        gapButton: 2,
        // color given to active buttons
        activeColor: "#F4FAFF",
        // color given to hovered buttons
        hoverColor: "#F4FAFF",
        // symbol for menu open arrow
        arrowSymbol: {
          left: "\u25C4",
          right: "\u25BA",
          up: "\u25B2",
          down: "\u25BC"
        }
      };
    }
  });

  // src/components/updatemenus/attributes.js
  var require_attributes18 = __commonJS({
    "src/components/updatemenus/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      var padAttrs = require_pad_attributes();
      var templatedArray = require_plot_template().templatedArray;
      var buttonsAttrs = templatedArray("button", {
        visible: {
          valType: "boolean"
        },
        method: {
          valType: "enumerated",
          values: ["restyle", "relayout", "animate", "update", "skip"],
          dflt: "restyle"
        },
        args: {
          valType: "info_array",
          freeLength: true,
          items: [
            { valType: "any" },
            { valType: "any" },
            { valType: "any" }
          ]
        },
        args2: {
          valType: "info_array",
          freeLength: true,
          items: [
            { valType: "any" },
            { valType: "any" },
            { valType: "any" }
          ]
        },
        label: {
          valType: "string",
          dflt: ""
        },
        execute: {
          valType: "boolean",
          dflt: true
        }
      });
      module.exports = overrideAll(templatedArray("updatemenu", {
        _arrayAttrRegexps: [/^updatemenus\[(0|[1-9][0-9]+)\]\.buttons/],
        visible: {
          valType: "boolean"
        },
        type: {
          valType: "enumerated",
          values: ["dropdown", "buttons"],
          dflt: "dropdown"
        },
        direction: {
          valType: "enumerated",
          values: ["left", "right", "up", "down"],
          dflt: "down"
        },
        active: {
          valType: "integer",
          min: -1,
          dflt: 0
        },
        showactive: {
          valType: "boolean",
          dflt: true
        },
        buttons: buttonsAttrs,
        x: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: -0.05
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "right"
        },
        y: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: 1
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "top"
        },
        pad: extendFlat(padAttrs({ editType: "arraydraw" }), {}),
        font: fontAttrs({}),
        bgcolor: {
          valType: "color"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttrs.borderLine
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "arraydraw"
        }
      }), "arraydraw", "from-root");
    }
  });

  // src/components/updatemenus/defaults.js
  var require_defaults14 = __commonJS({
    "src/components/updatemenus/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes18();
      var constants = require_constants9();
      var name = constants.name;
      var buttonAttrs = attributes.buttons;
      module.exports = function updateMenusDefaults(layoutIn, layoutOut) {
        var opts = {
          name,
          handleItemDefaults: menuDefaults
        };
        handleArrayContainerDefaults(layoutIn, layoutOut, opts);
      };
      function menuDefaults(menuIn, menuOut, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(menuIn, menuOut, attributes, attr, dflt);
        }
        var buttons = handleArrayContainerDefaults(menuIn, menuOut, {
          name: "buttons",
          handleItemDefaults: buttonDefaults
        });
        var visible = coerce("visible", buttons.length > 0);
        if (!visible) return;
        coerce("active");
        coerce("direction");
        coerce("type");
        coerce("showactive");
        coerce("x");
        coerce("y");
        Lib.noneOrAll(menuIn, menuOut, ["x", "y"]);
        coerce("xanchor");
        coerce("yanchor");
        coerce("pad.t");
        coerce("pad.r");
        coerce("pad.b");
        coerce("pad.l");
        Lib.coerceFont(coerce, "font", layoutOut.font);
        coerce("bgcolor", layoutOut.paper_bgcolor);
        coerce("bordercolor");
        coerce("borderwidth");
      }
      function buttonDefaults(buttonIn, buttonOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(buttonIn, buttonOut, buttonAttrs, attr, dflt);
        }
        var visible = coerce(
          "visible",
          buttonIn.method === "skip" || Array.isArray(buttonIn.args)
        );
        if (visible) {
          coerce("method");
          coerce("args");
          coerce("args2");
          coerce("label");
          coerce("execute");
        }
      }
    }
  });

  // src/components/updatemenus/scrollbox.js
  var require_scrollbox = __commonJS({
    "src/components/updatemenus/scrollbox.js"(exports, module) {
      "use strict";
      module.exports = ScrollBox;
      var d3 = require_d3();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      function ScrollBox(gd, container, id) {
        this.gd = gd;
        this.container = container;
        this.id = id;
        this.position = null;
        this.translateX = null;
        this.translateY = null;
        this.hbar = null;
        this.vbar = null;
        this.bg = this.container.selectAll("rect.scrollbox-bg").data([0]);
        this.bg.exit().on(".drag", null).on("wheel", null).remove();
        this.bg.enter().append("rect").classed("scrollbox-bg", true).style("pointer-events", "all").attr({
          opacity: 0,
          x: 0,
          y: 0,
          width: 0,
          height: 0
        });
      }
      ScrollBox.barWidth = 2;
      ScrollBox.barLength = 20;
      ScrollBox.barRadius = 2;
      ScrollBox.barPad = 1;
      ScrollBox.barColor = "#808BA4";
      ScrollBox.prototype.enable = function enable(position, translateX, translateY) {
        var fullLayout = this.gd._fullLayout;
        var fullWidth = fullLayout.width;
        var fullHeight = fullLayout.height;
        this.position = position;
        var l = this.position.l;
        var w = this.position.w;
        var t = this.position.t;
        var h = this.position.h;
        var direction = this.position.direction;
        var isDown = direction === "down";
        var isLeft = direction === "left";
        var isRight = direction === "right";
        var isUp = direction === "up";
        var boxW = w;
        var boxH = h;
        var boxL, boxR;
        var boxT, boxB;
        if (!isDown && !isLeft && !isRight && !isUp) {
          this.position.direction = "down";
          isDown = true;
        }
        var isVertical = isDown || isUp;
        if (isVertical) {
          boxL = l;
          boxR = boxL + boxW;
          if (isDown) {
            boxT = t;
            boxB = Math.min(boxT + boxH, fullHeight);
            boxH = boxB - boxT;
          } else {
            boxB = t + boxH;
            boxT = Math.max(boxB - boxH, 0);
            boxH = boxB - boxT;
          }
        } else {
          boxT = t;
          boxB = boxT + boxH;
          if (isLeft) {
            boxR = l + boxW;
            boxL = Math.max(boxR - boxW, 0);
            boxW = boxR - boxL;
          } else {
            boxL = l;
            boxR = Math.min(boxL + boxW, fullWidth);
            boxW = boxR - boxL;
          }
        }
        this._box = {
          l: boxL,
          t: boxT,
          w: boxW,
          h: boxH
        };
        var needsHorizontalScrollBar = w > boxW;
        var hbarW = ScrollBox.barLength + 2 * ScrollBox.barPad;
        var hbarH = ScrollBox.barWidth + 2 * ScrollBox.barPad;
        var hbarL = l;
        var hbarT = t + h;
        if (hbarT + hbarH > fullHeight) hbarT = fullHeight - hbarH;
        var hbar = this.container.selectAll("rect.scrollbar-horizontal").data(
          needsHorizontalScrollBar ? [0] : []
        );
        hbar.exit().on(".drag", null).remove();
        hbar.enter().append("rect").classed("scrollbar-horizontal", true).call(Color.fill, ScrollBox.barColor);
        if (needsHorizontalScrollBar) {
          this.hbar = hbar.attr({
            rx: ScrollBox.barRadius,
            ry: ScrollBox.barRadius,
            x: hbarL,
            y: hbarT,
            width: hbarW,
            height: hbarH
          });
          this._hbarXMin = hbarL + hbarW / 2;
          this._hbarTranslateMax = boxW - hbarW;
        } else {
          delete this.hbar;
          delete this._hbarXMin;
          delete this._hbarTranslateMax;
        }
        var needsVerticalScrollBar = h > boxH;
        var vbarW = ScrollBox.barWidth + 2 * ScrollBox.barPad;
        var vbarH = ScrollBox.barLength + 2 * ScrollBox.barPad;
        var vbarL = l + w;
        var vbarT = t;
        if (vbarL + vbarW > fullWidth) vbarL = fullWidth - vbarW;
        var vbar = this.container.selectAll("rect.scrollbar-vertical").data(
          needsVerticalScrollBar ? [0] : []
        );
        vbar.exit().on(".drag", null).remove();
        vbar.enter().append("rect").classed("scrollbar-vertical", true).call(Color.fill, ScrollBox.barColor);
        if (needsVerticalScrollBar) {
          this.vbar = vbar.attr({
            rx: ScrollBox.barRadius,
            ry: ScrollBox.barRadius,
            x: vbarL,
            y: vbarT,
            width: vbarW,
            height: vbarH
          });
          this._vbarYMin = vbarT + vbarH / 2;
          this._vbarTranslateMax = boxH - vbarH;
        } else {
          delete this.vbar;
          delete this._vbarYMin;
          delete this._vbarTranslateMax;
        }
        var clipId = this.id;
        var clipL = boxL - 0.5;
        var clipR = needsVerticalScrollBar ? boxR + vbarW + 0.5 : boxR + 0.5;
        var clipT = boxT - 0.5;
        var clipB = needsHorizontalScrollBar ? boxB + hbarH + 0.5 : boxB + 0.5;
        var clipPath = fullLayout._topdefs.selectAll("#" + clipId).data(needsHorizontalScrollBar || needsVerticalScrollBar ? [0] : []);
        clipPath.exit().remove();
        clipPath.enter().append("clipPath").attr("id", clipId).append("rect");
        if (needsHorizontalScrollBar || needsVerticalScrollBar) {
          this._clipRect = clipPath.select("rect").attr({
            x: Math.floor(clipL),
            y: Math.floor(clipT),
            width: Math.ceil(clipR) - Math.floor(clipL),
            height: Math.ceil(clipB) - Math.floor(clipT)
          });
          this.container.call(Drawing.setClipUrl, clipId, this.gd);
          this.bg.attr({
            x: l,
            y: t,
            width: w,
            height: h
          });
        } else {
          this.bg.attr({
            width: 0,
            height: 0
          });
          this.container.on("wheel", null).on(".drag", null).call(Drawing.setClipUrl, null);
          delete this._clipRect;
        }
        if (needsHorizontalScrollBar || needsVerticalScrollBar) {
          var onBoxDrag = d3.behavior.drag().on("dragstart", function() {
            d3.event.sourceEvent.preventDefault();
          }).on("drag", this._onBoxDrag.bind(this));
          this.container.on("wheel", null).on("wheel", this._onBoxWheel.bind(this)).on(".drag", null).call(onBoxDrag);
          var onBarDrag = d3.behavior.drag().on("dragstart", function() {
            d3.event.sourceEvent.preventDefault();
            d3.event.sourceEvent.stopPropagation();
          }).on("drag", this._onBarDrag.bind(this));
          if (needsHorizontalScrollBar) {
            this.hbar.on(".drag", null).call(onBarDrag);
          }
          if (needsVerticalScrollBar) {
            this.vbar.on(".drag", null).call(onBarDrag);
          }
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype.disable = function disable() {
        if (this.hbar || this.vbar) {
          this.bg.attr({
            width: 0,
            height: 0
          });
          this.container.on("wheel", null).on(".drag", null).call(Drawing.setClipUrl, null);
          delete this._clipRect;
        }
        if (this.hbar) {
          this.hbar.on(".drag", null);
          this.hbar.remove();
          delete this.hbar;
          delete this._hbarXMin;
          delete this._hbarTranslateMax;
        }
        if (this.vbar) {
          this.vbar.on(".drag", null);
          this.vbar.remove();
          delete this.vbar;
          delete this._vbarYMin;
          delete this._vbarTranslateMax;
        }
      };
      ScrollBox.prototype._onBoxDrag = function _onBoxDrag() {
        var translateX = this.translateX;
        var translateY = this.translateY;
        if (this.hbar) {
          translateX -= d3.event.dx;
        }
        if (this.vbar) {
          translateY -= d3.event.dy;
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype._onBoxWheel = function _onBoxWheel() {
        var translateX = this.translateX;
        var translateY = this.translateY;
        if (this.hbar) {
          translateX += d3.event.deltaY;
        }
        if (this.vbar) {
          translateY += d3.event.deltaY;
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype._onBarDrag = function _onBarDrag() {
        var translateX = this.translateX;
        var translateY = this.translateY;
        if (this.hbar) {
          var xMin = translateX + this._hbarXMin;
          var xMax = xMin + this._hbarTranslateMax;
          var x = Lib.constrain(d3.event.x, xMin, xMax);
          var xf = (x - xMin) / (xMax - xMin);
          var translateXMax = this.position.w - this._box.w;
          translateX = xf * translateXMax;
        }
        if (this.vbar) {
          var yMin = translateY + this._vbarYMin;
          var yMax = yMin + this._vbarTranslateMax;
          var y = Lib.constrain(d3.event.y, yMin, yMax);
          var yf = (y - yMin) / (yMax - yMin);
          var translateYMax = this.position.h - this._box.h;
          translateY = yf * translateYMax;
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype.setTranslate = function setTranslate(translateX, translateY) {
        var translateXMax = this.position.w - this._box.w;
        var translateYMax = this.position.h - this._box.h;
        translateX = Lib.constrain(translateX || 0, 0, translateXMax);
        translateY = Lib.constrain(translateY || 0, 0, translateYMax);
        this.translateX = translateX;
        this.translateY = translateY;
        this.container.call(
          Drawing.setTranslate,
          this._box.l - this.position.l - translateX,
          this._box.t - this.position.t - translateY
        );
        if (this._clipRect) {
          this._clipRect.attr({
            x: Math.floor(this.position.l + translateX - 0.5),
            y: Math.floor(this.position.t + translateY - 0.5)
          });
        }
        if (this.hbar) {
          var xf = translateX / translateXMax;
          this.hbar.call(
            Drawing.setTranslate,
            translateX + xf * this._hbarTranslateMax,
            translateY
          );
        }
        if (this.vbar) {
          var yf = translateY / translateYMax;
          this.vbar.call(
            Drawing.setTranslate,
            translateX,
            translateY + yf * this._vbarTranslateMax
          );
        }
      };
    }
  });

  // src/components/updatemenus/draw.js
  var require_draw7 = __commonJS({
    "src/components/updatemenus/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Plots = require_plots();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var svgTextUtils = require_svg_text_utils();
      var arrayEditor = require_plot_template().arrayEditor;
      var LINE_SPACING = require_alignment().LINE_SPACING;
      var constants = require_constants9();
      var ScrollBox = require_scrollbox();
      module.exports = function draw(gd) {
        var fullLayout = gd._fullLayout;
        var menuData = Lib.filterVisible(fullLayout[constants.name]);
        function clearAutoMargin(menuOpts2) {
          Plots.autoMargin(gd, autoMarginId(menuOpts2));
        }
        var menus = fullLayout._menulayer.selectAll("g." + constants.containerClassName).data(menuData.length > 0 ? [0] : []);
        menus.enter().append("g").classed(constants.containerClassName, true).style("cursor", "pointer");
        menus.exit().each(function() {
          d3.select(this).selectAll("g." + constants.headerGroupClassName).each(clearAutoMargin);
        }).remove();
        if (menuData.length === 0) return;
        var headerGroups = menus.selectAll("g." + constants.headerGroupClassName).data(menuData, keyFunction);
        headerGroups.enter().append("g").classed(constants.headerGroupClassName, true);
        var gButton = Lib.ensureSingle(menus, "g", constants.dropdownButtonGroupClassName, function(s) {
          s.style("pointer-events", "all");
        });
        for (var i = 0; i < menuData.length; i++) {
          var menuOpts = menuData[i];
          findDimensions(gd, menuOpts);
        }
        var scrollBoxId = "updatemenus" + fullLayout._uid;
        var scrollBox = new ScrollBox(gd, gButton, scrollBoxId);
        if (headerGroups.enter().size()) {
          gButton.node().parentNode.appendChild(gButton.node());
          gButton.call(removeAllButtons);
        }
        headerGroups.exit().each(function(menuOpts2) {
          gButton.call(removeAllButtons);
          clearAutoMargin(menuOpts2);
        }).remove();
        headerGroups.each(function(menuOpts2) {
          var gHeader = d3.select(this);
          var _gButton = menuOpts2.type === "dropdown" ? gButton : null;
          Plots.manageCommandObserver(gd, menuOpts2, menuOpts2.buttons, function(data) {
            setActive(gd, menuOpts2, menuOpts2.buttons[data.index], gHeader, _gButton, scrollBox, data.index, true);
          });
          if (menuOpts2.type === "dropdown") {
            drawHeader(gd, gHeader, gButton, scrollBox, menuOpts2);
            if (isActive(gButton, menuOpts2)) {
              drawButtons(gd, gHeader, gButton, scrollBox, menuOpts2);
            }
          } else {
            drawButtons(gd, gHeader, null, null, menuOpts2);
          }
        });
      };
      function keyFunction(menuOpts) {
        return menuOpts._index;
      }
      function isFolded(gButton) {
        return +gButton.attr(constants.menuIndexAttrName) === -1;
      }
      function isActive(gButton, menuOpts) {
        return +gButton.attr(constants.menuIndexAttrName) === menuOpts._index;
      }
      function setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex, isSilentUpdate) {
        menuOpts.active = buttonIndex;
        arrayEditor(gd.layout, constants.name, menuOpts).applyUpdate("active", buttonIndex);
        if (menuOpts.type === "buttons") {
          drawButtons(gd, gHeader, null, null, menuOpts);
        } else if (menuOpts.type === "dropdown") {
          gButton.attr(constants.menuIndexAttrName, "-1");
          drawHeader(gd, gHeader, gButton, scrollBox, menuOpts);
          if (!isSilentUpdate) {
            drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
          }
        }
      }
      function drawHeader(gd, gHeader, gButton, scrollBox, menuOpts) {
        var header = Lib.ensureSingle(gHeader, "g", constants.headerClassName, function(s) {
          s.style("pointer-events", "all");
        });
        var dims = menuOpts._dims;
        var active = menuOpts.active;
        var headerOpts = menuOpts.buttons[active] || constants.blankHeaderOpts;
        var posOpts = { y: menuOpts.pad.t, yPad: 0, x: menuOpts.pad.l, xPad: 0, index: 0 };
        var positionOverrides = {
          width: dims.headerWidth,
          height: dims.headerHeight
        };
        header.call(drawItem, menuOpts, headerOpts, gd).call(setItemPosition, menuOpts, posOpts, positionOverrides);
        var arrow = Lib.ensureSingle(gHeader, "text", constants.headerArrowClassName, function(s) {
          s.attr("text-anchor", "end").call(Drawing.font, menuOpts.font).text(constants.arrowSymbol[menuOpts.direction]);
        });
        arrow.attr({
          x: dims.headerWidth - constants.arrowOffsetX + menuOpts.pad.l,
          y: dims.headerHeight / 2 + constants.textOffsetY + menuOpts.pad.t
        });
        header.on("click", function() {
          gButton.call(
            removeAllButtons,
            String(isActive(gButton, menuOpts) ? -1 : menuOpts._index)
          );
          drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
        });
        header.on("mouseover", function() {
          header.call(styleOnMouseOver);
        });
        header.on("mouseout", function() {
          header.call(styleOnMouseOut, menuOpts);
        });
        Drawing.setTranslate(gHeader, dims.lx, dims.ly);
      }
      function drawButtons(gd, gHeader, gButton, scrollBox, menuOpts) {
        if (!gButton) {
          gButton = gHeader;
          gButton.attr("pointer-events", "all");
        }
        var buttonData = !isFolded(gButton) || menuOpts.type === "buttons" ? menuOpts.buttons : [];
        var klass = menuOpts.type === "dropdown" ? constants.dropdownButtonClassName : constants.buttonClassName;
        var buttons = gButton.selectAll("g." + klass).data(Lib.filterVisible(buttonData));
        var enter = buttons.enter().append("g").classed(klass, true);
        var exit = buttons.exit();
        if (menuOpts.type === "dropdown") {
          enter.attr("opacity", "0").transition().attr("opacity", "1");
          exit.transition().attr("opacity", "0").remove();
        } else {
          exit.remove();
        }
        var x0 = 0;
        var y0 = 0;
        var dims = menuOpts._dims;
        var isVertical = ["up", "down"].indexOf(menuOpts.direction) !== -1;
        if (menuOpts.type === "dropdown") {
          if (isVertical) {
            y0 = dims.headerHeight + constants.gapButtonHeader;
          } else {
            x0 = dims.headerWidth + constants.gapButtonHeader;
          }
        }
        if (menuOpts.type === "dropdown" && menuOpts.direction === "up") {
          y0 = -constants.gapButtonHeader + constants.gapButton - dims.openHeight;
        }
        if (menuOpts.type === "dropdown" && menuOpts.direction === "left") {
          x0 = -constants.gapButtonHeader + constants.gapButton - dims.openWidth;
        }
        var posOpts = {
          x: dims.lx + x0 + menuOpts.pad.l,
          y: dims.ly + y0 + menuOpts.pad.t,
          yPad: constants.gapButton,
          xPad: constants.gapButton,
          index: 0
        };
        var scrollBoxPosition = {
          l: posOpts.x + menuOpts.borderwidth,
          t: posOpts.y + menuOpts.borderwidth
        };
        buttons.each(function(buttonOpts, buttonIndex) {
          var button = d3.select(this);
          button.call(drawItem, menuOpts, buttonOpts, gd).call(setItemPosition, menuOpts, posOpts);
          button.on("click", function() {
            if (d3.event.defaultPrevented) return;
            if (buttonOpts.execute) {
              if (buttonOpts.args2 && menuOpts.active === buttonIndex) {
                setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, -1);
                Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args2);
              } else {
                setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex);
                Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args);
              }
            }
            gd.emit("plotly_buttonclicked", { menu: menuOpts, button: buttonOpts, active: menuOpts.active });
          });
          button.on("mouseover", function() {
            button.call(styleOnMouseOver);
          });
          button.on("mouseout", function() {
            button.call(styleOnMouseOut, menuOpts);
            buttons.call(styleButtons, menuOpts);
          });
        });
        buttons.call(styleButtons, menuOpts);
        if (isVertical) {
          scrollBoxPosition.w = Math.max(dims.openWidth, dims.headerWidth);
          scrollBoxPosition.h = posOpts.y - scrollBoxPosition.t;
        } else {
          scrollBoxPosition.w = posOpts.x - scrollBoxPosition.l;
          scrollBoxPosition.h = Math.max(dims.openHeight, dims.headerHeight);
        }
        scrollBoxPosition.direction = menuOpts.direction;
        if (scrollBox) {
          if (buttons.size()) {
            drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, scrollBoxPosition);
          } else {
            hideScrollBox(scrollBox);
          }
        }
      }
      function drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, position) {
        var direction = menuOpts.direction;
        var isVertical = direction === "up" || direction === "down";
        var dims = menuOpts._dims;
        var active = menuOpts.active;
        var translateX, translateY;
        var i;
        if (isVertical) {
          translateY = 0;
          for (i = 0; i < active; i++) {
            translateY += dims.heights[i] + constants.gapButton;
          }
        } else {
          translateX = 0;
          for (i = 0; i < active; i++) {
            translateX += dims.widths[i] + constants.gapButton;
          }
        }
        scrollBox.enable(position, translateX, translateY);
        if (scrollBox.hbar) {
          scrollBox.hbar.attr("opacity", "0").transition().attr("opacity", "1");
        }
        if (scrollBox.vbar) {
          scrollBox.vbar.attr("opacity", "0").transition().attr("opacity", "1");
        }
      }
      function hideScrollBox(scrollBox) {
        var hasHBar = !!scrollBox.hbar;
        var hasVBar = !!scrollBox.vbar;
        if (hasHBar) {
          scrollBox.hbar.transition().attr("opacity", "0").each("end", function() {
            hasHBar = false;
            if (!hasVBar) scrollBox.disable();
          });
        }
        if (hasVBar) {
          scrollBox.vbar.transition().attr("opacity", "0").each("end", function() {
            hasVBar = false;
            if (!hasHBar) scrollBox.disable();
          });
        }
      }
      function drawItem(item, menuOpts, itemOpts, gd) {
        item.call(drawItemRect, menuOpts).call(drawItemText, menuOpts, itemOpts, gd);
      }
      function drawItemRect(item, menuOpts) {
        var rect = Lib.ensureSingle(item, "rect", constants.itemRectClassName, function(s) {
          s.attr({
            rx: constants.rx,
            ry: constants.ry,
            "shape-rendering": "crispEdges"
          });
        });
        rect.call(Color.stroke, menuOpts.bordercolor).call(Color.fill, menuOpts.bgcolor).style("stroke-width", menuOpts.borderwidth + "px");
      }
      function drawItemText(item, menuOpts, itemOpts, gd) {
        var text = Lib.ensureSingle(item, "text", constants.itemTextClassName, function(s) {
          s.attr({
            "text-anchor": "start",
            "data-notex": 1
          });
        });
        var tx = itemOpts.label;
        var _meta = gd._fullLayout._meta;
        if (_meta) tx = Lib.templateString(tx, _meta);
        text.call(Drawing.font, menuOpts.font).text(tx).call(svgTextUtils.convertToTspans, gd);
      }
      function styleButtons(buttons, menuOpts) {
        var active = menuOpts.active;
        buttons.each(function(buttonOpts, i) {
          var button = d3.select(this);
          if (i === active && menuOpts.showactive) {
            button.select("rect." + constants.itemRectClassName).call(Color.fill, constants.activeColor);
          }
        });
      }
      function styleOnMouseOver(item) {
        item.select("rect." + constants.itemRectClassName).call(Color.fill, constants.hoverColor);
      }
      function styleOnMouseOut(item, menuOpts) {
        item.select("rect." + constants.itemRectClassName).call(Color.fill, menuOpts.bgcolor);
      }
      function findDimensions(gd, menuOpts) {
        var dims = menuOpts._dims = {
          width1: 0,
          height1: 0,
          heights: [],
          widths: [],
          totalWidth: 0,
          totalHeight: 0,
          openWidth: 0,
          openHeight: 0,
          lx: 0,
          ly: 0
        };
        var fakeButtons = Drawing.tester.selectAll("g." + constants.dropdownButtonClassName).data(Lib.filterVisible(menuOpts.buttons));
        fakeButtons.enter().append("g").classed(constants.dropdownButtonClassName, true);
        var isVertical = ["up", "down"].indexOf(menuOpts.direction) !== -1;
        fakeButtons.each(function(buttonOpts, i) {
          var button = d3.select(this);
          button.call(drawItem, menuOpts, buttonOpts, gd);
          var text = button.select("." + constants.itemTextClassName);
          var tWidth = text.node() && Drawing.bBox(text.node()).width;
          var wEff = Math.max(tWidth + constants.textPadX, constants.minWidth);
          var tHeight = menuOpts.font.size * LINE_SPACING;
          var tLines = svgTextUtils.lineCount(text);
          var hEff = Math.max(tHeight * tLines, constants.minHeight) + constants.textOffsetY;
          hEff = Math.ceil(hEff);
          wEff = Math.ceil(wEff);
          dims.widths[i] = wEff;
          dims.heights[i] = hEff;
          dims.height1 = Math.max(dims.height1, hEff);
          dims.width1 = Math.max(dims.width1, wEff);
          if (isVertical) {
            dims.totalWidth = Math.max(dims.totalWidth, wEff);
            dims.openWidth = dims.totalWidth;
            dims.totalHeight += hEff + constants.gapButton;
            dims.openHeight += hEff + constants.gapButton;
          } else {
            dims.totalWidth += wEff + constants.gapButton;
            dims.openWidth += wEff + constants.gapButton;
            dims.totalHeight = Math.max(dims.totalHeight, hEff);
            dims.openHeight = dims.totalHeight;
          }
        });
        if (isVertical) {
          dims.totalHeight -= constants.gapButton;
        } else {
          dims.totalWidth -= constants.gapButton;
        }
        dims.headerWidth = dims.width1 + constants.arrowPadX;
        dims.headerHeight = dims.height1;
        if (menuOpts.type === "dropdown") {
          if (isVertical) {
            dims.width1 += constants.arrowPadX;
            dims.totalHeight = dims.height1;
          } else {
            dims.totalWidth = dims.width1;
          }
          dims.totalWidth += constants.arrowPadX;
        }
        fakeButtons.remove();
        var paddedWidth = dims.totalWidth + menuOpts.pad.l + menuOpts.pad.r;
        var paddedHeight = dims.totalHeight + menuOpts.pad.t + menuOpts.pad.b;
        var graphSize = gd._fullLayout._size;
        dims.lx = graphSize.l + graphSize.w * menuOpts.x;
        dims.ly = graphSize.t + graphSize.h * (1 - menuOpts.y);
        var xanchor = "left";
        if (Lib.isRightAnchor(menuOpts)) {
          dims.lx -= paddedWidth;
          xanchor = "right";
        }
        if (Lib.isCenterAnchor(menuOpts)) {
          dims.lx -= paddedWidth / 2;
          xanchor = "center";
        }
        var yanchor = "top";
        if (Lib.isBottomAnchor(menuOpts)) {
          dims.ly -= paddedHeight;
          yanchor = "bottom";
        }
        if (Lib.isMiddleAnchor(menuOpts)) {
          dims.ly -= paddedHeight / 2;
          yanchor = "middle";
        }
        dims.totalWidth = Math.ceil(dims.totalWidth);
        dims.totalHeight = Math.ceil(dims.totalHeight);
        dims.lx = Math.round(dims.lx);
        dims.ly = Math.round(dims.ly);
        Plots.autoMargin(gd, autoMarginId(menuOpts), {
          x: menuOpts.x,
          y: menuOpts.y,
          l: paddedWidth * ({ right: 1, center: 0.5 }[xanchor] || 0),
          r: paddedWidth * ({ left: 1, center: 0.5 }[xanchor] || 0),
          b: paddedHeight * ({ top: 1, middle: 0.5 }[yanchor] || 0),
          t: paddedHeight * ({ bottom: 1, middle: 0.5 }[yanchor] || 0)
        });
      }
      function autoMarginId(menuOpts) {
        return constants.autoMarginIdRoot + menuOpts._index;
      }
      function setItemPosition(item, menuOpts, posOpts, overrideOpts) {
        overrideOpts = overrideOpts || {};
        var rect = item.select("." + constants.itemRectClassName);
        var text = item.select("." + constants.itemTextClassName);
        var borderWidth = menuOpts.borderwidth;
        var index = posOpts.index;
        var dims = menuOpts._dims;
        Drawing.setTranslate(item, borderWidth + posOpts.x, borderWidth + posOpts.y);
        var isVertical = ["up", "down"].indexOf(menuOpts.direction) !== -1;
        var finalHeight = overrideOpts.height || (isVertical ? dims.heights[index] : dims.height1);
        rect.attr({
          x: 0,
          y: 0,
          width: overrideOpts.width || (isVertical ? dims.width1 : dims.widths[index]),
          height: finalHeight
        });
        var tHeight = menuOpts.font.size * LINE_SPACING;
        var tLines = svgTextUtils.lineCount(text);
        var spanOffset = (tLines - 1) * tHeight / 2;
        svgTextUtils.positionText(
          text,
          constants.textOffsetX,
          finalHeight / 2 - spanOffset + constants.textOffsetY
        );
        if (isVertical) {
          posOpts.y += dims.heights[index] + posOpts.yPad;
        } else {
          posOpts.x += dims.widths[index] + posOpts.xPad;
        }
        posOpts.index++;
      }
      function removeAllButtons(gButton, newMenuIndexAttr) {
        gButton.attr(constants.menuIndexAttrName, newMenuIndexAttr || "-1").selectAll("g." + constants.dropdownButtonClassName).remove();
      }
    }
  });

  // src/components/updatemenus/index.js
  var require_updatemenus = __commonJS({
    "src/components/updatemenus/index.js"(exports, module) {
      "use strict";
      var constants = require_constants9();
      module.exports = {
        moduleType: "component",
        name: constants.name,
        layoutAttributes: require_attributes18(),
        supplyLayoutDefaults: require_defaults14(),
        draw: require_draw7()
      };
    }
  });

  // src/components/sliders/constants.js
  var require_constants10 = __commonJS({
    "src/components/sliders/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // layout attribute name
        name: "sliders",
        // class names
        containerClassName: "slider-container",
        groupClassName: "slider-group",
        inputAreaClass: "slider-input-area",
        railRectClass: "slider-rail-rect",
        railTouchRectClass: "slider-rail-touch-rect",
        gripRectClass: "slider-grip-rect",
        tickRectClass: "slider-tick-rect",
        inputProxyClass: "slider-input-proxy",
        labelsClass: "slider-labels",
        labelGroupClass: "slider-label-group",
        labelClass: "slider-label",
        currentValueClass: "slider-current-value",
        railHeight: 5,
        // DOM attribute name in button group keeping track
        // of active update menu
        menuIndexAttrName: "slider-active-index",
        // id root pass to Plots.autoMargin
        autoMarginIdRoot: "slider-",
        // min item width / height
        minWidth: 30,
        minHeight: 30,
        // padding around item text
        textPadX: 40,
        // arrow offset off right edge
        arrowOffsetX: 4,
        railRadius: 2,
        railWidth: 5,
        railBorder: 4,
        railBorderWidth: 1,
        railBorderColor: "#bec8d9",
        railBgColor: "#f8fafc",
        // The distance of the rail from the edge of the touchable area
        // Slightly less than the step inset because of the curved edges
        // of the rail
        railInset: 8,
        // The distance from the extremal tick marks to the edge of the
        // touchable area. This is basically the same as the grip radius,
        // but for other styles it wouldn't really need to be.
        stepInset: 10,
        gripRadius: 10,
        gripWidth: 20,
        gripHeight: 20,
        gripBorder: 20,
        gripBorderWidth: 1,
        gripBorderColor: "#bec8d9",
        gripBgColor: "#f6f8fa",
        gripBgActiveColor: "#dbdde0",
        labelPadding: 8,
        labelOffset: 0,
        tickWidth: 1,
        tickColor: "#333",
        tickOffset: 25,
        tickLength: 7,
        minorTickOffset: 25,
        minorTickColor: "#333",
        minorTickLength: 4,
        // Extra space below the current value label:
        currentValuePadding: 8,
        currentValueInset: 0
      };
    }
  });

  // src/components/sliders/attributes.js
  var require_attributes19 = __commonJS({
    "src/components/sliders/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var padAttrs = require_pad_attributes();
      var extendDeepAll = require_extend().extendDeepAll;
      var overrideAll = require_edit_types().overrideAll;
      var animationAttrs = require_animation_attributes();
      var templatedArray = require_plot_template().templatedArray;
      var constants = require_constants10();
      var stepsAttrs = templatedArray("step", {
        visible: {
          valType: "boolean",
          dflt: true
        },
        method: {
          valType: "enumerated",
          values: ["restyle", "relayout", "animate", "update", "skip"],
          dflt: "restyle"
        },
        args: {
          valType: "info_array",
          freeLength: true,
          items: [
            { valType: "any" },
            { valType: "any" },
            { valType: "any" }
          ]
        },
        label: {
          valType: "string"
        },
        value: {
          valType: "string"
        },
        execute: {
          valType: "boolean",
          dflt: true
        }
      });
      module.exports = overrideAll(templatedArray("slider", {
        visible: {
          valType: "boolean",
          dflt: true
        },
        active: {
          valType: "number",
          min: 0,
          dflt: 0
        },
        steps: stepsAttrs,
        lenmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "fraction"
        },
        len: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        x: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: 0
        },
        pad: extendDeepAll(padAttrs({ editType: "arraydraw" }), {}, { t: { dflt: 20 } }),
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "left"
        },
        y: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: 0
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "top"
        },
        transition: {
          duration: {
            valType: "number",
            min: 0,
            dflt: 150
          },
          easing: {
            valType: "enumerated",
            values: animationAttrs.transition.easing.values,
            dflt: "cubic-in-out"
          }
        },
        currentvalue: {
          visible: {
            valType: "boolean",
            dflt: true
          },
          xanchor: {
            valType: "enumerated",
            values: ["left", "center", "right"],
            dflt: "left"
          },
          offset: {
            valType: "number",
            dflt: 10
          },
          prefix: {
            valType: "string"
          },
          suffix: {
            valType: "string"
          },
          font: fontAttrs({})
        },
        font: fontAttrs({}),
        activebgcolor: {
          valType: "color",
          dflt: constants.gripBgActiveColor
        },
        bgcolor: {
          valType: "color",
          dflt: constants.railBgColor
        },
        bordercolor: {
          valType: "color",
          dflt: constants.railBorderColor
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: constants.railBorderWidth
        },
        ticklen: {
          valType: "number",
          min: 0,
          dflt: constants.tickLength
        },
        tickcolor: {
          valType: "color",
          dflt: constants.tickColor
        },
        tickwidth: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        minorticklen: {
          valType: "number",
          min: 0,
          dflt: constants.minorTickLength
        }
      }), "arraydraw", "from-root");
    }
  });

  // src/components/sliders/defaults.js
  var require_defaults15 = __commonJS({
    "src/components/sliders/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes19();
      var constants = require_constants10();
      var name = constants.name;
      var stepAttrs = attributes.steps;
      module.exports = function slidersDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name,
          handleItemDefaults: sliderDefaults
        });
      };
      function sliderDefaults(sliderIn, sliderOut, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(sliderIn, sliderOut, attributes, attr, dflt);
        }
        var steps = handleArrayContainerDefaults(sliderIn, sliderOut, {
          name: "steps",
          handleItemDefaults: stepDefaults
        });
        var stepCount = 0;
        for (var i = 0; i < steps.length; i++) {
          if (steps[i].visible) stepCount++;
        }
        var visible;
        if (stepCount < 2) visible = sliderOut.visible = false;
        else visible = coerce("visible");
        if (!visible) return;
        sliderOut._stepCount = stepCount;
        var visSteps = sliderOut._visibleSteps = Lib.filterVisible(steps);
        var active = coerce("active");
        if (!(steps[active] || {}).visible) sliderOut.active = visSteps[0]._index;
        coerce("x");
        coerce("y");
        Lib.noneOrAll(sliderIn, sliderOut, ["x", "y"]);
        coerce("xanchor");
        coerce("yanchor");
        coerce("len");
        coerce("lenmode");
        coerce("pad.t");
        coerce("pad.r");
        coerce("pad.b");
        coerce("pad.l");
        Lib.coerceFont(coerce, "font", layoutOut.font);
        var currentValueIsVisible = coerce("currentvalue.visible");
        if (currentValueIsVisible) {
          coerce("currentvalue.xanchor");
          coerce("currentvalue.prefix");
          coerce("currentvalue.suffix");
          coerce("currentvalue.offset");
          Lib.coerceFont(coerce, "currentvalue.font", sliderOut.font);
        }
        coerce("transition.duration");
        coerce("transition.easing");
        coerce("bgcolor");
        coerce("activebgcolor");
        coerce("bordercolor");
        coerce("borderwidth");
        coerce("ticklen");
        coerce("tickwidth");
        coerce("tickcolor");
        coerce("minorticklen");
      }
      function stepDefaults(valueIn, valueOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(valueIn, valueOut, stepAttrs, attr, dflt);
        }
        var visible;
        if (valueIn.method !== "skip" && !Array.isArray(valueIn.args)) {
          visible = valueOut.visible = false;
        } else visible = coerce("visible");
        if (visible) {
          coerce("method");
          coerce("args");
          var label = coerce("label", "step-" + valueOut._index);
          coerce("value", label);
          coerce("execute");
        }
      }
    }
  });

  // src/components/sliders/draw.js
  var require_draw8 = __commonJS({
    "src/components/sliders/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Plots = require_plots();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var arrayEditor = require_plot_template().arrayEditor;
      var constants = require_constants10();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      module.exports = function draw(gd) {
        var staticPlot = gd._context.staticPlot;
        var fullLayout = gd._fullLayout;
        var sliderData = makeSliderData(fullLayout, gd);
        var sliders = fullLayout._infolayer.selectAll("g." + constants.containerClassName).data(sliderData.length > 0 ? [0] : []);
        sliders.enter().append("g").classed(constants.containerClassName, true).style("cursor", staticPlot ? null : "ew-resize");
        function clearSlider(sliderOpts2) {
          if (sliderOpts2._commandObserver) {
            sliderOpts2._commandObserver.remove();
            delete sliderOpts2._commandObserver;
          }
          Plots.autoMargin(gd, autoMarginId(sliderOpts2));
        }
        sliders.exit().each(function() {
          d3.select(this).selectAll("g." + constants.groupClassName).each(clearSlider);
        }).remove();
        if (sliderData.length === 0) return;
        var sliderGroups = sliders.selectAll("g." + constants.groupClassName).data(sliderData, keyFunction);
        sliderGroups.enter().append("g").classed(constants.groupClassName, true);
        sliderGroups.exit().each(clearSlider).remove();
        for (var i = 0; i < sliderData.length; i++) {
          var sliderOpts = sliderData[i];
          findDimensions(gd, sliderOpts);
        }
        sliderGroups.each(function(sliderOpts2) {
          var gSlider = d3.select(this);
          computeLabelSteps(sliderOpts2);
          Plots.manageCommandObserver(gd, sliderOpts2, sliderOpts2._visibleSteps, function(data) {
            var opts = gSlider.data()[0];
            if (opts.active === data.index) return;
            if (opts._dragging) return;
            setActive(gd, gSlider, opts, data.index, false, true);
          });
          drawSlider(gd, d3.select(this), sliderOpts2);
        });
      };
      function autoMarginId(sliderOpts) {
        return constants.autoMarginIdRoot + sliderOpts._index;
      }
      function makeSliderData(fullLayout, gd) {
        var contOpts = fullLayout[constants.name];
        var sliderData = [];
        for (var i = 0; i < contOpts.length; i++) {
          var item = contOpts[i];
          if (!item.visible) continue;
          item._gd = gd;
          sliderData.push(item);
        }
        return sliderData;
      }
      function keyFunction(opts) {
        return opts._index;
      }
      function findDimensions(gd, sliderOpts) {
        var sliderLabels = Drawing.tester.selectAll("g." + constants.labelGroupClass).data(sliderOpts._visibleSteps);
        sliderLabels.enter().append("g").classed(constants.labelGroupClass, true);
        var maxLabelWidth = 0;
        var labelHeight = 0;
        sliderLabels.each(function(stepOpts) {
          var labelGroup = d3.select(this);
          var text = drawLabel(labelGroup, { step: stepOpts }, sliderOpts);
          var textNode = text.node();
          if (textNode) {
            var bBox = Drawing.bBox(textNode);
            labelHeight = Math.max(labelHeight, bBox.height);
            maxLabelWidth = Math.max(maxLabelWidth, bBox.width);
          }
        });
        sliderLabels.remove();
        var dims = sliderOpts._dims = {};
        dims.inputAreaWidth = Math.max(
          constants.railWidth,
          constants.gripHeight
        );
        var graphSize = gd._fullLayout._size;
        dims.lx = graphSize.l + graphSize.w * sliderOpts.x;
        dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);
        if (sliderOpts.lenmode === "fraction") {
          dims.outerLength = Math.round(graphSize.w * sliderOpts.len);
        } else {
          dims.outerLength = sliderOpts.len;
        }
        dims.inputAreaStart = 0;
        dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);
        var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;
        var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);
        var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;
        dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));
        dims.labelHeight = labelHeight;
        dims.currentValueMaxWidth = 0;
        dims.currentValueHeight = 0;
        dims.currentValueTotalHeight = 0;
        dims.currentValueMaxLines = 1;
        if (sliderOpts.currentvalue.visible) {
          var dummyGroup = Drawing.tester.append("g");
          sliderLabels.each(function(stepOpts) {
            var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);
            var curValSize = curValPrefix.node() && Drawing.bBox(curValPrefix.node()) || { width: 0, height: 0 };
            var lines = svgTextUtils.lineCount(curValPrefix);
            dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));
            dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));
            dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);
          });
          dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;
          dummyGroup.remove();
        }
        dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;
        var xanchor = "left";
        if (Lib.isRightAnchor(sliderOpts)) {
          dims.lx -= dims.outerLength;
          xanchor = "right";
        }
        if (Lib.isCenterAnchor(sliderOpts)) {
          dims.lx -= dims.outerLength / 2;
          xanchor = "center";
        }
        var yanchor = "top";
        if (Lib.isBottomAnchor(sliderOpts)) {
          dims.ly -= dims.height;
          yanchor = "bottom";
        }
        if (Lib.isMiddleAnchor(sliderOpts)) {
          dims.ly -= dims.height / 2;
          yanchor = "middle";
        }
        dims.outerLength = Math.ceil(dims.outerLength);
        dims.height = Math.ceil(dims.height);
        dims.lx = Math.round(dims.lx);
        dims.ly = Math.round(dims.ly);
        var marginOpts = {
          y: sliderOpts.y,
          b: dims.height * FROM_BR[yanchor],
          t: dims.height * FROM_TL[yanchor]
        };
        if (sliderOpts.lenmode === "fraction") {
          marginOpts.l = 0;
          marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];
          marginOpts.r = 0;
          marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];
        } else {
          marginOpts.x = sliderOpts.x;
          marginOpts.l = dims.outerLength * FROM_TL[xanchor];
          marginOpts.r = dims.outerLength * FROM_BR[xanchor];
        }
        Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);
      }
      function drawSlider(gd, sliderGroup, sliderOpts) {
        if (!(sliderOpts.steps[sliderOpts.active] || {}).visible) {
          sliderOpts.active = sliderOpts._visibleSteps[0]._index;
        }
        sliderGroup.call(drawCurrentValue, sliderOpts).call(drawRail, sliderOpts).call(drawLabelGroup, sliderOpts).call(drawTicks, sliderOpts).call(drawTouchRect, gd, sliderOpts).call(drawGrip, gd, sliderOpts);
        var dims = sliderOpts._dims;
        Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);
        sliderGroup.call(setGripPosition, sliderOpts, false);
        sliderGroup.call(drawCurrentValue, sliderOpts);
      }
      function drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {
        if (!sliderOpts.currentvalue.visible) return;
        var dims = sliderOpts._dims;
        var x0, textAnchor;
        switch (sliderOpts.currentvalue.xanchor) {
          case "right":
            x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;
            textAnchor = "left";
            break;
          case "center":
            x0 = dims.inputAreaLength * 0.5;
            textAnchor = "middle";
            break;
          default:
            x0 = constants.currentValueInset;
            textAnchor = "left";
        }
        var text = Lib.ensureSingle(sliderGroup, "text", constants.labelClass, function(s) {
          s.attr({
            "text-anchor": textAnchor,
            "data-notex": 1
          });
        });
        var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : "";
        if (typeof valueOverride === "string") {
          str += valueOverride;
        } else {
          var curVal = sliderOpts.steps[sliderOpts.active].label;
          var _meta = sliderOpts._gd._fullLayout._meta;
          if (_meta) curVal = Lib.templateString(curVal, _meta);
          str += curVal;
        }
        if (sliderOpts.currentvalue.suffix) {
          str += sliderOpts.currentvalue.suffix;
        }
        text.call(Drawing.font, sliderOpts.currentvalue.font).text(str).call(svgTextUtils.convertToTspans, sliderOpts._gd);
        var lines = svgTextUtils.lineCount(text);
        var y0 = (dims.currentValueMaxLines + 1 - lines) * sliderOpts.currentvalue.font.size * LINE_SPACING;
        svgTextUtils.positionText(text, x0, y0);
        return text;
      }
      function drawGrip(sliderGroup, gd, sliderOpts) {
        var grip = Lib.ensureSingle(sliderGroup, "rect", constants.gripRectClass, function(s) {
          s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style("pointer-events", "all");
        });
        grip.attr({
          width: constants.gripWidth,
          height: constants.gripHeight,
          rx: constants.gripRadius,
          ry: constants.gripRadius
        }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style("stroke-width", sliderOpts.borderwidth + "px");
      }
      function drawLabel(item, data, sliderOpts) {
        var text = Lib.ensureSingle(item, "text", constants.labelClass, function(s) {
          s.attr({
            "text-anchor": "middle",
            "data-notex": 1
          });
        });
        var tx = data.step.label;
        var _meta = sliderOpts._gd._fullLayout._meta;
        if (_meta) tx = Lib.templateString(tx, _meta);
        text.call(Drawing.font, sliderOpts.font).text(tx).call(svgTextUtils.convertToTspans, sliderOpts._gd);
        return text;
      }
      function drawLabelGroup(sliderGroup, sliderOpts) {
        var labels = Lib.ensureSingle(sliderGroup, "g", constants.labelsClass);
        var dims = sliderOpts._dims;
        var labelItems = labels.selectAll("g." + constants.labelGroupClass).data(dims.labelSteps);
        labelItems.enter().append("g").classed(constants.labelGroupClass, true);
        labelItems.exit().remove();
        labelItems.each(function(d) {
          var item = d3.select(this);
          item.call(drawLabel, d, sliderOpts);
          Drawing.setTranslate(
            item,
            normalizedValueToPosition(sliderOpts, d.fraction),
            constants.tickOffset + sliderOpts.ticklen + // position is the baseline of the top line of text only, even
            // if the label spans multiple lines
            sliderOpts.font.size * LINE_SPACING + constants.labelOffset + dims.currentValueTotalHeight
          );
        });
      }
      function handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {
        var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));
        var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;
        if (quantizedIndex !== sliderOpts.active) {
          setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);
        }
      }
      function setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {
        var previousActive = sliderOpts.active;
        sliderOpts.active = index;
        arrayEditor(gd.layout, constants.name, sliderOpts).applyUpdate("active", index);
        var step = sliderOpts.steps[sliderOpts.active];
        sliderGroup.call(setGripPosition, sliderOpts, doTransition);
        sliderGroup.call(drawCurrentValue, sliderOpts);
        gd.emit("plotly_sliderchange", {
          slider: sliderOpts,
          step: sliderOpts.steps[sliderOpts.active],
          interaction: doCallback,
          previousActive
        });
        if (step && step.method && doCallback) {
          if (sliderGroup._nextMethod) {
            sliderGroup._nextMethod.step = step;
            sliderGroup._nextMethod.doCallback = doCallback;
            sliderGroup._nextMethod.doTransition = doTransition;
          } else {
            sliderGroup._nextMethod = { step, doCallback, doTransition };
            sliderGroup._nextMethodRaf = window.requestAnimationFrame(function() {
              var _step = sliderGroup._nextMethod.step;
              if (!_step.method) return;
              if (_step.execute) {
                Plots.executeAPICommand(gd, _step.method, _step.args);
              }
              sliderGroup._nextMethod = null;
              sliderGroup._nextMethodRaf = null;
            });
          }
        }
      }
      function attachGripEvents(item, gd, sliderGroup) {
        if (gd._context.staticPlot) return;
        var node = sliderGroup.node();
        var $gd = d3.select(gd);
        function getSliderOpts() {
          return sliderGroup.data()[0];
        }
        function mouseDownHandler() {
          var sliderOpts = getSliderOpts();
          gd.emit("plotly_sliderstart", { slider: sliderOpts });
          var grip = sliderGroup.select("." + constants.gripRectClass);
          d3.event.stopPropagation();
          d3.event.preventDefault();
          grip.call(Color.fill, sliderOpts.activebgcolor);
          var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);
          handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);
          sliderOpts._dragging = true;
          function mouseMoveHandler() {
            var sliderOpts2 = getSliderOpts();
            var normalizedPosition2 = positionToNormalizedValue(sliderOpts2, d3.mouse(node)[0]);
            handleInput(gd, sliderGroup, sliderOpts2, normalizedPosition2, false);
          }
          $gd.on("mousemove", mouseMoveHandler);
          $gd.on("touchmove", mouseMoveHandler);
          function mouseUpHandler() {
            var sliderOpts2 = getSliderOpts();
            sliderOpts2._dragging = false;
            grip.call(Color.fill, sliderOpts2.bgcolor);
            $gd.on("mouseup", null);
            $gd.on("mousemove", null);
            $gd.on("touchend", null);
            $gd.on("touchmove", null);
            gd.emit("plotly_sliderend", {
              slider: sliderOpts2,
              step: sliderOpts2.steps[sliderOpts2.active]
            });
          }
          $gd.on("mouseup", mouseUpHandler);
          $gd.on("touchend", mouseUpHandler);
        }
        item.on("mousedown", mouseDownHandler);
        item.on("touchstart", mouseDownHandler);
      }
      function drawTicks(sliderGroup, sliderOpts) {
        var tick = sliderGroup.selectAll("rect." + constants.tickRectClass).data(sliderOpts._visibleSteps);
        var dims = sliderOpts._dims;
        tick.enter().append("rect").classed(constants.tickRectClass, true);
        tick.exit().remove();
        tick.attr({
          width: sliderOpts.tickwidth + "px",
          "shape-rendering": "crispEdges"
        });
        tick.each(function(d, i) {
          var isMajor = i % dims.labelStride === 0;
          var item = d3.select(this);
          item.attr({ height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen }).call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);
          Drawing.setTranslate(
            item,
            normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth,
            (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight
          );
        });
      }
      function computeLabelSteps(sliderOpts) {
        var dims = sliderOpts._dims;
        dims.labelSteps = [];
        var nsteps = sliderOpts._stepCount;
        for (var i = 0; i < nsteps; i += dims.labelStride) {
          dims.labelSteps.push({
            fraction: i / (nsteps - 1),
            step: sliderOpts._visibleSteps[i]
          });
        }
      }
      function setGripPosition(sliderGroup, sliderOpts, doTransition) {
        var grip = sliderGroup.select("rect." + constants.gripRectClass);
        var quantizedIndex = 0;
        for (var i = 0; i < sliderOpts._stepCount; i++) {
          if (sliderOpts._visibleSteps[i]._index === sliderOpts.active) {
            quantizedIndex = i;
            break;
          }
        }
        var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1));
        if (sliderOpts._invokingCommand) return;
        var el = grip;
        if (doTransition && sliderOpts.transition.duration > 0) {
          el = el.transition().duration(sliderOpts.transition.duration).ease(sliderOpts.transition.easing);
        }
        el.attr("transform", strTranslate(x - constants.gripWidth * 0.5, sliderOpts._dims.currentValueTotalHeight));
      }
      function normalizedValueToPosition(sliderOpts, normalizedPosition) {
        var dims = sliderOpts._dims;
        return dims.inputAreaStart + constants.stepInset + (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));
      }
      function positionToNormalizedValue(sliderOpts, position) {
        var dims = sliderOpts._dims;
        return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));
      }
      function drawTouchRect(sliderGroup, gd, sliderOpts) {
        var dims = sliderOpts._dims;
        var rect = Lib.ensureSingle(sliderGroup, "rect", constants.railTouchRectClass, function(s) {
          s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style("pointer-events", "all");
        });
        rect.attr({
          width: dims.inputAreaLength,
          height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)
        }).call(Color.fill, sliderOpts.bgcolor).attr("opacity", 0);
        Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);
      }
      function drawRail(sliderGroup, sliderOpts) {
        var dims = sliderOpts._dims;
        var computedLength = dims.inputAreaLength - constants.railInset * 2;
        var rect = Lib.ensureSingle(sliderGroup, "rect", constants.railRectClass);
        rect.attr({
          width: computedLength,
          height: constants.railWidth,
          rx: constants.railRadius,
          ry: constants.railRadius,
          "shape-rendering": "crispEdges"
        }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style("stroke-width", sliderOpts.borderwidth + "px");
        Drawing.setTranslate(
          rect,
          constants.railInset,
          (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight
        );
      }
    }
  });

  // src/components/sliders/index.js
  var require_sliders = __commonJS({
    "src/components/sliders/index.js"(exports, module) {
      "use strict";
      var constants = require_constants10();
      module.exports = {
        moduleType: "component",
        name: constants.name,
        layoutAttributes: require_attributes19(),
        supplyLayoutDefaults: require_defaults15(),
        draw: require_draw8()
      };
    }
  });

  // src/components/rangeslider/attributes.js
  var require_attributes20 = __commonJS({
    "src/components/rangeslider/attributes.js"(exports, module) {
      "use strict";
      var colorAttributes = require_attributes3();
      module.exports = {
        bgcolor: {
          valType: "color",
          dflt: colorAttributes.background,
          editType: "plot"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttributes.defaultLine,
          editType: "plot"
        },
        borderwidth: {
          valType: "integer",
          dflt: 0,
          min: 0,
          editType: "plot"
        },
        autorange: {
          valType: "boolean",
          dflt: true,
          editType: "calc",
          impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
        },
        range: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "calc", impliedEdits: { "^autorange": false } },
            { valType: "any", editType: "calc", impliedEdits: { "^autorange": false } }
          ],
          editType: "calc",
          impliedEdits: { autorange: false }
        },
        thickness: {
          valType: "number",
          dflt: 0.15,
          min: 0,
          max: 1,
          editType: "plot"
        },
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "calc"
        },
        editType: "calc"
      };
    }
  });

  // src/components/rangeslider/oppaxis_attributes.js
  var require_oppaxis_attributes = __commonJS({
    "src/components/rangeslider/oppaxis_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        // not really a 'subplot' attribute container,
        // but this is the flag we use to denote attributes that
        // support yaxis, yaxis2, yaxis3, ... counters
        _isSubplotObj: true,
        rangemode: {
          valType: "enumerated",
          values: ["auto", "fixed", "match"],
          dflt: "match",
          editType: "calc"
        },
        range: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "plot" },
            { valType: "any", editType: "plot" }
          ],
          editType: "plot"
        },
        editType: "calc"
      };
    }
  });

  // src/components/rangeslider/constants.js
  var require_constants11 = __commonJS({
    "src/components/rangeslider/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // attribute container name
        name: "rangeslider",
        // class names
        containerClassName: "rangeslider-container",
        bgClassName: "rangeslider-bg",
        rangePlotClassName: "rangeslider-rangeplot",
        maskMinClassName: "rangeslider-mask-min",
        maskMaxClassName: "rangeslider-mask-max",
        slideBoxClassName: "rangeslider-slidebox",
        grabberMinClassName: "rangeslider-grabber-min",
        grabAreaMinClassName: "rangeslider-grabarea-min",
        handleMinClassName: "rangeslider-handle-min",
        grabberMaxClassName: "rangeslider-grabber-max",
        grabAreaMaxClassName: "rangeslider-grabarea-max",
        handleMaxClassName: "rangeslider-handle-max",
        maskMinOppAxisClassName: "rangeslider-mask-min-opp-axis",
        maskMaxOppAxisClassName: "rangeslider-mask-max-opp-axis",
        // style constants
        maskColor: "rgba(0,0,0,0.4)",
        maskOppAxisColor: "rgba(0,0,0,0.2)",
        slideBoxFill: "transparent",
        slideBoxCursor: "ew-resize",
        grabAreaFill: "transparent",
        grabAreaCursor: "col-resize",
        grabAreaWidth: 10,
        handleWidth: 4,
        handleRadius: 1,
        handleStrokeWidth: 1,
        extraPad: 15
      };
    }
  });

  // src/components/rangeslider/helpers.js
  var require_helpers11 = __commonJS({
    "src/components/rangeslider/helpers.js"(exports) {
      "use strict";
      var axisIDs = require_axis_ids();
      var svgTextUtils = require_svg_text_utils();
      var constants = require_constants11();
      var LINE_SPACING = require_alignment().LINE_SPACING;
      var name = constants.name;
      function isVisible(ax) {
        var rangeSlider = ax && ax[name];
        return rangeSlider && rangeSlider.visible;
      }
      exports.isVisible = isVisible;
      exports.makeData = function(fullLayout) {
        var axes = axisIDs.list({ _fullLayout: fullLayout }, "x", true);
        var margin = fullLayout.margin;
        var rangeSliderData = [];
        for (var i = 0; i < axes.length; i++) {
          var ax = axes[i];
          if (isVisible(ax)) {
            rangeSliderData.push(ax);
            var opts = ax[name];
            opts._id = name + ax._id;
            opts._height = (fullLayout.height - margin.b - margin.t) * opts.thickness;
            opts._offsetShift = Math.floor(opts.borderwidth / 2);
          }
        }
        fullLayout._rangeSliderData = rangeSliderData;
      };
      exports.autoMarginOpts = function(gd, ax) {
        var fullLayout = gd._fullLayout;
        var opts = ax[name];
        var axLetter = ax._id.charAt(0);
        var bottomDepth = 0;
        var titleHeight = 0;
        if (ax.side === "bottom") {
          bottomDepth = ax._depth;
          if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
            titleHeight = 1.5 * ax.title.font.size + 10 + opts._offsetShift;
            var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
            titleHeight += extraLines * ax.title.font.size * LINE_SPACING;
          }
        }
        return {
          x: 0,
          y: ax._counterDomainMin,
          l: 0,
          r: 0,
          t: 0,
          b: opts._height + bottomDepth + Math.max(fullLayout.margin.b, titleHeight),
          pad: constants.extraPad + opts._offsetShift * 2
        };
      };
    }
  });

  // src/components/rangeslider/defaults.js
  var require_defaults16 = __commonJS({
    "src/components/rangeslider/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var axisIds = require_axis_ids();
      var attributes = require_attributes20();
      var oppAxisAttrs = require_oppaxis_attributes();
      module.exports = function handleDefaults(layoutIn, layoutOut, axName) {
        var axIn = layoutIn[axName];
        var axOut = layoutOut[axName];
        if (!(axIn.rangeslider || layoutOut._requestRangeslider[axOut._id])) return;
        if (!Lib.isPlainObject(axIn.rangeslider)) {
          axIn.rangeslider = {};
        }
        var containerIn = axIn.rangeslider;
        var containerOut = Template.newContainer(axOut, "rangeslider");
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        var rangeContainerIn, rangeContainerOut;
        function coerceRange(attr, dflt) {
          return Lib.coerce(rangeContainerIn, rangeContainerOut, oppAxisAttrs, attr, dflt);
        }
        var visible = coerce("visible");
        if (!visible) return;
        coerce("bgcolor", layoutOut.plot_bgcolor);
        coerce("bordercolor");
        coerce("borderwidth");
        coerce("thickness");
        coerce("autorange", !axOut.isValidRange(containerIn.range));
        coerce("range");
        var subplots = layoutOut._subplots;
        if (subplots) {
          var yIds = subplots.cartesian.filter(function(subplotId) {
            return subplotId.substr(0, subplotId.indexOf("y")) === axisIds.name2id(axName);
          }).map(function(subplotId) {
            return subplotId.substr(subplotId.indexOf("y"), subplotId.length);
          });
          var yNames = Lib.simpleMap(yIds, axisIds.id2name);
          for (var i = 0; i < yNames.length; i++) {
            var yName = yNames[i];
            rangeContainerIn = containerIn[yName] || {};
            rangeContainerOut = Template.newContainer(containerOut, yName, "yaxis");
            var yAxOut = layoutOut[yName];
            var rangemodeDflt;
            if (rangeContainerIn.range && yAxOut.isValidRange(rangeContainerIn.range)) {
              rangemodeDflt = "fixed";
            }
            var rangeMode = coerceRange("rangemode", rangemodeDflt);
            if (rangeMode !== "match") {
              coerceRange("range", yAxOut.range.slice());
            }
          }
        }
        containerOut._input = containerIn;
      };
    }
  });

  // src/components/rangeslider/calc_autorange.js
  var require_calc_autorange3 = __commonJS({
    "src/components/rangeslider/calc_autorange.js"(exports, module) {
      "use strict";
      var listAxes = require_axis_ids().list;
      var getAutoRange = require_autorange().getAutoRange;
      var constants = require_constants11();
      module.exports = function calcAutorange(gd) {
        var axes = listAxes(gd, "x", true);
        for (var i = 0; i < axes.length; i++) {
          var ax = axes[i];
          var opts = ax[constants.name];
          if (opts && opts.visible && opts.autorange) {
            opts._input.autorange = true;
            opts._input.range = opts.range = getAutoRange(gd, ax);
          }
        }
      };
    }
  });

  // src/components/rangeslider/draw.js
  var require_draw9 = __commonJS({
    "src/components/rangeslider/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Drawing = require_drawing();
      var Color = require_color();
      var Titles = require_titles();
      var Cartesian = require_cartesian();
      var axisIDs = require_axis_ids();
      var dragElement = require_dragelement();
      var setCursor = require_setcursor();
      var constants = require_constants11();
      module.exports = function(gd) {
        var fullLayout = gd._fullLayout;
        var rangeSliderData = fullLayout._rangeSliderData;
        for (var i = 0; i < rangeSliderData.length; i++) {
          var opts = rangeSliderData[i][constants.name];
          opts._clipId = opts._id + "-" + fullLayout._uid;
        }
        function keyFunction(axisOpts) {
          return axisOpts._name;
        }
        var rangeSliders = fullLayout._infolayer.selectAll("g." + constants.containerClassName).data(rangeSliderData, keyFunction);
        rangeSliders.exit().each(function(axisOpts) {
          var opts2 = axisOpts[constants.name];
          fullLayout._topdefs.select("#" + opts2._clipId).remove();
        }).remove();
        if (rangeSliderData.length === 0) return;
        rangeSliders.enter().append("g").classed(constants.containerClassName, true).attr("pointer-events", "all");
        rangeSliders.each(function(axisOpts) {
          var rangeSlider = d3.select(this);
          var opts2 = axisOpts[constants.name];
          var oppAxisOpts = fullLayout[axisIDs.id2name(axisOpts.anchor)];
          var oppAxisRangeOpts = opts2[axisIDs.id2name(axisOpts.anchor)];
          if (opts2.range) {
            var rng = Lib.simpleMap(opts2.range, axisOpts.r2l);
            var axRng = Lib.simpleMap(axisOpts.range, axisOpts.r2l);
            var newRng;
            if (axRng[0] < axRng[1]) {
              newRng = [
                Math.min(rng[0], axRng[0]),
                Math.max(rng[1], axRng[1])
              ];
            } else {
              newRng = [
                Math.max(rng[0], axRng[0]),
                Math.min(rng[1], axRng[1])
              ];
            }
            opts2.range = opts2._input.range = Lib.simpleMap(newRng, axisOpts.l2r);
          }
          axisOpts.cleanRange("rangeslider.range");
          var gs = fullLayout._size;
          var domain = axisOpts.domain;
          opts2._width = gs.w * (domain[1] - domain[0]);
          var x = Math.round(gs.l + gs.w * domain[0]);
          var y = Math.round(
            gs.t + gs.h * (1 - axisOpts._counterDomainMin) + (axisOpts.side === "bottom" ? axisOpts._depth : 0) + opts2._offsetShift + constants.extraPad
          );
          rangeSlider.attr("transform", strTranslate(x, y));
          opts2._rl = Lib.simpleMap(opts2.range, axisOpts.r2l);
          var rl0 = opts2._rl[0];
          var rl1 = opts2._rl[1];
          var drl = rl1 - rl0;
          opts2.p2d = function(v) {
            return v / opts2._width * drl + rl0;
          };
          opts2.d2p = function(v) {
            return (v - rl0) / drl * opts2._width;
          };
          if (axisOpts.rangebreaks) {
            var rsBreaks = axisOpts.locateBreaks(rl0, rl1);
            if (rsBreaks.length) {
              var j, brk;
              var lBreaks = 0;
              for (j = 0; j < rsBreaks.length; j++) {
                brk = rsBreaks[j];
                lBreaks += brk.max - brk.min;
              }
              var m2 = opts2._width / (rl1 - rl0 - lBreaks);
              var _B = [-m2 * rl0];
              for (j = 0; j < rsBreaks.length; j++) {
                brk = rsBreaks[j];
                _B.push(_B[_B.length - 1] - m2 * (brk.max - brk.min));
              }
              opts2.d2p = function(v) {
                var b = _B[0];
                for (var j2 = 0; j2 < rsBreaks.length; j2++) {
                  var brk2 = rsBreaks[j2];
                  if (v >= brk2.max) b = _B[j2 + 1];
                  else if (v < brk2.min) break;
                }
                return b + m2 * v;
              };
              for (j = 0; j < rsBreaks.length; j++) {
                brk = rsBreaks[j];
                brk.pmin = opts2.d2p(brk.min);
                brk.pmax = opts2.d2p(brk.max);
              }
              opts2.p2d = function(v) {
                var b = _B[0];
                for (var j2 = 0; j2 < rsBreaks.length; j2++) {
                  var brk2 = rsBreaks[j2];
                  if (v >= brk2.pmax) b = _B[j2 + 1];
                  else if (v < brk2.pmin) break;
                }
                return (v - b) / m2;
              };
            }
          }
          if (oppAxisRangeOpts.rangemode !== "match") {
            var range0OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);
            var range1OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);
            var distOppAxis = range1OppAxis - range0OppAxis;
            opts2.d2pOppAxis = function(v) {
              return (v - range0OppAxis) / distOppAxis * opts2._height;
            };
          }
          rangeSlider.call(drawBg, gd, axisOpts, opts2).call(addClipPath, gd, axisOpts, opts2).call(drawRangePlot, gd, axisOpts, opts2).call(drawMasks, gd, axisOpts, opts2, oppAxisRangeOpts).call(drawSlideBox, gd, axisOpts, opts2).call(drawGrabbers, gd, axisOpts, opts2);
          setupDragElement(rangeSlider, gd, axisOpts, opts2);
          setPixelRange(rangeSlider, gd, axisOpts, opts2, oppAxisOpts, oppAxisRangeOpts);
          if (axisOpts.side === "bottom") {
            Titles.draw(gd, axisOpts._id + "title", {
              propContainer: axisOpts,
              propName: axisOpts._name + ".title",
              placeholder: fullLayout._dfltTitle.x,
              attributes: {
                x: axisOpts._offset + axisOpts._length / 2,
                y: y + opts2._height + opts2._offsetShift + 10 + 1.5 * axisOpts.title.font.size,
                "text-anchor": "middle"
              }
            });
          }
        });
      };
      function eventX(event) {
        if (typeof event.clientX === "number") {
          return event.clientX;
        }
        if (event.touches && event.touches.length > 0) {
          return event.touches[0].clientX;
        }
        return 0;
      }
      function setupDragElement(rangeSlider, gd, axisOpts, opts) {
        if (gd._context.staticPlot) return;
        var slideBox = rangeSlider.select("rect." + constants.slideBoxClassName).node();
        var grabAreaMin = rangeSlider.select("rect." + constants.grabAreaMinClassName).node();
        var grabAreaMax = rangeSlider.select("rect." + constants.grabAreaMaxClassName).node();
        function mouseDownHandler() {
          var event = d3.event;
          var target = event.target;
          var startX = eventX(event);
          var offsetX = startX - rangeSlider.node().getBoundingClientRect().left;
          var minVal = opts.d2p(axisOpts._rl[0]);
          var maxVal = opts.d2p(axisOpts._rl[1]);
          var dragCover = dragElement.coverSlip();
          this.addEventListener("touchmove", mouseMove);
          this.addEventListener("touchend", mouseUp);
          dragCover.addEventListener("mousemove", mouseMove);
          dragCover.addEventListener("mouseup", mouseUp);
          function mouseMove(e) {
            var clientX = eventX(e);
            var delta = +clientX - startX;
            var pixelMin, pixelMax, cursor;
            switch (target) {
              case slideBox:
                cursor = "ew-resize";
                if (minVal + delta > axisOpts._length || maxVal + delta < 0) {
                  return;
                }
                pixelMin = minVal + delta;
                pixelMax = maxVal + delta;
                break;
              case grabAreaMin:
                cursor = "col-resize";
                if (minVal + delta > axisOpts._length) {
                  return;
                }
                pixelMin = minVal + delta;
                pixelMax = maxVal;
                break;
              case grabAreaMax:
                cursor = "col-resize";
                if (maxVal + delta < 0) {
                  return;
                }
                pixelMin = minVal;
                pixelMax = maxVal + delta;
                break;
              default:
                cursor = "ew-resize";
                pixelMin = offsetX;
                pixelMax = offsetX + delta;
                break;
            }
            if (pixelMax < pixelMin) {
              var tmp = pixelMax;
              pixelMax = pixelMin;
              pixelMin = tmp;
            }
            opts._pixelMin = pixelMin;
            opts._pixelMax = pixelMax;
            setCursor(d3.select(dragCover), cursor);
            setDataRange(rangeSlider, gd, axisOpts, opts);
          }
          function mouseUp() {
            dragCover.removeEventListener("mousemove", mouseMove);
            dragCover.removeEventListener("mouseup", mouseUp);
            this.removeEventListener("touchmove", mouseMove);
            this.removeEventListener("touchend", mouseUp);
            Lib.removeElement(dragCover);
          }
        }
        rangeSlider.on("mousedown", mouseDownHandler);
        rangeSlider.on("touchstart", mouseDownHandler);
      }
      function setDataRange(rangeSlider, gd, axisOpts, opts) {
        function clamp(v) {
          return axisOpts.l2r(Lib.constrain(v, opts._rl[0], opts._rl[1]));
        }
        var dataMin = clamp(opts.p2d(opts._pixelMin));
        var dataMax = clamp(opts.p2d(opts._pixelMax));
        window.requestAnimationFrame(function() {
          Registry.call("_guiRelayout", gd, axisOpts._name + ".range", [dataMin, dataMax]);
        });
      }
      function setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts) {
        var hw2 = constants.handleWidth / 2;
        function clamp(v) {
          return Lib.constrain(v, 0, opts._width);
        }
        function clampOppAxis(v) {
          return Lib.constrain(v, 0, opts._height);
        }
        function clampHandle(v) {
          return Lib.constrain(v, -hw2, opts._width + hw2);
        }
        var pixelMin = clamp(opts.d2p(axisOpts._rl[0]));
        var pixelMax = clamp(opts.d2p(axisOpts._rl[1]));
        rangeSlider.select("rect." + constants.slideBoxClassName).attr("x", pixelMin).attr("width", pixelMax - pixelMin);
        rangeSlider.select("rect." + constants.maskMinClassName).attr("width", pixelMin);
        rangeSlider.select("rect." + constants.maskMaxClassName).attr("x", pixelMax).attr("width", opts._width - pixelMax);
        if (oppAxisRangeOpts.rangemode !== "match") {
          var pixelMinOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));
          var pixelMaxOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));
          rangeSlider.select("rect." + constants.maskMinOppAxisClassName).attr("x", pixelMin).attr("height", pixelMinOppAxis).attr("width", pixelMax - pixelMin);
          rangeSlider.select("rect." + constants.maskMaxOppAxisClassName).attr("x", pixelMin).attr("y", pixelMaxOppAxis).attr("height", opts._height - pixelMaxOppAxis).attr("width", pixelMax - pixelMin);
          rangeSlider.select("rect." + constants.slideBoxClassName).attr("y", pixelMinOppAxis).attr("height", pixelMaxOppAxis - pixelMinOppAxis);
        }
        var offset = 0.5;
        var xMin = Math.round(clampHandle(pixelMin - hw2)) - offset;
        var xMax = Math.round(clampHandle(pixelMax - hw2)) + offset;
        rangeSlider.select("g." + constants.grabberMinClassName).attr("transform", strTranslate(xMin, offset));
        rangeSlider.select("g." + constants.grabberMaxClassName).attr("transform", strTranslate(xMax, offset));
      }
      function drawBg(rangeSlider, gd, axisOpts, opts) {
        var bg = Lib.ensureSingle(rangeSlider, "rect", constants.bgClassName, function(s) {
          s.attr({
            x: 0,
            y: 0,
            "shape-rendering": "crispEdges"
          });
        });
        var borderCorrect = opts.borderwidth % 2 === 0 ? opts.borderwidth : opts.borderwidth - 1;
        var offsetShift = -opts._offsetShift;
        var lw = Drawing.crispRound(gd, opts.borderwidth);
        bg.attr({
          width: opts._width + borderCorrect,
          height: opts._height + borderCorrect,
          transform: strTranslate(offsetShift, offsetShift),
          "stroke-width": lw
        }).call(Color.stroke, opts.bordercolor).call(Color.fill, opts.bgcolor);
      }
      function addClipPath(rangeSlider, gd, axisOpts, opts) {
        var fullLayout = gd._fullLayout;
        var clipPath = Lib.ensureSingleById(fullLayout._topdefs, "clipPath", opts._clipId, function(s) {
          s.append("rect").attr({ x: 0, y: 0 });
        });
        clipPath.select("rect").attr({
          width: opts._width,
          height: opts._height
        });
      }
      function drawRangePlot(rangeSlider, gd, axisOpts, opts) {
        var calcData = gd.calcdata;
        var rangePlots = rangeSlider.selectAll("g." + constants.rangePlotClassName).data(axisOpts._subplotsWith, Lib.identity);
        rangePlots.enter().append("g").attr("class", function(id) {
          return constants.rangePlotClassName + " " + id;
        }).call(Drawing.setClipUrl, opts._clipId, gd);
        rangePlots.order();
        rangePlots.exit().remove();
        var mainplotinfo;
        rangePlots.each(function(id, i) {
          var plotgroup = d3.select(this);
          var isMainPlot = i === 0;
          var oppAxisOpts = axisIDs.getFromId(gd, id, "y");
          var oppAxisName = oppAxisOpts._name;
          var oppAxisRangeOpts = opts[oppAxisName];
          var mockFigure = {
            data: [],
            layout: {
              xaxis: {
                type: axisOpts.type,
                domain: [0, 1],
                range: opts.range.slice(),
                calendar: axisOpts.calendar
              },
              width: opts._width,
              height: opts._height,
              margin: { t: 0, b: 0, l: 0, r: 0 }
            },
            _context: gd._context
          };
          if (axisOpts.rangebreaks) {
            mockFigure.layout.xaxis.rangebreaks = axisOpts.rangebreaks;
          }
          mockFigure.layout[oppAxisName] = {
            type: oppAxisOpts.type,
            domain: [0, 1],
            range: oppAxisRangeOpts.rangemode !== "match" ? oppAxisRangeOpts.range.slice() : oppAxisOpts.range.slice(),
            calendar: oppAxisOpts.calendar
          };
          if (oppAxisOpts.rangebreaks) {
            mockFigure.layout[oppAxisName].rangebreaks = oppAxisOpts.rangebreaks;
          }
          Plots.supplyDefaults(mockFigure);
          var xa = mockFigure._fullLayout.xaxis;
          var ya = mockFigure._fullLayout[oppAxisName];
          xa.clearCalc();
          xa.setScale();
          ya.clearCalc();
          ya.setScale();
          var plotinfo = {
            id,
            plotgroup,
            xaxis: xa,
            yaxis: ya,
            isRangePlot: true
          };
          if (isMainPlot) mainplotinfo = plotinfo;
          else {
            plotinfo.mainplot = "xy";
            plotinfo.mainplotinfo = mainplotinfo;
          }
          Cartesian.rangePlot(gd, plotinfo, filterRangePlotCalcData(calcData, id));
        });
      }
      function filterRangePlotCalcData(calcData, subplotId) {
        var out = [];
        for (var i = 0; i < calcData.length; i++) {
          var calcTrace = calcData[i];
          var trace = calcTrace[0].trace;
          if (trace.xaxis + trace.yaxis === subplotId) {
            out.push(calcTrace);
          }
        }
        return out;
      }
      function drawMasks(rangeSlider, gd, axisOpts, opts, oppAxisRangeOpts) {
        var maskMin = Lib.ensureSingle(rangeSlider, "rect", constants.maskMinClassName, function(s) {
          s.attr({
            x: 0,
            y: 0,
            "shape-rendering": "crispEdges"
          });
        });
        maskMin.attr("height", opts._height).call(Color.fill, constants.maskColor);
        var maskMax = Lib.ensureSingle(rangeSlider, "rect", constants.maskMaxClassName, function(s) {
          s.attr({
            y: 0,
            "shape-rendering": "crispEdges"
          });
        });
        maskMax.attr("height", opts._height).call(Color.fill, constants.maskColor);
        if (oppAxisRangeOpts.rangemode !== "match") {
          var maskMinOppAxis = Lib.ensureSingle(rangeSlider, "rect", constants.maskMinOppAxisClassName, function(s) {
            s.attr({
              y: 0,
              "shape-rendering": "crispEdges"
            });
          });
          maskMinOppAxis.attr("width", opts._width).call(Color.fill, constants.maskOppAxisColor);
          var maskMaxOppAxis = Lib.ensureSingle(rangeSlider, "rect", constants.maskMaxOppAxisClassName, function(s) {
            s.attr({
              y: 0,
              "shape-rendering": "crispEdges"
            });
          });
          maskMaxOppAxis.attr("width", opts._width).style("border-top", constants.maskOppBorder).call(Color.fill, constants.maskOppAxisColor);
        }
      }
      function drawSlideBox(rangeSlider, gd, axisOpts, opts) {
        if (gd._context.staticPlot) return;
        var slideBox = Lib.ensureSingle(rangeSlider, "rect", constants.slideBoxClassName, function(s) {
          s.attr({
            y: 0,
            cursor: constants.slideBoxCursor,
            "shape-rendering": "crispEdges"
          });
        });
        slideBox.attr({
          height: opts._height,
          fill: constants.slideBoxFill
        });
      }
      function drawGrabbers(rangeSlider, gd, axisOpts, opts) {
        var grabberMin = Lib.ensureSingle(rangeSlider, "g", constants.grabberMinClassName);
        var grabberMax = Lib.ensureSingle(rangeSlider, "g", constants.grabberMaxClassName);
        var handleFixAttrs = {
          x: 0,
          width: constants.handleWidth,
          rx: constants.handleRadius,
          fill: Color.background,
          stroke: Color.defaultLine,
          "stroke-width": constants.handleStrokeWidth,
          "shape-rendering": "crispEdges"
        };
        var handleDynamicAttrs = {
          y: Math.round(opts._height / 4),
          height: Math.round(opts._height / 2)
        };
        var handleMin = Lib.ensureSingle(grabberMin, "rect", constants.handleMinClassName, function(s) {
          s.attr(handleFixAttrs);
        });
        handleMin.attr(handleDynamicAttrs);
        var handleMax = Lib.ensureSingle(grabberMax, "rect", constants.handleMaxClassName, function(s) {
          s.attr(handleFixAttrs);
        });
        handleMax.attr(handleDynamicAttrs);
        var grabAreaFixAttrs = {
          width: constants.grabAreaWidth,
          x: 0,
          y: 0,
          fill: constants.grabAreaFill,
          cursor: !gd._context.staticPlot ? constants.grabAreaCursor : void 0
        };
        var grabAreaMin = Lib.ensureSingle(grabberMin, "rect", constants.grabAreaMinClassName, function(s) {
          s.attr(grabAreaFixAttrs);
        });
        grabAreaMin.attr("height", opts._height);
        var grabAreaMax = Lib.ensureSingle(grabberMax, "rect", constants.grabAreaMaxClassName, function(s) {
          s.attr(grabAreaFixAttrs);
        });
        grabAreaMax.attr("height", opts._height);
      }
    }
  });

  // src/components/rangeslider/index.js
  var require_rangeslider = __commonJS({
    "src/components/rangeslider/index.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var attrs = require_attributes20();
      var oppAxisAttrs = require_oppaxis_attributes();
      var helpers = require_helpers11();
      module.exports = {
        moduleType: "component",
        name: "rangeslider",
        schema: {
          subplots: {
            xaxis: {
              rangeslider: Lib.extendFlat({}, attrs, {
                yaxis: oppAxisAttrs
              })
            }
          }
        },
        layoutAttributes: require_attributes20(),
        handleDefaults: require_defaults16(),
        calcAutorange: require_calc_autorange3(),
        draw: require_draw9(),
        isVisible: helpers.isVisible,
        makeData: helpers.makeData,
        autoMarginOpts: helpers.autoMarginOpts
      };
    }
  });

  // src/components/rangeselector/attributes.js
  var require_attributes21 = __commonJS({
    "src/components/rangeselector/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      var templatedArray = require_plot_template().templatedArray;
      var buttonAttrs = templatedArray("button", {
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "plot"
        },
        step: {
          valType: "enumerated",
          values: ["month", "year", "day", "hour", "minute", "second", "all"],
          dflt: "month",
          editType: "plot"
        },
        stepmode: {
          valType: "enumerated",
          values: ["backward", "todate"],
          dflt: "backward",
          editType: "plot"
        },
        count: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "plot"
        },
        label: {
          valType: "string",
          editType: "plot"
        },
        editType: "plot"
      });
      module.exports = {
        visible: {
          valType: "boolean",
          editType: "plot"
        },
        buttons: buttonAttrs,
        x: {
          valType: "number",
          min: -2,
          max: 3,
          editType: "plot"
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "left",
          editType: "plot"
        },
        y: {
          valType: "number",
          min: -2,
          max: 3,
          editType: "plot"
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "bottom",
          editType: "plot"
        },
        font: fontAttrs({
          editType: "plot"
        }),
        bgcolor: {
          valType: "color",
          dflt: colorAttrs.lightLine,
          editType: "plot"
        },
        activecolor: {
          valType: "color",
          editType: "plot"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "plot"
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "plot"
        },
        editType: "plot"
      };
    }
  });

  // src/components/rangeselector/constants.js
  var require_constants12 = __commonJS({
    "src/components/rangeselector/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // 'y' position pad above counter axis domain
        yPad: 0.02,
        // minimum button width (regardless of text size)
        minButtonWidth: 30,
        // buttons rect radii
        rx: 3,
        ry: 3,
        // light fraction used to compute the 'activecolor' default
        lightAmount: 25,
        darkAmount: 10
      };
    }
  });

  // src/components/rangeselector/defaults.js
  var require_defaults17 = __commonJS({
    "src/components/rangeselector/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var Template = require_plot_template();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes21();
      var constants = require_constants12();
      module.exports = function handleDefaults(containerIn, containerOut, layout, counterAxes, calendar) {
        var selectorIn = containerIn.rangeselector || {};
        var selectorOut = Template.newContainer(containerOut, "rangeselector");
        function coerce(attr, dflt) {
          return Lib.coerce(selectorIn, selectorOut, attributes, attr, dflt);
        }
        var buttons = handleArrayContainerDefaults(selectorIn, selectorOut, {
          name: "buttons",
          handleItemDefaults: buttonDefaults,
          calendar
        });
        var visible = coerce("visible", buttons.length > 0);
        if (visible) {
          var posDflt = getPosDflt(containerOut, layout, counterAxes);
          coerce("x", posDflt[0]);
          coerce("y", posDflt[1]);
          Lib.noneOrAll(containerIn, containerOut, ["x", "y"]);
          coerce("xanchor");
          coerce("yanchor");
          Lib.coerceFont(coerce, "font", layout.font);
          var bgColor = coerce("bgcolor");
          coerce("activecolor", Color.contrast(bgColor, constants.lightAmount, constants.darkAmount));
          coerce("bordercolor");
          coerce("borderwidth");
        }
      };
      function buttonDefaults(buttonIn, buttonOut, selectorOut, opts) {
        var calendar = opts.calendar;
        function coerce(attr, dflt) {
          return Lib.coerce(buttonIn, buttonOut, attributes.buttons, attr, dflt);
        }
        var visible = coerce("visible");
        if (visible) {
          var step = coerce("step");
          if (step !== "all") {
            if (calendar && calendar !== "gregorian" && (step === "month" || step === "year")) {
              buttonOut.stepmode = "backward";
            } else {
              coerce("stepmode");
            }
            coerce("count");
          }
          coerce("label");
        }
      }
      function getPosDflt(containerOut, layout, counterAxes) {
        var anchoredList = counterAxes.filter(function(ax) {
          return layout[ax].anchor === containerOut._id;
        });
        var posY = 0;
        for (var i = 0; i < anchoredList.length; i++) {
          var domain = layout[anchoredList[i]].domain;
          if (domain) posY = Math.max(domain[1], posY);
        }
        return [containerOut.domain[0], posY + constants.yPad];
      }
    }
  });

  // src/components/rangeselector/get_update_object.js
  var require_get_update_object = __commonJS({
    "src/components/rangeselector/get_update_object.js"(exports, module) {
      "use strict";
      var d3Time = require_d3_time();
      var titleCase = require_lib().titleCase;
      module.exports = function getUpdateObject(axisLayout, buttonLayout) {
        var axName = axisLayout._name;
        var update = {};
        if (buttonLayout.step === "all") {
          update[axName + ".autorange"] = true;
        } else {
          var xrange = getXRange(axisLayout, buttonLayout);
          update[axName + ".range[0]"] = xrange[0];
          update[axName + ".range[1]"] = xrange[1];
        }
        return update;
      };
      function getXRange(axisLayout, buttonLayout) {
        var currentRange = axisLayout.range;
        var base = new Date(axisLayout.r2l(currentRange[1]));
        var step = buttonLayout.step;
        var utcStep = d3Time["utc" + titleCase(step)];
        var count = buttonLayout.count;
        var range0;
        switch (buttonLayout.stepmode) {
          case "backward":
            range0 = axisLayout.l2r(+utcStep.offset(base, -count));
            break;
          case "todate":
            var base2 = utcStep.offset(base, -count);
            range0 = axisLayout.l2r(+utcStep.ceil(base2));
            break;
        }
        var range1 = currentRange[1];
        return [range0, range1];
      }
    }
  });

  // src/components/rangeselector/draw.js
  var require_draw10 = __commonJS({
    "src/components/rangeselector/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var axisIds = require_axis_ids();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      var constants = require_constants12();
      var getUpdateObject = require_get_update_object();
      module.exports = function draw(gd) {
        var fullLayout = gd._fullLayout;
        var selectors = fullLayout._infolayer.selectAll(".rangeselector").data(makeSelectorData(gd), selectorKeyFunc);
        selectors.enter().append("g").classed("rangeselector", true);
        selectors.exit().remove();
        selectors.style({
          cursor: "pointer",
          "pointer-events": "all"
        });
        selectors.each(function(d) {
          var selector = d3.select(this);
          var axisLayout = d;
          var selectorLayout = axisLayout.rangeselector;
          var buttons = selector.selectAll("g.button").data(Lib.filterVisible(selectorLayout.buttons));
          buttons.enter().append("g").classed("button", true);
          buttons.exit().remove();
          buttons.each(function(d2) {
            var button = d3.select(this);
            var update = getUpdateObject(axisLayout, d2);
            d2._isActive = isActive(axisLayout, d2, update);
            button.call(drawButtonRect, selectorLayout, d2);
            button.call(drawButtonText, selectorLayout, d2, gd);
            button.on("click", function() {
              if (gd._dragged) return;
              Registry.call("_guiRelayout", gd, update);
            });
            button.on("mouseover", function() {
              d2._isHovered = true;
              button.call(drawButtonRect, selectorLayout, d2);
            });
            button.on("mouseout", function() {
              d2._isHovered = false;
              button.call(drawButtonRect, selectorLayout, d2);
            });
          });
          reposition(gd, buttons, selectorLayout, axisLayout._name, selector);
        });
      };
      function makeSelectorData(gd) {
        var axes = axisIds.list(gd, "x", true);
        var data = [];
        for (var i = 0; i < axes.length; i++) {
          var axis = axes[i];
          if (axis.rangeselector && axis.rangeselector.visible) {
            data.push(axis);
          }
        }
        return data;
      }
      function selectorKeyFunc(d) {
        return d._id;
      }
      function isActive(axisLayout, opts, update) {
        if (opts.step === "all") {
          return axisLayout.autorange === true;
        } else {
          var keys = Object.keys(update);
          return axisLayout.range[0] === update[keys[0]] && axisLayout.range[1] === update[keys[1]];
        }
      }
      function drawButtonRect(button, selectorLayout, d) {
        var rect = Lib.ensureSingle(button, "rect", "selector-rect", function(s) {
          s.attr("shape-rendering", "crispEdges");
        });
        rect.attr({
          rx: constants.rx,
          ry: constants.ry
        });
        rect.call(Color.stroke, selectorLayout.bordercolor).call(Color.fill, getFillColor(selectorLayout, d)).style("stroke-width", selectorLayout.borderwidth + "px");
      }
      function getFillColor(selectorLayout, d) {
        return d._isActive || d._isHovered ? selectorLayout.activecolor : selectorLayout.bgcolor;
      }
      function drawButtonText(button, selectorLayout, d, gd) {
        function textLayout(s) {
          svgTextUtils.convertToTspans(s, gd);
        }
        var text = Lib.ensureSingle(button, "text", "selector-text", function(s) {
          s.attr("text-anchor", "middle");
        });
        text.call(Drawing.font, selectorLayout.font).text(getLabel(d, gd._fullLayout._meta)).call(textLayout);
      }
      function getLabel(opts, _meta) {
        if (opts.label) {
          return _meta ? Lib.templateString(opts.label, _meta) : opts.label;
        }
        if (opts.step === "all") return "all";
        return opts.count + opts.step.charAt(0);
      }
      function reposition(gd, buttons, opts, axName, selector) {
        var width = 0;
        var height = 0;
        var borderWidth = opts.borderwidth;
        buttons.each(function() {
          var button = d3.select(this);
          var text = button.select(".selector-text");
          var tHeight = opts.font.size * LINE_SPACING;
          var hEff = Math.max(tHeight * svgTextUtils.lineCount(text), 16) + 3;
          height = Math.max(height, hEff);
        });
        buttons.each(function() {
          var button = d3.select(this);
          var rect = button.select(".selector-rect");
          var text = button.select(".selector-text");
          var tWidth = text.node() && Drawing.bBox(text.node()).width;
          var tHeight = opts.font.size * LINE_SPACING;
          var tLines = svgTextUtils.lineCount(text);
          var wEff = Math.max(tWidth + 10, constants.minButtonWidth);
          button.attr("transform", strTranslate(borderWidth + width, borderWidth));
          rect.attr({
            x: 0,
            y: 0,
            width: wEff,
            height
          });
          svgTextUtils.positionText(
            text,
            wEff / 2,
            height / 2 - (tLines - 1) * tHeight / 2 + 3
          );
          width += wEff + 5;
        });
        var graphSize = gd._fullLayout._size;
        var lx = graphSize.l + graphSize.w * opts.x;
        var ly = graphSize.t + graphSize.h * (1 - opts.y);
        var xanchor = "left";
        if (Lib.isRightAnchor(opts)) {
          lx -= width;
          xanchor = "right";
        }
        if (Lib.isCenterAnchor(opts)) {
          lx -= width / 2;
          xanchor = "center";
        }
        var yanchor = "top";
        if (Lib.isBottomAnchor(opts)) {
          ly -= height;
          yanchor = "bottom";
        }
        if (Lib.isMiddleAnchor(opts)) {
          ly -= height / 2;
          yanchor = "middle";
        }
        width = Math.ceil(width);
        height = Math.ceil(height);
        lx = Math.round(lx);
        ly = Math.round(ly);
        Plots.autoMargin(gd, axName + "-range-selector", {
          x: opts.x,
          y: opts.y,
          l: width * FROM_TL[xanchor],
          r: width * FROM_BR[xanchor],
          b: height * FROM_BR[yanchor],
          t: height * FROM_TL[yanchor]
        });
        selector.attr("transform", strTranslate(lx, ly));
      }
    }
  });

  // src/components/rangeselector/index.js
  var require_rangeselector = __commonJS({
    "src/components/rangeselector/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "rangeselector",
        schema: {
          subplots: {
            xaxis: { rangeselector: require_attributes21() }
          }
        },
        layoutAttributes: require_attributes21(),
        handleDefaults: require_defaults17(),
        draw: require_draw10()
      };
    }
  });

  // src/plots/domain.js
  var require_domain = __commonJS({
    "src/plots/domain.js"(exports) {
      "use strict";
      var extendFlat = require_extend().extendFlat;
      exports.attributes = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var base = {
          valType: "info_array",
          editType: opts.editType,
          items: [
            { valType: "number", min: 0, max: 1, editType: opts.editType },
            { valType: "number", min: 0, max: 1, editType: opts.editType }
          ],
          dflt: [0, 1]
        };
        var namePart = opts.name ? opts.name + " " : "";
        var contPart = opts.trace ? "trace " : "subplot ";
        var descPart = extra.description ? " " + extra.description : "";
        var out = {
          x: extendFlat({}, base, {}),
          y: extendFlat({}, base, {}),
          editType: opts.editType
        };
        if (!opts.noGridCell) {
          out.row = {
            valType: "integer",
            min: 0,
            dflt: 0,
            editType: opts.editType
          };
          out.column = {
            valType: "integer",
            min: 0,
            dflt: 0,
            editType: opts.editType
          };
        }
        return out;
      };
      exports.defaults = function(containerOut, layout, coerce, dfltDomains) {
        var dfltX = dfltDomains && dfltDomains.x || [0, 1];
        var dfltY = dfltDomains && dfltDomains.y || [0, 1];
        var grid = layout.grid;
        if (grid) {
          var column = coerce("domain.column");
          if (column !== void 0) {
            if (column < grid.columns) dfltX = grid._domains.x[column];
            else delete containerOut.domain.column;
          }
          var row = coerce("domain.row");
          if (row !== void 0) {
            if (row < grid.rows) dfltY = grid._domains.y[row];
            else delete containerOut.domain.row;
          }
        }
        var x = coerce("domain.x", dfltX);
        var y = coerce("domain.y", dfltY);
        if (!(x[0] < x[1])) containerOut.domain.x = dfltX.slice();
        if (!(y[0] < y[1])) containerOut.domain.y = dfltY.slice();
      };
    }
  });

  // src/components/grid/index.js
  var require_grid = __commonJS({
    "src/components/grid/index.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var counterRegex = require_regex().counter;
      var domainAttrs = require_domain().attributes;
      var cartesianIdRegex = require_constants2().idRegex;
      var Template = require_plot_template();
      var gridAttrs = {
        rows: {
          valType: "integer",
          min: 1,
          editType: "plot"
        },
        roworder: {
          valType: "enumerated",
          values: ["top to bottom", "bottom to top"],
          dflt: "top to bottom",
          editType: "plot"
        },
        columns: {
          valType: "integer",
          min: 1,
          editType: "plot"
        },
        subplots: {
          valType: "info_array",
          freeLength: true,
          dimensions: 2,
          items: { valType: "enumerated", values: [counterRegex("xy").toString(), ""], editType: "plot" },
          editType: "plot"
        },
        xaxes: {
          valType: "info_array",
          freeLength: true,
          items: { valType: "enumerated", values: [cartesianIdRegex.x.toString(), ""], editType: "plot" },
          editType: "plot"
        },
        yaxes: {
          valType: "info_array",
          freeLength: true,
          items: { valType: "enumerated", values: [cartesianIdRegex.y.toString(), ""], editType: "plot" },
          editType: "plot"
        },
        pattern: {
          valType: "enumerated",
          values: ["independent", "coupled"],
          dflt: "coupled",
          editType: "plot"
        },
        xgap: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "plot"
        },
        ygap: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "plot"
        },
        domain: domainAttrs({ name: "grid", editType: "plot", noGridCell: true }, {}),
        xside: {
          valType: "enumerated",
          values: ["bottom", "bottom plot", "top plot", "top"],
          dflt: "bottom plot",
          editType: "plot"
        },
        yside: {
          valType: "enumerated",
          values: ["left", "left plot", "right plot", "right"],
          dflt: "left plot",
          editType: "plot"
        },
        editType: "plot"
      };
      function getAxes(layout, grid, axLetter) {
        var gridVal = grid[axLetter + "axes"];
        var splomVal = Object.keys((layout._splomAxes || {})[axLetter] || {});
        if (Array.isArray(gridVal)) return gridVal;
        if (splomVal.length) return splomVal;
      }
      function sizeDefaults(layoutIn, layoutOut) {
        var gridIn = layoutIn.grid || {};
        var xAxes = getAxes(layoutOut, gridIn, "x");
        var yAxes = getAxes(layoutOut, gridIn, "y");
        if (!layoutIn.grid && !xAxes && !yAxes) return;
        var hasSubplotGrid = Array.isArray(gridIn.subplots) && Array.isArray(gridIn.subplots[0]);
        var hasXaxes = Array.isArray(xAxes);
        var hasYaxes = Array.isArray(yAxes);
        var isSplomGenerated = hasXaxes && xAxes !== gridIn.xaxes && hasYaxes && yAxes !== gridIn.yaxes;
        var dfltRows, dfltColumns;
        if (hasSubplotGrid) {
          dfltRows = gridIn.subplots.length;
          dfltColumns = gridIn.subplots[0].length;
        } else {
          if (hasYaxes) dfltRows = yAxes.length;
          if (hasXaxes) dfltColumns = xAxes.length;
        }
        var gridOut = Template.newContainer(layoutOut, "grid");
        function coerce(attr, dflt) {
          return Lib.coerce(gridIn, gridOut, gridAttrs, attr, dflt);
        }
        var rows = coerce("rows", dfltRows);
        var columns = coerce("columns", dfltColumns);
        if (!(rows * columns > 1)) {
          delete layoutOut.grid;
          return;
        }
        if (!hasSubplotGrid && !hasXaxes && !hasYaxes) {
          var useDefaultSubplots = coerce("pattern") === "independent";
          if (useDefaultSubplots) hasSubplotGrid = true;
        }
        gridOut._hasSubplotGrid = hasSubplotGrid;
        var rowOrder = coerce("roworder");
        var reversed = rowOrder === "top to bottom";
        var dfltGapX = hasSubplotGrid ? 0.2 : 0.1;
        var dfltGapY = hasSubplotGrid ? 0.3 : 0.1;
        var dfltSideX, dfltSideY;
        if (isSplomGenerated && layoutOut._splomGridDflt) {
          dfltSideX = layoutOut._splomGridDflt.xside;
          dfltSideY = layoutOut._splomGridDflt.yside;
        }
        gridOut._domains = {
          x: fillGridPositions("x", coerce, dfltGapX, dfltSideX, columns),
          y: fillGridPositions("y", coerce, dfltGapY, dfltSideY, rows, reversed)
        };
      }
      function fillGridPositions(axLetter, coerce, dfltGap, dfltSide, len, reversed) {
        var dirGap = coerce(axLetter + "gap", dfltGap);
        var domain = coerce("domain." + axLetter);
        coerce(axLetter + "side", dfltSide);
        var out = new Array(len);
        var start = domain[0];
        var step = (domain[1] - start) / (len - dirGap);
        var cellDomain = step * (1 - dirGap);
        for (var i = 0; i < len; i++) {
          var cellStart = start + step * i;
          out[reversed ? len - 1 - i : i] = [cellStart, cellStart + cellDomain];
        }
        return out;
      }
      function contentDefaults(layoutIn, layoutOut) {
        var gridOut = layoutOut.grid;
        if (!gridOut || !gridOut._domains) return;
        var gridIn = layoutIn.grid || {};
        var subplots = layoutOut._subplots;
        var hasSubplotGrid = gridOut._hasSubplotGrid;
        var rows = gridOut.rows;
        var columns = gridOut.columns;
        var useDefaultSubplots = gridOut.pattern === "independent";
        var i, j, xId, yId, subplotId, subplotsOut, yPos;
        var axisMap = gridOut._axisMap = {};
        if (hasSubplotGrid) {
          var subplotsIn = gridIn.subplots || [];
          subplotsOut = gridOut.subplots = new Array(rows);
          var index = 1;
          for (i = 0; i < rows; i++) {
            var rowOut = subplotsOut[i] = new Array(columns);
            var rowIn = subplotsIn[i] || [];
            for (j = 0; j < columns; j++) {
              if (useDefaultSubplots) {
                subplotId = index === 1 ? "xy" : "x" + index + "y" + index;
                index++;
              } else subplotId = rowIn[j];
              rowOut[j] = "";
              if (subplots.cartesian.indexOf(subplotId) !== -1) {
                yPos = subplotId.indexOf("y");
                xId = subplotId.slice(0, yPos);
                yId = subplotId.slice(yPos);
                if (axisMap[xId] !== void 0 && axisMap[xId] !== j || axisMap[yId] !== void 0 && axisMap[yId] !== i) {
                  continue;
                }
                rowOut[j] = subplotId;
                axisMap[xId] = j;
                axisMap[yId] = i;
              }
            }
          }
        } else {
          var xAxes = getAxes(layoutOut, gridIn, "x");
          var yAxes = getAxes(layoutOut, gridIn, "y");
          gridOut.xaxes = fillGridAxes(xAxes, subplots.xaxis, columns, axisMap, "x");
          gridOut.yaxes = fillGridAxes(yAxes, subplots.yaxis, rows, axisMap, "y");
        }
        var anchors = gridOut._anchors = {};
        var reversed = gridOut.roworder === "top to bottom";
        for (var axisId in axisMap) {
          var axLetter = axisId.charAt(0);
          var side = gridOut[axLetter + "side"];
          var i0, inc, iFinal;
          if (side.length < 8) {
            anchors[axisId] = "free";
          } else if (axLetter === "x") {
            if (side.charAt(0) === "t" === reversed) {
              i0 = 0;
              inc = 1;
              iFinal = rows;
            } else {
              i0 = rows - 1;
              inc = -1;
              iFinal = -1;
            }
            if (hasSubplotGrid) {
              var column = axisMap[axisId];
              for (i = i0; i !== iFinal; i += inc) {
                subplotId = subplotsOut[i][column];
                if (!subplotId) continue;
                yPos = subplotId.indexOf("y");
                if (subplotId.slice(0, yPos) === axisId) {
                  anchors[axisId] = subplotId.slice(yPos);
                  break;
                }
              }
            } else {
              for (i = i0; i !== iFinal; i += inc) {
                yId = gridOut.yaxes[i];
                if (subplots.cartesian.indexOf(axisId + yId) !== -1) {
                  anchors[axisId] = yId;
                  break;
                }
              }
            }
          } else {
            if (side.charAt(0) === "l") {
              i0 = 0;
              inc = 1;
              iFinal = columns;
            } else {
              i0 = columns - 1;
              inc = -1;
              iFinal = -1;
            }
            if (hasSubplotGrid) {
              var row = axisMap[axisId];
              for (i = i0; i !== iFinal; i += inc) {
                subplotId = subplotsOut[row][i];
                if (!subplotId) continue;
                yPos = subplotId.indexOf("y");
                if (subplotId.slice(yPos) === axisId) {
                  anchors[axisId] = subplotId.slice(0, yPos);
                  break;
                }
              }
            } else {
              for (i = i0; i !== iFinal; i += inc) {
                xId = gridOut.xaxes[i];
                if (subplots.cartesian.indexOf(xId + axisId) !== -1) {
                  anchors[axisId] = xId;
                  break;
                }
              }
            }
          }
        }
      }
      function fillGridAxes(axesIn, axesAllowed, len, axisMap, axLetter) {
        var out = new Array(len);
        var i;
        function fillOneAxis(i2, axisId) {
          if (axesAllowed.indexOf(axisId) !== -1 && axisMap[axisId] === void 0) {
            out[i2] = axisId;
            axisMap[axisId] = i2;
          } else out[i2] = "";
        }
        if (Array.isArray(axesIn)) {
          for (i = 0; i < len; i++) {
            fillOneAxis(i, axesIn[i]);
          }
        } else {
          fillOneAxis(0, axLetter);
          for (i = 1; i < len; i++) {
            fillOneAxis(i, axLetter + (i + 1));
          }
        }
        return out;
      }
      module.exports = {
        moduleType: "component",
        name: "grid",
        schema: {
          layout: { grid: gridAttrs }
        },
        layoutAttributes: gridAttrs,
        sizeDefaults,
        contentDefaults
      };
    }
  });

  // src/components/errorbars/attributes.js
  var require_attributes22 = __commonJS({
    "src/components/errorbars/attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        visible: {
          valType: "boolean",
          editType: "calc"
        },
        type: {
          valType: "enumerated",
          values: ["percent", "constant", "sqrt", "data"],
          editType: "calc"
        },
        symmetric: {
          valType: "boolean",
          editType: "calc"
        },
        array: {
          valType: "data_array",
          editType: "calc"
        },
        arrayminus: {
          valType: "data_array",
          editType: "calc"
        },
        value: {
          valType: "number",
          min: 0,
          dflt: 10,
          editType: "calc"
        },
        valueminus: {
          valType: "number",
          min: 0,
          dflt: 10,
          editType: "calc"
        },
        traceref: {
          valType: "integer",
          min: 0,
          dflt: 0,
          editType: "style"
        },
        tracerefminus: {
          valType: "integer",
          min: 0,
          dflt: 0,
          editType: "style"
        },
        copy_ystyle: {
          valType: "boolean",
          editType: "plot"
        },
        copy_zstyle: {
          valType: "boolean",
          editType: "style"
        },
        color: {
          valType: "color",
          editType: "style"
        },
        thickness: {
          valType: "number",
          min: 0,
          dflt: 2,
          editType: "style"
        },
        width: {
          valType: "number",
          min: 0,
          editType: "plot"
        },
        editType: "calc"
      };
    }
  });

  // src/components/errorbars/defaults.js
  var require_defaults18 = __commonJS({
    "src/components/errorbars/defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Registry = require_registry();
      var Lib = require_lib();
      var Template = require_plot_template();
      var attributes = require_attributes22();
      module.exports = function(traceIn, traceOut, defaultColor, opts) {
        var objName = "error_" + opts.axis;
        var containerOut = Template.newContainer(traceOut, objName);
        var containerIn = traceIn[objName] || {};
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        var hasErrorBars = containerIn.array !== void 0 || containerIn.value !== void 0 || containerIn.type === "sqrt";
        var visible = coerce("visible", hasErrorBars);
        if (visible === false) return;
        var type = coerce("type", "array" in containerIn ? "data" : "percent");
        var symmetric = true;
        if (type !== "sqrt") {
          symmetric = coerce(
            "symmetric",
            !((type === "data" ? "arrayminus" : "valueminus") in containerIn)
          );
        }
        if (type === "data") {
          coerce("array");
          coerce("traceref");
          if (!symmetric) {
            coerce("arrayminus");
            coerce("tracerefminus");
          }
        } else if (type === "percent" || type === "constant") {
          coerce("value");
          if (!symmetric) coerce("valueminus");
        }
        var copyAttr = "copy_" + opts.inherit + "style";
        if (opts.inherit) {
          var inheritObj = traceOut["error_" + opts.inherit];
          if ((inheritObj || {}).visible) {
            coerce(copyAttr, !(containerIn.color || isNumeric(containerIn.thickness) || isNumeric(containerIn.width)));
          }
        }
        if (!opts.inherit || !containerOut[copyAttr]) {
          coerce("color", defaultColor);
          coerce("thickness");
          coerce("width", Registry.traceIs(traceOut, "gl3d") ? 0 : 4);
        }
      };
    }
  });

  // src/components/errorbars/compute_error.js
  var require_compute_error = __commonJS({
    "src/components/errorbars/compute_error.js"(exports, module) {
      "use strict";
      module.exports = function makeComputeError(opts) {
        var type = opts.type;
        var symmetric = opts.symmetric;
        if (type === "data") {
          var array = opts.array || [];
          if (symmetric) {
            return function computeError(dataPt, index) {
              var val = +array[index];
              return [val, val];
            };
          } else {
            var arrayminus = opts.arrayminus || [];
            return function computeError(dataPt, index) {
              var val = +array[index];
              var valMinus = +arrayminus[index];
              if (!isNaN(val) || !isNaN(valMinus)) {
                return [valMinus || 0, val || 0];
              }
              return [NaN, NaN];
            };
          }
        } else {
          var computeErrorValue = makeComputeErrorValue(type, opts.value);
          var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);
          if (symmetric || opts.valueminus === void 0) {
            return function computeError(dataPt) {
              var val = computeErrorValue(dataPt);
              return [val, val];
            };
          } else {
            return function computeError(dataPt) {
              return [
                computeErrorValueMinus(dataPt),
                computeErrorValue(dataPt)
              ];
            };
          }
        }
      };
      function makeComputeErrorValue(type, value) {
        if (type === "percent") {
          return function(dataPt) {
            return Math.abs(dataPt * value / 100);
          };
        }
        if (type === "constant") {
          return function() {
            return Math.abs(value);
          };
        }
        if (type === "sqrt") {
          return function(dataPt) {
            return Math.sqrt(Math.abs(dataPt));
          };
        }
      }
    }
  });

  // src/components/errorbars/calc.js
  var require_calc4 = __commonJS({
    "src/components/errorbars/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Registry = require_registry();
      var Axes = require_axes();
      var Lib = require_lib();
      var makeComputeError = require_compute_error();
      module.exports = function calc(gd) {
        var calcdata = gd.calcdata;
        for (var i = 0; i < calcdata.length; i++) {
          var calcTrace = calcdata[i];
          var trace = calcTrace[0].trace;
          if (trace.visible === true && Registry.traceIs(trace, "errorBarsOK")) {
            var xa = Axes.getFromId(gd, trace.xaxis);
            var ya = Axes.getFromId(gd, trace.yaxis);
            calcOneAxis(calcTrace, trace, xa, "x");
            calcOneAxis(calcTrace, trace, ya, "y");
          }
        }
      };
      function calcOneAxis(calcTrace, trace, axis, coord) {
        var opts = trace["error_" + coord] || {};
        var isVisible = opts.visible && ["linear", "log"].indexOf(axis.type) !== -1;
        var vals = [];
        if (!isVisible) return;
        var computeError = makeComputeError(opts);
        for (var i = 0; i < calcTrace.length; i++) {
          var calcPt = calcTrace[i];
          var iIn = calcPt.i;
          if (iIn === void 0) iIn = i;
          else if (iIn === null) continue;
          var calcCoord = calcPt[coord];
          if (!isNumeric(axis.c2l(calcCoord))) continue;
          var errors = computeError(calcCoord, iIn);
          if (isNumeric(errors[0]) && isNumeric(errors[1])) {
            var shoe = calcPt[coord + "s"] = calcCoord - errors[0];
            var hat = calcPt[coord + "h"] = calcCoord + errors[1];
            vals.push(shoe, hat);
          }
        }
        var axId = axis._id;
        var baseExtremes = trace._extremes[axId];
        var extremes = Axes.findExtremes(
          axis,
          vals,
          Lib.extendFlat({ tozero: baseExtremes.opts.tozero }, { padded: true })
        );
        baseExtremes.min = baseExtremes.min.concat(extremes.min);
        baseExtremes.max = baseExtremes.max.concat(extremes.max);
      }
    }
  });

  // src/components/errorbars/plot.js
  var require_plot2 = __commonJS({
    "src/components/errorbars/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Drawing = require_drawing();
      var subTypes = require_subtypes();
      module.exports = function plot(gd, traces, plotinfo, transitionOpts) {
        var isNew;
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var hasAnimation = transitionOpts && transitionOpts.duration > 0;
        var isStatic = gd._context.staticPlot;
        traces.each(function(d) {
          var trace = d[0].trace;
          var xObj = trace.error_x || {};
          var yObj = trace.error_y || {};
          var keyFunc;
          if (trace.ids) {
            keyFunc = function(d2) {
              return d2.id;
            };
          }
          var sparse = subTypes.hasMarkers(trace) && trace.marker.maxdisplayed > 0;
          if (!yObj.visible && !xObj.visible) d = [];
          var errorbars = d3.select(this).selectAll("g.errorbar").data(d, keyFunc);
          errorbars.exit().remove();
          if (!d.length) return;
          if (!xObj.visible) errorbars.selectAll("path.xerror").remove();
          if (!yObj.visible) errorbars.selectAll("path.yerror").remove();
          errorbars.style("opacity", 1);
          var enter = errorbars.enter().append("g").classed("errorbar", true);
          if (hasAnimation) {
            enter.style("opacity", 0).transition().duration(transitionOpts.duration).style("opacity", 1);
          }
          Drawing.setClipUrl(errorbars, plotinfo.layerClipId, gd);
          errorbars.each(function(d2) {
            var errorbar = d3.select(this);
            var coords = errorCoords(d2, xa, ya);
            if (sparse && !d2.vis) return;
            var path;
            var yerror = errorbar.select("path.yerror");
            if (yObj.visible && isNumeric(coords.x) && isNumeric(coords.yh) && isNumeric(coords.ys)) {
              var yw = yObj.width;
              path = "M" + (coords.x - yw) + "," + coords.yh + "h" + 2 * yw + // hat
              "m-" + yw + ",0V" + coords.ys;
              if (!coords.noYS) path += "m-" + yw + ",0h" + 2 * yw;
              isNew = !yerror.size();
              if (isNew) {
                yerror = errorbar.append("path").style("vector-effect", isStatic ? "none" : "non-scaling-stroke").classed("yerror", true);
              } else if (hasAnimation) {
                yerror = yerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);
              }
              yerror.attr("d", path);
            } else yerror.remove();
            var xerror = errorbar.select("path.xerror");
            if (xObj.visible && isNumeric(coords.y) && isNumeric(coords.xh) && isNumeric(coords.xs)) {
              var xw = (xObj.copy_ystyle ? yObj : xObj).width;
              path = "M" + coords.xh + "," + (coords.y - xw) + "v" + 2 * xw + // hat
              "m0,-" + xw + "H" + coords.xs;
              if (!coords.noXS) path += "m0,-" + xw + "v" + 2 * xw;
              isNew = !xerror.size();
              if (isNew) {
                xerror = errorbar.append("path").style("vector-effect", isStatic ? "none" : "non-scaling-stroke").classed("xerror", true);
              } else if (hasAnimation) {
                xerror = xerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);
              }
              xerror.attr("d", path);
            } else xerror.remove();
          });
        });
      };
      function errorCoords(d, xa, ya) {
        var out = {
          x: xa.c2p(d.x),
          y: ya.c2p(d.y)
        };
        if (d.yh !== void 0) {
          out.yh = ya.c2p(d.yh);
          out.ys = ya.c2p(d.ys);
          if (!isNumeric(out.ys)) {
            out.noYS = true;
            out.ys = ya.c2p(d.ys, true);
          }
        }
        if (d.xh !== void 0) {
          out.xh = xa.c2p(d.xh);
          out.xs = xa.c2p(d.xs);
          if (!isNumeric(out.xs)) {
            out.noXS = true;
            out.xs = xa.c2p(d.xs, true);
          }
        }
        return out;
      }
    }
  });

  // src/components/errorbars/style.js
  var require_style3 = __commonJS({
    "src/components/errorbars/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Color = require_color();
      module.exports = function style(traces) {
        traces.each(function(d) {
          var trace = d[0].trace;
          var yObj = trace.error_y || {};
          var xObj = trace.error_x || {};
          var s = d3.select(this);
          s.selectAll("path.yerror").style("stroke-width", yObj.thickness + "px").call(Color.stroke, yObj.color);
          if (xObj.copy_ystyle) xObj = yObj;
          s.selectAll("path.xerror").style("stroke-width", xObj.thickness + "px").call(Color.stroke, xObj.color);
        });
      };
    }
  });

  // src/components/errorbars/index.js
  var require_errorbars = __commonJS({
    "src/components/errorbars/index.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var overrideAll = require_edit_types().overrideAll;
      var attributes = require_attributes22();
      var xyAttrs = {
        error_x: Lib.extendFlat({}, attributes),
        error_y: Lib.extendFlat({}, attributes)
      };
      delete xyAttrs.error_x.copy_zstyle;
      delete xyAttrs.error_y.copy_zstyle;
      delete xyAttrs.error_y.copy_ystyle;
      var xyzAttrs = {
        error_x: Lib.extendFlat({}, attributes),
        error_y: Lib.extendFlat({}, attributes),
        error_z: Lib.extendFlat({}, attributes)
      };
      delete xyzAttrs.error_x.copy_ystyle;
      delete xyzAttrs.error_y.copy_ystyle;
      delete xyzAttrs.error_z.copy_ystyle;
      delete xyzAttrs.error_z.copy_zstyle;
      module.exports = {
        moduleType: "component",
        name: "errorbars",
        schema: {
          traces: {
            scatter: xyAttrs,
            bar: xyAttrs,
            histogram: xyAttrs,
            scatter3d: overrideAll(xyzAttrs, "calc", "nested"),
            scattergl: overrideAll(xyAttrs, "calc", "nested")
          }
        },
        supplyDefaults: require_defaults18(),
        calc: require_calc4(),
        makeComputeError: require_compute_error(),
        plot: require_plot2(),
        style: require_style3(),
        hoverInfo
      };
      function hoverInfo(calcPoint, trace, hoverPoint) {
        if ((trace.error_y || {}).visible) {
          hoverPoint.yerr = calcPoint.yh - calcPoint.y;
          if (!trace.error_y.symmetric) hoverPoint.yerrneg = calcPoint.y - calcPoint.ys;
        }
        if ((trace.error_x || {}).visible) {
          hoverPoint.xerr = calcPoint.xh - calcPoint.x;
          if (!trace.error_x.symmetric) hoverPoint.xerrneg = calcPoint.x - calcPoint.xs;
        }
      }
    }
  });

  // src/components/colorbar/constants.js
  var require_constants13 = __commonJS({
    "src/components/colorbar/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        cn: {
          colorbar: "colorbar",
          cbbg: "cbbg",
          cbfill: "cbfill",
          cbfills: "cbfills",
          cbline: "cbline",
          cblines: "cblines",
          cbaxis: "cbaxis",
          cbtitleunshift: "cbtitleunshift",
          cbtitle: "cbtitle",
          cboutline: "cboutline",
          crisp: "crisp",
          jsPlaceholder: "js-placeholder"
        }
      };
    }
  });

  // src/components/colorbar/draw.js
  var require_draw11 = __commonJS({
    "src/components/colorbar/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var tinycolor = require_tinycolor();
      var Plots = require_plots();
      var Registry = require_registry();
      var Axes = require_axes();
      var dragElement = require_dragelement();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var extendFlat = require_extend().extendFlat;
      var setCursor = require_setcursor();
      var Drawing = require_drawing();
      var Color = require_color();
      var Titles = require_titles();
      var svgTextUtils = require_svg_text_utils();
      var flipScale = require_helpers().flipScale;
      var handleAxisDefaults = require_axis_defaults();
      var handleAxisPositionDefaults = require_position_defaults();
      var axisLayoutAttrs = require_layout_attributes4();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      var cn = require_constants13().cn;
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        var colorBars = fullLayout._infolayer.selectAll("g." + cn.colorbar).data(makeColorBarData(gd), function(opts) {
          return opts._id;
        });
        colorBars.enter().append("g").attr("class", function(opts) {
          return opts._id;
        }).classed(cn.colorbar, true);
        colorBars.each(function(opts) {
          var g = d3.select(this);
          Lib.ensureSingle(g, "rect", cn.cbbg);
          Lib.ensureSingle(g, "g", cn.cbfills);
          Lib.ensureSingle(g, "g", cn.cblines);
          Lib.ensureSingle(g, "g", cn.cbaxis, function(s) {
            s.classed(cn.crisp, true);
          });
          Lib.ensureSingle(g, "g", cn.cbtitleunshift, function(s) {
            s.append("g").classed(cn.cbtitle, true);
          });
          Lib.ensureSingle(g, "rect", cn.cboutline);
          var done = drawColorBar(g, opts, gd);
          if (done && done.then) (gd._promises || []).push(done);
          if (gd._context.edits.colorbarPosition) {
            makeEditable(g, opts, gd);
          }
        });
        colorBars.exit().each(function(opts) {
          Plots.autoMargin(gd, opts._id);
        }).remove();
        colorBars.order();
      }
      function makeColorBarData(gd) {
        var fullLayout = gd._fullLayout;
        var calcdata = gd.calcdata;
        var out = [];
        var opts;
        var cont;
        var trace;
        var cbOpt;
        function initOpts(opts2) {
          return extendFlat(opts2, {
            // fillcolor can be a d3 scale, domain is z values, range is colors
            // or leave it out for no fill,
            // or set to a string constant for single-color fill
            _fillcolor: null,
            // line.color has the same options as fillcolor
            _line: { color: null, width: null, dash: null },
            // levels of lines to draw.
            // note that this DOES NOT determine the extent of the bar
            // that's given by the domain of fillcolor
            // (or line.color if no fillcolor domain)
            _levels: { start: null, end: null, size: null },
            // separate fill levels (for example, heatmap coloring of a
            // contour map) if this is omitted, fillcolors will be
            // evaluated halfway between levels
            _filllevels: null,
            // for continuous colorscales: fill with a gradient instead of explicit levels
            // value should be the colorscale [[0, c0], [v1, c1], ..., [1, cEnd]]
            _fillgradient: null,
            // when using a gradient, we need the data range specified separately
            _zrange: null
          });
        }
        function calcOpts() {
          if (typeof cbOpt.calc === "function") {
            cbOpt.calc(gd, trace, opts);
          } else {
            opts._fillgradient = cont.reversescale ? flipScale(cont.colorscale) : cont.colorscale;
            opts._zrange = [cont[cbOpt.min], cont[cbOpt.max]];
          }
        }
        for (var i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          trace = cd[0].trace;
          if (!trace._module) continue;
          var moduleOpts = trace._module.colorbar;
          if (trace.visible === true && moduleOpts) {
            var allowsMultiplotCbs = Array.isArray(moduleOpts);
            var cbOpts = allowsMultiplotCbs ? moduleOpts : [moduleOpts];
            for (var j = 0; j < cbOpts.length; j++) {
              cbOpt = cbOpts[j];
              var contName = cbOpt.container;
              cont = contName ? trace[contName] : trace;
              if (cont && cont.showscale) {
                opts = initOpts(cont.colorbar);
                opts._id = "cb" + trace.uid + (allowsMultiplotCbs && contName ? "-" + contName : "");
                opts._traceIndex = trace.index;
                opts._propPrefix = (contName ? contName + "." : "") + "colorbar.";
                opts._meta = trace._meta;
                calcOpts();
                out.push(opts);
              }
            }
          }
        }
        for (var k in fullLayout._colorAxes) {
          cont = fullLayout[k];
          if (cont.showscale) {
            var colorAxOpts = fullLayout._colorAxes[k];
            opts = initOpts(cont.colorbar);
            opts._id = "cb" + k;
            opts._propPrefix = k + ".colorbar.";
            opts._meta = fullLayout._meta;
            cbOpt = { min: "cmin", max: "cmax" };
            if (colorAxOpts[0] !== "heatmap") {
              trace = colorAxOpts[1];
              cbOpt.calc = trace._module.colorbar.calc;
            }
            calcOpts();
            out.push(opts);
          }
        }
        return out;
      }
      function drawColorBar(g, opts, gd) {
        var isVertical = opts.orientation === "v";
        var len = opts.len;
        var lenmode = opts.lenmode;
        var thickness = opts.thickness;
        var thicknessmode = opts.thicknessmode;
        var outlinewidth = opts.outlinewidth;
        var borderwidth = opts.borderwidth;
        var bgcolor = opts.bgcolor;
        var xanchor = opts.xanchor;
        var yanchor = opts.yanchor;
        var xpad = opts.xpad;
        var ypad = opts.ypad;
        var optsX = opts.x;
        var optsY = isVertical ? opts.y : 1 - opts.y;
        var isPaperY = opts.yref === "paper";
        var isPaperX = opts.xref === "paper";
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var fillColor = opts._fillcolor;
        var line = opts._line;
        var title = opts.title;
        var titleSide = title.side;
        var zrange = opts._zrange || d3.extent((typeof fillColor === "function" ? fillColor : line.color).domain());
        var lineColormap = typeof line.color === "function" ? line.color : function() {
          return line.color;
        };
        var fillColormap = typeof fillColor === "function" ? fillColor : function() {
          return fillColor;
        };
        var levelsIn = opts._levels;
        var levelsOut = calcLevels(gd, opts, zrange);
        var fillLevels = levelsOut.fill;
        var lineLevels = levelsOut.line;
        var thickPx = Math.round(thickness * (thicknessmode === "fraction" ? isVertical ? gs.w : gs.h : 1));
        var thickFrac = thickPx / (isVertical ? gs.w : gs.h);
        var lenPx = Math.round(len * (lenmode === "fraction" ? isVertical ? gs.h : gs.w : 1));
        var lenFrac = lenPx / (isVertical ? gs.h : gs.w);
        var posW = isPaperX ? gs.w : gd._fullLayout.width;
        var posH = isPaperY ? gs.h : gd._fullLayout.height;
        var uPx = Math.round(
          isVertical ? optsX * posW + xpad : optsY * posH + ypad
        );
        var xRatio = { center: 0.5, right: 1 }[xanchor] || 0;
        var yRatio = { top: 1, middle: 0.5 }[yanchor] || 0;
        var uFrac = isVertical ? optsX - xRatio * thickFrac : optsY - yRatio * thickFrac;
        var vFrac = isVertical ? optsY - yRatio * lenFrac : optsX - xRatio * lenFrac;
        var vPx = Math.round(
          isVertical ? posH * (1 - vFrac) : posW * vFrac
        );
        opts._lenFrac = lenFrac;
        opts._thickFrac = thickFrac;
        opts._uFrac = uFrac;
        opts._vFrac = vFrac;
        var ax = opts._axis = mockColorBarAxis(gd, opts, zrange);
        ax.position = thickFrac + (isVertical ? optsX + xpad / gs.w : optsY + ypad / gs.h);
        var topOrBottom = ["top", "bottom"].indexOf(titleSide) !== -1;
        if (isVertical && topOrBottom) {
          ax.title.side = titleSide;
          ax.titlex = optsX + xpad / gs.w;
          ax.titley = vFrac + (title.side === "top" ? lenFrac - ypad / gs.h : ypad / gs.h);
        }
        if (!isVertical && !topOrBottom) {
          ax.title.side = titleSide;
          ax.titley = optsY + ypad / gs.h;
          ax.titlex = vFrac + xpad / gs.w;
        }
        if (line.color && opts.tickmode === "auto") {
          ax.tickmode = "linear";
          ax.tick0 = levelsIn.start;
          var dtick = levelsIn.size;
          var autoNtick = Lib.constrain(lenPx / 50, 4, 15) + 1;
          var dtFactor = (zrange[1] - zrange[0]) / ((opts.nticks || autoNtick) * dtick);
          if (dtFactor > 1) {
            var dtexp = Math.pow(10, Math.floor(Math.log(dtFactor) / Math.LN10));
            dtick *= dtexp * Lib.roundUp(dtFactor / dtexp, [2, 5, 10]);
            if ((Math.abs(levelsIn.start) / levelsIn.size + 1e-6) % 1 < 2e-6) {
              ax.tick0 = 0;
            }
          }
          ax.dtick = dtick;
        }
        ax.domain = isVertical ? [
          vFrac + ypad / gs.h,
          vFrac + lenFrac - ypad / gs.h
        ] : [
          vFrac + xpad / gs.w,
          vFrac + lenFrac - xpad / gs.w
        ];
        ax.setScale();
        g.attr("transform", strTranslate(Math.round(gs.l), Math.round(gs.t)));
        var titleCont = g.select("." + cn.cbtitleunshift).attr("transform", strTranslate(-Math.round(gs.l), -Math.round(gs.t)));
        var ticklabelposition = ax.ticklabelposition;
        var titleFontSize = ax.title.font.size;
        var axLayer = g.select("." + cn.cbaxis);
        var titleEl;
        var titleHeight = 0;
        var titleWidth = 0;
        function drawTitle(titleClass, titleOpts) {
          var dfltTitleOpts = {
            propContainer: ax,
            propName: opts._propPrefix + "title",
            traceIndex: opts._traceIndex,
            _meta: opts._meta,
            placeholder: fullLayout._dfltTitle.colorbar,
            containerGroup: g.select("." + cn.cbtitle)
          };
          var otherClass = titleClass.charAt(0) === "h" ? titleClass.substr(1) : "h" + titleClass;
          g.selectAll("." + otherClass + ",." + otherClass + "-math-group").remove();
          Titles.draw(gd, titleClass, extendFlat(dfltTitleOpts, titleOpts || {}));
        }
        function drawDummyTitle() {
          if (isVertical && topOrBottom || !isVertical && !topOrBottom) {
            var x, y;
            if (titleSide === "top") {
              x = xpad + gs.l + posW * optsX;
              y = ypad + gs.t + posH * (1 - vFrac - lenFrac) + 3 + titleFontSize * 0.75;
            }
            if (titleSide === "bottom") {
              x = xpad + gs.l + posW * optsX;
              y = ypad + gs.t + posH * (1 - vFrac) - 3 - titleFontSize * 0.25;
            }
            if (titleSide === "right") {
              y = ypad + gs.t + posH * optsY + 3 + titleFontSize * 0.75;
              x = xpad + gs.l + posW * vFrac;
            }
            drawTitle(ax._id + "title", {
              attributes: { x, y, "text-anchor": isVertical ? "start" : "middle" }
            });
          }
        }
        function drawCbTitle() {
          if (isVertical && !topOrBottom || !isVertical && topOrBottom) {
            var pos = ax.position || 0;
            var mid = ax._offset + ax._length / 2;
            var x, y;
            if (titleSide === "right") {
              y = mid;
              x = gs.l + posW * pos + 10 + titleFontSize * (ax.showticklabels ? 1 : 0.5);
            } else {
              x = mid;
              if (titleSide === "bottom") {
                y = gs.t + posH * pos + 10 + (ticklabelposition.indexOf("inside") === -1 ? ax.tickfont.size : 0) + (ax.ticks !== "intside" ? opts.ticklen || 0 : 0);
              }
              if (titleSide === "top") {
                var nlines = title.text.split("<br>").length;
                y = gs.t + posH * pos + 10 - thickPx - LINE_SPACING * titleFontSize * nlines;
              }
            }
            drawTitle((isVertical ? (
              // the 'h' + is a hack to get around the fact that
              // convertToTspans rotates any 'y...' class by 90 degrees.
              // TODO: find a better way to control this.
              "h"
            ) : "v") + ax._id + "title", {
              avoid: {
                selection: d3.select(gd).selectAll("g." + ax._id + "tick"),
                side: titleSide,
                offsetTop: isVertical ? 0 : gs.t,
                offsetLeft: isVertical ? gs.l : 0,
                maxShift: isVertical ? fullLayout.width : fullLayout.height
              },
              attributes: { x, y, "text-anchor": "middle" },
              transform: { rotate: isVertical ? -90 : 0, offset: 0 }
            });
          }
        }
        function drawAxis() {
          if (!isVertical && !topOrBottom || isVertical && topOrBottom) {
            var titleGroup = g.select("." + cn.cbtitle);
            var titleText = titleGroup.select("text");
            var titleTrans = [-outlinewidth / 2, outlinewidth / 2];
            var mathJaxNode = titleGroup.select(".h" + ax._id + "title-math-group").node();
            var lineSize = 15.6;
            if (titleText.node()) {
              lineSize = parseInt(titleText.node().style.fontSize, 10) * LINE_SPACING;
            }
            var bb;
            if (mathJaxNode) {
              bb = Drawing.bBox(mathJaxNode);
              titleWidth = bb.width;
              titleHeight = bb.height;
              if (titleHeight > lineSize) {
                titleTrans[1] -= (titleHeight - lineSize) / 2;
              }
            } else if (titleText.node() && !titleText.classed(cn.jsPlaceholder)) {
              bb = Drawing.bBox(titleText.node());
              titleWidth = bb.width;
              titleHeight = bb.height;
            }
            if (isVertical) {
              if (titleHeight) {
                titleHeight += 5;
                if (titleSide === "top") {
                  ax.domain[1] -= titleHeight / gs.h;
                  titleTrans[1] *= -1;
                } else {
                  ax.domain[0] += titleHeight / gs.h;
                  var nlines = svgTextUtils.lineCount(titleText);
                  titleTrans[1] += (1 - nlines) * lineSize;
                }
                titleGroup.attr("transform", strTranslate(titleTrans[0], titleTrans[1]));
                ax.setScale();
              }
            } else {
              if (titleWidth) {
                if (titleSide === "right") {
                  ax.domain[0] += (titleWidth + titleFontSize / 2) / gs.w;
                }
                titleGroup.attr("transform", strTranslate(titleTrans[0], titleTrans[1]));
                ax.setScale();
              }
            }
          }
          g.selectAll("." + cn.cbfills + ",." + cn.cblines).attr(
            "transform",
            isVertical ? strTranslate(0, Math.round(gs.h * (1 - ax.domain[1]))) : strTranslate(Math.round(gs.w * ax.domain[0]), 0)
          );
          axLayer.attr(
            "transform",
            isVertical ? strTranslate(0, Math.round(-gs.t)) : strTranslate(Math.round(-gs.l), 0)
          );
          var fills = g.select("." + cn.cbfills).selectAll("rect." + cn.cbfill).attr("style", "").data(fillLevels);
          fills.enter().append("rect").classed(cn.cbfill, true).attr("style", "");
          fills.exit().remove();
          var zBounds = zrange.map(ax.c2p).map(Math.round).sort(function(a, b) {
            return a - b;
          });
          fills.each(function(d, i) {
            var z = [
              i === 0 ? zrange[0] : (fillLevels[i] + fillLevels[i - 1]) / 2,
              i === fillLevels.length - 1 ? zrange[1] : (fillLevels[i] + fillLevels[i + 1]) / 2
            ].map(ax.c2p).map(Math.round);
            if (isVertical) {
              z[1] = Lib.constrain(z[1] + (z[1] > z[0]) ? 1 : -1, zBounds[0], zBounds[1]);
            }
            var fillEl = d3.select(this).attr(isVertical ? "x" : "y", uPx).attr(isVertical ? "y" : "x", d3.min(z)).attr(isVertical ? "width" : "height", Math.max(thickPx, 2)).attr(isVertical ? "height" : "width", Math.max(d3.max(z) - d3.min(z), 2));
            if (opts._fillgradient) {
              Drawing.gradient(fillEl, gd, opts._id, isVertical ? "vertical" : "horizontalreversed", opts._fillgradient, "fill");
            } else {
              var colorString = fillColormap(d).replace("e-", "");
              fillEl.attr("fill", tinycolor(colorString).toHexString());
            }
          });
          var lines = g.select("." + cn.cblines).selectAll("path." + cn.cbline).data(line.color && line.width ? lineLevels : []);
          lines.enter().append("path").classed(cn.cbline, true);
          lines.exit().remove();
          lines.each(function(d) {
            var a = uPx;
            var b = Math.round(ax.c2p(d)) + line.width / 2 % 1;
            d3.select(this).attr(
              "d",
              "M" + (isVertical ? a + "," + b : b + "," + a) + (isVertical ? "h" : "v") + thickPx
            ).call(Drawing.lineGroupStyle, line.width, lineColormap(d), line.dash);
          });
          axLayer.selectAll("g." + ax._id + "tick,path").remove();
          var shift = uPx + thickPx + (outlinewidth || 0) / 2 - (opts.ticks === "outside" ? 1 : 0);
          var vals = Axes.calcTicks(ax);
          var tickSign = Axes.getTickSigns(ax)[2];
          Axes.drawTicks(gd, ax, {
            vals: ax.ticks === "inside" ? Axes.clipEnds(ax, vals) : vals,
            layer: axLayer,
            path: Axes.makeTickPath(ax, shift, tickSign),
            transFn: Axes.makeTransTickFn(ax)
          });
          return Axes.drawLabels(gd, ax, {
            vals,
            layer: axLayer,
            transFn: Axes.makeTransTickLabelFn(ax),
            labelFns: Axes.makeLabelFns(ax, shift)
          });
        }
        function positionCB() {
          var bb;
          var innerThickness = thickPx + outlinewidth / 2;
          if (ticklabelposition.indexOf("inside") === -1) {
            bb = Drawing.bBox(axLayer.node());
            innerThickness += isVertical ? bb.width : bb.height;
          }
          titleEl = titleCont.select("text");
          var titleWidth2 = 0;
          var topSideVertical = isVertical && titleSide === "top";
          var rightSideHorizontal = !isVertical && titleSide === "right";
          var moveY = 0;
          if (titleEl.node() && !titleEl.classed(cn.jsPlaceholder)) {
            var _titleHeight;
            var mathJaxNode = titleCont.select(".h" + ax._id + "title-math-group").node();
            if (mathJaxNode && (isVertical && topOrBottom || !isVertical && !topOrBottom)) {
              bb = Drawing.bBox(mathJaxNode);
              titleWidth2 = bb.width;
              _titleHeight = bb.height;
            } else {
              bb = Drawing.bBox(titleCont.node());
              titleWidth2 = bb.right - gs.l - (isVertical ? uPx : vPx);
              _titleHeight = bb.bottom - gs.t - (isVertical ? vPx : uPx);
              if (!isVertical && titleSide === "top") {
                innerThickness += bb.height;
                moveY = bb.height;
              }
            }
            if (rightSideHorizontal) {
              titleEl.attr("transform", strTranslate(titleWidth2 / 2 + titleFontSize / 2, 0));
              titleWidth2 *= 2;
            }
            innerThickness = Math.max(
              innerThickness,
              isVertical ? titleWidth2 : _titleHeight
            );
          }
          var outerThickness = (isVertical ? xpad : ypad) * 2 + innerThickness + borderwidth + outlinewidth / 2;
          var hColorbarMoveTitle = 0;
          if (!isVertical && title.text && yanchor === "bottom" && optsY <= 0) {
            hColorbarMoveTitle = outerThickness / 2;
            outerThickness += hColorbarMoveTitle;
            moveY += hColorbarMoveTitle;
          }
          fullLayout._hColorbarMoveTitle = hColorbarMoveTitle;
          fullLayout._hColorbarMoveCBTitle = moveY;
          var extraW = borderwidth + outlinewidth;
          var lx = (isVertical ? uPx : vPx) - extraW / 2 - (isVertical ? xpad : 0);
          var ly = (isVertical ? vPx : uPx) - (isVertical ? lenPx : ypad + moveY - hColorbarMoveTitle);
          g.select("." + cn.cbbg).attr("x", lx).attr("y", ly).attr(isVertical ? "width" : "height", Math.max(outerThickness - hColorbarMoveTitle, 2)).attr(isVertical ? "height" : "width", Math.max(lenPx + extraW, 2)).call(Color.fill, bgcolor).call(Color.stroke, opts.bordercolor).style("stroke-width", borderwidth);
          var moveX = rightSideHorizontal ? Math.max(titleWidth2 - 10, 0) : 0;
          g.selectAll("." + cn.cboutline).attr("x", (isVertical ? uPx : vPx + xpad) + moveX).attr("y", (isVertical ? vPx + ypad - lenPx : uPx) + (topSideVertical ? titleHeight : 0)).attr(isVertical ? "width" : "height", Math.max(thickPx, 2)).attr(isVertical ? "height" : "width", Math.max(lenPx - (isVertical ? 2 * ypad + titleHeight : 2 * xpad + moveX), 2)).call(Color.stroke, opts.outlinecolor).style({
            fill: "none",
            "stroke-width": outlinewidth
          });
          var xShift = isVertical ? xRatio * outerThickness : 0;
          var yShift = isVertical ? 0 : (1 - yRatio) * outerThickness - moveY;
          xShift = isPaperX ? gs.l - xShift : -xShift;
          yShift = isPaperY ? gs.t - yShift : -yShift;
          g.attr("transform", strTranslate(
            xShift,
            yShift
          ));
          if (!isVertical && (borderwidth || tinycolor(bgcolor).getAlpha() && !tinycolor.equals(fullLayout.paper_bgcolor, bgcolor))) {
            var tickLabels = axLayer.selectAll("text");
            var numTicks = tickLabels[0].length;
            var border = g.select("." + cn.cbbg).node();
            var oBb = Drawing.bBox(border);
            var oTr = Drawing.getTranslate(g);
            var TEXTPAD = 2;
            tickLabels.each(function(d, i) {
              var first = 0;
              var last = numTicks - 1;
              if (i === first || i === last) {
                var iBb = Drawing.bBox(this);
                var iTr = Drawing.getTranslate(this);
                var deltaX;
                if (i === last) {
                  var iRight = iBb.right + iTr.x;
                  var oRight = oBb.right + oTr.x + vPx - borderwidth - TEXTPAD + optsX;
                  deltaX = oRight - iRight;
                  if (deltaX > 0) deltaX = 0;
                } else if (i === first) {
                  var iLeft = iBb.left + iTr.x;
                  var oLeft = oBb.left + oTr.x + vPx + borderwidth + TEXTPAD;
                  deltaX = oLeft - iLeft;
                  if (deltaX < 0) deltaX = 0;
                }
                if (deltaX) {
                  if (numTicks < 3) {
                    this.setAttribute(
                      "transform",
                      "translate(" + deltaX + ",0) " + this.getAttribute("transform")
                    );
                  } else {
                    this.setAttribute("visibility", "hidden");
                  }
                }
              }
            });
          }
          var marginOpts = {};
          var lFrac = FROM_TL[xanchor];
          var rFrac = FROM_BR[xanchor];
          var tFrac = FROM_TL[yanchor];
          var bFrac = FROM_BR[yanchor];
          var extraThickness = outerThickness - thickPx;
          if (isVertical) {
            if (lenmode === "pixels") {
              marginOpts.y = optsY;
              marginOpts.t = lenPx * tFrac;
              marginOpts.b = lenPx * bFrac;
            } else {
              marginOpts.t = marginOpts.b = 0;
              marginOpts.yt = optsY + len * tFrac;
              marginOpts.yb = optsY - len * bFrac;
            }
            if (thicknessmode === "pixels") {
              marginOpts.x = optsX;
              marginOpts.l = outerThickness * lFrac;
              marginOpts.r = outerThickness * rFrac;
            } else {
              marginOpts.l = extraThickness * lFrac;
              marginOpts.r = extraThickness * rFrac;
              marginOpts.xl = optsX - thickness * lFrac;
              marginOpts.xr = optsX + thickness * rFrac;
            }
          } else {
            if (lenmode === "pixels") {
              marginOpts.x = optsX;
              marginOpts.l = lenPx * lFrac;
              marginOpts.r = lenPx * rFrac;
            } else {
              marginOpts.l = marginOpts.r = 0;
              marginOpts.xl = optsX + len * lFrac;
              marginOpts.xr = optsX - len * rFrac;
            }
            if (thicknessmode === "pixels") {
              marginOpts.y = 1 - optsY;
              marginOpts.t = outerThickness * tFrac;
              marginOpts.b = outerThickness * bFrac;
            } else {
              marginOpts.t = extraThickness * tFrac;
              marginOpts.b = extraThickness * bFrac;
              marginOpts.yt = optsY - thickness * tFrac;
              marginOpts.yb = optsY + thickness * bFrac;
            }
          }
          var sideY = opts.y < 0.5 ? "b" : "t";
          var sideX = opts.x < 0.5 ? "l" : "r";
          gd._fullLayout._reservedMargin[opts._id] = {};
          var possibleReservedMargins = {
            r: fullLayout.width - lx - xShift,
            l: lx + marginOpts.r,
            b: fullLayout.height - ly - yShift,
            t: ly + marginOpts.b
          };
          if (isPaperX && isPaperY) {
            Plots.autoMargin(gd, opts._id, marginOpts);
          } else if (isPaperX) {
            gd._fullLayout._reservedMargin[opts._id][sideY] = possibleReservedMargins[sideY];
          } else if (isPaperY) {
            gd._fullLayout._reservedMargin[opts._id][sideX] = possibleReservedMargins[sideX];
          } else {
            if (isVertical) {
              gd._fullLayout._reservedMargin[opts._id][sideX] = possibleReservedMargins[sideX];
            } else {
              gd._fullLayout._reservedMargin[opts._id][sideY] = possibleReservedMargins[sideY];
            }
          }
        }
        return Lib.syncOrAsync([
          Plots.previousPromises,
          drawDummyTitle,
          drawAxis,
          drawCbTitle,
          Plots.previousPromises,
          positionCB
        ], gd);
      }
      function makeEditable(g, opts, gd) {
        var isVertical = opts.orientation === "v";
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var t0, xf, yf;
        dragElement.init({
          element: g.node(),
          gd,
          prepFn: function() {
            t0 = g.attr("transform");
            setCursor(g);
          },
          moveFn: function(dx, dy) {
            g.attr("transform", t0 + strTranslate(dx, dy));
            xf = dragElement.align(
              (isVertical ? opts._uFrac : opts._vFrac) + dx / gs.w,
              isVertical ? opts._thickFrac : opts._lenFrac,
              0,
              1,
              opts.xanchor
            );
            yf = dragElement.align(
              (isVertical ? opts._vFrac : 1 - opts._uFrac) - dy / gs.h,
              isVertical ? opts._lenFrac : opts._thickFrac,
              0,
              1,
              opts.yanchor
            );
            var csr = dragElement.getCursor(xf, yf, opts.xanchor, opts.yanchor);
            setCursor(g, csr);
          },
          doneFn: function() {
            setCursor(g);
            if (xf !== void 0 && yf !== void 0) {
              var update = {};
              update[opts._propPrefix + "x"] = xf;
              update[opts._propPrefix + "y"] = yf;
              if (opts._traceIndex !== void 0) {
                Registry.call("_guiRestyle", gd, update, opts._traceIndex);
              } else {
                Registry.call("_guiRelayout", gd, update);
              }
            }
          }
        });
      }
      function calcLevels(gd, opts, zrange) {
        var levelsIn = opts._levels;
        var lineLevels = [];
        var fillLevels = [];
        var l;
        var i;
        var l0 = levelsIn.end + levelsIn.size / 100;
        var ls = levelsIn.size;
        var zr0 = 1.001 * zrange[0] - 1e-3 * zrange[1];
        var zr1 = 1.001 * zrange[1] - 1e-3 * zrange[0];
        for (i = 0; i < 1e5; i++) {
          l = levelsIn.start + i * ls;
          if (ls > 0 ? l >= l0 : l <= l0) break;
          if (l > zr0 && l < zr1) lineLevels.push(l);
        }
        if (opts._fillgradient) {
          fillLevels = [0];
        } else if (typeof opts._fillcolor === "function") {
          var fillLevelsIn = opts._filllevels;
          if (fillLevelsIn) {
            l0 = fillLevelsIn.end + fillLevelsIn.size / 100;
            ls = fillLevelsIn.size;
            for (i = 0; i < 1e5; i++) {
              l = fillLevelsIn.start + i * ls;
              if (ls > 0 ? l >= l0 : l <= l0) break;
              if (l > zrange[0] && l < zrange[1]) fillLevels.push(l);
            }
          } else {
            fillLevels = lineLevels.map(function(v) {
              return v - levelsIn.size / 2;
            });
            fillLevels.push(fillLevels[fillLevels.length - 1] + levelsIn.size);
          }
        } else if (opts._fillcolor && typeof opts._fillcolor === "string") {
          fillLevels = [0];
        }
        if (levelsIn.size < 0) {
          lineLevels.reverse();
          fillLevels.reverse();
        }
        return { line: lineLevels, fill: fillLevels };
      }
      function mockColorBarAxis(gd, opts, zrange) {
        var fullLayout = gd._fullLayout;
        var isVertical = opts.orientation === "v";
        var cbAxisIn = {
          type: "linear",
          range: zrange,
          tickmode: opts.tickmode,
          nticks: opts.nticks,
          tick0: opts.tick0,
          dtick: opts.dtick,
          tickvals: opts.tickvals,
          ticktext: opts.ticktext,
          ticks: opts.ticks,
          ticklen: opts.ticklen,
          tickwidth: opts.tickwidth,
          tickcolor: opts.tickcolor,
          showticklabels: opts.showticklabels,
          labelalias: opts.labelalias,
          ticklabelposition: opts.ticklabelposition,
          ticklabeloverflow: opts.ticklabeloverflow,
          ticklabelstep: opts.ticklabelstep,
          tickfont: opts.tickfont,
          tickangle: opts.tickangle,
          tickformat: opts.tickformat,
          exponentformat: opts.exponentformat,
          minexponent: opts.minexponent,
          separatethousands: opts.separatethousands,
          showexponent: opts.showexponent,
          showtickprefix: opts.showtickprefix,
          tickprefix: opts.tickprefix,
          showticksuffix: opts.showticksuffix,
          ticksuffix: opts.ticksuffix,
          title: opts.title,
          showline: true,
          anchor: "free",
          side: isVertical ? "right" : "bottom",
          position: 1
        };
        var letter = isVertical ? "y" : "x";
        var cbAxisOut = {
          type: "linear",
          _id: letter + opts._id
        };
        var axisOptions = {
          letter,
          font: fullLayout.font,
          noAutotickangles: letter === "y",
          noHover: true,
          noTickson: true,
          noTicklabelmode: true,
          noInsideRange: true,
          calendar: fullLayout.calendar
          // not really necessary (yet?)
        };
        function coerce(attr, dflt) {
          return Lib.coerce(cbAxisIn, cbAxisOut, axisLayoutAttrs, attr, dflt);
        }
        handleAxisDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions, fullLayout);
        handleAxisPositionDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions);
        return cbAxisOut;
      }
      module.exports = {
        draw
      };
    }
  });

  // src/components/colorbar/index.js
  var require_colorbar = __commonJS({
    "src/components/colorbar/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "colorbar",
        attributes: require_attributes7(),
        supplyDefaults: require_defaults(),
        draw: require_draw11().draw,
        hasColorbar: require_has_colorbar()
      };
    }
  });

  // src/components/legend/index.js
  var require_legend = __commonJS({
    "src/components/legend/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "legend",
        layoutAttributes: require_attributes9(),
        supplyLayoutDefaults: require_defaults3(),
        draw: require_draw(),
        style: require_style()
      };
    }
  });

  // src/locale-en.js
  var require_locale_en = __commonJS({
    "src/locale-en.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "locale",
        name: "en",
        dictionary: {
          "Click to enter Colorscale title": "Click to enter Colourscale title"
        },
        format: {
          days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ],
          shortMonths: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          periods: ["AM", "PM"],
          dateTime: "%a %b %e %X %Y",
          date: "%d/%m/%Y",
          time: "%H:%M:%S",
          decimal: ".",
          thousands: ",",
          grouping: [3],
          currency: ["$", ""],
          year: "%Y",
          month: "%b %Y",
          dayMonth: "%b %-d",
          dayMonthYear: "%b %-d, %Y"
        }
      };
    }
  });

  // src/locale-en-us.js
  var require_locale_en_us = __commonJS({
    "src/locale-en-us.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "locale",
        name: "en-US",
        dictionary: {
          "Click to enter Colorscale title": "Click to enter Colorscale title"
        },
        format: {
          date: "%m/%d/%Y"
        }
      };
    }
  });

  // src/snapshot/cloneplot.js
  var require_cloneplot = __commonJS({
    "src/snapshot/cloneplot.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var extendFlat = Lib.extendFlat;
      var extendDeep = Lib.extendDeep;
      function cloneLayoutOverride(tileClass) {
        var override;
        switch (tileClass) {
          case "themes__thumb":
            override = {
              autosize: true,
              width: 150,
              height: 150,
              title: { text: "" },
              showlegend: false,
              margin: { l: 5, r: 5, t: 5, b: 5, pad: 0 },
              annotations: []
            };
            break;
          case "thumbnail":
            override = {
              title: { text: "" },
              hidesources: true,
              showlegend: false,
              borderwidth: 0,
              bordercolor: "",
              margin: { l: 1, r: 1, t: 1, b: 1, pad: 0 },
              annotations: []
            };
            break;
          default:
            override = {};
        }
        return override;
      }
      function keyIsAxis(keyName) {
        var types = ["xaxis", "yaxis", "zaxis"];
        return types.indexOf(keyName.slice(0, 5)) > -1;
      }
      module.exports = function clonePlot(graphObj, options) {
        var i;
        var oldData = graphObj.data;
        var oldLayout = graphObj.layout;
        var newData = extendDeep([], oldData);
        var newLayout = extendDeep({}, oldLayout, cloneLayoutOverride(options.tileClass));
        var context = graphObj._context || {};
        if (options.width) newLayout.width = options.width;
        if (options.height) newLayout.height = options.height;
        if (options.tileClass === "thumbnail" || options.tileClass === "themes__thumb") {
          newLayout.annotations = [];
          var keys = Object.keys(newLayout);
          for (i = 0; i < keys.length; i++) {
            if (keyIsAxis(keys[i])) {
              newLayout[keys[i]].title = { text: "" };
            }
          }
          for (i = 0; i < newData.length; i++) {
            var trace = newData[i];
            trace.showscale = false;
            if (trace.marker) trace.marker.showscale = false;
            if (Registry.traceIs(trace, "pie-like")) trace.textposition = "none";
          }
        }
        if (Array.isArray(options.annotations)) {
          for (i = 0; i < options.annotations.length; i++) {
            newLayout.annotations.push(options.annotations[i]);
          }
        }
        var sceneIds = Object.keys(newLayout).filter(function(key) {
          return key.match(/^scene\d*$/);
        });
        if (sceneIds.length) {
          var axesImageOverride = {};
          if (options.tileClass === "thumbnail") {
            axesImageOverride = {
              title: { text: "" },
              showaxeslabels: false,
              showticklabels: false,
              linetickenable: false
            };
          }
          for (i = 0; i < sceneIds.length; i++) {
            var scene = newLayout[sceneIds[i]];
            if (!scene.xaxis) {
              scene.xaxis = {};
            }
            if (!scene.yaxis) {
              scene.yaxis = {};
            }
            if (!scene.zaxis) {
              scene.zaxis = {};
            }
            extendFlat(scene.xaxis, axesImageOverride);
            extendFlat(scene.yaxis, axesImageOverride);
            extendFlat(scene.zaxis, axesImageOverride);
            scene._scene = null;
          }
        }
        var gd = document.createElement("div");
        if (options.tileClass) gd.className = options.tileClass;
        var plotTile = {
          gd,
          td: gd,
          // for external (image server) compatibility
          layout: newLayout,
          data: newData,
          config: {
            staticPlot: options.staticPlot === void 0 ? true : options.staticPlot,
            plotGlPixelRatio: options.plotGlPixelRatio === void 0 ? 2 : options.plotGlPixelRatio,
            displaylogo: options.displaylogo || false,
            showLink: options.showLink || false,
            showTips: options.showTips || false,
            mapboxAccessToken: context.mapboxAccessToken
          }
        };
        if (options.setBackground !== "transparent") {
          plotTile.config.setBackground = options.setBackground || "opaque";
        }
        plotTile.gd.defaultLayout = cloneLayoutOverride(options.tileClass);
        return plotTile;
      };
    }
  });

  // src/snapshot/toimage.js
  var require_toimage = __commonJS({
    "src/snapshot/toimage.js"(exports, module) {
      "use strict";
      var EventEmitter = require_events().EventEmitter;
      var Registry = require_registry();
      var Lib = require_lib();
      var helpers = require_helpers10();
      var clonePlot = require_cloneplot();
      var toSVG = require_tosvg();
      var svgToImg = require_svgtoimg();
      function toImage(gd, opts) {
        var ev = new EventEmitter();
        var clone = clonePlot(gd, { format: "png" });
        var clonedGd = clone.gd;
        clonedGd.style.position = "absolute";
        clonedGd.style.left = "-5000px";
        document.body.appendChild(clonedGd);
        function wait() {
          var delay = helpers.getDelay(clonedGd._fullLayout);
          setTimeout(function() {
            var svg = toSVG(clonedGd);
            var canvas = document.createElement("canvas");
            canvas.id = Lib.randstr();
            ev = svgToImg({
              format: opts.format,
              width: clonedGd._fullLayout.width,
              height: clonedGd._fullLayout.height,
              canvas,
              emitter: ev,
              svg
            });
            ev.clean = function() {
              if (clonedGd) document.body.removeChild(clonedGd);
            };
          }, delay);
        }
        var redrawFunc = helpers.getRedrawFunc(clonedGd);
        Registry.call("_doPlot", clonedGd, clone.data, clone.layout, clone.config).then(redrawFunc).then(wait).catch(function(err) {
          ev.emit("error", err);
        });
        return ev;
      }
      module.exports = toImage;
    }
  });

  // src/snapshot/index.js
  var require_snapshot = __commonJS({
    "src/snapshot/index.js"(exports, module) {
      "use strict";
      var helpers = require_helpers10();
      var Snapshot = {
        getDelay: helpers.getDelay,
        getRedrawFunc: helpers.getRedrawFunc,
        clone: require_cloneplot(),
        toSVG: require_tosvg(),
        svgToImg: require_svgtoimg(),
        toImage: require_toimage(),
        downloadImage: require_download()
      };
      module.exports = Snapshot;
    }
  });

  // src/core.js
  var require_core = __commonJS({
    "src/core.js"(exports) {
      "use strict";
      exports.version = require_version().version;
      require_npo_src();
      require_plotcss();
      var Registry = require_registry();
      var register = exports.register = Registry.register;
      var plotApi = require_plot_api2();
      var methodNames = Object.keys(plotApi);
      for (i = 0; i < methodNames.length; i++) {
        name = methodNames[i];
        if (name.charAt(0) !== "_") exports[name] = plotApi[name];
        register({
          moduleType: "apiMethod",
          name,
          fn: plotApi[name]
        });
      }
      var name;
      var i;
      register(require_scatter());
      register([
        require_annotations(),
        require_annotations3d(),
        require_selections(),
        require_shapes(),
        require_images(),
        require_updatemenus(),
        require_sliders(),
        require_rangeslider(),
        require_rangeselector(),
        require_grid(),
        require_errorbars(),
        require_colorscale(),
        require_colorbar(),
        require_legend(),
        // legend needs to come after shape | legend defaults depends on shapes
        require_fx(),
        // fx needs to come after legend | unified hover defaults depends on legends
        require_modebar2()
      ]);
      register([
        require_locale_en(),
        require_locale_en_us()
      ]);
      if (window.PlotlyLocales && Array.isArray(window.PlotlyLocales)) {
        register(window.PlotlyLocales);
        delete window.PlotlyLocales;
      }
      exports.Icons = require_ploticon();
      var Fx = require_fx();
      var Plots = require_plots();
      exports.Plots = {
        resize: Plots.resize,
        graphJson: Plots.graphJson,
        sendDataToCloud: Plots.sendDataToCloud
      };
      exports.Fx = {
        hover: Fx.hover,
        unhover: Fx.unhover,
        loneHover: Fx.loneHover,
        loneUnhover: Fx.loneUnhover
      };
      exports.Snapshot = require_snapshot();
      exports.PlotSchema = require_plot_schema();
    }
  });

  // lib/core.js
  var require_core2 = __commonJS({
    "lib/core.js"(exports, module) {
      "use strict";
      module.exports = require_core();
    }
  });

  // src/traces/bar/constants.js
  var require_constants14 = __commonJS({
    "src/traces/bar/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // padding in pixels around text
        TEXTPAD: 3,
        // 'value' and 'label' are not really necessary for bar traces,
        // but they were made available to `texttemplate` (maybe by accident)
        // via tokens `%{value}` and `%{label}` starting in 1.50.0,
        // so let's include them in the event data also.
        eventDataKeys: ["value", "label"]
      };
    }
  });

  // src/traces/bar/attributes.js
  var require_attributes23 = __commonJS({
    "src/traces/bar/attributes.js"(exports, module) {
      "use strict";
      var scatterAttrs = require_attributes12();
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var texttemplateAttrs = require_template_attributes().texttemplateAttrs;
      var colorScaleAttrs = require_attributes8();
      var fontAttrs = require_font_attributes();
      var constants = require_constants14();
      var pattern = require_attributes4().pattern;
      var extendFlat = require_extend().extendFlat;
      var textFontAttrs = fontAttrs({
        editType: "calc",
        arrayOk: true,
        colorEditType: "style"
      });
      var scatterMarkerAttrs = scatterAttrs.marker;
      var scatterMarkerLineAttrs = scatterMarkerAttrs.line;
      var markerLineWidth = extendFlat(
        {},
        scatterMarkerLineAttrs.width,
        { dflt: 0 }
      );
      var markerLine = extendFlat({
        width: markerLineWidth,
        editType: "calc"
      }, colorScaleAttrs("marker.line"));
      var marker = extendFlat({
        line: markerLine,
        editType: "calc"
      }, colorScaleAttrs("marker"), {
        opacity: {
          valType: "number",
          arrayOk: true,
          dflt: 1,
          min: 0,
          max: 1,
          editType: "style"
        },
        pattern,
        cornerradius: {
          valType: "any",
          editType: "calc"
        }
      });
      module.exports = {
        x: scatterAttrs.x,
        x0: scatterAttrs.x0,
        dx: scatterAttrs.dx,
        y: scatterAttrs.y,
        y0: scatterAttrs.y0,
        dy: scatterAttrs.dy,
        xperiod: scatterAttrs.xperiod,
        yperiod: scatterAttrs.yperiod,
        xperiod0: scatterAttrs.xperiod0,
        yperiod0: scatterAttrs.yperiod0,
        xperiodalignment: scatterAttrs.xperiodalignment,
        yperiodalignment: scatterAttrs.yperiodalignment,
        xhoverformat: axisHoverFormat("x"),
        yhoverformat: axisHoverFormat("y"),
        text: scatterAttrs.text,
        texttemplate: texttemplateAttrs({ editType: "plot" }, {
          keys: constants.eventDataKeys
        }),
        hovertext: scatterAttrs.hovertext,
        hovertemplate: hovertemplateAttrs({}, {
          keys: constants.eventDataKeys
        }),
        textposition: {
          valType: "enumerated",
          values: ["inside", "outside", "auto", "none"],
          dflt: "auto",
          arrayOk: true,
          editType: "calc"
        },
        insidetextanchor: {
          valType: "enumerated",
          values: ["end", "middle", "start"],
          dflt: "end",
          editType: "plot"
        },
        textangle: {
          valType: "angle",
          dflt: "auto",
          editType: "plot"
        },
        textfont: extendFlat({}, textFontAttrs, {}),
        insidetextfont: extendFlat({}, textFontAttrs, {}),
        outsidetextfont: extendFlat({}, textFontAttrs, {}),
        constraintext: {
          valType: "enumerated",
          values: ["inside", "outside", "both", "none"],
          dflt: "both",
          editType: "calc"
        },
        cliponaxis: extendFlat({}, scatterAttrs.cliponaxis, {}),
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          editType: "calc+clearAxisTypes"
        },
        base: {
          valType: "any",
          dflt: null,
          arrayOk: true,
          editType: "calc"
        },
        offset: {
          valType: "number",
          dflt: null,
          arrayOk: true,
          editType: "calc"
        },
        width: {
          valType: "number",
          dflt: null,
          min: 0,
          arrayOk: true,
          editType: "calc"
        },
        marker,
        offsetgroup: scatterAttrs.offsetgroup,
        alignmentgroup: scatterAttrs.alignmentgroup,
        selected: {
          marker: {
            opacity: scatterAttrs.selected.marker.opacity,
            color: scatterAttrs.selected.marker.color,
            editType: "style"
          },
          textfont: scatterAttrs.selected.textfont,
          editType: "style"
        },
        unselected: {
          marker: {
            opacity: scatterAttrs.unselected.marker.opacity,
            color: scatterAttrs.unselected.marker.color,
            editType: "style"
          },
          textfont: scatterAttrs.unselected.textfont,
          editType: "style"
        },
        zorder: scatterAttrs.zorder
      };
    }
  });

  // src/traces/bar/layout_attributes.js
  var require_layout_attributes6 = __commonJS({
    "src/traces/bar/layout_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        barmode: {
          valType: "enumerated",
          values: ["stack", "group", "overlay", "relative"],
          dflt: "group",
          editType: "calc"
        },
        barnorm: {
          valType: "enumerated",
          values: ["", "fraction", "percent"],
          dflt: "",
          editType: "calc"
        },
        bargap: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "calc"
        },
        bargroupgap: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0,
          editType: "calc"
        },
        barcornerradius: {
          valType: "any",
          editType: "calc"
        }
      };
    }
  });

  // src/traces/bar/style_defaults.js
  var require_style_defaults = __commonJS({
    "src/traces/bar/style_defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var hasColorscale = require_helpers().hasColorscale;
      var colorscaleDefaults = require_defaults2();
      var coercePattern = require_lib().coercePattern;
      module.exports = function handleStyleDefaults(traceIn, traceOut, coerce, defaultColor, layout) {
        var markerColor = coerce("marker.color", defaultColor);
        var hasMarkerColorscale = hasColorscale(traceIn, "marker");
        if (hasMarkerColorscale) {
          colorscaleDefaults(
            traceIn,
            traceOut,
            layout,
            coerce,
            { prefix: "marker.", cLetter: "c" }
          );
        }
        coerce("marker.line.color", Color.defaultLine);
        if (hasColorscale(traceIn, "marker.line")) {
          colorscaleDefaults(
            traceIn,
            traceOut,
            layout,
            coerce,
            { prefix: "marker.line.", cLetter: "c" }
          );
        }
        coerce("marker.line.width");
        coerce("marker.opacity");
        coercePattern(coerce, "marker.pattern", markerColor, hasMarkerColorscale);
        coerce("selected.marker.color");
        coerce("unselected.marker.color");
      };
    }
  });

  // src/traces/bar/defaults.js
  var require_defaults19 = __commonJS({
    "src/traces/bar/defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Color = require_color();
      var Registry = require_registry();
      var handleXYDefaults = require_xy_defaults();
      var handlePeriodDefaults = require_period_defaults();
      var handleStyleDefaults = require_style_defaults();
      var handleGroupingDefaults = require_grouping_defaults();
      var attributes = require_attributes23();
      var coerceFont = Lib.coerceFont;
      function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var len = handleXYDefaults(traceIn, traceOut, layout, coerce);
        if (!len) {
          traceOut.visible = false;
          return;
        }
        handlePeriodDefaults(traceIn, traceOut, layout, coerce);
        coerce("xhoverformat");
        coerce("yhoverformat");
        coerce("zorder");
        coerce("orientation", traceOut.x && !traceOut.y ? "h" : "v");
        coerce("base");
        coerce("offset");
        coerce("width");
        coerce("text");
        coerce("hovertext");
        coerce("hovertemplate");
        var textposition = coerce("textposition");
        handleText(traceIn, traceOut, layout, coerce, textposition, {
          moduleHasSelected: true,
          moduleHasUnselected: true,
          moduleHasConstrain: true,
          moduleHasCliponaxis: true,
          moduleHasTextangle: true,
          moduleHasInsideanchor: true
        });
        handleStyleDefaults(traceIn, traceOut, coerce, defaultColor, layout);
        var lineColor = (traceOut.marker.line || {}).color;
        var errorBarsSupplyDefaults = Registry.getComponentMethod("errorbars", "supplyDefaults");
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || Color.defaultLine, { axis: "y" });
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || Color.defaultLine, { axis: "x", inherit: "y" });
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
      }
      function crossTraceDefaults(fullData, fullLayout) {
        var traceIn, traceOut;
        function coerce(attr, dflt) {
          return Lib.coerce(traceOut._input, traceOut, attributes, attr, dflt);
        }
        for (var i = 0; i < fullData.length; i++) {
          traceOut = fullData[i];
          if (traceOut.type === "bar") {
            traceIn = traceOut._input;
            var r = coerce("marker.cornerradius", fullLayout.barcornerradius);
            if (traceOut.marker) {
              traceOut.marker.cornerradius = validateCornerradius(r);
            }
            handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce, fullLayout.barmode);
          }
        }
      }
      function validateCornerradius(r) {
        if (isNumeric(r)) {
          r = +r;
          if (r >= 0) return r;
        } else if (typeof r === "string") {
          r = r.trim();
          if (r.slice(-1) === "%" && isNumeric(r.slice(0, -1))) {
            r = +r.slice(0, -1);
            if (r >= 0) return r + "%";
          }
        }
        return void 0;
      }
      function handleText(traceIn, traceOut, layout, coerce, textposition, opts) {
        opts = opts || {};
        var moduleHasSelected = !(opts.moduleHasSelected === false);
        var moduleHasUnselected = !(opts.moduleHasUnselected === false);
        var moduleHasConstrain = !(opts.moduleHasConstrain === false);
        var moduleHasCliponaxis = !(opts.moduleHasCliponaxis === false);
        var moduleHasTextangle = !(opts.moduleHasTextangle === false);
        var moduleHasInsideanchor = !(opts.moduleHasInsideanchor === false);
        var hasPathbar = !!opts.hasPathbar;
        var hasBoth = Array.isArray(textposition) || textposition === "auto";
        var hasInside = hasBoth || textposition === "inside";
        var hasOutside = hasBoth || textposition === "outside";
        if (hasInside || hasOutside) {
          var dfltFont = coerceFont(coerce, "textfont", layout.font);
          var insideTextFontDefault = Lib.extendFlat({}, dfltFont);
          var isTraceTextfontColorSet = traceIn.textfont && traceIn.textfont.color;
          var isColorInheritedFromLayoutFont = !isTraceTextfontColorSet;
          if (isColorInheritedFromLayoutFont) {
            delete insideTextFontDefault.color;
          }
          coerceFont(coerce, "insidetextfont", insideTextFontDefault);
          if (hasPathbar) {
            var pathbarTextFontDefault = Lib.extendFlat({}, dfltFont);
            if (isColorInheritedFromLayoutFont) {
              delete pathbarTextFontDefault.color;
            }
            coerceFont(coerce, "pathbar.textfont", pathbarTextFontDefault);
          }
          if (hasOutside) coerceFont(coerce, "outsidetextfont", dfltFont);
          if (moduleHasSelected) coerce("selected.textfont.color");
          if (moduleHasUnselected) coerce("unselected.textfont.color");
          if (moduleHasConstrain) coerce("constraintext");
          if (moduleHasCliponaxis) coerce("cliponaxis");
          if (moduleHasTextangle) coerce("textangle");
          coerce("texttemplate");
        }
        if (hasInside) {
          if (moduleHasInsideanchor) coerce("insidetextanchor");
        }
      }
      module.exports = {
        supplyDefaults,
        crossTraceDefaults,
        handleText,
        validateCornerradius
      };
    }
  });

  // src/traces/bar/layout_defaults.js
  var require_layout_defaults5 = __commonJS({
    "src/traces/bar/layout_defaults.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Axes = require_axes();
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes6();
      var validateCornerradius = require_defaults19().validateCornerradius;
      module.exports = function(layoutIn, layoutOut, fullData) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        var hasBars = false;
        var shouldBeGapless = false;
        var gappedAnyway = false;
        var usedSubplots = {};
        var mode = coerce("barmode");
        var isGroup = mode === "group";
        for (var i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          if (Registry.traceIs(trace, "bar") && trace.visible) hasBars = true;
          else continue;
          var subploti = trace.xaxis + trace.yaxis;
          if (isGroup) {
            if (usedSubplots[subploti]) gappedAnyway = true;
            usedSubplots[subploti] = true;
          } else {
            subploti += trace._input.offsetgroup;
            if (usedSubplots.length > 0 && !usedSubplots[subploti]) gappedAnyway = true;
            usedSubplots[subploti] = true;
          }
          if (trace.visible && trace.type === "histogram") {
            var pa = Axes.getFromId(
              { _fullLayout: layoutOut },
              trace[trace.orientation === "v" ? "xaxis" : "yaxis"]
            );
            if (pa.type !== "category") shouldBeGapless = true;
          }
        }
        if (!hasBars) {
          delete layoutOut.barmode;
          return;
        }
        if (mode !== "overlay") coerce("barnorm");
        coerce("bargap", shouldBeGapless && !gappedAnyway ? 0 : 0.2);
        coerce("bargroupgap");
        var r = coerce("barcornerradius");
        layoutOut.barcornerradius = validateCornerradius(r);
      };
    }
  });

  // src/traces/bar/arrays_to_calcdata.js
  var require_arrays_to_calcdata2 = __commonJS({
    "src/traces/bar/arrays_to_calcdata.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function arraysToCalcdata(cd, trace) {
        for (var i = 0; i < cd.length; i++) cd[i].i = i;
        Lib.mergeArray(trace.text, cd, "tx");
        Lib.mergeArray(trace.hovertext, cd, "htx");
        var marker = trace.marker;
        if (marker) {
          Lib.mergeArray(marker.opacity, cd, "mo", true);
          Lib.mergeArray(marker.color, cd, "mc");
          var markerLine = marker.line;
          if (markerLine) {
            Lib.mergeArray(markerLine.color, cd, "mlc");
            Lib.mergeArrayCastPositive(markerLine.width, cd, "mlw");
          }
        }
      };
    }
  });

  // src/traces/bar/calc.js
  var require_calc5 = __commonJS({
    "src/traces/bar/calc.js"(exports, module) {
      "use strict";
      var Axes = require_axes();
      var alignPeriod = require_align_period();
      var hasColorscale = require_helpers().hasColorscale;
      var colorscaleCalc = require_calc();
      var arraysToCalcdata = require_arrays_to_calcdata2();
      var calcSelection = require_calc_selection();
      module.exports = function calc(gd, trace) {
        var xa = Axes.getFromId(gd, trace.xaxis || "x");
        var ya = Axes.getFromId(gd, trace.yaxis || "y");
        var size, pos, origPos, pObj, hasPeriod, pLetter;
        var sizeOpts = {
          msUTC: !!(trace.base || trace.base === 0)
        };
        if (trace.orientation === "h") {
          size = xa.makeCalcdata(trace, "x", sizeOpts);
          origPos = ya.makeCalcdata(trace, "y");
          pObj = alignPeriod(trace, ya, "y", origPos);
          hasPeriod = !!trace.yperiodalignment;
          pLetter = "y";
        } else {
          size = ya.makeCalcdata(trace, "y", sizeOpts);
          origPos = xa.makeCalcdata(trace, "x");
          pObj = alignPeriod(trace, xa, "x", origPos);
          hasPeriod = !!trace.xperiodalignment;
          pLetter = "x";
        }
        pos = pObj.vals;
        var serieslen = Math.min(pos.length, size.length);
        var cd = new Array(serieslen);
        for (var i = 0; i < serieslen; i++) {
          cd[i] = { p: pos[i], s: size[i] };
          if (hasPeriod) {
            cd[i].orig_p = origPos[i];
            cd[i][pLetter + "End"] = pObj.ends[i];
            cd[i][pLetter + "Start"] = pObj.starts[i];
          }
          if (trace.ids) {
            cd[i].id = String(trace.ids[i]);
          }
        }
        if (hasColorscale(trace, "marker")) {
          colorscaleCalc(gd, trace, {
            vals: trace.marker.color,
            containerStr: "marker",
            cLetter: "c"
          });
        }
        if (hasColorscale(trace, "marker.line")) {
          colorscaleCalc(gd, trace, {
            vals: trace.marker.line.color,
            containerStr: "marker.line",
            cLetter: "c"
          });
        }
        arraysToCalcdata(cd, trace);
        calcSelection(cd, trace);
        return cd;
      };
    }
  });

  // src/traces/bar/uniform_text.js
  var require_uniform_text = __commonJS({
    "src/traces/bar/uniform_text.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      function resizeText(gd, gTrace, traceType) {
        var fullLayout = gd._fullLayout;
        var minSize = fullLayout["_" + traceType + "Text_minsize"];
        if (minSize) {
          var shouldHide = fullLayout.uniformtext.mode === "hide";
          var selector;
          switch (traceType) {
            case "funnelarea":
            case "pie":
            case "sunburst":
              selector = "g.slice";
              break;
            case "treemap":
            case "icicle":
              selector = "g.slice, g.pathbar";
              break;
            default:
              selector = "g.points > g.point";
          }
          gTrace.selectAll(selector).each(function(d) {
            var transform = d.transform;
            if (transform) {
              transform.scale = shouldHide && transform.hide ? 0 : minSize / transform.fontSize;
              var el = d3.select(this).select("text");
              Lib.setTransormAndDisplay(el, transform);
            }
          });
        }
      }
      function recordMinTextSize(traceType, transform, fullLayout) {
        if (fullLayout.uniformtext.mode) {
          var minKey = getMinKey(traceType);
          var minSize = fullLayout.uniformtext.minsize;
          var size = transform.scale * transform.fontSize;
          transform.hide = size < minSize;
          fullLayout[minKey] = fullLayout[minKey] || Infinity;
          if (!transform.hide) {
            fullLayout[minKey] = Math.min(
              fullLayout[minKey],
              Math.max(size, minSize)
            );
          }
        }
      }
      function clearMinTextSize(traceType, fullLayout) {
        var minKey = getMinKey(traceType);
        fullLayout[minKey] = void 0;
      }
      function getMinKey(traceType) {
        return "_" + traceType + "Text_minsize";
      }
      module.exports = {
        recordMinTextSize,
        clearMinTextSize,
        resizeText
      };
    }
  });

  // src/traces/bar/helpers.js
  var require_helpers12 = __commonJS({
    "src/traces/bar/helpers.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      exports.coerceString = function(attributeDefinition, value, defaultValue) {
        if (typeof value === "string") {
          if (value || !attributeDefinition.noBlank) return value;
        } else if (typeof value === "number" || value === true) {
          if (!attributeDefinition.strict) return String(value);
        }
        return defaultValue !== void 0 ? defaultValue : attributeDefinition.dflt;
      };
      exports.coerceNumber = function(attributeDefinition, value, defaultValue) {
        if (isNumeric(value)) {
          value = +value;
          var min = attributeDefinition.min;
          var max = attributeDefinition.max;
          var isOutOfBounds = min !== void 0 && value < min || max !== void 0 && value > max;
          if (!isOutOfBounds) return value;
        }
        return defaultValue !== void 0 ? defaultValue : attributeDefinition.dflt;
      };
      exports.coerceColor = function(attributeDefinition, value, defaultValue) {
        if (tinycolor(value).isValid()) return value;
        return defaultValue !== void 0 ? defaultValue : attributeDefinition.dflt;
      };
      exports.coerceEnumerated = function(attributeDefinition, value, defaultValue) {
        if (attributeDefinition.coerceNumber) value = +value;
        if (attributeDefinition.values.indexOf(value) !== -1) return value;
        return defaultValue !== void 0 ? defaultValue : attributeDefinition.dflt;
      };
      exports.getValue = function(arrayOrScalar, index) {
        var value;
        if (!isArrayOrTypedArray(arrayOrScalar)) value = arrayOrScalar;
        else if (index < arrayOrScalar.length) value = arrayOrScalar[index];
        return value;
      };
      exports.getLineWidth = function(trace, di) {
        var w = 0 < di.mlw ? di.mlw : !isArrayOrTypedArray(trace.marker.line.width) ? trace.marker.line.width : 0;
        return w;
      };
    }
  });

  // src/traces/bar/style.js
  var require_style4 = __commonJS({
    "src/traces/bar/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var Registry = require_registry();
      var resizeText = require_uniform_text().resizeText;
      var attributes = require_attributes23();
      var attributeTextFont = attributes.textfont;
      var attributeInsideTextFont = attributes.insidetextfont;
      var attributeOutsideTextFont = attributes.outsidetextfont;
      var helpers = require_helpers12();
      function style(gd) {
        var s = d3.select(gd).selectAll('g[class^="barlayer"]').selectAll("g.trace");
        resizeText(gd, s, "bar");
        var barcount = s.size();
        var fullLayout = gd._fullLayout;
        s.style("opacity", function(d) {
          return d[0].trace.opacity;
        }).each(function(d) {
          if (fullLayout.barmode === "stack" && barcount > 1 || fullLayout.bargap === 0 && fullLayout.bargroupgap === 0 && !d[0].trace.marker.line.width) {
            d3.select(this).attr("shape-rendering", "crispEdges");
          }
        });
        s.selectAll("g.points").each(function(d) {
          var sel = d3.select(this);
          var trace = d[0].trace;
          stylePoints(sel, trace, gd);
        });
        Registry.getComponentMethod("errorbars", "style")(s);
      }
      function stylePoints(sel, trace, gd) {
        Drawing.pointStyle(sel.selectAll("path"), trace, gd);
        styleTextPoints(sel, trace, gd);
      }
      function styleTextPoints(sel, trace, gd) {
        sel.selectAll("text").each(function(d) {
          var tx = d3.select(this);
          var font = Lib.ensureUniformFontSize(gd, determineFont(tx, d, trace, gd));
          Drawing.font(tx, font);
        });
      }
      function styleOnSelect(gd, cd, sel) {
        var trace = cd[0].trace;
        if (trace.selectedpoints) {
          stylePointsInSelectionMode(sel, trace, gd);
        } else {
          stylePoints(sel, trace, gd);
          Registry.getComponentMethod("errorbars", "style")(sel);
        }
      }
      function stylePointsInSelectionMode(s, trace, gd) {
        Drawing.selectedPointStyle(s.selectAll("path"), trace);
        styleTextInSelectionMode(s.selectAll("text"), trace, gd);
      }
      function styleTextInSelectionMode(txs, trace, gd) {
        txs.each(function(d) {
          var tx = d3.select(this);
          var font;
          if (d.selected) {
            font = Lib.ensureUniformFontSize(gd, determineFont(tx, d, trace, gd));
            var selectedFontColor = trace.selected.textfont && trace.selected.textfont.color;
            if (selectedFontColor) {
              font.color = selectedFontColor;
            }
            Drawing.font(tx, font);
          } else {
            Drawing.selectedTextStyle(tx, trace);
          }
        });
      }
      function determineFont(tx, d, trace, gd) {
        var layoutFont = gd._fullLayout.font;
        var textFont = trace.textfont;
        if (tx.classed("bartext-inside")) {
          var barColor = getBarColor(d, trace);
          textFont = getInsideTextFont(trace, d.i, layoutFont, barColor);
        } else if (tx.classed("bartext-outside")) {
          textFont = getOutsideTextFont(trace, d.i, layoutFont);
        }
        return textFont;
      }
      function getTextFont(trace, index, defaultValue) {
        return getFontValue(
          attributeTextFont,
          trace.textfont,
          index,
          defaultValue
        );
      }
      function getInsideTextFont(trace, index, layoutFont, barColor) {
        var defaultFont = getTextFont(trace, index, layoutFont);
        var wouldFallBackToLayoutFont = trace._input.textfont === void 0 || trace._input.textfont.color === void 0 || Array.isArray(trace.textfont.color) && trace.textfont.color[index] === void 0;
        if (wouldFallBackToLayoutFont) {
          defaultFont = {
            color: Color.contrast(barColor),
            family: defaultFont.family,
            size: defaultFont.size,
            weight: defaultFont.weight,
            style: defaultFont.style,
            variant: defaultFont.variant,
            textcase: defaultFont.textcase,
            lineposition: defaultFont.lineposition,
            shadow: defaultFont.shadow
          };
        }
        return getFontValue(
          attributeInsideTextFont,
          trace.insidetextfont,
          index,
          defaultFont
        );
      }
      function getOutsideTextFont(trace, index, layoutFont) {
        var defaultFont = getTextFont(trace, index, layoutFont);
        return getFontValue(
          attributeOutsideTextFont,
          trace.outsidetextfont,
          index,
          defaultFont
        );
      }
      function getFontValue(attributeDefinition, attributeValue, index, defaultValue) {
        attributeValue = attributeValue || {};
        var familyValue = helpers.getValue(attributeValue.family, index);
        var sizeValue = helpers.getValue(attributeValue.size, index);
        var colorValue = helpers.getValue(attributeValue.color, index);
        var weightValue = helpers.getValue(attributeValue.weight, index);
        var styleValue = helpers.getValue(attributeValue.style, index);
        var variantValue = helpers.getValue(attributeValue.variant, index);
        var textcaseValue = helpers.getValue(attributeValue.textcase, index);
        var linepositionValue = helpers.getValue(attributeValue.lineposition, index);
        var shadowValue = helpers.getValue(attributeValue.shadow, index);
        return {
          family: helpers.coerceString(
            attributeDefinition.family,
            familyValue,
            defaultValue.family
          ),
          size: helpers.coerceNumber(
            attributeDefinition.size,
            sizeValue,
            defaultValue.size
          ),
          color: helpers.coerceColor(
            attributeDefinition.color,
            colorValue,
            defaultValue.color
          ),
          weight: helpers.coerceString(
            attributeDefinition.weight,
            weightValue,
            defaultValue.weight
          ),
          style: helpers.coerceString(
            attributeDefinition.style,
            styleValue,
            defaultValue.style
          ),
          variant: helpers.coerceString(
            attributeDefinition.variant,
            variantValue,
            defaultValue.variant
          ),
          textcase: helpers.coerceString(
            attributeDefinition.variant,
            textcaseValue,
            defaultValue.textcase
          ),
          lineposition: helpers.coerceString(
            attributeDefinition.variant,
            linepositionValue,
            defaultValue.lineposition
          ),
          shadow: helpers.coerceString(
            attributeDefinition.variant,
            shadowValue,
            defaultValue.shadow
          )
        };
      }
      function getBarColor(cd, trace) {
        if (trace.type === "waterfall") {
          return trace[cd.dir].marker.color;
        }
        return cd.mcc || cd.mc || trace.marker.color;
      }
      module.exports = {
        style,
        styleTextPoints,
        styleOnSelect,
        getInsideTextFont,
        getOutsideTextFont,
        getBarColor,
        resizeText
      };
    }
  });

  // src/traces/bar/plot.js
  var require_plot3 = __commonJS({
    "src/traces/bar/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var svgTextUtils = require_svg_text_utils();
      var Color = require_color();
      var Drawing = require_drawing();
      var Registry = require_registry();
      var tickText = require_axes().tickText;
      var uniformText = require_uniform_text();
      var recordMinTextSize = uniformText.recordMinTextSize;
      var clearMinTextSize = uniformText.clearMinTextSize;
      var style = require_style4();
      var helpers = require_helpers12();
      var constants = require_constants14();
      var attributes = require_attributes23();
      var attributeText = attributes.text;
      var attributeTextPosition = attributes.textposition;
      var appendArrayPointValue = require_helpers2().appendArrayPointValue;
      var TEXTPAD = constants.TEXTPAD;
      function keyFunc(d) {
        return d.id;
      }
      function getKeyFunc(trace) {
        if (trace.ids) {
          return keyFunc;
        }
      }
      function sign(v) {
        return (v > 0) - (v < 0);
      }
      function dirSign(a, b) {
        return a < b ? 1 : -1;
      }
      function getXY(di, xa, ya, isHorizontal) {
        var s = [];
        var p = [];
        var sAxis = isHorizontal ? xa : ya;
        var pAxis = isHorizontal ? ya : xa;
        s[0] = sAxis.c2p(di.s0, true);
        p[0] = pAxis.c2p(di.p0, true);
        s[1] = sAxis.c2p(di.s1, true);
        p[1] = pAxis.c2p(di.p1, true);
        return isHorizontal ? [s, p] : [p, s];
      }
      function transition(selection, fullLayout, opts, makeOnCompleteCallback) {
        if (!fullLayout.uniformtext.mode && hasTransition(opts)) {
          var onComplete;
          if (makeOnCompleteCallback) {
            onComplete = makeOnCompleteCallback();
          }
          return selection.transition().duration(opts.duration).ease(opts.easing).each("end", function() {
            onComplete && onComplete();
          }).each("interrupt", function() {
            onComplete && onComplete();
          });
        } else {
          return selection;
        }
      }
      function hasTransition(transitionOpts) {
        return transitionOpts && transitionOpts.duration > 0;
      }
      function plot(gd, plotinfo, cdModule, traceLayer, opts, makeOnCompleteCallback) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var fullLayout = gd._fullLayout;
        var isStatic = gd._context.staticPlot;
        if (!opts) {
          opts = {
            mode: fullLayout.barmode,
            norm: fullLayout.barmode,
            gap: fullLayout.bargap,
            groupgap: fullLayout.bargroupgap
          };
          clearMinTextSize("bar", fullLayout);
        }
        var bartraces = Lib.makeTraceGroups(traceLayer, cdModule, "trace bars").each(function(cd) {
          var plotGroup = d3.select(this);
          var trace = cd[0].trace;
          var t = cd[0].t;
          var isWaterfall = trace.type === "waterfall";
          var isFunnel = trace.type === "funnel";
          var isHistogram = trace.type === "histogram";
          var isBar = trace.type === "bar";
          var shouldDisplayZeros = isBar || isFunnel;
          var adjustPixel = 0;
          if (isWaterfall && trace.connector.visible && trace.connector.mode === "between") {
            adjustPixel = trace.connector.line.width / 2;
          }
          var isHorizontal = trace.orientation === "h";
          var withTransition = hasTransition(opts);
          var pointGroup = Lib.ensureSingle(plotGroup, "g", "points");
          var keyFunc2 = getKeyFunc(trace);
          var bars = pointGroup.selectAll("g.point").data(Lib.identity, keyFunc2);
          bars.enter().append("g").classed("point", true);
          bars.exit().remove();
          bars.each(function(di, i) {
            var bar = d3.select(this);
            var xy = getXY(di, xa, ya, isHorizontal);
            var x0 = xy[0][0];
            var x1 = xy[0][1];
            var y0 = xy[1][0];
            var y1 = xy[1][1];
            var isBlank = (isHorizontal ? x1 - x0 : y1 - y0) === 0;
            if (isBlank && shouldDisplayZeros && helpers.getLineWidth(trace, di)) {
              isBlank = false;
            }
            if (!isBlank) {
              isBlank = !isNumeric(x0) || !isNumeric(x1) || !isNumeric(y0) || !isNumeric(y1);
            }
            di.isBlank = isBlank;
            if (isBlank) {
              if (isHorizontal) {
                x1 = x0;
              } else {
                y1 = y0;
              }
            }
            if (adjustPixel && !isBlank) {
              if (isHorizontal) {
                x0 -= dirSign(x0, x1) * adjustPixel;
                x1 += dirSign(x0, x1) * adjustPixel;
              } else {
                y0 -= dirSign(y0, y1) * adjustPixel;
                y1 += dirSign(y0, y1) * adjustPixel;
              }
            }
            var lw;
            var mc;
            if (trace.type === "waterfall") {
              if (!isBlank) {
                var cont = trace[di.dir].marker;
                lw = cont.line.width;
                mc = cont.color;
              }
            } else {
              lw = helpers.getLineWidth(trace, di);
              mc = di.mc || trace.marker.color;
            }
            function roundWithLine(v) {
              var offset = d3.round(lw / 2 % 1, 2);
              return opts.gap === 0 && opts.groupgap === 0 ? d3.round(Math.round(v) - offset, 2) : v;
            }
            function expandToVisible(v, vc, hideZeroSpan) {
              if (hideZeroSpan && v === vc) {
                return v;
              }
              return Math.abs(v - vc) >= 2 ? roundWithLine(v) : (
                // but if it's very thin, expand it so it's
                // necessarily visible, even if it might overlap
                // its neighbor
                v > vc ? Math.ceil(v) : Math.floor(v)
              );
            }
            var op = Color.opacity(mc);
            var fixpx = op < 1 || lw > 0.01 ? roundWithLine : expandToVisible;
            if (!gd._context.staticPlot) {
              x0 = fixpx(x0, x1, isHorizontal);
              x1 = fixpx(x1, x0, isHorizontal);
              y0 = fixpx(y0, y1, !isHorizontal);
              y1 = fixpx(y1, y0, !isHorizontal);
            }
            var c2p = isHorizontal ? xa.c2p : ya.c2p;
            var outerBound;
            if (di.s0 > 0) {
              outerBound = di._sMax;
            } else if (di.s0 < 0) {
              outerBound = di._sMin;
            } else {
              outerBound = di.s1 > 0 ? di._sMax : di._sMin;
            }
            function calcCornerRadius(crValue, crForm) {
              if (!crValue) return 0;
              var barWidth = isHorizontal ? Math.abs(y1 - y0) : Math.abs(x1 - x0);
              var barLength = isHorizontal ? Math.abs(x1 - x0) : Math.abs(y1 - y0);
              var stackedBarTotalLength = fixpx(Math.abs(c2p(outerBound, true) - c2p(0, true)));
              var maxRadius = di.hasB ? Math.min(barWidth / 2, barLength / 2) : Math.min(barWidth / 2, stackedBarTotalLength);
              var crPx;
              if (crForm === "%") {
                var crPercent = Math.min(50, crValue);
                crPx = barWidth * (crPercent / 100);
              } else {
                crPx = crValue;
              }
              return fixpx(Math.max(Math.min(crPx, maxRadius), 0));
            }
            var r = isBar || isHistogram ? calcCornerRadius(t.cornerradiusvalue, t.cornerradiusform) : 0;
            var path, h;
            var rectanglePath = "M" + x0 + "," + y0 + "V" + y1 + "H" + x1 + "V" + y0 + "Z";
            var overhead = 0;
            if (r && di.s) {
              var refPoint = sign(di.s0) === 0 || sign(di.s) === sign(di.s0) ? di.s1 : di.s0;
              overhead = fixpx(!di.hasB ? Math.abs(c2p(outerBound, true) - c2p(refPoint, true)) : 0);
              if (overhead < r) {
                var xdir = dirSign(x0, x1);
                var ydir = dirSign(y0, y1);
                var cornersweep = xdir === -ydir ? 1 : 0;
                if (isHorizontal) {
                  if (di.hasB) {
                    path = "M" + (x0 + r * xdir) + "," + y0 + "A " + r + "," + r + " 0 0 " + cornersweep + " " + x0 + "," + (y0 + r * ydir) + "V" + (y1 - r * ydir) + "A " + r + "," + r + " 0 0 " + cornersweep + " " + (x0 + r * xdir) + "," + y1 + "H" + (x1 - r * xdir) + "A " + r + "," + r + " 0 0 " + cornersweep + " " + x1 + "," + (y1 - r * ydir) + "V" + (y0 + r * ydir) + "A " + r + "," + r + " 0 0 " + cornersweep + " " + (x1 - r * xdir) + "," + y0 + "Z";
                  } else {
                    h = Math.abs(x1 - x0) + overhead;
                    var dy1 = h < r ? r - Math.sqrt(h * (2 * r - h)) : 0;
                    var dy2 = overhead > 0 ? Math.sqrt(overhead * (2 * r - overhead)) : 0;
                    var xminfunc = xdir > 0 ? Math.max : Math.min;
                    path = "M" + x0 + "," + y0 + "V" + (y1 - dy1 * ydir) + "H" + xminfunc(x1 - (r - overhead) * xdir, x0) + "A " + r + "," + r + " 0 0 " + cornersweep + " " + x1 + "," + (y1 - r * ydir - dy2) + "V" + (y0 + r * ydir + dy2) + "A " + r + "," + r + " 0 0 " + cornersweep + " " + xminfunc(x1 - (r - overhead) * xdir, x0) + "," + (y0 + dy1 * ydir) + "Z";
                  }
                } else {
                  if (di.hasB) {
                    path = "M" + (x0 + r * xdir) + "," + y0 + "A " + r + "," + r + " 0 0 " + cornersweep + " " + x0 + "," + (y0 + r * ydir) + "V" + (y1 - r * ydir) + "A " + r + "," + r + " 0 0 " + cornersweep + " " + (x0 + r * xdir) + "," + y1 + "H" + (x1 - r * xdir) + "A " + r + "," + r + " 0 0 " + cornersweep + " " + x1 + "," + (y1 - r * ydir) + "V" + (y0 + r * ydir) + "A " + r + "," + r + " 0 0 " + cornersweep + " " + (x1 - r * xdir) + "," + y0 + "Z";
                  } else {
                    h = Math.abs(y1 - y0) + overhead;
                    var dx1 = h < r ? r - Math.sqrt(h * (2 * r - h)) : 0;
                    var dx2 = overhead > 0 ? Math.sqrt(overhead * (2 * r - overhead)) : 0;
                    var yminfunc = ydir > 0 ? Math.max : Math.min;
                    path = "M" + (x0 + dx1 * xdir) + "," + y0 + "V" + yminfunc(y1 - (r - overhead) * ydir, y0) + "A " + r + "," + r + " 0 0 " + cornersweep + " " + (x0 + r * xdir - dx2) + "," + y1 + "H" + (x1 - r * xdir + dx2) + "A " + r + "," + r + " 0 0 " + cornersweep + " " + (x1 - dx1 * xdir) + "," + yminfunc(y1 - (r - overhead) * ydir, y0) + "V" + y0 + "Z";
                  }
                }
              } else {
                path = rectanglePath;
              }
            } else {
              path = rectanglePath;
            }
            var sel = transition(Lib.ensureSingle(bar, "path"), fullLayout, opts, makeOnCompleteCallback);
            sel.style("vector-effect", isStatic ? "none" : "non-scaling-stroke").attr("d", isNaN((x1 - x0) * (y1 - y0)) || isBlank && gd._context.staticPlot ? "M0,0Z" : path).call(Drawing.setClipUrl, plotinfo.layerClipId, gd);
            if (!fullLayout.uniformtext.mode && withTransition) {
              var styleFns = Drawing.makePointStyleFns(trace);
              Drawing.singlePointStyle(di, sel, trace, styleFns, gd);
            }
            appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, r, overhead, opts, makeOnCompleteCallback);
            if (plotinfo.layerClipId) {
              Drawing.hideOutsideRangePoint(di, bar.select("text"), xa, ya, trace.xcalendar, trace.ycalendar);
            }
          });
          var hasClipOnAxisFalse = trace.cliponaxis === false;
          Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);
        });
        Registry.getComponentMethod("errorbars", "plot")(gd, bartraces, plotinfo, opts);
      }
      function appendBarText(gd, plotinfo, bar, cd, i, x0, x1, y0, y1, r, overhead, opts, makeOnCompleteCallback) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var fullLayout = gd._fullLayout;
        var textPosition;
        function appendTextNode(bar2, text2, font2) {
          var textSelection2 = Lib.ensureSingle(bar2, "text").text(text2).attr({
            class: "bartext bartext-" + textPosition,
            "text-anchor": "middle",
            // prohibit tex interpretation until we can handle
            // tex and regular text together
            "data-notex": 1
          }).call(Drawing.font, font2).call(svgTextUtils.convertToTspans, gd);
          return textSelection2;
        }
        var trace = cd[0].trace;
        var isHorizontal = trace.orientation === "h";
        var text = getText(fullLayout, cd, i, xa, ya);
        textPosition = getTextPosition(trace, i);
        var inStackOrRelativeMode = opts.mode === "stack" || opts.mode === "relative";
        var calcBar = cd[i];
        var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;
        var hasB = calcBar.hasB;
        var barIsRounded = r && r - overhead > TEXTPAD;
        if (!text || textPosition === "none" || (calcBar.isBlank || x0 === x1 || y0 === y1) && (textPosition === "auto" || textPosition === "inside")) {
          bar.select("text").remove();
          return;
        }
        var layoutFont = fullLayout.font;
        var barColor = style.getBarColor(cd[i], trace);
        var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);
        var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont);
        var insidetextanchor = trace.insidetextanchor || "end";
        var di = bar.datum();
        if (isHorizontal) {
          if (xa.type === "log" && di.s0 <= 0) {
            if (xa.range[0] < xa.range[1]) {
              x0 = 0;
            } else {
              x0 = xa._length;
            }
          }
        } else {
          if (ya.type === "log" && di.s0 <= 0) {
            if (ya.range[0] < ya.range[1]) {
              y0 = ya._length;
            } else {
              y0 = 0;
            }
          }
        }
        var lx = Math.abs(x1 - x0);
        var ly = Math.abs(y1 - y0);
        var barWidth = lx - 2 * TEXTPAD;
        var barHeight = ly - 2 * TEXTPAD;
        var textSelection;
        var textBB;
        var textWidth;
        var textHeight;
        var font;
        if (textPosition === "outside") {
          if (!isOutmostBar && !calcBar.hasB) textPosition = "inside";
        }
        if (textPosition === "auto") {
          if (isOutmostBar) {
            textPosition = "inside";
            font = Lib.ensureUniformFontSize(gd, insideTextFont);
            textSelection = appendTextNode(bar, text, font);
            textBB = Drawing.bBox(textSelection.node());
            textWidth = textBB.width;
            textHeight = textBB.height;
            var textHasSize = textWidth > 0 && textHeight > 0;
            var fitsInside;
            if (barIsRounded) {
              if (hasB) {
                fitsInside = textfitsInsideBar(barWidth - 2 * r, barHeight, textWidth, textHeight, isHorizontal) || textfitsInsideBar(barWidth, barHeight - 2 * r, textWidth, textHeight, isHorizontal);
              } else if (isHorizontal) {
                fitsInside = textfitsInsideBar(barWidth - (r - overhead), barHeight, textWidth, textHeight, isHorizontal) || textfitsInsideBar(barWidth, barHeight - 2 * (r - overhead), textWidth, textHeight, isHorizontal);
              } else {
                fitsInside = textfitsInsideBar(barWidth, barHeight - (r - overhead), textWidth, textHeight, isHorizontal) || textfitsInsideBar(barWidth - 2 * (r - overhead), barHeight, textWidth, textHeight, isHorizontal);
              }
            } else {
              fitsInside = textfitsInsideBar(barWidth, barHeight, textWidth, textHeight, isHorizontal);
            }
            if (textHasSize && fitsInside) {
              textPosition = "inside";
            } else {
              textPosition = "outside";
              textSelection.remove();
              textSelection = null;
            }
          } else {
            textPosition = "inside";
          }
        }
        if (!textSelection) {
          font = Lib.ensureUniformFontSize(gd, textPosition === "outside" ? outsideTextFont : insideTextFont);
          textSelection = appendTextNode(bar, text, font);
          var currentTransform = textSelection.attr("transform");
          textSelection.attr("transform", "");
          textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;
          textSelection.attr("transform", currentTransform);
          if (textWidth <= 0 || textHeight <= 0) {
            textSelection.remove();
            return;
          }
        }
        var angle = trace.textangle;
        var transform, constrained;
        if (textPosition === "outside") {
          constrained = trace.constraintext === "both" || trace.constraintext === "outside";
          transform = toMoveOutsideBar(x0, x1, y0, y1, textBB, {
            isHorizontal,
            constrained,
            angle
          });
        } else {
          constrained = trace.constraintext === "both" || trace.constraintext === "inside";
          transform = toMoveInsideBar(x0, x1, y0, y1, textBB, {
            isHorizontal,
            constrained,
            angle,
            anchor: insidetextanchor,
            hasB,
            r,
            overhead
          });
        }
        transform.fontSize = font.size;
        recordMinTextSize(trace.type === "histogram" ? "bar" : trace.type, transform, fullLayout);
        calcBar.transform = transform;
        var s = transition(textSelection, fullLayout, opts, makeOnCompleteCallback);
        Lib.setTransormAndDisplay(s, transform);
      }
      function textfitsInsideBar(barWidth, barHeight, textWidth, textHeight, isHorizontal) {
        if (barWidth < 0 || barHeight < 0) return false;
        var fitsInside = textWidth <= barWidth && textHeight <= barHeight;
        var fitsInsideIfRotated = textWidth <= barHeight && textHeight <= barWidth;
        var fitsInsideIfShrunk = isHorizontal ? barWidth >= textWidth * (barHeight / textHeight) : barHeight >= textHeight * (barWidth / textWidth);
        return fitsInside || fitsInsideIfRotated || fitsInsideIfShrunk;
      }
      function getRotateFromAngle(angle) {
        return angle === "auto" ? 0 : angle;
      }
      function getRotatedTextSize(textBB, rotate) {
        var a = Math.PI / 180 * rotate;
        var absSin = Math.abs(Math.sin(a));
        var absCos = Math.abs(Math.cos(a));
        return {
          x: textBB.width * absCos + textBB.height * absSin,
          y: textBB.width * absSin + textBB.height * absCos
        };
      }
      function toMoveInsideBar(x0, x1, y0, y1, textBB, opts) {
        var isHorizontal = !!opts.isHorizontal;
        var constrained = !!opts.constrained;
        var angle = opts.angle || 0;
        var anchor = opts.anchor;
        var isEnd = anchor === "end";
        var isStart = anchor === "start";
        var leftToRight = opts.leftToRight || 0;
        var toRight = (leftToRight + 1) / 2;
        var toLeft = 1 - toRight;
        var hasB = opts.hasB;
        var r = opts.r;
        var overhead = opts.overhead;
        var textWidth = textBB.width;
        var textHeight = textBB.height;
        var lx = Math.abs(x1 - x0);
        var ly = Math.abs(y1 - y0);
        var textpad = lx > 2 * TEXTPAD && ly > 2 * TEXTPAD ? TEXTPAD : 0;
        lx -= 2 * textpad;
        ly -= 2 * textpad;
        var rotate = getRotateFromAngle(angle);
        if (angle === "auto" && !(textWidth <= lx && textHeight <= ly) && (textWidth > lx || textHeight > ly) && (!(textWidth > ly || textHeight > lx) || textWidth < textHeight !== lx < ly)) {
          rotate += 90;
        }
        var t = getRotatedTextSize(textBB, rotate);
        var scale, padForRounding;
        if (r && r - overhead > TEXTPAD) {
          var scaleAndPad = scaleTextForRoundedBar(x0, x1, y0, y1, t, r, overhead, isHorizontal, hasB);
          scale = scaleAndPad.scale;
          padForRounding = scaleAndPad.pad;
        } else {
          scale = 1;
          if (constrained) {
            scale = Math.min(
              1,
              lx / t.x,
              ly / t.y
            );
          }
          padForRounding = 0;
        }
        var textX = textBB.left * toLeft + textBB.right * toRight;
        var textY = (textBB.top + textBB.bottom) / 2;
        var targetX = (x0 + TEXTPAD) * toLeft + (x1 - TEXTPAD) * toRight;
        var targetY = (y0 + y1) / 2;
        var anchorX = 0;
        var anchorY = 0;
        if (isStart || isEnd) {
          var extrapad = (isHorizontal ? t.x : t.y) / 2;
          if (r && (isEnd || hasB)) {
            textpad += padForRounding;
          }
          var dir = isHorizontal ? dirSign(x0, x1) : dirSign(y0, y1);
          if (isHorizontal) {
            if (isStart) {
              targetX = x0 + dir * textpad;
              anchorX = -dir * extrapad;
            } else {
              targetX = x1 - dir * textpad;
              anchorX = dir * extrapad;
            }
          } else {
            if (isStart) {
              targetY = y0 + dir * textpad;
              anchorY = -dir * extrapad;
            } else {
              targetY = y1 - dir * textpad;
              anchorY = dir * extrapad;
            }
          }
        }
        return {
          textX,
          textY,
          targetX,
          targetY,
          anchorX,
          anchorY,
          scale,
          rotate
        };
      }
      function scaleTextForRoundedBar(x0, x1, y0, y1, t, r, overhead, isHorizontal, hasB) {
        var barWidth = Math.max(0, Math.abs(x1 - x0) - 2 * TEXTPAD);
        var barHeight = Math.max(0, Math.abs(y1 - y0) - 2 * TEXTPAD);
        var R = r - TEXTPAD;
        var clippedR = overhead ? R - Math.sqrt(R * R - (R - overhead) * (R - overhead)) : R;
        var rX = hasB ? R * 2 : isHorizontal ? R - overhead : 2 * clippedR;
        var rY = hasB ? R * 2 : isHorizontal ? 2 * clippedR : R - overhead;
        var a, b, c;
        var scale, pad;
        if (t.y / t.x >= barHeight / (barWidth - rX)) {
          scale = barHeight / t.y;
        } else if (t.y / t.x <= (barHeight - rY) / barWidth) {
          scale = barWidth / t.x;
        } else if (!hasB && isHorizontal) {
          a = t.x * t.x + t.y * t.y / 4;
          b = -2 * t.x * (barWidth - R) - t.y * (barHeight / 2 - R);
          c = (barWidth - R) * (barWidth - R) + (barHeight / 2 - R) * (barHeight / 2 - R) - R * R;
          scale = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
        } else if (!hasB) {
          a = t.x * t.x / 4 + t.y * t.y;
          b = -t.x * (barWidth / 2 - R) - 2 * t.y * (barHeight - R);
          c = (barWidth / 2 - R) * (barWidth / 2 - R) + (barHeight - R) * (barHeight - R) - R * R;
          scale = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
        } else {
          a = (t.x * t.x + t.y * t.y) / 4;
          b = -t.x * (barWidth / 2 - R) - t.y * (barHeight / 2 - R);
          c = (barWidth / 2 - R) * (barWidth / 2 - R) + (barHeight / 2 - R) * (barHeight / 2 - R) - R * R;
          scale = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
        }
        scale = Math.min(1, scale);
        if (isHorizontal) {
          pad = Math.max(0, R - Math.sqrt(Math.max(0, R * R - (R - (barHeight - t.y * scale) / 2) * (R - (barHeight - t.y * scale) / 2))) - overhead);
        } else {
          pad = Math.max(0, R - Math.sqrt(Math.max(0, R * R - (R - (barWidth - t.x * scale) / 2) * (R - (barWidth - t.x * scale) / 2))) - overhead);
        }
        return { scale, pad };
      }
      function toMoveOutsideBar(x0, x1, y0, y1, textBB, opts) {
        var isHorizontal = !!opts.isHorizontal;
        var constrained = !!opts.constrained;
        var angle = opts.angle || 0;
        var textWidth = textBB.width;
        var textHeight = textBB.height;
        var lx = Math.abs(x1 - x0);
        var ly = Math.abs(y1 - y0);
        var textpad;
        if (isHorizontal) {
          textpad = ly > 2 * TEXTPAD ? TEXTPAD : 0;
        } else {
          textpad = lx > 2 * TEXTPAD ? TEXTPAD : 0;
        }
        var scale = 1;
        if (constrained) {
          scale = isHorizontal ? Math.min(1, ly / textHeight) : Math.min(1, lx / textWidth);
        }
        var rotate = getRotateFromAngle(angle);
        var t = getRotatedTextSize(textBB, rotate);
        var extrapad = (isHorizontal ? t.x : t.y) / 2;
        var textX = (textBB.left + textBB.right) / 2;
        var textY = (textBB.top + textBB.bottom) / 2;
        var targetX = (x0 + x1) / 2;
        var targetY = (y0 + y1) / 2;
        var anchorX = 0;
        var anchorY = 0;
        var dir = isHorizontal ? dirSign(x1, x0) : dirSign(y0, y1);
        if (isHorizontal) {
          targetX = x1 - dir * textpad;
          anchorX = dir * extrapad;
        } else {
          targetY = y1 + dir * textpad;
          anchorY = -dir * extrapad;
        }
        return {
          textX,
          textY,
          targetX,
          targetY,
          anchorX,
          anchorY,
          scale,
          rotate
        };
      }
      function getText(fullLayout, cd, index, xa, ya) {
        var trace = cd[0].trace;
        var texttemplate = trace.texttemplate;
        var value;
        if (texttemplate) {
          value = calcTexttemplate(fullLayout, cd, index, xa, ya);
        } else if (trace.textinfo) {
          value = calcTextinfo(cd, index, xa, ya);
        } else {
          value = helpers.getValue(trace.text, index);
        }
        return helpers.coerceString(attributeText, value);
      }
      function getTextPosition(trace, index) {
        var value = helpers.getValue(trace.textposition, index);
        return helpers.coerceEnumerated(attributeTextPosition, value);
      }
      function calcTexttemplate(fullLayout, cd, index, xa, ya) {
        var trace = cd[0].trace;
        var texttemplate = Lib.castOption(trace, index, "texttemplate");
        if (!texttemplate) return "";
        var isHistogram = trace.type === "histogram";
        var isWaterfall = trace.type === "waterfall";
        var isFunnel = trace.type === "funnel";
        var isHorizontal = trace.orientation === "h";
        var pLetter, pAxis;
        var vLetter, vAxis;
        if (isHorizontal) {
          pLetter = "y";
          pAxis = ya;
          vLetter = "x";
          vAxis = xa;
        } else {
          pLetter = "x";
          pAxis = xa;
          vLetter = "y";
          vAxis = ya;
        }
        function formatLabel(u) {
          return tickText(pAxis, pAxis.c2l(u), true).text;
        }
        function formatNumber(v) {
          return tickText(vAxis, vAxis.c2l(v), true).text;
        }
        var cdi = cd[index];
        var obj = {};
        obj.label = cdi.p;
        obj.labelLabel = obj[pLetter + "Label"] = formatLabel(cdi.p);
        var tx = Lib.castOption(trace, cdi.i, "text");
        if (tx === 0 || tx) obj.text = tx;
        obj.value = cdi.s;
        obj.valueLabel = obj[vLetter + "Label"] = formatNumber(cdi.s);
        var pt = {};
        appendArrayPointValue(pt, trace, cdi.i);
        if (isHistogram || pt.x === void 0) pt.x = isHorizontal ? obj.value : obj.label;
        if (isHistogram || pt.y === void 0) pt.y = isHorizontal ? obj.label : obj.value;
        if (isHistogram || pt.xLabel === void 0) pt.xLabel = isHorizontal ? obj.valueLabel : obj.labelLabel;
        if (isHistogram || pt.yLabel === void 0) pt.yLabel = isHorizontal ? obj.labelLabel : obj.valueLabel;
        if (isWaterfall) {
          obj.delta = +cdi.rawS || cdi.s;
          obj.deltaLabel = formatNumber(obj.delta);
          obj.final = cdi.v;
          obj.finalLabel = formatNumber(obj.final);
          obj.initial = obj.final - obj.delta;
          obj.initialLabel = formatNumber(obj.initial);
        }
        if (isFunnel) {
          obj.value = cdi.s;
          obj.valueLabel = formatNumber(obj.value);
          obj.percentInitial = cdi.begR;
          obj.percentInitialLabel = Lib.formatPercent(cdi.begR);
          obj.percentPrevious = cdi.difR;
          obj.percentPreviousLabel = Lib.formatPercent(cdi.difR);
          obj.percentTotal = cdi.sumR;
          obj.percenTotalLabel = Lib.formatPercent(cdi.sumR);
        }
        var customdata = Lib.castOption(trace, cdi.i, "customdata");
        if (customdata) obj.customdata = customdata;
        return Lib.texttemplateString(texttemplate, obj, fullLayout._d3locale, pt, obj, trace._meta || {});
      }
      function calcTextinfo(cd, index, xa, ya) {
        var trace = cd[0].trace;
        var isHorizontal = trace.orientation === "h";
        var isWaterfall = trace.type === "waterfall";
        var isFunnel = trace.type === "funnel";
        function formatLabel(u) {
          var pAxis = isHorizontal ? ya : xa;
          return tickText(pAxis, u, true).text;
        }
        function formatNumber(v) {
          var sAxis = isHorizontal ? xa : ya;
          return tickText(sAxis, +v, true).text;
        }
        var textinfo = trace.textinfo;
        var cdi = cd[index];
        var parts = textinfo.split("+");
        var text = [];
        var tx;
        var hasFlag = function(flag) {
          return parts.indexOf(flag) !== -1;
        };
        if (hasFlag("label")) {
          text.push(formatLabel(cd[index].p));
        }
        if (hasFlag("text")) {
          tx = Lib.castOption(trace, cdi.i, "text");
          if (tx === 0 || tx) text.push(tx);
        }
        if (isWaterfall) {
          var delta = +cdi.rawS || cdi.s;
          var final = cdi.v;
          var initial = final - delta;
          if (hasFlag("initial")) text.push(formatNumber(initial));
          if (hasFlag("delta")) text.push(formatNumber(delta));
          if (hasFlag("final")) text.push(formatNumber(final));
        }
        if (isFunnel) {
          if (hasFlag("value")) text.push(formatNumber(cdi.s));
          var nPercent = 0;
          if (hasFlag("percent initial")) nPercent++;
          if (hasFlag("percent previous")) nPercent++;
          if (hasFlag("percent total")) nPercent++;
          var hasMultiplePercents = nPercent > 1;
          if (hasFlag("percent initial")) {
            tx = Lib.formatPercent(cdi.begR);
            if (hasMultiplePercents) tx += " of initial";
            text.push(tx);
          }
          if (hasFlag("percent previous")) {
            tx = Lib.formatPercent(cdi.difR);
            if (hasMultiplePercents) tx += " of previous";
            text.push(tx);
          }
          if (hasFlag("percent total")) {
            tx = Lib.formatPercent(cdi.sumR);
            if (hasMultiplePercents) tx += " of total";
            text.push(tx);
          }
        }
        return text.join("<br>");
      }
      module.exports = {
        plot,
        toMoveInsideBar
      };
    }
  });

  // src/traces/bar/hover.js
  var require_hover3 = __commonJS({
    "src/traces/bar/hover.js"(exports, module) {
      "use strict";
      var Fx = require_fx();
      var Registry = require_registry();
      var Color = require_color();
      var fillText = require_lib().fillText;
      var getLineWidth = require_helpers12().getLineWidth;
      var hoverLabelText = require_axes().hoverLabelText;
      var BADNUM = require_numerical().BADNUM;
      function hoverPoints(pointData, xval, yval, hovermode, opts) {
        var barPointData = hoverOnBars(pointData, xval, yval, hovermode, opts);
        if (barPointData) {
          var cd = barPointData.cd;
          var trace = cd[0].trace;
          var di = cd[barPointData.index];
          barPointData.color = getTraceColor(trace, di);
          Registry.getComponentMethod("errorbars", "hoverInfo")(di, trace, barPointData);
          return [barPointData];
        }
      }
      function hoverOnBars(pointData, xval, yval, hovermode, opts) {
        var cd = pointData.cd;
        var trace = cd[0].trace;
        var t = cd[0].t;
        var isClosest = hovermode === "closest";
        var isWaterfall = trace.type === "waterfall";
        var maxHoverDistance = pointData.maxHoverDistance;
        var maxSpikeDistance = pointData.maxSpikeDistance;
        var posVal, sizeVal, posLetter, sizeLetter, dx, dy, pRangeCalc;
        if (trace.orientation === "h") {
          posVal = yval;
          sizeVal = xval;
          posLetter = "y";
          sizeLetter = "x";
          dx = sizeFn;
          dy = positionFn;
        } else {
          posVal = xval;
          sizeVal = yval;
          posLetter = "x";
          sizeLetter = "y";
          dy = sizeFn;
          dx = positionFn;
        }
        var period = trace[posLetter + "period"];
        var isClosestOrPeriod = isClosest || period;
        function thisBarMinPos(di2) {
          return thisBarExtPos(di2, -1);
        }
        function thisBarMaxPos(di2) {
          return thisBarExtPos(di2, 1);
        }
        function thisBarExtPos(di2, sgn) {
          var w = di2.w;
          return di2[posLetter] + sgn * w / 2;
        }
        function periodLength(di2) {
          return di2[posLetter + "End"] - di2[posLetter + "Start"];
        }
        var minPos = isClosest ? thisBarMinPos : period ? function(di2) {
          return di2.p - periodLength(di2) / 2;
        } : function(di2) {
          return Math.min(thisBarMinPos(di2), di2.p - t.bardelta / 2);
        };
        var maxPos = isClosest ? thisBarMaxPos : period ? function(di2) {
          return di2.p + periodLength(di2) / 2;
        } : function(di2) {
          return Math.max(thisBarMaxPos(di2), di2.p + t.bardelta / 2);
        };
        function inbox(_minPos, _maxPos, maxDistance) {
          if (opts.finiteRange) maxDistance = 0;
          return Fx.inbox(
            _minPos - posVal,
            _maxPos - posVal,
            maxDistance + Math.min(1, Math.abs(_maxPos - _minPos) / pRangeCalc) - 1
          );
        }
        function positionFn(di2) {
          return inbox(minPos(di2), maxPos(di2), maxHoverDistance);
        }
        function thisBarPositionFn(di2) {
          return inbox(thisBarMinPos(di2), thisBarMaxPos(di2), maxSpikeDistance);
        }
        function getSize(di2) {
          var s = di2[sizeLetter];
          if (isWaterfall) {
            var rawS = Math.abs(di2.rawS) || 0;
            if (sizeVal > 0) {
              s += rawS;
            } else if (sizeVal < 0) {
              s -= rawS;
            }
          }
          return s;
        }
        function sizeFn(di2) {
          var v = sizeVal;
          var b = di2.b;
          var s = getSize(di2);
          return Fx.inbox(b - v, s - v, maxHoverDistance + (s - v) / (s - b) - 1);
        }
        function thisBarSizeFn(di2) {
          var v = sizeVal;
          var b = di2.b;
          var s = getSize(di2);
          return Fx.inbox(b - v, s - v, maxSpikeDistance + (s - v) / (s - b) - 1);
        }
        var pa = pointData[posLetter + "a"];
        var sa = pointData[sizeLetter + "a"];
        pRangeCalc = Math.abs(pa.r2c(pa.range[1]) - pa.r2c(pa.range[0]));
        function dxy(di2) {
          return (dx(di2) + dy(di2)) / 2;
        }
        var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);
        Fx.getClosest(cd, distfn, pointData);
        if (pointData.index === false) return;
        if (cd[pointData.index].p === BADNUM) return;
        if (!isClosestOrPeriod) {
          minPos = function(di2) {
            return Math.min(thisBarMinPos(di2), di2.p - t.bargroupwidth / 2);
          };
          maxPos = function(di2) {
            return Math.max(thisBarMaxPos(di2), di2.p + t.bargroupwidth / 2);
          };
        }
        var index = pointData.index;
        var di = cd[index];
        var size = trace.base ? di.b + di.s : di.s;
        pointData[sizeLetter + "0"] = pointData[sizeLetter + "1"] = sa.c2p(di[sizeLetter], true);
        pointData[sizeLetter + "LabelVal"] = size;
        var extent = t.extents[t.extents.round(di.p)];
        pointData[posLetter + "0"] = pa.c2p(isClosest ? minPos(di) : extent[0], true);
        pointData[posLetter + "1"] = pa.c2p(isClosest ? maxPos(di) : extent[1], true);
        var hasPeriod = di.orig_p !== void 0;
        pointData[posLetter + "LabelVal"] = hasPeriod ? di.orig_p : di.p;
        pointData.labelLabel = hoverLabelText(pa, pointData[posLetter + "LabelVal"], trace[posLetter + "hoverformat"]);
        pointData.valueLabel = hoverLabelText(sa, pointData[sizeLetter + "LabelVal"], trace[sizeLetter + "hoverformat"]);
        pointData.baseLabel = hoverLabelText(sa, di.b, trace[sizeLetter + "hoverformat"]);
        pointData.spikeDistance = (thisBarSizeFn(di) + thisBarPositionFn(di)) / 2;
        pointData[posLetter + "Spike"] = pa.c2p(di.p, true);
        fillText(di, trace, pointData);
        pointData.hovertemplate = trace.hovertemplate;
        return pointData;
      }
      function getTraceColor(trace, di) {
        var mc = di.mcc || trace.marker.color;
        var mlc = di.mlcc || trace.marker.line.color;
        var mlw = getLineWidth(trace, di);
        if (Color.opacity(mc)) return mc;
        else if (Color.opacity(mlc) && mlw) return mlc;
      }
      module.exports = {
        hoverPoints,
        hoverOnBars,
        getTraceColor
      };
    }
  });

  // src/traces/bar/event_data.js
  var require_event_data = __commonJS({
    "src/traces/bar/event_data.js"(exports, module) {
      "use strict";
      module.exports = function eventData(out, pt, trace) {
        out.x = "xVal" in pt ? pt.xVal : pt.x;
        out.y = "yVal" in pt ? pt.yVal : pt.y;
        if (pt.xa) out.xaxis = pt.xa;
        if (pt.ya) out.yaxis = pt.ya;
        if (trace.orientation === "h") {
          out.label = out.y;
          out.value = out.x;
        } else {
          out.label = out.x;
          out.value = out.y;
        }
        return out;
      };
    }
  });

  // src/traces/bar/select.js
  var require_select3 = __commonJS({
    "src/traces/bar/select.js"(exports, module) {
      "use strict";
      module.exports = function selectPoints(searchInfo, selectionTester) {
        var cd = searchInfo.cd;
        var xa = searchInfo.xaxis;
        var ya = searchInfo.yaxis;
        var trace = cd[0].trace;
        var isFunnel = trace.type === "funnel";
        var isHorizontal = trace.orientation === "h";
        var selection = [];
        var i;
        if (selectionTester === false) {
          for (i = 0; i < cd.length; i++) {
            cd[i].selected = 0;
          }
        } else {
          for (i = 0; i < cd.length; i++) {
            var di = cd[i];
            var ct = "ct" in di ? di.ct : getCentroid(di, xa, ya, isHorizontal, isFunnel);
            if (selectionTester.contains(ct, false, i, searchInfo)) {
              selection.push({
                pointNumber: i,
                x: xa.c2d(di.x),
                y: ya.c2d(di.y)
              });
              di.selected = 1;
            } else {
              di.selected = 0;
            }
          }
        }
        return selection;
      };
      function getCentroid(d, xa, ya, isHorizontal, isFunnel) {
        var x0 = xa.c2p(isHorizontal ? d.s0 : d.p0, true);
        var x1 = xa.c2p(isHorizontal ? d.s1 : d.p1, true);
        var y0 = ya.c2p(isHorizontal ? d.p0 : d.s0, true);
        var y1 = ya.c2p(isHorizontal ? d.p1 : d.s1, true);
        if (isFunnel) {
          return [(x0 + x1) / 2, (y0 + y1) / 2];
        } else {
          if (isHorizontal) {
            return [x1, (y0 + y1) / 2];
          } else {
            return [(x0 + x1) / 2, y1];
          }
        }
      }
    }
  });

  // src/traces/bar/index.js
  var require_bar = __commonJS({
    "src/traces/bar/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes23(),
        layoutAttributes: require_layout_attributes6(),
        supplyDefaults: require_defaults19().supplyDefaults,
        crossTraceDefaults: require_defaults19().crossTraceDefaults,
        supplyLayoutDefaults: require_layout_defaults5(),
        calc: require_calc5(),
        crossTraceCalc: require_cross_trace_calc().crossTraceCalc,
        colorbar: require_marker_colorbar(),
        arraysToCalcdata: require_arrays_to_calcdata2(),
        plot: require_plot3().plot,
        style: require_style4().style,
        styleOnSelect: require_style4().styleOnSelect,
        hoverPoints: require_hover3().hoverPoints,
        eventData: require_event_data(),
        selectPoints: require_select3(),
        moduleType: "trace",
        name: "bar",
        basePlotModule: require_cartesian(),
        categories: ["bar-like", "cartesian", "svg", "bar", "oriented", "errorBarsOK", "showLegend", "zoomScale"],
        animatable: true,
        meta: {}
      };
    }
  });

  // lib/bar.js
  var require_bar2 = __commonJS({
    "lib/bar.js"(exports, module) {
      "use strict";
      module.exports = require_bar();
    }
  });

  // src/traces/box/attributes.js
  var require_attributes24 = __commonJS({
    "src/traces/box/attributes.js"(exports, module) {
      "use strict";
      var makeFillcolorAttr = require_fillcolor_attribute();
      var scatterAttrs = require_attributes12();
      var barAttrs = require_attributes23();
      var colorAttrs = require_attributes3();
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var extendFlat = require_extend().extendFlat;
      var scatterMarkerAttrs = scatterAttrs.marker;
      var scatterMarkerLineAttrs = scatterMarkerAttrs.line;
      module.exports = {
        y: {
          valType: "data_array",
          editType: "calc+clearAxisTypes"
        },
        x: {
          valType: "data_array",
          editType: "calc+clearAxisTypes"
        },
        x0: {
          valType: "any",
          editType: "calc+clearAxisTypes"
        },
        y0: {
          valType: "any",
          editType: "calc+clearAxisTypes"
        },
        dx: {
          valType: "number",
          editType: "calc"
        },
        dy: {
          valType: "number",
          editType: "calc"
        },
        xperiod: scatterAttrs.xperiod,
        yperiod: scatterAttrs.yperiod,
        xperiod0: scatterAttrs.xperiod0,
        yperiod0: scatterAttrs.yperiod0,
        xperiodalignment: scatterAttrs.xperiodalignment,
        yperiodalignment: scatterAttrs.yperiodalignment,
        xhoverformat: axisHoverFormat("x"),
        yhoverformat: axisHoverFormat("y"),
        name: {
          valType: "string",
          editType: "calc+clearAxisTypes"
        },
        q1: {
          valType: "data_array",
          editType: "calc+clearAxisTypes"
        },
        median: {
          valType: "data_array",
          editType: "calc+clearAxisTypes"
        },
        q3: {
          valType: "data_array",
          editType: "calc+clearAxisTypes"
        },
        lowerfence: {
          valType: "data_array",
          editType: "calc"
        },
        upperfence: {
          valType: "data_array",
          editType: "calc"
        },
        notched: {
          valType: "boolean",
          editType: "calc"
        },
        notchwidth: {
          valType: "number",
          min: 0,
          max: 0.5,
          dflt: 0.25,
          editType: "calc"
        },
        notchspan: {
          valType: "data_array",
          editType: "calc"
        },
        // TODO
        // maybe add
        // - loweroutlierbound / upperoutlierbound
        // - lowersuspectedoutlierbound / uppersuspectedoutlierbound
        boxpoints: {
          valType: "enumerated",
          values: ["all", "outliers", "suspectedoutliers", false],
          editType: "calc"
        },
        jitter: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "calc"
        },
        pointpos: {
          valType: "number",
          min: -2,
          max: 2,
          editType: "calc"
        },
        sdmultiple: {
          valType: "number",
          min: 0,
          editType: "calc",
          dflt: 1
        },
        sizemode: {
          valType: "enumerated",
          values: ["quartiles", "sd"],
          editType: "calc",
          dflt: "quartiles"
        },
        boxmean: {
          valType: "enumerated",
          values: [true, "sd", false],
          editType: "calc"
        },
        mean: {
          valType: "data_array",
          editType: "calc"
        },
        sd: {
          valType: "data_array",
          editType: "calc"
        },
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          editType: "calc+clearAxisTypes"
        },
        quartilemethod: {
          valType: "enumerated",
          values: ["linear", "exclusive", "inclusive"],
          dflt: "linear",
          editType: "calc"
        },
        width: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "calc"
        },
        marker: {
          outliercolor: {
            valType: "color",
            dflt: "rgba(0, 0, 0, 0)",
            editType: "style"
          },
          symbol: extendFlat(
            {},
            scatterMarkerAttrs.symbol,
            { arrayOk: false, editType: "plot" }
          ),
          opacity: extendFlat(
            {},
            scatterMarkerAttrs.opacity,
            { arrayOk: false, dflt: 1, editType: "style" }
          ),
          angle: extendFlat(
            {},
            scatterMarkerAttrs.angle,
            { arrayOk: false, editType: "calc" }
          ),
          size: extendFlat(
            {},
            scatterMarkerAttrs.size,
            { arrayOk: false, editType: "calc" }
          ),
          color: extendFlat(
            {},
            scatterMarkerAttrs.color,
            { arrayOk: false, editType: "style" }
          ),
          line: {
            color: extendFlat(
              {},
              scatterMarkerLineAttrs.color,
              { arrayOk: false, dflt: colorAttrs.defaultLine, editType: "style" }
            ),
            width: extendFlat(
              {},
              scatterMarkerLineAttrs.width,
              { arrayOk: false, dflt: 0, editType: "style" }
            ),
            outliercolor: {
              valType: "color",
              editType: "style"
            },
            outlierwidth: {
              valType: "number",
              min: 0,
              dflt: 1,
              editType: "style"
            },
            editType: "style"
          },
          editType: "plot"
        },
        line: {
          color: {
            valType: "color",
            editType: "style"
          },
          width: {
            valType: "number",
            min: 0,
            dflt: 2,
            editType: "style"
          },
          editType: "plot"
        },
        fillcolor: makeFillcolorAttr(),
        whiskerwidth: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0.5,
          editType: "calc"
        },
        showwhiskers: {
          valType: "boolean",
          editType: "calc"
        },
        offsetgroup: barAttrs.offsetgroup,
        alignmentgroup: barAttrs.alignmentgroup,
        selected: {
          marker: scatterAttrs.selected.marker,
          editType: "style"
        },
        unselected: {
          marker: scatterAttrs.unselected.marker,
          editType: "style"
        },
        text: extendFlat({}, scatterAttrs.text, {}),
        hovertext: extendFlat({}, scatterAttrs.hovertext, {}),
        hovertemplate: hovertemplateAttrs({}),
        hoveron: {
          valType: "flaglist",
          flags: ["boxes", "points"],
          dflt: "boxes+points",
          editType: "style"
        },
        zorder: scatterAttrs.zorder
      };
    }
  });

  // src/traces/box/layout_attributes.js
  var require_layout_attributes7 = __commonJS({
    "src/traces/box/layout_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        boxmode: {
          valType: "enumerated",
          values: ["group", "overlay"],
          dflt: "overlay",
          editType: "calc"
        },
        boxgap: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0.3,
          editType: "calc"
        },
        boxgroupgap: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0.3,
          editType: "calc"
        }
      };
    }
  });

  // src/traces/box/defaults.js
  var require_defaults20 = __commonJS({
    "src/traces/box/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      var Color = require_color();
      var handlePeriodDefaults = require_period_defaults();
      var handleGroupingDefaults = require_grouping_defaults();
      var autoType = require_axis_autotype();
      var attributes = require_attributes24();
      function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        handleSampleDefaults(traceIn, traceOut, coerce, layout);
        if (traceOut.visible === false) return;
        handlePeriodDefaults(traceIn, traceOut, layout, coerce);
        coerce("xhoverformat");
        coerce("yhoverformat");
        var hasPreCompStats = traceOut._hasPreCompStats;
        if (hasPreCompStats) {
          coerce("lowerfence");
          coerce("upperfence");
        }
        coerce("line.color", (traceIn.marker || {}).color || defaultColor);
        coerce("line.width");
        coerce("fillcolor", Color.addOpacity(traceOut.line.color, 0.5));
        var boxmeanDflt = false;
        if (hasPreCompStats) {
          var mean = coerce("mean");
          var sd = coerce("sd");
          if (mean && mean.length) {
            boxmeanDflt = true;
            if (sd && sd.length) boxmeanDflt = "sd";
          }
        }
        coerce("whiskerwidth");
        var sizemode = coerce("sizemode");
        var boxmean;
        if (sizemode === "quartiles") {
          boxmean = coerce("boxmean", boxmeanDflt);
        }
        coerce("showwhiskers", sizemode === "quartiles");
        if (sizemode === "sd" || boxmean === "sd") {
          coerce("sdmultiple");
        }
        coerce("width");
        coerce("quartilemethod");
        var notchedDflt = false;
        if (hasPreCompStats) {
          var notchspan = coerce("notchspan");
          if (notchspan && notchspan.length) {
            notchedDflt = true;
          }
        } else if (Lib.validate(traceIn.notchwidth, attributes.notchwidth)) {
          notchedDflt = true;
        }
        var notched = coerce("notched", notchedDflt);
        if (notched) coerce("notchwidth");
        handlePointsDefaults(traceIn, traceOut, coerce, { prefix: "box" });
        coerce("zorder");
      }
      function handleSampleDefaults(traceIn, traceOut, coerce, layout) {
        function getDims(arr) {
          var dims = 0;
          if (arr && arr.length) {
            dims += 1;
            if (Lib.isArrayOrTypedArray(arr[0]) && arr[0].length) {
              dims += 1;
            }
          }
          return dims;
        }
        function valid(astr) {
          return Lib.validate(traceIn[astr], attributes[astr]);
        }
        var y = coerce("y");
        var x = coerce("x");
        var sLen;
        if (traceOut.type === "box") {
          var q1 = coerce("q1");
          var median = coerce("median");
          var q3 = coerce("q3");
          traceOut._hasPreCompStats = q1 && q1.length && median && median.length && q3 && q3.length;
          sLen = Math.min(
            Lib.minRowLength(q1),
            Lib.minRowLength(median),
            Lib.minRowLength(q3)
          );
        }
        var yDims = getDims(y);
        var xDims = getDims(x);
        var yLen = yDims && Lib.minRowLength(y);
        var xLen = xDims && Lib.minRowLength(x);
        var calendar = layout.calendar;
        var opts = {
          autotypenumbers: layout.autotypenumbers
        };
        var defaultOrientation, len;
        if (traceOut._hasPreCompStats) {
          switch (String(xDims) + String(yDims)) {
            // no x / no y
            case "00":
              var setInX = valid("x0") || valid("dx");
              var setInY = valid("y0") || valid("dy");
              if (setInY && !setInX) {
                defaultOrientation = "h";
              } else {
                defaultOrientation = "v";
              }
              len = sLen;
              break;
            // just x
            case "10":
              defaultOrientation = "v";
              len = Math.min(sLen, xLen);
              break;
            case "20":
              defaultOrientation = "h";
              len = Math.min(sLen, x.length);
              break;
            // just y
            case "01":
              defaultOrientation = "h";
              len = Math.min(sLen, yLen);
              break;
            case "02":
              defaultOrientation = "v";
              len = Math.min(sLen, y.length);
              break;
            // both
            case "12":
              defaultOrientation = "v";
              len = Math.min(sLen, xLen, y.length);
              break;
            case "21":
              defaultOrientation = "h";
              len = Math.min(sLen, x.length, yLen);
              break;
            case "11":
              len = 0;
              break;
            case "22":
              var hasCategories = false;
              var i;
              for (i = 0; i < x.length; i++) {
                if (autoType(x[i], calendar, opts) === "category") {
                  hasCategories = true;
                  break;
                }
              }
              if (hasCategories) {
                defaultOrientation = "v";
                len = Math.min(sLen, xLen, y.length);
              } else {
                for (i = 0; i < y.length; i++) {
                  if (autoType(y[i], calendar, opts) === "category") {
                    hasCategories = true;
                    break;
                  }
                }
                if (hasCategories) {
                  defaultOrientation = "h";
                  len = Math.min(sLen, x.length, yLen);
                } else {
                  defaultOrientation = "v";
                  len = Math.min(sLen, xLen, y.length);
                }
              }
              break;
          }
        } else if (yDims > 0) {
          defaultOrientation = "v";
          if (xDims > 0) {
            len = Math.min(xLen, yLen);
          } else {
            len = Math.min(yLen);
          }
        } else if (xDims > 0) {
          defaultOrientation = "h";
          len = Math.min(xLen);
        } else {
          len = 0;
        }
        if (!len) {
          traceOut.visible = false;
          return;
        }
        traceOut._length = len;
        var orientation = coerce("orientation", defaultOrientation);
        if (traceOut._hasPreCompStats) {
          if (orientation === "v" && xDims === 0) {
            coerce("x0", 0);
            coerce("dx", 1);
          } else if (orientation === "h" && yDims === 0) {
            coerce("y0", 0);
            coerce("dy", 1);
          }
        } else {
          if (orientation === "v" && xDims === 0) {
            coerce("x0");
          } else if (orientation === "h" && yDims === 0) {
            coerce("y0");
          }
        }
        var handleCalendarDefaults = Registry.getComponentMethod("calendars", "handleTraceDefaults");
        handleCalendarDefaults(traceIn, traceOut, ["x", "y"], layout);
      }
      function handlePointsDefaults(traceIn, traceOut, coerce, opts) {
        var prefix = opts.prefix;
        var outlierColorDflt = Lib.coerce2(traceIn, traceOut, attributes, "marker.outliercolor");
        var lineoutliercolor = coerce("marker.line.outliercolor");
        var modeDflt = "outliers";
        if (traceOut._hasPreCompStats) {
          modeDflt = "all";
        } else if (outlierColorDflt || lineoutliercolor) {
          modeDflt = "suspectedoutliers";
        }
        var mode = coerce(prefix + "points", modeDflt);
        if (mode) {
          coerce("jitter", mode === "all" ? 0.3 : 0);
          coerce("pointpos", mode === "all" ? -1.5 : 0);
          coerce("marker.symbol");
          coerce("marker.opacity");
          coerce("marker.size");
          coerce("marker.angle");
          coerce("marker.color", traceOut.line.color);
          coerce("marker.line.color");
          coerce("marker.line.width");
          if (mode === "suspectedoutliers") {
            coerce("marker.line.outliercolor", traceOut.marker.color);
            coerce("marker.line.outlierwidth");
          }
          coerce("selected.marker.color");
          coerce("unselected.marker.color");
          coerce("selected.marker.size");
          coerce("unselected.marker.size");
          coerce("text");
          coerce("hovertext");
        } else {
          delete traceOut.marker;
        }
        var hoveron = coerce("hoveron");
        if (hoveron === "all" || hoveron.indexOf("points") !== -1) {
          coerce("hovertemplate");
        }
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
      }
      function crossTraceDefaults(fullData, fullLayout) {
        var traceIn, traceOut;
        function coerce(attr) {
          return Lib.coerce(traceOut._input, traceOut, attributes, attr);
        }
        for (var i = 0; i < fullData.length; i++) {
          traceOut = fullData[i];
          var traceType = traceOut.type;
          if (traceType === "box" || traceType === "violin") {
            traceIn = traceOut._input;
            var mode = fullLayout[traceType + "mode"];
            if (mode === "group") {
              handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce, mode);
            }
          }
        }
      }
      module.exports = {
        supplyDefaults,
        crossTraceDefaults,
        handleSampleDefaults,
        handlePointsDefaults
      };
    }
  });

  // src/traces/box/layout_defaults.js
  var require_layout_defaults6 = __commonJS({
    "src/traces/box/layout_defaults.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes7();
      function _supply(layoutIn, layoutOut, fullData, coerce, traceType) {
        var category = traceType + "Layout";
        var hasTraceType = false;
        for (var i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          if (Registry.traceIs(trace, category)) {
            hasTraceType = true;
            break;
          }
        }
        if (!hasTraceType) return;
        coerce(traceType + "mode");
        coerce(traceType + "gap");
        coerce(traceType + "groupgap");
      }
      function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        _supply(layoutIn, layoutOut, fullData, coerce, "box");
      }
      module.exports = {
        supplyLayoutDefaults,
        _supply
      };
    }
  });

  // src/traces/box/calc.js
  var require_calc6 = __commonJS({
    "src/traces/box/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Axes = require_axes();
      var alignPeriod = require_align_period();
      var Lib = require_lib();
      var BADNUM = require_numerical().BADNUM;
      var _ = Lib._;
      module.exports = function calc(gd, trace) {
        var fullLayout = gd._fullLayout;
        var xa = Axes.getFromId(gd, trace.xaxis || "x");
        var ya = Axes.getFromId(gd, trace.yaxis || "y");
        var cd = [];
        var numKey = trace.type === "violin" ? "_numViolins" : "_numBoxes";
        var i, j;
        var valAxis, valLetter;
        var posAxis, posLetter;
        var hasPeriod;
        if (trace.orientation === "h") {
          valAxis = xa;
          valLetter = "x";
          posAxis = ya;
          posLetter = "y";
          hasPeriod = !!trace.yperiodalignment;
        } else {
          valAxis = ya;
          valLetter = "y";
          posAxis = xa;
          posLetter = "x";
          hasPeriod = !!trace.xperiodalignment;
        }
        var allPosArrays = getPosArrays(trace, posLetter, posAxis, fullLayout[numKey]);
        var posArray = allPosArrays[0];
        var origPos = allPosArrays[1];
        var dv = Lib.distinctVals(posArray, posAxis);
        var posDistinct = dv.vals;
        var dPos = dv.minDiff / 2;
        var cdi;
        var pts;
        var boxVals;
        var N;
        var pt;
        var v;
        var ptFilterFn = (trace.boxpoints || trace.points) === "all" ? Lib.identity : function(pt2) {
          return pt2.v < cdi.lf || pt2.v > cdi.uf;
        };
        if (trace._hasPreCompStats) {
          var valArrayRaw = trace[valLetter];
          var d2c = function(k) {
            return valAxis.d2c((trace[k] || [])[i]);
          };
          var minVal = Infinity;
          var maxVal = -Infinity;
          for (i = 0; i < trace._length; i++) {
            var posi = posArray[i];
            if (!isNumeric(posi)) continue;
            cdi = {};
            cdi.pos = cdi[posLetter] = posi;
            if (hasPeriod && origPos) {
              cdi.orig_p = origPos[i];
            }
            cdi.q1 = d2c("q1");
            cdi.med = d2c("median");
            cdi.q3 = d2c("q3");
            pts = [];
            if (valArrayRaw && Lib.isArrayOrTypedArray(valArrayRaw[i])) {
              for (j = 0; j < valArrayRaw[i].length; j++) {
                v = valAxis.d2c(valArrayRaw[i][j]);
                if (v !== BADNUM) {
                  pt = { v, i: [i, j] };
                  arraysToCalcdata(pt, trace, [i, j]);
                  pts.push(pt);
                }
              }
            }
            cdi.pts = pts.sort(sortByVal);
            boxVals = cdi[valLetter] = pts.map(extractVal);
            N = boxVals.length;
            if (cdi.med !== BADNUM && cdi.q1 !== BADNUM && cdi.q3 !== BADNUM && cdi.med >= cdi.q1 && cdi.q3 >= cdi.med) {
              var lf = d2c("lowerfence");
              cdi.lf = lf !== BADNUM && lf <= cdi.q1 ? lf : computeLowerFence(cdi, boxVals, N);
              var uf = d2c("upperfence");
              cdi.uf = uf !== BADNUM && uf >= cdi.q3 ? uf : computeUpperFence(cdi, boxVals, N);
              var mean = d2c("mean");
              cdi.mean = mean !== BADNUM ? mean : N ? Lib.mean(boxVals, N) : (cdi.q1 + cdi.q3) / 2;
              var sd = d2c("sd");
              cdi.sd = mean !== BADNUM && sd >= 0 ? sd : N ? Lib.stdev(boxVals, N, cdi.mean) : cdi.q3 - cdi.q1;
              cdi.lo = computeLowerOutlierBound(cdi);
              cdi.uo = computeUpperOutlierBound(cdi);
              var ns = d2c("notchspan");
              ns = ns !== BADNUM && ns > 0 ? ns : computeNotchSpan(cdi, N);
              cdi.ln = cdi.med - ns;
              cdi.un = cdi.med + ns;
              var imin = cdi.lf;
              var imax = cdi.uf;
              if (trace.boxpoints && boxVals.length) {
                imin = Math.min(imin, boxVals[0]);
                imax = Math.max(imax, boxVals[N - 1]);
              }
              if (trace.notched) {
                imin = Math.min(imin, cdi.ln);
                imax = Math.max(imax, cdi.un);
              }
              cdi.min = imin;
              cdi.max = imax;
            } else {
              Lib.warn([
                "Invalid input - make sure that q1 <= median <= q3",
                "q1 = " + cdi.q1,
                "median = " + cdi.med,
                "q3 = " + cdi.q3
              ].join("\n"));
              var v0;
              if (cdi.med !== BADNUM) {
                v0 = cdi.med;
              } else if (cdi.q1 !== BADNUM) {
                if (cdi.q3 !== BADNUM) v0 = (cdi.q1 + cdi.q3) / 2;
                else v0 = cdi.q1;
              } else if (cdi.q3 !== BADNUM) {
                v0 = cdi.q3;
              } else {
                v0 = 0;
              }
              cdi.med = v0;
              cdi.q1 = cdi.q3 = v0;
              cdi.lf = cdi.uf = v0;
              cdi.mean = cdi.sd = v0;
              cdi.ln = cdi.un = v0;
              cdi.min = cdi.max = v0;
            }
            minVal = Math.min(minVal, cdi.min);
            maxVal = Math.max(maxVal, cdi.max);
            cdi.pts2 = pts.filter(ptFilterFn);
            cd.push(cdi);
          }
          trace._extremes[valAxis._id] = Axes.findExtremes(
            valAxis,
            [minVal, maxVal],
            { padded: true }
          );
        } else {
          var valArray = valAxis.makeCalcdata(trace, valLetter);
          var posBins = makeBins(posDistinct, dPos);
          var pLen = posDistinct.length;
          var ptsPerBin = initNestedArray(pLen);
          for (i = 0; i < trace._length; i++) {
            v = valArray[i];
            if (!isNumeric(v)) continue;
            var n = Lib.findBin(posArray[i], posBins);
            if (n >= 0 && n < pLen) {
              pt = { v, i };
              arraysToCalcdata(pt, trace, i);
              ptsPerBin[n].push(pt);
            }
          }
          var minLowerNotch = Infinity;
          var maxUpperNotch = -Infinity;
          var quartilemethod = trace.quartilemethod;
          var usesExclusive = quartilemethod === "exclusive";
          var usesInclusive = quartilemethod === "inclusive";
          for (i = 0; i < pLen; i++) {
            if (ptsPerBin[i].length > 0) {
              cdi = {};
              cdi.pos = cdi[posLetter] = posDistinct[i];
              pts = cdi.pts = ptsPerBin[i].sort(sortByVal);
              boxVals = cdi[valLetter] = pts.map(extractVal);
              N = boxVals.length;
              cdi.min = boxVals[0];
              cdi.max = boxVals[N - 1];
              cdi.mean = Lib.mean(boxVals, N);
              cdi.sd = Lib.stdev(boxVals, N, cdi.mean) * trace.sdmultiple;
              cdi.med = Lib.interp(boxVals, 0.5);
              if (N % 2 && (usesExclusive || usesInclusive)) {
                var lower;
                var upper;
                if (usesExclusive) {
                  lower = boxVals.slice(0, N / 2);
                  upper = boxVals.slice(N / 2 + 1);
                } else if (usesInclusive) {
                  lower = boxVals.slice(0, N / 2 + 1);
                  upper = boxVals.slice(N / 2);
                }
                cdi.q1 = Lib.interp(lower, 0.5);
                cdi.q3 = Lib.interp(upper, 0.5);
              } else {
                cdi.q1 = Lib.interp(boxVals, 0.25);
                cdi.q3 = Lib.interp(boxVals, 0.75);
              }
              cdi.lf = computeLowerFence(cdi, boxVals, N);
              cdi.uf = computeUpperFence(cdi, boxVals, N);
              cdi.lo = computeLowerOutlierBound(cdi);
              cdi.uo = computeUpperOutlierBound(cdi);
              var mci = computeNotchSpan(cdi, N);
              cdi.ln = cdi.med - mci;
              cdi.un = cdi.med + mci;
              minLowerNotch = Math.min(minLowerNotch, cdi.ln);
              maxUpperNotch = Math.max(maxUpperNotch, cdi.un);
              cdi.pts2 = pts.filter(ptFilterFn);
              cd.push(cdi);
            }
          }
          if (trace.notched && Lib.isTypedArray(valArray)) valArray = Array.from(valArray);
          trace._extremes[valAxis._id] = Axes.findExtremes(
            valAxis,
            trace.notched ? valArray.concat([minLowerNotch, maxUpperNotch]) : valArray,
            { padded: true }
          );
        }
        calcSelection(cd, trace);
        if (cd.length > 0) {
          cd[0].t = {
            num: fullLayout[numKey],
            dPos,
            posLetter,
            valLetter,
            labels: {
              med: _(gd, "median:"),
              min: _(gd, "min:"),
              q1: _(gd, "q1:"),
              q3: _(gd, "q3:"),
              max: _(gd, "max:"),
              mean: trace.boxmean === "sd" || trace.sizemode === "sd" ? _(gd, "mean \xB1 \u03C3:").replace("\u03C3", trace.sdmultiple === 1 ? "\u03C3" : trace.sdmultiple + "\u03C3") : (
                // displaying mean +- N whilst supporting translations
                _(gd, "mean:")
              ),
              lf: _(gd, "lower fence:"),
              uf: _(gd, "upper fence:")
            }
          };
          fullLayout[numKey]++;
          return cd;
        } else {
          return [{ t: { empty: true } }];
        }
      };
      function getPosArrays(trace, posLetter, posAxis, num) {
        var hasPosArray = posLetter in trace;
        var hasPos0 = posLetter + "0" in trace;
        var hasPosStep = "d" + posLetter in trace;
        if (hasPosArray || hasPos0 && hasPosStep) {
          var origPos = posAxis.makeCalcdata(trace, posLetter);
          var pos = alignPeriod(trace, posAxis, posLetter, origPos).vals;
          return [pos, origPos];
        }
        var pos0;
        if (hasPos0) {
          pos0 = trace[posLetter + "0"];
        } else if ("name" in trace && (posAxis.type === "category" || isNumeric(trace.name) && ["linear", "log"].indexOf(posAxis.type) !== -1 || Lib.isDateTime(trace.name) && posAxis.type === "date")) {
          pos0 = trace.name;
        } else {
          pos0 = num;
        }
        var pos0c = posAxis.type === "multicategory" ? posAxis.r2c_just_indices(pos0) : posAxis.d2c(pos0, 0, trace[posLetter + "calendar"]);
        var len = trace._length;
        var out = new Array(len);
        for (var i = 0; i < len; i++) out[i] = pos0c;
        return [out];
      }
      function makeBins(x, dx) {
        var len = x.length;
        var bins = new Array(len + 1);
        for (var i = 0; i < len; i++) {
          bins[i] = x[i] - dx;
        }
        bins[len] = x[len - 1] + dx;
        return bins;
      }
      function initNestedArray(len) {
        var arr = new Array(len);
        for (var i = 0; i < len; i++) {
          arr[i] = [];
        }
        return arr;
      }
      var TRACE_TO_CALC = {
        text: "tx",
        hovertext: "htx"
      };
      function arraysToCalcdata(pt, trace, ptNumber) {
        for (var k in TRACE_TO_CALC) {
          if (Lib.isArrayOrTypedArray(trace[k])) {
            if (Array.isArray(ptNumber)) {
              if (Lib.isArrayOrTypedArray(trace[k][ptNumber[0]])) {
                pt[TRACE_TO_CALC[k]] = trace[k][ptNumber[0]][ptNumber[1]];
              }
            } else {
              pt[TRACE_TO_CALC[k]] = trace[k][ptNumber];
            }
          }
        }
      }
      function calcSelection(cd, trace) {
        if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {
          for (var i = 0; i < cd.length; i++) {
            var pts = cd[i].pts || [];
            var ptNumber2cdIndex = {};
            for (var j = 0; j < pts.length; j++) {
              ptNumber2cdIndex[pts[j].i] = j;
            }
            Lib.tagSelected(pts, trace, ptNumber2cdIndex);
          }
        }
      }
      function sortByVal(a, b) {
        return a.v - b.v;
      }
      function extractVal(o) {
        return o.v;
      }
      function computeLowerFence(cdi, boxVals, N) {
        if (N === 0) return cdi.q1;
        return Math.min(
          cdi.q1,
          boxVals[Math.min(
            Lib.findBin(2.5 * cdi.q1 - 1.5 * cdi.q3, boxVals, true) + 1,
            N - 1
          )]
        );
      }
      function computeUpperFence(cdi, boxVals, N) {
        if (N === 0) return cdi.q3;
        return Math.max(
          cdi.q3,
          boxVals[Math.max(
            Lib.findBin(2.5 * cdi.q3 - 1.5 * cdi.q1, boxVals),
            0
          )]
        );
      }
      function computeLowerOutlierBound(cdi) {
        return 4 * cdi.q1 - 3 * cdi.q3;
      }
      function computeUpperOutlierBound(cdi) {
        return 4 * cdi.q3 - 3 * cdi.q1;
      }
      function computeNotchSpan(cdi, N) {
        if (N === 0) return 0;
        return 1.57 * (cdi.q3 - cdi.q1) / Math.sqrt(N);
      }
    }
  });

  // src/traces/box/cross_trace_calc.js
  var require_cross_trace_calc3 = __commonJS({
    "src/traces/box/cross_trace_calc.js"(exports, module) {
      "use strict";
      var Axes = require_axes();
      var Lib = require_lib();
      var getAxisGroup = require_constraints().getAxisGroup;
      var orientations = ["v", "h"];
      function crossTraceCalc(gd, plotinfo) {
        var calcdata = gd.calcdata;
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        for (var i = 0; i < orientations.length; i++) {
          var orientation = orientations[i];
          var posAxis = orientation === "h" ? ya : xa;
          var boxList = [];
          for (var j = 0; j < calcdata.length; j++) {
            var cd = calcdata[j];
            var t = cd[0].t;
            var trace = cd[0].trace;
            if (trace.visible === true && (trace.type === "box" || trace.type === "candlestick") && !t.empty && (trace.orientation || "v") === orientation && trace.xaxis === xa._id && trace.yaxis === ya._id) {
              boxList.push(j);
            }
          }
          setPositionOffset("box", gd, boxList, posAxis);
        }
      }
      function setPositionOffset(traceType, gd, boxList, posAxis) {
        var calcdata = gd.calcdata;
        var fullLayout = gd._fullLayout;
        var axId = posAxis._id;
        var axLetter = axId.charAt(0);
        var i, j, calcTrace;
        var pointList = [];
        var shownPts = 0;
        for (i = 0; i < boxList.length; i++) {
          calcTrace = calcdata[boxList[i]];
          for (j = 0; j < calcTrace.length; j++) {
            pointList.push(posAxis.c2l(calcTrace[j].pos, true));
            shownPts += (calcTrace[j].pts2 || []).length;
          }
        }
        if (!pointList.length) return;
        var boxdv = Lib.distinctVals(pointList);
        if (posAxis.type === "category" || posAxis.type === "multicategory") {
          boxdv.minDiff = 1;
        }
        var dPos0 = boxdv.minDiff / 2;
        Axes.minDtick(posAxis, boxdv.minDiff, boxdv.vals[0], true);
        var numKey = traceType === "violin" ? "_numViolins" : "_numBoxes";
        var numTotal = fullLayout[numKey];
        var group = fullLayout[traceType + "mode"] === "group" && numTotal > 1;
        var groupFraction = 1 - fullLayout[traceType + "gap"];
        var groupGapFraction = 1 - fullLayout[traceType + "groupgap"];
        for (i = 0; i < boxList.length; i++) {
          calcTrace = calcdata[boxList[i]];
          var trace = calcTrace[0].trace;
          var t = calcTrace[0].t;
          var width = trace.width;
          var side = trace.side;
          var dPos;
          var bdPos;
          var bPos;
          var wHover;
          if (width) {
            dPos = bdPos = wHover = width / 2;
            bPos = 0;
          } else {
            dPos = dPos0;
            if (group) {
              var groupId = getAxisGroup(fullLayout, posAxis._id) + trace.orientation;
              var alignmentGroups = fullLayout._alignmentOpts[groupId] || {};
              var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};
              var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;
              var num = nOffsetGroups || numTotal;
              var shift = nOffsetGroups ? trace._offsetIndex : t.num;
              bdPos = dPos * groupFraction * groupGapFraction / num;
              bPos = 2 * dPos * (-0.5 + (shift + 0.5) / num) * groupFraction;
              wHover = dPos * groupFraction / num;
            } else {
              bdPos = dPos * groupFraction * groupGapFraction;
              bPos = 0;
              wHover = dPos;
            }
          }
          t.dPos = dPos;
          t.bPos = bPos;
          t.bdPos = bdPos;
          t.wHover = wHover;
          var pushplus;
          var pushminus;
          var edge = bPos + bdPos;
          var edgeplus;
          var edgeminus;
          var vpadplus;
          var vpadminus;
          var ppadplus;
          var ppadminus;
          var padded = Boolean(width);
          var hasPts = (trace.boxpoints || trace.points) && shownPts > 0;
          if (side === "positive") {
            pushplus = dPos * (width ? 1 : 0.5);
            edgeplus = edge;
            pushminus = edgeplus = bPos;
          } else if (side === "negative") {
            pushplus = edgeplus = bPos;
            pushminus = dPos * (width ? 1 : 0.5);
            edgeminus = edge;
          } else {
            pushplus = pushminus = dPos;
            edgeplus = edgeminus = edge;
          }
          if (hasPts) {
            var pointpos = trace.pointpos;
            var jitter = trace.jitter;
            var ms = trace.marker.size / 2;
            var pp = 0;
            if (pointpos + jitter >= 0) {
              pp = edge * (pointpos + jitter);
              if (pp > pushplus) {
                padded = true;
                ppadplus = ms;
                vpadplus = pp;
              } else if (pp > edgeplus) {
                ppadplus = ms;
                vpadplus = pushplus;
              }
            }
            if (pp <= pushplus) {
              vpadplus = pushplus;
            }
            var pm = 0;
            if (pointpos - jitter <= 0) {
              pm = -edge * (pointpos - jitter);
              if (pm > pushminus) {
                padded = true;
                ppadminus = ms;
                vpadminus = pm;
              } else if (pm > edgeminus) {
                ppadminus = ms;
                vpadminus = pushminus;
              }
            }
            if (pm <= pushminus) {
              vpadminus = pushminus;
            }
          } else {
            vpadplus = pushplus;
            vpadminus = pushminus;
          }
          var pos = new Array(calcTrace.length);
          for (j = 0; j < calcTrace.length; j++) {
            pos[j] = calcTrace[j].pos;
          }
          trace._extremes[axId] = Axes.findExtremes(posAxis, pos, {
            padded,
            vpadminus,
            vpadplus,
            vpadLinearized: true,
            // N.B. SVG px-space positive/negative
            ppadminus: { x: ppadminus, y: ppadplus }[axLetter],
            ppadplus: { x: ppadplus, y: ppadminus }[axLetter]
          });
        }
      }
      module.exports = {
        crossTraceCalc,
        setPositionOffset
      };
    }
  });

  // src/traces/box/plot.js
  var require_plot4 = __commonJS({
    "src/traces/box/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var Drawing = require_drawing();
      var JITTERCOUNT = 5;
      var JITTERSPREAD = 0.01;
      function plot(gd, plotinfo, cdbox, boxLayer) {
        var isStatic = gd._context.staticPlot;
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        Lib.makeTraceGroups(boxLayer, cdbox, "trace boxes").each(function(cd) {
          var plotGroup = d3.select(this);
          var cd0 = cd[0];
          var t = cd0.t;
          var trace = cd0.trace;
          t.wdPos = t.bdPos * trace.whiskerwidth;
          if (trace.visible !== true || t.empty) {
            plotGroup.remove();
            return;
          }
          var posAxis, valAxis;
          if (trace.orientation === "h") {
            posAxis = ya;
            valAxis = xa;
          } else {
            posAxis = xa;
            valAxis = ya;
          }
          plotBoxAndWhiskers(plotGroup, { pos: posAxis, val: valAxis }, trace, t, isStatic);
          plotPoints(plotGroup, { x: xa, y: ya }, trace, t);
          plotBoxMean(plotGroup, { pos: posAxis, val: valAxis }, trace, t);
        });
      }
      function plotBoxAndWhiskers(sel, axes, trace, t, isStatic) {
        var isHorizontal = trace.orientation === "h";
        var valAxis = axes.val;
        var posAxis = axes.pos;
        var posHasRangeBreaks = !!posAxis.rangebreaks;
        var bPos = t.bPos;
        var wdPos = t.wdPos || 0;
        var bPosPxOffset = t.bPosPxOffset || 0;
        var whiskerWidth = trace.whiskerwidth || 0;
        var showWhiskers = trace.showwhiskers !== false;
        var notched = trace.notched || false;
        var nw = notched ? 1 - 2 * trace.notchwidth : 1;
        var bdPos0;
        var bdPos1;
        if (Array.isArray(t.bdPos)) {
          bdPos0 = t.bdPos[0];
          bdPos1 = t.bdPos[1];
        } else {
          bdPos0 = t.bdPos;
          bdPos1 = t.bdPos;
        }
        var paths = sel.selectAll("path.box").data(trace.type !== "violin" || trace.box.visible ? Lib.identity : []);
        paths.enter().append("path").style("vector-effect", isStatic ? "none" : "non-scaling-stroke").attr("class", "box");
        paths.exit().remove();
        paths.each(function(d) {
          if (d.empty) return d3.select(this).attr("d", "M0,0Z");
          var lcenter = posAxis.c2l(d.pos + bPos, true);
          var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;
          var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;
          var posc = posHasRangeBreaks ? (pos0 + pos1) / 2 : posAxis.l2p(lcenter) + bPosPxOffset;
          var r = trace.whiskerwidth;
          var posw0 = posHasRangeBreaks ? pos0 * r + (1 - r) * posc : posAxis.l2p(lcenter - wdPos) + bPosPxOffset;
          var posw1 = posHasRangeBreaks ? pos1 * r + (1 - r) * posc : posAxis.l2p(lcenter + wdPos) + bPosPxOffset;
          var posm0 = posAxis.l2p(lcenter - bdPos0 * nw) + bPosPxOffset;
          var posm1 = posAxis.l2p(lcenter + bdPos1 * nw) + bPosPxOffset;
          var sdmode = trace.sizemode === "sd";
          var q1 = valAxis.c2p(sdmode ? d.mean - d.sd : d.q1, true);
          var q3 = sdmode ? valAxis.c2p(d.mean + d.sd, true) : valAxis.c2p(d.q3, true);
          var m = Lib.constrain(
            sdmode ? valAxis.c2p(d.mean, true) : valAxis.c2p(d.med, true),
            Math.min(q1, q3) + 1,
            Math.max(q1, q3) - 1
          );
          var useExtremes = d.lf === void 0 || trace.boxpoints === false || sdmode;
          var lf = valAxis.c2p(useExtremes ? d.min : d.lf, true);
          var uf = valAxis.c2p(useExtremes ? d.max : d.uf, true);
          var ln = valAxis.c2p(d.ln, true);
          var un = valAxis.c2p(d.un, true);
          if (isHorizontal) {
            d3.select(this).attr(
              "d",
              "M" + m + "," + posm0 + "V" + posm1 + // median line
              "M" + q1 + "," + pos0 + "V" + pos1 + // left edge
              (notched ? "H" + ln + "L" + m + "," + posm1 + "L" + un + "," + pos1 : "") + // top notched edge
              "H" + q3 + // end of the top edge
              "V" + pos0 + // right edge
              (notched ? "H" + un + "L" + m + "," + posm0 + "L" + ln + "," + pos0 : "") + // bottom notched edge
              "Z" + // end of the box
              (showWhiskers ? "M" + q1 + "," + posc + "H" + lf + "M" + q3 + "," + posc + "H" + uf + // whiskers
              (whiskerWidth === 0 ? "" : (
                // whisker caps
                "M" + lf + "," + posw0 + "V" + posw1 + "M" + uf + "," + posw0 + "V" + posw1
              )) : "")
            );
          } else {
            d3.select(this).attr(
              "d",
              "M" + posm0 + "," + m + "H" + posm1 + // median line
              "M" + pos0 + "," + q1 + "H" + pos1 + // top of the box
              (notched ? "V" + ln + "L" + posm1 + "," + m + "L" + pos1 + "," + un : "") + // notched right edge
              "V" + q3 + // end of the right edge
              "H" + pos0 + // bottom of the box
              (notched ? "V" + un + "L" + posm0 + "," + m + "L" + pos0 + "," + ln : "") + // notched left edge
              "Z" + // end of the box
              (showWhiskers ? "M" + posc + "," + q1 + "V" + lf + "M" + posc + "," + q3 + "V" + uf + // whiskers
              (whiskerWidth === 0 ? "" : (
                // whisker caps
                "M" + posw0 + "," + lf + "H" + posw1 + "M" + posw0 + "," + uf + "H" + posw1
              )) : "")
            );
          }
        });
      }
      function plotPoints(sel, axes, trace, t) {
        var xa = axes.x;
        var ya = axes.y;
        var bdPos = t.bdPos;
        var bPos = t.bPos;
        var mode = trace.boxpoints || trace.points;
        Lib.seedPseudoRandom();
        var fn = function(d) {
          d.forEach(function(v) {
            v.t = t;
            v.trace = trace;
          });
          return d;
        };
        var gPoints = sel.selectAll("g.points").data(mode ? fn : []);
        gPoints.enter().append("g").attr("class", "points");
        gPoints.exit().remove();
        var paths = gPoints.selectAll("path").data(function(d) {
          var i;
          var pts = d.pts2;
          var typicalSpread = Math.max((d.max - d.min) / 10, d.q3 - d.q1);
          var minSpread = typicalSpread * 1e-9;
          var spreadLimit = typicalSpread * JITTERSPREAD;
          var jitterFactors = [];
          var maxJitterFactor = 0;
          var newJitter;
          if (trace.jitter) {
            if (typicalSpread === 0) {
              maxJitterFactor = 1;
              jitterFactors = new Array(pts.length);
              for (i = 0; i < pts.length; i++) {
                jitterFactors[i] = 1;
              }
            } else {
              for (i = 0; i < pts.length; i++) {
                var i0 = Math.max(0, i - JITTERCOUNT);
                var pmin = pts[i0].v;
                var i1 = Math.min(pts.length - 1, i + JITTERCOUNT);
                var pmax = pts[i1].v;
                if (mode !== "all") {
                  if (pts[i].v < d.lf) pmax = Math.min(pmax, d.lf);
                  else pmin = Math.max(pmin, d.uf);
                }
                var jitterFactor = Math.sqrt(spreadLimit * (i1 - i0) / (pmax - pmin + minSpread)) || 0;
                jitterFactor = Lib.constrain(Math.abs(jitterFactor), 0, 1);
                jitterFactors.push(jitterFactor);
                maxJitterFactor = Math.max(jitterFactor, maxJitterFactor);
              }
            }
            newJitter = trace.jitter * 2 / (maxJitterFactor || 1);
          }
          for (i = 0; i < pts.length; i++) {
            var pt = pts[i];
            var v = pt.v;
            var jitterOffset = trace.jitter ? newJitter * jitterFactors[i] * (Lib.pseudoRandom() - 0.5) : 0;
            var posPx = d.pos + bPos + bdPos * (trace.pointpos + jitterOffset);
            if (trace.orientation === "h") {
              pt.y = posPx;
              pt.x = v;
            } else {
              pt.x = posPx;
              pt.y = v;
            }
            if (mode === "suspectedoutliers" && v < d.uo && v > d.lo) {
              pt.so = true;
            }
          }
          return pts;
        });
        paths.enter().append("path").classed("point", true);
        paths.exit().remove();
        paths.call(Drawing.translatePoints, xa, ya);
      }
      function plotBoxMean(sel, axes, trace, t) {
        var valAxis = axes.val;
        var posAxis = axes.pos;
        var posHasRangeBreaks = !!posAxis.rangebreaks;
        var bPos = t.bPos;
        var bPosPxOffset = t.bPosPxOffset || 0;
        var mode = trace.boxmean || (trace.meanline || {}).visible;
        var bdPos0;
        var bdPos1;
        if (Array.isArray(t.bdPos)) {
          bdPos0 = t.bdPos[0];
          bdPos1 = t.bdPos[1];
        } else {
          bdPos0 = t.bdPos;
          bdPos1 = t.bdPos;
        }
        var paths = sel.selectAll("path.mean").data(trace.type === "box" && trace.boxmean || trace.type === "violin" && trace.box.visible && trace.meanline.visible ? Lib.identity : []);
        paths.enter().append("path").attr("class", "mean").style({
          fill: "none",
          "vector-effect": "non-scaling-stroke"
        });
        paths.exit().remove();
        paths.each(function(d) {
          var lcenter = posAxis.c2l(d.pos + bPos, true);
          var pos0 = posAxis.l2p(lcenter - bdPos0) + bPosPxOffset;
          var pos1 = posAxis.l2p(lcenter + bdPos1) + bPosPxOffset;
          var posc = posHasRangeBreaks ? (pos0 + pos1) / 2 : posAxis.l2p(lcenter) + bPosPxOffset;
          var m = valAxis.c2p(d.mean, true);
          var sl = valAxis.c2p(d.mean - d.sd, true);
          var sh = valAxis.c2p(d.mean + d.sd, true);
          if (trace.orientation === "h") {
            d3.select(this).attr(
              "d",
              "M" + m + "," + pos0 + "V" + pos1 + (mode === "sd" ? "m0,0L" + sl + "," + posc + "L" + m + "," + pos0 + "L" + sh + "," + posc + "Z" : "")
            );
          } else {
            d3.select(this).attr(
              "d",
              "M" + pos0 + "," + m + "H" + pos1 + (mode === "sd" ? "m0,0L" + posc + "," + sl + "L" + pos0 + "," + m + "L" + posc + "," + sh + "Z" : "")
            );
          }
        });
      }
      module.exports = {
        plot,
        plotBoxAndWhiskers,
        plotPoints,
        plotBoxMean
      };
    }
  });

  // src/traces/box/style.js
  var require_style5 = __commonJS({
    "src/traces/box/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Color = require_color();
      var Drawing = require_drawing();
      function style(gd, cd, sel) {
        var s = sel ? sel : d3.select(gd).selectAll("g.trace.boxes");
        s.style("opacity", function(d) {
          return d[0].trace.opacity;
        });
        s.each(function(d) {
          var el = d3.select(this);
          var trace = d[0].trace;
          var lineWidth = trace.line.width;
          function styleBox(boxSel, lineWidth2, lineColor, fillColor) {
            boxSel.style("stroke-width", lineWidth2 + "px").call(Color.stroke, lineColor).call(Color.fill, fillColor);
          }
          var allBoxes = el.selectAll("path.box");
          if (trace.type === "candlestick") {
            allBoxes.each(function(boxData) {
              if (boxData.empty) return;
              var thisBox = d3.select(this);
              var container = trace[boxData.dir];
              styleBox(thisBox, container.line.width, container.line.color, container.fillcolor);
              thisBox.style("opacity", trace.selectedpoints && !boxData.selected ? 0.3 : 1);
            });
          } else {
            styleBox(allBoxes, lineWidth, trace.line.color, trace.fillcolor);
            el.selectAll("path.mean").style({
              "stroke-width": lineWidth,
              "stroke-dasharray": 2 * lineWidth + "px," + lineWidth + "px"
            }).call(Color.stroke, trace.line.color);
            var pts = el.selectAll("path.point");
            Drawing.pointStyle(pts, trace, gd);
          }
        });
      }
      function styleOnSelect(gd, cd, sel) {
        var trace = cd[0].trace;
        var pts = sel.selectAll("path.point");
        if (trace.selectedpoints) {
          Drawing.selectedPointStyle(pts, trace);
        } else {
          Drawing.pointStyle(pts, trace, gd);
        }
      }
      module.exports = {
        style,
        styleOnSelect
      };
    }
  });

  // src/traces/box/hover.js
  var require_hover4 = __commonJS({
    "src/traces/box/hover.js"(exports, module) {
      "use strict";
      var Axes = require_axes();
      var Lib = require_lib();
      var Fx = require_fx();
      var Color = require_color();
      var fillText = Lib.fillText;
      function hoverPoints(pointData, xval, yval, hovermode) {
        var cd = pointData.cd;
        var trace = cd[0].trace;
        var hoveron = trace.hoveron;
        var closeBoxData = [];
        var closePtData;
        if (hoveron.indexOf("boxes") !== -1) {
          closeBoxData = closeBoxData.concat(hoverOnBoxes(pointData, xval, yval, hovermode));
        }
        if (hoveron.indexOf("points") !== -1) {
          closePtData = hoverOnPoints(pointData, xval, yval);
        }
        if (hovermode === "closest") {
          if (closePtData) return [closePtData];
          return closeBoxData;
        }
        if (closePtData) {
          closeBoxData.push(closePtData);
          return closeBoxData;
        }
        return closeBoxData;
      }
      function hoverOnBoxes(pointData, xval, yval, hovermode) {
        var cd = pointData.cd;
        var xa = pointData.xa;
        var ya = pointData.ya;
        var trace = cd[0].trace;
        var t = cd[0].t;
        var isViolin = trace.type === "violin";
        var pLetter, vLetter, pAxis, vAxis, vVal, pVal, dx, dy, dPos, hoverPseudoDistance, spikePseudoDistance;
        var boxDelta = t.bdPos;
        var boxDeltaPos, boxDeltaNeg;
        var posAcceptance = t.wHover;
        var shiftPos = function(di2) {
          return pAxis.c2l(di2.pos) + t.bPos - pAxis.c2l(pVal);
        };
        if (isViolin && trace.side !== "both") {
          if (trace.side === "positive") {
            dPos = function(di2) {
              var pos = shiftPos(di2);
              return Fx.inbox(pos, pos + posAcceptance, hoverPseudoDistance);
            };
            boxDeltaPos = boxDelta;
            boxDeltaNeg = 0;
          }
          if (trace.side === "negative") {
            dPos = function(di2) {
              var pos = shiftPos(di2);
              return Fx.inbox(pos - posAcceptance, pos, hoverPseudoDistance);
            };
            boxDeltaPos = 0;
            boxDeltaNeg = boxDelta;
          }
        } else {
          dPos = function(di2) {
            var pos = shiftPos(di2);
            return Fx.inbox(pos - posAcceptance, pos + posAcceptance, hoverPseudoDistance);
          };
          boxDeltaPos = boxDeltaNeg = boxDelta;
        }
        var dVal;
        if (isViolin) {
          dVal = function(di2) {
            return Fx.inbox(di2.span[0] - vVal, di2.span[1] - vVal, hoverPseudoDistance);
          };
        } else {
          dVal = function(di2) {
            return Fx.inbox(di2.min - vVal, di2.max - vVal, hoverPseudoDistance);
          };
        }
        if (trace.orientation === "h") {
          vVal = xval;
          pVal = yval;
          dx = dVal;
          dy = dPos;
          pLetter = "y";
          pAxis = ya;
          vLetter = "x";
          vAxis = xa;
        } else {
          vVal = yval;
          pVal = xval;
          dx = dPos;
          dy = dVal;
          pLetter = "x";
          pAxis = xa;
          vLetter = "y";
          vAxis = ya;
        }
        var pseudoDistance = Math.min(1, boxDelta / Math.abs(pAxis.r2c(pAxis.range[1]) - pAxis.r2c(pAxis.range[0])));
        hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;
        spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;
        function dxy(di2) {
          return (dx(di2) + dy(di2)) / 2;
        }
        var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);
        Fx.getClosest(cd, distfn, pointData);
        if (pointData.index === false) return [];
        var di = cd[pointData.index];
        var lc = trace.line.color;
        var mc = (trace.marker || {}).color;
        if (Color.opacity(lc) && trace.line.width) pointData.color = lc;
        else if (Color.opacity(mc) && trace.boxpoints) pointData.color = mc;
        else pointData.color = trace.fillcolor;
        pointData[pLetter + "0"] = pAxis.c2p(di.pos + t.bPos - boxDeltaNeg, true);
        pointData[pLetter + "1"] = pAxis.c2p(di.pos + t.bPos + boxDeltaPos, true);
        pointData[pLetter + "LabelVal"] = di.orig_p !== void 0 ? di.orig_p : di.pos;
        var spikePosAttr = pLetter + "Spike";
        pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;
        pointData[spikePosAttr] = pAxis.c2p(di.pos, true);
        var hasMean = trace.boxmean || trace.sizemode === "sd" || (trace.meanline || {}).visible;
        var hasFences = trace.boxpoints || trace.points;
        var attrs = hasFences && hasMean ? ["max", "uf", "q3", "med", "mean", "q1", "lf", "min"] : hasFences && !hasMean ? ["max", "uf", "q3", "med", "q1", "lf", "min"] : !hasFences && hasMean ? ["max", "q3", "med", "mean", "q1", "min"] : ["max", "q3", "med", "q1", "min"];
        var rev = vAxis.range[1] < vAxis.range[0];
        if (trace.orientation === (rev ? "v" : "h")) {
          attrs.reverse();
        }
        var spikeDistance = pointData.spikeDistance;
        var spikePosition = pointData[spikePosAttr];
        var closeBoxData = [];
        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          if (!(attr in di)) continue;
          var val = di[attr];
          var valPx = vAxis.c2p(val, true);
          var pointData2 = Lib.extendFlat({}, pointData);
          pointData2.attr = attr;
          pointData2[vLetter + "0"] = pointData2[vLetter + "1"] = valPx;
          pointData2[vLetter + "LabelVal"] = val;
          pointData2[vLetter + "Label"] = (t.labels ? t.labels[attr] + " " : "") + Axes.hoverLabelText(vAxis, val, trace[vLetter + "hoverformat"]);
          pointData2.hoverOnBox = true;
          if (attr === "mean" && "sd" in di && (trace.boxmean === "sd" || trace.sizemode === "sd")) {
            pointData2[vLetter + "err"] = di.sd;
          }
          pointData2.hovertemplate = false;
          closeBoxData.push(pointData2);
        }
        pointData.name = "";
        pointData.spikeDistance = void 0;
        pointData[spikePosAttr] = void 0;
        for (var k = 0; k < closeBoxData.length; k++) {
          if (closeBoxData[k].attr !== "med") {
            closeBoxData[k].name = "";
            closeBoxData[k].spikeDistance = void 0;
            closeBoxData[k][spikePosAttr] = void 0;
          } else {
            closeBoxData[k].spikeDistance = spikeDistance;
            closeBoxData[k][spikePosAttr] = spikePosition;
          }
        }
        return closeBoxData;
      }
      function hoverOnPoints(pointData, xval, yval) {
        var cd = pointData.cd;
        var xa = pointData.xa;
        var ya = pointData.ya;
        var trace = cd[0].trace;
        var xPx = xa.c2p(xval);
        var yPx = ya.c2p(yval);
        var closePtData;
        var dx = function(di2) {
          var rad2 = Math.max(3, di2.mrc || 0);
          return Math.max(Math.abs(xa.c2p(di2.x) - xPx) - rad2, 1 - 3 / rad2);
        };
        var dy = function(di2) {
          var rad2 = Math.max(3, di2.mrc || 0);
          return Math.max(Math.abs(ya.c2p(di2.y) - yPx) - rad2, 1 - 3 / rad2);
        };
        var distfn = Fx.quadrature(dx, dy);
        var ijClosest = false;
        var di, pt;
        for (var i = 0; i < cd.length; i++) {
          di = cd[i];
          for (var j = 0; j < (di.pts || []).length; j++) {
            pt = di.pts[j];
            var newDistance = distfn(pt);
            if (newDistance <= pointData.distance) {
              pointData.distance = newDistance;
              ijClosest = [i, j];
            }
          }
        }
        if (!ijClosest) return false;
        di = cd[ijClosest[0]];
        pt = di.pts[ijClosest[1]];
        var xc = xa.c2p(pt.x, true);
        var yc = ya.c2p(pt.y, true);
        var rad = pt.mrc || 1;
        closePtData = Lib.extendFlat({}, pointData, {
          // corresponds to index in x/y input data array
          index: pt.i,
          color: (trace.marker || {}).color,
          name: trace.name,
          x0: xc - rad,
          x1: xc + rad,
          y0: yc - rad,
          y1: yc + rad,
          spikeDistance: pointData.distance,
          hovertemplate: trace.hovertemplate
        });
        var origPos = di.orig_p;
        var pos = origPos !== void 0 ? origPos : di.pos;
        var pa;
        if (trace.orientation === "h") {
          pa = ya;
          closePtData.xLabelVal = pt.x;
          closePtData.yLabelVal = pos;
        } else {
          pa = xa;
          closePtData.xLabelVal = pos;
          closePtData.yLabelVal = pt.y;
        }
        var pLetter = pa._id.charAt(0);
        closePtData[pLetter + "Spike"] = pa.c2p(di.pos, true);
        fillText(pt, trace, closePtData);
        return closePtData;
      }
      module.exports = {
        hoverPoints,
        hoverOnBoxes,
        hoverOnPoints
      };
    }
  });

  // src/traces/box/event_data.js
  var require_event_data2 = __commonJS({
    "src/traces/box/event_data.js"(exports, module) {
      "use strict";
      module.exports = function eventData(out, pt) {
        if (pt.hoverOnBox) out.hoverOnBox = pt.hoverOnBox;
        if ("xVal" in pt) out.x = pt.xVal;
        if ("yVal" in pt) out.y = pt.yVal;
        if (pt.xa) out.xaxis = pt.xa;
        if (pt.ya) out.yaxis = pt.ya;
        return out;
      };
    }
  });

  // src/traces/box/select.js
  var require_select4 = __commonJS({
    "src/traces/box/select.js"(exports, module) {
      "use strict";
      module.exports = function selectPoints(searchInfo, selectionTester) {
        var cd = searchInfo.cd;
        var xa = searchInfo.xaxis;
        var ya = searchInfo.yaxis;
        var selection = [];
        var i, j;
        if (selectionTester === false) {
          for (i = 0; i < cd.length; i++) {
            for (j = 0; j < (cd[i].pts || []).length; j++) {
              cd[i].pts[j].selected = 0;
            }
          }
        } else {
          for (i = 0; i < cd.length; i++) {
            for (j = 0; j < (cd[i].pts || []).length; j++) {
              var pt = cd[i].pts[j];
              var x = xa.c2p(pt.x);
              var y = ya.c2p(pt.y);
              if (selectionTester.contains([x, y], null, pt.i, searchInfo)) {
                selection.push({
                  pointNumber: pt.i,
                  x: xa.c2d(pt.x),
                  y: ya.c2d(pt.y)
                });
                pt.selected = 1;
              } else {
                pt.selected = 0;
              }
            }
          }
        }
        return selection;
      };
    }
  });

  // src/traces/box/index.js
  var require_box = __commonJS({
    "src/traces/box/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes24(),
        layoutAttributes: require_layout_attributes7(),
        supplyDefaults: require_defaults20().supplyDefaults,
        crossTraceDefaults: require_defaults20().crossTraceDefaults,
        supplyLayoutDefaults: require_layout_defaults6().supplyLayoutDefaults,
        calc: require_calc6(),
        crossTraceCalc: require_cross_trace_calc3().crossTraceCalc,
        plot: require_plot4().plot,
        style: require_style5().style,
        styleOnSelect: require_style5().styleOnSelect,
        hoverPoints: require_hover4().hoverPoints,
        eventData: require_event_data2(),
        selectPoints: require_select4(),
        moduleType: "trace",
        name: "box",
        basePlotModule: require_cartesian(),
        categories: ["cartesian", "svg", "symbols", "oriented", "box-violin", "showLegend", "boxLayout", "zoomScale"],
        meta: {}
      };
    }
  });

  // lib/box.js
  var require_box2 = __commonJS({
    "lib/box.js"(exports, module) {
      "use strict";
      module.exports = require_box();
    }
  });

  // src/traces/heatmap/attributes.js
  var require_attributes25 = __commonJS({
    "src/traces/heatmap/attributes.js"(exports, module) {
      "use strict";
      var scatterAttrs = require_attributes12();
      var baseAttrs = require_attributes2();
      var fontAttrs = require_font_attributes();
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var texttemplateAttrs = require_template_attributes().texttemplateAttrs;
      var colorScaleAttrs = require_attributes8();
      var extendFlat = require_extend().extendFlat;
      module.exports = extendFlat(
        {
          z: {
            valType: "data_array",
            editType: "calc"
          },
          x: extendFlat({}, scatterAttrs.x, { impliedEdits: { xtype: "array" } }),
          x0: extendFlat({}, scatterAttrs.x0, { impliedEdits: { xtype: "scaled" } }),
          dx: extendFlat({}, scatterAttrs.dx, { impliedEdits: { xtype: "scaled" } }),
          y: extendFlat({}, scatterAttrs.y, { impliedEdits: { ytype: "array" } }),
          y0: extendFlat({}, scatterAttrs.y0, { impliedEdits: { ytype: "scaled" } }),
          dy: extendFlat({}, scatterAttrs.dy, { impliedEdits: { ytype: "scaled" } }),
          xperiod: extendFlat({}, scatterAttrs.xperiod, { impliedEdits: { xtype: "scaled" } }),
          yperiod: extendFlat({}, scatterAttrs.yperiod, { impliedEdits: { ytype: "scaled" } }),
          xperiod0: extendFlat({}, scatterAttrs.xperiod0, { impliedEdits: { xtype: "scaled" } }),
          yperiod0: extendFlat({}, scatterAttrs.yperiod0, { impliedEdits: { ytype: "scaled" } }),
          xperiodalignment: extendFlat({}, scatterAttrs.xperiodalignment, { impliedEdits: { xtype: "scaled" } }),
          yperiodalignment: extendFlat({}, scatterAttrs.yperiodalignment, { impliedEdits: { ytype: "scaled" } }),
          text: {
            valType: "data_array",
            editType: "calc"
          },
          hovertext: {
            valType: "data_array",
            editType: "calc"
          },
          transpose: {
            valType: "boolean",
            dflt: false,
            editType: "calc"
          },
          xtype: {
            valType: "enumerated",
            values: ["array", "scaled"],
            editType: "calc+clearAxisTypes"
          },
          ytype: {
            valType: "enumerated",
            values: ["array", "scaled"],
            editType: "calc+clearAxisTypes"
          },
          zsmooth: {
            valType: "enumerated",
            values: ["fast", "best", false],
            dflt: false,
            editType: "calc"
          },
          hoverongaps: {
            valType: "boolean",
            dflt: true,
            editType: "none"
          },
          connectgaps: {
            valType: "boolean",
            editType: "calc"
          },
          xgap: {
            valType: "number",
            dflt: 0,
            min: 0,
            editType: "plot"
          },
          ygap: {
            valType: "number",
            dflt: 0,
            min: 0,
            editType: "plot"
          },
          xhoverformat: axisHoverFormat("x"),
          yhoverformat: axisHoverFormat("y"),
          zhoverformat: axisHoverFormat("z", 1),
          hovertemplate: hovertemplateAttrs(),
          texttemplate: texttemplateAttrs({
            arrayOk: false,
            editType: "plot"
          }, {
            keys: ["x", "y", "z", "text"]
          }),
          textfont: fontAttrs({
            editType: "plot",
            autoSize: true,
            autoColor: true,
            colorEditType: "style"
          }),
          showlegend: extendFlat({}, baseAttrs.showlegend, { dflt: false }),
          zorder: scatterAttrs.zorder
        },
        colorScaleAttrs("", { cLetter: "z", autoColorDflt: false })
      );
    }
  });

  // src/traces/heatmap/xyz_defaults.js
  var require_xyz_defaults = __commonJS({
    "src/traces/heatmap/xyz_defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Registry = require_registry();
      module.exports = function handleXYZDefaults(traceIn, traceOut, coerce, layout, xName, yName) {
        var z = coerce("z");
        xName = xName || "x";
        yName = yName || "y";
        var x, y;
        if (z === void 0 || !z.length) return 0;
        if (Lib.isArray1D(z)) {
          x = coerce(xName);
          y = coerce(yName);
          var xlen = Lib.minRowLength(x);
          var ylen = Lib.minRowLength(y);
          if (xlen === 0 || ylen === 0) return 0;
          traceOut._length = Math.min(xlen, ylen, z.length);
        } else {
          x = coordDefaults(xName, coerce);
          y = coordDefaults(yName, coerce);
          if (!isValidZ(z)) return 0;
          coerce("transpose");
          traceOut._length = null;
        }
        var handleCalendarDefaults = Registry.getComponentMethod("calendars", "handleTraceDefaults");
        handleCalendarDefaults(traceIn, traceOut, [xName, yName], layout);
        return true;
      };
      function coordDefaults(coordStr, coerce) {
        var coord = coerce(coordStr);
        var coordType = coord ? coerce(coordStr + "type", "array") : "scaled";
        if (coordType === "scaled") {
          coerce(coordStr + "0");
          coerce("d" + coordStr);
        }
        return coord;
      }
      function isValidZ(z) {
        var allRowsAreArrays = true;
        var oneRowIsFilled = false;
        var hasOneNumber = false;
        var zi;
        for (var i = 0; i < z.length; i++) {
          zi = z[i];
          if (!Lib.isArrayOrTypedArray(zi)) {
            allRowsAreArrays = false;
            break;
          }
          if (zi.length > 0) oneRowIsFilled = true;
          for (var j = 0; j < zi.length; j++) {
            if (isNumeric(zi[j])) {
              hasOneNumber = true;
              break;
            }
          }
        }
        return allRowsAreArrays && oneRowIsFilled && hasOneNumber;
      }
    }
  });

  // src/traces/heatmap/label_defaults.js
  var require_label_defaults = __commonJS({
    "src/traces/heatmap/label_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function handleHeatmapLabelDefaults(coerce, layout) {
        coerce("texttemplate");
        var fontDflt = Lib.extendFlat({}, layout.font, {
          color: "auto",
          size: "auto"
        });
        Lib.coerceFont(coerce, "textfont", fontDflt);
      };
    }
  });

  // src/traces/heatmap/style_defaults.js
  var require_style_defaults2 = __commonJS({
    "src/traces/heatmap/style_defaults.js"(exports, module) {
      "use strict";
      module.exports = function handleStyleDefaults(traceIn, traceOut, coerce) {
        var zsmooth = coerce("zsmooth");
        if (zsmooth === false) {
          coerce("xgap");
          coerce("ygap");
        }
        coerce("zhoverformat");
      };
    }
  });

  // src/traces/heatmap/defaults.js
  var require_defaults21 = __commonJS({
    "src/traces/heatmap/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleXYZDefaults = require_xyz_defaults();
      var handleHeatmapLabelDefaults = require_label_defaults();
      var handlePeriodDefaults = require_period_defaults();
      var handleStyleDefaults = require_style_defaults2();
      var colorscaleDefaults = require_defaults2();
      var attributes = require_attributes25();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var validData = handleXYZDefaults(traceIn, traceOut, coerce, layout);
        if (!validData) {
          traceOut.visible = false;
          return;
        }
        handlePeriodDefaults(traceIn, traceOut, layout, coerce);
        coerce("xhoverformat");
        coerce("yhoverformat");
        coerce("text");
        coerce("hovertext");
        coerce("hovertemplate");
        handleHeatmapLabelDefaults(coerce, layout);
        handleStyleDefaults(traceIn, traceOut, coerce, layout);
        coerce("hoverongaps");
        coerce("connectgaps", Lib.isArray1D(traceOut.z) && traceOut.zsmooth !== false);
        colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "", cLetter: "z" });
        coerce("zorder");
      };
    }
  });

  // src/traces/histogram/bin_functions.js
  var require_bin_functions = __commonJS({
    "src/traces/histogram/bin_functions.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      module.exports = {
        count: function(n, i, size) {
          size[n]++;
          return 1;
        },
        sum: function(n, i, size, counterData) {
          var v = counterData[i];
          if (isNumeric(v)) {
            v = Number(v);
            size[n] += v;
            return v;
          }
          return 0;
        },
        avg: function(n, i, size, counterData, counts) {
          var v = counterData[i];
          if (isNumeric(v)) {
            v = Number(v);
            size[n] += v;
            counts[n]++;
          }
          return 0;
        },
        min: function(n, i, size, counterData) {
          var v = counterData[i];
          if (isNumeric(v)) {
            v = Number(v);
            if (!isNumeric(size[n])) {
              size[n] = v;
              return v;
            } else if (size[n] > v) {
              var delta = v - size[n];
              size[n] = v;
              return delta;
            }
          }
          return 0;
        },
        max: function(n, i, size, counterData) {
          var v = counterData[i];
          if (isNumeric(v)) {
            v = Number(v);
            if (!isNumeric(size[n])) {
              size[n] = v;
              return v;
            } else if (size[n] < v) {
              var delta = v - size[n];
              size[n] = v;
              return delta;
            }
          }
          return 0;
        }
      };
    }
  });

  // src/traces/histogram/norm_functions.js
  var require_norm_functions = __commonJS({
    "src/traces/histogram/norm_functions.js"(exports, module) {
      "use strict";
      module.exports = {
        percent: function(size, total) {
          var nMax = size.length;
          var norm = 100 / total;
          for (var n = 0; n < nMax; n++) size[n] *= norm;
        },
        probability: function(size, total) {
          var nMax = size.length;
          for (var n = 0; n < nMax; n++) size[n] /= total;
        },
        density: function(size, total, inc, yinc) {
          var nMax = size.length;
          yinc = yinc || 1;
          for (var n = 0; n < nMax; n++) size[n] *= inc[n] * yinc;
        },
        "probability density": function(size, total, inc, yinc) {
          var nMax = size.length;
          if (yinc) total /= yinc;
          for (var n = 0; n < nMax; n++) size[n] *= inc[n] / total;
        }
      };
    }
  });

  // src/traces/histogram/average.js
  var require_average = __commonJS({
    "src/traces/histogram/average.js"(exports, module) {
      "use strict";
      module.exports = function doAvg(size, counts) {
        var nMax = size.length;
        var total = 0;
        for (var i = 0; i < nMax; i++) {
          if (counts[i]) {
            size[i] /= counts[i];
            total += size[i];
          } else size[i] = null;
        }
        return total;
      };
    }
  });

  // src/traces/histogram/bin_label_vals.js
  var require_bin_label_vals = __commonJS({
    "src/traces/histogram/bin_label_vals.js"(exports, module) {
      "use strict";
      var numConstants = require_numerical();
      var oneYear = numConstants.ONEAVGYEAR;
      var oneMonth = numConstants.ONEAVGMONTH;
      var oneDay = numConstants.ONEDAY;
      var oneHour = numConstants.ONEHOUR;
      var oneMin = numConstants.ONEMIN;
      var oneSec = numConstants.ONESEC;
      var tickIncrement = require_axes().tickIncrement;
      module.exports = function getBinSpanLabelRound(leftGap, rightGap, binEdges, pa, calendar) {
        var dv0 = -1.1 * rightGap;
        var dv1 = -0.1 * rightGap;
        var dv2 = leftGap - dv1;
        var edge0 = binEdges[0];
        var edge1 = binEdges[1];
        var leftDigit = Math.min(
          biggestDigitChanged(edge0 + dv1, edge0 + dv2, pa, calendar),
          biggestDigitChanged(edge1 + dv1, edge1 + dv2, pa, calendar)
        );
        var rightDigit = Math.min(
          biggestDigitChanged(edge0 + dv0, edge0 + dv1, pa, calendar),
          biggestDigitChanged(edge1 + dv0, edge1 + dv1, pa, calendar)
        );
        var digit, disambiguateEdges;
        if (leftDigit > rightDigit && rightDigit < Math.abs(edge1 - edge0) / 4e3) {
          digit = leftDigit;
          disambiguateEdges = false;
        } else {
          digit = Math.min(leftDigit, rightDigit);
          disambiguateEdges = true;
        }
        if (pa.type === "date" && digit > oneDay) {
          var dashExclude = digit === oneYear ? 1 : 6;
          var increment = digit === oneYear ? "M12" : "M1";
          return function(v, isRightEdge) {
            var dateStr = pa.c2d(v, oneYear, calendar);
            var dashPos = dateStr.indexOf("-", dashExclude);
            if (dashPos > 0) dateStr = dateStr.substr(0, dashPos);
            var roundedV = pa.d2c(dateStr, 0, calendar);
            if (roundedV < v) {
              var nextV = tickIncrement(roundedV, increment, false, calendar);
              if ((roundedV + nextV) / 2 < v + leftGap) roundedV = nextV;
            }
            if (isRightEdge && disambiguateEdges) {
              return tickIncrement(roundedV, increment, true, calendar);
            }
            return roundedV;
          };
        }
        return function(v, isRightEdge) {
          var roundedV = digit * Math.round(v / digit);
          if (roundedV + digit / 10 < v && roundedV + digit * 0.9 < v + leftGap) {
            roundedV += digit;
          }
          if (isRightEdge && disambiguateEdges) {
            roundedV -= digit;
          }
          return roundedV;
        };
      };
      function biggestDigitChanged(v1, v2, pa, calendar) {
        if (v1 * v2 <= 0) return Infinity;
        var dv = Math.abs(v2 - v1);
        var isDate = pa.type === "date";
        var digit = biggestGuaranteedDigitChanged(dv, isDate);
        for (var i = 0; i < 10; i++) {
          var nextDigit = biggestGuaranteedDigitChanged(digit * 80, isDate);
          if (digit === nextDigit) break;
          if (didDigitChange(nextDigit, v1, v2, isDate, pa, calendar)) digit = nextDigit;
          else break;
        }
        return digit;
      }
      function biggestGuaranteedDigitChanged(dv, isDate) {
        if (isDate && dv > oneSec) {
          if (dv > oneDay) {
            if (dv > oneYear * 1.1) return oneYear;
            if (dv > oneMonth * 1.1) return oneMonth;
            return oneDay;
          }
          if (dv > oneHour) return oneHour;
          if (dv > oneMin) return oneMin;
          return oneSec;
        }
        return Math.pow(10, Math.floor(Math.log(dv) / Math.LN10));
      }
      function didDigitChange(digit, v1, v2, isDate, pa, calendar) {
        if (isDate && digit > oneDay) {
          var dateParts1 = dateParts(v1, pa, calendar);
          var dateParts2 = dateParts(v2, pa, calendar);
          var parti = digit === oneYear ? 0 : 1;
          return dateParts1[parti] !== dateParts2[parti];
        }
        return Math.floor(v2 / digit) - Math.floor(v1 / digit) > 0.1;
      }
      function dateParts(v, pa, calendar) {
        var parts = pa.c2d(v, oneYear, calendar).split("-");
        if (parts[0] === "") {
          parts.unshift();
          parts[0] = "-" + parts[0];
        }
        return parts;
      }
    }
  });

  // src/traces/histogram/calc.js
  var require_calc7 = __commonJS({
    "src/traces/histogram/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Registry = require_registry();
      var Axes = require_axes();
      var arraysToCalcdata = require_arrays_to_calcdata2();
      var binFunctions = require_bin_functions();
      var normFunctions = require_norm_functions();
      var doAvg = require_average();
      var getBinSpanLabelRound = require_bin_label_vals();
      function calc(gd, trace) {
        var pos = [];
        var size = [];
        var isHorizontal = trace.orientation === "h";
        var pa = Axes.getFromId(gd, isHorizontal ? trace.yaxis : trace.xaxis);
        var mainData = isHorizontal ? "y" : "x";
        var counterData = { x: "y", y: "x" }[mainData];
        var calendar = trace[mainData + "calendar"];
        var cumulativeSpec = trace.cumulative;
        var i;
        var binsAndPos = calcAllAutoBins(gd, trace, pa, mainData);
        var binSpec = binsAndPos[0];
        var pos0 = binsAndPos[1];
        var nonuniformBins = typeof binSpec.size === "string";
        var binEdges = [];
        var bins = nonuniformBins ? binEdges : binSpec;
        var inc = [];
        var counts = [];
        var inputPoints = [];
        var total = 0;
        var norm = trace.histnorm;
        var func = trace.histfunc;
        var densityNorm = norm.indexOf("density") !== -1;
        var i2, binEnd, n;
        if (cumulativeSpec.enabled && densityNorm) {
          norm = norm.replace(/ ?density$/, "");
          densityNorm = false;
        }
        var extremeFunc = func === "max" || func === "min";
        var sizeInit = extremeFunc ? null : 0;
        var binFunc = binFunctions.count;
        var normFunc = normFunctions[norm];
        var isAvg = false;
        var pr2c = function(v) {
          return pa.r2c(v, 0, calendar);
        };
        var rawCounterData;
        if (Lib.isArrayOrTypedArray(trace[counterData]) && func !== "count") {
          rawCounterData = trace[counterData];
          isAvg = func === "avg";
          binFunc = binFunctions[func];
        }
        i = pr2c(binSpec.start);
        binEnd = pr2c(binSpec.end) + (i - Axes.tickIncrement(i, binSpec.size, false, calendar)) / 1e6;
        while (i < binEnd && pos.length < 1e6) {
          i2 = Axes.tickIncrement(i, binSpec.size, false, calendar);
          pos.push((i + i2) / 2);
          size.push(sizeInit);
          inputPoints.push([]);
          binEdges.push(i);
          if (densityNorm) inc.push(1 / (i2 - i));
          if (isAvg) counts.push(0);
          if (i2 <= i) break;
          i = i2;
        }
        binEdges.push(i);
        if (!nonuniformBins && pa.type === "date") {
          bins = {
            start: pr2c(bins.start),
            end: pr2c(bins.end),
            size: bins.size
          };
        }
        if (!gd._fullLayout._roundFnOpts) gd._fullLayout._roundFnOpts = {};
        var groupName = trace["_" + mainData + "bingroup"];
        var roundFnOpts = { leftGap: Infinity, rightGap: Infinity };
        if (groupName) {
          if (!gd._fullLayout._roundFnOpts[groupName]) gd._fullLayout._roundFnOpts[groupName] = roundFnOpts;
          roundFnOpts = gd._fullLayout._roundFnOpts[groupName];
        }
        var nMax = size.length;
        var uniqueValsPerBin = true;
        var leftGap = roundFnOpts.leftGap;
        var rightGap = roundFnOpts.rightGap;
        var ptNumber2cdIndex = {};
        for (i = 0; i < pos0.length; i++) {
          var posi = pos0[i];
          n = Lib.findBin(posi, bins);
          if (n >= 0 && n < nMax) {
            total += binFunc(n, i, size, rawCounterData, counts);
            if (uniqueValsPerBin && inputPoints[n].length && posi !== pos0[inputPoints[n][0]]) {
              uniqueValsPerBin = false;
            }
            inputPoints[n].push(i);
            ptNumber2cdIndex[i] = n;
            leftGap = Math.min(leftGap, posi - binEdges[n]);
            rightGap = Math.min(rightGap, binEdges[n + 1] - posi);
          }
        }
        roundFnOpts.leftGap = leftGap;
        roundFnOpts.rightGap = rightGap;
        var roundFn;
        if (!uniqueValsPerBin) {
          roundFn = function(v, isRightEdge) {
            return function() {
              var roundFnOpts2 = gd._fullLayout._roundFnOpts[groupName];
              return getBinSpanLabelRound(
                roundFnOpts2.leftGap,
                roundFnOpts2.rightGap,
                binEdges,
                pa,
                calendar
              )(v, isRightEdge);
            };
          };
        }
        if (isAvg) total = doAvg(size, counts);
        if (normFunc) normFunc(size, total, inc);
        if (cumulativeSpec.enabled) cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);
        var seriesLen = Math.min(pos.length, size.length);
        var cd = [];
        var firstNonzero = 0;
        var lastNonzero = seriesLen - 1;
        for (i = 0; i < seriesLen; i++) {
          if (size[i]) {
            firstNonzero = i;
            break;
          }
        }
        for (i = seriesLen - 1; i >= firstNonzero; i--) {
          if (size[i]) {
            lastNonzero = i;
            break;
          }
        }
        for (i = firstNonzero; i <= lastNonzero; i++) {
          if (isNumeric(pos[i]) && isNumeric(size[i])) {
            var cdi = {
              p: pos[i],
              s: size[i],
              b: 0
            };
            if (!cumulativeSpec.enabled) {
              cdi.pts = inputPoints[i];
              if (uniqueValsPerBin) {
                cdi.ph0 = cdi.ph1 = inputPoints[i].length ? pos0[inputPoints[i][0]] : pos[i];
              } else {
                trace._computePh = true;
                cdi.ph0 = roundFn(binEdges[i]);
                cdi.ph1 = roundFn(binEdges[i + 1], true);
              }
            }
            cd.push(cdi);
          }
        }
        if (cd.length === 1) {
          cd[0].width1 = Axes.tickIncrement(cd[0].p, binSpec.size, false, calendar) - cd[0].p;
        }
        arraysToCalcdata(cd, trace);
        if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {
          Lib.tagSelected(cd, trace, ptNumber2cdIndex);
        }
        return cd;
      }
      function calcAllAutoBins(gd, trace, pa, mainData, _overlayEdgeCase) {
        var binAttr = mainData + "bins";
        var fullLayout = gd._fullLayout;
        var groupName = trace["_" + mainData + "bingroup"];
        var binOpts = fullLayout._histogramBinOpts[groupName];
        var isOverlay = fullLayout.barmode === "overlay";
        var i, traces, tracei, calendar, pos0, autoVals, cumulativeSpec;
        var r2c = function(v) {
          return pa.r2c(v, 0, calendar);
        };
        var c2r = function(v) {
          return pa.c2r(v, 0, calendar);
        };
        var cleanBound = pa.type === "date" ? function(v) {
          return v || v === 0 ? Lib.cleanDate(v, null, calendar) : null;
        } : function(v) {
          return isNumeric(v) ? Number(v) : null;
        };
        function setBound(attr, bins, newBins) {
          if (bins[attr + "Found"]) {
            bins[attr] = cleanBound(bins[attr]);
            if (bins[attr] === null) bins[attr] = newBins[attr];
          } else {
            autoVals[attr] = bins[attr] = newBins[attr];
            Lib.nestedProperty(traces[0], binAttr + "." + attr).set(newBins[attr]);
          }
        }
        if (trace["_" + mainData + "autoBinFinished"]) {
          delete trace["_" + mainData + "autoBinFinished"];
        } else {
          traces = binOpts.traces;
          var allPos = [];
          var isFirstVisible = true;
          var has2dMap = false;
          var hasHist2dContour = false;
          for (i = 0; i < traces.length; i++) {
            tracei = traces[i];
            if (tracei.visible) {
              var mainDatai = binOpts.dirs[i];
              pos0 = tracei["_" + mainDatai + "pos0"] = pa.makeCalcdata(tracei, mainDatai);
              allPos = Lib.concat(allPos, pos0);
              delete tracei["_" + mainData + "autoBinFinished"];
              if (trace.visible === true) {
                if (isFirstVisible) {
                  isFirstVisible = false;
                } else {
                  delete tracei._autoBin;
                  tracei["_" + mainData + "autoBinFinished"] = 1;
                }
                if (Registry.traceIs(tracei, "2dMap")) {
                  has2dMap = true;
                }
                if (tracei.type === "histogram2dcontour") {
                  hasHist2dContour = true;
                }
              }
            }
          }
          calendar = traces[0][mainData + "calendar"];
          var newBinSpec = Axes.autoBin(allPos, pa, binOpts.nbins, has2dMap, calendar, binOpts.sizeFound && binOpts.size);
          var autoBin = traces[0]._autoBin = {};
          autoVals = autoBin[binOpts.dirs[0]] = {};
          if (hasHist2dContour) {
            if (!binOpts.size) {
              newBinSpec.start = c2r(Axes.tickIncrement(
                r2c(newBinSpec.start),
                newBinSpec.size,
                true,
                calendar
              ));
            }
            if (binOpts.end === void 0) {
              newBinSpec.end = c2r(Axes.tickIncrement(
                r2c(newBinSpec.end),
                newBinSpec.size,
                false,
                calendar
              ));
            }
          }
          if (isOverlay && !Registry.traceIs(trace, "2dMap") && newBinSpec._dataSpan === 0 && pa.type !== "category" && pa.type !== "multicategory" && trace.bingroup === "" && typeof trace.xbins === "undefined") {
            if (_overlayEdgeCase) return [newBinSpec, pos0, true];
            newBinSpec = handleSingleValueOverlays(gd, trace, pa, mainData, binAttr);
          }
          cumulativeSpec = tracei.cumulative || {};
          if (cumulativeSpec.enabled && cumulativeSpec.currentbin !== "include") {
            if (cumulativeSpec.direction === "decreasing") {
              newBinSpec.start = c2r(Axes.tickIncrement(
                r2c(newBinSpec.start),
                newBinSpec.size,
                true,
                calendar
              ));
            } else {
              newBinSpec.end = c2r(Axes.tickIncrement(
                r2c(newBinSpec.end),
                newBinSpec.size,
                false,
                calendar
              ));
            }
          }
          binOpts.size = newBinSpec.size;
          if (!binOpts.sizeFound) {
            autoVals.size = newBinSpec.size;
            Lib.nestedProperty(traces[0], binAttr + ".size").set(newBinSpec.size);
          }
          setBound("start", binOpts, newBinSpec);
          setBound("end", binOpts, newBinSpec);
        }
        pos0 = trace["_" + mainData + "pos0"];
        delete trace["_" + mainData + "pos0"];
        var traceInputBins = trace._input[binAttr] || {};
        var traceBinOptsCalc = Lib.extendFlat({}, binOpts);
        var mainStart = binOpts.start;
        var startIn = pa.r2l(traceInputBins.start);
        var hasStart = startIn !== void 0;
        if ((binOpts.startFound || hasStart) && startIn !== pa.r2l(mainStart)) {
          var traceStart = hasStart ? startIn : Lib.aggNums(Math.min, null, pos0);
          var dummyAx = {
            type: pa.type === "category" || pa.type === "multicategory" ? "linear" : pa.type,
            r2l: pa.r2l,
            dtick: binOpts.size,
            tick0: mainStart,
            calendar,
            range: [traceStart, Axes.tickIncrement(traceStart, binOpts.size, false, calendar)].map(pa.l2r)
          };
          var newStart = Axes.tickFirst(dummyAx);
          if (newStart > pa.r2l(traceStart)) {
            newStart = Axes.tickIncrement(newStart, binOpts.size, true, calendar);
          }
          traceBinOptsCalc.start = pa.l2r(newStart);
          if (!hasStart) Lib.nestedProperty(trace, binAttr + ".start").set(traceBinOptsCalc.start);
        }
        var mainEnd = binOpts.end;
        var endIn = pa.r2l(traceInputBins.end);
        var hasEnd = endIn !== void 0;
        if ((binOpts.endFound || hasEnd) && endIn !== pa.r2l(mainEnd)) {
          var traceEnd = hasEnd ? endIn : Lib.aggNums(Math.max, null, pos0);
          traceBinOptsCalc.end = pa.l2r(traceEnd);
          if (!hasEnd) Lib.nestedProperty(trace, binAttr + ".start").set(traceBinOptsCalc.end);
        }
        var autoBinAttr = "autobin" + mainData;
        if (trace._input[autoBinAttr] === false) {
          trace._input[binAttr] = Lib.extendFlat({}, trace[binAttr] || {});
          delete trace._input[autoBinAttr];
          delete trace[autoBinAttr];
        }
        return [traceBinOptsCalc, pos0];
      }
      function handleSingleValueOverlays(gd, trace, pa, mainData, binAttr) {
        var fullLayout = gd._fullLayout;
        var overlaidTraceGroup = getConnectedHistograms(gd, trace);
        var pastThisTrace = false;
        var minSize = Infinity;
        var singleValuedTraces = [trace];
        var i, tracei, binOpts;
        for (i = 0; i < overlaidTraceGroup.length; i++) {
          tracei = overlaidTraceGroup[i];
          if (tracei === trace) {
            pastThisTrace = true;
          } else if (!pastThisTrace) {
            binOpts = fullLayout._histogramBinOpts[tracei["_" + mainData + "bingroup"]];
            minSize = Math.min(minSize, binOpts.size || tracei[binAttr].size);
          } else {
            var resulti = calcAllAutoBins(gd, tracei, pa, mainData, true);
            var binSpeci = resulti[0];
            var isSingleValued = resulti[2];
            tracei["_" + mainData + "autoBinFinished"] = 1;
            tracei["_" + mainData + "pos0"] = resulti[1];
            if (isSingleValued) {
              singleValuedTraces.push(tracei);
            } else {
              minSize = Math.min(minSize, binSpeci.size);
            }
          }
        }
        var dataVals = new Array(singleValuedTraces.length);
        for (i = 0; i < singleValuedTraces.length; i++) {
          var pos0 = singleValuedTraces[i]["_" + mainData + "pos0"];
          for (var j = 0; j < pos0.length; j++) {
            if (pos0[j] !== void 0) {
              dataVals[i] = pos0[j];
              break;
            }
          }
        }
        if (!isFinite(minSize)) {
          minSize = Lib.distinctVals(dataVals).minDiff;
        }
        for (i = 0; i < singleValuedTraces.length; i++) {
          tracei = singleValuedTraces[i];
          var calendar = tracei[mainData + "calendar"];
          var newBins = {
            start: pa.c2r(dataVals[i] - minSize / 2, 0, calendar),
            end: pa.c2r(dataVals[i] + minSize / 2, 0, calendar),
            size: minSize
          };
          tracei._input[binAttr] = tracei[binAttr] = newBins;
          binOpts = fullLayout._histogramBinOpts[tracei["_" + mainData + "bingroup"]];
          if (binOpts) Lib.extendFlat(binOpts, newBins);
        }
        return trace[binAttr];
      }
      function getConnectedHistograms(gd, trace) {
        var xid = trace.xaxis;
        var yid = trace.yaxis;
        var orientation = trace.orientation;
        var out = [];
        var fullData = gd._fullData;
        for (var i = 0; i < fullData.length; i++) {
          var tracei = fullData[i];
          if (tracei.type === "histogram" && tracei.visible === true && tracei.orientation === orientation && tracei.xaxis === xid && tracei.yaxis === yid) {
            out.push(tracei);
          }
        }
        return out;
      }
      function cdf(size, direction, currentBin) {
        var i, vi, prevSum;
        function firstHalfPoint(i2) {
          prevSum = size[i2];
          size[i2] /= 2;
        }
        function nextHalfPoint(i2) {
          vi = size[i2];
          size[i2] = prevSum + vi / 2;
          prevSum += vi;
        }
        if (currentBin === "half") {
          if (direction === "increasing") {
            firstHalfPoint(0);
            for (i = 1; i < size.length; i++) {
              nextHalfPoint(i);
            }
          } else {
            firstHalfPoint(size.length - 1);
            for (i = size.length - 2; i >= 0; i--) {
              nextHalfPoint(i);
            }
          }
        } else if (direction === "increasing") {
          for (i = 1; i < size.length; i++) {
            size[i] += size[i - 1];
          }
          if (currentBin === "exclude") {
            size.unshift(0);
            size.pop();
          }
        } else {
          for (i = size.length - 2; i >= 0; i--) {
            size[i] += size[i + 1];
          }
          if (currentBin === "exclude") {
            size.push(0);
            size.shift();
          }
        }
      }
      module.exports = {
        calc,
        calcAllAutoBins
      };
    }
  });

  // src/traces/histogram2d/calc.js
  var require_calc8 = __commonJS({
    "src/traces/histogram2d/calc.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var binFunctions = require_bin_functions();
      var normFunctions = require_norm_functions();
      var doAvg = require_average();
      var getBinSpanLabelRound = require_bin_label_vals();
      var calcAllAutoBins = require_calc7().calcAllAutoBins;
      module.exports = function calc(gd, trace) {
        var xa = Axes.getFromId(gd, trace.xaxis);
        var ya = Axes.getFromId(gd, trace.yaxis);
        var xcalendar = trace.xcalendar;
        var ycalendar = trace.ycalendar;
        var xr2c = function(v) {
          return xa.r2c(v, 0, xcalendar);
        };
        var yr2c = function(v) {
          return ya.r2c(v, 0, ycalendar);
        };
        var xc2r = function(v) {
          return xa.c2r(v, 0, xcalendar);
        };
        var yc2r = function(v) {
          return ya.c2r(v, 0, ycalendar);
        };
        var i, j, n, m;
        var xBinsAndPos = calcAllAutoBins(gd, trace, xa, "x");
        var xBinSpec = xBinsAndPos[0];
        var xPos0 = xBinsAndPos[1];
        var yBinsAndPos = calcAllAutoBins(gd, trace, ya, "y");
        var yBinSpec = yBinsAndPos[0];
        var yPos0 = yBinsAndPos[1];
        var serieslen = trace._length;
        if (xPos0.length > serieslen) xPos0.splice(serieslen, xPos0.length - serieslen);
        if (yPos0.length > serieslen) yPos0.splice(serieslen, yPos0.length - serieslen);
        var z = [];
        var onecol = [];
        var zerocol = [];
        var nonuniformBinsX = typeof xBinSpec.size === "string";
        var nonuniformBinsY = typeof yBinSpec.size === "string";
        var xEdges = [];
        var yEdges = [];
        var xbins = nonuniformBinsX ? xEdges : xBinSpec;
        var ybins = nonuniformBinsY ? yEdges : yBinSpec;
        var total = 0;
        var counts = [];
        var inputPoints = [];
        var norm = trace.histnorm;
        var func = trace.histfunc;
        var densitynorm = norm.indexOf("density") !== -1;
        var extremefunc = func === "max" || func === "min";
        var sizeinit = extremefunc ? null : 0;
        var binfunc = binFunctions.count;
        var normfunc = normFunctions[norm];
        var doavg = false;
        var xinc = [];
        var yinc = [];
        var rawCounterData = "z" in trace ? trace.z : "marker" in trace && Array.isArray(trace.marker.color) ? trace.marker.color : "";
        if (rawCounterData && func !== "count") {
          doavg = func === "avg";
          binfunc = binFunctions[func];
        }
        var xBinSize = xBinSpec.size;
        var xBinStart = xr2c(xBinSpec.start);
        var xBinEnd = xr2c(xBinSpec.end) + (xBinStart - Axes.tickIncrement(xBinStart, xBinSize, false, xcalendar)) / 1e6;
        for (i = xBinStart; i < xBinEnd; i = Axes.tickIncrement(i, xBinSize, false, xcalendar)) {
          onecol.push(sizeinit);
          xEdges.push(i);
          if (doavg) zerocol.push(0);
        }
        xEdges.push(i);
        var nx = onecol.length;
        var dx = (i - xBinStart) / nx;
        var x0 = xc2r(xBinStart + dx / 2);
        var yBinSize = yBinSpec.size;
        var yBinStart = yr2c(yBinSpec.start);
        var yBinEnd = yr2c(yBinSpec.end) + (yBinStart - Axes.tickIncrement(yBinStart, yBinSize, false, ycalendar)) / 1e6;
        for (i = yBinStart; i < yBinEnd; i = Axes.tickIncrement(i, yBinSize, false, ycalendar)) {
          z.push(onecol.slice());
          yEdges.push(i);
          var ipCol = new Array(nx);
          for (j = 0; j < nx; j++) ipCol[j] = [];
          inputPoints.push(ipCol);
          if (doavg) counts.push(zerocol.slice());
        }
        yEdges.push(i);
        var ny = z.length;
        var dy = (i - yBinStart) / ny;
        var y0 = yc2r(yBinStart + dy / 2);
        if (densitynorm) {
          xinc = makeIncrements(onecol.length, xbins, dx, nonuniformBinsX);
          yinc = makeIncrements(z.length, ybins, dy, nonuniformBinsY);
        }
        if (!nonuniformBinsX && xa.type === "date") xbins = binsToCalc(xr2c, xbins);
        if (!nonuniformBinsY && ya.type === "date") ybins = binsToCalc(yr2c, ybins);
        var uniqueValsPerX = true;
        var uniqueValsPerY = true;
        var xVals = new Array(nx);
        var yVals = new Array(ny);
        var xGapLow = Infinity;
        var xGapHigh = Infinity;
        var yGapLow = Infinity;
        var yGapHigh = Infinity;
        for (i = 0; i < serieslen; i++) {
          var xi = xPos0[i];
          var yi = yPos0[i];
          n = Lib.findBin(xi, xbins);
          m = Lib.findBin(yi, ybins);
          if (n >= 0 && n < nx && m >= 0 && m < ny) {
            total += binfunc(n, i, z[m], rawCounterData, counts[m]);
            inputPoints[m][n].push(i);
            if (uniqueValsPerX) {
              if (xVals[n] === void 0) xVals[n] = xi;
              else if (xVals[n] !== xi) uniqueValsPerX = false;
            }
            if (uniqueValsPerY) {
              if (yVals[m] === void 0) yVals[m] = yi;
              else if (yVals[m] !== yi) uniqueValsPerY = false;
            }
            xGapLow = Math.min(xGapLow, xi - xEdges[n]);
            xGapHigh = Math.min(xGapHigh, xEdges[n + 1] - xi);
            yGapLow = Math.min(yGapLow, yi - yEdges[m]);
            yGapHigh = Math.min(yGapHigh, yEdges[m + 1] - yi);
          }
        }
        if (doavg) {
          for (m = 0; m < ny; m++) total += doAvg(z[m], counts[m]);
        }
        if (normfunc) {
          for (m = 0; m < ny; m++) normfunc(z[m], total, xinc, yinc[m]);
        }
        return {
          x: xPos0,
          xRanges: getRanges(xEdges, uniqueValsPerX && xVals, xGapLow, xGapHigh, xa, xcalendar),
          x0,
          dx,
          y: yPos0,
          yRanges: getRanges(yEdges, uniqueValsPerY && yVals, yGapLow, yGapHigh, ya, ycalendar),
          y0,
          dy,
          z,
          pts: inputPoints
        };
      };
      function makeIncrements(len, bins, dv, nonuniform) {
        var out = new Array(len);
        var i;
        if (nonuniform) {
          for (i = 0; i < len; i++) out[i] = 1 / (bins[i + 1] - bins[i]);
        } else {
          var inc = 1 / dv;
          for (i = 0; i < len; i++) out[i] = inc;
        }
        return out;
      }
      function binsToCalc(r2c, bins) {
        return {
          start: r2c(bins.start),
          end: r2c(bins.end),
          size: bins.size
        };
      }
      function getRanges(edges, uniqueVals, gapLow, gapHigh, ax, calendar) {
        var i;
        var len = edges.length - 1;
        var out = new Array(len);
        var roundFn = getBinSpanLabelRound(gapLow, gapHigh, edges, ax, calendar);
        for (i = 0; i < len; i++) {
          var v = (uniqueVals || [])[i];
          out[i] = v === void 0 ? [roundFn(edges[i]), roundFn(edges[i + 1], true)] : [v, v];
        }
        return out;
      }
    }
  });

  // src/traces/heatmap/convert_column_xyz.js
  var require_convert_column_xyz = __commonJS({
    "src/traces/heatmap/convert_column_xyz.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var BADNUM = require_numerical().BADNUM;
      var alignPeriod = require_align_period();
      module.exports = function convertColumnData(trace, ax1, ax2, var1Name, var2Name, arrayVarNames) {
        var colLen = trace._length;
        var col1 = ax1.makeCalcdata(trace, var1Name);
        var col2 = ax2.makeCalcdata(trace, var2Name);
        col1 = alignPeriod(trace, ax1, var1Name, col1).vals;
        col2 = alignPeriod(trace, ax2, var2Name, col2).vals;
        var textCol = trace.text;
        var hasColumnText = textCol !== void 0 && Lib.isArray1D(textCol);
        var hoverTextCol = trace.hovertext;
        var hasColumnHoverText = hoverTextCol !== void 0 && Lib.isArray1D(hoverTextCol);
        var i, j;
        var col1dv = Lib.distinctVals(col1);
        var col1vals = col1dv.vals;
        var col2dv = Lib.distinctVals(col2);
        var col2vals = col2dv.vals;
        var newArrays = [];
        var text;
        var hovertext;
        var nI = col2vals.length;
        var nJ = col1vals.length;
        for (i = 0; i < arrayVarNames.length; i++) {
          newArrays[i] = Lib.init2dArray(nI, nJ);
        }
        if (hasColumnText) {
          text = Lib.init2dArray(nI, nJ);
        }
        if (hasColumnHoverText) {
          hovertext = Lib.init2dArray(nI, nJ);
        }
        var after2before = Lib.init2dArray(nI, nJ);
        for (i = 0; i < colLen; i++) {
          if (col1[i] !== BADNUM && col2[i] !== BADNUM) {
            var i1 = Lib.findBin(col1[i] + col1dv.minDiff / 2, col1vals);
            var i2 = Lib.findBin(col2[i] + col2dv.minDiff / 2, col2vals);
            for (j = 0; j < arrayVarNames.length; j++) {
              var arrayVarName = arrayVarNames[j];
              var arrayVar = trace[arrayVarName];
              var newArray = newArrays[j];
              newArray[i2][i1] = arrayVar[i];
              after2before[i2][i1] = i;
            }
            if (hasColumnText) text[i2][i1] = textCol[i];
            if (hasColumnHoverText) hovertext[i2][i1] = hoverTextCol[i];
          }
        }
        trace["_" + var1Name] = col1vals;
        trace["_" + var2Name] = col2vals;
        for (j = 0; j < arrayVarNames.length; j++) {
          trace["_" + arrayVarNames[j]] = newArrays[j];
        }
        if (hasColumnText) trace._text = text;
        if (hasColumnHoverText) trace._hovertext = hovertext;
        if (ax1 && ax1.type === "category") {
          trace["_" + var1Name + "CategoryMap"] = col1vals.map(function(v) {
            return ax1._categories[v];
          });
        }
        if (ax2 && ax2.type === "category") {
          trace["_" + var2Name + "CategoryMap"] = col2vals.map(function(v) {
            return ax2._categories[v];
          });
        }
        trace._after2before = after2before;
      };
    }
  });

  // src/traces/heatmap/clean_2d_array.js
  var require_clean_2d_array = __commonJS({
    "src/traces/heatmap/clean_2d_array.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var BADNUM = require_numerical().BADNUM;
      module.exports = function clean2dArray(zOld, trace, xa, ya) {
        var rowlen, collen, getCollen, old2new, i, j;
        function cleanZvalue(v) {
          if (!isNumeric(v)) return void 0;
          return +v;
        }
        if (trace && trace.transpose) {
          rowlen = 0;
          for (i = 0; i < zOld.length; i++) rowlen = Math.max(rowlen, zOld[i].length);
          if (rowlen === 0) return false;
          getCollen = function(zOld2) {
            return zOld2.length;
          };
          old2new = function(zOld2, i2, j2) {
            return (zOld2[j2] || [])[i2];
          };
        } else {
          rowlen = zOld.length;
          getCollen = function(zOld2, i2) {
            return zOld2[i2].length;
          };
          old2new = function(zOld2, i2, j2) {
            return (zOld2[i2] || [])[j2];
          };
        }
        var padOld2new = function(zOld2, i2, j2) {
          if (i2 === BADNUM || j2 === BADNUM) return BADNUM;
          return old2new(zOld2, i2, j2);
        };
        function axisMapping(ax) {
          if (trace && trace.type !== "carpet" && trace.type !== "contourcarpet" && ax && ax.type === "category" && trace["_" + ax._id.charAt(0)].length) {
            var axLetter = ax._id.charAt(0);
            var axMapping = {};
            var traceCategories = trace["_" + axLetter + "CategoryMap"] || trace[axLetter];
            for (i = 0; i < traceCategories.length; i++) {
              axMapping[traceCategories[i]] = i;
            }
            return function(i2) {
              var ind = axMapping[ax._categories[i2]];
              return ind + 1 ? ind : BADNUM;
            };
          } else {
            return Lib.identity;
          }
        }
        var xMap = axisMapping(xa);
        var yMap = axisMapping(ya);
        if (ya && ya.type === "category") rowlen = ya._categories.length;
        var zNew = new Array(rowlen);
        for (i = 0; i < rowlen; i++) {
          if (xa && xa.type === "category") {
            collen = xa._categories.length;
          } else {
            collen = getCollen(zOld, i);
          }
          zNew[i] = new Array(collen);
          for (j = 0; j < collen; j++) zNew[i][j] = cleanZvalue(padOld2new(zOld, yMap(i), xMap(j)));
        }
        return zNew;
      };
    }
  });

  // src/traces/heatmap/interp2d.js
  var require_interp2d = __commonJS({
    "src/traces/heatmap/interp2d.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var INTERPTHRESHOLD = 0.01;
      var NEIGHBORSHIFTS = [[-1, 0], [1, 0], [0, -1], [0, 1]];
      function correctionOvershoot(maxFractionalChange) {
        return 0.5 - 0.25 * Math.min(1, maxFractionalChange * 0.5);
      }
      module.exports = function interp2d(z, emptyPoints) {
        var maxFractionalChange = 1;
        var i;
        iterateInterp2d(z, emptyPoints);
        for (i = 0; i < emptyPoints.length; i++) {
          if (emptyPoints[i][2] < 4) break;
        }
        emptyPoints = emptyPoints.slice(i);
        for (i = 0; i < 100 && maxFractionalChange > INTERPTHRESHOLD; i++) {
          maxFractionalChange = iterateInterp2d(
            z,
            emptyPoints,
            correctionOvershoot(maxFractionalChange)
          );
        }
        if (maxFractionalChange > INTERPTHRESHOLD) {
          Lib.log("interp2d didn't converge quickly", maxFractionalChange);
        }
        return z;
      };
      function iterateInterp2d(z, emptyPoints, overshoot) {
        var maxFractionalChange = 0;
        var thisPt;
        var i;
        var j;
        var p;
        var q;
        var neighborShift;
        var neighborRow;
        var neighborVal;
        var neighborCount;
        var neighborSum;
        var initialVal;
        var minNeighbor;
        var maxNeighbor;
        for (p = 0; p < emptyPoints.length; p++) {
          thisPt = emptyPoints[p];
          i = thisPt[0];
          j = thisPt[1];
          initialVal = z[i][j];
          neighborSum = 0;
          neighborCount = 0;
          for (q = 0; q < 4; q++) {
            neighborShift = NEIGHBORSHIFTS[q];
            neighborRow = z[i + neighborShift[0]];
            if (!neighborRow) continue;
            neighborVal = neighborRow[j + neighborShift[1]];
            if (neighborVal !== void 0) {
              if (neighborSum === 0) {
                minNeighbor = maxNeighbor = neighborVal;
              } else {
                minNeighbor = Math.min(minNeighbor, neighborVal);
                maxNeighbor = Math.max(maxNeighbor, neighborVal);
              }
              neighborCount++;
              neighborSum += neighborVal;
            }
          }
          if (neighborCount === 0) {
            throw "iterateInterp2d order is wrong: no defined neighbors";
          }
          z[i][j] = neighborSum / neighborCount;
          if (initialVal === void 0) {
            if (neighborCount < 4) maxFractionalChange = 1;
          } else {
            z[i][j] = (1 + overshoot) * z[i][j] - overshoot * initialVal;
            if (maxNeighbor > minNeighbor) {
              maxFractionalChange = Math.max(
                maxFractionalChange,
                Math.abs(z[i][j] - initialVal) / (maxNeighbor - minNeighbor)
              );
            }
          }
        }
        return maxFractionalChange;
      }
    }
  });

  // src/traces/heatmap/find_empties.js
  var require_find_empties = __commonJS({
    "src/traces/heatmap/find_empties.js"(exports, module) {
      "use strict";
      var maxRowLength = require_lib().maxRowLength;
      module.exports = function findEmpties(z) {
        var empties = [];
        var neighborHash = {};
        var noNeighborList = [];
        var nextRow = z[0];
        var row = [];
        var blank = [0, 0, 0];
        var rowLength = maxRowLength(z);
        var prevRow;
        var i;
        var j;
        var thisPt;
        var p;
        var neighborCount;
        var newNeighborHash;
        var foundNewNeighbors;
        for (i = 0; i < z.length; i++) {
          prevRow = row;
          row = nextRow;
          nextRow = z[i + 1] || [];
          for (j = 0; j < rowLength; j++) {
            if (row[j] === void 0) {
              neighborCount = (row[j - 1] !== void 0 ? 1 : 0) + (row[j + 1] !== void 0 ? 1 : 0) + (prevRow[j] !== void 0 ? 1 : 0) + (nextRow[j] !== void 0 ? 1 : 0);
              if (neighborCount) {
                if (i === 0) neighborCount++;
                if (j === 0) neighborCount++;
                if (i === z.length - 1) neighborCount++;
                if (j === row.length - 1) neighborCount++;
                if (neighborCount < 4) {
                  neighborHash[[i, j]] = [i, j, neighborCount];
                }
                empties.push([i, j, neighborCount]);
              } else noNeighborList.push([i, j]);
            }
          }
        }
        while (noNeighborList.length) {
          newNeighborHash = {};
          foundNewNeighbors = false;
          for (p = noNeighborList.length - 1; p >= 0; p--) {
            thisPt = noNeighborList[p];
            i = thisPt[0];
            j = thisPt[1];
            neighborCount = ((neighborHash[[i - 1, j]] || blank)[2] + (neighborHash[[i + 1, j]] || blank)[2] + (neighborHash[[i, j - 1]] || blank)[2] + (neighborHash[[i, j + 1]] || blank)[2]) / 20;
            if (neighborCount) {
              newNeighborHash[thisPt] = [i, j, neighborCount];
              noNeighborList.splice(p, 1);
              foundNewNeighbors = true;
            }
          }
          if (!foundNewNeighbors) {
            throw "findEmpties iterated with no new neighbors";
          }
          for (thisPt in newNeighborHash) {
            neighborHash[thisPt] = newNeighborHash[thisPt];
            empties.push(newNeighborHash[thisPt]);
          }
        }
        return empties.sort(function(a, b) {
          return b[2] - a[2];
        });
      };
    }
  });

  // src/traces/heatmap/make_bound_array.js
  var require_make_bound_array = __commonJS({
    "src/traces/heatmap/make_bound_array.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      module.exports = function makeBoundArray(trace, arrayIn, v0In, dvIn, numbricks, ax) {
        var arrayOut = [];
        var isContour = Registry.traceIs(trace, "contour");
        var isHist = Registry.traceIs(trace, "histogram");
        var v0;
        var dv;
        var i;
        var isArrayOfTwoItemsOrMore = isArrayOrTypedArray(arrayIn) && arrayIn.length > 1;
        if (isArrayOfTwoItemsOrMore && !isHist && ax.type !== "category") {
          var len = arrayIn.length;
          if (len <= numbricks) {
            if (isContour) arrayOut = Array.from(arrayIn).slice(0, numbricks);
            else if (numbricks === 1) {
              if (ax.type === "log") {
                arrayOut = [0.5 * arrayIn[0], 2 * arrayIn[0]];
              } else {
                arrayOut = [arrayIn[0] - 0.5, arrayIn[0] + 0.5];
              }
            } else if (ax.type === "log") {
              arrayOut = [Math.pow(arrayIn[0], 1.5) / Math.pow(arrayIn[1], 0.5)];
              for (i = 1; i < len; i++) {
                arrayOut.push(Math.sqrt(arrayIn[i - 1] * arrayIn[i]));
              }
              arrayOut.push(Math.pow(arrayIn[len - 1], 1.5) / Math.pow(arrayIn[len - 2], 0.5));
            } else {
              arrayOut = [1.5 * arrayIn[0] - 0.5 * arrayIn[1]];
              for (i = 1; i < len; i++) {
                arrayOut.push((arrayIn[i - 1] + arrayIn[i]) * 0.5);
              }
              arrayOut.push(1.5 * arrayIn[len - 1] - 0.5 * arrayIn[len - 2]);
            }
            if (len < numbricks) {
              var lastPt = arrayOut[arrayOut.length - 1];
              var delta;
              if (ax.type === "log") {
                delta = lastPt / arrayOut[arrayOut.length - 2];
                for (i = len; i < numbricks; i++) {
                  lastPt *= delta;
                  arrayOut.push(lastPt);
                }
              } else {
                delta = lastPt - arrayOut[arrayOut.length - 2];
                for (i = len; i < numbricks; i++) {
                  lastPt += delta;
                  arrayOut.push(lastPt);
                }
              }
            }
          } else {
            return isContour ? arrayIn.slice(0, numbricks) : (
              // we must be strict for contours
              arrayIn.slice(0, numbricks + 1)
            );
          }
        } else {
          var calendar = trace[ax._id.charAt(0) + "calendar"];
          if (isHist) {
            v0 = ax.r2c(v0In, 0, calendar);
          } else {
            if (isArrayOrTypedArray(arrayIn) && arrayIn.length === 1) {
              v0 = arrayIn[0];
            } else if (v0In === void 0) {
              v0 = 0;
            } else {
              var fn = ax.type === "log" ? ax.d2c : ax.r2c;
              v0 = fn(v0In, 0, calendar);
            }
          }
          dv = dvIn || 1;
          for (i = isContour ? 0 : -0.5; i < numbricks; i++) {
            arrayOut.push(v0 + dv * i);
          }
        }
        return arrayOut;
      };
    }
  });

  // src/traces/heatmap/calc.js
  var require_calc9 = __commonJS({
    "src/traces/heatmap/calc.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var Axes = require_axes();
      var alignPeriod = require_align_period();
      var histogram2dCalc = require_calc8();
      var colorscaleCalc = require_calc();
      var convertColumnData = require_convert_column_xyz();
      var clean2dArray = require_clean_2d_array();
      var interp2d = require_interp2d();
      var findEmpties = require_find_empties();
      var makeBoundArray = require_make_bound_array();
      var BADNUM = require_numerical().BADNUM;
      module.exports = function calc(gd, trace) {
        var xa = Axes.getFromId(gd, trace.xaxis || "x");
        var ya = Axes.getFromId(gd, trace.yaxis || "y");
        var isContour = Registry.traceIs(trace, "contour");
        var isHist = Registry.traceIs(trace, "histogram");
        var zsmooth = isContour ? "best" : trace.zsmooth;
        var x, x0, dx, origX;
        var y, y0, dy, origY;
        var z, i, binned;
        xa._minDtick = 0;
        ya._minDtick = 0;
        if (isHist) {
          binned = histogram2dCalc(gd, trace);
          origX = binned.orig_x;
          x = binned.x;
          x0 = binned.x0;
          dx = binned.dx;
          origY = binned.orig_y;
          y = binned.y;
          y0 = binned.y0;
          dy = binned.dy;
          z = binned.z;
        } else {
          var zIn = trace.z;
          if (Lib.isArray1D(zIn)) {
            convertColumnData(trace, xa, ya, "x", "y", ["z"]);
            x = trace._x;
            y = trace._y;
            zIn = trace._z;
          } else {
            origX = trace.x ? xa.makeCalcdata(trace, "x") : [];
            origY = trace.y ? ya.makeCalcdata(trace, "y") : [];
            x = alignPeriod(trace, xa, "x", origX).vals;
            y = alignPeriod(trace, ya, "y", origY).vals;
            trace._x = x;
            trace._y = y;
          }
          x0 = trace.x0;
          dx = trace.dx;
          y0 = trace.y0;
          dy = trace.dy;
          z = clean2dArray(zIn, trace, xa, ya);
        }
        if (xa.rangebreaks || ya.rangebreaks) {
          z = dropZonBreaks(x, y, z);
          if (!isHist) {
            x = skipBreaks(x);
            y = skipBreaks(y);
            trace._x = x;
            trace._y = y;
          }
        }
        if (!isHist && (isContour || trace.connectgaps)) {
          trace._emptypoints = findEmpties(z);
          interp2d(z, trace._emptypoints);
        }
        function noZsmooth(msg) {
          zsmooth = trace._input.zsmooth = trace.zsmooth = false;
          Lib.warn('cannot use zsmooth: "fast": ' + msg);
        }
        function scaleIsLinear(s) {
          if (s.length > 1) {
            var avgdx = (s[s.length - 1] - s[0]) / (s.length - 1);
            var maxErrX = Math.abs(avgdx / 100);
            for (i = 0; i < s.length - 1; i++) {
              if (Math.abs(s[i + 1] - s[i] - avgdx) > maxErrX) {
                return false;
              }
            }
          }
          return true;
        }
        trace._islinear = false;
        if (xa.type === "log" || ya.type === "log") {
          if (zsmooth === "fast") {
            noZsmooth("log axis found");
          }
        } else if (!scaleIsLinear(x)) {
          if (zsmooth === "fast") noZsmooth("x scale is not linear");
        } else if (!scaleIsLinear(y)) {
          if (zsmooth === "fast") noZsmooth("y scale is not linear");
        } else {
          trace._islinear = true;
        }
        var xlen = Lib.maxRowLength(z);
        var xIn = trace.xtype === "scaled" ? "" : x;
        var xArray = makeBoundArray(trace, xIn, x0, dx, xlen, xa);
        var yIn = trace.ytype === "scaled" ? "" : y;
        var yArray = makeBoundArray(trace, yIn, y0, dy, z.length, ya);
        trace._extremes[xa._id] = Axes.findExtremes(xa, xArray);
        trace._extremes[ya._id] = Axes.findExtremes(ya, yArray);
        var cd0 = {
          x: xArray,
          y: yArray,
          z,
          text: trace._text || trace.text,
          hovertext: trace._hovertext || trace.hovertext
        };
        if (trace.xperiodalignment && origX) {
          cd0.orig_x = origX;
        }
        if (trace.yperiodalignment && origY) {
          cd0.orig_y = origY;
        }
        if (xIn && xIn.length === xArray.length - 1) cd0.xCenter = xIn;
        if (yIn && yIn.length === yArray.length - 1) cd0.yCenter = yIn;
        if (isHist) {
          cd0.xRanges = binned.xRanges;
          cd0.yRanges = binned.yRanges;
          cd0.pts = binned.pts;
        }
        if (!isContour) {
          colorscaleCalc(gd, trace, { vals: z, cLetter: "z" });
        }
        if (isContour && trace.contours && trace.contours.coloring === "heatmap") {
          var dummyTrace = {
            type: trace.type === "contour" ? "heatmap" : "histogram2d",
            xcalendar: trace.xcalendar,
            ycalendar: trace.ycalendar
          };
          cd0.xfill = makeBoundArray(dummyTrace, xIn, x0, dx, xlen, xa);
          cd0.yfill = makeBoundArray(dummyTrace, yIn, y0, dy, z.length, ya);
        }
        return [cd0];
      };
      function skipBreaks(a) {
        var b = [];
        var len = a.length;
        for (var i = 0; i < len; i++) {
          var v = a[i];
          if (v !== BADNUM) b.push(v);
        }
        return b;
      }
      function dropZonBreaks(x, y, z) {
        var newZ = [];
        var k = -1;
        for (var i = 0; i < z.length; i++) {
          if (y[i] === BADNUM) continue;
          k++;
          newZ[k] = [];
          for (var j = 0; j < z[i].length; j++) {
            if (x[j] === BADNUM) continue;
            newZ[k].push(z[i][j]);
          }
        }
        return newZ;
      }
    }
  });

  // src/constants/pixelated_image.js
  var require_pixelated_image = __commonJS({
    "src/constants/pixelated_image.js"(exports) {
      "use strict";
      exports.CSS_DECLARATIONS = [
        ["image-rendering", "optimizeSpeed"],
        ["image-rendering", "-moz-crisp-edges"],
        ["image-rendering", "-o-crisp-edges"],
        ["image-rendering", "-webkit-optimize-contrast"],
        ["image-rendering", "optimize-contrast"],
        ["image-rendering", "crisp-edges"],
        ["image-rendering", "pixelated"]
      ];
      exports.STYLE = exports.CSS_DECLARATIONS.map(function(d) {
        return d.join(": ") + "; ";
      }).join("");
    }
  });

  // src/lib/supports_pixelated_image.js
  var require_supports_pixelated_image = __commonJS({
    "src/lib/supports_pixelated_image.js"(exports, module) {
      "use strict";
      var constants = require_pixelated_image();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var _supportsPixelated = null;
      function supportsPixelatedImage() {
        if (_supportsPixelated !== null) {
          return _supportsPixelated;
        }
        _supportsPixelated = false;
        var unsupportedBrowser = Lib.isSafari() || Lib.isIOS();
        if (window.navigator.userAgent && !unsupportedBrowser) {
          var declarations = Array.from(constants.CSS_DECLARATIONS).reverse();
          var supports = window.CSS && window.CSS.supports || window.supportsCSS;
          if (typeof supports === "function") {
            _supportsPixelated = declarations.some(function(d) {
              return supports.apply(null, d);
            });
          } else {
            var image3 = Drawing.tester.append("image").attr("style", constants.STYLE);
            var cStyles = window.getComputedStyle(image3.node());
            var imageRendering = cStyles.imageRendering;
            _supportsPixelated = declarations.some(function(d) {
              var value = d[1];
              return imageRendering === value || imageRendering === value.toLowerCase();
            });
            image3.remove();
          }
        }
        return _supportsPixelated;
      }
      module.exports = supportsPixelatedImage;
    }
  });

  // src/traces/heatmap/plot.js
  var require_plot5 = __commonJS({
    "src/traces/heatmap/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var tinycolor = require_tinycolor();
      var Registry = require_registry();
      var Drawing = require_drawing();
      var Axes = require_axes();
      var Lib = require_lib();
      var svgTextUtils = require_svg_text_utils();
      var formatLabels = require_format_labels();
      var Color = require_color();
      var extractOpts = require_colorscale().extractOpts;
      var makeColorScaleFuncFromTrace = require_colorscale().makeColorScaleFuncFromTrace;
      var xmlnsNamespaces = require_xmlns_namespaces();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var supportsPixelatedImage = require_supports_pixelated_image();
      var PIXELATED_IMAGE_STYLE = require_pixelated_image().STYLE;
      var labelClass = "heatmap-label";
      function selectLabels(plotGroup) {
        return plotGroup.selectAll("g." + labelClass);
      }
      function removeLabels(plotGroup) {
        selectLabels(plotGroup).remove();
      }
      module.exports = function(gd, plotinfo, cdheatmaps, heatmapLayer) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        Lib.makeTraceGroups(heatmapLayer, cdheatmaps, "hm").each(function(cd) {
          var plotGroup = d3.select(this);
          var cd0 = cd[0];
          var trace = cd0.trace;
          var xGap = trace.xgap || 0;
          var yGap = trace.ygap || 0;
          var z = cd0.z;
          var x = cd0.x;
          var y = cd0.y;
          var xc = cd0.xCenter;
          var yc = cd0.yCenter;
          var isContour = Registry.traceIs(trace, "contour");
          var zsmooth = isContour ? "best" : trace.zsmooth;
          var m = z.length;
          var n = Lib.maxRowLength(z);
          var xrev = false;
          var yrev = false;
          var left, right, temp, top, bottom, i, j, k;
          i = 0;
          while (left === void 0 && i < x.length - 1) {
            left = xa.c2p(x[i]);
            i++;
          }
          i = x.length - 1;
          while (right === void 0 && i > 0) {
            right = xa.c2p(x[i]);
            i--;
          }
          if (right < left) {
            temp = right;
            right = left;
            left = temp;
            xrev = true;
          }
          i = 0;
          while (top === void 0 && i < y.length - 1) {
            top = ya.c2p(y[i]);
            i++;
          }
          i = y.length - 1;
          while (bottom === void 0 && i > 0) {
            bottom = ya.c2p(y[i]);
            i--;
          }
          if (bottom < top) {
            temp = top;
            top = bottom;
            bottom = temp;
            yrev = true;
          }
          if (isContour) {
            xc = x;
            yc = y;
            x = cd0.xfill;
            y = cd0.yfill;
          }
          var drawingMethod = "default";
          if (zsmooth) {
            drawingMethod = zsmooth === "best" ? "smooth" : "fast";
          } else if (trace._islinear && xGap === 0 && yGap === 0 && supportsPixelatedImage()) {
            drawingMethod = "fast";
          }
          if (drawingMethod !== "fast") {
            var extra = zsmooth === "best" ? 0 : 0.5;
            left = Math.max(-extra * xa._length, left);
            right = Math.min((1 + extra) * xa._length, right);
            top = Math.max(-extra * ya._length, top);
            bottom = Math.min((1 + extra) * ya._length, bottom);
          }
          var imageWidth = Math.round(right - left);
          var imageHeight = Math.round(bottom - top);
          var isOffScreen = left >= xa._length || right <= 0 || top >= ya._length || bottom <= 0;
          if (isOffScreen) {
            var noImage = plotGroup.selectAll("image").data([]);
            noImage.exit().remove();
            removeLabels(plotGroup);
            return;
          }
          var canvasW, canvasH;
          if (drawingMethod === "fast") {
            canvasW = n;
            canvasH = m;
          } else {
            canvasW = imageWidth;
            canvasH = imageHeight;
          }
          var canvas = document.createElement("canvas");
          canvas.width = canvasW;
          canvas.height = canvasH;
          var context = canvas.getContext("2d", { willReadFrequently: true });
          var sclFunc = makeColorScaleFuncFromTrace(trace, { noNumericCheck: true, returnArray: true });
          var xpx, ypx;
          if (drawingMethod === "fast") {
            xpx = xrev ? function(index) {
              return n - 1 - index;
            } : Lib.identity;
            ypx = yrev ? function(index) {
              return m - 1 - index;
            } : Lib.identity;
          } else {
            xpx = function(index) {
              return Lib.constrain(
                Math.round(xa.c2p(x[index]) - left),
                0,
                imageWidth
              );
            };
            ypx = function(index) {
              return Lib.constrain(
                Math.round(ya.c2p(y[index]) - top),
                0,
                imageHeight
              );
            };
          }
          var yi = ypx(0);
          var yb = [yi, yi];
          var xbi = xrev ? 0 : 1;
          var ybi = yrev ? 0 : 1;
          var pixcount = 0;
          var rcount = 0;
          var gcount = 0;
          var bcount = 0;
          var xb, xi, v, row, c;
          function setColor(v2, pixsize) {
            if (v2 !== void 0) {
              var c2 = sclFunc(v2);
              c2[0] = Math.round(c2[0]);
              c2[1] = Math.round(c2[1]);
              c2[2] = Math.round(c2[2]);
              pixcount += pixsize;
              rcount += c2[0] * pixsize;
              gcount += c2[1] * pixsize;
              bcount += c2[2] * pixsize;
              return c2;
            }
            return [0, 0, 0, 0];
          }
          function interpColor(r02, r12, xinterp, yinterp2) {
            var z00 = r02[xinterp.bin0];
            if (z00 === void 0) return setColor(void 0, 1);
            var z01 = r02[xinterp.bin1];
            var z10 = r12[xinterp.bin0];
            var z11 = r12[xinterp.bin1];
            var dx2 = z01 - z00 || 0;
            var dy2 = z10 - z00 || 0;
            var dxy;
            if (z01 === void 0) {
              if (z11 === void 0) dxy = 0;
              else if (z10 === void 0) dxy = 2 * (z11 - z00);
              else dxy = (2 * z11 - z10 - z00) * 2 / 3;
            } else if (z11 === void 0) {
              if (z10 === void 0) dxy = 0;
              else dxy = (2 * z00 - z01 - z10) * 2 / 3;
            } else if (z10 === void 0) dxy = (2 * z11 - z01 - z00) * 2 / 3;
            else dxy = z11 + z00 - z01 - z10;
            return setColor(z00 + xinterp.frac * dx2 + yinterp2.frac * (dy2 + xinterp.frac * dxy));
          }
          if (drawingMethod !== "default") {
            var pxIndex = 0;
            var pixels;
            try {
              pixels = new Uint8Array(canvasW * canvasH * 4);
            } catch (e) {
              pixels = new Array(canvasW * canvasH * 4);
            }
            if (drawingMethod === "smooth") {
              var xForPx = xc || x;
              var yForPx = yc || y;
              var xPixArray = new Array(xForPx.length);
              var yPixArray = new Array(yForPx.length);
              var xinterpArray = new Array(imageWidth);
              var findInterpX = xc ? findInterpFromCenters : findInterp;
              var findInterpY = yc ? findInterpFromCenters : findInterp;
              var yinterp, r0, r1;
              for (i = 0; i < xForPx.length; i++) xPixArray[i] = Math.round(xa.c2p(xForPx[i]) - left);
              for (i = 0; i < yForPx.length; i++) yPixArray[i] = Math.round(ya.c2p(yForPx[i]) - top);
              for (i = 0; i < imageWidth; i++) xinterpArray[i] = findInterpX(i, xPixArray);
              for (j = 0; j < imageHeight; j++) {
                yinterp = findInterpY(j, yPixArray);
                r0 = z[yinterp.bin0];
                r1 = z[yinterp.bin1];
                for (i = 0; i < imageWidth; i++, pxIndex += 4) {
                  c = interpColor(r0, r1, xinterpArray[i], yinterp);
                  putColor(pixels, pxIndex, c);
                }
              }
            } else {
              for (j = 0; j < m; j++) {
                row = z[j];
                yb = ypx(j);
                for (i = 0; i < n; i++) {
                  c = setColor(row[i], 1);
                  pxIndex = (yb * n + xpx(i)) * 4;
                  putColor(pixels, pxIndex, c);
                }
              }
            }
            var imageData = context.createImageData(canvasW, canvasH);
            try {
              imageData.data.set(pixels);
            } catch (e) {
              var pxArray = imageData.data;
              var dlen = pxArray.length;
              for (j = 0; j < dlen; j++) {
                pxArray[j] = pixels[j];
              }
            }
            context.putImageData(imageData, 0, 0);
          } else {
            var xGapLeft = Math.floor(xGap / 2);
            var yGapTop = Math.floor(yGap / 2);
            for (j = 0; j < m; j++) {
              row = z[j];
              yb.reverse();
              yb[ybi] = ypx(j + 1);
              if (yb[0] === yb[1] || yb[0] === void 0 || yb[1] === void 0) {
                continue;
              }
              xi = xpx(0);
              xb = [xi, xi];
              for (i = 0; i < n; i++) {
                xb.reverse();
                xb[xbi] = xpx(i + 1);
                if (xb[0] === xb[1] || xb[0] === void 0 || xb[1] === void 0) {
                  continue;
                }
                v = row[i];
                c = setColor(v, (xb[1] - xb[0]) * (yb[1] - yb[0]));
                context.fillStyle = "rgba(" + c.join(",") + ")";
                context.fillRect(
                  xb[0] + xGapLeft,
                  yb[0] + yGapTop,
                  xb[1] - xb[0] - xGap,
                  yb[1] - yb[0] - yGap
                );
              }
            }
          }
          rcount = Math.round(rcount / pixcount);
          gcount = Math.round(gcount / pixcount);
          bcount = Math.round(bcount / pixcount);
          var avgColor = tinycolor("rgb(" + rcount + "," + gcount + "," + bcount + ")");
          gd._hmpixcount = (gd._hmpixcount || 0) + pixcount;
          gd._hmlumcount = (gd._hmlumcount || 0) + pixcount * avgColor.getLuminance();
          var image3 = plotGroup.selectAll("image").data(cd);
          image3.enter().append("svg:image").attr({
            xmlns: xmlnsNamespaces.svg,
            preserveAspectRatio: "none"
          });
          image3.attr({
            height: imageHeight,
            width: imageWidth,
            x: left,
            y: top,
            "xlink:href": canvas.toDataURL("image/png")
          });
          if (drawingMethod === "fast" && !zsmooth) {
            image3.attr("style", PIXELATED_IMAGE_STYLE);
          }
          removeLabels(plotGroup);
          var texttemplate = trace.texttemplate;
          if (texttemplate) {
            var cOpts = extractOpts(trace);
            var dummyAx = {
              type: "linear",
              range: [cOpts.min, cOpts.max],
              _separators: xa._separators,
              _numFormat: xa._numFormat
            };
            var aHistogram2dContour = trace.type === "histogram2dcontour";
            var aContour = trace.type === "contour";
            var iStart = aContour ? 1 : 0;
            var iStop = aContour ? m - 1 : m;
            var jStart = aContour ? 1 : 0;
            var jStop = aContour ? n - 1 : n;
            var textData = [];
            for (i = iStart; i < iStop; i++) {
              var yVal;
              if (aContour) {
                yVal = cd0.y[i];
              } else if (aHistogram2dContour) {
                if (i === 0 || i === m - 1) continue;
                yVal = cd0.y[i];
              } else if (cd0.yCenter) {
                yVal = cd0.yCenter[i];
              } else {
                if (i + 1 === m && cd0.y[i + 1] === void 0) continue;
                yVal = (cd0.y[i] + cd0.y[i + 1]) / 2;
              }
              var _y = Math.round(ya.c2p(yVal));
              if (0 > _y || _y > ya._length) continue;
              for (j = jStart; j < jStop; j++) {
                var xVal;
                if (aContour) {
                  xVal = cd0.x[j];
                } else if (aHistogram2dContour) {
                  if (j === 0 || j === n - 1) continue;
                  xVal = cd0.x[j];
                } else if (cd0.xCenter) {
                  xVal = cd0.xCenter[j];
                } else {
                  if (j + 1 === n && cd0.x[j + 1] === void 0) continue;
                  xVal = (cd0.x[j] + cd0.x[j + 1]) / 2;
                }
                var _x = Math.round(xa.c2p(xVal));
                if (0 > _x || _x > xa._length) continue;
                var obj = formatLabels({
                  x: xVal,
                  y: yVal
                }, trace, gd._fullLayout);
                obj.x = xVal;
                obj.y = yVal;
                var zVal = cd0.z[i][j];
                if (zVal === void 0) {
                  obj.z = "";
                  obj.zLabel = "";
                } else {
                  obj.z = zVal;
                  obj.zLabel = Axes.tickText(dummyAx, zVal, "hover").text;
                }
                var theText = cd0.text && cd0.text[i] && cd0.text[i][j];
                if (theText === void 0 || theText === false) theText = "";
                obj.text = theText;
                var _t = Lib.texttemplateString(texttemplate, obj, gd._fullLayout._d3locale, obj, trace._meta || {});
                if (!_t) continue;
                var lines = _t.split("<br>");
                var nL = lines.length;
                var nC = 0;
                for (k = 0; k < nL; k++) {
                  nC = Math.max(nC, lines[k].length);
                }
                textData.push({
                  l: nL,
                  // number of lines
                  c: nC,
                  // maximum number of chars in a line
                  t: _t,
                  // text
                  x: _x,
                  y: _y,
                  z: zVal
                });
              }
            }
            var font = trace.textfont;
            var fontSize = font.size;
            var globalFontSize = gd._fullLayout.font.size;
            if (!fontSize || fontSize === "auto") {
              var minW = Infinity;
              var minH = Infinity;
              var maxL = 0;
              var maxC = 0;
              for (k = 0; k < textData.length; k++) {
                var d = textData[k];
                maxL = Math.max(maxL, d.l);
                maxC = Math.max(maxC, d.c);
                if (k < textData.length - 1) {
                  var nextD = textData[k + 1];
                  var dx = Math.abs(nextD.x - d.x);
                  var dy = Math.abs(nextD.y - d.y);
                  if (dx) minW = Math.min(minW, dx);
                  if (dy) minH = Math.min(minH, dy);
                }
              }
              if (!isFinite(minW) || !isFinite(minH)) {
                fontSize = globalFontSize;
              } else {
                minW -= xGap;
                minH -= yGap;
                minW /= maxC;
                minH /= maxL;
                minW /= LINE_SPACING / 2;
                minH /= LINE_SPACING;
                fontSize = Math.min(
                  Math.floor(minW),
                  Math.floor(minH),
                  globalFontSize
                );
              }
            }
            if (fontSize <= 0 || !isFinite(fontSize)) return;
            var xFn = function(d2) {
              return d2.x;
            };
            var yFn = function(d2) {
              return d2.y - fontSize * (d2.l * LINE_SPACING / 2 - 1);
            };
            var labels = selectLabels(plotGroup).data(textData);
            labels.enter().append("g").classed(labelClass, 1).append("text").attr("text-anchor", "middle").each(function(d2) {
              var thisLabel = d3.select(this);
              var fontColor = font.color;
              if (!fontColor || fontColor === "auto") {
                fontColor = Color.contrast(
                  d2.z === void 0 ? gd._fullLayout.plot_bgcolor : "rgba(" + sclFunc(d2.z).join() + ")"
                );
              }
              thisLabel.attr("data-notex", 1).call(svgTextUtils.positionText, xFn(d2), yFn(d2)).call(Drawing.font, {
                family: font.family,
                size: fontSize,
                color: fontColor,
                weight: font.weight,
                style: font.style,
                variant: font.variant,
                textcase: font.textcase,
                lineposition: font.lineposition,
                shadow: font.shadow
              }).text(d2.t).call(svgTextUtils.convertToTspans, gd);
            });
          }
        });
      };
      function findInterp(pixel, pixArray) {
        var maxBin = pixArray.length - 2;
        var bin = Lib.constrain(Lib.findBin(pixel, pixArray), 0, maxBin);
        var pix0 = pixArray[bin];
        var pix1 = pixArray[bin + 1];
        var interp = Lib.constrain(bin + (pixel - pix0) / (pix1 - pix0) - 0.5, 0, maxBin);
        var bin0 = Math.round(interp);
        var frac = Math.abs(interp - bin0);
        if (!interp || interp === maxBin || !frac) {
          return {
            bin0,
            bin1: bin0,
            frac: 0
          };
        }
        return {
          bin0,
          frac,
          bin1: Math.round(bin0 + frac / (interp - bin0))
        };
      }
      function findInterpFromCenters(pixel, centerPixArray) {
        var maxBin = centerPixArray.length - 1;
        var bin = Lib.constrain(Lib.findBin(pixel, centerPixArray), 0, maxBin);
        var pix0 = centerPixArray[bin];
        var pix1 = centerPixArray[bin + 1];
        var frac = (pixel - pix0) / (pix1 - pix0) || 0;
        if (frac <= 0) {
          return {
            bin0: bin,
            bin1: bin,
            frac: 0
          };
        }
        if (frac < 0.5) {
          return {
            bin0: bin,
            bin1: bin + 1,
            frac
          };
        }
        return {
          bin0: bin + 1,
          bin1: bin,
          frac: 1 - frac
        };
      }
      function putColor(pixels, pxIndex, c) {
        pixels[pxIndex] = c[0];
        pixels[pxIndex + 1] = c[1];
        pixels[pxIndex + 2] = c[2];
        pixels[pxIndex + 3] = Math.round(c[3] * 255);
      }
    }
  });

  // src/traces/heatmap/colorbar.js
  var require_colorbar2 = __commonJS({
    "src/traces/heatmap/colorbar.js"(exports, module) {
      "use strict";
      module.exports = {
        min: "zmin",
        max: "zmax"
      };
    }
  });

  // src/traces/heatmap/style.js
  var require_style6 = __commonJS({
    "src/traces/heatmap/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      module.exports = function style(gd) {
        d3.select(gd).selectAll(".hm image").style("opacity", function(d) {
          return d.trace.opacity;
        });
      };
    }
  });

  // src/traces/heatmap/hover.js
  var require_hover5 = __commonJS({
    "src/traces/heatmap/hover.js"(exports, module) {
      "use strict";
      var Fx = require_fx();
      var Lib = require_lib();
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var Axes = require_axes();
      var extractOpts = require_colorscale().extractOpts;
      module.exports = function hoverPoints(pointData, xval, yval, hovermode, opts) {
        if (!opts) opts = {};
        var isContour = opts.isContour;
        var cd0 = pointData.cd[0];
        var trace = cd0.trace;
        var xa = pointData.xa;
        var ya = pointData.ya;
        var x = cd0.x;
        var y = cd0.y;
        var z = cd0.z;
        var xc = cd0.xCenter;
        var yc = cd0.yCenter;
        var zmask = cd0.zmask;
        var zhoverformat = trace.zhoverformat;
        var x2 = x;
        var y2 = y;
        var xl, yl, nx, ny;
        if (pointData.index !== false) {
          try {
            nx = Math.round(pointData.index[1]);
            ny = Math.round(pointData.index[0]);
          } catch (e) {
            Lib.error("Error hovering on heatmap, pointNumber must be [row,col], found:", pointData.index);
            return;
          }
          if (nx < 0 || nx >= z[0].length || ny < 0 || ny > z.length) {
            return;
          }
        } else if (Fx.inbox(xval - x[0], xval - x[x.length - 1], 0) > 0 || Fx.inbox(yval - y[0], yval - y[y.length - 1], 0) > 0) {
          return;
        } else {
          if (isContour) {
            var i2;
            x2 = [2 * x[0] - x[1]];
            for (i2 = 1; i2 < x.length; i2++) {
              x2.push((x[i2] + x[i2 - 1]) / 2);
            }
            x2.push([2 * x[x.length - 1] - x[x.length - 2]]);
            y2 = [2 * y[0] - y[1]];
            for (i2 = 1; i2 < y.length; i2++) {
              y2.push((y[i2] + y[i2 - 1]) / 2);
            }
            y2.push([2 * y[y.length - 1] - y[y.length - 2]]);
          }
          nx = Math.max(0, Math.min(x2.length - 2, Lib.findBin(xval, x2)));
          ny = Math.max(0, Math.min(y2.length - 2, Lib.findBin(yval, y2)));
        }
        var x0 = xa.c2p(x[nx]);
        var x1 = xa.c2p(x[nx + 1]);
        var y0 = ya.c2p(y[ny]);
        var y1 = ya.c2p(y[ny + 1]);
        var _x, _y;
        if (isContour) {
          _x = cd0.orig_x || x;
          _y = cd0.orig_y || y;
          x1 = x0;
          xl = _x[nx];
          y1 = y0;
          yl = _y[ny];
        } else {
          _x = cd0.orig_x || xc || x;
          _y = cd0.orig_y || yc || y;
          xl = xc ? _x[nx] : (_x[nx] + _x[nx + 1]) / 2;
          yl = yc ? _y[ny] : (_y[ny] + _y[ny + 1]) / 2;
          if (xa && xa.type === "category") xl = x[nx];
          if (ya && ya.type === "category") yl = y[ny];
          if (trace.zsmooth) {
            x0 = x1 = xa.c2p(xl);
            y0 = y1 = ya.c2p(yl);
          }
        }
        var zVal = z[ny][nx];
        if (zmask && !zmask[ny][nx]) zVal = void 0;
        if (zVal === void 0 && !trace.hoverongaps) return;
        var text;
        if (isArrayOrTypedArray(cd0.hovertext) && isArrayOrTypedArray(cd0.hovertext[ny])) {
          text = cd0.hovertext[ny][nx];
        } else if (isArrayOrTypedArray(cd0.text) && isArrayOrTypedArray(cd0.text[ny])) {
          text = cd0.text[ny][nx];
        }
        var cOpts = extractOpts(trace);
        var dummyAx = {
          type: "linear",
          range: [cOpts.min, cOpts.max],
          hoverformat: zhoverformat,
          _separators: xa._separators,
          _numFormat: xa._numFormat
        };
        var zLabel = Axes.tickText(dummyAx, zVal, "hover").text;
        return [Lib.extendFlat(pointData, {
          index: trace._after2before ? trace._after2before[ny][nx] : [ny, nx],
          // never let a 2D override 1D type as closest point
          distance: pointData.maxHoverDistance,
          spikeDistance: pointData.maxSpikeDistance,
          x0,
          x1,
          y0,
          y1,
          xLabelVal: xl,
          yLabelVal: yl,
          zLabelVal: zVal,
          zLabel,
          text
        })];
      };
    }
  });

  // src/traces/heatmap/index.js
  var require_heatmap = __commonJS({
    "src/traces/heatmap/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes25(),
        supplyDefaults: require_defaults21(),
        calc: require_calc9(),
        plot: require_plot5(),
        colorbar: require_colorbar2(),
        style: require_style6(),
        hoverPoints: require_hover5(),
        moduleType: "trace",
        name: "heatmap",
        basePlotModule: require_cartesian(),
        categories: ["cartesian", "svg", "2dMap", "showLegend"],
        meta: {}
      };
    }
  });

  // lib/heatmap.js
  var require_heatmap2 = __commonJS({
    "lib/heatmap.js"(exports, module) {
      "use strict";
      module.exports = require_heatmap();
    }
  });

  // src/traces/histogram/bin_attributes.js
  var require_bin_attributes = __commonJS({
    "src/traces/histogram/bin_attributes.js"(exports, module) {
      "use strict";
      module.exports = function makeBinAttrs(axLetter, match) {
        return {
          start: {
            valType: "any",
            // for date axes
            editType: "calc"
          },
          end: {
            valType: "any",
            // for date axes
            editType: "calc"
          },
          size: {
            valType: "any",
            // for date axes
            editType: "calc"
          },
          editType: "calc"
        };
      };
    }
  });

  // src/traces/histogram/constants.js
  var require_constants15 = __commonJS({
    "src/traces/histogram/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        eventDataKeys: ["binNumber"]
      };
    }
  });

  // src/traces/histogram/attributes.js
  var require_attributes26 = __commonJS({
    "src/traces/histogram/attributes.js"(exports, module) {
      "use strict";
      var barAttrs = require_attributes23();
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var texttemplateAttrs = require_template_attributes().texttemplateAttrs;
      var fontAttrs = require_font_attributes();
      var makeBinAttrs = require_bin_attributes();
      var constants = require_constants15();
      var extendFlat = require_extend().extendFlat;
      module.exports = {
        x: {
          valType: "data_array",
          editType: "calc+clearAxisTypes"
        },
        y: {
          valType: "data_array",
          editType: "calc+clearAxisTypes"
        },
        xhoverformat: axisHoverFormat("x"),
        yhoverformat: axisHoverFormat("y"),
        text: extendFlat({}, barAttrs.text, {}),
        hovertext: extendFlat({}, barAttrs.hovertext, {}),
        orientation: barAttrs.orientation,
        histfunc: {
          valType: "enumerated",
          values: ["count", "sum", "avg", "min", "max"],
          dflt: "count",
          editType: "calc"
        },
        histnorm: {
          valType: "enumerated",
          values: ["", "percent", "probability", "density", "probability density"],
          dflt: "",
          editType: "calc"
        },
        cumulative: {
          enabled: {
            valType: "boolean",
            dflt: false,
            editType: "calc"
          },
          direction: {
            valType: "enumerated",
            values: ["increasing", "decreasing"],
            dflt: "increasing",
            editType: "calc"
          },
          currentbin: {
            valType: "enumerated",
            values: ["include", "exclude", "half"],
            dflt: "include",
            editType: "calc"
          },
          editType: "calc"
        },
        nbinsx: {
          valType: "integer",
          min: 0,
          dflt: 0,
          editType: "calc"
        },
        xbins: makeBinAttrs("x", true),
        nbinsy: {
          valType: "integer",
          min: 0,
          dflt: 0,
          editType: "calc"
        },
        ybins: makeBinAttrs("y", true),
        autobinx: {
          valType: "boolean",
          dflt: null,
          editType: "calc"
        },
        autobiny: {
          valType: "boolean",
          dflt: null,
          editType: "calc"
        },
        bingroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        hovertemplate: hovertemplateAttrs({}, {
          keys: constants.eventDataKeys
        }),
        texttemplate: texttemplateAttrs({
          arrayOk: false,
          editType: "plot"
        }, {
          keys: ["label", "value"]
        }),
        textposition: extendFlat({}, barAttrs.textposition, {
          arrayOk: false
        }),
        textfont: fontAttrs({
          arrayOk: false,
          editType: "plot",
          colorEditType: "style"
        }),
        outsidetextfont: fontAttrs({
          arrayOk: false,
          editType: "plot",
          colorEditType: "style"
        }),
        insidetextfont: fontAttrs({
          arrayOk: false,
          editType: "plot",
          colorEditType: "style"
        }),
        insidetextanchor: barAttrs.insidetextanchor,
        textangle: barAttrs.textangle,
        cliponaxis: barAttrs.cliponaxis,
        constraintext: barAttrs.constraintext,
        marker: barAttrs.marker,
        offsetgroup: barAttrs.offsetgroup,
        alignmentgroup: barAttrs.alignmentgroup,
        selected: barAttrs.selected,
        unselected: barAttrs.unselected,
        zorder: barAttrs.zorder
      };
    }
  });

  // src/traces/histogram/defaults.js
  var require_defaults22 = __commonJS({
    "src/traces/histogram/defaults.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var Color = require_color();
      var handleText = require_defaults19().handleText;
      var handleStyleDefaults = require_style_defaults();
      var attributes = require_attributes26();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var x = coerce("x");
        var y = coerce("y");
        var cumulative = coerce("cumulative.enabled");
        if (cumulative) {
          coerce("cumulative.direction");
          coerce("cumulative.currentbin");
        }
        coerce("text");
        var textposition = coerce("textposition");
        handleText(traceIn, traceOut, layout, coerce, textposition, {
          moduleHasSelected: true,
          moduleHasUnselected: true,
          moduleHasConstrain: true,
          moduleHasCliponaxis: true,
          moduleHasTextangle: true,
          moduleHasInsideanchor: true
        });
        coerce("hovertext");
        coerce("hovertemplate");
        coerce("xhoverformat");
        coerce("yhoverformat");
        var orientation = coerce("orientation", y && !x ? "h" : "v");
        var sampleLetter = orientation === "v" ? "x" : "y";
        var aggLetter = orientation === "v" ? "y" : "x";
        var len = x && y ? Math.min(Lib.minRowLength(x) && Lib.minRowLength(y)) : Lib.minRowLength(traceOut[sampleLetter] || []);
        if (!len) {
          traceOut.visible = false;
          return;
        }
        traceOut._length = len;
        var handleCalendarDefaults = Registry.getComponentMethod("calendars", "handleTraceDefaults");
        handleCalendarDefaults(traceIn, traceOut, ["x", "y"], layout);
        var hasAggregationData = traceOut[aggLetter];
        if (hasAggregationData) coerce("histfunc");
        coerce("histnorm");
        coerce("autobin" + sampleLetter);
        handleStyleDefaults(traceIn, traceOut, coerce, defaultColor, layout);
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
        var lineColor = (traceOut.marker.line || {}).color;
        var errorBarsSupplyDefaults = Registry.getComponentMethod("errorbars", "supplyDefaults");
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || Color.defaultLine, { axis: "y" });
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || Color.defaultLine, { axis: "x", inherit: "y" });
        coerce("zorder");
      };
    }
  });

  // src/traces/histogram/cross_trace_defaults.js
  var require_cross_trace_defaults3 = __commonJS({
    "src/traces/histogram/cross_trace_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var axisIds = require_axis_ids();
      var traceIs = require_registry().traceIs;
      var handleGroupingDefaults = require_grouping_defaults();
      var validateCornerradius = require_defaults19().validateCornerradius;
      var nestedProperty = Lib.nestedProperty;
      var getAxisGroup = require_constraints().getAxisGroup;
      var BINATTRS = [
        { aStr: { x: "xbins.start", y: "ybins.start" }, name: "start" },
        { aStr: { x: "xbins.end", y: "ybins.end" }, name: "end" },
        { aStr: { x: "xbins.size", y: "ybins.size" }, name: "size" },
        { aStr: { x: "nbinsx", y: "nbinsy" }, name: "nbins" }
      ];
      var BINDIRECTIONS = ["x", "y"];
      module.exports = function crossTraceDefaults(fullData, fullLayout) {
        var allBinOpts = fullLayout._histogramBinOpts = {};
        var histTraces = [];
        var mustMatchTracesLookup = {};
        var otherTracesList = [];
        var traceOut, traces, groupName, binDir;
        var i, j, k;
        function coerce(attr2, dflt) {
          return Lib.coerce(traceOut._input, traceOut, traceOut._module.attributes, attr2, dflt);
        }
        function orientation2binDir(traceOut2) {
          return traceOut2.orientation === "v" ? "x" : "y";
        }
        function getAxisType(traceOut2, binDir2) {
          var ax = axisIds.getFromTrace({ _fullLayout: fullLayout }, traceOut2, binDir2);
          return ax.type;
        }
        function fillBinOpts(traceOut2, groupName2, binDir2) {
          var fallbackGroupName = traceOut2.uid + "__" + binDir2;
          if (!groupName2) groupName2 = fallbackGroupName;
          var axType = getAxisType(traceOut2, binDir2);
          var calendar = traceOut2[binDir2 + "calendar"] || "";
          var binOpts2 = allBinOpts[groupName2];
          var needsNewItem = true;
          if (binOpts2) {
            if (axType === binOpts2.axType && calendar === binOpts2.calendar) {
              needsNewItem = false;
              binOpts2.traces.push(traceOut2);
              binOpts2.dirs.push(binDir2);
            } else {
              groupName2 = fallbackGroupName;
              if (axType !== binOpts2.axType) {
                Lib.warn([
                  "Attempted to group the bins of trace",
                  traceOut2.index,
                  "set on a",
                  "type:" + axType,
                  "axis",
                  "with bins on",
                  "type:" + binOpts2.axType,
                  "axis."
                ].join(" "));
              }
              if (calendar !== binOpts2.calendar) {
                Lib.warn([
                  "Attempted to group the bins of trace",
                  traceOut2.index,
                  "set with a",
                  calendar,
                  "calendar",
                  "with bins",
                  binOpts2.calendar ? "on a " + binOpts2.calendar + " calendar" : "w/o a set calendar"
                ].join(" "));
              }
            }
          }
          if (needsNewItem) {
            allBinOpts[groupName2] = {
              traces: [traceOut2],
              dirs: [binDir2],
              axType,
              calendar: traceOut2[binDir2 + "calendar"] || ""
            };
          }
          traceOut2["_" + binDir2 + "bingroup"] = groupName2;
        }
        for (i = 0; i < fullData.length; i++) {
          traceOut = fullData[i];
          if (traceIs(traceOut, "histogram")) {
            histTraces.push(traceOut);
            delete traceOut._xautoBinFinished;
            delete traceOut._yautoBinFinished;
            if (traceOut.type === "histogram") {
              var r = coerce("marker.cornerradius", fullLayout.barcornerradius);
              if (traceOut.marker) {
                traceOut.marker.cornerradius = validateCornerradius(r);
              }
            }
            if (!traceIs(traceOut, "2dMap")) {
              handleGroupingDefaults(traceOut._input, traceOut, fullLayout, coerce, fullLayout.barmode);
            }
          }
        }
        var alignmentOpts = fullLayout._alignmentOpts || {};
        for (i = 0; i < histTraces.length; i++) {
          traceOut = histTraces[i];
          groupName = "";
          if (!traceIs(traceOut, "2dMap")) {
            binDir = orientation2binDir(traceOut);
            if (fullLayout.barmode === "group" && traceOut.alignmentgroup) {
              var pa = traceOut[binDir + "axis"];
              var aGroupId = getAxisGroup(fullLayout, pa) + traceOut.orientation;
              if ((alignmentOpts[aGroupId] || {})[traceOut.alignmentgroup]) {
                groupName = aGroupId;
              }
            }
            if (!groupName && fullLayout.barmode !== "overlay") {
              groupName = getAxisGroup(fullLayout, traceOut.xaxis) + getAxisGroup(fullLayout, traceOut.yaxis) + orientation2binDir(traceOut);
            }
          }
          if (groupName) {
            if (!mustMatchTracesLookup[groupName]) {
              mustMatchTracesLookup[groupName] = [];
            }
            mustMatchTracesLookup[groupName].push(traceOut);
          } else {
            otherTracesList.push(traceOut);
          }
        }
        for (groupName in mustMatchTracesLookup) {
          traces = mustMatchTracesLookup[groupName];
          if (traces.length === 1) {
            otherTracesList.push(traces[0]);
            continue;
          }
          var binGroupFound = false;
          if (traces.length) {
            traceOut = traces[0];
            binGroupFound = coerce("bingroup");
          }
          groupName = binGroupFound || groupName;
          for (i = 0; i < traces.length; i++) {
            traceOut = traces[i];
            var bingroupIn = traceOut._input.bingroup;
            if (bingroupIn && bingroupIn !== groupName) {
              Lib.warn([
                "Trace",
                traceOut.index,
                "must match",
                "within bingroup",
                groupName + ".",
                "Ignoring its bingroup:",
                bingroupIn,
                "setting."
              ].join(" "));
            }
            traceOut.bingroup = groupName;
            fillBinOpts(traceOut, groupName, orientation2binDir(traceOut));
          }
        }
        for (i = 0; i < otherTracesList.length; i++) {
          traceOut = otherTracesList[i];
          var binGroup = coerce("bingroup");
          if (traceIs(traceOut, "2dMap")) {
            for (k = 0; k < 2; k++) {
              binDir = BINDIRECTIONS[k];
              var binGroupInDir = coerce(
                binDir + "bingroup",
                binGroup ? binGroup + "__" + binDir : null
              );
              fillBinOpts(traceOut, binGroupInDir, binDir);
            }
          } else {
            fillBinOpts(traceOut, binGroup, orientation2binDir(traceOut));
          }
        }
        for (groupName in allBinOpts) {
          var binOpts = allBinOpts[groupName];
          traces = binOpts.traces;
          for (j = 0; j < BINATTRS.length; j++) {
            var attrSpec = BINATTRS[j];
            var attr = attrSpec.name;
            var aStr;
            var autoVals;
            if (attr === "nbins" && binOpts.sizeFound) continue;
            for (i = 0; i < traces.length; i++) {
              traceOut = traces[i];
              binDir = binOpts.dirs[i];
              aStr = attrSpec.aStr[binDir];
              if (nestedProperty(traceOut._input, aStr).get() !== void 0) {
                binOpts[attr] = coerce(aStr);
                binOpts[attr + "Found"] = true;
                break;
              }
              autoVals = (traceOut._autoBin || {})[binDir] || {};
              if (autoVals[attr]) {
                nestedProperty(traceOut, aStr).set(autoVals[attr]);
              }
            }
            if (attr === "start" || attr === "end") {
              for (; i < traces.length; i++) {
                traceOut = traces[i];
                if (traceOut["_" + binDir + "bingroup"]) {
                  autoVals = (traceOut._autoBin || {})[binDir] || {};
                  coerce(aStr, autoVals[attr]);
                }
              }
            }
            if (attr === "nbins" && !binOpts.sizeFound && !binOpts.nbinsFound) {
              traceOut = traces[0];
              binOpts[attr] = coerce(aStr);
            }
          }
        }
      };
    }
  });

  // src/traces/histogram/hover.js
  var require_hover6 = __commonJS({
    "src/traces/histogram/hover.js"(exports, module) {
      "use strict";
      var barHover = require_hover3().hoverPoints;
      var hoverLabelText = require_axes().hoverLabelText;
      module.exports = function hoverPoints(pointData, xval, yval, hovermode, opts) {
        var pts = barHover(pointData, xval, yval, hovermode, opts);
        if (!pts) return;
        pointData = pts[0];
        var di = pointData.cd[pointData.index];
        var trace = pointData.cd[0].trace;
        if (!trace.cumulative.enabled) {
          var posLetter = trace.orientation === "h" ? "y" : "x";
          pointData[posLetter + "Label"] = hoverLabelText(pointData[posLetter + "a"], [di.ph0, di.ph1], trace[posLetter + "hoverformat"]);
        }
        return pts;
      };
    }
  });

  // src/traces/histogram/event_data.js
  var require_event_data3 = __commonJS({
    "src/traces/histogram/event_data.js"(exports, module) {
      "use strict";
      module.exports = function eventData(out, pt, trace, cd, pointNumber) {
        out.x = "xVal" in pt ? pt.xVal : pt.x;
        out.y = "yVal" in pt ? pt.yVal : pt.y;
        if ("zLabelVal" in pt) out.z = pt.zLabelVal;
        if (pt.xa) out.xaxis = pt.xa;
        if (pt.ya) out.yaxis = pt.ya;
        if (!(trace.cumulative || {}).enabled) {
          var pts = Array.isArray(pointNumber) ? cd[0].pts[pointNumber[0]][pointNumber[1]] : cd[pointNumber].pts;
          out.pointNumbers = pts;
          out.binNumber = out.pointNumber;
          delete out.pointNumber;
          delete out.pointIndex;
          var pointIndices;
          if (trace._indexToPoints) {
            pointIndices = [];
            for (var i = 0; i < pts.length; i++) {
              pointIndices = pointIndices.concat(trace._indexToPoints[pts[i]]);
            }
          } else {
            pointIndices = pts;
          }
          out.pointIndices = pointIndices;
        }
        return out;
      };
    }
  });

  // src/traces/histogram/index.js
  var require_histogram = __commonJS({
    "src/traces/histogram/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes26(),
        layoutAttributes: require_layout_attributes6(),
        supplyDefaults: require_defaults22(),
        crossTraceDefaults: require_cross_trace_defaults3(),
        supplyLayoutDefaults: require_layout_defaults5(),
        calc: require_calc7().calc,
        crossTraceCalc: require_cross_trace_calc().crossTraceCalc,
        plot: require_plot3().plot,
        layerName: "barlayer",
        style: require_style4().style,
        styleOnSelect: require_style4().styleOnSelect,
        colorbar: require_marker_colorbar(),
        hoverPoints: require_hover6(),
        selectPoints: require_select3(),
        eventData: require_event_data3(),
        moduleType: "trace",
        name: "histogram",
        basePlotModule: require_cartesian(),
        categories: ["bar-like", "cartesian", "svg", "bar", "histogram", "oriented", "errorBarsOK", "showLegend"],
        meta: {}
      };
    }
  });

  // lib/histogram.js
  var require_histogram2 = __commonJS({
    "lib/histogram.js"(exports, module) {
      "use strict";
      module.exports = require_histogram();
    }
  });

  // src/traces/histogram2d/attributes.js
  var require_attributes27 = __commonJS({
    "src/traces/histogram2d/attributes.js"(exports, module) {
      "use strict";
      var histogramAttrs = require_attributes26();
      var makeBinAttrs = require_bin_attributes();
      var heatmapAttrs = require_attributes25();
      var baseAttrs = require_attributes2();
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var texttemplateAttrs = require_template_attributes().texttemplateAttrs;
      var colorScaleAttrs = require_attributes8();
      var extendFlat = require_extend().extendFlat;
      module.exports = extendFlat(
        {
          x: histogramAttrs.x,
          y: histogramAttrs.y,
          z: {
            valType: "data_array",
            editType: "calc"
          },
          marker: {
            color: {
              valType: "data_array",
              editType: "calc"
            },
            editType: "calc"
          },
          histnorm: histogramAttrs.histnorm,
          histfunc: histogramAttrs.histfunc,
          nbinsx: histogramAttrs.nbinsx,
          xbins: makeBinAttrs("x"),
          nbinsy: histogramAttrs.nbinsy,
          ybins: makeBinAttrs("y"),
          autobinx: histogramAttrs.autobinx,
          autobiny: histogramAttrs.autobiny,
          bingroup: extendFlat({}, histogramAttrs.bingroup, {}),
          xbingroup: extendFlat({}, histogramAttrs.bingroup, {}),
          ybingroup: extendFlat({}, histogramAttrs.bingroup, {}),
          xgap: heatmapAttrs.xgap,
          ygap: heatmapAttrs.ygap,
          zsmooth: heatmapAttrs.zsmooth,
          xhoverformat: axisHoverFormat("x"),
          yhoverformat: axisHoverFormat("y"),
          zhoverformat: axisHoverFormat("z", 1),
          hovertemplate: hovertemplateAttrs({}, { keys: "z" }),
          texttemplate: texttemplateAttrs({
            arrayOk: false,
            editType: "plot"
          }, {
            keys: "z"
          }),
          textfont: heatmapAttrs.textfont,
          showlegend: extendFlat({}, baseAttrs.showlegend, { dflt: false })
        },
        colorScaleAttrs("", { cLetter: "z", autoColorDflt: false })
      );
    }
  });

  // src/traces/histogram2d/sample_defaults.js
  var require_sample_defaults = __commonJS({
    "src/traces/histogram2d/sample_defaults.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      module.exports = function handleSampleDefaults(traceIn, traceOut, coerce, layout) {
        var x = coerce("x");
        var y = coerce("y");
        var xlen = Lib.minRowLength(x);
        var ylen = Lib.minRowLength(y);
        if (!xlen || !ylen) {
          traceOut.visible = false;
          return;
        }
        traceOut._length = Math.min(xlen, ylen);
        var handleCalendarDefaults = Registry.getComponentMethod("calendars", "handleTraceDefaults");
        handleCalendarDefaults(traceIn, traceOut, ["x", "y"], layout);
        var hasAggregationData = coerce("z") || coerce("marker.color");
        if (hasAggregationData) coerce("histfunc");
        coerce("histnorm");
        coerce("autobinx");
        coerce("autobiny");
      };
    }
  });

  // src/traces/histogram2d/defaults.js
  var require_defaults23 = __commonJS({
    "src/traces/histogram2d/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleSampleDefaults = require_sample_defaults();
      var handleStyleDefaults = require_style_defaults2();
      var colorscaleDefaults = require_defaults2();
      var handleHeatmapLabelDefaults = require_label_defaults();
      var attributes = require_attributes27();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        handleSampleDefaults(traceIn, traceOut, coerce, layout);
        if (traceOut.visible === false) return;
        handleStyleDefaults(traceIn, traceOut, coerce, layout);
        colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "", cLetter: "z" });
        coerce("hovertemplate");
        handleHeatmapLabelDefaults(coerce, layout);
        coerce("xhoverformat");
        coerce("yhoverformat");
      };
    }
  });

  // src/traces/histogram2d/hover.js
  var require_hover7 = __commonJS({
    "src/traces/histogram2d/hover.js"(exports, module) {
      "use strict";
      var heatmapHover = require_hover5();
      var hoverLabelText = require_axes().hoverLabelText;
      module.exports = function hoverPoints(pointData, xval, yval, hovermode, opts) {
        var pts = heatmapHover(pointData, xval, yval, hovermode, opts);
        if (!pts) return;
        pointData = pts[0];
        var indices = pointData.index;
        var ny = indices[0];
        var nx = indices[1];
        var cd0 = pointData.cd[0];
        var trace = cd0.trace;
        var xRange = cd0.xRanges[nx];
        var yRange = cd0.yRanges[ny];
        pointData.xLabel = hoverLabelText(pointData.xa, [xRange[0], xRange[1]], trace.xhoverformat);
        pointData.yLabel = hoverLabelText(pointData.ya, [yRange[0], yRange[1]], trace.yhoverformat);
        return pts;
      };
    }
  });

  // src/traces/histogram2d/index.js
  var require_histogram2d = __commonJS({
    "src/traces/histogram2d/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes27(),
        supplyDefaults: require_defaults23(),
        crossTraceDefaults: require_cross_trace_defaults3(),
        calc: require_calc9(),
        plot: require_plot5(),
        layerName: "heatmaplayer",
        colorbar: require_colorbar2(),
        style: require_style6(),
        hoverPoints: require_hover7(),
        eventData: require_event_data3(),
        moduleType: "trace",
        name: "histogram2d",
        basePlotModule: require_cartesian(),
        categories: ["cartesian", "svg", "2dMap", "histogram", "showLegend"],
        meta: {}
      };
    }
  });

  // lib/histogram2d.js
  var require_histogram2d2 = __commonJS({
    "lib/histogram2d.js"(exports, module) {
      "use strict";
      module.exports = require_histogram2d();
    }
  });

  // src/constants/filter_ops.js
  var require_filter_ops = __commonJS({
    "src/constants/filter_ops.js"(exports, module) {
      "use strict";
      module.exports = {
        COMPARISON_OPS: ["=", "!=", "<", ">=", ">", "<="],
        COMPARISON_OPS2: ["=", "<", ">=", ">", "<="],
        INTERVAL_OPS: ["[]", "()", "[)", "(]", "][", ")(", "](", ")["],
        SET_OPS: ["{}", "}{"],
        CONSTRAINT_REDUCTION: {
          // for contour constraints, open/closed endpoints are equivalent
          "=": "=",
          "<": "<",
          "<=": "<",
          ">": ">",
          ">=": ">",
          "[]": "[]",
          "()": "[]",
          "[)": "[]",
          "(]": "[]",
          "][": "][",
          ")(": "][",
          "](": "][",
          ")[": "]["
        }
      };
    }
  });

  // src/traces/contour/attributes.js
  var require_attributes28 = __commonJS({
    "src/traces/contour/attributes.js"(exports, module) {
      "use strict";
      var heatmapAttrs = require_attributes25();
      var scatterAttrs = require_attributes12();
      var axisFormat = require_axis_format_attributes();
      var axisHoverFormat = axisFormat.axisHoverFormat;
      var descriptionOnlyNumbers = axisFormat.descriptionOnlyNumbers;
      var colorScaleAttrs = require_attributes8();
      var dash = require_attributes4().dash;
      var fontAttrs = require_font_attributes();
      var extendFlat = require_extend().extendFlat;
      var filterOps = require_filter_ops();
      var COMPARISON_OPS2 = filterOps.COMPARISON_OPS2;
      var INTERVAL_OPS = filterOps.INTERVAL_OPS;
      var scatterLineAttrs = scatterAttrs.line;
      module.exports = extendFlat(
        {
          z: heatmapAttrs.z,
          x: heatmapAttrs.x,
          x0: heatmapAttrs.x0,
          dx: heatmapAttrs.dx,
          y: heatmapAttrs.y,
          y0: heatmapAttrs.y0,
          dy: heatmapAttrs.dy,
          xperiod: heatmapAttrs.xperiod,
          yperiod: heatmapAttrs.yperiod,
          xperiod0: scatterAttrs.xperiod0,
          yperiod0: scatterAttrs.yperiod0,
          xperiodalignment: heatmapAttrs.xperiodalignment,
          yperiodalignment: heatmapAttrs.yperiodalignment,
          text: heatmapAttrs.text,
          hovertext: heatmapAttrs.hovertext,
          transpose: heatmapAttrs.transpose,
          xtype: heatmapAttrs.xtype,
          ytype: heatmapAttrs.ytype,
          xhoverformat: axisHoverFormat("x"),
          yhoverformat: axisHoverFormat("y"),
          zhoverformat: axisHoverFormat("z", 1),
          hovertemplate: heatmapAttrs.hovertemplate,
          texttemplate: extendFlat({}, heatmapAttrs.texttemplate, {}),
          textfont: extendFlat({}, heatmapAttrs.textfont, {}),
          hoverongaps: heatmapAttrs.hoverongaps,
          connectgaps: extendFlat({}, heatmapAttrs.connectgaps, {}),
          fillcolor: {
            valType: "color",
            editType: "calc"
          },
          autocontour: {
            valType: "boolean",
            dflt: true,
            editType: "calc",
            impliedEdits: {
              "contours.start": void 0,
              "contours.end": void 0,
              "contours.size": void 0
            }
          },
          ncontours: {
            valType: "integer",
            dflt: 15,
            min: 1,
            editType: "calc"
          },
          contours: {
            type: {
              valType: "enumerated",
              values: ["levels", "constraint"],
              dflt: "levels",
              editType: "calc"
            },
            start: {
              valType: "number",
              dflt: null,
              editType: "plot",
              impliedEdits: { "^autocontour": false }
            },
            end: {
              valType: "number",
              dflt: null,
              editType: "plot",
              impliedEdits: { "^autocontour": false }
            },
            size: {
              valType: "number",
              dflt: null,
              min: 0,
              editType: "plot",
              impliedEdits: { "^autocontour": false }
            },
            coloring: {
              valType: "enumerated",
              values: ["fill", "heatmap", "lines", "none"],
              dflt: "fill",
              editType: "calc"
            },
            showlines: {
              valType: "boolean",
              dflt: true,
              editType: "plot"
            },
            showlabels: {
              valType: "boolean",
              dflt: false,
              editType: "plot"
            },
            labelfont: fontAttrs({
              editType: "plot",
              colorEditType: "style"
            }),
            labelformat: {
              valType: "string",
              dflt: "",
              editType: "plot",
              description: descriptionOnlyNumbers("contour label")
            },
            operation: {
              valType: "enumerated",
              values: [].concat(COMPARISON_OPS2).concat(INTERVAL_OPS),
              dflt: "=",
              editType: "calc"
            },
            value: {
              valType: "any",
              dflt: 0,
              editType: "calc"
            },
            editType: "calc",
            impliedEdits: { autocontour: false }
          },
          line: {
            color: extendFlat({}, scatterLineAttrs.color, {
              editType: "style+colorbars"
            }),
            width: {
              valType: "number",
              min: 0,
              editType: "style+colorbars"
            },
            dash,
            smoothing: extendFlat({}, scatterLineAttrs.smoothing, {}),
            editType: "plot"
          },
          zorder: scatterAttrs.zorder
        },
        colorScaleAttrs("", {
          cLetter: "z",
          autoColorDflt: false,
          editTypeOverride: "calc"
        })
      );
    }
  });

  // src/traces/histogram2dcontour/attributes.js
  var require_attributes29 = __commonJS({
    "src/traces/histogram2dcontour/attributes.js"(exports, module) {
      "use strict";
      var histogram2dAttrs = require_attributes27();
      var contourAttrs = require_attributes28();
      var colorScaleAttrs = require_attributes8();
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var extendFlat = require_extend().extendFlat;
      module.exports = extendFlat(
        {
          x: histogram2dAttrs.x,
          y: histogram2dAttrs.y,
          z: histogram2dAttrs.z,
          marker: histogram2dAttrs.marker,
          histnorm: histogram2dAttrs.histnorm,
          histfunc: histogram2dAttrs.histfunc,
          nbinsx: histogram2dAttrs.nbinsx,
          xbins: histogram2dAttrs.xbins,
          nbinsy: histogram2dAttrs.nbinsy,
          ybins: histogram2dAttrs.ybins,
          autobinx: histogram2dAttrs.autobinx,
          autobiny: histogram2dAttrs.autobiny,
          bingroup: histogram2dAttrs.bingroup,
          xbingroup: histogram2dAttrs.xbingroup,
          ybingroup: histogram2dAttrs.ybingroup,
          autocontour: contourAttrs.autocontour,
          ncontours: contourAttrs.ncontours,
          contours: contourAttrs.contours,
          line: {
            color: contourAttrs.line.color,
            width: extendFlat({}, contourAttrs.line.width, {
              dflt: 0.5
            }),
            dash: contourAttrs.line.dash,
            smoothing: contourAttrs.line.smoothing,
            editType: "plot"
          },
          xhoverformat: axisHoverFormat("x"),
          yhoverformat: axisHoverFormat("y"),
          zhoverformat: axisHoverFormat("z", 1),
          hovertemplate: histogram2dAttrs.hovertemplate,
          texttemplate: contourAttrs.texttemplate,
          textfont: contourAttrs.textfont
        },
        colorScaleAttrs("", {
          cLetter: "z",
          editTypeOverride: "calc"
        })
      );
    }
  });

  // src/traces/contour/contours_defaults.js
  var require_contours_defaults = __commonJS({
    "src/traces/contour/contours_defaults.js"(exports, module) {
      "use strict";
      module.exports = function handleContourDefaults(traceIn, traceOut, coerce, coerce2) {
        var contourStart = coerce2("contours.start");
        var contourEnd = coerce2("contours.end");
        var missingEnd = contourStart === false || contourEnd === false;
        var contourSize = coerce("contours.size");
        var autoContour;
        if (missingEnd) autoContour = traceOut.autocontour = true;
        else autoContour = coerce("autocontour", false);
        if (autoContour || !contourSize) coerce("ncontours");
      };
    }
  });

  // src/traces/contour/label_defaults.js
  var require_label_defaults2 = __commonJS({
    "src/traces/contour/label_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function handleLabelDefaults(coerce, layout, lineColor, opts) {
        if (!opts) opts = {};
        var showLabels = coerce("contours.showlabels");
        if (showLabels) {
          var globalFont = layout.font;
          Lib.coerceFont(coerce, "contours.labelfont", globalFont, { overrideDflt: {
            color: lineColor
          } });
          coerce("contours.labelformat");
        }
        if (opts.hasHover !== false) coerce("zhoverformat");
      };
    }
  });

  // src/traces/contour/style_defaults.js
  var require_style_defaults3 = __commonJS({
    "src/traces/contour/style_defaults.js"(exports, module) {
      "use strict";
      var colorscaleDefaults = require_defaults2();
      var handleLabelDefaults = require_label_defaults2();
      module.exports = function handleStyleDefaults(traceIn, traceOut, coerce, layout, opts) {
        var coloring = coerce("contours.coloring");
        var showLines;
        var lineColor = "";
        if (coloring === "fill") showLines = coerce("contours.showlines");
        if (showLines !== false) {
          if (coloring !== "lines") lineColor = coerce("line.color", "#000");
          coerce("line.width", 0.5);
          coerce("line.dash");
        }
        if (coloring !== "none") {
          if (traceIn.showlegend !== true) traceOut.showlegend = false;
          traceOut._dfltShowLegend = false;
          colorscaleDefaults(
            traceIn,
            traceOut,
            layout,
            coerce,
            { prefix: "", cLetter: "z" }
          );
        }
        coerce("line.smoothing");
        handleLabelDefaults(coerce, layout, lineColor, opts);
      };
    }
  });

  // src/traces/histogram2dcontour/defaults.js
  var require_defaults24 = __commonJS({
    "src/traces/histogram2dcontour/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleSampleDefaults = require_sample_defaults();
      var handleContoursDefaults = require_contours_defaults();
      var handleStyleDefaults = require_style_defaults3();
      var handleHeatmapLabelDefaults = require_label_defaults();
      var attributes = require_attributes29();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        function coerce2(attr) {
          return Lib.coerce2(traceIn, traceOut, attributes, attr);
        }
        handleSampleDefaults(traceIn, traceOut, coerce, layout);
        if (traceOut.visible === false) return;
        handleContoursDefaults(traceIn, traceOut, coerce, coerce2);
        handleStyleDefaults(traceIn, traceOut, coerce, layout);
        coerce("xhoverformat");
        coerce("yhoverformat");
        coerce("hovertemplate");
        if (traceOut.contours && traceOut.contours.coloring === "heatmap") {
          handleHeatmapLabelDefaults(coerce, layout);
        }
      };
    }
  });

  // src/traces/contour/set_contours.js
  var require_set_contours = __commonJS({
    "src/traces/contour/set_contours.js"(exports, module) {
      "use strict";
      var Axes = require_axes();
      var Lib = require_lib();
      module.exports = function setContours(trace, vals) {
        var contours = trace.contours;
        if (trace.autocontour) {
          var zmin = trace.zmin;
          var zmax = trace.zmax;
          if (trace.zauto || zmin === void 0) {
            zmin = Lib.aggNums(Math.min, null, vals);
          }
          if (trace.zauto || zmax === void 0) {
            zmax = Lib.aggNums(Math.max, null, vals);
          }
          var dummyAx = autoContours(zmin, zmax, trace.ncontours);
          contours.size = dummyAx.dtick;
          contours.start = Axes.tickFirst(dummyAx);
          dummyAx.range.reverse();
          contours.end = Axes.tickFirst(dummyAx);
          if (contours.start === zmin) contours.start += contours.size;
          if (contours.end === zmax) contours.end -= contours.size;
          if (contours.start > contours.end) {
            contours.start = contours.end = (contours.start + contours.end) / 2;
          }
          if (!trace._input.contours) trace._input.contours = {};
          Lib.extendFlat(trace._input.contours, {
            start: contours.start,
            end: contours.end,
            size: contours.size
          });
          trace._input.autocontour = true;
        } else if (contours.type !== "constraint") {
          var start = contours.start;
          var end = contours.end;
          var inputContours = trace._input.contours;
          if (start > end) {
            contours.start = inputContours.start = end;
            end = contours.end = inputContours.end = start;
            start = contours.start;
          }
          if (!(contours.size > 0)) {
            var sizeOut;
            if (start === end) sizeOut = 1;
            else sizeOut = autoContours(start, end, trace.ncontours).dtick;
            inputContours.size = contours.size = sizeOut;
          }
        }
      };
      function autoContours(start, end, ncontours) {
        var dummyAx = {
          type: "linear",
          range: [start, end]
        };
        Axes.autoTicks(
          dummyAx,
          (end - start) / (ncontours || 15)
        );
        return dummyAx;
      }
    }
  });

  // src/traces/contour/end_plus.js
  var require_end_plus = __commonJS({
    "src/traces/contour/end_plus.js"(exports, module) {
      "use strict";
      module.exports = function endPlus(contours) {
        return contours.end + contours.size / 1e6;
      };
    }
  });

  // src/traces/contour/calc.js
  var require_calc10 = __commonJS({
    "src/traces/contour/calc.js"(exports, module) {
      "use strict";
      var Colorscale = require_colorscale();
      var heatmapCalc = require_calc9();
      var setContours = require_set_contours();
      var endPlus = require_end_plus();
      module.exports = function calc(gd, trace) {
        var cd = heatmapCalc(gd, trace);
        var zOut = cd[0].z;
        setContours(trace, zOut);
        var contours = trace.contours;
        var cOpts = Colorscale.extractOpts(trace);
        var cVals;
        if (contours.coloring === "heatmap" && cOpts.auto && trace.autocontour === false) {
          var start = contours.start;
          var end = endPlus(contours);
          var cs = contours.size || 1;
          var nc = Math.floor((end - start) / cs) + 1;
          if (!isFinite(cs)) {
            cs = 1;
            nc = 1;
          }
          var min0 = start - cs / 2;
          var max0 = min0 + nc * cs;
          cVals = [min0, max0];
        } else {
          cVals = zOut;
        }
        Colorscale.calc(gd, trace, { vals: cVals, cLetter: "z" });
        return cd;
      };
    }
  });

  // src/traces/contour/constants.js
  var require_constants16 = __commonJS({
    "src/traces/contour/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // some constants to help with marching squares algorithm
        // where does the path start for each index?
        BOTTOMSTART: [1, 9, 13, 104, 713],
        TOPSTART: [4, 6, 7, 104, 713],
        LEFTSTART: [8, 12, 14, 208, 1114],
        RIGHTSTART: [2, 3, 11, 208, 1114],
        // which way [dx,dy] do we leave a given index?
        // saddles are already disambiguated
        NEWDELTA: [
          null,
          [-1, 0],
          [0, -1],
          [-1, 0],
          [1, 0],
          null,
          [0, -1],
          [-1, 0],
          [0, 1],
          [0, 1],
          null,
          [0, 1],
          [1, 0],
          [1, 0],
          [0, -1]
        ],
        // for each saddle, the first index here is used
        // for dx||dy<0, the second for dx||dy>0
        CHOOSESADDLE: {
          104: [4, 1],
          208: [2, 8],
          713: [7, 13],
          1114: [11, 14]
        },
        // after one index has been used for a saddle, which do we
        // substitute to be used up later?
        SADDLEREMAINDER: { 1: 4, 2: 8, 4: 1, 7: 13, 8: 2, 11: 14, 13: 7, 14: 11 },
        // length of a contour, as a multiple of the plot area diagonal, per label
        LABELDISTANCE: 2,
        // number of contour levels after which we start increasing the number of
        // labels we draw. Many contours means they will generally be close
        // together, so it will be harder to follow a long way to find a label
        LABELINCREASE: 10,
        // minimum length of a contour line, as a multiple of the label length,
        // at which we draw *any* labels
        LABELMIN: 3,
        // max number of labels to draw on a single contour path, no matter how long
        LABELMAX: 10,
        // constants for the label position cost function
        LABELOPTIMIZER: {
          // weight given to edge proximity
          EDGECOST: 1,
          // weight given to the angle off horizontal
          ANGLECOST: 1,
          // weight given to distance from already-placed labels
          NEIGHBORCOST: 5,
          // cost multiplier for labels on the same level
          SAMELEVELFACTOR: 10,
          // minimum distance (as a multiple of the label length)
          // for labels on the same level
          SAMELEVELDISTANCE: 5,
          // maximum cost before we won't even place the label
          MAXCOST: 100,
          // number of evenly spaced points to look at in the first
          // iteration of the search
          INITIALSEARCHPOINTS: 10,
          // number of binary search iterations after the initial wide search
          ITERATIONS: 5
        }
      };
    }
  });

  // src/traces/contour/make_crossings.js
  var require_make_crossings = __commonJS({
    "src/traces/contour/make_crossings.js"(exports, module) {
      "use strict";
      var constants = require_constants16();
      module.exports = function makeCrossings(pathinfo) {
        var z = pathinfo[0].z;
        var m = z.length;
        var n = z[0].length;
        var twoWide = m === 2 || n === 2;
        var xi;
        var yi;
        var startIndices;
        var ystartIndices;
        var label;
        var corners;
        var mi;
        var pi;
        var i;
        for (yi = 0; yi < m - 1; yi++) {
          ystartIndices = [];
          if (yi === 0) ystartIndices = ystartIndices.concat(constants.BOTTOMSTART);
          if (yi === m - 2) ystartIndices = ystartIndices.concat(constants.TOPSTART);
          for (xi = 0; xi < n - 1; xi++) {
            startIndices = ystartIndices.slice();
            if (xi === 0) startIndices = startIndices.concat(constants.LEFTSTART);
            if (xi === n - 2) startIndices = startIndices.concat(constants.RIGHTSTART);
            label = xi + "," + yi;
            corners = [
              [z[yi][xi], z[yi][xi + 1]],
              [z[yi + 1][xi], z[yi + 1][xi + 1]]
            ];
            for (i = 0; i < pathinfo.length; i++) {
              pi = pathinfo[i];
              mi = getMarchingIndex(pi.level, corners);
              if (!mi) continue;
              pi.crossings[label] = mi;
              if (startIndices.indexOf(mi) !== -1) {
                pi.starts.push([xi, yi]);
                if (twoWide && startIndices.indexOf(
                  mi,
                  startIndices.indexOf(mi) + 1
                ) !== -1) {
                  pi.starts.push([xi, yi]);
                }
              }
            }
          }
        }
      };
      function getMarchingIndex(val, corners) {
        var mi = (corners[0][0] > val ? 0 : 1) + (corners[0][1] > val ? 0 : 2) + (corners[1][1] > val ? 0 : 4) + (corners[1][0] > val ? 0 : 8);
        if (mi === 5 || mi === 10) {
          var avg = (corners[0][0] + corners[0][1] + corners[1][0] + corners[1][1]) / 4;
          if (val > avg) return mi === 5 ? 713 : 1114;
          return mi === 5 ? 104 : 208;
        }
        return mi === 15 ? 0 : mi;
      }
    }
  });

  // src/traces/contour/find_all_paths.js
  var require_find_all_paths = __commonJS({
    "src/traces/contour/find_all_paths.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var constants = require_constants16();
      module.exports = function findAllPaths(pathinfo, xtol, ytol) {
        var cnt, startLoc, i, pi, j;
        xtol = xtol || 0.01;
        ytol = ytol || 0.01;
        for (i = 0; i < pathinfo.length; i++) {
          pi = pathinfo[i];
          for (j = 0; j < pi.starts.length; j++) {
            startLoc = pi.starts[j];
            makePath(pi, startLoc, "edge", xtol, ytol);
          }
          cnt = 0;
          while (Object.keys(pi.crossings).length && cnt < 1e4) {
            cnt++;
            startLoc = Object.keys(pi.crossings)[0].split(",").map(Number);
            makePath(pi, startLoc, void 0, xtol, ytol);
          }
          if (cnt === 1e4) Lib.log("Infinite loop in contour?");
        }
      };
      function equalPts(pt1, pt2, xtol, ytol) {
        return Math.abs(pt1[0] - pt2[0]) < xtol && Math.abs(pt1[1] - pt2[1]) < ytol;
      }
      function ptDist(pt1, pt2) {
        var dx = pt1[2] - pt2[2];
        var dy = pt1[3] - pt2[3];
        return Math.sqrt(dx * dx + dy * dy);
      }
      function makePath(pi, loc, edgeflag, xtol, ytol) {
        var locStr = loc.join(",");
        var mi = pi.crossings[locStr];
        var marchStep = getStartStep(mi, edgeflag, loc);
        var pts = [getInterpPx(pi, loc, [-marchStep[0], -marchStep[1]])];
        var m = pi.z.length;
        var n = pi.z[0].length;
        var startLoc = loc.slice();
        var startStep = marchStep.slice();
        var cnt;
        for (cnt = 0; cnt < 1e4; cnt++) {
          if (mi > 20) {
            mi = constants.CHOOSESADDLE[mi][(marchStep[0] || marchStep[1]) < 0 ? 0 : 1];
            pi.crossings[locStr] = constants.SADDLEREMAINDER[mi];
          } else {
            delete pi.crossings[locStr];
          }
          marchStep = constants.NEWDELTA[mi];
          if (!marchStep) {
            Lib.log("Found bad marching index:", mi, loc, pi.level);
            break;
          }
          pts.push(getInterpPx(pi, loc, marchStep));
          loc[0] += marchStep[0];
          loc[1] += marchStep[1];
          locStr = loc.join(",");
          if (equalPts(pts[pts.length - 1], pts[pts.length - 2], xtol, ytol)) pts.pop();
          var atEdge = marchStep[0] && (loc[0] < 0 || loc[0] > n - 2) || marchStep[1] && (loc[1] < 0 || loc[1] > m - 2);
          var closedLoop = loc[0] === startLoc[0] && loc[1] === startLoc[1] && marchStep[0] === startStep[0] && marchStep[1] === startStep[1];
          if (closedLoop || edgeflag && atEdge) break;
          mi = pi.crossings[locStr];
        }
        if (cnt === 1e4) {
          Lib.log("Infinite loop in contour?");
        }
        var closedpath = equalPts(pts[0], pts[pts.length - 1], xtol, ytol);
        var totaldist = 0;
        var distThresholdFactor = 0.2 * pi.smoothing;
        var alldists = [];
        var cropstart = 0;
        var distgroup, cnt2, cnt3, newpt, ptcnt, ptavg, thisdist, i, j, edgepathi, edgepathj;
        for (cnt = 1; cnt < pts.length; cnt++) {
          thisdist = ptDist(pts[cnt], pts[cnt - 1]);
          totaldist += thisdist;
          alldists.push(thisdist);
        }
        var distThreshold = totaldist / alldists.length * distThresholdFactor;
        function getpt(i2) {
          return pts[i2 % pts.length];
        }
        for (cnt = pts.length - 2; cnt >= cropstart; cnt--) {
          distgroup = alldists[cnt];
          if (distgroup < distThreshold) {
            cnt3 = 0;
            for (cnt2 = cnt - 1; cnt2 >= cropstart; cnt2--) {
              if (distgroup + alldists[cnt2] < distThreshold) {
                distgroup += alldists[cnt2];
              } else break;
            }
            if (closedpath && cnt === pts.length - 2) {
              for (cnt3 = 0; cnt3 < cnt2; cnt3++) {
                if (distgroup + alldists[cnt3] < distThreshold) {
                  distgroup += alldists[cnt3];
                } else break;
              }
            }
            ptcnt = cnt - cnt2 + cnt3 + 1;
            ptavg = Math.floor((cnt + cnt2 + cnt3 + 2) / 2);
            if (!closedpath && cnt === pts.length - 2) newpt = pts[pts.length - 1];
            else if (!closedpath && cnt2 === -1) newpt = pts[0];
            else if (ptcnt % 2) newpt = getpt(ptavg);
            else {
              newpt = [
                (getpt(ptavg)[0] + getpt(ptavg + 1)[0]) / 2,
                (getpt(ptavg)[1] + getpt(ptavg + 1)[1]) / 2
              ];
            }
            pts.splice(cnt2 + 1, cnt - cnt2 + 1, newpt);
            cnt = cnt2 + 1;
            if (cnt3) cropstart = cnt3;
            if (closedpath) {
              if (cnt === pts.length - 2) pts[cnt3] = pts[pts.length - 1];
              else if (cnt === 0) pts[pts.length - 1] = pts[0];
            }
          }
        }
        pts.splice(0, cropstart);
        for (cnt = 0; cnt < pts.length; cnt++) pts[cnt].length = 2;
        if (pts.length < 2) return;
        else if (closedpath) {
          pts.pop();
          pi.paths.push(pts);
        } else {
          if (!edgeflag) {
            Lib.log(
              "Unclosed interior contour?",
              pi.level,
              startLoc.join(","),
              pts.join("L")
            );
          }
          var merged = false;
          for (i = 0; i < pi.edgepaths.length; i++) {
            edgepathi = pi.edgepaths[i];
            if (!merged && equalPts(edgepathi[0], pts[pts.length - 1], xtol, ytol)) {
              pts.pop();
              merged = true;
              var doublemerged = false;
              for (j = 0; j < pi.edgepaths.length; j++) {
                edgepathj = pi.edgepaths[j];
                if (equalPts(edgepathj[edgepathj.length - 1], pts[0], xtol, ytol)) {
                  doublemerged = true;
                  pts.shift();
                  pi.edgepaths.splice(i, 1);
                  if (j === i) {
                    pi.paths.push(pts.concat(edgepathj));
                  } else {
                    if (j > i) j--;
                    pi.edgepaths[j] = edgepathj.concat(pts, edgepathi);
                  }
                  break;
                }
              }
              if (!doublemerged) {
                pi.edgepaths[i] = pts.concat(edgepathi);
              }
            }
          }
          for (i = 0; i < pi.edgepaths.length; i++) {
            if (merged) break;
            edgepathi = pi.edgepaths[i];
            if (equalPts(edgepathi[edgepathi.length - 1], pts[0], xtol, ytol)) {
              pts.shift();
              pi.edgepaths[i] = edgepathi.concat(pts);
              merged = true;
            }
          }
          if (!merged) pi.edgepaths.push(pts);
        }
      }
      function getStartStep(mi, edgeflag, loc) {
        var dx = 0;
        var dy = 0;
        if (mi > 20 && edgeflag) {
          if (mi === 208 || mi === 1114) {
            dx = loc[0] === 0 ? 1 : -1;
          } else {
            dy = loc[1] === 0 ? 1 : -1;
          }
        } else if (constants.BOTTOMSTART.indexOf(mi) !== -1) dy = 1;
        else if (constants.LEFTSTART.indexOf(mi) !== -1) dx = 1;
        else if (constants.TOPSTART.indexOf(mi) !== -1) dy = -1;
        else dx = -1;
        return [dx, dy];
      }
      function getInterpPx(pi, loc, step) {
        var locx = loc[0] + Math.max(step[0], 0);
        var locy = loc[1] + Math.max(step[1], 0);
        var zxy = pi.z[locy][locx];
        var xa = pi.xaxis;
        var ya = pi.yaxis;
        if (step[1]) {
          var dx = (pi.level - zxy) / (pi.z[locy][locx + 1] - zxy);
          var dxl = (dx !== 1 ? (1 - dx) * xa.c2l(pi.x[locx]) : 0) + (dx !== 0 ? dx * xa.c2l(pi.x[locx + 1]) : 0);
          return [
            xa.c2p(xa.l2c(dxl), true),
            ya.c2p(pi.y[locy], true),
            locx + dx,
            locy
          ];
        } else {
          var dy = (pi.level - zxy) / (pi.z[locy + 1][locx] - zxy);
          var dyl = (dy !== 1 ? (1 - dy) * ya.c2l(pi.y[locy]) : 0) + (dy !== 0 ? dy * ya.c2l(pi.y[locy + 1]) : 0);
          return [
            xa.c2p(pi.x[locx], true),
            ya.c2p(ya.l2c(dyl), true),
            locx,
            locy + dy
          ];
        }
      }
    }
  });

  // src/traces/contour/constraint_mapping.js
  var require_constraint_mapping = __commonJS({
    "src/traces/contour/constraint_mapping.js"(exports, module) {
      "use strict";
      var filterOps = require_filter_ops();
      var isNumeric = require_fast_isnumeric();
      module.exports = {
        "[]": makeRangeSettings("[]"),
        "][": makeRangeSettings("]["),
        ">": makeInequalitySettings(">"),
        "<": makeInequalitySettings("<"),
        "=": makeInequalitySettings("=")
      };
      function coerceValue(operation, value) {
        var hasArrayValue = Array.isArray(value);
        var coercedValue;
        function coerce(value2) {
          return isNumeric(value2) ? +value2 : null;
        }
        if (filterOps.COMPARISON_OPS2.indexOf(operation) !== -1) {
          coercedValue = hasArrayValue ? coerce(value[0]) : coerce(value);
        } else if (filterOps.INTERVAL_OPS.indexOf(operation) !== -1) {
          coercedValue = hasArrayValue ? [coerce(value[0]), coerce(value[1])] : [coerce(value), coerce(value)];
        } else if (filterOps.SET_OPS.indexOf(operation) !== -1) {
          coercedValue = hasArrayValue ? value.map(coerce) : [coerce(value)];
        }
        return coercedValue;
      }
      function makeRangeSettings(operation) {
        return function(value) {
          value = coerceValue(operation, value);
          var min = Math.min(value[0], value[1]);
          var max = Math.max(value[0], value[1]);
          return {
            start: min,
            end: max,
            size: max - min
          };
        };
      }
      function makeInequalitySettings(operation) {
        return function(value) {
          value = coerceValue(operation, value);
          return {
            start: value,
            end: Infinity,
            size: Infinity
          };
        };
      }
    }
  });

  // src/traces/contour/empty_pathinfo.js
  var require_empty_pathinfo = __commonJS({
    "src/traces/contour/empty_pathinfo.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var constraintMapping = require_constraint_mapping();
      var endPlus = require_end_plus();
      module.exports = function emptyPathinfo(contours, plotinfo, cd0) {
        var contoursFinal = contours.type === "constraint" ? constraintMapping[contours._operation](contours.value) : contours;
        var cs = contoursFinal.size;
        var pathinfo = [];
        var end = endPlus(contoursFinal);
        var carpet = cd0.trace._carpetTrace;
        var basePathinfo = carpet ? {
          // store axes so we can convert to px
          xaxis: carpet.aaxis,
          yaxis: carpet.baxis,
          // full data arrays to use for interpolation
          x: cd0.a,
          y: cd0.b
        } : {
          xaxis: plotinfo.xaxis,
          yaxis: plotinfo.yaxis,
          x: cd0.x,
          y: cd0.y
        };
        for (var ci = contoursFinal.start; ci < end; ci += cs) {
          pathinfo.push(Lib.extendFlat({
            level: ci,
            // all the cells with nontrivial marching index
            crossings: {},
            // starting points on the edges of the lattice for each contour
            starts: [],
            // all unclosed paths (may have less items than starts,
            // if a path is closed by rounding)
            edgepaths: [],
            // all closed paths
            paths: [],
            z: cd0.z,
            smoothing: cd0.trace.line.smoothing
          }, basePathinfo));
          if (pathinfo.length > 1e3) {
            Lib.warn("Too many contours, clipping at 1000", contours);
            break;
          }
        }
        return pathinfo;
      };
    }
  });

  // src/traces/contour/convert_to_constraints.js
  var require_convert_to_constraints = __commonJS({
    "src/traces/contour/convert_to_constraints.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function(pathinfo, operation) {
        var i, pi0, pi1;
        var op0 = function(arr) {
          return arr.reverse();
        };
        var op1 = function(arr) {
          return arr;
        };
        switch (operation) {
          case "=":
          case "<":
            return pathinfo;
          case ">":
            if (pathinfo.length !== 1) {
              Lib.warn("Contour data invalid for the specified inequality operation.");
            }
            pi0 = pathinfo[0];
            for (i = 0; i < pi0.edgepaths.length; i++) {
              pi0.edgepaths[i] = op0(pi0.edgepaths[i]);
            }
            for (i = 0; i < pi0.paths.length; i++) {
              pi0.paths[i] = op0(pi0.paths[i]);
            }
            for (i = 0; i < pi0.starts.length; i++) {
              pi0.starts[i] = op0(pi0.starts[i]);
            }
            return pathinfo;
          case "][":
            var tmp = op0;
            op0 = op1;
            op1 = tmp;
          // It's a nice rule, except this definitely *is* what's intended here.
          /* eslint-disable: no-fallthrough */
          case "[]":
            if (pathinfo.length !== 2) {
              Lib.warn("Contour data invalid for the specified inequality range operation.");
            }
            pi0 = copyPathinfo(pathinfo[0]);
            pi1 = copyPathinfo(pathinfo[1]);
            for (i = 0; i < pi0.edgepaths.length; i++) {
              pi0.edgepaths[i] = op0(pi0.edgepaths[i]);
            }
            for (i = 0; i < pi0.paths.length; i++) {
              pi0.paths[i] = op0(pi0.paths[i]);
            }
            for (i = 0; i < pi0.starts.length; i++) {
              pi0.starts[i] = op0(pi0.starts[i]);
            }
            while (pi1.edgepaths.length) {
              pi0.edgepaths.push(op1(pi1.edgepaths.shift()));
            }
            while (pi1.paths.length) {
              pi0.paths.push(op1(pi1.paths.shift()));
            }
            while (pi1.starts.length) {
              pi0.starts.push(op1(pi1.starts.shift()));
            }
            return [pi0];
        }
      };
      function copyPathinfo(pi) {
        return Lib.extendFlat({}, pi, {
          edgepaths: Lib.extendDeep([], pi.edgepaths),
          paths: Lib.extendDeep([], pi.paths),
          starts: Lib.extendDeep([], pi.starts)
        });
      }
    }
  });

  // src/traces/contour/close_boundaries.js
  var require_close_boundaries = __commonJS({
    "src/traces/contour/close_boundaries.js"(exports, module) {
      "use strict";
      module.exports = function(pathinfo, contours) {
        var pi0 = pathinfo[0];
        var z = pi0.z;
        var i;
        switch (contours.type) {
          case "levels":
            var edgeVal2 = Math.min(z[0][0], z[0][1]);
            for (i = 0; i < pathinfo.length; i++) {
              var pi = pathinfo[i];
              pi.prefixBoundary = !pi.edgepaths.length && (edgeVal2 > pi.level || pi.starts.length && edgeVal2 === pi.level);
            }
            break;
          case "constraint":
            pi0.prefixBoundary = false;
            if (pi0.edgepaths.length) return;
            var na = pi0.x.length;
            var nb = pi0.y.length;
            var boundaryMax = -Infinity;
            var boundaryMin = Infinity;
            for (i = 0; i < nb; i++) {
              boundaryMin = Math.min(boundaryMin, z[i][0]);
              boundaryMin = Math.min(boundaryMin, z[i][na - 1]);
              boundaryMax = Math.max(boundaryMax, z[i][0]);
              boundaryMax = Math.max(boundaryMax, z[i][na - 1]);
            }
            for (i = 1; i < na - 1; i++) {
              boundaryMin = Math.min(boundaryMin, z[0][i]);
              boundaryMin = Math.min(boundaryMin, z[nb - 1][i]);
              boundaryMax = Math.max(boundaryMax, z[0][i]);
              boundaryMax = Math.max(boundaryMax, z[nb - 1][i]);
            }
            var contoursValue = contours.value;
            var v1, v2;
            switch (contours._operation) {
              case ">":
                if (contoursValue > boundaryMax) {
                  pi0.prefixBoundary = true;
                }
                break;
              case "<":
                if (contoursValue < boundaryMin || pi0.starts.length && contoursValue === boundaryMin) {
                  pi0.prefixBoundary = true;
                }
                break;
              case "[]":
                v1 = Math.min(contoursValue[0], contoursValue[1]);
                v2 = Math.max(contoursValue[0], contoursValue[1]);
                if (v2 < boundaryMin || v1 > boundaryMax || pi0.starts.length && v2 === boundaryMin) {
                  pi0.prefixBoundary = true;
                }
                break;
              case "][":
                v1 = Math.min(contoursValue[0], contoursValue[1]);
                v2 = Math.max(contoursValue[0], contoursValue[1]);
                if (v1 < boundaryMin && v2 > boundaryMax) {
                  pi0.prefixBoundary = true;
                }
                break;
            }
            break;
        }
      };
    }
  });

  // src/traces/contour/plot.js
  var require_plot6 = __commonJS({
    "src/traces/contour/plot.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var Drawing = require_drawing();
      var Colorscale = require_colorscale();
      var svgTextUtils = require_svg_text_utils();
      var Axes = require_axes();
      var setConvert = require_set_convert();
      var heatmapPlot = require_plot5();
      var makeCrossings = require_make_crossings();
      var findAllPaths = require_find_all_paths();
      var emptyPathinfo = require_empty_pathinfo();
      var convertToConstraints = require_convert_to_constraints();
      var closeBoundaries = require_close_boundaries();
      var constants = require_constants16();
      var costConstants = constants.LABELOPTIMIZER;
      exports.plot = function plot(gd, plotinfo, cdcontours, contourLayer) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        Lib.makeTraceGroups(contourLayer, cdcontours, "contour").each(function(cd) {
          var plotGroup = d3.select(this);
          var cd0 = cd[0];
          var trace = cd0.trace;
          var x = cd0.x;
          var y = cd0.y;
          var contours = trace.contours;
          var pathinfo = emptyPathinfo(contours, plotinfo, cd0);
          var heatmapColoringLayer = Lib.ensureSingle(plotGroup, "g", "heatmapcoloring");
          var cdheatmaps = [];
          if (contours.coloring === "heatmap") {
            cdheatmaps = [cd];
          }
          heatmapPlot(gd, plotinfo, cdheatmaps, heatmapColoringLayer);
          makeCrossings(pathinfo);
          findAllPaths(pathinfo);
          var leftedge = xa.c2p(x[0], true);
          var rightedge = xa.c2p(x[x.length - 1], true);
          var bottomedge = ya.c2p(y[0], true);
          var topedge = ya.c2p(y[y.length - 1], true);
          var perimeter = [
            [leftedge, topedge],
            [rightedge, topedge],
            [rightedge, bottomedge],
            [leftedge, bottomedge]
          ];
          var fillPathinfo = pathinfo;
          if (contours.type === "constraint") {
            fillPathinfo = convertToConstraints(pathinfo, contours._operation);
          }
          makeBackground(plotGroup, perimeter, contours);
          makeFills(plotGroup, fillPathinfo, perimeter, contours);
          makeLinesAndLabels(plotGroup, pathinfo, gd, cd0, contours);
          clipGaps(plotGroup, plotinfo, gd, cd0, perimeter);
        });
      };
      function makeBackground(plotgroup, perimeter, contours) {
        var bggroup = Lib.ensureSingle(plotgroup, "g", "contourbg");
        var bgfill = bggroup.selectAll("path").data(contours.coloring === "fill" ? [0] : []);
        bgfill.enter().append("path");
        bgfill.exit().remove();
        bgfill.attr("d", "M" + perimeter.join("L") + "Z").style("stroke", "none");
      }
      function makeFills(plotgroup, pathinfo, perimeter, contours) {
        var hasFills = contours.coloring === "fill" || contours.type === "constraint" && contours._operation !== "=";
        var boundaryPath = "M" + perimeter.join("L") + "Z";
        if (hasFills) {
          closeBoundaries(pathinfo, contours);
        }
        var fillgroup = Lib.ensureSingle(plotgroup, "g", "contourfill");
        var fillitems = fillgroup.selectAll("path").data(hasFills ? pathinfo : []);
        fillitems.enter().append("path");
        fillitems.exit().remove();
        fillitems.each(function(pi) {
          var fullpath = (pi.prefixBoundary ? boundaryPath : "") + joinAllPaths(pi, perimeter);
          if (!fullpath) {
            d3.select(this).remove();
          } else {
            d3.select(this).attr("d", fullpath).style("stroke", "none");
          }
        });
      }
      function joinAllPaths(pi, perimeter) {
        var fullpath = "";
        var i = 0;
        var startsleft = pi.edgepaths.map(function(v, i2) {
          return i2;
        });
        var newloop = true;
        var endpt;
        var newendpt;
        var cnt;
        var nexti;
        var possiblei;
        var addpath;
        function istop(pt) {
          return Math.abs(pt[1] - perimeter[0][1]) < 0.01;
        }
        function isbottom(pt) {
          return Math.abs(pt[1] - perimeter[2][1]) < 0.01;
        }
        function isleft(pt) {
          return Math.abs(pt[0] - perimeter[0][0]) < 0.01;
        }
        function isright(pt) {
          return Math.abs(pt[0] - perimeter[2][0]) < 0.01;
        }
        while (startsleft.length) {
          addpath = Drawing.smoothopen(pi.edgepaths[i], pi.smoothing);
          fullpath += newloop ? addpath : addpath.replace(/^M/, "L");
          startsleft.splice(startsleft.indexOf(i), 1);
          endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];
          nexti = -1;
          for (cnt = 0; cnt < 4; cnt++) {
            if (!endpt) {
              Lib.log("Missing end?", i, pi);
              break;
            }
            if (istop(endpt) && !isright(endpt)) newendpt = perimeter[1];
            else if (isleft(endpt)) newendpt = perimeter[0];
            else if (isbottom(endpt)) newendpt = perimeter[3];
            else if (isright(endpt)) newendpt = perimeter[2];
            for (possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {
              var ptNew = pi.edgepaths[possiblei][0];
              if (Math.abs(endpt[0] - newendpt[0]) < 0.01) {
                if (Math.abs(endpt[0] - ptNew[0]) < 0.01 && (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {
                  newendpt = ptNew;
                  nexti = possiblei;
                }
              } else if (Math.abs(endpt[1] - newendpt[1]) < 0.01) {
                if (Math.abs(endpt[1] - ptNew[1]) < 0.01 && (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {
                  newendpt = ptNew;
                  nexti = possiblei;
                }
              } else {
                Lib.log(
                  "endpt to newendpt is not vert. or horz.",
                  endpt,
                  newendpt,
                  ptNew
                );
              }
            }
            endpt = newendpt;
            if (nexti >= 0) break;
            fullpath += "L" + newendpt;
          }
          if (nexti === pi.edgepaths.length) {
            Lib.log("unclosed perimeter path");
            break;
          }
          i = nexti;
          newloop = startsleft.indexOf(i) === -1;
          if (newloop) {
            i = startsleft[0];
            fullpath += "Z";
          }
        }
        for (i = 0; i < pi.paths.length; i++) {
          fullpath += Drawing.smoothclosed(pi.paths[i], pi.smoothing);
        }
        return fullpath;
      }
      function makeLinesAndLabels(plotgroup, pathinfo, gd, cd0, contours) {
        var isStatic = gd._context.staticPlot;
        var lineContainer = Lib.ensureSingle(plotgroup, "g", "contourlines");
        var showLines = contours.showlines !== false;
        var showLabels = contours.showlabels;
        var clipLinesForLabels = showLines && showLabels;
        var linegroup = exports.createLines(lineContainer, showLines || showLabels, pathinfo, isStatic);
        var lineClip = exports.createLineClip(lineContainer, clipLinesForLabels, gd, cd0.trace.uid);
        var labelGroup = plotgroup.selectAll("g.contourlabels").data(showLabels ? [0] : []);
        labelGroup.exit().remove();
        labelGroup.enter().append("g").classed("contourlabels", true);
        if (showLabels) {
          var labelClipPathData = [];
          var labelData = [];
          Lib.clearLocationCache();
          var contourFormat = exports.labelFormatter(gd, cd0);
          var dummyText = Drawing.tester.append("text").attr("data-notex", 1).call(Drawing.font, contours.labelfont);
          var xa = pathinfo[0].xaxis;
          var ya = pathinfo[0].yaxis;
          var xLen = xa._length;
          var yLen = ya._length;
          var xRng = xa.range;
          var yRng = ya.range;
          var xMin = Lib.aggNums(Math.min, null, cd0.x);
          var xMax = Lib.aggNums(Math.max, null, cd0.x);
          var yMin = Lib.aggNums(Math.min, null, cd0.y);
          var yMax = Lib.aggNums(Math.max, null, cd0.y);
          var x0 = Math.max(xa.c2p(xMin, true), 0);
          var x1 = Math.min(xa.c2p(xMax, true), xLen);
          var y0 = Math.max(ya.c2p(yMax, true), 0);
          var y1 = Math.min(ya.c2p(yMin, true), yLen);
          var bounds = {};
          if (xRng[0] < xRng[1]) {
            bounds.left = x0;
            bounds.right = x1;
          } else {
            bounds.left = x1;
            bounds.right = x0;
          }
          if (yRng[0] < yRng[1]) {
            bounds.top = y0;
            bounds.bottom = y1;
          } else {
            bounds.top = y1;
            bounds.bottom = y0;
          }
          bounds.middle = (bounds.top + bounds.bottom) / 2;
          bounds.center = (bounds.left + bounds.right) / 2;
          labelClipPathData.push([
            [bounds.left, bounds.top],
            [bounds.right, bounds.top],
            [bounds.right, bounds.bottom],
            [bounds.left, bounds.bottom]
          ]);
          var plotDiagonal = Math.sqrt(xLen * xLen + yLen * yLen);
          var normLength = constants.LABELDISTANCE * plotDiagonal / Math.max(1, pathinfo.length / constants.LABELINCREASE);
          linegroup.each(function(d) {
            var textOpts = exports.calcTextOpts(d.level, contourFormat, dummyText, gd);
            d3.select(this).selectAll("path").each(function() {
              var path = this;
              var pathBounds = Lib.getVisibleSegment(path, bounds, textOpts.height / 2);
              if (!pathBounds) return;
              if (pathBounds.len < (textOpts.width + textOpts.height) * constants.LABELMIN) return;
              var maxLabels = Math.min(
                Math.ceil(pathBounds.len / normLength),
                constants.LABELMAX
              );
              for (var i = 0; i < maxLabels; i++) {
                var loc = exports.findBestTextLocation(
                  path,
                  pathBounds,
                  textOpts,
                  labelData,
                  bounds
                );
                if (!loc) break;
                exports.addLabelData(loc, textOpts, labelData, labelClipPathData);
              }
            });
          });
          dummyText.remove();
          exports.drawLabels(
            labelGroup,
            labelData,
            gd,
            lineClip,
            clipLinesForLabels ? labelClipPathData : null
          );
        }
        if (showLabels && !showLines) linegroup.remove();
      }
      exports.createLines = function(lineContainer, makeLines, pathinfo, isStatic) {
        var smoothing = pathinfo[0].smoothing;
        var linegroup = lineContainer.selectAll("g.contourlevel").data(makeLines ? pathinfo : []);
        linegroup.exit().remove();
        linegroup.enter().append("g").classed("contourlevel", true);
        if (makeLines) {
          var opencontourlines = linegroup.selectAll("path.openline").data(function(d) {
            return d.pedgepaths || d.edgepaths;
          });
          opencontourlines.exit().remove();
          opencontourlines.enter().append("path").classed("openline", true);
          opencontourlines.attr("d", function(d) {
            return Drawing.smoothopen(d, smoothing);
          }).style("stroke-miterlimit", 1).style("vector-effect", isStatic ? "none" : "non-scaling-stroke");
          var closedcontourlines = linegroup.selectAll("path.closedline").data(function(d) {
            return d.ppaths || d.paths;
          });
          closedcontourlines.exit().remove();
          closedcontourlines.enter().append("path").classed("closedline", true);
          closedcontourlines.attr("d", function(d) {
            return Drawing.smoothclosed(d, smoothing);
          }).style("stroke-miterlimit", 1).style("vector-effect", isStatic ? "none" : "non-scaling-stroke");
        }
        return linegroup;
      };
      exports.createLineClip = function(lineContainer, clipLinesForLabels, gd, uid) {
        var clips = gd._fullLayout._clips;
        var clipId = clipLinesForLabels ? "clipline" + uid : null;
        var lineClip = clips.selectAll("#" + clipId).data(clipLinesForLabels ? [0] : []);
        lineClip.exit().remove();
        lineClip.enter().append("clipPath").classed("contourlineclip", true).attr("id", clipId);
        Drawing.setClipUrl(lineContainer, clipId, gd);
        return lineClip;
      };
      exports.labelFormatter = function(gd, cd0) {
        var fullLayout = gd._fullLayout;
        var trace = cd0.trace;
        var contours = trace.contours;
        var formatAxis = {
          type: "linear",
          _id: "ycontour",
          showexponent: "all",
          exponentformat: "B"
        };
        if (contours.labelformat) {
          formatAxis.tickformat = contours.labelformat;
          setConvert(formatAxis, fullLayout);
        } else {
          var cOpts = Colorscale.extractOpts(trace);
          if (cOpts && cOpts.colorbar && cOpts.colorbar._axis) {
            formatAxis = cOpts.colorbar._axis;
          } else {
            if (contours.type === "constraint") {
              var value = contours.value;
              if (Lib.isArrayOrTypedArray(value)) {
                formatAxis.range = [value[0], value[value.length - 1]];
              } else formatAxis.range = [value, value];
            } else {
              formatAxis.range = [contours.start, contours.end];
              formatAxis.nticks = (contours.end - contours.start) / contours.size;
            }
            if (formatAxis.range[0] === formatAxis.range[1]) {
              formatAxis.range[1] += formatAxis.range[0] || 1;
            }
            if (!formatAxis.nticks) formatAxis.nticks = 1e3;
            setConvert(formatAxis, fullLayout);
            Axes.prepTicks(formatAxis);
            formatAxis._tmin = null;
            formatAxis._tmax = null;
          }
        }
        return function(v) {
          return Axes.tickText(formatAxis, v).text;
        };
      };
      exports.calcTextOpts = function(level, contourFormat, dummyText, gd) {
        var text = contourFormat(level);
        dummyText.text(text).call(svgTextUtils.convertToTspans, gd);
        var el = dummyText.node();
        var bBox = Drawing.bBox(el, true);
        return {
          text,
          width: bBox.width,
          height: bBox.height,
          fontSize: +el.style["font-size"].replace("px", ""),
          level,
          dy: (bBox.top + bBox.bottom) / 2
        };
      };
      exports.findBestTextLocation = function(path, pathBounds, textOpts, labelData, plotBounds) {
        var textWidth = textOpts.width;
        var p0, dp, pMax, pMin, loc;
        if (pathBounds.isClosed) {
          dp = pathBounds.len / costConstants.INITIALSEARCHPOINTS;
          p0 = pathBounds.min + dp / 2;
          pMax = pathBounds.max;
        } else {
          dp = (pathBounds.len - textWidth) / (costConstants.INITIALSEARCHPOINTS + 1);
          p0 = pathBounds.min + dp + textWidth / 2;
          pMax = pathBounds.max - (dp + textWidth) / 2;
        }
        var cost = Infinity;
        for (var j = 0; j < costConstants.ITERATIONS; j++) {
          for (var p = p0; p < pMax; p += dp) {
            var newLocation = Lib.getTextLocation(path, pathBounds.total, p, textWidth);
            var newCost = locationCost(newLocation, textOpts, labelData, plotBounds);
            if (newCost < cost) {
              cost = newCost;
              loc = newLocation;
              pMin = p;
            }
          }
          if (cost > costConstants.MAXCOST * 2) break;
          if (j) dp /= 2;
          p0 = pMin - dp / 2;
          pMax = p0 + dp * 1.5;
        }
        if (cost <= costConstants.MAXCOST) return loc;
      };
      function locationCost(loc, textOpts, labelData, bounds) {
        var halfWidth = textOpts.width / 2;
        var halfHeight = textOpts.height / 2;
        var x = loc.x;
        var y = loc.y;
        var theta = loc.theta;
        var dx = Math.cos(theta) * halfWidth;
        var dy = Math.sin(theta) * halfWidth;
        var normX = (x > bounds.center ? bounds.right - x : x - bounds.left) / (dx + Math.abs(Math.sin(theta) * halfHeight));
        var normY = (y > bounds.middle ? bounds.bottom - y : y - bounds.top) / (Math.abs(dy) + Math.cos(theta) * halfHeight);
        if (normX < 1 || normY < 1) return Infinity;
        var cost = costConstants.EDGECOST * (1 / (normX - 1) + 1 / (normY - 1));
        cost += costConstants.ANGLECOST * theta * theta;
        var x1 = x - dx;
        var y1 = y - dy;
        var x2 = x + dx;
        var y2 = y + dy;
        for (var i = 0; i < labelData.length; i++) {
          var labeli = labelData[i];
          var dxd = Math.cos(labeli.theta) * labeli.width / 2;
          var dyd = Math.sin(labeli.theta) * labeli.width / 2;
          var dist = Lib.segmentDistance(
            x1,
            y1,
            x2,
            y2,
            labeli.x - dxd,
            labeli.y - dyd,
            labeli.x + dxd,
            labeli.y + dyd
          ) * 2 / (textOpts.height + labeli.height);
          var sameLevel = labeli.level === textOpts.level;
          var distOffset = sameLevel ? costConstants.SAMELEVELDISTANCE : 1;
          if (dist <= distOffset) return Infinity;
          var distFactor = costConstants.NEIGHBORCOST * (sameLevel ? costConstants.SAMELEVELFACTOR : 1);
          cost += distFactor / (dist - distOffset);
        }
        return cost;
      }
      exports.addLabelData = function(loc, textOpts, labelData, labelClipPathData) {
        var fontSize = textOpts.fontSize;
        var w = textOpts.width + fontSize / 3;
        var h = Math.max(0, textOpts.height - fontSize / 3);
        var x = loc.x;
        var y = loc.y;
        var theta = loc.theta;
        var sin = Math.sin(theta);
        var cos = Math.cos(theta);
        var rotateXY = function(dx, dy) {
          return [
            x + dx * cos - dy * sin,
            y + dx * sin + dy * cos
          ];
        };
        var bBoxPts = [
          rotateXY(-w / 2, -h / 2),
          rotateXY(-w / 2, h / 2),
          rotateXY(w / 2, h / 2),
          rotateXY(w / 2, -h / 2)
        ];
        labelData.push({
          text: textOpts.text,
          x,
          y,
          dy: textOpts.dy,
          theta,
          level: textOpts.level,
          width: w,
          height: h
        });
        labelClipPathData.push(bBoxPts);
      };
      exports.drawLabels = function(labelGroup, labelData, gd, lineClip, labelClipPathData) {
        var labels = labelGroup.selectAll("text").data(labelData, function(d) {
          return d.text + "," + d.x + "," + d.y + "," + d.theta;
        });
        labels.exit().remove();
        labels.enter().append("text").attr({
          "data-notex": 1,
          "text-anchor": "middle"
        }).each(function(d) {
          var x = d.x + Math.sin(d.theta) * d.dy;
          var y = d.y - Math.cos(d.theta) * d.dy;
          d3.select(this).text(d.text).attr({
            x,
            y,
            transform: "rotate(" + 180 * d.theta / Math.PI + " " + x + " " + y + ")"
          }).call(svgTextUtils.convertToTspans, gd);
        });
        if (labelClipPathData) {
          var clipPath = "";
          for (var i = 0; i < labelClipPathData.length; i++) {
            clipPath += "M" + labelClipPathData[i].join("L") + "Z";
          }
          var lineClipPath = Lib.ensureSingle(lineClip, "path", "");
          lineClipPath.attr("d", clipPath);
        }
      };
      function clipGaps(plotGroup, plotinfo, gd, cd0, perimeter) {
        var trace = cd0.trace;
        var clips = gd._fullLayout._clips;
        var clipId = "clip" + trace.uid;
        var clipPath = clips.selectAll("#" + clipId).data(trace.connectgaps ? [] : [0]);
        clipPath.enter().append("clipPath").classed("contourclip", true).attr("id", clipId);
        clipPath.exit().remove();
        if (trace.connectgaps === false) {
          var clipPathInfo = {
            // fraction of the way from missing to present point
            // to draw the boundary.
            // if you make this 1 (or 1-epsilon) then a point in
            // a sea of missing data will disappear entirely.
            level: 0.9,
            crossings: {},
            starts: [],
            edgepaths: [],
            paths: [],
            xaxis: plotinfo.xaxis,
            yaxis: plotinfo.yaxis,
            x: cd0.x,
            y: cd0.y,
            // 0 = no data, 1 = data
            z: makeClipMask(cd0),
            smoothing: 0
          };
          makeCrossings([clipPathInfo]);
          findAllPaths([clipPathInfo]);
          closeBoundaries([clipPathInfo], { type: "levels" });
          var path = Lib.ensureSingle(clipPath, "path", "");
          path.attr(
            "d",
            (clipPathInfo.prefixBoundary ? "M" + perimeter.join("L") + "Z" : "") + joinAllPaths(clipPathInfo, perimeter)
          );
        } else clipId = null;
        Drawing.setClipUrl(plotGroup, clipId, gd);
      }
      function makeClipMask(cd0) {
        var empties = cd0.trace._emptypoints;
        var z = [];
        var m = cd0.z.length;
        var n = cd0.z[0].length;
        var i;
        var row = [];
        var emptyPoint;
        for (i = 0; i < n; i++) row.push(1);
        for (i = 0; i < m; i++) z.push(row.slice());
        for (i = 0; i < empties.length; i++) {
          emptyPoint = empties[i];
          z[emptyPoint[0]][emptyPoint[1]] = 0;
        }
        cd0.zmask = z;
        return z;
      }
    }
  });

  // src/traces/contour/make_color_map.js
  var require_make_color_map = __commonJS({
    "src/traces/contour/make_color_map.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Colorscale = require_colorscale();
      var endPlus = require_end_plus();
      module.exports = function makeColorMap(trace) {
        var contours = trace.contours;
        var start = contours.start;
        var end = endPlus(contours);
        var cs = contours.size || 1;
        var nc = Math.floor((end - start) / cs) + 1;
        var extra = contours.coloring === "lines" ? 0 : 1;
        var cOpts = Colorscale.extractOpts(trace);
        if (!isFinite(cs)) {
          cs = 1;
          nc = 1;
        }
        var scl = cOpts.reversescale ? Colorscale.flipScale(cOpts.colorscale) : cOpts.colorscale;
        var len = scl.length;
        var domain = new Array(len);
        var range = new Array(len);
        var si, i;
        var zmin0 = cOpts.min;
        var zmax0 = cOpts.max;
        if (contours.coloring === "heatmap") {
          for (i = 0; i < len; i++) {
            si = scl[i];
            domain[i] = si[0] * (zmax0 - zmin0) + zmin0;
            range[i] = si[1];
          }
          var zRange = d3.extent([
            zmin0,
            zmax0,
            contours.start,
            contours.start + cs * (nc - 1)
          ]);
          var zmin = zRange[zmin0 < zmax0 ? 0 : 1];
          var zmax = zRange[zmin0 < zmax0 ? 1 : 0];
          if (zmin !== zmin0) {
            domain.splice(0, 0, zmin);
            range.splice(0, 0, range[0]);
          }
          if (zmax !== zmax0) {
            domain.push(zmax);
            range.push(range[range.length - 1]);
          }
        } else {
          var zRangeInput = trace._input && (typeof trace._input.zmin === "number" && typeof trace._input.zmax === "number");
          if (zRangeInput && (start <= zmin0 || end >= zmax0)) {
            if (start <= zmin0) start = zmin0;
            if (end >= zmax0) end = zmax0;
            nc = Math.floor((end - start) / cs) + 1;
            extra = 0;
          }
          for (i = 0; i < len; i++) {
            si = scl[i];
            domain[i] = (si[0] * (nc + extra - 1) - extra / 2) * cs + start;
            range[i] = si[1];
          }
          if (zRangeInput || trace.autocontour) {
            if (domain[0] > zmin0) {
              domain.unshift(zmin0);
              range.unshift(range[0]);
            }
            if (domain[domain.length - 1] < zmax0) {
              domain.push(zmax0);
              range.push(range[range.length - 1]);
            }
          }
        }
        return Colorscale.makeColorScaleFunc(
          { domain, range },
          { noNumericCheck: true }
        );
      };
    }
  });

  // src/traces/contour/style.js
  var require_style7 = __commonJS({
    "src/traces/contour/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Drawing = require_drawing();
      var heatmapStyle = require_style6();
      var makeColorMap = require_make_color_map();
      module.exports = function style(gd) {
        var contours = d3.select(gd).selectAll("g.contour");
        contours.style("opacity", function(d) {
          return d[0].trace.opacity;
        });
        contours.each(function(d) {
          var c = d3.select(this);
          var trace = d[0].trace;
          var contours2 = trace.contours;
          var line = trace.line;
          var cs = contours2.size || 1;
          var start = contours2.start;
          var isConstraintType = contours2.type === "constraint";
          var colorLines = !isConstraintType && contours2.coloring === "lines";
          var colorFills = !isConstraintType && contours2.coloring === "fill";
          var colorMap = colorLines || colorFills ? makeColorMap(trace) : null;
          c.selectAll("g.contourlevel").each(function(d2) {
            d3.select(this).selectAll("path").call(
              Drawing.lineGroupStyle,
              line.width,
              colorLines ? colorMap(d2.level) : line.color,
              line.dash
            );
          });
          var labelFont = contours2.labelfont;
          c.selectAll("g.contourlabels text").each(function(d2) {
            Drawing.font(d3.select(this), {
              weight: labelFont.weight,
              style: labelFont.style,
              variant: labelFont.variant,
              textcase: labelFont.textcase,
              lineposition: labelFont.lineposition,
              shadow: labelFont.shadow,
              family: labelFont.family,
              size: labelFont.size,
              color: labelFont.color || (colorLines ? colorMap(d2.level) : line.color)
            });
          });
          if (isConstraintType) {
            c.selectAll("g.contourfill path").style("fill", trace.fillcolor);
          } else if (colorFills) {
            var firstFill;
            c.selectAll("g.contourfill path").style("fill", function(d2) {
              if (firstFill === void 0) firstFill = d2.level;
              return colorMap(d2.level + 0.5 * cs);
            });
            if (firstFill === void 0) firstFill = start;
            c.selectAll("g.contourbg path").style("fill", colorMap(firstFill - 0.5 * cs));
          }
        });
        heatmapStyle(gd);
      };
    }
  });

  // src/traces/contour/colorbar.js
  var require_colorbar3 = __commonJS({
    "src/traces/contour/colorbar.js"(exports, module) {
      "use strict";
      var Colorscale = require_colorscale();
      var makeColorMap = require_make_color_map();
      var endPlus = require_end_plus();
      function calc(gd, trace, opts) {
        var contours = trace.contours;
        var line = trace.line;
        var cs = contours.size || 1;
        var coloring = contours.coloring;
        var colorMap = makeColorMap(trace, { isColorbar: true });
        if (coloring === "heatmap") {
          var cOpts = Colorscale.extractOpts(trace);
          opts._fillgradient = cOpts.reversescale ? Colorscale.flipScale(cOpts.colorscale) : cOpts.colorscale;
          opts._zrange = [cOpts.min, cOpts.max];
        } else if (coloring === "fill") {
          opts._fillcolor = colorMap;
        }
        opts._line = {
          color: coloring === "lines" ? colorMap : line.color,
          width: contours.showlines !== false ? line.width : 0,
          dash: line.dash
        };
        opts._levels = {
          start: contours.start,
          end: endPlus(contours),
          size: cs
        };
      }
      module.exports = {
        min: "zmin",
        max: "zmax",
        calc
      };
    }
  });

  // src/traces/contour/hover.js
  var require_hover8 = __commonJS({
    "src/traces/contour/hover.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var heatmapHoverPoints = require_hover5();
      module.exports = function hoverPoints(pointData, xval, yval, hovermode, opts) {
        if (!opts) opts = {};
        opts.isContour = true;
        var hoverData = heatmapHoverPoints(pointData, xval, yval, hovermode, opts);
        if (hoverData) {
          hoverData.forEach(function(hoverPt) {
            var trace = hoverPt.trace;
            if (trace.contours.type === "constraint") {
              if (trace.fillcolor && Color.opacity(trace.fillcolor)) {
                hoverPt.color = Color.addOpacity(trace.fillcolor, 1);
              } else if (trace.contours.showlines && Color.opacity(trace.line.color)) {
                hoverPt.color = Color.addOpacity(trace.line.color, 1);
              }
            }
          });
        }
        return hoverData;
      };
    }
  });

  // src/traces/histogram2dcontour/index.js
  var require_histogram2dcontour = __commonJS({
    "src/traces/histogram2dcontour/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes29(),
        supplyDefaults: require_defaults24(),
        crossTraceDefaults: require_cross_trace_defaults3(),
        calc: require_calc10(),
        plot: require_plot6().plot,
        layerName: "contourlayer",
        style: require_style7(),
        colorbar: require_colorbar3(),
        hoverPoints: require_hover8(),
        moduleType: "trace",
        name: "histogram2dcontour",
        basePlotModule: require_cartesian(),
        categories: ["cartesian", "svg", "2dMap", "contour", "histogram", "showLegend"],
        meta: {}
      };
    }
  });

  // lib/histogram2dcontour.js
  var require_histogram2dcontour2 = __commonJS({
    "lib/histogram2dcontour.js"(exports, module) {
      "use strict";
      module.exports = require_histogram2dcontour();
    }
  });

  // src/traces/contour/constraint_defaults.js
  var require_constraint_defaults = __commonJS({
    "src/traces/contour/constraint_defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var handleLabelDefaults = require_label_defaults2();
      var Color = require_color();
      var addOpacity = Color.addOpacity;
      var opacity = Color.opacity;
      var filterOps = require_filter_ops();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var CONSTRAINT_REDUCTION = filterOps.CONSTRAINT_REDUCTION;
      var COMPARISON_OPS2 = filterOps.COMPARISON_OPS2;
      module.exports = function handleConstraintDefaults(traceIn, traceOut, coerce, layout, defaultColor, opts) {
        var contours = traceOut.contours;
        var showLines, lineColor, fillColor;
        var operation = coerce("contours.operation");
        contours._operation = CONSTRAINT_REDUCTION[operation];
        handleConstraintValueDefaults(coerce, contours);
        if (operation === "=") {
          showLines = contours.showlines = true;
        } else {
          showLines = coerce("contours.showlines");
          fillColor = coerce("fillcolor", addOpacity(
            (traceIn.line || {}).color || defaultColor,
            0.5
          ));
        }
        if (showLines) {
          var lineDfltColor = fillColor && opacity(fillColor) ? addOpacity(traceOut.fillcolor, 1) : defaultColor;
          lineColor = coerce("line.color", lineDfltColor);
          coerce("line.width", 2);
          coerce("line.dash");
        }
        coerce("line.smoothing");
        handleLabelDefaults(coerce, layout, lineColor, opts);
      };
      function handleConstraintValueDefaults(coerce, contours) {
        var zvalue;
        if (COMPARISON_OPS2.indexOf(contours.operation) === -1) {
          coerce("contours.value", [0, 1]);
          if (!isArrayOrTypedArray(contours.value)) {
            if (isNumeric(contours.value)) {
              zvalue = parseFloat(contours.value);
              contours.value = [zvalue, zvalue + 1];
            }
          } else if (contours.value.length > 2) {
            contours.value = contours.value.slice(2);
          } else if (contours.length === 0) {
            contours.value = [0, 1];
          } else if (contours.length < 2) {
            zvalue = parseFloat(contours.value[0]);
            contours.value = [zvalue, zvalue + 1];
          } else {
            contours.value = [
              parseFloat(contours.value[0]),
              parseFloat(contours.value[1])
            ];
          }
        } else {
          coerce("contours.value", 0);
          if (!isNumeric(contours.value)) {
            if (isArrayOrTypedArray(contours.value)) {
              contours.value = parseFloat(contours.value[0]);
            } else {
              contours.value = 0;
            }
          }
        }
      }
    }
  });

  // src/traces/contour/defaults.js
  var require_defaults25 = __commonJS({
    "src/traces/contour/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleXYZDefaults = require_xyz_defaults();
      var handlePeriodDefaults = require_period_defaults();
      var handleConstraintDefaults = require_constraint_defaults();
      var handleContoursDefaults = require_contours_defaults();
      var handleStyleDefaults = require_style_defaults3();
      var handleHeatmapLabelDefaults = require_label_defaults();
      var attributes = require_attributes28();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        function coerce2(attr) {
          return Lib.coerce2(traceIn, traceOut, attributes, attr);
        }
        var len = handleXYZDefaults(traceIn, traceOut, coerce, layout);
        if (!len) {
          traceOut.visible = false;
          return;
        }
        handlePeriodDefaults(traceIn, traceOut, layout, coerce);
        coerce("xhoverformat");
        coerce("yhoverformat");
        coerce("text");
        coerce("hovertext");
        coerce("hoverongaps");
        coerce("hovertemplate");
        var isConstraint = coerce("contours.type") === "constraint";
        coerce("connectgaps", Lib.isArray1D(traceOut.z));
        if (isConstraint) {
          handleConstraintDefaults(traceIn, traceOut, coerce, layout, defaultColor);
        } else {
          handleContoursDefaults(traceIn, traceOut, coerce, coerce2);
          handleStyleDefaults(traceIn, traceOut, coerce, layout);
        }
        if (traceOut.contours && traceOut.contours.coloring === "heatmap") {
          handleHeatmapLabelDefaults(coerce, layout);
        }
        coerce("zorder");
      };
    }
  });

  // src/traces/contour/index.js
  var require_contour = __commonJS({
    "src/traces/contour/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes28(),
        supplyDefaults: require_defaults25(),
        calc: require_calc10(),
        plot: require_plot6().plot,
        style: require_style7(),
        colorbar: require_colorbar3(),
        hoverPoints: require_hover8(),
        moduleType: "trace",
        name: "contour",
        basePlotModule: require_cartesian(),
        categories: ["cartesian", "svg", "2dMap", "contour", "showLegend"],
        meta: {}
      };
    }
  });

  // lib/contour.js
  var require_contour2 = __commonJS({
    "lib/contour.js"(exports, module) {
      "use strict";
      module.exports = require_contour();
    }
  });

  // src/traces/scatterternary/attributes.js
  var require_attributes30 = __commonJS({
    "src/traces/scatterternary/attributes.js"(exports, module) {
      "use strict";
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var texttemplateAttrs = require_template_attributes().texttemplateAttrs;
      var makeFillcolorAttr = require_fillcolor_attribute();
      var scatterAttrs = require_attributes12();
      var baseAttrs = require_attributes2();
      var colorScaleAttrs = require_attributes8();
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var scatterMarkerAttrs = scatterAttrs.marker;
      var scatterLineAttrs = scatterAttrs.line;
      var scatterMarkerLineAttrs = scatterMarkerAttrs.line;
      module.exports = {
        a: {
          valType: "data_array",
          editType: "calc"
        },
        b: {
          valType: "data_array",
          editType: "calc"
        },
        c: {
          valType: "data_array",
          editType: "calc"
        },
        sum: {
          valType: "number",
          dflt: 0,
          min: 0,
          editType: "calc"
        },
        mode: extendFlat({}, scatterAttrs.mode, { dflt: "markers" }),
        text: extendFlat({}, scatterAttrs.text, {}),
        texttemplate: texttemplateAttrs({ editType: "plot" }, {
          keys: ["a", "b", "c", "text"]
        }),
        hovertext: extendFlat({}, scatterAttrs.hovertext, {}),
        line: {
          color: scatterLineAttrs.color,
          width: scatterLineAttrs.width,
          dash,
          backoff: scatterLineAttrs.backoff,
          shape: extendFlat(
            {},
            scatterLineAttrs.shape,
            { values: ["linear", "spline"] }
          ),
          smoothing: scatterLineAttrs.smoothing,
          editType: "calc"
        },
        connectgaps: scatterAttrs.connectgaps,
        cliponaxis: scatterAttrs.cliponaxis,
        fill: extendFlat({}, scatterAttrs.fill, {
          values: ["none", "toself", "tonext"],
          dflt: "none"
        }),
        fillcolor: makeFillcolorAttr(),
        marker: extendFlat(
          {
            symbol: scatterMarkerAttrs.symbol,
            opacity: scatterMarkerAttrs.opacity,
            angle: scatterMarkerAttrs.angle,
            angleref: scatterMarkerAttrs.angleref,
            standoff: scatterMarkerAttrs.standoff,
            maxdisplayed: scatterMarkerAttrs.maxdisplayed,
            size: scatterMarkerAttrs.size,
            sizeref: scatterMarkerAttrs.sizeref,
            sizemin: scatterMarkerAttrs.sizemin,
            sizemode: scatterMarkerAttrs.sizemode,
            line: extendFlat(
              {
                width: scatterMarkerLineAttrs.width,
                editType: "calc"
              },
              colorScaleAttrs("marker.line")
            ),
            gradient: scatterMarkerAttrs.gradient,
            editType: "calc"
          },
          colorScaleAttrs("marker")
        ),
        textfont: scatterAttrs.textfont,
        textposition: scatterAttrs.textposition,
        selected: scatterAttrs.selected,
        unselected: scatterAttrs.unselected,
        hoverinfo: extendFlat({}, baseAttrs.hoverinfo, {
          flags: ["a", "b", "c", "text", "name"]
        }),
        hoveron: scatterAttrs.hoveron,
        hovertemplate: hovertemplateAttrs()
      };
    }
  });

  // src/traces/scatterternary/defaults.js
  var require_defaults26 = __commonJS({
    "src/traces/scatterternary/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var constants = require_constants8();
      var subTypes = require_subtypes();
      var handleMarkerDefaults = require_marker_defaults();
      var handleLineDefaults = require_line_defaults();
      var handleLineShapeDefaults = require_line_shape_defaults();
      var handleTextDefaults = require_text_defaults();
      var handleFillColorDefaults = require_fillcolor_defaults();
      var attributes = require_attributes30();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var a = coerce("a");
        var b = coerce("b");
        var c = coerce("c");
        var len;
        if (a) {
          len = a.length;
          if (b) {
            len = Math.min(len, b.length);
            if (c) len = Math.min(len, c.length);
          } else if (c) len = Math.min(len, c.length);
          else len = 0;
        } else if (b && c) {
          len = Math.min(b.length, c.length);
        }
        if (!len) {
          traceOut.visible = false;
          return;
        }
        traceOut._length = len;
        coerce("sum");
        coerce("text");
        coerce("hovertext");
        if (traceOut.hoveron !== "fills") coerce("hovertemplate");
        var defaultMode = len < constants.PTS_LINESONLY ? "lines+markers" : "lines";
        coerce("mode", defaultMode);
        if (subTypes.hasMarkers(traceOut)) {
          handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce, { gradient: true });
        }
        if (subTypes.hasLines(traceOut)) {
          handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce, { backoff: true });
          handleLineShapeDefaults(traceIn, traceOut, coerce);
          coerce("connectgaps");
        }
        if (subTypes.hasText(traceOut)) {
          coerce("texttemplate");
          handleTextDefaults(traceIn, traceOut, layout, coerce);
        }
        var dfltHoverOn = [];
        if (subTypes.hasMarkers(traceOut) || subTypes.hasText(traceOut)) {
          coerce("cliponaxis");
          coerce("marker.maxdisplayed");
          dfltHoverOn.push("points");
        }
        coerce("fill");
        if (traceOut.fill !== "none") {
          handleFillColorDefaults(traceIn, traceOut, defaultColor, coerce);
          if (!subTypes.hasLines(traceOut)) handleLineShapeDefaults(traceIn, traceOut, coerce);
        }
        if (traceOut.fill === "tonext" || traceOut.fill === "toself") {
          dfltHoverOn.push("fills");
        }
        coerce("hoveron", dfltHoverOn.join("+") || "points");
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
      };
    }
  });

  // src/traces/scatterternary/format_labels.js
  var require_format_labels2 = __commonJS({
    "src/traces/scatterternary/format_labels.js"(exports, module) {
      "use strict";
      var Axes = require_axes();
      module.exports = function formatLabels(cdi, trace, fullLayout) {
        var labels = {};
        var subplot = fullLayout[trace.subplot]._subplot;
        labels.aLabel = Axes.tickText(subplot.aaxis, cdi.a, true).text;
        labels.bLabel = Axes.tickText(subplot.baxis, cdi.b, true).text;
        labels.cLabel = Axes.tickText(subplot.caxis, cdi.c, true).text;
        return labels;
      };
    }
  });

  // src/traces/scatterternary/calc.js
  var require_calc11 = __commonJS({
    "src/traces/scatterternary/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var calcColorscale = require_colorscale_calc();
      var arraysToCalcdata = require_arrays_to_calcdata();
      var calcSelection = require_calc_selection();
      var calcMarkerSize = require_calc3().calcMarkerSize;
      var dataArrays = ["a", "b", "c"];
      var arraysToFill = { a: ["b", "c"], b: ["a", "c"], c: ["a", "b"] };
      module.exports = function calc(gd, trace) {
        var ternary = gd._fullLayout[trace.subplot];
        var displaySum = ternary.sum;
        var normSum = trace.sum || displaySum;
        var arrays = { a: trace.a, b: trace.b, c: trace.c };
        var ids = trace.ids;
        var i, j, dataArray, newArray, fillArray1, fillArray2;
        for (i = 0; i < dataArrays.length; i++) {
          dataArray = dataArrays[i];
          if (arrays[dataArray]) continue;
          fillArray1 = arrays[arraysToFill[dataArray][0]];
          fillArray2 = arrays[arraysToFill[dataArray][1]];
          newArray = new Array(fillArray1.length);
          for (j = 0; j < fillArray1.length; j++) {
            newArray[j] = normSum - fillArray1[j] - fillArray2[j];
          }
          arrays[dataArray] = newArray;
        }
        var serieslen = trace._length;
        var cd = new Array(serieslen);
        var a, b, c, norm, x, y;
        for (i = 0; i < serieslen; i++) {
          a = arrays.a[i];
          b = arrays.b[i];
          c = arrays.c[i];
          if (isNumeric(a) && isNumeric(b) && isNumeric(c)) {
            a = +a;
            b = +b;
            c = +c;
            norm = displaySum / (a + b + c);
            if (norm !== 1) {
              a *= norm;
              b *= norm;
              c *= norm;
            }
            y = a;
            x = c - b;
            cd[i] = { x, y, a, b, c };
            if (ids) {
              cd[i].id = ids[i];
            }
          } else cd[i] = { x: false, y: false };
        }
        calcMarkerSize(trace, serieslen);
        calcColorscale(gd, trace);
        arraysToCalcdata(cd, trace);
        calcSelection(cd, trace);
        return cd;
      };
    }
  });

  // src/traces/scatterternary/plot.js
  var require_plot7 = __commonJS({
    "src/traces/scatterternary/plot.js"(exports, module) {
      "use strict";
      var scatterPlot = require_plot();
      module.exports = function plot(gd, ternary, moduleCalcData) {
        var plotContainer = ternary.plotContainer;
        plotContainer.select(".scatterlayer").selectAll("*").remove();
        var xa = ternary.xaxis;
        var ya = ternary.yaxis;
        var plotinfo = {
          xaxis: xa,
          yaxis: ya,
          plot: plotContainer,
          layerClipId: ternary._hasClipOnAxisFalse ? ternary.clipIdRelative : null
        };
        var scatterLayer = ternary.layers.frontplot.select("g.scatterlayer");
        for (var i = 0; i < moduleCalcData.length; i++) {
          var cdi = moduleCalcData[i];
          if (cdi.length) {
            cdi[0].trace._xA = xa;
            cdi[0].trace._yA = ya;
          }
        }
        scatterPlot(gd, plotinfo, moduleCalcData, scatterLayer);
      };
    }
  });

  // src/traces/scatterternary/hover.js
  var require_hover9 = __commonJS({
    "src/traces/scatterternary/hover.js"(exports, module) {
      "use strict";
      var scatterHover = require_hover2();
      module.exports = function hoverPoints(pointData, xval, yval, hovermode) {
        var scatterPointData = scatterHover(pointData, xval, yval, hovermode);
        if (!scatterPointData || scatterPointData[0].index === false) return;
        var newPointData = scatterPointData[0];
        if (newPointData.index === void 0) {
          var yFracUp = 1 - newPointData.y0 / pointData.ya._length;
          var xLen = pointData.xa._length;
          var xMin = xLen * yFracUp / 2;
          var xMax = xLen - xMin;
          newPointData.x0 = Math.max(Math.min(newPointData.x0, xMax), xMin);
          newPointData.x1 = Math.max(Math.min(newPointData.x1, xMax), xMin);
          return scatterPointData;
        }
        var cdi = newPointData.cd[newPointData.index];
        var trace = newPointData.trace;
        var subplot = newPointData.subplot;
        newPointData.a = cdi.a;
        newPointData.b = cdi.b;
        newPointData.c = cdi.c;
        newPointData.xLabelVal = void 0;
        newPointData.yLabelVal = void 0;
        var fullLayout = {};
        fullLayout[trace.subplot] = { _subplot: subplot };
        var labels = trace._module.formatLabels(cdi, trace, fullLayout);
        newPointData.aLabel = labels.aLabel;
        newPointData.bLabel = labels.bLabel;
        newPointData.cLabel = labels.cLabel;
        var hoverinfo = cdi.hi || trace.hoverinfo;
        var text = [];
        function textPart(ax, val) {
          text.push(ax._hovertitle + ": " + val);
        }
        if (!trace.hovertemplate) {
          var parts = hoverinfo.split("+");
          if (parts.indexOf("all") !== -1) parts = ["a", "b", "c"];
          if (parts.indexOf("a") !== -1) textPart(subplot.aaxis, newPointData.aLabel);
          if (parts.indexOf("b") !== -1) textPart(subplot.baxis, newPointData.bLabel);
          if (parts.indexOf("c") !== -1) textPart(subplot.caxis, newPointData.cLabel);
        }
        newPointData.extraText = text.join("<br>");
        newPointData.hovertemplate = trace.hovertemplate;
        return scatterPointData;
      };
    }
  });

  // src/traces/scatterternary/event_data.js
  var require_event_data4 = __commonJS({
    "src/traces/scatterternary/event_data.js"(exports, module) {
      "use strict";
      module.exports = function eventData(out, pt, trace, cd, pointNumber) {
        if (pt.xa) out.xaxis = pt.xa;
        if (pt.ya) out.yaxis = pt.ya;
        if (cd[pointNumber]) {
          var cdi = cd[pointNumber];
          out.a = cdi.a;
          out.b = cdi.b;
          out.c = cdi.c;
        } else {
          out.a = pt.a;
          out.b = pt.b;
          out.c = pt.c;
        }
        return out;
      };
    }
  });

  // src/plots/ternary/ternary.js
  var require_ternary = __commonJS({
    "src/plots/ternary/ternary.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var tinycolor = require_tinycolor();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var _ = Lib._;
      var Color = require_color();
      var Drawing = require_drawing();
      var setConvert = require_set_convert();
      var extendFlat = require_extend().extendFlat;
      var Plots = require_plots();
      var Axes = require_axes();
      var dragElement = require_dragelement();
      var Fx = require_fx();
      var dragHelpers = require_helpers5();
      var freeMode = dragHelpers.freeMode;
      var rectMode = dragHelpers.rectMode;
      var Titles = require_titles();
      var prepSelect = require_selections().prepSelect;
      var selectOnClick = require_selections().selectOnClick;
      var clearOutline = require_selections().clearOutline;
      var clearSelectionsCache = require_selections().clearSelectionsCache;
      var constants = require_constants2();
      function Ternary(options, fullLayout) {
        this.id = options.id;
        this.graphDiv = options.graphDiv;
        this.init(fullLayout);
        this.makeFramework(fullLayout);
        this.updateFx(fullLayout);
        this.aTickLayout = null;
        this.bTickLayout = null;
        this.cTickLayout = null;
      }
      module.exports = Ternary;
      var proto = Ternary.prototype;
      proto.init = function(fullLayout) {
        this.container = fullLayout._ternarylayer;
        this.defs = fullLayout._defs;
        this.layoutId = fullLayout._uid;
        this.traceHash = {};
        this.layers = {};
      };
      proto.plot = function(ternaryCalcData, fullLayout) {
        var _this = this;
        var ternaryLayout = fullLayout[_this.id];
        var graphSize = fullLayout._size;
        _this._hasClipOnAxisFalse = false;
        for (var i = 0; i < ternaryCalcData.length; i++) {
          var trace = ternaryCalcData[i][0].trace;
          if (trace.cliponaxis === false) {
            _this._hasClipOnAxisFalse = true;
            break;
          }
        }
        _this.updateLayers(ternaryLayout);
        _this.adjustLayout(ternaryLayout, graphSize);
        Plots.generalUpdatePerTraceModule(_this.graphDiv, _this, ternaryCalcData, ternaryLayout);
        _this.layers.plotbg.select("path").call(Color.fill, ternaryLayout.bgcolor);
      };
      proto.makeFramework = function(fullLayout) {
        var _this = this;
        var gd = _this.graphDiv;
        var ternaryLayout = fullLayout[_this.id];
        var clipId = _this.clipId = "clip" + _this.layoutId + _this.id;
        var clipIdRelative = _this.clipIdRelative = "clip-relative" + _this.layoutId + _this.id;
        _this.clipDef = Lib.ensureSingleById(fullLayout._clips, "clipPath", clipId, function(s) {
          s.append("path").attr("d", "M0,0Z");
        });
        _this.clipDefRelative = Lib.ensureSingleById(fullLayout._clips, "clipPath", clipIdRelative, function(s) {
          s.append("path").attr("d", "M0,0Z");
        });
        _this.plotContainer = Lib.ensureSingle(_this.container, "g", _this.id);
        _this.updateLayers(ternaryLayout);
        Drawing.setClipUrl(_this.layers.backplot, clipId, gd);
        Drawing.setClipUrl(_this.layers.grids, clipId, gd);
      };
      proto.updateFx = function(fullLayout) {
        fullLayout._ternarylayer.selectAll("g.toplevel").style("cursor", fullLayout.dragmode === "pan" ? "move" : "crosshair");
      };
      proto.updateLayers = function(ternaryLayout) {
        var _this = this;
        var layers = _this.layers;
        var plotLayers = ["draglayer", "plotbg", "backplot", "grids"];
        if (ternaryLayout.aaxis.layer === "below traces") {
          plotLayers.push("aaxis", "aline");
        }
        if (ternaryLayout.baxis.layer === "below traces") {
          plotLayers.push("baxis", "bline");
        }
        if (ternaryLayout.caxis.layer === "below traces") {
          plotLayers.push("caxis", "cline");
        }
        plotLayers.push("frontplot");
        if (ternaryLayout.aaxis.layer === "above traces") {
          plotLayers.push("aaxis", "aline");
        }
        if (ternaryLayout.baxis.layer === "above traces") {
          plotLayers.push("baxis", "bline");
        }
        if (ternaryLayout.caxis.layer === "above traces") {
          plotLayers.push("caxis", "cline");
        }
        var toplevel = _this.plotContainer.selectAll("g.toplevel").data(plotLayers, String);
        var grids = ["agrid", "bgrid", "cgrid"];
        toplevel.enter().append("g").attr("class", function(d) {
          return "toplevel " + d;
        }).each(function(d) {
          var s = d3.select(this);
          layers[d] = s;
          if (d === "frontplot") {
            s.append("g").classed("scatterlayer", true);
          } else if (d === "backplot") {
            s.append("g").classed("maplayer", true);
          } else if (d === "plotbg") {
            s.append("path").attr("d", "M0,0Z");
          } else if (d === "aline" || d === "bline" || d === "cline") {
            s.append("path");
          } else if (d === "grids") {
            grids.forEach(function(d2) {
              layers[d2] = s.append("g").classed("grid " + d2, true);
            });
          }
        });
        toplevel.order();
      };
      var whRatio = Math.sqrt(4 / 3);
      proto.adjustLayout = function(ternaryLayout, graphSize) {
        var _this = this;
        var domain = ternaryLayout.domain;
        var xDomainCenter = (domain.x[0] + domain.x[1]) / 2;
        var yDomainCenter = (domain.y[0] + domain.y[1]) / 2;
        var xDomain = domain.x[1] - domain.x[0];
        var yDomain = domain.y[1] - domain.y[0];
        var wmax = xDomain * graphSize.w;
        var hmax = yDomain * graphSize.h;
        var sum = ternaryLayout.sum;
        var amin = ternaryLayout.aaxis.min;
        var bmin = ternaryLayout.baxis.min;
        var cmin = ternaryLayout.caxis.min;
        var x0, y0, w, h, xDomainFinal, yDomainFinal;
        if (wmax > whRatio * hmax) {
          h = hmax;
          w = h * whRatio;
        } else {
          w = wmax;
          h = w / whRatio;
        }
        xDomainFinal = xDomain * w / wmax;
        yDomainFinal = yDomain * h / hmax;
        x0 = graphSize.l + graphSize.w * xDomainCenter - w / 2;
        y0 = graphSize.t + graphSize.h * (1 - yDomainCenter) - h / 2;
        _this.x0 = x0;
        _this.y0 = y0;
        _this.w = w;
        _this.h = h;
        _this.sum = sum;
        _this.xaxis = {
          type: "linear",
          range: [amin + 2 * cmin - sum, sum - amin - 2 * bmin],
          domain: [
            xDomainCenter - xDomainFinal / 2,
            xDomainCenter + xDomainFinal / 2
          ],
          _id: "x"
        };
        setConvert(_this.xaxis, _this.graphDiv._fullLayout);
        _this.xaxis.setScale();
        _this.xaxis.isPtWithinRange = function(d) {
          return d.a >= _this.aaxis.range[0] && d.a <= _this.aaxis.range[1] && d.b >= _this.baxis.range[1] && d.b <= _this.baxis.range[0] && d.c >= _this.caxis.range[1] && d.c <= _this.caxis.range[0];
        };
        _this.yaxis = {
          type: "linear",
          range: [amin, sum - bmin - cmin],
          domain: [
            yDomainCenter - yDomainFinal / 2,
            yDomainCenter + yDomainFinal / 2
          ],
          _id: "y"
        };
        setConvert(_this.yaxis, _this.graphDiv._fullLayout);
        _this.yaxis.setScale();
        _this.yaxis.isPtWithinRange = function() {
          return true;
        };
        var yDomain0 = _this.yaxis.domain[0];
        var aaxis = _this.aaxis = extendFlat({}, ternaryLayout.aaxis, {
          range: [amin, sum - bmin - cmin],
          side: "left",
          // tickangle = 'auto' means 0 anyway for a y axis, need to coerce to 0 here
          // so we can shift by 30.
          tickangle: (+ternaryLayout.aaxis.tickangle || 0) - 30,
          domain: [yDomain0, yDomain0 + yDomainFinal * whRatio],
          anchor: "free",
          position: 0,
          _id: "y",
          _length: w
        });
        setConvert(aaxis, _this.graphDiv._fullLayout);
        aaxis.setScale();
        var baxis = _this.baxis = extendFlat({}, ternaryLayout.baxis, {
          range: [sum - amin - cmin, bmin],
          side: "bottom",
          domain: _this.xaxis.domain,
          anchor: "free",
          position: 0,
          _id: "x",
          _length: w
        });
        setConvert(baxis, _this.graphDiv._fullLayout);
        baxis.setScale();
        var caxis = _this.caxis = extendFlat({}, ternaryLayout.caxis, {
          range: [sum - amin - bmin, cmin],
          side: "right",
          tickangle: (+ternaryLayout.caxis.tickangle || 0) + 30,
          domain: [yDomain0, yDomain0 + yDomainFinal * whRatio],
          anchor: "free",
          position: 0,
          _id: "y",
          _length: w
        });
        setConvert(caxis, _this.graphDiv._fullLayout);
        caxis.setScale();
        var triangleClip = "M" + x0 + "," + (y0 + h) + "h" + w + "l-" + w / 2 + ",-" + h + "Z";
        _this.clipDef.select("path").attr("d", triangleClip);
        _this.layers.plotbg.select("path").attr("d", triangleClip);
        var triangleClipRelative = "M0," + h + "h" + w + "l-" + w / 2 + ",-" + h + "Z";
        _this.clipDefRelative.select("path").attr("d", triangleClipRelative);
        var plotTransform = strTranslate(x0, y0);
        _this.plotContainer.selectAll(".scatterlayer,.maplayer").attr("transform", plotTransform);
        _this.clipDefRelative.select("path").attr("transform", null);
        var bTransform = strTranslate(x0 - baxis._offset, y0 + h);
        _this.layers.baxis.attr("transform", bTransform);
        _this.layers.bgrid.attr("transform", bTransform);
        var aTransform = strTranslate(x0 + w / 2, y0) + "rotate(30)" + strTranslate(0, -aaxis._offset);
        _this.layers.aaxis.attr("transform", aTransform);
        _this.layers.agrid.attr("transform", aTransform);
        var cTransform = strTranslate(x0 + w / 2, y0) + "rotate(-30)" + strTranslate(0, -caxis._offset);
        _this.layers.caxis.attr("transform", cTransform);
        _this.layers.cgrid.attr("transform", cTransform);
        _this.drawAxes(true);
        _this.layers.aline.select("path").attr("d", aaxis.showline ? "M" + x0 + "," + (y0 + h) + "l" + w / 2 + ",-" + h : "M0,0").call(Color.stroke, aaxis.linecolor || "#000").style("stroke-width", (aaxis.linewidth || 0) + "px");
        _this.layers.bline.select("path").attr("d", baxis.showline ? "M" + x0 + "," + (y0 + h) + "h" + w : "M0,0").call(Color.stroke, baxis.linecolor || "#000").style("stroke-width", (baxis.linewidth || 0) + "px");
        _this.layers.cline.select("path").attr("d", caxis.showline ? "M" + (x0 + w / 2) + "," + y0 + "l" + w / 2 + "," + h : "M0,0").call(Color.stroke, caxis.linecolor || "#000").style("stroke-width", (caxis.linewidth || 0) + "px");
        if (!_this.graphDiv._context.staticPlot) {
          _this.initInteractions();
        }
        Drawing.setClipUrl(
          _this.layers.frontplot,
          _this._hasClipOnAxisFalse ? null : _this.clipId,
          _this.graphDiv
        );
      };
      proto.drawAxes = function(doTitles) {
        var _this = this;
        var gd = _this.graphDiv;
        var titlesuffix = _this.id.substr(7) + "title";
        var layers = _this.layers;
        var aaxis = _this.aaxis;
        var baxis = _this.baxis;
        var caxis = _this.caxis;
        _this.drawAx(aaxis);
        _this.drawAx(baxis);
        _this.drawAx(caxis);
        if (doTitles) {
          var apad = Math.max(
            aaxis.showticklabels ? aaxis.tickfont.size / 2 : 0,
            (caxis.showticklabels ? caxis.tickfont.size * 0.75 : 0) + (caxis.ticks === "outside" ? caxis.ticklen * 0.87 : 0)
          );
          var bpad = (baxis.showticklabels ? baxis.tickfont.size : 0) + (baxis.ticks === "outside" ? baxis.ticklen : 0) + 3;
          layers["a-title"] = Titles.draw(gd, "a" + titlesuffix, {
            propContainer: aaxis,
            propName: _this.id + ".aaxis.title",
            placeholder: _(gd, "Click to enter Component A title"),
            attributes: {
              x: _this.x0 + _this.w / 2,
              y: _this.y0 - aaxis.title.font.size / 3 - apad,
              "text-anchor": "middle"
            }
          });
          layers["b-title"] = Titles.draw(gd, "b" + titlesuffix, {
            propContainer: baxis,
            propName: _this.id + ".baxis.title",
            placeholder: _(gd, "Click to enter Component B title"),
            attributes: {
              x: _this.x0 - bpad,
              y: _this.y0 + _this.h + baxis.title.font.size * 0.83 + bpad,
              "text-anchor": "middle"
            }
          });
          layers["c-title"] = Titles.draw(gd, "c" + titlesuffix, {
            propContainer: caxis,
            propName: _this.id + ".caxis.title",
            placeholder: _(gd, "Click to enter Component C title"),
            attributes: {
              x: _this.x0 + _this.w + bpad,
              y: _this.y0 + _this.h + caxis.title.font.size * 0.83 + bpad,
              "text-anchor": "middle"
            }
          });
        }
      };
      proto.drawAx = function(ax) {
        var _this = this;
        var gd = _this.graphDiv;
        var axName = ax._name;
        var axLetter = axName.charAt(0);
        var axId = ax._id;
        var axLayer = _this.layers[axName];
        var counterAngle = 30;
        var stashKey = axLetter + "tickLayout";
        var newTickLayout = strTickLayout(ax);
        if (_this[stashKey] !== newTickLayout) {
          axLayer.selectAll("." + axId + "tick").remove();
          _this[stashKey] = newTickLayout;
        }
        ax.setScale();
        var vals = Axes.calcTicks(ax);
        var valsClipped = Axes.clipEnds(ax, vals);
        var transFn = Axes.makeTransTickFn(ax);
        var tickSign = Axes.getTickSigns(ax)[2];
        var caRad = Lib.deg2rad(counterAngle);
        var pad = tickSign * (ax.linewidth || 1) / 2;
        var len = tickSign * ax.ticklen;
        var w = _this.w;
        var h = _this.h;
        var tickPath = axLetter === "b" ? "M0," + pad + "l" + Math.sin(caRad) * len + "," + Math.cos(caRad) * len : "M" + pad + ",0l" + Math.cos(caRad) * len + "," + -Math.sin(caRad) * len;
        var gridPath = {
          a: "M0,0l" + h + ",-" + w / 2,
          b: "M0,0l-" + w / 2 + ",-" + h,
          c: "M0,0l-" + h + "," + w / 2
        }[axLetter];
        Axes.drawTicks(gd, ax, {
          vals: ax.ticks === "inside" ? valsClipped : vals,
          layer: axLayer,
          path: tickPath,
          transFn,
          crisp: false
        });
        Axes.drawGrid(gd, ax, {
          vals: valsClipped,
          layer: _this.layers[axLetter + "grid"],
          path: gridPath,
          transFn,
          crisp: false
        });
        Axes.drawLabels(gd, ax, {
          vals,
          layer: axLayer,
          transFn,
          labelFns: Axes.makeLabelFns(ax, 0, counterAngle)
        });
      };
      function strTickLayout(axLayout) {
        return axLayout.ticks + String(axLayout.ticklen) + String(axLayout.showticklabels);
      }
      var CLEN = constants.MINZOOM / 2 + 0.87;
      var BLPATH = "m-0.87,.5h" + CLEN + "v3h-" + (CLEN + 5.2) + "l" + (CLEN / 2 + 2.6) + ",-" + (CLEN * 0.87 + 4.5) + "l2.6,1.5l-" + CLEN / 2 + "," + CLEN * 0.87 + "Z";
      var BRPATH = "m0.87,.5h-" + CLEN + "v3h" + (CLEN + 5.2) + "l-" + (CLEN / 2 + 2.6) + ",-" + (CLEN * 0.87 + 4.5) + "l-2.6,1.5l" + CLEN / 2 + "," + CLEN * 0.87 + "Z";
      var TOPPATH = "m0,1l" + CLEN / 2 + "," + CLEN * 0.87 + "l2.6,-1.5l-" + (CLEN / 2 + 2.6) + ",-" + (CLEN * 0.87 + 4.5) + "l-" + (CLEN / 2 + 2.6) + "," + (CLEN * 0.87 + 4.5) + "l2.6,1.5l" + CLEN / 2 + ",-" + CLEN * 0.87 + "Z";
      var STARTMARKER = "m0.5,0.5h5v-2h-5v-5h-2v5h-5v2h5v5h2Z";
      var SHOWZOOMOUTTIP = true;
      proto.clearOutline = function() {
        clearSelectionsCache(this.dragOptions);
        clearOutline(this.dragOptions.gd);
      };
      proto.initInteractions = function() {
        var _this = this;
        var dragger = _this.layers.plotbg.select("path").node();
        var gd = _this.graphDiv;
        var zoomLayer = gd._fullLayout._zoomlayer;
        var scaleX;
        var scaleY;
        this.dragOptions = {
          element: dragger,
          gd,
          plotinfo: {
            id: _this.id,
            domain: gd._fullLayout[_this.id].domain,
            xaxis: _this.xaxis,
            yaxis: _this.yaxis
          },
          subplot: _this.id,
          prepFn: function(e, startX, startY) {
            _this.dragOptions.xaxes = [_this.xaxis];
            _this.dragOptions.yaxes = [_this.yaxis];
            scaleX = gd._fullLayout._invScaleX;
            scaleY = gd._fullLayout._invScaleY;
            var dragModeNow = _this.dragOptions.dragmode = gd._fullLayout.dragmode;
            if (freeMode(dragModeNow)) _this.dragOptions.minDrag = 1;
            else _this.dragOptions.minDrag = void 0;
            if (dragModeNow === "zoom") {
              _this.dragOptions.moveFn = zoomMove;
              _this.dragOptions.clickFn = clickZoomPan;
              _this.dragOptions.doneFn = zoomDone;
              zoomPrep(e, startX, startY);
            } else if (dragModeNow === "pan") {
              _this.dragOptions.moveFn = plotDrag;
              _this.dragOptions.clickFn = clickZoomPan;
              _this.dragOptions.doneFn = dragDone;
              panPrep();
              _this.clearOutline(gd);
            } else if (rectMode(dragModeNow) || freeMode(dragModeNow)) {
              prepSelect(e, startX, startY, _this.dragOptions, dragModeNow);
            }
          }
        };
        var x0, y0, mins0, span0, mins, lum, path0, dimmed, zb, corners;
        function makeUpdate(_mins) {
          var attrs = {};
          attrs[_this.id + ".aaxis.min"] = _mins.a;
          attrs[_this.id + ".baxis.min"] = _mins.b;
          attrs[_this.id + ".caxis.min"] = _mins.c;
          return attrs;
        }
        function clickZoomPan(numClicks, evt) {
          var clickMode = gd._fullLayout.clickmode;
          removeZoombox(gd);
          if (numClicks === 2) {
            gd.emit("plotly_doubleclick", null);
            Registry.call("_guiRelayout", gd, makeUpdate({ a: 0, b: 0, c: 0 }));
          }
          if (clickMode.indexOf("select") > -1 && numClicks === 1) {
            selectOnClick(evt, gd, [_this.xaxis], [_this.yaxis], _this.id, _this.dragOptions);
          }
          if (clickMode.indexOf("event") > -1) {
            Fx.click(gd, evt, _this.id);
          }
        }
        function zoomPrep(e, startX, startY) {
          var dragBBox = dragger.getBoundingClientRect();
          x0 = startX - dragBBox.left;
          y0 = startY - dragBBox.top;
          gd._fullLayout._calcInverseTransform(gd);
          var inverse = gd._fullLayout._invTransform;
          var transformedCoords = Lib.apply3DTransform(inverse)(x0, y0);
          x0 = transformedCoords[0];
          y0 = transformedCoords[1];
          mins0 = {
            a: _this.aaxis.range[0],
            b: _this.baxis.range[1],
            c: _this.caxis.range[1]
          };
          mins = mins0;
          span0 = _this.aaxis.range[1] - mins0.a;
          lum = tinycolor(_this.graphDiv._fullLayout[_this.id].bgcolor).getLuminance();
          path0 = "M0," + _this.h + "L" + _this.w / 2 + ", 0L" + _this.w + "," + _this.h + "Z";
          dimmed = false;
          zb = zoomLayer.append("path").attr("class", "zoombox").attr("transform", strTranslate(_this.x0, _this.y0)).style({
            fill: lum > 0.2 ? "rgba(0,0,0,0)" : "rgba(255,255,255,0)",
            "stroke-width": 0
          }).attr("d", path0);
          corners = zoomLayer.append("path").attr("class", "zoombox-corners").attr("transform", strTranslate(_this.x0, _this.y0)).style({
            fill: Color.background,
            stroke: Color.defaultLine,
            "stroke-width": 1,
            opacity: 0
          }).attr("d", "M0,0Z");
          _this.clearOutline(gd);
        }
        function getAFrac(x, y) {
          return 1 - y / _this.h;
        }
        function getBFrac(x, y) {
          return 1 - (x + (_this.h - y) / Math.sqrt(3)) / _this.w;
        }
        function getCFrac(x, y) {
          return (x - (_this.h - y) / Math.sqrt(3)) / _this.w;
        }
        function zoomMove(dx0, dy0) {
          var x1 = x0 + dx0 * scaleX;
          var y1 = y0 + dy0 * scaleY;
          var afrac = Math.max(0, Math.min(1, getAFrac(x0, y0), getAFrac(x1, y1)));
          var bfrac = Math.max(0, Math.min(1, getBFrac(x0, y0), getBFrac(x1, y1)));
          var cfrac = Math.max(0, Math.min(1, getCFrac(x0, y0), getCFrac(x1, y1)));
          var xLeft = (afrac / 2 + cfrac) * _this.w;
          var xRight = (1 - afrac / 2 - bfrac) * _this.w;
          var xCenter = (xLeft + xRight) / 2;
          var xSpan = xRight - xLeft;
          var yBottom = (1 - afrac) * _this.h;
          var yTop = yBottom - xSpan / whRatio;
          if (xSpan < constants.MINZOOM) {
            mins = mins0;
            zb.attr("d", path0);
            corners.attr("d", "M0,0Z");
          } else {
            mins = {
              a: mins0.a + afrac * span0,
              b: mins0.b + bfrac * span0,
              c: mins0.c + cfrac * span0
            };
            zb.attr("d", path0 + "M" + xLeft + "," + yBottom + "H" + xRight + "L" + xCenter + "," + yTop + "L" + xLeft + "," + yBottom + "Z");
            corners.attr("d", "M" + x0 + "," + y0 + STARTMARKER + "M" + xLeft + "," + yBottom + BLPATH + "M" + xRight + "," + yBottom + BRPATH + "M" + xCenter + "," + yTop + TOPPATH);
          }
          if (!dimmed) {
            zb.transition().style("fill", lum > 0.2 ? "rgba(0,0,0,0.4)" : "rgba(255,255,255,0.3)").duration(200);
            corners.transition().style("opacity", 1).duration(200);
            dimmed = true;
          }
          gd.emit("plotly_relayouting", makeUpdate(mins));
        }
        function zoomDone() {
          removeZoombox(gd);
          if (mins === mins0) return;
          Registry.call("_guiRelayout", gd, makeUpdate(mins));
          if (SHOWZOOMOUTTIP && gd.data && gd._context.showTips) {
            Lib.notifier(_(gd, "Double-click to zoom back out"), "long");
            SHOWZOOMOUTTIP = false;
          }
        }
        function panPrep() {
          mins0 = {
            a: _this.aaxis.range[0],
            b: _this.baxis.range[1],
            c: _this.caxis.range[1]
          };
          mins = mins0;
        }
        function plotDrag(dx, dy) {
          var dxScaled = dx / _this.xaxis._m;
          var dyScaled = dy / _this.yaxis._m;
          mins = {
            a: mins0.a - dyScaled,
            b: mins0.b + (dxScaled + dyScaled) / 2,
            c: mins0.c - (dxScaled - dyScaled) / 2
          };
          var minsorted = [mins.a, mins.b, mins.c].sort(Lib.sorterAsc);
          var minindices = {
            a: minsorted.indexOf(mins.a),
            b: minsorted.indexOf(mins.b),
            c: minsorted.indexOf(mins.c)
          };
          if (minsorted[0] < 0) {
            if (minsorted[1] + minsorted[0] / 2 < 0) {
              minsorted[2] += minsorted[0] + minsorted[1];
              minsorted[0] = minsorted[1] = 0;
            } else {
              minsorted[2] += minsorted[0] / 2;
              minsorted[1] += minsorted[0] / 2;
              minsorted[0] = 0;
            }
            mins = {
              a: minsorted[minindices.a],
              b: minsorted[minindices.b],
              c: minsorted[minindices.c]
            };
            dy = (mins0.a - mins.a) * _this.yaxis._m;
            dx = (mins0.c - mins.c - mins0.b + mins.b) * _this.xaxis._m;
          }
          var plotTransform = strTranslate(_this.x0 + dx, _this.y0 + dy);
          _this.plotContainer.selectAll(".scatterlayer,.maplayer").attr("transform", plotTransform);
          var plotTransform2 = strTranslate(-dx, -dy);
          _this.clipDefRelative.select("path").attr("transform", plotTransform2);
          _this.aaxis.range = [mins.a, _this.sum - mins.b - mins.c];
          _this.baxis.range = [_this.sum - mins.a - mins.c, mins.b];
          _this.caxis.range = [_this.sum - mins.a - mins.b, mins.c];
          _this.drawAxes(false);
          if (_this._hasClipOnAxisFalse) {
            _this.plotContainer.select(".scatterlayer").selectAll(".trace").call(Drawing.hideOutsideRangePoints, _this);
          }
          gd.emit("plotly_relayouting", makeUpdate(mins));
        }
        function dragDone() {
          Registry.call("_guiRelayout", gd, makeUpdate(mins));
        }
        dragger.onmousemove = function(evt) {
          Fx.hover(gd, evt, _this.id);
          gd._fullLayout._lasthover = dragger;
          gd._fullLayout._hoversubplot = _this.id;
        };
        dragger.onmouseout = function(evt) {
          if (gd._dragging) return;
          dragElement.unhover(gd, evt);
        };
        dragElement.init(this.dragOptions);
      };
      function removeZoombox(gd) {
        d3.select(gd).selectAll(".zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners").remove();
      }
    }
  });

  // src/plots/ternary/layout_attributes.js
  var require_layout_attributes8 = __commonJS({
    "src/plots/ternary/layout_attributes.js"(exports, module) {
      "use strict";
      var colorAttrs = require_attributes3();
      var domainAttrs = require_domain().attributes;
      var axesAttrs = require_layout_attributes4();
      var overrideAll = require_edit_types().overrideAll;
      var extendFlat = require_extend().extendFlat;
      var ternaryAxesAttrs = {
        title: {
          text: axesAttrs.title.text,
          font: axesAttrs.title.font
          // TODO does standoff here make sense?
        },
        color: axesAttrs.color,
        // ticks
        tickmode: axesAttrs.minor.tickmode,
        nticks: extendFlat({}, axesAttrs.nticks, { dflt: 6, min: 1 }),
        tick0: axesAttrs.tick0,
        dtick: axesAttrs.dtick,
        tickvals: axesAttrs.tickvals,
        ticktext: axesAttrs.ticktext,
        ticks: axesAttrs.ticks,
        ticklen: axesAttrs.ticklen,
        tickwidth: axesAttrs.tickwidth,
        tickcolor: axesAttrs.tickcolor,
        ticklabelstep: axesAttrs.ticklabelstep,
        showticklabels: axesAttrs.showticklabels,
        labelalias: axesAttrs.labelalias,
        showtickprefix: axesAttrs.showtickprefix,
        tickprefix: axesAttrs.tickprefix,
        showticksuffix: axesAttrs.showticksuffix,
        ticksuffix: axesAttrs.ticksuffix,
        showexponent: axesAttrs.showexponent,
        exponentformat: axesAttrs.exponentformat,
        minexponent: axesAttrs.minexponent,
        separatethousands: axesAttrs.separatethousands,
        tickfont: axesAttrs.tickfont,
        tickangle: axesAttrs.tickangle,
        tickformat: axesAttrs.tickformat,
        tickformatstops: axesAttrs.tickformatstops,
        hoverformat: axesAttrs.hoverformat,
        // lines and grids
        showline: extendFlat({}, axesAttrs.showline, { dflt: true }),
        linecolor: axesAttrs.linecolor,
        linewidth: axesAttrs.linewidth,
        showgrid: extendFlat({}, axesAttrs.showgrid, { dflt: true }),
        gridcolor: axesAttrs.gridcolor,
        gridwidth: axesAttrs.gridwidth,
        griddash: axesAttrs.griddash,
        layer: axesAttrs.layer,
        // range
        min: {
          valType: "number",
          dflt: 0,
          min: 0
        }
      };
      var attrs = module.exports = overrideAll({
        domain: domainAttrs({ name: "ternary" }),
        bgcolor: {
          valType: "color",
          dflt: colorAttrs.background
        },
        sum: {
          valType: "number",
          dflt: 1,
          min: 0
        },
        aaxis: ternaryAxesAttrs,
        baxis: ternaryAxesAttrs,
        caxis: ternaryAxesAttrs
      }, "plot", "from-root");
      attrs.uirevision = {
        valType: "any",
        editType: "none"
      };
      attrs.aaxis.uirevision = attrs.baxis.uirevision = attrs.caxis.uirevision = {
        valType: "any",
        editType: "none"
      };
    }
  });

  // src/plots/subplot_defaults.js
  var require_subplot_defaults = __commonJS({
    "src/plots/subplot_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var handleDomainDefaults = require_domain().defaults;
      module.exports = function handleSubplotDefaults(layoutIn, layoutOut, fullData, opts) {
        var subplotType = opts.type;
        var subplotAttributes = opts.attributes;
        var handleDefaults = opts.handleDefaults;
        var partition = opts.partition || "x";
        var ids = layoutOut._subplots[subplotType];
        var idsLength = ids.length;
        var baseId = idsLength && ids[0].replace(/\d+$/, "");
        var subplotLayoutIn, subplotLayoutOut;
        function coerce(attr, dflt) {
          return Lib.coerce(subplotLayoutIn, subplotLayoutOut, subplotAttributes, attr, dflt);
        }
        for (var i = 0; i < idsLength; i++) {
          var id = ids[i];
          if (layoutIn[id]) subplotLayoutIn = layoutIn[id];
          else subplotLayoutIn = layoutIn[id] = {};
          subplotLayoutOut = Template.newContainer(layoutOut, id, baseId);
          if (!opts.noUirevision) coerce("uirevision", layoutOut.uirevision);
          var dfltDomains = {};
          dfltDomains[partition] = [i / idsLength, (i + 1) / idsLength];
          handleDomainDefaults(subplotLayoutOut, layoutOut, coerce, dfltDomains);
          opts.id = id;
          handleDefaults(subplotLayoutIn, subplotLayoutOut, coerce, opts);
        }
      };
    }
  });

  // src/plots/ternary/layout_defaults.js
  var require_layout_defaults7 = __commonJS({
    "src/plots/ternary/layout_defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var Template = require_plot_template();
      var Lib = require_lib();
      var handleSubplotDefaults = require_subplot_defaults();
      var handleTickLabelDefaults = require_tick_label_defaults();
      var handlePrefixSuffixDefaults = require_prefix_suffix_defaults();
      var handleTickMarkDefaults = require_tick_mark_defaults();
      var handleTickValueDefaults = require_tick_value_defaults();
      var handleLineGridDefaults = require_line_grid_defaults();
      var layoutAttributes = require_layout_attributes8();
      var axesNames = ["aaxis", "baxis", "caxis"];
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
        handleSubplotDefaults(layoutIn, layoutOut, fullData, {
          type: "ternary",
          attributes: layoutAttributes,
          handleDefaults: handleTernaryDefaults,
          font: layoutOut.font,
          paper_bgcolor: layoutOut.paper_bgcolor
        });
      };
      function handleTernaryDefaults(ternaryLayoutIn, ternaryLayoutOut, coerce, options) {
        var bgColor = coerce("bgcolor");
        var sum = coerce("sum");
        options.bgColor = Color.combine(bgColor, options.paper_bgcolor);
        var axName, containerIn, containerOut;
        for (var j = 0; j < axesNames.length; j++) {
          axName = axesNames[j];
          containerIn = ternaryLayoutIn[axName] || {};
          containerOut = Template.newContainer(ternaryLayoutOut, axName);
          containerOut._name = axName;
          handleAxisDefaults(containerIn, containerOut, options, ternaryLayoutOut);
        }
        var aaxis = ternaryLayoutOut.aaxis;
        var baxis = ternaryLayoutOut.baxis;
        var caxis = ternaryLayoutOut.caxis;
        if (aaxis.min + baxis.min + caxis.min >= sum) {
          aaxis.min = 0;
          baxis.min = 0;
          caxis.min = 0;
          if (ternaryLayoutIn.aaxis) delete ternaryLayoutIn.aaxis.min;
          if (ternaryLayoutIn.baxis) delete ternaryLayoutIn.baxis.min;
          if (ternaryLayoutIn.caxis) delete ternaryLayoutIn.caxis.min;
        }
      }
      function handleAxisDefaults(containerIn, containerOut, options, ternaryLayoutOut) {
        var axAttrs = layoutAttributes[containerOut._name];
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, axAttrs, attr, dflt);
        }
        coerce("uirevision", ternaryLayoutOut.uirevision);
        containerOut.type = "linear";
        var dfltColor = coerce("color");
        var dfltFontColor = dfltColor !== axAttrs.color.dflt ? dfltColor : options.font.color;
        var axName = containerOut._name;
        var letterUpper = axName.charAt(0).toUpperCase();
        var dfltTitle = "Component " + letterUpper;
        var title = coerce("title.text", dfltTitle);
        containerOut._hovertitle = title === dfltTitle ? title : letterUpper;
        Lib.coerceFont(coerce, "title.font", options.font, { overrideDflt: {
          size: Lib.bigFont(options.font.size),
          color: dfltFontColor
        } });
        coerce("min");
        handleTickValueDefaults(containerIn, containerOut, coerce, "linear");
        handlePrefixSuffixDefaults(containerIn, containerOut, coerce, "linear");
        handleTickLabelDefaults(containerIn, containerOut, coerce, "linear", {
          noAutotickangles: true,
          noTicklabelshift: true,
          noTicklabelstandoff: true
        });
        handleTickMarkDefaults(
          containerIn,
          containerOut,
          coerce,
          { outerTicks: true }
        );
        var showTickLabels = coerce("showticklabels");
        if (showTickLabels) {
          Lib.coerceFont(coerce, "tickfont", options.font, { overrideDflt: {
            color: dfltFontColor
          } });
          coerce("tickangle");
          coerce("tickformat");
        }
        handleLineGridDefaults(containerIn, containerOut, coerce, {
          dfltColor,
          bgColor: options.bgColor,
          // default grid color is darker here (60%, vs cartesian default ~91%)
          // because the grid is not square so the eye needs heavier cues to follow
          blend: 60,
          showLine: true,
          showGrid: true,
          noZeroLine: true,
          attributes: axAttrs
        });
        coerce("hoverformat");
        coerce("layer");
      }
    }
  });

  // src/plots/ternary/index.js
  var require_ternary2 = __commonJS({
    "src/plots/ternary/index.js"(exports) {
      "use strict";
      var Ternary = require_ternary();
      var getSubplotCalcData = require_get_data().getSubplotCalcData;
      var counterRegex = require_lib().counterRegex;
      var TERNARY = "ternary";
      exports.name = TERNARY;
      var attr = exports.attr = "subplot";
      exports.idRoot = TERNARY;
      exports.idRegex = exports.attrRegex = counterRegex(TERNARY);
      var attributes = exports.attributes = {};
      attributes[attr] = {
        valType: "subplotid",
        dflt: "ternary",
        editType: "calc"
      };
      exports.layoutAttributes = require_layout_attributes8();
      exports.supplyLayoutDefaults = require_layout_defaults7();
      exports.plot = function plot(gd) {
        var fullLayout = gd._fullLayout;
        var calcData = gd.calcdata;
        var ternaryIds = fullLayout._subplots[TERNARY];
        for (var i = 0; i < ternaryIds.length; i++) {
          var ternaryId = ternaryIds[i];
          var ternaryCalcData = getSubplotCalcData(calcData, TERNARY, ternaryId);
          var ternary = fullLayout[ternaryId]._subplot;
          if (!ternary) {
            ternary = new Ternary(
              {
                id: ternaryId,
                graphDiv: gd,
                container: fullLayout._ternarylayer.node()
              },
              fullLayout
            );
            fullLayout[ternaryId]._subplot = ternary;
          }
          ternary.plot(ternaryCalcData, fullLayout, gd._promises);
        }
      };
      exports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var oldTernaryKeys = oldFullLayout._subplots[TERNARY] || [];
        for (var i = 0; i < oldTernaryKeys.length; i++) {
          var oldTernaryKey = oldTernaryKeys[i];
          var oldTernary = oldFullLayout[oldTernaryKey]._subplot;
          if (!newFullLayout[oldTernaryKey] && !!oldTernary) {
            oldTernary.plotContainer.remove();
            oldTernary.clipDef.remove();
            oldTernary.clipDefRelative.remove();
            oldTernary.layers["a-title"].remove();
            oldTernary.layers["b-title"].remove();
            oldTernary.layers["c-title"].remove();
          }
        }
      };
      exports.updateFx = function(gd) {
        var fullLayout = gd._fullLayout;
        fullLayout._ternarylayer.selectAll("g.toplevel").style("cursor", fullLayout.dragmode === "pan" ? "move" : "crosshair");
      };
    }
  });

  // src/traces/scatterternary/index.js
  var require_scatterternary = __commonJS({
    "src/traces/scatterternary/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes30(),
        supplyDefaults: require_defaults26(),
        colorbar: require_marker_colorbar(),
        formatLabels: require_format_labels2(),
        calc: require_calc11(),
        plot: require_plot7(),
        style: require_style2().style,
        styleOnSelect: require_style2().styleOnSelect,
        hoverPoints: require_hover9(),
        selectPoints: require_select2(),
        eventData: require_event_data4(),
        moduleType: "trace",
        name: "scatterternary",
        basePlotModule: require_ternary2(),
        categories: ["ternary", "symbols", "showLegend", "scatter-like"],
        meta: {}
      };
    }
  });

  // lib/scatterternary.js
  var require_scatterternary2 = __commonJS({
    "lib/scatterternary.js"(exports, module) {
      "use strict";
      module.exports = require_scatterternary();
    }
  });

  // src/traces/violin/attributes.js
  var require_attributes31 = __commonJS({
    "src/traces/violin/attributes.js"(exports, module) {
      "use strict";
      var boxAttrs = require_attributes24();
      var extendFlat = require_extend().extendFlat;
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      module.exports = {
        y: boxAttrs.y,
        x: boxAttrs.x,
        x0: boxAttrs.x0,
        y0: boxAttrs.y0,
        xhoverformat: axisHoverFormat("x"),
        yhoverformat: axisHoverFormat("y"),
        name: extendFlat({}, boxAttrs.name, {}),
        orientation: extendFlat({}, boxAttrs.orientation, {}),
        bandwidth: {
          valType: "number",
          min: 0,
          editType: "calc"
        },
        scalegroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        scalemode: {
          valType: "enumerated",
          values: ["width", "count"],
          dflt: "width",
          editType: "calc"
        },
        spanmode: {
          valType: "enumerated",
          values: ["soft", "hard", "manual"],
          dflt: "soft",
          editType: "calc"
        },
        span: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "calc" },
            { valType: "any", editType: "calc" }
          ],
          editType: "calc"
        },
        line: {
          color: {
            valType: "color",
            editType: "style"
          },
          width: {
            valType: "number",
            min: 0,
            dflt: 2,
            editType: "style"
          },
          editType: "plot"
        },
        fillcolor: boxAttrs.fillcolor,
        points: extendFlat({}, boxAttrs.boxpoints, {}),
        jitter: extendFlat({}, boxAttrs.jitter, {}),
        pointpos: extendFlat({}, boxAttrs.pointpos, {}),
        width: extendFlat({}, boxAttrs.width, {}),
        marker: boxAttrs.marker,
        text: boxAttrs.text,
        hovertext: boxAttrs.hovertext,
        hovertemplate: boxAttrs.hovertemplate,
        quartilemethod: boxAttrs.quartilemethod,
        box: {
          visible: {
            valType: "boolean",
            dflt: false,
            editType: "plot"
          },
          width: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 0.25,
            editType: "plot"
          },
          fillcolor: {
            valType: "color",
            editType: "style"
          },
          line: {
            color: {
              valType: "color",
              editType: "style"
            },
            width: {
              valType: "number",
              min: 0,
              editType: "style"
            },
            editType: "style"
          },
          editType: "plot"
        },
        meanline: {
          visible: {
            valType: "boolean",
            dflt: false,
            editType: "plot"
          },
          color: {
            valType: "color",
            editType: "style"
          },
          width: {
            valType: "number",
            min: 0,
            editType: "style"
          },
          editType: "plot"
        },
        side: {
          valType: "enumerated",
          values: ["both", "positive", "negative"],
          dflt: "both",
          editType: "calc"
        },
        offsetgroup: boxAttrs.offsetgroup,
        alignmentgroup: boxAttrs.alignmentgroup,
        selected: boxAttrs.selected,
        unselected: boxAttrs.unselected,
        hoveron: {
          valType: "flaglist",
          flags: ["violins", "points", "kde"],
          dflt: "violins+points+kde",
          extras: ["all"],
          editType: "style"
        },
        zorder: boxAttrs.zorder
      };
    }
  });

  // src/traces/violin/layout_attributes.js
  var require_layout_attributes9 = __commonJS({
    "src/traces/violin/layout_attributes.js"(exports, module) {
      "use strict";
      var boxLayoutAttrs = require_layout_attributes7();
      var extendFlat = require_lib().extendFlat;
      module.exports = {
        violinmode: extendFlat({}, boxLayoutAttrs.boxmode, {}),
        violingap: extendFlat({}, boxLayoutAttrs.boxgap, {}),
        violingroupgap: extendFlat({}, boxLayoutAttrs.boxgroupgap, {})
      };
    }
  });

  // src/traces/violin/defaults.js
  var require_defaults27 = __commonJS({
    "src/traces/violin/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var boxDefaults = require_defaults20();
      var attributes = require_attributes31();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        function coerce2(attr, dflt) {
          return Lib.coerce2(traceIn, traceOut, attributes, attr, dflt);
        }
        boxDefaults.handleSampleDefaults(traceIn, traceOut, coerce, layout);
        if (traceOut.visible === false) return;
        coerce("bandwidth");
        coerce("side");
        var width = coerce("width");
        if (!width) {
          coerce("scalegroup", traceOut.name);
          coerce("scalemode");
        }
        var span = coerce("span");
        var spanmodeDflt;
        if (Array.isArray(span)) spanmodeDflt = "manual";
        coerce("spanmode", spanmodeDflt);
        var lineColor = coerce("line.color", (traceIn.marker || {}).color || defaultColor);
        var lineWidth = coerce("line.width");
        var fillColor = coerce("fillcolor", Color.addOpacity(traceOut.line.color, 0.5));
        boxDefaults.handlePointsDefaults(traceIn, traceOut, coerce, { prefix: "" });
        var boxWidth = coerce2("box.width");
        var boxFillColor = coerce2("box.fillcolor", fillColor);
        var boxLineColor = coerce2("box.line.color", lineColor);
        var boxLineWidth = coerce2("box.line.width", lineWidth);
        var boxVisible = coerce("box.visible", Boolean(boxWidth || boxFillColor || boxLineColor || boxLineWidth));
        if (!boxVisible) traceOut.box = { visible: false };
        var meanLineColor = coerce2("meanline.color", lineColor);
        var meanLineWidth = coerce2("meanline.width", lineWidth);
        var meanLineVisible = coerce("meanline.visible", Boolean(meanLineColor || meanLineWidth));
        if (!meanLineVisible) traceOut.meanline = { visible: false };
        coerce("quartilemethod");
        coerce("zorder");
      };
    }
  });

  // src/traces/violin/layout_defaults.js
  var require_layout_defaults8 = __commonJS({
    "src/traces/violin/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes9();
      var boxLayoutDefaults = require_layout_defaults6();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        boxLayoutDefaults._supply(layoutIn, layoutOut, fullData, coerce, "violin");
      };
    }
  });

  // src/traces/violin/helpers.js
  var require_helpers13 = __commonJS({
    "src/traces/violin/helpers.js"(exports) {
      "use strict";
      var Lib = require_lib();
      var kernels = {
        gaussian: function(v) {
          return 1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * v * v);
        }
      };
      exports.makeKDE = function(calcItem, trace, vals) {
        var len = vals.length;
        var kernel = kernels.gaussian;
        var bandwidth = calcItem.bandwidth;
        var factor = 1 / (len * bandwidth);
        return function(x) {
          var sum = 0;
          for (var i = 0; i < len; i++) {
            sum += kernel((x - vals[i]) / bandwidth);
          }
          return factor * sum;
        };
      };
      exports.getPositionOnKdePath = function(calcItem, trace, valuePx) {
        var posLetter, valLetter;
        if (trace.orientation === "h") {
          posLetter = "y";
          valLetter = "x";
        } else {
          posLetter = "x";
          valLetter = "y";
        }
        var pointOnPath = Lib.findPointOnPath(
          calcItem.path,
          valuePx,
          valLetter,
          { pathLength: calcItem.pathLength }
        );
        var posCenterPx = calcItem.posCenterPx;
        var posOnPath0 = pointOnPath[posLetter];
        var posOnPath1 = trace.side === "both" ? 2 * posCenterPx - posOnPath0 : posCenterPx;
        return [posOnPath0, posOnPath1];
      };
      exports.getKdeValue = function(calcItem, trace, valueDist) {
        var vals = calcItem.pts.map(exports.extractVal);
        var kde = exports.makeKDE(calcItem, trace, vals);
        return kde(valueDist) / calcItem.posDensityScale;
      };
      exports.extractVal = function(o) {
        return o.v;
      };
    }
  });

  // src/traces/violin/calc.js
  var require_calc12 = __commonJS({
    "src/traces/violin/calc.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var boxCalc = require_calc6();
      var helpers = require_helpers13();
      var BADNUM = require_numerical().BADNUM;
      module.exports = function calc(gd, trace) {
        var cd = boxCalc(gd, trace);
        if (cd[0].t.empty) return cd;
        var fullLayout = gd._fullLayout;
        var valAxis = Axes.getFromId(
          gd,
          trace[trace.orientation === "h" ? "xaxis" : "yaxis"]
        );
        var spanMin = Infinity;
        var spanMax = -Infinity;
        var maxKDE = 0;
        var maxCount = 0;
        for (var i = 0; i < cd.length; i++) {
          var cdi = cd[i];
          var vals = cdi.pts.map(helpers.extractVal);
          var bandwidth = cdi.bandwidth = calcBandwidth(trace, cdi, vals);
          var span = cdi.span = calcSpan(trace, cdi, valAxis, bandwidth);
          if (cdi.min === cdi.max && bandwidth === 0) {
            span = cdi.span = [cdi.min, cdi.max];
            cdi.density = [{ v: 1, t: span[0] }];
            cdi.bandwidth = bandwidth;
            maxKDE = Math.max(maxKDE, 1);
          } else {
            var dist = span[1] - span[0];
            var n = Math.ceil(dist / (bandwidth / 3));
            var step = dist / n;
            if (!isFinite(step) || !isFinite(n)) {
              Lib.error("Something went wrong with computing the violin span");
              cd[0].t.empty = true;
              return cd;
            }
            var kde = helpers.makeKDE(cdi, trace, vals);
            cdi.density = new Array(n);
            for (var k = 0, t = span[0]; t < span[1] + step / 2; k++, t += step) {
              var v = kde(t);
              cdi.density[k] = { v, t };
              maxKDE = Math.max(maxKDE, v);
            }
          }
          maxCount = Math.max(maxCount, vals.length);
          spanMin = Math.min(spanMin, span[0]);
          spanMax = Math.max(spanMax, span[1]);
        }
        var extremes = Axes.findExtremes(valAxis, [spanMin, spanMax], { padded: true });
        trace._extremes[valAxis._id] = extremes;
        if (trace.width) {
          cd[0].t.maxKDE = maxKDE;
        } else {
          var violinScaleGroupStats = fullLayout._violinScaleGroupStats;
          var scaleGroup = trace.scalegroup;
          var groupStats = violinScaleGroupStats[scaleGroup];
          if (groupStats) {
            groupStats.maxKDE = Math.max(groupStats.maxKDE, maxKDE);
            groupStats.maxCount = Math.max(groupStats.maxCount, maxCount);
          } else {
            violinScaleGroupStats[scaleGroup] = {
              maxKDE,
              maxCount
            };
          }
        }
        cd[0].t.labels.kde = Lib._(gd, "kde:");
        return cd;
      };
      function silvermanRule(len, ssd, iqr) {
        var a = Math.min(ssd, iqr / 1.349);
        return 1.059 * a * Math.pow(len, -0.2);
      }
      function calcBandwidth(trace, cdi, vals) {
        var span = cdi.max - cdi.min;
        if (!span) {
          if (trace.bandwidth) {
            return trace.bandwidth;
          } else {
            return 0;
          }
        }
        if (trace.bandwidth) {
          return Math.max(trace.bandwidth, span / 1e4);
        } else {
          var len = vals.length;
          var ssd = Lib.stdev(vals, len - 1, cdi.mean);
          return Math.max(
            silvermanRule(len, ssd, cdi.q3 - cdi.q1),
            span / 100
          );
        }
      }
      function calcSpan(trace, cdi, valAxis, bandwidth) {
        var spanmode = trace.spanmode;
        var spanIn = trace.span || [];
        var spanTight = [cdi.min, cdi.max];
        var spanLoose = [cdi.min - 2 * bandwidth, cdi.max + 2 * bandwidth];
        var spanOut;
        function calcSpanItem(index) {
          var s = spanIn[index];
          var sc = valAxis.type === "multicategory" ? valAxis.r2c(s) : valAxis.d2c(s, 0, trace[cdi.valLetter + "calendar"]);
          return sc === BADNUM ? spanLoose[index] : sc;
        }
        if (spanmode === "soft") {
          spanOut = spanLoose;
        } else if (spanmode === "hard") {
          spanOut = spanTight;
        } else {
          spanOut = [calcSpanItem(0), calcSpanItem(1)];
        }
        var dummyAx = {
          type: "linear",
          range: spanOut
        };
        Axes.setConvert(dummyAx);
        dummyAx.cleanRange();
        return spanOut;
      }
    }
  });

  // src/traces/violin/cross_trace_calc.js
  var require_cross_trace_calc4 = __commonJS({
    "src/traces/violin/cross_trace_calc.js"(exports, module) {
      "use strict";
      var setPositionOffset = require_cross_trace_calc3().setPositionOffset;
      var orientations = ["v", "h"];
      module.exports = function crossTraceCalc(gd, plotinfo) {
        var calcdata = gd.calcdata;
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        for (var i = 0; i < orientations.length; i++) {
          var orientation = orientations[i];
          var posAxis = orientation === "h" ? ya : xa;
          var violinList = [];
          for (var j = 0; j < calcdata.length; j++) {
            var cd = calcdata[j];
            var t = cd[0].t;
            var trace = cd[0].trace;
            if (trace.visible === true && trace.type === "violin" && !t.empty && trace.orientation === orientation && trace.xaxis === xa._id && trace.yaxis === ya._id) {
              violinList.push(j);
            }
          }
          setPositionOffset("violin", gd, violinList, posAxis);
        }
      };
    }
  });

  // src/traces/violin/plot.js
  var require_plot8 = __commonJS({
    "src/traces/violin/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var Drawing = require_drawing();
      var boxPlot = require_plot4();
      var linePoints = require_line_points();
      var helpers = require_helpers13();
      module.exports = function plot(gd, plotinfo, cdViolins, violinLayer) {
        var isStatic = gd._context.staticPlot;
        var fullLayout = gd._fullLayout;
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        function makePath(pts, trace) {
          var segments = linePoints(pts, {
            xaxis: xa,
            yaxis: ya,
            trace,
            connectGaps: true,
            baseTolerance: 0.75,
            shape: "spline",
            simplify: true,
            linearized: true
          });
          return Drawing.smoothopen(segments[0], 1);
        }
        Lib.makeTraceGroups(violinLayer, cdViolins, "trace violins").each(function(cd) {
          var plotGroup = d3.select(this);
          var cd0 = cd[0];
          var t = cd0.t;
          var trace = cd0.trace;
          if (trace.visible !== true || t.empty) {
            plotGroup.remove();
            return;
          }
          var bPos = t.bPos;
          var bdPos = t.bdPos;
          var valAxis = plotinfo[t.valLetter + "axis"];
          var posAxis = plotinfo[t.posLetter + "axis"];
          var hasBothSides = trace.side === "both";
          var hasPositiveSide = hasBothSides || trace.side === "positive";
          var hasNegativeSide = hasBothSides || trace.side === "negative";
          var violins = plotGroup.selectAll("path.violin").data(Lib.identity);
          violins.enter().append("path").style("vector-effect", isStatic ? "none" : "non-scaling-stroke").attr("class", "violin");
          violins.exit().remove();
          violins.each(function(d) {
            var pathSel = d3.select(this);
            var density = d.density;
            var len = density.length;
            var posCenter = posAxis.c2l(d.pos + bPos, true);
            var posCenterPx = posAxis.l2p(posCenter);
            var scale;
            if (trace.width) {
              scale = t.maxKDE / bdPos;
            } else {
              var groupStats = fullLayout._violinScaleGroupStats[trace.scalegroup];
              scale = trace.scalemode === "count" ? groupStats.maxKDE / bdPos * (groupStats.maxCount / d.pts.length) : groupStats.maxKDE / bdPos;
            }
            var pathPos, pathNeg, path;
            var i, k, pts, pt;
            if (hasPositiveSide) {
              pts = new Array(len);
              for (i = 0; i < len; i++) {
                pt = pts[i] = {};
                pt[t.posLetter] = posCenter + density[i].v / scale;
                pt[t.valLetter] = valAxis.c2l(density[i].t, true);
              }
              pathPos = makePath(pts, trace);
            }
            if (hasNegativeSide) {
              pts = new Array(len);
              for (k = 0, i = len - 1; k < len; k++, i--) {
                pt = pts[k] = {};
                pt[t.posLetter] = posCenter - density[i].v / scale;
                pt[t.valLetter] = valAxis.c2l(density[i].t, true);
              }
              pathNeg = makePath(pts, trace);
            }
            if (hasBothSides) {
              path = pathPos + "L" + pathNeg.substr(1) + "Z";
            } else {
              var startPt = [posCenterPx, valAxis.c2p(density[0].t)];
              var endPt = [posCenterPx, valAxis.c2p(density[len - 1].t)];
              if (trace.orientation === "h") {
                startPt.reverse();
                endPt.reverse();
              }
              if (hasPositiveSide) {
                path = "M" + startPt + "L" + pathPos.substr(1) + "L" + endPt;
              } else {
                path = "M" + endPt + "L" + pathNeg.substr(1) + "L" + startPt;
              }
            }
            pathSel.attr("d", path);
            d.posCenterPx = posCenterPx;
            d.posDensityScale = scale * bdPos;
            d.path = pathSel.node();
            d.pathLength = d.path.getTotalLength() / (hasBothSides ? 2 : 1);
          });
          var boxAttrs = trace.box;
          var boxWidth = boxAttrs.width;
          var boxLineWidth = (boxAttrs.line || {}).width;
          var bdPosScaled;
          var bPosPxOffset;
          if (hasBothSides) {
            bdPosScaled = bdPos * boxWidth;
            bPosPxOffset = 0;
          } else if (hasPositiveSide) {
            bdPosScaled = [0, bdPos * boxWidth / 2];
            bPosPxOffset = boxLineWidth * { x: 1, y: -1 }[t.posLetter];
          } else {
            bdPosScaled = [bdPos * boxWidth / 2, 0];
            bPosPxOffset = boxLineWidth * { x: -1, y: 1 }[t.posLetter];
          }
          boxPlot.plotBoxAndWhiskers(plotGroup, { pos: posAxis, val: valAxis }, trace, {
            bPos,
            bdPos: bdPosScaled,
            bPosPxOffset
          });
          boxPlot.plotBoxMean(plotGroup, { pos: posAxis, val: valAxis }, trace, {
            bPos,
            bdPos: bdPosScaled,
            bPosPxOffset
          });
          var fn;
          if (!trace.box.visible && trace.meanline.visible) {
            fn = Lib.identity;
          }
          var meanPaths = plotGroup.selectAll("path.meanline").data(fn || []);
          meanPaths.enter().append("path").attr("class", "meanline").style("fill", "none").style("vector-effect", isStatic ? "none" : "non-scaling-stroke");
          meanPaths.exit().remove();
          meanPaths.each(function(d) {
            var v = valAxis.c2p(d.mean, true);
            var p = helpers.getPositionOnKdePath(d, trace, v);
            d3.select(this).attr(
              "d",
              trace.orientation === "h" ? "M" + v + "," + p[0] + "V" + p[1] : "M" + p[0] + "," + v + "H" + p[1]
            );
          });
          boxPlot.plotPoints(plotGroup, { x: xa, y: ya }, trace, t);
        });
      };
    }
  });

  // src/traces/violin/style.js
  var require_style8 = __commonJS({
    "src/traces/violin/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Color = require_color();
      var stylePoints = require_style2().stylePoints;
      module.exports = function style(gd) {
        var s = d3.select(gd).selectAll("g.trace.violins");
        s.style("opacity", function(d) {
          return d[0].trace.opacity;
        });
        s.each(function(d) {
          var trace = d[0].trace;
          var sel = d3.select(this);
          var box = trace.box || {};
          var boxLine = box.line || {};
          var meanline = trace.meanline || {};
          var meanLineWidth = meanline.width;
          sel.selectAll("path.violin").style("stroke-width", trace.line.width + "px").call(Color.stroke, trace.line.color).call(Color.fill, trace.fillcolor);
          sel.selectAll("path.box").style("stroke-width", boxLine.width + "px").call(Color.stroke, boxLine.color).call(Color.fill, box.fillcolor);
          var meanLineStyle = {
            "stroke-width": meanLineWidth + "px",
            "stroke-dasharray": 2 * meanLineWidth + "px," + meanLineWidth + "px"
          };
          sel.selectAll("path.mean").style(meanLineStyle).call(Color.stroke, meanline.color);
          sel.selectAll("path.meanline").style(meanLineStyle).call(Color.stroke, meanline.color);
          stylePoints(sel, trace, gd);
        });
      };
    }
  });

  // src/traces/violin/hover.js
  var require_hover10 = __commonJS({
    "src/traces/violin/hover.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var Lib = require_lib();
      var Axes = require_axes();
      var boxHoverPoints = require_hover4();
      var helpers = require_helpers13();
      module.exports = function hoverPoints(pointData, xval, yval, hovermode, opts) {
        if (!opts) opts = {};
        var hoverLayer = opts.hoverLayer;
        var cd = pointData.cd;
        var trace = cd[0].trace;
        var hoveron = trace.hoveron;
        var hasHoveronViolins = hoveron.indexOf("violins") !== -1;
        var hasHoveronKDE = hoveron.indexOf("kde") !== -1;
        var closeData = [];
        var closePtData;
        var violinLineAttrs;
        if (hasHoveronViolins || hasHoveronKDE) {
          var closeBoxData = boxHoverPoints.hoverOnBoxes(pointData, xval, yval, hovermode);
          if (hasHoveronKDE && closeBoxData.length > 0) {
            var xa = pointData.xa;
            var ya = pointData.ya;
            var pLetter, vLetter, pAxis, vAxis, vVal;
            if (trace.orientation === "h") {
              vVal = xval;
              pLetter = "y";
              pAxis = ya;
              vLetter = "x";
              vAxis = xa;
            } else {
              vVal = yval;
              pLetter = "x";
              pAxis = xa;
              vLetter = "y";
              vAxis = ya;
            }
            var di = cd[pointData.index];
            if (vVal >= di.span[0] && vVal <= di.span[1]) {
              var kdePointData = Lib.extendFlat({}, pointData);
              var vValPx = vAxis.c2p(vVal, true);
              var kdeVal = helpers.getKdeValue(di, trace, vVal);
              var pOnPath = helpers.getPositionOnKdePath(di, trace, vValPx);
              var paOffset = pAxis._offset;
              var paLength = pAxis._length;
              kdePointData[pLetter + "0"] = pOnPath[0];
              kdePointData[pLetter + "1"] = pOnPath[1];
              kdePointData[vLetter + "0"] = kdePointData[vLetter + "1"] = vValPx;
              kdePointData[vLetter + "Label"] = vLetter + ": " + Axes.hoverLabelText(vAxis, vVal, trace[vLetter + "hoverformat"]) + ", " + cd[0].t.labels.kde + " " + kdeVal.toFixed(3);
              var medId = 0;
              for (var k = 0; k < closeBoxData.length; k++) {
                if (closeBoxData[k].attr === "med") {
                  medId = k;
                  break;
                }
              }
              kdePointData.spikeDistance = closeBoxData[medId].spikeDistance;
              var spikePosAttr = pLetter + "Spike";
              kdePointData[spikePosAttr] = closeBoxData[medId][spikePosAttr];
              closeBoxData[medId].spikeDistance = void 0;
              closeBoxData[medId][spikePosAttr] = void 0;
              kdePointData.hovertemplate = false;
              closeData.push(kdePointData);
              violinLineAttrs = {};
              violinLineAttrs[pLetter + "1"] = Lib.constrain(paOffset + pOnPath[0], paOffset, paOffset + paLength);
              violinLineAttrs[pLetter + "2"] = Lib.constrain(paOffset + pOnPath[1], paOffset, paOffset + paLength);
              violinLineAttrs[vLetter + "1"] = violinLineAttrs[vLetter + "2"] = vAxis._offset + vValPx;
            }
          }
          if (hasHoveronViolins) {
            closeData = closeData.concat(closeBoxData);
          }
        }
        if (hoveron.indexOf("points") !== -1) {
          closePtData = boxHoverPoints.hoverOnPoints(pointData, xval, yval);
        }
        var violinLine = hoverLayer.selectAll(".violinline-" + trace.uid).data(violinLineAttrs ? [0] : []);
        violinLine.enter().append("line").classed("violinline-" + trace.uid, true).attr("stroke-width", 1.5);
        violinLine.exit().remove();
        violinLine.attr(violinLineAttrs).call(Color.stroke, pointData.color);
        if (hovermode === "closest") {
          if (closePtData) return [closePtData];
          return closeData;
        }
        if (closePtData) {
          closeData.push(closePtData);
          return closeData;
        }
        return closeData;
      };
    }
  });

  // src/traces/violin/index.js
  var require_violin = __commonJS({
    "src/traces/violin/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes31(),
        layoutAttributes: require_layout_attributes9(),
        supplyDefaults: require_defaults27(),
        crossTraceDefaults: require_defaults20().crossTraceDefaults,
        supplyLayoutDefaults: require_layout_defaults8(),
        calc: require_calc12(),
        crossTraceCalc: require_cross_trace_calc4(),
        plot: require_plot8(),
        style: require_style8(),
        styleOnSelect: require_style2().styleOnSelect,
        hoverPoints: require_hover10(),
        selectPoints: require_select4(),
        moduleType: "trace",
        name: "violin",
        basePlotModule: require_cartesian(),
        categories: ["cartesian", "svg", "symbols", "oriented", "box-violin", "showLegend", "violinLayout", "zoomScale"],
        meta: {}
      };
    }
  });

  // lib/violin.js
  var require_violin2 = __commonJS({
    "lib/violin.js"(exports, module) {
      "use strict";
      module.exports = require_violin();
    }
  });

  // src/traces/image/constants.js
  var require_constants17 = __commonJS({
    "src/traces/image/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        colormodel: {
          // min and max define the numerical range accepted in CSS
          // If z(min|max)Dflt are not defined, z(min|max) will default to min/max
          rgb: {
            min: [0, 0, 0],
            max: [255, 255, 255],
            fmt: function(c) {
              return c.slice(0, 3);
            },
            suffix: ["", "", ""]
          },
          rgba: {
            min: [0, 0, 0, 0],
            max: [255, 255, 255, 1],
            fmt: function(c) {
              return c.slice(0, 4);
            },
            suffix: ["", "", "", ""]
          },
          rgba256: {
            colormodel: "rgba",
            // because rgba256 is not an accept colormodel in CSS
            zminDflt: [0, 0, 0, 0],
            zmaxDflt: [255, 255, 255, 255],
            min: [0, 0, 0, 0],
            max: [255, 255, 255, 1],
            fmt: function(c) {
              return c.slice(0, 4);
            },
            suffix: ["", "", "", ""]
          },
          hsl: {
            min: [0, 0, 0],
            max: [360, 100, 100],
            fmt: function(c) {
              var p = c.slice(0, 3);
              p[1] = p[1] + "%";
              p[2] = p[2] + "%";
              return p;
            },
            suffix: ["\xB0", "%", "%"]
          },
          hsla: {
            min: [0, 0, 0, 0],
            max: [360, 100, 100, 1],
            fmt: function(c) {
              var p = c.slice(0, 4);
              p[1] = p[1] + "%";
              p[2] = p[2] + "%";
              return p;
            },
            suffix: ["\xB0", "%", "%", ""]
          }
        }
      };
    }
  });

  // src/traces/image/attributes.js
  var require_attributes32 = __commonJS({
    "src/traces/image/attributes.js"(exports, module) {
      "use strict";
      var baseAttrs = require_attributes2();
      var zorder = require_attributes12().zorder;
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var extendFlat = require_extend().extendFlat;
      var colormodel = require_constants17().colormodel;
      var cm = ["rgb", "rgba", "rgba256", "hsl", "hsla"];
      var zminDesc = [];
      var zmaxDesc = [];
      for (i = 0; i < cm.length; i++) {
        cr = colormodel[cm[i]];
        zminDesc.push("For the `" + cm[i] + "` colormodel, it is [" + (cr.zminDflt || cr.min).join(", ") + "].");
        zmaxDesc.push("For the `" + cm[i] + "` colormodel, it is [" + (cr.zmaxDflt || cr.max).join(", ") + "].");
      }
      var cr;
      var i;
      module.exports = extendFlat({
        source: {
          valType: "string",
          editType: "calc"
        },
        z: {
          valType: "data_array",
          editType: "calc"
        },
        colormodel: {
          valType: "enumerated",
          values: cm,
          editType: "calc"
        },
        zsmooth: {
          valType: "enumerated",
          values: ["fast", false],
          dflt: false,
          editType: "plot"
        },
        zmin: {
          valType: "info_array",
          items: [
            { valType: "number", editType: "calc" },
            { valType: "number", editType: "calc" },
            { valType: "number", editType: "calc" },
            { valType: "number", editType: "calc" }
          ],
          editType: "calc"
        },
        zmax: {
          valType: "info_array",
          items: [
            { valType: "number", editType: "calc" },
            { valType: "number", editType: "calc" },
            { valType: "number", editType: "calc" },
            { valType: "number", editType: "calc" }
          ],
          editType: "calc"
        },
        x0: {
          valType: "any",
          dflt: 0,
          editType: "calc+clearAxisTypes"
        },
        y0: {
          valType: "any",
          dflt: 0,
          editType: "calc+clearAxisTypes"
        },
        dx: {
          valType: "number",
          dflt: 1,
          editType: "calc"
        },
        dy: {
          valType: "number",
          dflt: 1,
          editType: "calc"
        },
        text: {
          valType: "data_array",
          editType: "plot"
        },
        hovertext: {
          valType: "data_array",
          editType: "plot"
        },
        hoverinfo: extendFlat({}, baseAttrs.hoverinfo, {
          flags: ["x", "y", "z", "color", "name", "text"],
          dflt: "x+y+z+text+name"
        }),
        hovertemplate: hovertemplateAttrs({}, {
          keys: ["z", "color", "colormodel"]
        }),
        zorder
      });
    }
  });

  // src/traces/image/defaults.js
  var require_defaults28 = __commonJS({
    "src/traces/image/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var attributes = require_attributes32();
      var constants = require_constants17();
      var dataUri = require_helpers10().IMAGE_URL_PREFIX;
      module.exports = function supplyDefaults(traceIn, traceOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        coerce("source");
        if (traceOut.source && !traceOut.source.match(dataUri)) delete traceOut.source;
        traceOut._hasSource = !!traceOut.source;
        var z = coerce("z");
        traceOut._hasZ = !(z === void 0 || !z.length || !z[0] || !z[0].length);
        if (!traceOut._hasZ && !traceOut._hasSource) {
          traceOut.visible = false;
          return;
        }
        coerce("x0");
        coerce("y0");
        coerce("dx");
        coerce("dy");
        var cm;
        if (traceOut._hasZ) {
          coerce("colormodel", "rgb");
          cm = constants.colormodel[traceOut.colormodel];
          coerce("zmin", cm.zminDflt || cm.min);
          coerce("zmax", cm.zmaxDflt || cm.max);
        } else if (traceOut._hasSource) {
          traceOut.colormodel = "rgba256";
          cm = constants.colormodel[traceOut.colormodel];
          traceOut.zmin = cm.zminDflt;
          traceOut.zmax = cm.zmaxDflt;
        }
        coerce("zsmooth");
        coerce("text");
        coerce("hovertext");
        coerce("hovertemplate");
        traceOut._length = null;
        coerce("zorder");
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(
            uint8,
            i2,
            i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength
          ));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b) return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir) return -1;
          else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length) break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/es-errors/index.js
  var require_es_errors = __commonJS({
    "node_modules/es-errors/index.js"(exports, module) {
      "use strict";
      module.exports = Error;
    }
  });

  // node_modules/es-errors/eval.js
  var require_eval = __commonJS({
    "node_modules/es-errors/eval.js"(exports, module) {
      "use strict";
      module.exports = EvalError;
    }
  });

  // node_modules/es-errors/range.js
  var require_range = __commonJS({
    "node_modules/es-errors/range.js"(exports, module) {
      "use strict";
      module.exports = RangeError;
    }
  });

  // node_modules/es-errors/ref.js
  var require_ref = __commonJS({
    "node_modules/es-errors/ref.js"(exports, module) {
      "use strict";
      module.exports = ReferenceError;
    }
  });

  // node_modules/es-errors/syntax.js
  var require_syntax = __commonJS({
    "node_modules/es-errors/syntax.js"(exports, module) {
      "use strict";
      module.exports = SyntaxError;
    }
  });

  // node_modules/es-errors/type.js
  var require_type = __commonJS({
    "node_modules/es-errors/type.js"(exports, module) {
      "use strict";
      module.exports = TypeError;
    }
  });

  // node_modules/es-errors/uri.js
  var require_uri = __commonJS({
    "node_modules/es-errors/uri.js"(exports, module) {
      "use strict";
      module.exports = URIError;
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/has-proto/index.js
  var require_has_proto = __commonJS({
    "node_modules/has-proto/index.js"(exports, module) {
      "use strict";
      var test = {
        foo: {}
      };
      var $Object = Object;
      module.exports = function hasProto() {
        return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var toStr = Object.prototype.toString;
      var max = Math.max;
      var funcType = "[object Function]";
      var concatty = function concatty2(a, b) {
        var arr = [];
        for (var i = 0; i < a.length; i += 1) {
          arr[i] = a[i];
        }
        for (var j = 0; j < b.length; j += 1) {
          arr[j + a.length] = b[j];
        }
        return arr;
      };
      var slicy = function slicy2(arrLike, offset) {
        var arr = [];
        for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
          arr[j] = arrLike[i];
        }
        return arr;
      };
      var joiny = function(arr, joiner) {
        var str = "";
        for (var i = 0; i < arr.length; i += 1) {
          str += arr[i];
          if (i + 1 < arr.length) {
            str += joiner;
          }
        }
        return str;
      };
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.apply(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slicy(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              concatty(args, arguments)
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          }
          return target.apply(
            that,
            concatty(args, arguments)
          );
        };
        var boundLength = max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs[i] = "$" + i;
        }
        bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      var implementation = require_implementation();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/hasown/index.js
  var require_hasown = __commonJS({
    "node_modules/hasown/index.js"(exports, module) {
      "use strict";
      var call = Function.prototype.call;
      var $hasOwn = Object.prototype.hasOwnProperty;
      var bind = require_function_bind();
      module.exports = bind.call(call, $hasOwn);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      var undefined2;
      var $Error = require_es_errors();
      var $EvalError = require_eval();
      var $RangeError = require_range();
      var $ReferenceError = require_ref();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var $URIError = require_uri();
      var $Function = Function;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var hasProto = require_has_proto()();
      var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
        return x.__proto__;
      } : null);
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": $Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": $EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": $RangeError,
        "%ReferenceError%": $ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": $URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      if (getProto) {
        try {
          null.error;
        } catch (e) {
          errorProto = getProto(getProto(e));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var errorProto;
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen && getProto) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_hasown();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/es-define-property/index.js
  var require_es_define_property = __commonJS({
    "node_modules/es-define-property/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = false;
        }
      }
      module.exports = $defineProperty;
    }
  });

  // node_modules/gopd/index.js
  var require_gopd = __commonJS({
    "node_modules/gopd/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      module.exports = $gOPD;
    }
  });

  // node_modules/define-data-property/index.js
  var require_define_data_property = __commonJS({
    "node_modules/define-data-property/index.js"(exports, module) {
      "use strict";
      var $defineProperty = require_es_define_property();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var gopd = require_gopd();
      module.exports = function defineDataProperty(obj, property, value) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
          throw new $TypeError("`obj` must be an object or a function`");
        }
        if (typeof property !== "string" && typeof property !== "symbol") {
          throw new $TypeError("`property` must be a string or a symbol`");
        }
        if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
          throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
          throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
          throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
          throw new $TypeError("`loose`, if provided, must be a boolean");
        }
        var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
        var nonWritable = arguments.length > 4 ? arguments[4] : null;
        var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
        var loose = arguments.length > 6 ? arguments[6] : false;
        var desc = !!gopd && gopd(obj, property);
        if ($defineProperty) {
          $defineProperty(obj, property, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
          });
        } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
          obj[property] = value;
        } else {
          throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
        }
      };
    }
  });

  // node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "node_modules/has-property-descriptors/index.js"(exports, module) {
      "use strict";
      var $defineProperty = require_es_define_property();
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        return !!$defineProperty;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!$defineProperty) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    }
  });

  // node_modules/set-function-length/index.js
  var require_set_function_length = __commonJS({
    "node_modules/set-function-length/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var define2 = require_define_data_property();
      var hasDescriptors = require_has_property_descriptors()();
      var gOPD = require_gopd();
      var $TypeError = require_type();
      var $floor = GetIntrinsic("%Math.floor%");
      module.exports = function setFunctionLength(fn, length) {
        if (typeof fn !== "function") {
          throw new $TypeError("`fn` is not a function");
        }
        if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
          throw new $TypeError("`length` must be a positive 32-bit integer");
        }
        var loose = arguments.length > 2 && !!arguments[2];
        var functionLengthIsConfigurable = true;
        var functionLengthIsWritable = true;
        if ("length" in fn && gOPD) {
          var desc = gOPD(fn, "length");
          if (desc && !desc.configurable) {
            functionLengthIsConfigurable = false;
          }
          if (desc && !desc.writable) {
            functionLengthIsWritable = false;
          }
        }
        if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
          if (hasDescriptors) {
            define2(
              /** @type {Parameters<define>[0]} */
              fn,
              "length",
              length,
              true,
              true
            );
          } else {
            define2(
              /** @type {Parameters<define>[0]} */
              fn,
              "length",
              length
            );
          }
        }
        return fn;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var setFunctionLength = require_set_function_length();
      var $TypeError = require_type();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $defineProperty = require_es_define_property();
      var $max = GetIntrinsic("%Math.max%");
      module.exports = function callBind(originalFunction) {
        if (typeof originalFunction !== "function") {
          throw new $TypeError("a function is required");
        }
        var func = $reflectApply(bind, $call, arguments);
        return setFunctionLength(
          func,
          1 + $max(0, originalFunction.length - (arguments.length - 1)),
          true
        );
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e) {
        }
      };
      var GeneratorFunction;
      module.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "node_modules/is-callable/index.js"(exports, module) {
      "use strict";
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str = toStr.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
              } catch (e) {
              }
            }
            return false;
          };
        }
      }
      var all;
      module.exports = reflectApply ? function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e) {
          if (e !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
    }
  });

  // node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "node_modules/for-each/index.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i = 0, len = array.length; i < len; i++) {
          if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
              iterator(array[i], i, array);
            } else {
              iterator.call(receiver, array[i], i, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string, iterator, receiver) {
        for (var i = 0, len = string.length; i < len; i++) {
          if (receiver == null) {
            iterator(string.charAt(i), i, string);
          } else {
            iterator.call(receiver, string.charAt(i), i, string);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      var forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module.exports = forEach;
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports, module) {
      "use strict";
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g = typeof globalThis === "undefined" ? window : globalThis;
      module.exports = function availableTypedArrays() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
          if (typeof g[possibleNames[i]] === "function") {
            out[out.length] = possibleNames[i];
          }
        }
        return out;
      };
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports, module) {
      "use strict";
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBind = require_call_bind();
      var callBound = require_callBound();
      var gOPD = require_gopd();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g = typeof globalThis === "undefined" ? window : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var getPrototypeOf = Object.getPrototypeOf;
      var $indexOf = callBound("Array.prototype.indexOf", true) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
      function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var cache = { __proto__: null };
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            cache["$" + typedArray] = callBind(descriptor.get);
          }
        });
      } else {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          var fn = arr.slice || arr.set;
          if (fn) {
            cache["$" + typedArray] = callBind(fn);
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var found = false;
        forEach(
          // eslint-disable-next-line no-extra-parens
          /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
          /** @type {any} */
          cache,
          /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
          function(getter, typedArray) {
            if (!found) {
              try {
                if ("$" + getter(value) === typedArray) {
                  found = $slice(typedArray, 1);
                }
              } catch (e) {
              }
            }
          }
        );
        return found;
      };
      var trySlices = function tryAllSlices(value) {
        var found = false;
        forEach(
          // eslint-disable-next-line no-extra-parens
          /** @type {any} */
          cache,
          /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
          function(getter, name) {
            if (!found) {
              try {
                getter(value);
                found = $slice(name, 1);
              } catch (e) {
              }
            }
          }
        );
        return found;
      };
      module.exports = function whichTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag) {
          var tag = $slice($toString(value), 8, -1);
          if ($indexOf(typedArrays, tag) > -1) {
            return tag;
          }
          if (tag !== "Object") {
            return false;
          }
          return trySlices(value);
        }
        if (!gOPD) {
          return null;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports, module) {
      "use strict";
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var gOPD = require_gopd();
      var g = typeof globalThis === "undefined" ? window : globalThis;
      var typedArrays = availableTypedArrays();
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e) {
            }
          }
        });
        return anyTrue;
      };
      module.exports = function isTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          var tag = $slice($toString(value), 8, -1);
          return $indexOf(typedArrays, tag) > -1;
        }
        if (!gOPD) {
          return false;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports) {
      "use strict";
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports, module) {
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // (disabled):node_modules/util/util.js
  var require_util = __commonJS({
    "(disabled):node_modules/util/util.js"(exports) {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%") return "%";
          if (i >= len) return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if ("false") {
        debugEnv = "false";
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3) ctx.depth = arguments[2];
        if (arguments.length >= 4) ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
        if (isUndefined(ctx.depth)) ctx.depth = 2;
        if (isUndefined(ctx.colors)) ctx.colors = false;
        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
        if (ctx.colors) ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0) numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = require_types();
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = /* @__PURE__ */ new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add) {
        if (!add || !isObject(add)) return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return Object.defineProperties(
          fn,
          getOwnPropertyDescriptors(original)
        );
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports.callbackify = callbackify;
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer2 = _require.Buffer;
      var _require2 = require_util();
      var inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer2.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0) this.tail.next = entry;
            else this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null;
            else this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0) return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0) return Buffer2.alloc(0);
            var ret = Buffer2.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
          // Consumes a specified amount of bytes or characters from the buffered data.
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
          // Consumes a specified amount of characters from the buffered data.
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length) ret += str;
              else ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next) this.head = p.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Consumes a specified amount of bytes from the buffered data.
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer2.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next) this.head = p.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Make sure the linked list only shows the minimal necessary information.
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: false
            }));
          }
        }]);
        return BufferList;
      }();
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose) return;
        if (self2._readableState && !self2._readableState.emitClose) return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
        else stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js
  var require_errors_browser = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/util-deprecate/browser.js
  var require_browser = __commonJS({
    "node_modules/util-deprecate/browser.js"(exports, module) {
      module.exports = deprecate;
      function deprecate(fn, msg) {
        if (config("noDeprecation")) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config("throwDeprecation")) {
              throw new Error(msg);
            } else if (config("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config(name) {
        try {
          if (!window.localStorage) return false;
        } catch (_) {
          return false;
        }
        var val = window.localStorage[name];
        if (null == val) return false;
        return String(val).toLowerCase() === "true";
      }
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      module.exports = Writable;
      function CorkedRequest(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex;
      Writable.WritableState = WritableState;
      var internalUtil = {
        deprecate: require_browser()
      };
      var Stream = require_stream_browser();
      var Buffer2 = require_buffer().Buffer;
      var OurUint8Array = window.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer2.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable, Stream);
      function nop() {
      }
      function WritableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest(this);
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable(options) {
        Duplex = Duplex || require_stream_duplex();
        var isDuplex = this instanceof Duplex;
        if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
        this._writableState = new WritableState(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function") this._write = options.write;
          if (typeof options.writev === "function") this._writev = options.writev;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
          if (typeof options.final === "function") this._final = options.final;
        }
        Stream.call(this);
      }
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer2.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf) encoding = "buffer";
        else if (!encoding) encoding = state.defaultEncoding;
        if (typeof cb !== "function") cb = nop;
        if (state.ending) writeAfterEnd(this, cb);
        else if (isBuf || validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string") encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer2.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret) state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev) stream._writev(chunk, state.onwrite);
        else stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe(stream, state);
        }
      }
      function onwriteStateUpdate(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate(state);
        if (er) onwriteError(stream, state, sync, er, cb);
        else {
          var finished = needFinish(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite, stream, state, finished, cb);
          } else {
            afterWrite(stream, state, finished, cb);
          }
        }
      }
      function afterWrite(stream, state, finished, cb) {
        if (!finished) onwriteDrain(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe(stream, state);
      }
      function onwriteDrain(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null) state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending) endWritable(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable.prototype, "writableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function needFinish(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe(stream, state);
        });
      }
      function prefinish(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe(stream, state) {
        var need = needFinish(state);
        if (need) {
          prefinish(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable(stream, state, cb) {
        state.ending = true;
        finishMaybe(stream, state);
        if (cb) {
          if (state.finished) process.nextTick(cb);
          else stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable.prototype.destroy = destroyImpl.destroy;
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module.exports = Duplex;
      var Readable = require_stream_readable();
      var Writable = require_stream_writable();
      require_inherits_browser()(Duplex, Readable);
      {
        keys = objectKeys(Writable.prototype);
        for (v = 0; v < keys.length; v++) {
          method = keys[v];
          if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      var keys;
      var method;
      var v;
      function Duplex(options) {
        if (!(this instanceof Duplex)) return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false) this.readable = false;
          if (options.writable === false) this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend);
          }
        }
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex.prototype, "writableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex.prototype, "writableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.length;
        }
      });
      function onend() {
        if (this._writableState.ended) return;
        process.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports, module) {
      var buffer = require_buffer();
      var Buffer2 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer2.prototype);
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/stream-browserify/node_modules/string_decoder/lib/string_decoder.js
  var require_string_decoder = __commonJS({
    "node_modules/stream-browserify/node_modules/string_decoder/lib/string_decoder.js"(exports) {
      "use strict";
      var Buffer2 = require_safe_buffer().Buffer;
      var isEncoding = Buffer2.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc) return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried) return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer2.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0) return "";
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0) return "";
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127) return 0;
        else if (byte >> 5 === 6) return 2;
        else if (byte >> 4 === 14) return 3;
        else if (byte >> 3 === 30) return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i) {
        var j = buf.length - 1;
        if (j < i) return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2) return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2) nb = 0;
            else self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (r !== void 0) return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed) return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + "\uFFFD";
        return r;
      }
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString("utf16le", i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0) return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once(callback) {
        var called = false;
        return function() {
          if (called) return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function") return eos(stream, null, opts);
        if (!opts) opts = {};
        callback = once(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable) onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable) callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable) callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req) onrequest();
          else stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false) stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req) stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done) {
        return {
          value,
          done
        };
      }
      function readAndResolve(iter) {
        var resolve = iter[kLastResolve];
        if (resolve !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve = iterator[kLastResolve];
          if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      module.exports = Readable;
      var Duplex;
      Readable.ReadableState = ReadableState;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type) {
        return emitter.listeners(type).length;
      };
      var Stream = require_stream_browser();
      var Buffer2 = require_buffer().Buffer;
      var OurUint8Array = window.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer2.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util();
      var debug;
      if (debugUtil && debugUtil.debuglog) {
        debug = debugUtil.debuglog("stream");
      } else {
        debug = function debug2() {
        };
      }
      var BufferList = require_buffer_list();
      var destroyImpl = require_destroy();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder;
      var createReadableStreamAsyncIterator;
      var from;
      require_inherits_browser()(Readable, Stream);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener(emitter, event, fn) {
        if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
        else emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState(options, stream, isDuplex) {
        Duplex = Duplex || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
        this.objectMode = !!options.objectMode;
        if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable(options) {
        Duplex = Duplex || require_stream_duplex();
        if (!(this instanceof Readable)) return new Readable(options);
        var isDuplex = this instanceof Duplex;
        this._readableState = new ReadableState(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function") this._read = options.read;
          if (typeof options.destroy === "function") this._destroy = options.destroy;
        }
        Stream.call(this);
      }
      Object.defineProperty(Readable.prototype, "destroyed", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable.prototype.destroy = destroyImpl.destroy;
      Readable.prototype._undestroy = destroyImpl.undestroy;
      Readable.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable.prototype.unshift = function(chunk) {
        return readableAddChunk(this, chunk, null, true, false);
      };
      function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk(stream, state);
        } else {
          var er;
          if (!skipChunkCheck) er = chunkInvalid(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                else maybeReadMore(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);
          else state.buffer.push(chunk);
          if (state.needReadable) emitReadable(stream);
        }
        maybeReadMore(stream, state);
      }
      function chunkInvalid(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "") this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n >= MAX_HWM) {
          n = MAX_HWM;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended) return 0;
        if (state.objectMode) return 1;
        if (n !== n) {
          if (state.flowing && state.length) return state.buffer.head.data.length;
          else return state.length;
        }
        if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
        if (n <= state.length) return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0) state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended) endReadable(this);
          else emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0) endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0) state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading) n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0) ret = fromList(n, state);
        else ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended) state.needReadable = true;
          if (nOrig !== n && state.ended) endReadable(this);
        }
        if (ret !== null) this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream, state) {
        debug("onEofChunk");
        if (state.ended) return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
          }
        }
      }
      function emitReadable(stream) {
        var state = stream._readableState;
        debug("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_, stream);
        }
      }
      function emitReadable_(stream) {
        var state = stream._readableState;
        debug("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow(stream);
      }
      function maybeReadMore(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_, stream, state);
        }
      }
      function maybeReadMore_(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend : unpipe;
        if (state.endEmitted) process.nextTick(endFn);
        else src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          var ret = dest.write(chunk);
          debug("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
        }
        prependListener(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain) state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
          }
        };
      }
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0) return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes) return this;
          if (!dest) dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest) dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf(state.pipes, dest);
        if (index === -1) return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1) state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = Stream.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false) this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick, this);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      Readable.prototype.removeListener = function(ev, fn) {
        var res = Stream.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable.prototype.removeAllListeners = function(ev) {
        var res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0");
        self2.read(0);
      }
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = !state.readableListening;
          resume(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_, stream, state);
        }
      }
      function resume_(stream, state) {
        debug("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow(stream);
        if (state.flowing && !state.reading) stream.read(0);
      }
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow(stream) {
        var state = stream._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder) chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0)) return;
          else if (!state.objectMode && (!chunk || !chunk.length)) return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = /* @__PURE__ */ function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable.prototype, "readableBuffer", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable.prototype, "readableFlowing", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable._fromList = fromList;
      Object.defineProperty(Readable.prototype, "readableLength", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._readableState.length;
        }
      });
      function fromList(n, state) {
        if (state.length === 0) return null;
        var ret;
        if (state.objectMode) ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder) ret = state.buffer.join("");
          else if (state.buffer.length === 1) ret = state.buffer.first();
          else ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable(stream) {
        var state = stream._readableState;
        debug("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT, state, stream);
        }
      }
      function endReadableNT(state, stream) {
        debug("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable.from = function(iterable, opts) {
          if (from === void 0) {
            from = require_from_browser();
          }
          return from(Readable, iterable, opts);
        };
      }
      function indexOf(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x) return i;
        }
        return -1;
      }
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      module.exports = Transform;
      var _require$codes = require_errors_browser().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require_stream_duplex();
      require_inherits_browser()(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform)) return new Transform(options);
        Duplex.call(this, options);
        this._transformState = {
          afterTransform: afterTransform.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function") this._transform = options.transform;
          if (typeof options.flush === "function") this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er) return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      module.exports = PassThrough;
      var Transform = require_stream_transform();
      require_inherits_browser()(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough)) return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline = __commonJS({
    "node_modules/stream-browserify/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      var eos;
      function once(callback) {
        var called = false;
        return function() {
          if (called) return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err) throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0) eos = require_end_of_stream();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err) return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed) return;
          if (destroyed) return;
          destroyed = true;
          if (isRequest(stream)) return stream.abort();
          if (typeof stream.destroy === "function") return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length) return noop;
        if (typeof streams[streams.length - 1] !== "function") return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0])) streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error) error = err;
            if (err) destroys.forEach(call);
            if (reading) return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/stream-browserify/index.js
  var require_stream_browserify = __commonJS({
    "node_modules/stream-browserify/index.js"(exports, module) {
      module.exports = Stream;
      var EE = require_events().EventEmitter;
      var inherits = require_inherits_browser();
      inherits(Stream, EE);
      Stream.Readable = require_stream_readable();
      Stream.Writable = require_stream_writable();
      Stream.Duplex = require_stream_duplex();
      Stream.Transform = require_stream_transform();
      Stream.PassThrough = require_stream_passthrough();
      Stream.finished = require_end_of_stream();
      Stream.pipeline = require_pipeline();
      Stream.Stream = Stream;
      function Stream() {
        EE.call(this);
      }
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd) return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd) return;
          didOnEnd = true;
          if (typeof dest.destroy === "function") dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
    }
  });

  // node_modules/util/util.js
  var require_util2 = __commonJS({
    "node_modules/util/util.js"(exports) {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%") return "%";
          if (i >= len) return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if ("false") {
        debugEnv = "false";
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3) ctx.depth = arguments[2];
        if (arguments.length >= 4) ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
        if (isUndefined(ctx.depth)) ctx.depth = 2;
        if (isUndefined(ctx.colors)) ctx.colors = false;
        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
        if (ctx.colors) ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0) numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = require_types();
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = /* @__PURE__ */ new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add) {
        if (!add || !isObject(add)) return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return Object.defineProperties(
          fn,
          getOwnPropertyDescriptors(original)
        );
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports.callbackify = callbackify;
    }
  });

  // node_modules/assert/build/internal/errors.js
  var require_errors = __commonJS({
    "node_modules/assert/build/internal/errors.js"(exports, module) {
      "use strict";
      function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof(o);
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return _typeof(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (_typeof(input) !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof(res) !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        Object.defineProperty(subClass, "prototype", { writable: false });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        } else if (call !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var codes = {};
      var assert;
      var util;
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inherits(NodeError2, _Base);
          var _super = _createSuper(NodeError2);
          function NodeError2(arg1, arg2, arg3) {
            var _this;
            _classCallCheck(this, NodeError2);
            _this = _super.call(this, getMessage(arg1, arg2, arg3));
            _this.code = code;
            return _this;
          }
          return _createClass(NodeError2);
        }(Base);
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        if (assert === void 0) assert = require_assert();
        assert(typeof name === "string", "'name' must be a string");
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(_typeof(actual));
        return msg;
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
        var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
        if (util === void 0) util = require_util2();
        var inspected = util.inspect(value);
        if (inspected.length > 128) {
          inspected = "".concat(inspected.slice(0, 128), "...");
        }
        return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
      }, TypeError, RangeError);
      createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
        var type;
        if (value && value.constructor && value.constructor.name) {
          type = "instance of ".concat(value.constructor.name);
        } else {
          type = "type ".concat(_typeof(value));
        }
        return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
      }, TypeError);
      createErrorType("ERR_MISSING_ARGS", function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (assert === void 0) assert = require_assert();
        assert(args.length > 0, "At least one arg needs to be specified");
        var msg = "The ";
        var len = args.length;
        args = args.map(function(a) {
          return '"'.concat(a, '"');
        });
        switch (len) {
          case 1:
            msg += "".concat(args[0], " argument");
            break;
          case 2:
            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
            break;
          default:
            msg += args.slice(0, len - 1).join(", ");
            msg += ", and ".concat(args[len - 1], " arguments");
            break;
        }
        return "".concat(msg, " must be specified");
      }, TypeError);
      module.exports.codes = codes;
    }
  });

  // node_modules/assert/build/internal/assert/assertion_error.js
  var require_assertion_error = __commonJS({
    "node_modules/assert/build/internal/assert/assertion_error.js"(exports, module) {
      "use strict";
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
            _defineProperty(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return _typeof(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (_typeof(input) !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof(res) !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        Object.defineProperty(subClass, "prototype", { writable: false });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        } else if (call !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2)) return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2) _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof(o);
      }
      var _require = require_util2();
      var inspect = _require.inspect;
      var _require2 = require_errors();
      var ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function repeat(str, count) {
        count = Math.floor(count);
        if (str.length == 0 || count == 0) return "";
        var maxCount = str.length * count;
        count = Math.floor(Math.log(count) / Math.log(2));
        while (count) {
          str += str;
          count--;
        }
        str += str.substring(0, maxCount - str.length);
        return str;
      }
      var blue = "";
      var green = "";
      var red = "";
      var white = "";
      var kReadableOperator = {
        deepStrictEqual: "Expected values to be strictly deep-equal:",
        strictEqual: "Expected values to be strictly equal:",
        strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
        deepEqual: "Expected values to be loosely deep-equal:",
        equal: "Expected values to be loosely equal:",
        notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
        notStrictEqual: 'Expected "actual" to be strictly unequal to:',
        notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
        notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
        notEqual: 'Expected "actual" to be loosely unequal to:',
        notIdentical: "Values identical but not reference-equal:"
      };
      var kMaxShortLength = 10;
      function copyError(source) {
        var keys = Object.keys(source);
        var target = Object.create(Object.getPrototypeOf(source));
        keys.forEach(function(key) {
          target[key] = source[key];
        });
        Object.defineProperty(target, "message", {
          value: source.message
        });
        return target;
      }
      function inspectValue(val) {
        return inspect(val, {
          compact: false,
          customInspect: false,
          depth: 1e3,
          maxArrayLength: Infinity,
          // Assert compares only enumerable properties (with a few exceptions).
          showHidden: false,
          // Having a long line as error is better than wrapping the line for
          // comparison for now.
          // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
          // have meta information about the inspected properties (i.e., know where
          // in what line the property starts and ends).
          breakLength: Infinity,
          // Assert does not detect proxies currently.
          showProxy: false,
          sorted: true,
          // Inspect getters as we also check them when comparing entries.
          getters: true
        });
      }
      function createErrDiff(actual, expected, operator) {
        var other = "";
        var res = "";
        var lastPos = 0;
        var end = "";
        var skipped = false;
        var actualInspected = inspectValue(actual);
        var actualLines = actualInspected.split("\n");
        var expectedLines = inspectValue(expected).split("\n");
        var i = 0;
        var indicator = "";
        if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
          operator = "strictEqualObject";
        }
        if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
          var inputLength = actualLines[0].length + expectedLines[0].length;
          if (inputLength <= kMaxShortLength) {
            if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
              return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
            }
          } else if (operator !== "strictEqualObject") {
            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
            if (inputLength < maxLength) {
              while (actualLines[0][i] === expectedLines[0][i]) {
                i++;
              }
              if (i > 2) {
                indicator = "\n  ".concat(repeat(" ", i), "^");
                i = 0;
              }
            }
          }
        }
        var a = actualLines[actualLines.length - 1];
        var b = expectedLines[expectedLines.length - 1];
        while (a === b) {
          if (i++ < 2) {
            end = "\n  ".concat(a).concat(end);
          } else {
            other = a;
          }
          actualLines.pop();
          expectedLines.pop();
          if (actualLines.length === 0 || expectedLines.length === 0) break;
          a = actualLines[actualLines.length - 1];
          b = expectedLines[expectedLines.length - 1];
        }
        var maxLines = Math.max(actualLines.length, expectedLines.length);
        if (maxLines === 0) {
          var _actualLines = actualInspected.split("\n");
          if (_actualLines.length > 30) {
            _actualLines[26] = "".concat(blue, "...").concat(white);
            while (_actualLines.length > 27) {
              _actualLines.pop();
            }
          }
          return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
        }
        if (i > 3) {
          end = "\n".concat(blue, "...").concat(white).concat(end);
          skipped = true;
        }
        if (other !== "") {
          end = "\n  ".concat(other).concat(end);
          other = "";
        }
        var printedLines = 0;
        var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
        var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
        for (i = 0; i < maxLines; i++) {
          var cur = i - lastPos;
          if (actualLines.length < i + 1) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(expectedLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(expectedLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
            printedLines++;
          } else if (expectedLines.length < i + 1) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
            printedLines++;
          } else {
            var expectedLine = expectedLines[i];
            var actualLine = actualLines[i];
            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
            if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
              divergingLines = false;
              actualLine += ",";
            }
            if (divergingLines) {
              if (cur > 1 && i > 2) {
                if (cur > 4) {
                  res += "\n".concat(blue, "...").concat(white);
                  skipped = true;
                } else if (cur > 3) {
                  res += "\n  ".concat(actualLines[i - 2]);
                  printedLines++;
                }
                res += "\n  ".concat(actualLines[i - 1]);
                printedLines++;
              }
              lastPos = i;
              res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
              other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
              printedLines += 2;
            } else {
              res += other;
              other = "";
              if (cur === 1 || i === 0) {
                res += "\n  ".concat(actualLine);
                printedLines++;
              }
            }
          }
          if (printedLines > 20 && i < maxLines - 2) {
            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
          }
        }
        return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
      }
      var AssertionError = /* @__PURE__ */ function(_Error, _inspect$custom) {
        _inherits(AssertionError2, _Error);
        var _super = _createSuper(AssertionError2);
        function AssertionError2(options) {
          var _this;
          _classCallCheck(this, AssertionError2);
          if (_typeof(options) !== "object" || options === null) {
            throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
          }
          var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
          var actual = options.actual, expected = options.expected;
          var limit = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          if (message != null) {
            _this = _super.call(this, String(message));
          } else {
            if (process.stderr && process.stderr.isTTY) {
              if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                blue = "\x1B[34m";
                green = "\x1B[32m";
                white = "\x1B[39m";
                red = "\x1B[31m";
              } else {
                blue = "";
                green = "";
                white = "";
                red = "";
              }
            }
            if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
              actual = copyError(actual);
              expected = copyError(expected);
            }
            if (operator === "deepStrictEqual" || operator === "strictEqual") {
              _this = _super.call(this, createErrDiff(actual, expected, operator));
            } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
              var base = kReadableOperator[operator];
              var res = inspectValue(actual).split("\n");
              if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
                base = kReadableOperator.notStrictEqualObject;
              }
              if (res.length > 30) {
                res[26] = "".concat(blue, "...").concat(white);
                while (res.length > 27) {
                  res.pop();
                }
              }
              if (res.length === 1) {
                _this = _super.call(this, "".concat(base, " ").concat(res[0]));
              } else {
                _this = _super.call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n"));
              }
            } else {
              var _res = inspectValue(actual);
              var other = "";
              var knownOperators = kReadableOperator[operator];
              if (operator === "notDeepEqual" || operator === "notEqual") {
                _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                if (_res.length > 1024) {
                  _res = "".concat(_res.slice(0, 1021), "...");
                }
              } else {
                other = "".concat(inspectValue(expected));
                if (_res.length > 512) {
                  _res = "".concat(_res.slice(0, 509), "...");
                }
                if (other.length > 512) {
                  other = "".concat(other.slice(0, 509), "...");
                }
                if (operator === "deepEqual" || operator === "equal") {
                  _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                } else {
                  other = " ".concat(operator, " ").concat(other);
                }
              }
              _this = _super.call(this, "".concat(_res).concat(other));
            }
          }
          Error.stackTraceLimit = limit;
          _this.generatedMessage = !message;
          Object.defineProperty(_assertThisInitialized(_this), "name", {
            value: "AssertionError [ERR_ASSERTION]",
            enumerable: false,
            writable: true,
            configurable: true
          });
          _this.code = "ERR_ASSERTION";
          _this.actual = actual;
          _this.expected = expected;
          _this.operator = operator;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
          }
          _this.stack;
          _this.name = "AssertionError";
          return _possibleConstructorReturn(_this);
        }
        _createClass(AssertionError2, [{
          key: "toString",
          value: function toString() {
            return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
          }
        }, {
          key: _inspect$custom,
          value: function value(recurseTimes, ctx) {
            return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
              customInspect: false,
              depth: 0
            }));
          }
        }]);
        return AssertionError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error), inspect.custom);
      module.exports = AssertionError;
    }
  });

  // node_modules/object-keys/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/object-keys/isArguments.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      module.exports = function isArguments(value) {
        var str = toStr.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) {
          isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
      };
    }
  });

  // node_modules/object-keys/implementation.js
  var require_implementation2 = __commonJS({
    "node_modules/object-keys/implementation.js"(exports, module) {
      "use strict";
      var keysShim;
      if (!Object.keys) {
        has = Object.prototype.hasOwnProperty;
        toStr = Object.prototype.toString;
        isArgs = require_isArguments();
        isEnumerable = Object.prototype.propertyIsEnumerable;
        hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        hasProtoEnumBug = isEnumerable.call(function() {
        }, "prototype");
        dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ];
        equalsConstructorPrototype = function(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        hasAutomationEqualityBug = function() {
          if (typeof window === "undefined") {
            return false;
          }
          for (var k in window) {
            try {
              if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                try {
                  equalsConstructorPrototype(window[k]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        }();
        equalsConstructorPrototypeIfNotBuggy = function(o) {
          if (typeof window === "undefined" || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object) {
          var isObject = object !== null && typeof object === "object";
          var isFunction = toStr.call(object) === "[object Function]";
          var isArguments = isArgs(object);
          var isString = isObject && toStr.call(object) === "[object String]";
          var theKeys = [];
          if (!isObject && !isFunction && !isArguments) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object.length > 0 && !has.call(object, 0)) {
            for (var i = 0; i < object.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object.length > 0) {
            for (var j = 0; j < object.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object) {
              if (!(skipProto && name === "prototype") && has.call(object, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
      }
      var has;
      var toStr;
      var isArgs;
      var isEnumerable;
      var hasDontEnumBug;
      var hasProtoEnumBug;
      var dontEnums;
      var equalsConstructorPrototype;
      var excludedKeys;
      var hasAutomationEqualityBug;
      var equalsConstructorPrototypeIfNotBuggy;
      module.exports = keysShim;
    }
  });

  // node_modules/object-keys/index.js
  var require_object_keys = __commonJS({
    "node_modules/object-keys/index.js"(exports, module) {
      "use strict";
      var slice = Array.prototype.slice;
      var isArgs = require_isArguments();
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : require_implementation2();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object) {
              if (isArgs(object)) {
                return originalKeys(slice.call(object));
              }
              return originalKeys(object);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module.exports = keysShim;
    }
  });

  // node_modules/object.assign/implementation.js
  var require_implementation3 = __commonJS({
    "node_modules/object.assign/implementation.js"(exports, module) {
      "use strict";
      var objectKeys = require_object_keys();
      var hasSymbols = require_shams()();
      var callBound = require_callBound();
      var toObject = Object;
      var $push = callBound("Array.prototype.push");
      var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
      var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
      module.exports = function assign(target, source1) {
        if (target == null) {
          throw new TypeError("target must be an object");
        }
        var to = toObject(target);
        if (arguments.length === 1) {
          return to;
        }
        for (var s = 1; s < arguments.length; ++s) {
          var from = toObject(arguments[s]);
          var keys = objectKeys(from);
          var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
          if (getSymbols) {
            var syms = getSymbols(from);
            for (var j = 0; j < syms.length; ++j) {
              var key = syms[j];
              if ($propIsEnumerable(from, key)) {
                $push(keys, key);
              }
            }
          }
          for (var i = 0; i < keys.length; ++i) {
            var nextKey = keys[i];
            if ($propIsEnumerable(from, nextKey)) {
              var propValue = from[nextKey];
              to[nextKey] = propValue;
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/object.assign/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/object.assign/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation3();
      var lacksProperEnumerationOrder = function() {
        if (!Object.assign) {
          return false;
        }
        var str = "abcdefghijklmnopqrst";
        var letters = str.split("");
        var map = {};
        for (var i = 0; i < letters.length; ++i) {
          map[letters[i]] = letters[i];
        }
        var obj = Object.assign({}, map);
        var actual = "";
        for (var k in obj) {
          actual += k;
        }
        return str !== actual;
      };
      var assignHasPendingExceptions = function() {
        if (!Object.assign || !Object.preventExtensions) {
          return false;
        }
        var thrower = Object.preventExtensions({ 1: 2 });
        try {
          Object.assign(thrower, "xy");
        } catch (e) {
          return thrower[1] === "y";
        }
        return false;
      };
      module.exports = function getPolyfill() {
        if (!Object.assign) {
          return implementation;
        }
        if (lacksProperEnumerationOrder()) {
          return implementation;
        }
        if (assignHasPendingExceptions()) {
          return implementation;
        }
        return Object.assign;
      };
    }
  });

  // node_modules/object-is/implementation.js
  var require_implementation4 = __commonJS({
    "node_modules/object-is/implementation.js"(exports, module) {
      "use strict";
      var numberIsNaN = function(value) {
        return value !== value;
      };
      module.exports = function is(a, b) {
        if (a === 0 && b === 0) {
          return 1 / a === 1 / b;
        }
        if (a === b) {
          return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b)) {
          return true;
        }
        return false;
      };
    }
  });

  // node_modules/object-is/polyfill.js
  var require_polyfill2 = __commonJS({
    "node_modules/object-is/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation4();
      module.exports = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation;
      };
    }
  });

  // node_modules/define-properties/index.js
  var require_define_properties = __commonJS({
    "node_modules/define-properties/index.js"(exports, module) {
      "use strict";
      var keys = require_object_keys();
      var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr = Object.prototype.toString;
      var concat = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction = function(fn) {
        return typeof fn === "function" && toStr.call(fn) === "[object Function]";
      };
      var hasPropertyDescriptors = require_has_property_descriptors()();
      var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
      var defineProperty = function(object, name, value, predicate) {
        if (name in object) {
          if (predicate === true) {
            if (object[name] === value) {
              return;
            }
          } else if (!isFunction(predicate) || !predicate()) {
            return;
          }
        }
        if (supportsDescriptors) {
          origDefineProperty(object, name, {
            configurable: true,
            enumerable: false,
            value,
            writable: true
          });
        } else {
          object[name] = value;
        }
      };
      var defineProperties = function(object, map) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map);
        if (hasSymbols) {
          props = concat.call(props, Object.getOwnPropertySymbols(map));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module.exports = defineProperties;
    }
  });

  // node_modules/object-is/shim.js
  var require_shim = __commonJS({
    "node_modules/object-is/shim.js"(exports, module) {
      "use strict";
      var getPolyfill = require_polyfill2();
      var define2 = require_define_properties();
      module.exports = function shimObjectIs() {
        var polyfill = getPolyfill();
        define2(Object, { is: polyfill }, {
          is: function testObjectIs() {
            return Object.is !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/object-is/index.js
  var require_object_is = __commonJS({
    "node_modules/object-is/index.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation4();
      var getPolyfill = require_polyfill2();
      var shim = require_shim();
      var polyfill = callBind(getPolyfill(), Object);
      define2(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // node_modules/is-nan/implementation.js
  var require_implementation5 = __commonJS({
    "node_modules/is-nan/implementation.js"(exports, module) {
      "use strict";
      module.exports = function isNaN2(value) {
        return value !== value;
      };
    }
  });

  // node_modules/is-nan/polyfill.js
  var require_polyfill3 = __commonJS({
    "node_modules/is-nan/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation5();
      module.exports = function getPolyfill() {
        if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
          return Number.isNaN;
        }
        return implementation;
      };
    }
  });

  // node_modules/is-nan/shim.js
  var require_shim2 = __commonJS({
    "node_modules/is-nan/shim.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var getPolyfill = require_polyfill3();
      module.exports = function shimNumberIsNaN() {
        var polyfill = getPolyfill();
        define2(Number, { isNaN: polyfill }, {
          isNaN: function testIsNaN() {
            return Number.isNaN !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/is-nan/index.js
  var require_is_nan = __commonJS({
    "node_modules/is-nan/index.js"(exports, module) {
      "use strict";
      var callBind = require_call_bind();
      var define2 = require_define_properties();
      var implementation = require_implementation5();
      var getPolyfill = require_polyfill3();
      var shim = require_shim2();
      var polyfill = callBind(getPolyfill(), Number);
      define2(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // node_modules/assert/build/internal/util/comparisons.js
  var require_comparisons = __commonJS({
    "node_modules/assert/build/internal/util/comparisons.js"(exports, module) {
      "use strict";
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function _iterableToArrayLimit(r, l) {
        var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (null != t) {
          var e, n, i, u, a = [], f = true, o = false;
          try {
            if (i = (t = t.call(r)).next, 0 === l) {
              if (Object(t) !== t) return;
              f = false;
            } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
          } catch (r2) {
            o = true, n = r2;
          } finally {
            try {
              if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
            } finally {
              if (o) throw n;
            }
          }
          return a;
        }
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof(o);
      }
      var regexFlagsSupported = /a/g.flags !== void 0;
      var arrayFromSet = function arrayFromSet2(set) {
        var array = [];
        set.forEach(function(value) {
          return array.push(value);
        });
        return array;
      };
      var arrayFromMap = function arrayFromMap2(map) {
        var array = [];
        map.forEach(function(value, key) {
          return array.push([key, value]);
        });
        return array;
      };
      var objectIs = Object.is ? Object.is : require_object_is();
      var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return [];
      };
      var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
      var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
      var objectToString = uncurryThis(Object.prototype.toString);
      var _require$types = require_util2().types;
      var isAnyArrayBuffer = _require$types.isAnyArrayBuffer;
      var isArrayBufferView = _require$types.isArrayBufferView;
      var isDate = _require$types.isDate;
      var isMap = _require$types.isMap;
      var isRegExp = _require$types.isRegExp;
      var isSet = _require$types.isSet;
      var isNativeError = _require$types.isNativeError;
      var isBoxedPrimitive = _require$types.isBoxedPrimitive;
      var isNumberObject = _require$types.isNumberObject;
      var isStringObject = _require$types.isStringObject;
      var isBooleanObject = _require$types.isBooleanObject;
      var isBigIntObject = _require$types.isBigIntObject;
      var isSymbolObject = _require$types.isSymbolObject;
      var isFloat32Array = _require$types.isFloat32Array;
      var isFloat64Array = _require$types.isFloat64Array;
      function isNonIndex(key) {
        if (key.length === 0 || key.length > 10) return true;
        for (var i = 0; i < key.length; i++) {
          var code = key.charCodeAt(i);
          if (code < 48 || code > 57) return true;
        }
        return key.length === 10 && key >= Math.pow(2, 32);
      }
      function getOwnNonIndexProperties(value) {
        return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
      }
      function compare(a, b) {
        if (a === b) {
          return 0;
        }
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) {
          return -1;
        }
        if (y < x) {
          return 1;
        }
        return 0;
      }
      var ONLY_ENUMERABLE = void 0;
      var kStrict = true;
      var kLoose = false;
      var kNoIterator = 0;
      var kIsArray = 1;
      var kIsSet = 2;
      var kIsMap = 3;
      function areSimilarRegExps(a, b) {
        return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
      }
      function areSimilarFloatArrays(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        for (var offset = 0; offset < a.byteLength; offset++) {
          if (a[offset] !== b[offset]) {
            return false;
          }
        }
        return true;
      }
      function areSimilarTypedArrays(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
      }
      function areEqualArrayBuffers(buf1, buf2) {
        return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
      }
      function isEqualBoxedPrimitive(val1, val2) {
        if (isNumberObject(val1)) {
          return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
        }
        if (isStringObject(val1)) {
          return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
        }
        if (isBooleanObject(val1)) {
          return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
        }
        if (isBigIntObject(val1)) {
          return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
        }
        return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
      }
      function innerDeepEqual(val1, val2, strict, memos) {
        if (val1 === val2) {
          if (val1 !== 0) return true;
          return strict ? objectIs(val1, val2) : true;
        }
        if (strict) {
          if (_typeof(val1) !== "object") {
            return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
          }
          if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
            return false;
          }
          if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
          }
        } else {
          if (val1 === null || _typeof(val1) !== "object") {
            if (val2 === null || _typeof(val2) !== "object") {
              return val1 == val2;
            }
            return false;
          }
          if (val2 === null || _typeof(val2) !== "object") {
            return false;
          }
        }
        var val1Tag = objectToString(val1);
        var val2Tag = objectToString(val2);
        if (val1Tag !== val2Tag) {
          return false;
        }
        if (Array.isArray(val1)) {
          if (val1.length !== val2.length) {
            return false;
          }
          var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
          var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
        }
        if (val1Tag === "[object Object]") {
          if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
            return false;
          }
        }
        if (isDate(val1)) {
          if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
            return false;
          }
        } else if (isRegExp(val1)) {
          if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
            return false;
          }
        } else if (isNativeError(val1) || val1 instanceof Error) {
          if (val1.message !== val2.message || val1.name !== val2.name) {
            return false;
          }
        } else if (isArrayBufferView(val1)) {
          if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
              return false;
            }
          } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
          }
          var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
          var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
          if (_keys.length !== _keys2.length) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
        } else if (isSet(val1)) {
          if (!isSet(val2) || val1.size !== val2.size) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsSet);
        } else if (isMap(val1)) {
          if (!isMap(val2) || val1.size !== val2.size) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsMap);
        } else if (isAnyArrayBuffer(val1)) {
          if (!areEqualArrayBuffers(val1, val2)) {
            return false;
          }
        } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator);
      }
      function getEnumerables(val, keys) {
        return keys.filter(function(k) {
          return propertyIsEnumerable(val, k);
        });
      }
      function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
        if (arguments.length === 5) {
          aKeys = Object.keys(val1);
          var bKeys = Object.keys(val2);
          if (aKeys.length !== bKeys.length) {
            return false;
          }
        }
        var i = 0;
        for (; i < aKeys.length; i++) {
          if (!hasOwnProperty(val2, aKeys[i])) {
            return false;
          }
        }
        if (strict && arguments.length === 5) {
          var symbolKeysA = objectGetOwnPropertySymbols(val1);
          if (symbolKeysA.length !== 0) {
            var count = 0;
            for (i = 0; i < symbolKeysA.length; i++) {
              var key = symbolKeysA[i];
              if (propertyIsEnumerable(val1, key)) {
                if (!propertyIsEnumerable(val2, key)) {
                  return false;
                }
                aKeys.push(key);
                count++;
              } else if (propertyIsEnumerable(val2, key)) {
                return false;
              }
            }
            var symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
              return false;
            }
          } else {
            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
              return false;
            }
          }
        }
        if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
          return true;
        }
        if (memos === void 0) {
          memos = {
            val1: /* @__PURE__ */ new Map(),
            val2: /* @__PURE__ */ new Map(),
            position: 0
          };
        } else {
          var val2MemoA = memos.val1.get(val1);
          if (val2MemoA !== void 0) {
            var val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== void 0) {
              return val2MemoA === val2MemoB;
            }
          }
          memos.position++;
        }
        memos.val1.set(val1, memos.position);
        memos.val2.set(val2, memos.position);
        var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
        memos.val1.delete(val1);
        memos.val2.delete(val2);
        return areEq;
      }
      function setHasEqualElement(set, val1, strict, memo) {
        var setValues = arrayFromSet(set);
        for (var i = 0; i < setValues.length; i++) {
          var val2 = setValues[i];
          if (innerDeepEqual(val1, val2, strict, memo)) {
            set.delete(val2);
            return true;
          }
        }
        return false;
      }
      function findLooseMatchingPrimitives(prim) {
        switch (_typeof(prim)) {
          case "undefined":
            return null;
          case "object":
            return void 0;
          case "symbol":
            return false;
          case "string":
            prim = +prim;
          // Loose equal entries exist only if the string is possible to convert to
          // a regular number and not NaN.
          // Fall through
          case "number":
            if (numberIsNaN(prim)) {
              return false;
            }
        }
        return true;
      }
      function setMightHaveLoosePrim(a, b, prim) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) return altValue;
        return b.has(altValue) && !a.has(altValue);
      }
      function mapMightHaveLoosePrim(a, b, prim, item, memo) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) {
          return altValue;
        }
        var curB = b.get(altValue);
        if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
          return false;
        }
        return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
      }
      function setEquiv(a, b, strict, memo) {
        var set = null;
        var aValues = arrayFromSet(a);
        for (var i = 0; i < aValues.length; i++) {
          var val = aValues[i];
          if (_typeof(val) === "object" && val !== null) {
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(val);
          } else if (!b.has(val)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(a, b, val)) {
              return false;
            }
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(val);
          }
        }
        if (set !== null) {
          var bValues = arrayFromSet(b);
          for (var _i = 0; _i < bValues.length; _i++) {
            var _val = bValues[_i];
            if (_typeof(_val) === "object" && _val !== null) {
              if (!setHasEqualElement(set, _val, strict, memo)) return false;
            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
              return false;
            }
          }
          return set.size === 0;
        }
        return true;
      }
      function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
        var setValues = arrayFromSet(set);
        for (var i = 0; i < setValues.length; i++) {
          var key2 = setValues[i];
          if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
            set.delete(key2);
            return true;
          }
        }
        return false;
      }
      function mapEquiv(a, b, strict, memo) {
        var set = null;
        var aEntries = arrayFromMap(a);
        for (var i = 0; i < aEntries.length; i++) {
          var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
          if (_typeof(key) === "object" && key !== null) {
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key);
          } else {
            var item2 = b.get(key);
            if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
              if (strict) return false;
              if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
              if (set === null) {
                set = /* @__PURE__ */ new Set();
              }
              set.add(key);
            }
          }
        }
        if (set !== null) {
          var bEntries = arrayFromMap(b);
          for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
            if (_typeof(_key) === "object" && _key !== null) {
              if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
            } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
              return false;
            }
          }
          return set.size === 0;
        }
        return true;
      }
      function objEquiv(a, b, strict, keys, memos, iterationType) {
        var i = 0;
        if (iterationType === kIsSet) {
          if (!setEquiv(a, b, strict, memos)) {
            return false;
          }
        } else if (iterationType === kIsMap) {
          if (!mapEquiv(a, b, strict, memos)) {
            return false;
          }
        } else if (iterationType === kIsArray) {
          for (; i < a.length; i++) {
            if (hasOwnProperty(a, i)) {
              if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                return false;
              }
            } else if (hasOwnProperty(b, i)) {
              return false;
            } else {
              var keysA = Object.keys(a);
              for (; i < keysA.length; i++) {
                var key = keysA[i];
                if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                  return false;
                }
              }
              if (keysA.length !== Object.keys(b).length) {
                return false;
              }
              return true;
            }
          }
        }
        for (i = 0; i < keys.length; i++) {
          var _key2 = keys[i];
          if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
            return false;
          }
        }
        return true;
      }
      function isDeepEqual(val1, val2) {
        return innerDeepEqual(val1, val2, kLoose);
      }
      function isDeepStrictEqual(val1, val2) {
        return innerDeepEqual(val1, val2, kStrict);
      }
      module.exports = {
        isDeepEqual,
        isDeepStrictEqual
      };
    }
  });

  // node_modules/assert/build/assert.js
  var require_assert = __commonJS({
    "node_modules/assert/build/assert.js"(exports, module) {
      "use strict";
      function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof(o);
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return _typeof(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (_typeof(input) !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof(res) !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _require = require_errors();
      var _require$codes = _require.codes;
      var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
      var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var AssertionError = require_assertion_error();
      var _require2 = require_util2();
      var inspect = _require2.inspect;
      var _require$types = require_util2().types;
      var isPromise = _require$types.isPromise;
      var isRegExp = _require$types.isRegExp;
      var objectAssign = require_polyfill()();
      var objectIs = require_polyfill2()();
      var RegExpPrototypeTest = require_callBound()("RegExp.prototype.test");
      var isDeepEqual;
      var isDeepStrictEqual;
      function lazyLoadComparison() {
        var comparison = require_comparisons();
        isDeepEqual = comparison.isDeepEqual;
        isDeepStrictEqual = comparison.isDeepStrictEqual;
      }
      var warned = false;
      var assert = module.exports = ok;
      var NO_EXCEPTION_SENTINEL = {};
      function innerFail(obj) {
        if (obj.message instanceof Error) throw obj.message;
        throw new AssertionError(obj);
      }
      function fail(actual, expected, message, operator, stackStartFn) {
        var argsLen = arguments.length;
        var internalMessage;
        if (argsLen === 0) {
          internalMessage = "Failed";
        } else if (argsLen === 1) {
          message = actual;
          actual = void 0;
        } else {
          if (warned === false) {
            warned = true;
            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
            warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
          }
          if (argsLen === 2) operator = "!=";
        }
        if (message instanceof Error) throw message;
        var errArgs = {
          actual,
          expected,
          operator: operator === void 0 ? "fail" : operator,
          stackStartFn: stackStartFn || fail
        };
        if (message !== void 0) {
          errArgs.message = message;
        }
        var err = new AssertionError(errArgs);
        if (internalMessage) {
          err.message = internalMessage;
          err.generatedMessage = true;
        }
        throw err;
      }
      assert.fail = fail;
      assert.AssertionError = AssertionError;
      function innerOk(fn, argLen, value, message) {
        if (!value) {
          var generatedMessage = false;
          if (argLen === 0) {
            generatedMessage = true;
            message = "No value argument passed to `assert.ok()`";
          } else if (message instanceof Error) {
            throw message;
          }
          var err = new AssertionError({
            actual: value,
            expected: true,
            message,
            operator: "==",
            stackStartFn: fn
          });
          err.generatedMessage = generatedMessage;
          throw err;
        }
      }
      function ok() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        innerOk.apply(void 0, [ok, args.length].concat(args));
      }
      assert.ok = ok;
      assert.equal = function equal(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (actual != expected) {
          innerFail({
            actual,
            expected,
            message,
            operator: "==",
            stackStartFn: equal
          });
        }
      };
      assert.notEqual = function notEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (actual == expected) {
          innerFail({
            actual,
            expected,
            message,
            operator: "!=",
            stackStartFn: notEqual
          });
        }
      };
      assert.deepEqual = function deepEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0) lazyLoadComparison();
        if (!isDeepEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "deepEqual",
            stackStartFn: deepEqual
          });
        }
      };
      assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0) lazyLoadComparison();
        if (isDeepEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notDeepEqual",
            stackStartFn: notDeepEqual
          });
        }
      };
      assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0) lazyLoadComparison();
        if (!isDeepStrictEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "deepStrictEqual",
            stackStartFn: deepStrictEqual
          });
        }
      };
      assert.notDeepStrictEqual = notDeepStrictEqual;
      function notDeepStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0) lazyLoadComparison();
        if (isDeepStrictEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notDeepStrictEqual",
            stackStartFn: notDeepStrictEqual
          });
        }
      }
      assert.strictEqual = function strictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (!objectIs(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "strictEqual",
            stackStartFn: strictEqual
          });
        }
      };
      assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (objectIs(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notStrictEqual",
            stackStartFn: notStrictEqual
          });
        }
      };
      var Comparison = /* @__PURE__ */ _createClass(function Comparison2(obj, keys, actual) {
        var _this = this;
        _classCallCheck(this, Comparison2);
        keys.forEach(function(key) {
          if (key in obj) {
            if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
              _this[key] = actual[key];
            } else {
              _this[key] = obj[key];
            }
          }
        });
      });
      function compareExceptionKey(actual, expected, key, message, keys, fn) {
        if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
          if (!message) {
            var a = new Comparison(actual, keys);
            var b = new Comparison(expected, keys, actual);
            var err = new AssertionError({
              actual: a,
              expected: b,
              operator: "deepStrictEqual",
              stackStartFn: fn
            });
            err.actual = actual;
            err.expected = expected;
            err.operator = fn.name;
            throw err;
          }
          innerFail({
            actual,
            expected,
            message,
            operator: fn.name,
            stackStartFn: fn
          });
        }
      }
      function expectedException(actual, expected, msg, fn) {
        if (typeof expected !== "function") {
          if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
          if (arguments.length === 2) {
            throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
          }
          if (_typeof(actual) !== "object" || actual === null) {
            var err = new AssertionError({
              actual,
              expected,
              message: msg,
              operator: "deepStrictEqual",
              stackStartFn: fn
            });
            err.operator = fn.name;
            throw err;
          }
          var keys = Object.keys(expected);
          if (expected instanceof Error) {
            keys.push("name", "message");
          } else if (keys.length === 0) {
            throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
          }
          if (isDeepEqual === void 0) lazyLoadComparison();
          keys.forEach(function(key) {
            if (typeof actual[key] === "string" && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
              return;
            }
            compareExceptionKey(actual, expected, key, msg, keys, fn);
          });
          return true;
        }
        if (expected.prototype !== void 0 && actual instanceof expected) {
          return true;
        }
        if (Error.isPrototypeOf(expected)) {
          return false;
        }
        return expected.call({}, actual) === true;
      }
      function getActual(fn) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
        }
        try {
          fn();
        } catch (e) {
          return e;
        }
        return NO_EXCEPTION_SENTINEL;
      }
      function checkIsPromise(obj) {
        return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
      }
      function waitForActual(promiseFn) {
        return Promise.resolve().then(function() {
          var resultPromise;
          if (typeof promiseFn === "function") {
            resultPromise = promiseFn();
            if (!checkIsPromise(resultPromise)) {
              throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
            }
          } else if (checkIsPromise(promiseFn)) {
            resultPromise = promiseFn;
          } else {
            throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
          }
          return Promise.resolve().then(function() {
            return resultPromise;
          }).then(function() {
            return NO_EXCEPTION_SENTINEL;
          }).catch(function(e) {
            return e;
          });
        });
      }
      function expectsError(stackStartFn, actual, error, message) {
        if (typeof error === "string") {
          if (arguments.length === 4) {
            throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
          }
          if (_typeof(actual) === "object" && actual !== null) {
            if (actual.message === error) {
              throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
            }
          } else if (actual === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
          }
          message = error;
          error = void 0;
        } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
        }
        if (actual === NO_EXCEPTION_SENTINEL) {
          var details = "";
          if (error && error.name) {
            details += " (".concat(error.name, ")");
          }
          details += message ? ": ".concat(message) : ".";
          var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
          innerFail({
            actual: void 0,
            expected: error,
            operator: stackStartFn.name,
            message: "Missing expected ".concat(fnType).concat(details),
            stackStartFn
          });
        }
        if (error && !expectedException(actual, error, message, stackStartFn)) {
          throw actual;
        }
      }
      function expectsNoError(stackStartFn, actual, error, message) {
        if (actual === NO_EXCEPTION_SENTINEL) return;
        if (typeof error === "string") {
          message = error;
          error = void 0;
        }
        if (!error || expectedException(actual, error)) {
          var details = message ? ": ".concat(message) : ".";
          var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
          innerFail({
            actual,
            expected: error,
            operator: stackStartFn.name,
            message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
            stackStartFn
          });
        }
        throw actual;
      }
      assert.throws = function throws(promiseFn) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
      };
      assert.rejects = function rejects(promiseFn) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        return waitForActual(promiseFn).then(function(result) {
          return expectsError.apply(void 0, [rejects, result].concat(args));
        });
      };
      assert.doesNotThrow = function doesNotThrow(fn) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
      };
      assert.doesNotReject = function doesNotReject(fn) {
        for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          args[_key5 - 1] = arguments[_key5];
        }
        return waitForActual(fn).then(function(result) {
          return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
        });
      };
      assert.ifError = function ifError(err) {
        if (err !== null && err !== void 0) {
          var message = "ifError got unwanted exception: ";
          if (_typeof(err) === "object" && typeof err.message === "string") {
            if (err.message.length === 0 && err.constructor) {
              message += err.constructor.name;
            } else {
              message += err.message;
            }
          } else {
            message += inspect(err);
          }
          var newErr = new AssertionError({
            actual: err,
            expected: null,
            operator: "ifError",
            message,
            stackStartFn: ifError
          });
          var origStack = err.stack;
          if (typeof origStack === "string") {
            var tmp2 = origStack.split("\n");
            tmp2.shift();
            var tmp1 = newErr.stack.split("\n");
            for (var i = 0; i < tmp2.length; i++) {
              var pos = tmp1.indexOf(tmp2[i]);
              if (pos !== -1) {
                tmp1 = tmp1.slice(0, pos);
                break;
              }
            }
            newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
          }
          throw newErr;
        }
      };
      function internalMatch(string, regexp, message, fn, fnName) {
        if (!isRegExp(regexp)) {
          throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
        }
        var match = fnName === "match";
        if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
          if (message instanceof Error) {
            throw message;
          }
          var generatedMessage = !message;
          message = message || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
          var err = new AssertionError({
            actual: string,
            expected: regexp,
            message,
            operator: fnName,
            stackStartFn: fn
          });
          err.generatedMessage = generatedMessage;
          throw err;
        }
      }
      assert.match = function match(string, regexp, message) {
        internalMatch(string, regexp, message, match, "match");
      };
      assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
        internalMatch(string, regexp, message, doesNotMatch, "doesNotMatch");
      };
      function strict() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        innerOk.apply(void 0, [strict, args.length].concat(args));
      }
      assert.strict = objectAssign(strict, assert, {
        equal: assert.strictEqual,
        deepEqual: assert.deepStrictEqual,
        notEqual: assert.notStrictEqual,
        notDeepEqual: assert.notDeepStrictEqual
      });
      assert.strict.strict = assert.strict;
    }
  });

  // node_modules/stream-parser/node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/stream-parser/node_modules/ms/index.js"(exports, module) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isNaN(val) === false) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        if (ms >= d) {
          return Math.round(ms / d) + "d";
        }
        if (ms >= h) {
          return Math.round(ms / h) + "h";
        }
        if (ms >= m) {
          return Math.round(ms / m) + "m";
        }
        if (ms >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
      }
      function plural(ms, n, name) {
        if (ms < n) {
          return;
        }
        if (ms < n * 1.5) {
          return Math.floor(ms / n) + " " + name;
        }
        return Math.ceil(ms / n) + " " + name + "s";
      }
    }
  });

  // node_modules/stream-parser/node_modules/debug/src/debug.js
  var require_debug = __commonJS({
    "node_modules/stream-parser/node_modules/debug/src/debug.js"(exports, module) {
      exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
      exports.coerce = coerce;
      exports.disable = disable;
      exports.enable = enable;
      exports.enabled = enabled;
      exports.humanize = require_ms();
      exports.names = [];
      exports.skips = [];
      exports.formatters = {};
      var prevTime;
      function selectColor(namespace) {
        var hash = 0, i;
        for (i in namespace) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return exports.colors[Math.abs(hash) % exports.colors.length];
      }
      function createDebug(namespace) {
        function debug() {
          if (!debug.enabled) return;
          var self2 = debug;
          var curr = +/* @__PURE__ */ new Date();
          var ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          args[0] = exports.coerce(args[0]);
          if ("string" !== typeof args[0]) {
            args.unshift("%O");
          }
          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
            if (match === "%%") return match;
            index++;
            var formatter = exports.formatters[format];
            if ("function" === typeof formatter) {
              var val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          exports.formatArgs.call(self2, args);
          var logFn = debug.log || exports.log || console.log.bind(console);
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.enabled = exports.enabled(namespace);
        debug.useColors = exports.useColors();
        debug.color = selectColor(namespace);
        if ("function" === typeof exports.init) {
          exports.init(debug);
        }
        return debug;
      }
      function enable(namespaces) {
        exports.save(namespaces);
        exports.names = [];
        exports.skips = [];
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for (var i = 0; i < len; i++) {
          if (!split[i]) continue;
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            exports.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        exports.enable("");
      }
      function enabled(name) {
        var i, len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
          if (exports.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
          if (exports.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) return val.stack || val.message;
        return val;
      }
    }
  });

  // node_modules/stream-parser/node_modules/debug/src/browser.js
  var require_browser2 = __commonJS({
    "node_modules/stream-parser/node_modules/debug/src/browser.js"(exports, module) {
      exports = module.exports = require_debug();
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
      exports.colors = [
        "lightseagreen",
        "forestgreen",
        "goldenrod",
        "dodgerblue",
        "darkorchid",
        "crimson"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
          return true;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      exports.formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (err) {
          return "[UnexpectedJSONParseError]: " + err.message;
        }
      };
      function formatArgs(args) {
        var useColors2 = this.useColors;
        args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
        if (!useColors2) return;
        var c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match) {
          if ("%%" === match) return;
          index++;
          if ("%c" === match) {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      function log() {
        return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }
      function save(namespaces) {
        try {
          if (null == namespaces) {
            exports.storage.removeItem("debug");
          } else {
            exports.storage.debug = namespaces;
          }
        } catch (e) {
        }
      }
      function load() {
        var r;
        try {
          r = exports.storage.debug;
        } catch (e) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      exports.enable(load());
      function localstorage() {
        try {
          return window.localStorage;
        } catch (e) {
        }
      }
    }
  });

  // node_modules/stream-parser/index.js
  var require_stream_parser = __commonJS({
    "node_modules/stream-parser/index.js"(exports, module) {
      var assert = require_assert();
      var debug = require_browser2()("stream-parser");
      module.exports = Parser;
      var INIT = -1;
      var BUFFERING = 0;
      var SKIPPING = 1;
      var PASSTHROUGH = 2;
      function Parser(stream) {
        var isTransform = stream && "function" == typeof stream._transform;
        var isWritable = stream && "function" == typeof stream._write;
        if (!isTransform && !isWritable) throw new Error("must pass a Writable or Transform stream in");
        debug("extending Parser into stream");
        stream._bytes = _bytes;
        stream._skipBytes = _skipBytes;
        if (isTransform) stream._passthrough = _passthrough;
        if (isTransform) {
          stream._transform = transform;
        } else {
          stream._write = write;
        }
      }
      function init(stream) {
        debug("initializing parser stream");
        stream._parserBytesLeft = 0;
        stream._parserBuffers = [];
        stream._parserBuffered = 0;
        stream._parserState = INIT;
        stream._parserCallback = null;
        if ("function" == typeof stream.push) {
          stream._parserOutput = stream.push.bind(stream);
        }
        stream._parserInit = true;
      }
      function _bytes(n, fn) {
        assert(!this._parserCallback, 'there is already a "callback" set!');
        assert(isFinite(n) && n > 0, 'can only buffer a finite number of bytes > 0, got "' + n + '"');
        if (!this._parserInit) init(this);
        debug("buffering %o bytes", n);
        this._parserBytesLeft = n;
        this._parserCallback = fn;
        this._parserState = BUFFERING;
      }
      function _skipBytes(n, fn) {
        assert(!this._parserCallback, 'there is already a "callback" set!');
        assert(n > 0, 'can only skip > 0 bytes, got "' + n + '"');
        if (!this._parserInit) init(this);
        debug("skipping %o bytes", n);
        this._parserBytesLeft = n;
        this._parserCallback = fn;
        this._parserState = SKIPPING;
      }
      function _passthrough(n, fn) {
        assert(!this._parserCallback, 'There is already a "callback" set!');
        assert(n > 0, 'can only pass through > 0 bytes, got "' + n + '"');
        if (!this._parserInit) init(this);
        debug("passing through %o bytes", n);
        this._parserBytesLeft = n;
        this._parserCallback = fn;
        this._parserState = PASSTHROUGH;
      }
      function write(chunk, encoding, fn) {
        if (!this._parserInit) init(this);
        debug("write(%o bytes)", chunk.length);
        if ("function" == typeof encoding) fn = encoding;
        data(this, chunk, null, fn);
      }
      function transform(chunk, output, fn) {
        if (!this._parserInit) init(this);
        debug("transform(%o bytes)", chunk.length);
        if ("function" != typeof output) {
          output = this._parserOutput;
        }
        data(this, chunk, output, fn);
      }
      function _data(stream, chunk, output, fn) {
        if (stream._parserBytesLeft <= 0) {
          return fn(new Error("got data but not currently parsing anything"));
        }
        if (chunk.length <= stream._parserBytesLeft) {
          return function() {
            return process2(stream, chunk, output, fn);
          };
        } else {
          return function() {
            var b = chunk.slice(0, stream._parserBytesLeft);
            return process2(stream, b, output, function(err) {
              if (err) return fn(err);
              if (chunk.length > b.length) {
                return function() {
                  return _data(stream, chunk.slice(b.length), output, fn);
                };
              }
            });
          };
        }
      }
      function process2(stream, chunk, output, fn) {
        stream._parserBytesLeft -= chunk.length;
        debug("%o bytes left for stream piece", stream._parserBytesLeft);
        if (stream._parserState === BUFFERING) {
          stream._parserBuffers.push(chunk);
          stream._parserBuffered += chunk.length;
        } else if (stream._parserState === PASSTHROUGH) {
          output(chunk);
        }
        if (0 === stream._parserBytesLeft) {
          var cb = stream._parserCallback;
          if (cb && stream._parserState === BUFFERING && stream._parserBuffers.length > 1) {
            chunk = Buffer.concat(stream._parserBuffers, stream._parserBuffered);
          }
          if (stream._parserState !== BUFFERING) {
            chunk = null;
          }
          stream._parserCallback = null;
          stream._parserBuffered = 0;
          stream._parserState = INIT;
          stream._parserBuffers.splice(0);
          if (cb) {
            var args = [];
            if (chunk) {
              args.push(chunk);
            } else {
            }
            if (output) {
              args.push(output);
            }
            var async = cb.length > args.length;
            if (async) {
              args.push(trampoline(fn));
            }
            var rtn = cb.apply(stream, args);
            if (!async || fn === rtn) return fn;
          }
        } else {
          return fn;
        }
      }
      var data = trampoline(_data);
      function trampoline(fn) {
        return function() {
          var result = fn.apply(this, arguments);
          while ("function" == typeof result) {
            result = result();
          }
          return result;
        };
      }
    }
  });

  // node_modules/probe-image-size/lib/common.js
  var require_common = __commonJS({
    "node_modules/probe-image-size/lib/common.js"(exports) {
      "use strict";
      var Transform = require_stream_browserify().Transform;
      var streamParser = require_stream_parser();
      function ParserStream() {
        Transform.call(this, { readableObjectMode: true });
      }
      ParserStream.prototype = Object.create(Transform.prototype);
      ParserStream.prototype.constructor = ParserStream;
      streamParser(ParserStream.prototype);
      exports.ParserStream = ParserStream;
      exports.sliceEq = function(src, start, dest) {
        for (var i = start, j = 0; j < dest.length; ) {
          if (src[i++] !== dest[j++]) return false;
        }
        return true;
      };
      exports.str2arr = function(str, format) {
        var arr = [], i = 0;
        if (format && format === "hex") {
          while (i < str.length) {
            arr.push(parseInt(str.slice(i, i + 2), 16));
            i += 2;
          }
        } else {
          for (; i < str.length; i++) {
            arr.push(str.charCodeAt(i) & 255);
          }
        }
        return arr;
      };
      exports.readUInt16LE = function(data, offset) {
        return data[offset] | data[offset + 1] << 8;
      };
      exports.readUInt16BE = function(data, offset) {
        return data[offset + 1] | data[offset] << 8;
      };
      exports.readUInt32LE = function(data, offset) {
        return data[offset] | data[offset + 1] << 8 | data[offset + 2] << 16 | data[offset + 3] * 16777216;
      };
      exports.readUInt32BE = function(data, offset) {
        return data[offset + 3] | data[offset + 2] << 8 | data[offset + 1] << 16 | data[offset] * 16777216;
      };
      function ProbeError(message, code, statusCode) {
        Error.call(this);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          this.stack = new Error().stack || "";
        }
        this.name = this.constructor.name;
        this.message = message;
        if (code) this.code = code;
        if (statusCode) this.statusCode = statusCode;
      }
      ProbeError.prototype = Object.create(Error.prototype);
      ProbeError.prototype.constructor = ProbeError;
      exports.ProbeError = ProbeError;
    }
  });

  // node_modules/probe-image-size/lib/miaf_utils.js
  var require_miaf_utils = __commonJS({
    "node_modules/probe-image-size/lib/miaf_utils.js"(exports, module) {
      "use strict";
      var readUInt16BE = require_common().readUInt16BE;
      var readUInt32BE = require_common().readUInt32BE;
      function unbox(data, offset) {
        if (data.length < 4 + offset) return null;
        var size = readUInt32BE(data, offset);
        if (data.length < size + offset || size < 8) return null;
        return {
          boxtype: String.fromCharCode.apply(null, data.slice(offset + 4, offset + 8)),
          data: data.slice(offset + 8, offset + size),
          end: offset + size
        };
      }
      module.exports.unbox = unbox;
      function scan_ipco(data, sandbox) {
        var offset = 0;
        for (; ; ) {
          var box = unbox(data, offset);
          if (!box) break;
          switch (box.boxtype) {
            case "ispe":
              sandbox.sizes.push({
                width: readUInt32BE(box.data, 4),
                height: readUInt32BE(box.data, 8)
              });
              break;
            case "irot":
              sandbox.transforms.push({
                type: "irot",
                value: box.data[0] & 3
              });
              break;
            case "imir":
              sandbox.transforms.push({
                type: "imir",
                value: box.data[0] & 1
              });
              break;
          }
          offset = box.end;
        }
      }
      function readUIntBE(data, offset, size) {
        var result = 0;
        for (var i = 0; i < size; i++) {
          result = result * 256 + (data[offset + i] || 0);
        }
        return result;
      }
      function scan_iloc(data, sandbox) {
        var offset_size = data[4] >> 4 & 15;
        var length_size = data[4] & 15;
        var base_offset_size = data[5] >> 4 & 15;
        var item_count = readUInt16BE(data, 6);
        var offset = 8;
        for (var i = 0; i < item_count; i++) {
          var item_ID = readUInt16BE(data, offset);
          offset += 2;
          var data_reference_index = readUInt16BE(data, offset);
          offset += 2;
          var base_offset = readUIntBE(data, offset, base_offset_size);
          offset += base_offset_size;
          var extent_count = readUInt16BE(data, offset);
          offset += 2;
          if (data_reference_index === 0 && extent_count === 1) {
            var first_extent_offset = readUIntBE(data, offset, offset_size);
            var first_extent_length = readUIntBE(data, offset + offset_size, length_size);
            sandbox.item_loc[item_ID] = { length: first_extent_length, offset: first_extent_offset + base_offset };
          }
          offset += extent_count * (offset_size + length_size);
        }
      }
      function scan_iinf(data, sandbox) {
        var item_count = readUInt16BE(data, 4);
        var offset = 6;
        for (var i = 0; i < item_count; i++) {
          var box = unbox(data, offset);
          if (!box) break;
          if (box.boxtype === "infe") {
            var item_id = readUInt16BE(box.data, 4);
            var item_name = "";
            for (var pos = 8; pos < box.data.length && box.data[pos]; pos++) {
              item_name += String.fromCharCode(box.data[pos]);
            }
            sandbox.item_inf[item_name] = item_id;
          }
          offset = box.end;
        }
      }
      function scan_iprp(data, sandbox) {
        var offset = 0;
        for (; ; ) {
          var box = unbox(data, offset);
          if (!box) break;
          if (box.boxtype === "ipco") scan_ipco(box.data, sandbox);
          offset = box.end;
        }
      }
      function scan_meta(data, sandbox) {
        var offset = 4;
        for (; ; ) {
          var box = unbox(data, offset);
          if (!box) break;
          if (box.boxtype === "iprp") scan_iprp(box.data, sandbox);
          if (box.boxtype === "iloc") scan_iloc(box.data, sandbox);
          if (box.boxtype === "iinf") scan_iinf(box.data, sandbox);
          offset = box.end;
        }
      }
      function getMaxSize(sizes) {
        var maxWidthSize = sizes.reduce(function(a, b) {
          return a.width > b.width || a.width === b.width && a.height > b.height ? a : b;
        });
        var maxHeightSize = sizes.reduce(function(a, b) {
          return a.height > b.height || a.height === b.height && a.width > b.width ? a : b;
        });
        var maxSize;
        if (maxWidthSize.width > maxHeightSize.height || maxWidthSize.width === maxHeightSize.height && maxWidthSize.height > maxHeightSize.width) {
          maxSize = maxWidthSize;
        } else {
          maxSize = maxHeightSize;
        }
        return maxSize;
      }
      module.exports.readSizeFromMeta = function(data) {
        var sandbox = {
          sizes: [],
          transforms: [],
          item_inf: {},
          item_loc: {}
        };
        scan_meta(data, sandbox);
        if (!sandbox.sizes.length) return;
        var maxSize = getMaxSize(sandbox.sizes);
        var orientation = 1;
        sandbox.transforms.forEach(function(transform) {
          var rotate_ccw = { 1: 6, 2: 5, 3: 8, 4: 7, 5: 4, 6: 3, 7: 2, 8: 1 };
          var mirror_vert = { 1: 4, 2: 3, 3: 2, 4: 1, 5: 6, 6: 5, 7: 8, 8: 7 };
          if (transform.type === "imir") {
            if (transform.value === 0) {
              orientation = mirror_vert[orientation];
            } else {
              orientation = mirror_vert[orientation];
              orientation = rotate_ccw[orientation];
              orientation = rotate_ccw[orientation];
            }
          }
          if (transform.type === "irot") {
            for (var i = 0; i < transform.value; i++) {
              orientation = rotate_ccw[orientation];
            }
          }
        });
        var exif_location = null;
        if (sandbox.item_inf.Exif) {
          exif_location = sandbox.item_loc[sandbox.item_inf.Exif];
        }
        return {
          width: maxSize.width,
          height: maxSize.height,
          orientation: sandbox.transforms.length ? orientation : null,
          variants: sandbox.sizes,
          exif_location
        };
      };
      module.exports.getMimeType = function(data) {
        var brand = String.fromCharCode.apply(null, data.slice(0, 4));
        var compat = {};
        compat[brand] = true;
        for (var i = 8; i < data.length; i += 4) {
          compat[String.fromCharCode.apply(null, data.slice(i, i + 4))] = true;
        }
        if (!compat.mif1 && !compat.msf1 && !compat.miaf) return;
        if (brand === "avif" || brand === "avis" || brand === "avio") {
          return { type: "avif", mime: "image/avif" };
        }
        if (brand === "heic" || brand === "heix") {
          return { type: "heic", mime: "image/heic" };
        }
        if (brand === "hevc" || brand === "hevx") {
          return { type: "heic", mime: "image/heic-sequence" };
        }
        if (compat.avif || compat.avis) {
          return { type: "avif", mime: "image/avif" };
        }
        if (compat.heic || compat.heix || compat.hevc || compat.hevx || compat.heis) {
          if (compat.msf1) {
            return { type: "heif", mime: "image/heif-sequence" };
          }
          return { type: "heif", mime: "image/heif" };
        }
        return { type: "avif", mime: "image/avif" };
      };
    }
  });

  // node_modules/probe-image-size/lib/exif_utils.js
  var require_exif_utils = __commonJS({
    "node_modules/probe-image-size/lib/exif_utils.js"(exports, module) {
      "use strict";
      function error(message, code) {
        var err = new Error(message);
        err.code = code;
        return err;
      }
      function utf8_decode(str) {
        try {
          return decodeURIComponent(escape(str));
        } catch (_) {
          return str;
        }
      }
      function ExifParser(jpeg_bin, exif_start, exif_end) {
        this.input = jpeg_bin.subarray(exif_start, exif_end);
        this.start = exif_start;
        var sig = String.fromCharCode.apply(null, this.input.subarray(0, 4));
        if (sig !== "II*\0" && sig !== "MM\0*") {
          throw error("invalid TIFF signature", "EBADDATA");
        }
        this.big_endian = sig[0] === "M";
      }
      ExifParser.prototype.each = function(on_entry) {
        this.aborted = false;
        var offset = this.read_uint32(4);
        this.ifds_to_read = [{
          id: 0,
          offset
        }];
        while (this.ifds_to_read.length > 0 && !this.aborted) {
          var i = this.ifds_to_read.shift();
          if (!i.offset) continue;
          this.scan_ifd(i.id, i.offset, on_entry);
        }
      };
      ExifParser.prototype.read_uint16 = function(offset) {
        var d = this.input;
        if (offset + 2 > d.length) throw error("unexpected EOF", "EBADDATA");
        return this.big_endian ? d[offset] * 256 + d[offset + 1] : d[offset] + d[offset + 1] * 256;
      };
      ExifParser.prototype.read_uint32 = function(offset) {
        var d = this.input;
        if (offset + 4 > d.length) throw error("unexpected EOF", "EBADDATA");
        return this.big_endian ? d[offset] * 16777216 + d[offset + 1] * 65536 + d[offset + 2] * 256 + d[offset + 3] : d[offset] + d[offset + 1] * 256 + d[offset + 2] * 65536 + d[offset + 3] * 16777216;
      };
      ExifParser.prototype.is_subifd_link = function(ifd, tag) {
        return ifd === 0 && tag === 34665 || // SubIFD
        ifd === 0 && tag === 34853 || // GPS Info
        ifd === 34665 && tag === 40965;
      };
      ExifParser.prototype.exif_format_length = function(format) {
        switch (format) {
          case 1:
          // byte
          case 2:
          // ascii
          case 6:
          // sbyte
          case 7:
            return 1;
          case 3:
          // short
          case 8:
            return 2;
          case 4:
          // long
          case 9:
          // slong
          case 11:
            return 4;
          case 5:
          // rational
          case 10:
          // srational
          case 12:
            return 8;
          default:
            return 0;
        }
      };
      ExifParser.prototype.exif_format_read = function(format, offset) {
        var v;
        switch (format) {
          case 1:
          // byte
          case 2:
            v = this.input[offset];
            return v;
          case 6:
            v = this.input[offset];
            return v | (v & 128) * 33554430;
          case 3:
            v = this.read_uint16(offset);
            return v;
          case 8:
            v = this.read_uint16(offset);
            return v | (v & 32768) * 131070;
          case 4:
            v = this.read_uint32(offset);
            return v;
          case 9:
            v = this.read_uint32(offset);
            return v | 0;
          case 5:
          // rational
          case 10:
          // srational
          case 11:
          // float
          case 12:
            return null;
          // not implemented
          case 7:
            return null;
          // blob
          default:
            return null;
        }
      };
      ExifParser.prototype.scan_ifd = function(ifd_no, offset, on_entry) {
        var entry_count = this.read_uint16(offset);
        offset += 2;
        for (var i = 0; i < entry_count; i++) {
          var tag = this.read_uint16(offset);
          var format = this.read_uint16(offset + 2);
          var count = this.read_uint32(offset + 4);
          var comp_length = this.exif_format_length(format);
          var data_length = count * comp_length;
          var data_offset = data_length <= 4 ? offset + 8 : this.read_uint32(offset + 8);
          var is_subifd_link = false;
          if (data_offset + data_length > this.input.length) {
            throw error("unexpected EOF", "EBADDATA");
          }
          var value = [];
          var comp_offset = data_offset;
          for (var j = 0; j < count; j++, comp_offset += comp_length) {
            var item = this.exif_format_read(format, comp_offset);
            if (item === null) {
              value = null;
              break;
            }
            value.push(item);
          }
          if (Array.isArray(value) && format === 2) {
            value = utf8_decode(String.fromCharCode.apply(null, value));
            if (value && value[value.length - 1] === "\0") value = value.slice(0, -1);
          }
          if (this.is_subifd_link(ifd_no, tag)) {
            if (Array.isArray(value) && Number.isInteger(value[0]) && value[0] > 0) {
              this.ifds_to_read.push({
                id: tag,
                offset: value[0]
              });
              is_subifd_link = true;
            }
          }
          var entry = {
            is_big_endian: this.big_endian,
            ifd: ifd_no,
            tag,
            format,
            count,
            entry_offset: offset + this.start,
            data_length,
            data_offset: data_offset + this.start,
            value,
            is_subifd_link
          };
          if (on_entry(entry) === false) {
            this.aborted = true;
            return;
          }
          offset += 12;
        }
        if (ifd_no === 0) {
          this.ifds_to_read.push({
            id: 1,
            offset: this.read_uint32(offset)
          });
        }
      };
      module.exports.ExifParser = ExifParser;
      module.exports.get_orientation = function(data) {
        var orientation = 0;
        try {
          new ExifParser(data, 0, data.length).each(function(entry) {
            if (entry.ifd === 0 && entry.tag === 274 && Array.isArray(entry.value)) {
              orientation = entry.value[0];
              return false;
            }
          });
          return orientation;
        } catch (err) {
          return -1;
        }
      };
    }
  });

  // node_modules/probe-image-size/lib/parse_sync/avif.js
  var require_avif = __commonJS({
    "node_modules/probe-image-size/lib/parse_sync/avif.js"(exports, module) {
      "use strict";
      var str2arr = require_common().str2arr;
      var sliceEq = require_common().sliceEq;
      var readUInt32BE = require_common().readUInt32BE;
      var miaf = require_miaf_utils();
      var exif = require_exif_utils();
      var SIG_FTYP = str2arr("ftyp");
      module.exports = function(data) {
        if (!sliceEq(data, 4, SIG_FTYP)) return;
        var firstBox = miaf.unbox(data, 0);
        if (!firstBox) return;
        var fileType = miaf.getMimeType(firstBox.data);
        if (!fileType) return;
        var meta, offset = firstBox.end;
        for (; ; ) {
          var box = miaf.unbox(data, offset);
          if (!box) break;
          offset = box.end;
          if (box.boxtype === "mdat") return;
          if (box.boxtype === "meta") {
            meta = box.data;
            break;
          }
        }
        if (!meta) return;
        var imgSize = miaf.readSizeFromMeta(meta);
        if (!imgSize) return;
        var result = {
          width: imgSize.width,
          height: imgSize.height,
          type: fileType.type,
          mime: fileType.mime,
          wUnits: "px",
          hUnits: "px"
        };
        if (imgSize.variants.length > 1) {
          result.variants = imgSize.variants;
        }
        if (imgSize.orientation) {
          result.orientation = imgSize.orientation;
        }
        if (imgSize.exif_location && imgSize.exif_location.offset + imgSize.exif_location.length <= data.length) {
          var sig_offset = readUInt32BE(data, imgSize.exif_location.offset);
          var exif_data = data.slice(
            imgSize.exif_location.offset + sig_offset + 4,
            imgSize.exif_location.offset + imgSize.exif_location.length
          );
          var orientation = exif.get_orientation(exif_data);
          if (orientation > 0) result.orientation = orientation;
        }
        return result;
      };
    }
  });

  // node_modules/probe-image-size/lib/parse_sync/bmp.js
  var require_bmp = __commonJS({
    "node_modules/probe-image-size/lib/parse_sync/bmp.js"(exports, module) {
      "use strict";
      var str2arr = require_common().str2arr;
      var sliceEq = require_common().sliceEq;
      var readUInt16LE = require_common().readUInt16LE;
      var SIG_BM = str2arr("BM");
      module.exports = function(data) {
        if (data.length < 26) return;
        if (!sliceEq(data, 0, SIG_BM)) return;
        return {
          width: readUInt16LE(data, 18),
          height: readUInt16LE(data, 22),
          type: "bmp",
          mime: "image/bmp",
          wUnits: "px",
          hUnits: "px"
        };
      };
    }
  });

  // node_modules/probe-image-size/lib/parse_sync/gif.js
  var require_gif = __commonJS({
    "node_modules/probe-image-size/lib/parse_sync/gif.js"(exports, module) {
      "use strict";
      var str2arr = require_common().str2arr;
      var sliceEq = require_common().sliceEq;
      var readUInt16LE = require_common().readUInt16LE;
      var SIG_GIF87a = str2arr("GIF87a");
      var SIG_GIF89a = str2arr("GIF89a");
      module.exports = function(data) {
        if (data.length < 10) return;
        if (!sliceEq(data, 0, SIG_GIF87a) && !sliceEq(data, 0, SIG_GIF89a)) return;
        return {
          width: readUInt16LE(data, 6),
          height: readUInt16LE(data, 8),
          type: "gif",
          mime: "image/gif",
          wUnits: "px",
          hUnits: "px"
        };
      };
    }
  });

  // node_modules/probe-image-size/lib/parse_sync/ico.js
  var require_ico = __commonJS({
    "node_modules/probe-image-size/lib/parse_sync/ico.js"(exports, module) {
      "use strict";
      var readUInt16LE = require_common().readUInt16LE;
      var HEADER = 0;
      var TYPE_ICO = 1;
      var INDEX_SIZE = 16;
      module.exports = function(data) {
        var header = readUInt16LE(data, 0);
        var type = readUInt16LE(data, 2);
        var numImages = readUInt16LE(data, 4);
        if (header !== HEADER || type !== TYPE_ICO || !numImages) {
          return;
        }
        var variants = [];
        var maxSize = { width: 0, height: 0 };
        for (var i = 0; i < numImages; i++) {
          var width = data[6 + INDEX_SIZE * i] || 256;
          var height = data[6 + INDEX_SIZE * i + 1] || 256;
          var size = { width, height };
          variants.push(size);
          if (width > maxSize.width || height > maxSize.height) {
            maxSize = size;
          }
        }
        return {
          width: maxSize.width,
          height: maxSize.height,
          variants,
          type: "ico",
          mime: "image/x-icon",
          wUnits: "px",
          hUnits: "px"
        };
      };
    }
  });

  // node_modules/probe-image-size/lib/parse_sync/jpeg.js
  var require_jpeg = __commonJS({
    "node_modules/probe-image-size/lib/parse_sync/jpeg.js"(exports, module) {
      "use strict";
      var readUInt16BE = require_common().readUInt16BE;
      var str2arr = require_common().str2arr;
      var sliceEq = require_common().sliceEq;
      var exif = require_exif_utils();
      var SIG_EXIF = str2arr("Exif\0\0");
      module.exports = function(data) {
        if (data.length < 2) return;
        if (data[0] !== 255 || data[1] !== 216 || data[2] !== 255) return;
        var offset = 2;
        for (; ; ) {
          for (; ; ) {
            if (data.length - offset < 2) return;
            if (data[offset++] === 255) break;
          }
          var code = data[offset++];
          var length;
          while (code === 255) code = data[offset++];
          if (208 <= code && code <= 217 || code === 1) {
            length = 0;
          } else if (192 <= code && code <= 254) {
            if (data.length - offset < 2) return;
            length = readUInt16BE(data, offset) - 2;
            offset += 2;
          } else {
            return;
          }
          if (code === 217 || code === 218) {
            return;
          }
          var orientation;
          if (code === 225 && length >= 10 && sliceEq(data, offset, SIG_EXIF)) {
            orientation = exif.get_orientation(data.slice(offset + 6, offset + length));
          }
          if (length >= 5 && (192 <= code && code <= 207) && code !== 196 && code !== 200 && code !== 204) {
            if (data.length - offset < length) return;
            var result = {
              width: readUInt16BE(data, offset + 3),
              height: readUInt16BE(data, offset + 1),
              type: "jpg",
              mime: "image/jpeg",
              wUnits: "px",
              hUnits: "px"
            };
            if (orientation > 0) {
              result.orientation = orientation;
            }
            return result;
          }
          offset += length;
        }
      };
    }
  });

  // node_modules/probe-image-size/lib/parse_sync/png.js
  var require_png = __commonJS({
    "node_modules/probe-image-size/lib/parse_sync/png.js"(exports, module) {
      "use strict";
      var str2arr = require_common().str2arr;
      var sliceEq = require_common().sliceEq;
      var readUInt32BE = require_common().readUInt32BE;
      var SIG_PNG = str2arr("\x89PNG\r\n\n");
      var SIG_IHDR = str2arr("IHDR");
      module.exports = function(data) {
        if (data.length < 24) return;
        if (!sliceEq(data, 0, SIG_PNG)) return;
        if (!sliceEq(data, 12, SIG_IHDR)) return;
        return {
          width: readUInt32BE(data, 16),
          height: readUInt32BE(data, 20),
          type: "png",
          mime: "image/png",
          wUnits: "px",
          hUnits: "px"
        };
      };
    }
  });

  // node_modules/probe-image-size/lib/parse_sync/psd.js
  var require_psd = __commonJS({
    "node_modules/probe-image-size/lib/parse_sync/psd.js"(exports, module) {
      "use strict";
      var str2arr = require_common().str2arr;
      var sliceEq = require_common().sliceEq;
      var readUInt32BE = require_common().readUInt32BE;
      var SIG_8BPS = str2arr("8BPS\0");
      module.exports = function(data) {
        if (data.length < 6 + 16) return;
        if (!sliceEq(data, 0, SIG_8BPS)) return;
        return {
          width: readUInt32BE(data, 6 + 12),
          height: readUInt32BE(data, 6 + 8),
          type: "psd",
          mime: "image/vnd.adobe.photoshop",
          wUnits: "px",
          hUnits: "px"
        };
      };
    }
  });

  // node_modules/probe-image-size/lib/parse_sync/svg.js
  var require_svg = __commonJS({
    "node_modules/probe-image-size/lib/parse_sync/svg.js"(exports, module) {
      "use strict";
      function isWhiteSpace(chr) {
        return chr === 32 || chr === 9 || chr === 13 || chr === 10;
      }
      function isFinitePositive(val) {
        return typeof val === "number" && isFinite(val) && val > 0;
      }
      function canBeSvg(buf) {
        var i = 0, max = buf.length;
        if (buf[0] === 239 && buf[1] === 187 && buf[2] === 191) i = 3;
        while (i < max && isWhiteSpace(buf[i])) i++;
        if (i === max) return false;
        return buf[i] === 60;
      }
      var SVG_HEADER_RE = /<[-_.:a-zA-Z0-9][^>]*>/;
      var SVG_TAG_RE = /^<([-_.:a-zA-Z0-9]+:)?svg\s/;
      var SVG_WIDTH_RE = /[^-]\bwidth="([^%]+?)"|[^-]\bwidth='([^%]+?)'/;
      var SVG_HEIGHT_RE = /\bheight="([^%]+?)"|\bheight='([^%]+?)'/;
      var SVG_VIEWBOX_RE = /\bview[bB]ox="(.+?)"|\bview[bB]ox='(.+?)'/;
      var SVG_UNITS_RE = /in$|mm$|cm$|pt$|pc$|px$|em$|ex$/;
      function svgAttrs(str) {
        var width = str.match(SVG_WIDTH_RE);
        var height = str.match(SVG_HEIGHT_RE);
        var viewbox = str.match(SVG_VIEWBOX_RE);
        return {
          width: width && (width[1] || width[2]),
          height: height && (height[1] || height[2]),
          viewbox: viewbox && (viewbox[1] || viewbox[2])
        };
      }
      function units(str) {
        if (!SVG_UNITS_RE.test(str)) return "px";
        return str.match(SVG_UNITS_RE)[0];
      }
      module.exports = function(data) {
        if (!canBeSvg(data)) return;
        var str = "";
        for (var i = 0; i < data.length; i++) {
          str += String.fromCharCode(data[i]);
        }
        var svgTag = (str.match(SVG_HEADER_RE) || [""])[0];
        if (!SVG_TAG_RE.test(svgTag)) return;
        var attrs = svgAttrs(svgTag);
        var width = parseFloat(attrs.width);
        var height = parseFloat(attrs.height);
        if (attrs.width && attrs.height) {
          if (!isFinitePositive(width) || !isFinitePositive(height)) return;
          return {
            width,
            height,
            type: "svg",
            mime: "image/svg+xml",
            wUnits: units(attrs.width),
            hUnits: units(attrs.height)
          };
        }
        var parts = (attrs.viewbox || "").split(" ");
        var viewbox = {
          width: parts[2],
          height: parts[3]
        };
        var vbWidth = parseFloat(viewbox.width);
        var vbHeight = parseFloat(viewbox.height);
        if (!isFinitePositive(vbWidth) || !isFinitePositive(vbHeight)) return;
        if (units(viewbox.width) !== units(viewbox.height)) return;
        var ratio = vbWidth / vbHeight;
        if (attrs.width) {
          if (!isFinitePositive(width)) return;
          return {
            width,
            height: width / ratio,
            type: "svg",
            mime: "image/svg+xml",
            wUnits: units(attrs.width),
            hUnits: units(attrs.width)
          };
        }
        if (attrs.height) {
          if (!isFinitePositive(height)) return;
          return {
            width: height * ratio,
            height,
            type: "svg",
            mime: "image/svg+xml",
            wUnits: units(attrs.height),
            hUnits: units(attrs.height)
          };
        }
        return {
          width: vbWidth,
          height: vbHeight,
          type: "svg",
          mime: "image/svg+xml",
          wUnits: units(viewbox.width),
          hUnits: units(viewbox.height)
        };
      };
    }
  });

  // node_modules/probe-image-size/lib/parse_sync/tiff.js
  var require_tiff = __commonJS({
    "node_modules/probe-image-size/lib/parse_sync/tiff.js"(exports, module) {
      "use strict";
      var str2arr = require_common().str2arr;
      var sliceEq = require_common().sliceEq;
      var readUInt16LE = require_common().readUInt16LE;
      var readUInt16BE = require_common().readUInt16BE;
      var readUInt32LE = require_common().readUInt32LE;
      var readUInt32BE = require_common().readUInt32BE;
      var SIG_1 = str2arr("II*\0");
      var SIG_2 = str2arr("MM\0*");
      function readUInt16(buffer, offset, is_big_endian) {
        return is_big_endian ? readUInt16BE(buffer, offset) : readUInt16LE(buffer, offset);
      }
      function readUInt32(buffer, offset, is_big_endian) {
        return is_big_endian ? readUInt32BE(buffer, offset) : readUInt32LE(buffer, offset);
      }
      function readIFDValue(data, data_offset, is_big_endian) {
        var type = readUInt16(data, data_offset + 2, is_big_endian);
        var values = readUInt32(data, data_offset + 4, is_big_endian);
        if (values !== 1 || type !== 3 && type !== 4) return null;
        if (type === 3) {
          return readUInt16(data, data_offset + 8, is_big_endian);
        }
        return readUInt32(data, data_offset + 8, is_big_endian);
      }
      module.exports = function(data) {
        if (data.length < 8) return;
        if (!sliceEq(data, 0, SIG_1) && !sliceEq(data, 0, SIG_2)) return;
        var is_big_endian = data[0] === 77;
        var count = readUInt32(data, 4, is_big_endian) - 8;
        if (count < 0) return;
        var offset = count + 8;
        if (data.length - offset < 2) return;
        var ifd_size = readUInt16(data, offset + 0, is_big_endian) * 12;
        if (ifd_size <= 0) return;
        offset += 2;
        if (data.length - offset < ifd_size) return;
        var i, width, height, tag;
        for (i = 0; i < ifd_size; i += 12) {
          tag = readUInt16(data, offset + i, is_big_endian);
          if (tag === 256) {
            width = readIFDValue(data, offset + i, is_big_endian);
          } else if (tag === 257) {
            height = readIFDValue(data, offset + i, is_big_endian);
          }
        }
        if (width && height) {
          return {
            width,
            height,
            type: "tiff",
            mime: "image/tiff",
            wUnits: "px",
            hUnits: "px"
          };
        }
      };
    }
  });

  // node_modules/probe-image-size/lib/parse_sync/webp.js
  var require_webp = __commonJS({
    "node_modules/probe-image-size/lib/parse_sync/webp.js"(exports, module) {
      "use strict";
      var str2arr = require_common().str2arr;
      var sliceEq = require_common().sliceEq;
      var readUInt16LE = require_common().readUInt16LE;
      var readUInt32LE = require_common().readUInt32LE;
      var exif = require_exif_utils();
      var SIG_RIFF = str2arr("RIFF");
      var SIG_WEBP = str2arr("WEBP");
      function parseVP8(data, offset) {
        if (data[offset + 3] !== 157 || data[offset + 4] !== 1 || data[offset + 5] !== 42) {
          return;
        }
        return {
          width: readUInt16LE(data, offset + 6) & 16383,
          height: readUInt16LE(data, offset + 8) & 16383,
          type: "webp",
          mime: "image/webp",
          wUnits: "px",
          hUnits: "px"
        };
      }
      function parseVP8L(data, offset) {
        if (data[offset] !== 47) return;
        var bits = readUInt32LE(data, offset + 1);
        return {
          width: (bits & 16383) + 1,
          height: (bits >> 14 & 16383) + 1,
          type: "webp",
          mime: "image/webp",
          wUnits: "px",
          hUnits: "px"
        };
      }
      function parseVP8X(data, offset) {
        return {
          // TODO: replace with `data.readUIntLE(8, 3) + 1`
          //       when 0.10 support is dropped
          width: (data[offset + 6] << 16 | data[offset + 5] << 8 | data[offset + 4]) + 1,
          height: (data[offset + 9] << offset | data[offset + 8] << 8 | data[offset + 7]) + 1,
          type: "webp",
          mime: "image/webp",
          wUnits: "px",
          hUnits: "px"
        };
      }
      module.exports = function(data) {
        if (data.length < 16) return;
        if (!sliceEq(data, 0, SIG_RIFF) && !sliceEq(data, 8, SIG_WEBP)) return;
        var offset = 12;
        var result = null;
        var exif_orientation = 0;
        var fileLength = readUInt32LE(data, 4) + 8;
        if (fileLength > data.length) return;
        while (offset + 8 < fileLength) {
          if (data[offset] === 0) {
            offset++;
            continue;
          }
          var header = String.fromCharCode.apply(null, data.slice(offset, offset + 4));
          var length = readUInt32LE(data, offset + 4);
          if (header === "VP8 " && length >= 10) {
            result = result || parseVP8(data, offset + 8);
          } else if (header === "VP8L" && length >= 9) {
            result = result || parseVP8L(data, offset + 8);
          } else if (header === "VP8X" && length >= 10) {
            result = result || parseVP8X(data, offset + 8);
          } else if (header === "EXIF") {
            exif_orientation = exif.get_orientation(data.slice(offset + 8, offset + 8 + length));
            offset = Infinity;
          }
          offset += 8 + length;
        }
        if (!result) return;
        if (exif_orientation > 0) {
          result.orientation = exif_orientation;
        }
        return result;
      };
    }
  });

  // node_modules/probe-image-size/lib/parsers_sync.js
  var require_parsers_sync = __commonJS({
    "node_modules/probe-image-size/lib/parsers_sync.js"(exports, module) {
      "use strict";
      module.exports = {
        avif: require_avif(),
        bmp: require_bmp(),
        gif: require_gif(),
        ico: require_ico(),
        jpeg: require_jpeg(),
        png: require_png(),
        psd: require_psd(),
        svg: require_svg(),
        tiff: require_tiff(),
        webp: require_webp()
      };
    }
  });

  // node_modules/probe-image-size/sync.js
  var require_sync = __commonJS({
    "node_modules/probe-image-size/sync.js"(exports, module) {
      "use strict";
      var parsers = require_parsers_sync();
      function probeBuffer(buffer) {
        var parser_names = Object.keys(parsers);
        for (var i = 0; i < parser_names.length; i++) {
          var result = parsers[parser_names[i]](buffer);
          if (result) return result;
        }
        return null;
      }
      module.exports = function get_image_size(src) {
        return probeBuffer(src);
      };
      module.exports.parsers = parsers;
    }
  });

  // src/traces/image/helpers.js
  var require_helpers14 = __commonJS({
    "src/traces/image/helpers.js"(exports) {
      "use strict";
      var probeSync = require_sync();
      var dataUri = require_helpers10().IMAGE_URL_PREFIX;
      var Buffer2 = require_buffer().Buffer;
      exports.getImageSize = function(src) {
        var data = src.replace(dataUri, "");
        var buff = new Buffer2(data, "base64");
        return probeSync(buff);
      };
    }
  });

  // src/traces/image/calc.js
  var require_calc13 = __commonJS({
    "src/traces/image/calc.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var constants = require_constants17();
      var isNumeric = require_fast_isnumeric();
      var Axes = require_axes();
      var maxRowLength = require_lib().maxRowLength;
      var getImageSize = require_helpers14().getImageSize;
      module.exports = function calc(gd, trace) {
        var h;
        var w;
        if (trace._hasZ) {
          h = trace.z.length;
          w = maxRowLength(trace.z);
        } else if (trace._hasSource) {
          var size = getImageSize(trace.source);
          h = size.height;
          w = size.width;
        }
        var xa = Axes.getFromId(gd, trace.xaxis || "x");
        var ya = Axes.getFromId(gd, trace.yaxis || "y");
        var x0 = xa.d2c(trace.x0) - trace.dx / 2;
        var y0 = ya.d2c(trace.y0) - trace.dy / 2;
        var i;
        var xrange = [x0, x0 + w * trace.dx];
        var yrange = [y0, y0 + h * trace.dy];
        if (xa && xa.type === "log") for (i = 0; i < w; i++) xrange.push(x0 + i * trace.dx);
        if (ya && ya.type === "log") for (i = 0; i < h; i++) yrange.push(y0 + i * trace.dy);
        trace._extremes[xa._id] = Axes.findExtremes(xa, xrange);
        trace._extremes[ya._id] = Axes.findExtremes(ya, yrange);
        trace._scaler = makeScaler(trace);
        var cd0 = {
          x0,
          y0,
          z: trace.z,
          w,
          h
        };
        return [cd0];
      };
      function scale(zero, ratio, min, max) {
        return function(c) {
          return Lib.constrain((c - zero) * ratio, min, max);
        };
      }
      function constrain(min, max) {
        return function(c) {
          return Lib.constrain(c, min, max);
        };
      }
      function makeScaler(trace) {
        var cr = constants.colormodel[trace.colormodel];
        var colormodel = cr.colormodel || trace.colormodel;
        var n = colormodel.length;
        trace._sArray = [];
        for (var k = 0; k < n; k++) {
          if (cr.min[k] !== trace.zmin[k] || cr.max[k] !== trace.zmax[k]) {
            trace._sArray.push(scale(
              trace.zmin[k],
              (cr.max[k] - cr.min[k]) / (trace.zmax[k] - trace.zmin[k]),
              cr.min[k],
              cr.max[k]
            ));
          } else {
            trace._sArray.push(constrain(cr.min[k], cr.max[k]));
          }
        }
        return function(pixel) {
          var c = pixel.slice(0, n);
          for (var k2 = 0; k2 < n; k2++) {
            var ck = c[k2];
            if (!isNumeric(ck)) return false;
            c[k2] = trace._sArray[k2](ck);
          }
          return c;
        };
      }
    }
  });

  // src/traces/image/plot.js
  var require_plot9 = __commonJS({
    "src/traces/image/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var xmlnsNamespaces = require_xmlns_namespaces();
      var constants = require_constants17();
      var supportsPixelatedImage = require_supports_pixelated_image();
      var PIXELATED_IMAGE_STYLE = require_pixelated_image().STYLE;
      module.exports = function plot(gd, plotinfo, cdimage, imageLayer) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var supportsPixelated = !gd._context._exportedPlot && supportsPixelatedImage();
        Lib.makeTraceGroups(imageLayer, cdimage, "im").each(function(cd) {
          var plotGroup = d3.select(this);
          var cd0 = cd[0];
          var trace = cd0.trace;
          var realImage = (trace.zsmooth === "fast" || trace.zsmooth === false && supportsPixelated) && !trace._hasZ && trace._hasSource && xa.type === "linear" && ya.type === "linear";
          trace._realImage = realImage;
          var z = cd0.z;
          var x0 = cd0.x0;
          var y0 = cd0.y0;
          var w = cd0.w;
          var h = cd0.h;
          var dx = trace.dx;
          var dy = trace.dy;
          var left, right, temp, top, bottom, i;
          i = 0;
          while (left === void 0 && i < w) {
            left = xa.c2p(x0 + i * dx);
            i++;
          }
          i = w;
          while (right === void 0 && i > 0) {
            right = xa.c2p(x0 + i * dx);
            i--;
          }
          i = 0;
          while (top === void 0 && i < h) {
            top = ya.c2p(y0 + i * dy);
            i++;
          }
          i = h;
          while (bottom === void 0 && i > 0) {
            bottom = ya.c2p(y0 + i * dy);
            i--;
          }
          if (right < left) {
            temp = right;
            right = left;
            left = temp;
          }
          if (bottom < top) {
            temp = top;
            top = bottom;
            bottom = temp;
          }
          if (!realImage) {
            var extra = 0.5;
            left = Math.max(-extra * xa._length, left);
            right = Math.min((1 + extra) * xa._length, right);
            top = Math.max(-extra * ya._length, top);
            bottom = Math.min((1 + extra) * ya._length, bottom);
          }
          var imageWidth = Math.round(right - left);
          var imageHeight = Math.round(bottom - top);
          var isOffScreen = imageWidth <= 0 || imageHeight <= 0;
          if (isOffScreen) {
            var noImage = plotGroup.selectAll("image").data([]);
            noImage.exit().remove();
            return;
          }
          function drawMagnifiedPixelsOnCanvas(readPixel) {
            var canvas = document.createElement("canvas");
            canvas.width = imageWidth;
            canvas.height = imageHeight;
            var context = canvas.getContext("2d", { willReadFrequently: true });
            var ipx = function(i2) {
              return Lib.constrain(Math.round(xa.c2p(x0 + i2 * dx) - left), 0, imageWidth);
            };
            var jpx = function(j2) {
              return Lib.constrain(Math.round(ya.c2p(y0 + j2 * dy) - top), 0, imageHeight);
            };
            var cr = constants.colormodel[trace.colormodel];
            var colormodel = cr.colormodel || trace.colormodel;
            var fmt = cr.fmt;
            var c;
            for (i = 0; i < cd0.w; i++) {
              var ipx0 = ipx(i);
              var ipx1 = ipx(i + 1);
              if (ipx1 === ipx0 || isNaN(ipx1) || isNaN(ipx0)) continue;
              for (var j = 0; j < cd0.h; j++) {
                var jpx0 = jpx(j);
                var jpx1 = jpx(j + 1);
                if (jpx1 === jpx0 || isNaN(jpx1) || isNaN(jpx0) || !readPixel(i, j)) continue;
                c = trace._scaler(readPixel(i, j));
                if (c) {
                  context.fillStyle = colormodel + "(" + fmt(c).join(",") + ")";
                } else {
                  context.fillStyle = "rgba(0,0,0,0)";
                }
                context.fillRect(ipx0, jpx0, ipx1 - ipx0, jpx1 - jpx0);
              }
            }
            return canvas;
          }
          var image3 = plotGroup.selectAll("image").data([cd]);
          image3.enter().append("svg:image").attr({
            xmlns: xmlnsNamespaces.svg,
            preserveAspectRatio: "none"
          });
          image3.exit().remove();
          var style = trace.zsmooth === false ? PIXELATED_IMAGE_STYLE : "";
          if (realImage) {
            var xRange = Lib.simpleMap(xa.range, xa.r2l);
            var yRange = Lib.simpleMap(ya.range, ya.r2l);
            var flipX = xRange[1] < xRange[0];
            var flipY = yRange[1] > yRange[0];
            if (flipX || flipY) {
              var tx = left + imageWidth / 2;
              var ty = top + imageHeight / 2;
              style += "transform:" + strTranslate(tx + "px", ty + "px") + "scale(" + (flipX ? -1 : 1) + "," + (flipY ? -1 : 1) + ")" + strTranslate(-tx + "px", -ty + "px") + ";";
            }
          }
          image3.attr("style", style);
          var p = new Promise(function(resolve) {
            if (trace._hasZ) {
              resolve();
            } else if (trace._hasSource) {
              if (trace._canvas && trace._canvas.el.width === w && trace._canvas.el.height === h && trace._canvas.source === trace.source) {
                resolve();
              } else {
                var canvas = document.createElement("canvas");
                canvas.width = w;
                canvas.height = h;
                var context = canvas.getContext("2d", { willReadFrequently: true });
                trace._image = trace._image || new Image();
                var image = trace._image;
                image.onload = function() {
                  context.drawImage(image, 0, 0);
                  trace._canvas = {
                    el: canvas,
                    source: trace.source
                  };
                  resolve();
                };
                image.setAttribute("src", trace.source);
              }
            }
          }).then(function() {
            var href, canvas;
            if (trace._hasZ) {
              canvas = drawMagnifiedPixelsOnCanvas(function(i2, j) {
                var _z = z[j][i2];
                if (Lib.isTypedArray(_z)) _z = Array.from(_z);
                return _z;
              });
              href = canvas.toDataURL("image/png");
            } else if (trace._hasSource) {
              if (realImage) {
                href = trace.source;
              } else {
                var context = trace._canvas.el.getContext("2d", { willReadFrequently: true });
                var data = context.getImageData(0, 0, w, h).data;
                canvas = drawMagnifiedPixelsOnCanvas(function(i2, j) {
                  var index = 4 * (j * w + i2);
                  return [
                    data[index],
                    data[index + 1],
                    data[index + 2],
                    data[index + 3]
                  ];
                });
                href = canvas.toDataURL("image/png");
              }
            }
            image3.attr({
              "xlink:href": href,
              height: imageHeight,
              width: imageWidth,
              x: left,
              y: top
            });
          });
          gd._promises.push(p);
        });
      };
    }
  });

  // src/traces/image/style.js
  var require_style9 = __commonJS({
    "src/traces/image/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      module.exports = function style(gd) {
        d3.select(gd).selectAll(".im image").style("opacity", function(d) {
          return d[0].trace.opacity;
        });
      };
    }
  });

  // src/traces/image/hover.js
  var require_hover11 = __commonJS({
    "src/traces/image/hover.js"(exports, module) {
      "use strict";
      var Fx = require_fx();
      var Lib = require_lib();
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var constants = require_constants17();
      module.exports = function hoverPoints(pointData, xval, yval) {
        var cd0 = pointData.cd[0];
        var trace = cd0.trace;
        var xa = pointData.xa;
        var ya = pointData.ya;
        if (Fx.inbox(xval - cd0.x0, xval - (cd0.x0 + cd0.w * trace.dx), 0) > 0 || Fx.inbox(yval - cd0.y0, yval - (cd0.y0 + cd0.h * trace.dy), 0) > 0) {
          return;
        }
        var nx = Math.floor((xval - cd0.x0) / trace.dx);
        var ny = Math.floor(Math.abs(yval - cd0.y0) / trace.dy);
        var pixel;
        if (trace._hasZ) {
          pixel = cd0.z[ny][nx];
        } else if (trace._hasSource) {
          pixel = trace._canvas.el.getContext("2d", { willReadFrequently: true }).getImageData(nx, ny, 1, 1).data;
        }
        if (!pixel) return;
        var hoverinfo = cd0.hi || trace.hoverinfo;
        var fmtColor;
        if (hoverinfo) {
          var parts = hoverinfo.split("+");
          if (parts.indexOf("all") !== -1) parts = ["color"];
          if (parts.indexOf("color") !== -1) fmtColor = true;
        }
        var cr = constants.colormodel[trace.colormodel];
        var colormodel = cr.colormodel || trace.colormodel;
        var dims = colormodel.length;
        var c = trace._scaler(pixel);
        var s = cr.suffix;
        var colorstring = [];
        if (trace.hovertemplate || fmtColor) {
          colorstring.push("[" + [c[0] + s[0], c[1] + s[1], c[2] + s[2]].join(", "));
          if (dims === 4) colorstring.push(", " + c[3] + s[3]);
          colorstring.push("]");
          colorstring = colorstring.join("");
          pointData.extraText = colormodel.toUpperCase() + ": " + colorstring;
        }
        var text;
        if (isArrayOrTypedArray(trace.hovertext) && isArrayOrTypedArray(trace.hovertext[ny])) {
          text = trace.hovertext[ny][nx];
        } else if (isArrayOrTypedArray(trace.text) && isArrayOrTypedArray(trace.text[ny])) {
          text = trace.text[ny][nx];
        }
        var py = ya.c2p(cd0.y0 + (ny + 0.5) * trace.dy);
        var xVal = cd0.x0 + (nx + 0.5) * trace.dx;
        var yVal = cd0.y0 + (ny + 0.5) * trace.dy;
        var zLabel = "[" + pixel.slice(0, trace.colormodel.length).join(", ") + "]";
        return [Lib.extendFlat(pointData, {
          index: [ny, nx],
          x0: xa.c2p(cd0.x0 + nx * trace.dx),
          x1: xa.c2p(cd0.x0 + (nx + 1) * trace.dx),
          y0: py,
          y1: py,
          color: c,
          xVal,
          xLabelVal: xVal,
          yVal,
          yLabelVal: yVal,
          zLabelVal: zLabel,
          text,
          hovertemplateLabels: {
            zLabel,
            colorLabel: colorstring,
            "color[0]Label": c[0] + s[0],
            "color[1]Label": c[1] + s[1],
            "color[2]Label": c[2] + s[2],
            "color[3]Label": c[3] + s[3]
          }
        })];
      };
    }
  });

  // src/traces/image/event_data.js
  var require_event_data5 = __commonJS({
    "src/traces/image/event_data.js"(exports, module) {
      "use strict";
      module.exports = function eventData(out, pt) {
        if ("xVal" in pt) out.x = pt.xVal;
        if ("yVal" in pt) out.y = pt.yVal;
        if (pt.xa) out.xaxis = pt.xa;
        if (pt.ya) out.yaxis = pt.ya;
        out.color = pt.color;
        out.colormodel = pt.trace.colormodel;
        if (!out.z) out.z = pt.color;
        return out;
      };
    }
  });

  // src/traces/image/index.js
  var require_image = __commonJS({
    "src/traces/image/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes32(),
        supplyDefaults: require_defaults28(),
        calc: require_calc13(),
        plot: require_plot9(),
        style: require_style9(),
        hoverPoints: require_hover11(),
        eventData: require_event_data5(),
        moduleType: "trace",
        name: "image",
        basePlotModule: require_cartesian(),
        categories: ["cartesian", "svg", "2dMap", "noSortingByValue"],
        animatable: false,
        meta: {}
      };
    }
  });

  // lib/image.js
  var require_image2 = __commonJS({
    "lib/image.js"(exports, module) {
      "use strict";
      module.exports = require_image();
    }
  });

  // src/traces/pie/attributes.js
  var require_attributes33 = __commonJS({
    "src/traces/pie/attributes.js"(exports, module) {
      "use strict";
      var baseAttrs = require_attributes2();
      var domainAttrs = require_domain().attributes;
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var texttemplateAttrs = require_template_attributes().texttemplateAttrs;
      var extendFlat = require_extend().extendFlat;
      var pattern = require_attributes4().pattern;
      var textFontAttrs = fontAttrs({
        editType: "plot",
        arrayOk: true,
        colorEditType: "plot"
      });
      module.exports = {
        labels: {
          valType: "data_array",
          editType: "calc"
        },
        // equivalent of x0 and dx, if label is missing
        label0: {
          valType: "number",
          dflt: 0,
          editType: "calc"
        },
        dlabel: {
          valType: "number",
          dflt: 1,
          editType: "calc"
        },
        values: {
          valType: "data_array",
          editType: "calc"
        },
        marker: {
          colors: {
            valType: "data_array",
            // TODO 'color_array' ?
            editType: "calc"
          },
          line: {
            color: {
              valType: "color",
              dflt: colorAttrs.defaultLine,
              arrayOk: true,
              editType: "style"
            },
            width: {
              valType: "number",
              min: 0,
              dflt: 0,
              arrayOk: true,
              editType: "style"
            },
            editType: "calc"
          },
          pattern,
          editType: "calc"
        },
        text: {
          valType: "data_array",
          editType: "plot"
        },
        hovertext: {
          valType: "string",
          dflt: "",
          arrayOk: true,
          editType: "style"
        },
        // 'see eg:'
        // 'https://www.e-education.psu.edu/natureofgeoinfo/sites/www.e-education.psu.edu.natureofgeoinfo/files/image/hisp_pies.gif',
        // '(this example involves a map too - may someday be a whole trace type',
        // 'of its own. but the point is the size of the whole pie is important.)'
        scalegroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        // labels (legend is handled by plots.attributes.showlegend and layout.hiddenlabels)
        textinfo: {
          valType: "flaglist",
          flags: ["label", "text", "value", "percent"],
          extras: ["none"],
          editType: "calc"
        },
        hoverinfo: extendFlat({}, baseAttrs.hoverinfo, {
          flags: ["label", "text", "value", "percent", "name"]
        }),
        hovertemplate: hovertemplateAttrs({}, {
          keys: ["label", "color", "value", "percent", "text"]
        }),
        texttemplate: texttemplateAttrs({ editType: "plot" }, {
          keys: ["label", "color", "value", "percent", "text"]
        }),
        textposition: {
          valType: "enumerated",
          values: ["inside", "outside", "auto", "none"],
          dflt: "auto",
          arrayOk: true,
          editType: "plot"
        },
        textfont: extendFlat({}, textFontAttrs, {}),
        insidetextorientation: {
          valType: "enumerated",
          values: ["horizontal", "radial", "tangential", "auto"],
          dflt: "auto",
          editType: "plot"
        },
        insidetextfont: extendFlat({}, textFontAttrs, {}),
        outsidetextfont: extendFlat({}, textFontAttrs, {}),
        automargin: {
          valType: "boolean",
          dflt: false,
          editType: "plot"
        },
        title: {
          text: {
            valType: "string",
            dflt: "",
            editType: "plot"
          },
          font: extendFlat({}, textFontAttrs, {}),
          position: {
            valType: "enumerated",
            values: [
              "top left",
              "top center",
              "top right",
              "middle center",
              "bottom left",
              "bottom center",
              "bottom right"
            ],
            editType: "plot"
          },
          editType: "plot"
        },
        // position and shape
        domain: domainAttrs({ name: "pie", trace: true, editType: "calc" }),
        hole: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0,
          editType: "calc"
        },
        // ordering and direction
        sort: {
          valType: "boolean",
          dflt: true,
          editType: "calc"
        },
        direction: {
          /**
           * there are two common conventions, both of which place the first
           * (largest, if sorted) slice with its left edge at 12 o'clock but
           * succeeding slices follow either cw or ccw from there.
           *
           * see http://visage.co/data-visualization-101-pie-charts/
           */
          valType: "enumerated",
          values: ["clockwise", "counterclockwise"],
          dflt: "counterclockwise",
          editType: "calc"
        },
        rotation: {
          valType: "angle",
          dflt: 0,
          editType: "calc"
        },
        pull: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0,
          arrayOk: true,
          editType: "calc"
        }
      };
    }
  });

  // src/traces/pie/defaults.js
  var require_defaults29 = __commonJS({
    "src/traces/pie/defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var attributes = require_attributes33();
      var handleDomainDefaults = require_domain().defaults;
      var handleText = require_defaults19().handleText;
      var coercePattern = require_lib().coercePattern;
      function handleLabelsAndValues(labels, values) {
        var hasLabels = Lib.isArrayOrTypedArray(labels);
        var hasValues = Lib.isArrayOrTypedArray(values);
        var len = Math.min(
          hasLabels ? labels.length : Infinity,
          hasValues ? values.length : Infinity
        );
        if (!isFinite(len)) len = 0;
        if (len && hasValues) {
          var hasPositive;
          for (var i = 0; i < len; i++) {
            var v = values[i];
            if (isNumeric(v) && v > 0) {
              hasPositive = true;
              break;
            }
          }
          if (!hasPositive) len = 0;
        }
        return {
          hasLabels,
          hasValues,
          len
        };
      }
      function handleMarkerDefaults(traceIn, traceOut, layout, coerce, isPie) {
        var lineWidth = coerce("marker.line.width");
        if (lineWidth) {
          coerce(
            "marker.line.color",
            isPie ? void 0 : layout.paper_bgcolor
            // case of funnelarea, sunburst, icicle, treemap
          );
        }
        var markerColors = coerce("marker.colors");
        coercePattern(coerce, "marker.pattern", markerColors);
        if (traceIn.marker && !traceOut.marker.pattern.fgcolor) traceOut.marker.pattern.fgcolor = traceIn.marker.colors;
        if (!traceOut.marker.pattern.bgcolor) traceOut.marker.pattern.bgcolor = layout.paper_bgcolor;
      }
      function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var labels = coerce("labels");
        var values = coerce("values");
        var res = handleLabelsAndValues(labels, values);
        var len = res.len;
        traceOut._hasLabels = res.hasLabels;
        traceOut._hasValues = res.hasValues;
        if (!traceOut._hasLabels && traceOut._hasValues) {
          coerce("label0");
          coerce("dlabel");
        }
        if (!len) {
          traceOut.visible = false;
          return;
        }
        traceOut._length = len;
        handleMarkerDefaults(traceIn, traceOut, layout, coerce, true);
        coerce("scalegroup");
        var textData = coerce("text");
        var textTemplate = coerce("texttemplate");
        var textInfo;
        if (!textTemplate) textInfo = coerce("textinfo", Lib.isArrayOrTypedArray(textData) ? "text+percent" : "percent");
        coerce("hovertext");
        coerce("hovertemplate");
        if (textTemplate || textInfo && textInfo !== "none") {
          var textposition = coerce("textposition");
          handleText(traceIn, traceOut, layout, coerce, textposition, {
            moduleHasSelected: false,
            moduleHasUnselected: false,
            moduleHasConstrain: false,
            moduleHasCliponaxis: false,
            moduleHasTextangle: false,
            moduleHasInsideanchor: false
          });
          var hasBoth = Array.isArray(textposition) || textposition === "auto";
          var hasOutside = hasBoth || textposition === "outside";
          if (hasOutside) {
            coerce("automargin");
          }
          if (textposition === "inside" || textposition === "auto" || Array.isArray(textposition)) {
            coerce("insidetextorientation");
          }
        } else if (textInfo === "none") {
          coerce("textposition", "none");
        }
        handleDomainDefaults(traceOut, layout, coerce);
        var hole = coerce("hole");
        var title = coerce("title.text");
        if (title) {
          var titlePosition = coerce("title.position", hole ? "middle center" : "top center");
          if (!hole && titlePosition === "middle center") traceOut.title.position = "top center";
          Lib.coerceFont(coerce, "title.font", layout.font);
        }
        coerce("sort");
        coerce("direction");
        coerce("rotation");
        coerce("pull");
      }
      module.exports = {
        handleLabelsAndValues,
        handleMarkerDefaults,
        supplyDefaults
      };
    }
  });

  // src/traces/pie/layout_attributes.js
  var require_layout_attributes10 = __commonJS({
    "src/traces/pie/layout_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        hiddenlabels: {
          valType: "data_array",
          editType: "calc"
        },
        piecolorway: {
          valType: "colorlist",
          editType: "calc"
        },
        extendpiecolors: {
          valType: "boolean",
          dflt: true,
          editType: "calc"
        }
      };
    }
  });

  // src/traces/pie/layout_defaults.js
  var require_layout_defaults9 = __commonJS({
    "src/traces/pie/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes10();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        coerce("hiddenlabels");
        coerce("piecolorway", layoutOut.colorway);
        coerce("extendpiecolors");
      };
    }
  });

  // src/traces/pie/calc.js
  var require_calc14 = __commonJS({
    "src/traces/pie/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var Color = require_color();
      var extendedColorWayList = {};
      function calc(gd, trace) {
        var cd = [];
        var fullLayout = gd._fullLayout;
        var hiddenLabels = fullLayout.hiddenlabels || [];
        var labels = trace.labels;
        var colors = trace.marker.colors || [];
        var vals = trace.values;
        var len = trace._length;
        var hasValues = trace._hasValues && len;
        var i, pt;
        if (trace.dlabel) {
          labels = new Array(len);
          for (i = 0; i < len; i++) {
            labels[i] = String(trace.label0 + i * trace.dlabel);
          }
        }
        var allThisTraceLabels = {};
        var pullColor = makePullColorFn(fullLayout["_" + trace.type + "colormap"]);
        var vTotal = 0;
        var isAggregated = false;
        for (i = 0; i < len; i++) {
          var v, label, hidden;
          if (hasValues) {
            v = vals[i];
            if (!isNumeric(v)) continue;
            v = +v;
          } else v = 1;
          label = labels[i];
          if (label === void 0 || label === "") label = i;
          label = String(label);
          var thisLabelIndex = allThisTraceLabels[label];
          if (thisLabelIndex === void 0) {
            allThisTraceLabels[label] = cd.length;
            hidden = hiddenLabels.indexOf(label) !== -1;
            if (!hidden) vTotal += v;
            cd.push({
              v,
              label,
              color: pullColor(colors[i], label),
              i,
              pts: [i],
              hidden
            });
          } else {
            isAggregated = true;
            pt = cd[thisLabelIndex];
            pt.v += v;
            pt.pts.push(i);
            if (!pt.hidden) vTotal += v;
            if (pt.color === false && colors[i]) {
              pt.color = pullColor(colors[i], label);
            }
          }
        }
        cd = cd.filter(function(elem) {
          return elem.v >= 0;
        });
        var shouldSort = trace.type === "funnelarea" ? isAggregated : trace.sort;
        if (shouldSort) cd.sort(function(a, b) {
          return b.v - a.v;
        });
        if (cd[0]) cd[0].vTotal = vTotal;
        return cd;
      }
      function makePullColorFn(colorMap) {
        return function pullColor(color, id) {
          if (!color) return false;
          color = tinycolor(color);
          if (!color.isValid()) return false;
          color = Color.addOpacity(color, color.getAlpha());
          if (!colorMap[id]) colorMap[id] = color;
          return color;
        };
      }
      function crossTraceCalc(gd, plotinfo) {
        var desiredType = (plotinfo || {}).type;
        if (!desiredType) desiredType = "pie";
        var fullLayout = gd._fullLayout;
        var calcdata = gd.calcdata;
        var colorWay = fullLayout[desiredType + "colorway"];
        var colorMap = fullLayout["_" + desiredType + "colormap"];
        if (fullLayout["extend" + desiredType + "colors"]) {
          colorWay = generateExtendedColors(colorWay, extendedColorWayList);
        }
        var dfltColorCount = 0;
        for (var i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var traceType = cd[0].trace.type;
          if (traceType !== desiredType) continue;
          for (var j = 0; j < cd.length; j++) {
            var pt = cd[j];
            if (pt.color === false) {
              if (colorMap[pt.label]) {
                pt.color = colorMap[pt.label];
              } else {
                colorMap[pt.label] = pt.color = colorWay[dfltColorCount % colorWay.length];
                dfltColorCount++;
              }
            }
          }
        }
      }
      function generateExtendedColors(colorList, extendedColorWays) {
        var i;
        var colorString = JSON.stringify(colorList);
        var colors = extendedColorWays[colorString];
        if (!colors) {
          colors = colorList.slice();
          for (i = 0; i < colorList.length; i++) {
            colors.push(tinycolor(colorList[i]).lighten(20).toHexString());
          }
          for (i = 0; i < colorList.length; i++) {
            colors.push(tinycolor(colorList[i]).darken(20).toHexString());
          }
          extendedColorWays[colorString] = colors;
        }
        return colors;
      }
      module.exports = {
        calc,
        crossTraceCalc,
        makePullColorFn,
        generateExtendedColors
      };
    }
  });

  // src/traces/pie/event_data.js
  var require_event_data6 = __commonJS({
    "src/traces/pie/event_data.js"(exports, module) {
      "use strict";
      var appendArrayMultiPointValues = require_helpers2().appendArrayMultiPointValues;
      module.exports = function eventData(pt, trace) {
        var out = {
          curveNumber: trace.index,
          pointNumbers: pt.pts,
          data: trace._input,
          fullData: trace,
          label: pt.label,
          color: pt.color,
          value: pt.v,
          percent: pt.percent,
          text: pt.text,
          bbox: pt.bbox,
          // pt.v (and pt.i below) for backward compatibility
          v: pt.v
        };
        if (pt.pts.length === 1) out.pointNumber = out.i = pt.pts[0];
        appendArrayMultiPointValues(out, trace, pt.pts);
        if (trace.type === "funnelarea") {
          delete out.v;
          delete out.i;
        }
        return out;
      };
    }
  });

  // src/traces/pie/plot.js
  var require_plot10 = __commonJS({
    "src/traces/pie/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Plots = require_plots();
      var Fx = require_fx();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var strScale = Lib.strScale;
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var uniformText = require_uniform_text();
      var recordMinTextSize = uniformText.recordMinTextSize;
      var clearMinTextSize = uniformText.clearMinTextSize;
      var TEXTPAD = require_constants14().TEXTPAD;
      var helpers = require_helpers4();
      var eventData = require_event_data6();
      var isValidTextValue = require_lib().isValidTextValue;
      function plot(gd, cdModule) {
        var isStatic = gd._context.staticPlot;
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        clearMinTextSize("pie", fullLayout);
        prerenderTitles(cdModule, gd);
        layoutAreas(cdModule, gs);
        var plotGroups = Lib.makeTraceGroups(fullLayout._pielayer, cdModule, "trace").each(function(cd) {
          var plotGroup = d3.select(this);
          var cd0 = cd[0];
          var trace = cd0.trace;
          setCoords(cd);
          plotGroup.attr("stroke-linejoin", "round");
          plotGroup.each(function() {
            var slices = d3.select(this).selectAll("g.slice").data(cd);
            slices.enter().append("g").classed("slice", true);
            slices.exit().remove();
            var quadrants = [
              [[], []],
              // y<0: x<0, x>=0
              [[], []]
              // y>=0: x<0, x>=0
            ];
            var hasOutsideText = false;
            slices.each(function(pt, i) {
              if (pt.hidden) {
                d3.select(this).selectAll("path,g").remove();
                return;
              }
              pt.pointNumber = pt.i;
              pt.curveNumber = trace.index;
              quadrants[pt.pxmid[1] < 0 ? 0 : 1][pt.pxmid[0] < 0 ? 0 : 1].push(pt);
              var cx = cd0.cx;
              var cy = cd0.cy;
              var sliceTop = d3.select(this);
              var slicePath = sliceTop.selectAll("path.surface").data([pt]);
              slicePath.enter().append("path").classed("surface", true).style({ "pointer-events": isStatic ? "none" : "all" });
              sliceTop.call(attachFxHandlers, gd, cd);
              if (trace.pull) {
                var pull = +helpers.castOption(trace.pull, pt.pts) || 0;
                if (pull > 0) {
                  cx += pull * pt.pxmid[0];
                  cy += pull * pt.pxmid[1];
                }
              }
              pt.cxFinal = cx;
              pt.cyFinal = cy;
              function arc(start, finish, cw, scale) {
                var dx = scale * (finish[0] - start[0]);
                var dy = scale * (finish[1] - start[1]);
                return "a" + scale * cd0.r + "," + scale * cd0.r + " 0 " + pt.largeArc + (cw ? " 1 " : " 0 ") + dx + "," + dy;
              }
              var hole = trace.hole;
              if (pt.v === cd0.vTotal) {
                var outerCircle = "M" + (cx + pt.px0[0]) + "," + (cy + pt.px0[1]) + arc(pt.px0, pt.pxmid, true, 1) + arc(pt.pxmid, pt.px0, true, 1) + "Z";
                if (hole) {
                  slicePath.attr(
                    "d",
                    "M" + (cx + hole * pt.px0[0]) + "," + (cy + hole * pt.px0[1]) + arc(pt.px0, pt.pxmid, false, hole) + arc(pt.pxmid, pt.px0, false, hole) + "Z" + outerCircle
                  );
                } else slicePath.attr("d", outerCircle);
              } else {
                var outerArc = arc(pt.px0, pt.px1, true, 1);
                if (hole) {
                  var rim = 1 - hole;
                  slicePath.attr(
                    "d",
                    "M" + (cx + hole * pt.px1[0]) + "," + (cy + hole * pt.px1[1]) + arc(pt.px1, pt.px0, false, hole) + "l" + rim * pt.px0[0] + "," + rim * pt.px0[1] + outerArc + "Z"
                  );
                } else {
                  slicePath.attr(
                    "d",
                    "M" + cx + "," + cy + "l" + pt.px0[0] + "," + pt.px0[1] + outerArc + "Z"
                  );
                }
              }
              formatSliceLabel(gd, pt, cd0);
              var textPosition = helpers.castOption(trace.textposition, pt.pts);
              var sliceTextGroup = sliceTop.selectAll("g.slicetext").data(pt.text && textPosition !== "none" ? [0] : []);
              sliceTextGroup.enter().append("g").classed("slicetext", true);
              sliceTextGroup.exit().remove();
              sliceTextGroup.each(function() {
                var sliceText = Lib.ensureSingle(d3.select(this), "text", "", function(s) {
                  s.attr("data-notex", 1);
                });
                var font = Lib.ensureUniformFontSize(
                  gd,
                  textPosition === "outside" ? determineOutsideTextFont(trace, pt, fullLayout.font) : determineInsideTextFont(trace, pt, fullLayout.font)
                );
                sliceText.text(pt.text).attr({
                  class: "slicetext",
                  transform: "",
                  "text-anchor": "middle"
                }).call(Drawing.font, font).call(svgTextUtils.convertToTspans, gd);
                var textBB = Drawing.bBox(sliceText.node());
                var transform;
                if (textPosition === "outside") {
                  transform = transformOutsideText(textBB, pt);
                } else {
                  transform = transformInsideText(textBB, pt, cd0);
                  if (textPosition === "auto" && transform.scale < 1) {
                    var newFont = Lib.ensureUniformFontSize(gd, trace.outsidetextfont);
                    sliceText.call(Drawing.font, newFont);
                    textBB = Drawing.bBox(sliceText.node());
                    transform = transformOutsideText(textBB, pt);
                  }
                }
                var textPosAngle = transform.textPosAngle;
                var textXY = textPosAngle === void 0 ? pt.pxmid : getCoords(cd0.r, textPosAngle);
                transform.targetX = cx + textXY[0] * transform.rCenter + (transform.x || 0);
                transform.targetY = cy + textXY[1] * transform.rCenter + (transform.y || 0);
                computeTransform(transform, textBB);
                if (transform.outside) {
                  var targetY = transform.targetY;
                  pt.yLabelMin = targetY - textBB.height / 2;
                  pt.yLabelMid = targetY;
                  pt.yLabelMax = targetY + textBB.height / 2;
                  pt.labelExtraX = 0;
                  pt.labelExtraY = 0;
                  hasOutsideText = true;
                }
                transform.fontSize = font.size;
                recordMinTextSize(trace.type, transform, fullLayout);
                cd[i].transform = transform;
                Lib.setTransormAndDisplay(sliceText, transform);
              });
            });
            var titleTextGroup = d3.select(this).selectAll("g.titletext").data(trace.title.text ? [0] : []);
            titleTextGroup.enter().append("g").classed("titletext", true);
            titleTextGroup.exit().remove();
            titleTextGroup.each(function() {
              var titleText = Lib.ensureSingle(d3.select(this), "text", "", function(s) {
                s.attr("data-notex", 1);
              });
              var txt = trace.title.text;
              if (trace._meta) {
                txt = Lib.templateString(txt, trace._meta);
              }
              titleText.text(txt).attr({
                class: "titletext",
                transform: "",
                "text-anchor": "middle"
              }).call(Drawing.font, trace.title.font).call(svgTextUtils.convertToTspans, gd);
              var transform;
              if (trace.title.position === "middle center") {
                transform = positionTitleInside(cd0);
              } else {
                transform = positionTitleOutside(cd0, gs);
              }
              titleText.attr(
                "transform",
                strTranslate(transform.x, transform.y) + strScale(Math.min(1, transform.scale)) + strTranslate(transform.tx, transform.ty)
              );
            });
            if (hasOutsideText) scootLabels(quadrants, trace);
            plotTextLines(slices, trace);
            if (hasOutsideText && trace.automargin) {
              var traceBbox = Drawing.bBox(plotGroup.node());
              var domain = trace.domain;
              var vpw = gs.w * (domain.x[1] - domain.x[0]);
              var vph = gs.h * (domain.y[1] - domain.y[0]);
              var xgap = (0.5 * vpw - cd0.r) / gs.w;
              var ygap = (0.5 * vph - cd0.r) / gs.h;
              Plots.autoMargin(gd, "pie." + trace.uid + ".automargin", {
                xl: domain.x[0] - xgap,
                xr: domain.x[1] + xgap,
                yb: domain.y[0] - ygap,
                yt: domain.y[1] + ygap,
                l: Math.max(cd0.cx - cd0.r - traceBbox.left, 0),
                r: Math.max(traceBbox.right - (cd0.cx + cd0.r), 0),
                b: Math.max(traceBbox.bottom - (cd0.cy + cd0.r), 0),
                t: Math.max(cd0.cy - cd0.r - traceBbox.top, 0),
                pad: 5
              });
            }
          });
        });
        setTimeout(function() {
          plotGroups.selectAll("tspan").each(function() {
            var s = d3.select(this);
            if (s.attr("dy")) s.attr("dy", s.attr("dy"));
          });
        }, 0);
      }
      function plotTextLines(slices, trace) {
        slices.each(function(pt) {
          var sliceTop = d3.select(this);
          if (!pt.labelExtraX && !pt.labelExtraY) {
            sliceTop.select("path.textline").remove();
            return;
          }
          var sliceText = sliceTop.select("g.slicetext text");
          pt.transform.targetX += pt.labelExtraX;
          pt.transform.targetY += pt.labelExtraY;
          Lib.setTransormAndDisplay(sliceText, pt.transform);
          var lineStartX = pt.cxFinal + pt.pxmid[0];
          var lineStartY = pt.cyFinal + pt.pxmid[1];
          var textLinePath = "M" + lineStartX + "," + lineStartY;
          var finalX = (pt.yLabelMax - pt.yLabelMin) * (pt.pxmid[0] < 0 ? -1 : 1) / 4;
          if (pt.labelExtraX) {
            var yFromX = pt.labelExtraX * pt.pxmid[1] / pt.pxmid[0];
            var yNet = pt.yLabelMid + pt.labelExtraY - (pt.cyFinal + pt.pxmid[1]);
            if (Math.abs(yFromX) > Math.abs(yNet)) {
              textLinePath += "l" + yNet * pt.pxmid[0] / pt.pxmid[1] + "," + yNet + "H" + (lineStartX + pt.labelExtraX + finalX);
            } else {
              textLinePath += "l" + pt.labelExtraX + "," + yFromX + "v" + (yNet - yFromX) + "h" + finalX;
            }
          } else {
            textLinePath += "V" + (pt.yLabelMid + pt.labelExtraY) + "h" + finalX;
          }
          Lib.ensureSingle(sliceTop, "path", "textline").call(Color.stroke, trace.outsidetextfont.color).attr({
            "stroke-width": Math.min(2, trace.outsidetextfont.size / 8),
            d: textLinePath,
            fill: "none"
          });
        });
      }
      function attachFxHandlers(sliceTop, gd, cd) {
        var cd0 = cd[0];
        var cx = cd0.cx;
        var cy = cd0.cy;
        var trace = cd0.trace;
        var isFunnelArea = trace.type === "funnelarea";
        if (!("_hasHoverLabel" in trace)) trace._hasHoverLabel = false;
        if (!("_hasHoverEvent" in trace)) trace._hasHoverEvent = false;
        sliceTop.on("mouseover", function(pt) {
          var fullLayout2 = gd._fullLayout;
          var trace2 = gd._fullData[trace.index];
          if (gd._dragging || fullLayout2.hovermode === false) return;
          var hoverinfo = trace2.hoverinfo;
          if (Array.isArray(hoverinfo)) {
            hoverinfo = Fx.castHoverinfo({
              hoverinfo: [helpers.castOption(hoverinfo, pt.pts)],
              _module: trace._module
            }, fullLayout2, 0);
          }
          if (hoverinfo === "all") hoverinfo = "label+text+value+percent+name";
          if (trace2.hovertemplate || hoverinfo !== "none" && hoverinfo !== "skip" && hoverinfo) {
            var rInscribed = pt.rInscribed || 0;
            var hoverCenterX = cx + pt.pxmid[0] * (1 - rInscribed);
            var hoverCenterY = cy + pt.pxmid[1] * (1 - rInscribed);
            var separators = fullLayout2.separators;
            var text = [];
            if (hoverinfo && hoverinfo.indexOf("label") !== -1) text.push(pt.label);
            pt.text = helpers.castOption(trace2.hovertext || trace2.text, pt.pts);
            if (hoverinfo && hoverinfo.indexOf("text") !== -1) {
              var tx = pt.text;
              if (Lib.isValidTextValue(tx)) text.push(tx);
            }
            pt.value = pt.v;
            pt.valueLabel = helpers.formatPieValue(pt.v, separators);
            if (hoverinfo && hoverinfo.indexOf("value") !== -1) text.push(pt.valueLabel);
            pt.percent = pt.v / cd0.vTotal;
            pt.percentLabel = helpers.formatPiePercent(pt.percent, separators);
            if (hoverinfo && hoverinfo.indexOf("percent") !== -1) text.push(pt.percentLabel);
            var hoverLabel = trace2.hoverlabel;
            var hoverFont = hoverLabel.font;
            var bbox = [];
            Fx.loneHover({
              trace,
              x0: hoverCenterX - rInscribed * cd0.r,
              x1: hoverCenterX + rInscribed * cd0.r,
              y: hoverCenterY,
              _x0: isFunnelArea ? cx + pt.TL[0] : hoverCenterX - rInscribed * cd0.r,
              _x1: isFunnelArea ? cx + pt.TR[0] : hoverCenterX + rInscribed * cd0.r,
              _y0: isFunnelArea ? cy + pt.TL[1] : hoverCenterY - rInscribed * cd0.r,
              _y1: isFunnelArea ? cy + pt.BL[1] : hoverCenterY + rInscribed * cd0.r,
              text: text.join("<br>"),
              name: trace2.hovertemplate || hoverinfo.indexOf("name") !== -1 ? trace2.name : void 0,
              idealAlign: pt.pxmid[0] < 0 ? "left" : "right",
              color: helpers.castOption(hoverLabel.bgcolor, pt.pts) || pt.color,
              borderColor: helpers.castOption(hoverLabel.bordercolor, pt.pts),
              fontFamily: helpers.castOption(hoverFont.family, pt.pts),
              fontSize: helpers.castOption(hoverFont.size, pt.pts),
              fontColor: helpers.castOption(hoverFont.color, pt.pts),
              nameLength: helpers.castOption(hoverLabel.namelength, pt.pts),
              textAlign: helpers.castOption(hoverLabel.align, pt.pts),
              hovertemplate: helpers.castOption(trace2.hovertemplate, pt.pts),
              hovertemplateLabels: pt,
              eventData: [eventData(pt, trace2)]
            }, {
              container: fullLayout2._hoverlayer.node(),
              outerContainer: fullLayout2._paper.node(),
              gd,
              inOut_bbox: bbox
            });
            pt.bbox = bbox[0];
            trace._hasHoverLabel = true;
          }
          trace._hasHoverEvent = true;
          gd.emit("plotly_hover", {
            points: [eventData(pt, trace2)],
            event: d3.event
          });
        });
        sliceTop.on("mouseout", function(evt) {
          var fullLayout2 = gd._fullLayout;
          var trace2 = gd._fullData[trace.index];
          var pt = d3.select(this).datum();
          if (trace._hasHoverEvent) {
            evt.originalEvent = d3.event;
            gd.emit("plotly_unhover", {
              points: [eventData(pt, trace2)],
              event: d3.event
            });
            trace._hasHoverEvent = false;
          }
          if (trace._hasHoverLabel) {
            Fx.loneUnhover(fullLayout2._hoverlayer.node());
            trace._hasHoverLabel = false;
          }
        });
        sliceTop.on("click", function(pt) {
          var fullLayout2 = gd._fullLayout;
          var trace2 = gd._fullData[trace.index];
          if (gd._dragging || fullLayout2.hovermode === false) return;
          gd._hoverdata = [eventData(pt, trace2)];
          Fx.click(gd, d3.event);
        });
      }
      function determineOutsideTextFont(trace, pt, layoutFont) {
        var color = helpers.castOption(trace.outsidetextfont.color, pt.pts) || helpers.castOption(trace.textfont.color, pt.pts) || layoutFont.color;
        var family = helpers.castOption(trace.outsidetextfont.family, pt.pts) || helpers.castOption(trace.textfont.family, pt.pts) || layoutFont.family;
        var size = helpers.castOption(trace.outsidetextfont.size, pt.pts) || helpers.castOption(trace.textfont.size, pt.pts) || layoutFont.size;
        var weight = helpers.castOption(trace.outsidetextfont.weight, pt.pts) || helpers.castOption(trace.textfont.weight, pt.pts) || layoutFont.weight;
        var style = helpers.castOption(trace.outsidetextfont.style, pt.pts) || helpers.castOption(trace.textfont.style, pt.pts) || layoutFont.style;
        var variant = helpers.castOption(trace.outsidetextfont.variant, pt.pts) || helpers.castOption(trace.textfont.variant, pt.pts) || layoutFont.variant;
        var textcase = helpers.castOption(trace.outsidetextfont.textcase, pt.pts) || helpers.castOption(trace.textfont.textcase, pt.pts) || layoutFont.textcase;
        var lineposition = helpers.castOption(trace.outsidetextfont.lineposition, pt.pts) || helpers.castOption(trace.textfont.lineposition, pt.pts) || layoutFont.lineposition;
        var shadow = helpers.castOption(trace.outsidetextfont.shadow, pt.pts) || helpers.castOption(trace.textfont.shadow, pt.pts) || layoutFont.shadow;
        return {
          color,
          family,
          size,
          weight,
          style,
          variant,
          textcase,
          lineposition,
          shadow
        };
      }
      function determineInsideTextFont(trace, pt, layoutFont) {
        var customColor = helpers.castOption(trace.insidetextfont.color, pt.pts);
        if (!customColor && trace._input.textfont) {
          customColor = helpers.castOption(trace._input.textfont.color, pt.pts);
        }
        var family = helpers.castOption(trace.insidetextfont.family, pt.pts) || helpers.castOption(trace.textfont.family, pt.pts) || layoutFont.family;
        var size = helpers.castOption(trace.insidetextfont.size, pt.pts) || helpers.castOption(trace.textfont.size, pt.pts) || layoutFont.size;
        var weight = helpers.castOption(trace.insidetextfont.weight, pt.pts) || helpers.castOption(trace.textfont.weight, pt.pts) || layoutFont.weight;
        var style = helpers.castOption(trace.insidetextfont.style, pt.pts) || helpers.castOption(trace.textfont.style, pt.pts) || layoutFont.style;
        var variant = helpers.castOption(trace.insidetextfont.variant, pt.pts) || helpers.castOption(trace.textfont.variant, pt.pts) || layoutFont.variant;
        var textcase = helpers.castOption(trace.insidetextfont.textcase, pt.pts) || helpers.castOption(trace.textfont.textcase, pt.pts) || layoutFont.textcase;
        var lineposition = helpers.castOption(trace.insidetextfont.lineposition, pt.pts) || helpers.castOption(trace.textfont.lineposition, pt.pts) || layoutFont.lineposition;
        var shadow = helpers.castOption(trace.insidetextfont.shadow, pt.pts) || helpers.castOption(trace.textfont.shadow, pt.pts) || layoutFont.shadow;
        return {
          color: customColor || Color.contrast(pt.color),
          family,
          size,
          weight,
          style,
          variant,
          textcase,
          lineposition,
          shadow
        };
      }
      function prerenderTitles(cdModule, gd) {
        var cd0, trace;
        for (var i = 0; i < cdModule.length; i++) {
          cd0 = cdModule[i][0];
          trace = cd0.trace;
          if (trace.title.text) {
            var txt = trace.title.text;
            if (trace._meta) {
              txt = Lib.templateString(txt, trace._meta);
            }
            var dummyTitle = Drawing.tester.append("text").attr("data-notex", 1).text(txt).call(Drawing.font, trace.title.font).call(svgTextUtils.convertToTspans, gd);
            var bBox = Drawing.bBox(dummyTitle.node(), true);
            cd0.titleBox = {
              width: bBox.width,
              height: bBox.height
            };
            dummyTitle.remove();
          }
        }
      }
      function transformInsideText(textBB, pt, cd0) {
        var r = cd0.r || pt.rpx1;
        var rInscribed = pt.rInscribed;
        var isEmpty = pt.startangle === pt.stopangle;
        if (isEmpty) {
          return {
            rCenter: 1 - rInscribed,
            scale: 0,
            rotate: 0,
            textPosAngle: 0
          };
        }
        var ring = pt.ring;
        var isCircle = ring === 1 && Math.abs(pt.startangle - pt.stopangle) === Math.PI * 2;
        var halfAngle = pt.halfangle;
        var midAngle = pt.midangle;
        var orientation = cd0.trace.insidetextorientation;
        var isHorizontal = orientation === "horizontal";
        var isTangential = orientation === "tangential";
        var isRadial = orientation === "radial";
        var isAuto = orientation === "auto";
        var allTransforms = [];
        var newT;
        if (!isAuto) {
          var considerCrossing = function(angle, key) {
            if (isCrossing(pt, angle)) {
              var dStart = Math.abs(angle - pt.startangle);
              var dStop = Math.abs(angle - pt.stopangle);
              var closestEdge = dStart < dStop ? dStart : dStop;
              if (key === "tan") {
                newT = calcTanTransform(textBB, r, ring, closestEdge, 0);
              } else {
                newT = calcRadTransform(textBB, r, ring, closestEdge, Math.PI / 2);
              }
              newT.textPosAngle = angle;
              allTransforms.push(newT);
            }
          };
          var i;
          if (isHorizontal || isTangential) {
            for (i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * i, "tan");
            for (i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * (i + 1), "tan");
          }
          if (isHorizontal || isRadial) {
            for (i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * (i + 1.5), "rad");
            for (i = 4; i >= -4; i -= 2) considerCrossing(Math.PI * (i + 0.5), "rad");
          }
        }
        if (isCircle || isAuto || isHorizontal) {
          var textDiameter = Math.sqrt(textBB.width * textBB.width + textBB.height * textBB.height);
          newT = {
            scale: rInscribed * r * 2 / textDiameter,
            // and the center position and rotation in this case
            rCenter: 1 - rInscribed,
            rotate: 0
          };
          newT.textPosAngle = (pt.startangle + pt.stopangle) / 2;
          if (newT.scale >= 1) return newT;
          allTransforms.push(newT);
        }
        if (isAuto || isRadial) {
          newT = calcRadTransform(textBB, r, ring, halfAngle, midAngle);
          newT.textPosAngle = (pt.startangle + pt.stopangle) / 2;
          allTransforms.push(newT);
        }
        if (isAuto || isTangential) {
          newT = calcTanTransform(textBB, r, ring, halfAngle, midAngle);
          newT.textPosAngle = (pt.startangle + pt.stopangle) / 2;
          allTransforms.push(newT);
        }
        var id = 0;
        var maxScale = 0;
        for (var k = 0; k < allTransforms.length; k++) {
          var s = allTransforms[k].scale;
          if (maxScale < s) {
            maxScale = s;
            id = k;
          }
          if (!isAuto && maxScale >= 1) {
            break;
          }
        }
        return allTransforms[id];
      }
      function isCrossing(pt, angle) {
        var start = pt.startangle;
        var stop = pt.stopangle;
        return start > angle && angle > stop || start < angle && angle < stop;
      }
      function calcRadTransform(textBB, r, ring, halfAngle, midAngle) {
        r = Math.max(0, r - 2 * TEXTPAD);
        var a = textBB.width / textBB.height;
        var s = calcMaxHalfSize(a, halfAngle, r, ring);
        return {
          scale: s * 2 / textBB.height,
          rCenter: calcRCenter(a, s / r),
          rotate: calcRotate(midAngle)
        };
      }
      function calcTanTransform(textBB, r, ring, halfAngle, midAngle) {
        r = Math.max(0, r - 2 * TEXTPAD);
        var a = textBB.height / textBB.width;
        var s = calcMaxHalfSize(a, halfAngle, r, ring);
        return {
          scale: s * 2 / textBB.width,
          rCenter: calcRCenter(a, s / r),
          rotate: calcRotate(midAngle + Math.PI / 2)
        };
      }
      function calcRCenter(a, b) {
        return Math.cos(b) - a * b;
      }
      function calcRotate(t) {
        return (180 / Math.PI * t + 720) % 180 - 90;
      }
      function calcMaxHalfSize(a, halfAngle, r, ring) {
        var q = a + 1 / (2 * Math.tan(halfAngle));
        return r * Math.min(
          1 / (Math.sqrt(q * q + 0.5) + q),
          ring / (Math.sqrt(a * a + ring / 2) + a)
        );
      }
      function getInscribedRadiusFraction(pt, cd0) {
        if (pt.v === cd0.vTotal && !cd0.trace.hole) return 1;
        return Math.min(1 / (1 + 1 / Math.sin(pt.halfangle)), pt.ring / 2);
      }
      function transformOutsideText(textBB, pt) {
        var x = pt.pxmid[0];
        var y = pt.pxmid[1];
        var dx = textBB.width / 2;
        var dy = textBB.height / 2;
        if (x < 0) dx *= -1;
        if (y < 0) dy *= -1;
        return {
          scale: 1,
          rCenter: 1,
          rotate: 0,
          x: dx + Math.abs(dy) * (dx > 0 ? 1 : -1) / 2,
          y: dy / (1 + x * x / (y * y)),
          outside: true
        };
      }
      function positionTitleInside(cd0) {
        var textDiameter = Math.sqrt(cd0.titleBox.width * cd0.titleBox.width + cd0.titleBox.height * cd0.titleBox.height);
        return {
          x: cd0.cx,
          y: cd0.cy,
          scale: cd0.trace.hole * cd0.r * 2 / textDiameter,
          tx: 0,
          ty: -cd0.titleBox.height / 2 + cd0.trace.title.font.size
        };
      }
      function positionTitleOutside(cd0, plotSize) {
        var scaleX = 1;
        var scaleY = 1;
        var maxPull;
        var trace = cd0.trace;
        var topMiddle = {
          x: cd0.cx,
          y: cd0.cy
        };
        var translate = {
          tx: 0,
          ty: 0
        };
        translate.ty += trace.title.font.size;
        maxPull = getMaxPull(trace);
        if (trace.title.position.indexOf("top") !== -1) {
          topMiddle.y -= (1 + maxPull) * cd0.r;
          translate.ty -= cd0.titleBox.height;
        } else if (trace.title.position.indexOf("bottom") !== -1) {
          topMiddle.y += (1 + maxPull) * cd0.r;
        }
        var rx = applyAspectRatio(cd0.r, cd0.trace.aspectratio);
        var maxWidth = plotSize.w * (trace.domain.x[1] - trace.domain.x[0]) / 2;
        if (trace.title.position.indexOf("left") !== -1) {
          maxWidth = maxWidth + rx;
          topMiddle.x -= (1 + maxPull) * rx;
          translate.tx += cd0.titleBox.width / 2;
        } else if (trace.title.position.indexOf("center") !== -1) {
          maxWidth *= 2;
        } else if (trace.title.position.indexOf("right") !== -1) {
          maxWidth = maxWidth + rx;
          topMiddle.x += (1 + maxPull) * rx;
          translate.tx -= cd0.titleBox.width / 2;
        }
        scaleX = maxWidth / cd0.titleBox.width;
        scaleY = getTitleSpace(cd0, plotSize) / cd0.titleBox.height;
        return {
          x: topMiddle.x,
          y: topMiddle.y,
          scale: Math.min(scaleX, scaleY),
          tx: translate.tx,
          ty: translate.ty
        };
      }
      function applyAspectRatio(x, aspectratio) {
        return x / (aspectratio === void 0 ? 1 : aspectratio);
      }
      function getTitleSpace(cd0, plotSize) {
        var trace = cd0.trace;
        var pieBoxHeight = plotSize.h * (trace.domain.y[1] - trace.domain.y[0]);
        return Math.min(cd0.titleBox.height, pieBoxHeight / 2);
      }
      function getMaxPull(trace) {
        var maxPull = trace.pull;
        if (!maxPull) return 0;
        var j;
        if (Lib.isArrayOrTypedArray(maxPull)) {
          maxPull = 0;
          for (j = 0; j < trace.pull.length; j++) {
            if (trace.pull[j] > maxPull) maxPull = trace.pull[j];
          }
        }
        return maxPull;
      }
      function scootLabels(quadrants, trace) {
        var xHalf, yHalf, equatorFirst, farthestX, farthestY, xDiffSign, yDiffSign, thisQuad, oppositeQuad, wholeSide, i, thisQuadOutside, firstOppositeOutsidePt;
        function topFirst(a, b) {
          return a.pxmid[1] - b.pxmid[1];
        }
        function bottomFirst(a, b) {
          return b.pxmid[1] - a.pxmid[1];
        }
        function scootOneLabel(thisPt, prevPt2) {
          if (!prevPt2) prevPt2 = {};
          var prevOuterY = prevPt2.labelExtraY + (yHalf ? prevPt2.yLabelMax : prevPt2.yLabelMin);
          var thisInnerY = yHalf ? thisPt.yLabelMin : thisPt.yLabelMax;
          var thisOuterY = yHalf ? thisPt.yLabelMax : thisPt.yLabelMin;
          var thisSliceOuterY = thisPt.cyFinal + farthestY(thisPt.px0[1], thisPt.px1[1]);
          var newExtraY = prevOuterY - thisInnerY;
          var xBuffer, i2, otherPt, otherOuterY, otherOuterX, newExtraX;
          if (newExtraY * yDiffSign > 0) thisPt.labelExtraY = newExtraY;
          if (!Lib.isArrayOrTypedArray(trace.pull)) return;
          for (i2 = 0; i2 < wholeSide.length; i2++) {
            otherPt = wholeSide[i2];
            if (otherPt === thisPt || (helpers.castOption(trace.pull, thisPt.pts) || 0) >= (helpers.castOption(trace.pull, otherPt.pts) || 0)) {
              continue;
            }
            if ((thisPt.pxmid[1] - otherPt.pxmid[1]) * yDiffSign > 0) {
              otherOuterY = otherPt.cyFinal + farthestY(otherPt.px0[1], otherPt.px1[1]);
              newExtraY = otherOuterY - thisInnerY - thisPt.labelExtraY;
              if (newExtraY * yDiffSign > 0) thisPt.labelExtraY += newExtraY;
            } else if ((thisOuterY + thisPt.labelExtraY - thisSliceOuterY) * yDiffSign > 0) {
              xBuffer = 3 * xDiffSign * Math.abs(i2 - wholeSide.indexOf(thisPt));
              otherOuterX = otherPt.cxFinal + farthestX(otherPt.px0[0], otherPt.px1[0]);
              newExtraX = otherOuterX + xBuffer - (thisPt.cxFinal + thisPt.pxmid[0]) - thisPt.labelExtraX;
              if (newExtraX * xDiffSign > 0) thisPt.labelExtraX += newExtraX;
            }
          }
        }
        for (yHalf = 0; yHalf < 2; yHalf++) {
          equatorFirst = yHalf ? topFirst : bottomFirst;
          farthestY = yHalf ? Math.max : Math.min;
          yDiffSign = yHalf ? 1 : -1;
          for (xHalf = 0; xHalf < 2; xHalf++) {
            farthestX = xHalf ? Math.max : Math.min;
            xDiffSign = xHalf ? 1 : -1;
            thisQuad = quadrants[yHalf][xHalf];
            thisQuad.sort(equatorFirst);
            oppositeQuad = quadrants[1 - yHalf][xHalf];
            wholeSide = oppositeQuad.concat(thisQuad);
            thisQuadOutside = [];
            for (i = 0; i < thisQuad.length; i++) {
              if (thisQuad[i].yLabelMid !== void 0) thisQuadOutside.push(thisQuad[i]);
            }
            firstOppositeOutsidePt = false;
            for (i = 0; yHalf && i < oppositeQuad.length; i++) {
              if (oppositeQuad[i].yLabelMid !== void 0) {
                firstOppositeOutsidePt = oppositeQuad[i];
                break;
              }
            }
            for (i = 0; i < thisQuadOutside.length; i++) {
              var prevPt = i && thisQuadOutside[i - 1];
              if (firstOppositeOutsidePt && !i) prevPt = firstOppositeOutsidePt;
              scootOneLabel(thisQuadOutside[i], prevPt);
            }
          }
        }
      }
      function layoutAreas(cdModule, plotSize) {
        var scaleGroups = [];
        for (var i = 0; i < cdModule.length; i++) {
          var cd0 = cdModule[i][0];
          var trace = cd0.trace;
          var domain = trace.domain;
          var width = plotSize.w * (domain.x[1] - domain.x[0]);
          var height = plotSize.h * (domain.y[1] - domain.y[0]);
          if (trace.title.text && trace.title.position !== "middle center") {
            height -= getTitleSpace(cd0, plotSize);
          }
          var rx = width / 2;
          var ry = height / 2;
          if (trace.type === "funnelarea" && !trace.scalegroup) {
            ry /= trace.aspectratio;
          }
          cd0.r = Math.min(rx, ry) / (1 + getMaxPull(trace));
          cd0.cx = plotSize.l + plotSize.w * (trace.domain.x[1] + trace.domain.x[0]) / 2;
          cd0.cy = plotSize.t + plotSize.h * (1 - trace.domain.y[0]) - height / 2;
          if (trace.title.text && trace.title.position.indexOf("bottom") !== -1) {
            cd0.cy -= getTitleSpace(cd0, plotSize);
          }
          if (trace.scalegroup && scaleGroups.indexOf(trace.scalegroup) === -1) {
            scaleGroups.push(trace.scalegroup);
          }
        }
        groupScale(cdModule, scaleGroups);
      }
      function groupScale(cdModule, scaleGroups) {
        var cd0, i, trace;
        for (var k = 0; k < scaleGroups.length; k++) {
          var min = Infinity;
          var g = scaleGroups[k];
          for (i = 0; i < cdModule.length; i++) {
            cd0 = cdModule[i][0];
            trace = cd0.trace;
            if (trace.scalegroup === g) {
              var area;
              if (trace.type === "pie") {
                area = cd0.r * cd0.r;
              } else if (trace.type === "funnelarea") {
                var rx, ry;
                if (trace.aspectratio > 1) {
                  rx = cd0.r;
                  ry = rx / trace.aspectratio;
                } else {
                  ry = cd0.r;
                  rx = ry * trace.aspectratio;
                }
                rx *= (1 + trace.baseratio) / 2;
                area = rx * ry;
              }
              min = Math.min(min, area / cd0.vTotal);
            }
          }
          for (i = 0; i < cdModule.length; i++) {
            cd0 = cdModule[i][0];
            trace = cd0.trace;
            if (trace.scalegroup === g) {
              var v = min * cd0.vTotal;
              if (trace.type === "funnelarea") {
                v /= (1 + trace.baseratio) / 2;
                v /= trace.aspectratio;
              }
              cd0.r = Math.sqrt(v);
            }
          }
        }
      }
      function setCoords(cd) {
        var cd0 = cd[0];
        var r = cd0.r;
        var trace = cd0.trace;
        var currentAngle = helpers.getRotationAngle(trace.rotation);
        var angleFactor = 2 * Math.PI / cd0.vTotal;
        var firstPt = "px0";
        var lastPt = "px1";
        var i, cdi, currentCoords;
        if (trace.direction === "counterclockwise") {
          for (i = 0; i < cd.length; i++) {
            if (!cd[i].hidden) break;
          }
          if (i === cd.length) return;
          currentAngle += angleFactor * cd[i].v;
          angleFactor *= -1;
          firstPt = "px1";
          lastPt = "px0";
        }
        currentCoords = getCoords(r, currentAngle);
        for (i = 0; i < cd.length; i++) {
          cdi = cd[i];
          if (cdi.hidden) continue;
          cdi[firstPt] = currentCoords;
          cdi.startangle = currentAngle;
          currentAngle += angleFactor * cdi.v / 2;
          cdi.pxmid = getCoords(r, currentAngle);
          cdi.midangle = currentAngle;
          currentAngle += angleFactor * cdi.v / 2;
          currentCoords = getCoords(r, currentAngle);
          cdi.stopangle = currentAngle;
          cdi[lastPt] = currentCoords;
          cdi.largeArc = cdi.v > cd0.vTotal / 2 ? 1 : 0;
          cdi.halfangle = Math.PI * Math.min(cdi.v / cd0.vTotal, 0.5);
          cdi.ring = 1 - trace.hole;
          cdi.rInscribed = getInscribedRadiusFraction(cdi, cd0);
        }
      }
      function getCoords(r, angle) {
        return [r * Math.sin(angle), -r * Math.cos(angle)];
      }
      function formatSliceLabel(gd, pt, cd0) {
        var fullLayout = gd._fullLayout;
        var trace = cd0.trace;
        var texttemplate = trace.texttemplate;
        var textinfo = trace.textinfo;
        if (!texttemplate && textinfo && textinfo !== "none") {
          var parts = textinfo.split("+");
          var hasFlag = function(flag) {
            return parts.indexOf(flag) !== -1;
          };
          var hasLabel = hasFlag("label");
          var hasText = hasFlag("text");
          var hasValue = hasFlag("value");
          var hasPercent = hasFlag("percent");
          var separators = fullLayout.separators;
          var text;
          text = hasLabel ? [pt.label] : [];
          if (hasText) {
            var tx = helpers.getFirstFilled(trace.text, pt.pts);
            if (isValidTextValue(tx)) text.push(tx);
          }
          if (hasValue) text.push(helpers.formatPieValue(pt.v, separators));
          if (hasPercent) text.push(helpers.formatPiePercent(pt.v / cd0.vTotal, separators));
          pt.text = text.join("<br>");
        }
        function makeTemplateVariables(pt2) {
          return {
            label: pt2.label,
            value: pt2.v,
            valueLabel: helpers.formatPieValue(pt2.v, fullLayout.separators),
            percent: pt2.v / cd0.vTotal,
            percentLabel: helpers.formatPiePercent(pt2.v / cd0.vTotal, fullLayout.separators),
            color: pt2.color,
            text: pt2.text,
            customdata: Lib.castOption(trace, pt2.i, "customdata")
          };
        }
        if (texttemplate) {
          var txt = Lib.castOption(trace, pt.i, "texttemplate");
          if (!txt) {
            pt.text = "";
          } else {
            var obj = makeTemplateVariables(pt);
            var ptTx = helpers.getFirstFilled(trace.text, pt.pts);
            if (isValidTextValue(ptTx) || ptTx === "") obj.text = ptTx;
            pt.text = Lib.texttemplateString(txt, obj, gd._fullLayout._d3locale, obj, trace._meta || {});
          }
        }
      }
      function computeTransform(transform, textBB) {
        var a = transform.rotate * Math.PI / 180;
        var cosA = Math.cos(a);
        var sinA = Math.sin(a);
        var midX = (textBB.left + textBB.right) / 2;
        var midY = (textBB.top + textBB.bottom) / 2;
        transform.textX = midX * cosA - midY * sinA;
        transform.textY = midX * sinA + midY * cosA;
        transform.noCenter = true;
      }
      module.exports = {
        plot,
        formatSliceLabel,
        transformInsideText,
        determineInsideTextFont,
        positionTitleOutside,
        prerenderTitles,
        layoutAreas,
        attachFxHandlers,
        computeTransform
      };
    }
  });

  // src/traces/pie/style.js
  var require_style10 = __commonJS({
    "src/traces/pie/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var styleOne = require_style_one();
      var resizeText = require_uniform_text().resizeText;
      module.exports = function style(gd) {
        var s = gd._fullLayout._pielayer.selectAll(".trace");
        resizeText(gd, s, "pie");
        s.each(function(cd) {
          var cd0 = cd[0];
          var trace = cd0.trace;
          var traceSelection = d3.select(this);
          traceSelection.style({ opacity: trace.opacity });
          traceSelection.selectAll("path.surface").each(function(pt) {
            d3.select(this).call(styleOne, pt, trace, gd);
          });
        });
      };
    }
  });

  // src/traces/pie/base_plot.js
  var require_base_plot = __commonJS({
    "src/traces/pie/base_plot.js"(exports) {
      "use strict";
      var plots = require_plots();
      exports.name = "pie";
      exports.plot = function(gd, traces, transitionOpts, makeOnCompleteCallback) {
        plots.plotBasePlot(exports.name, gd, traces, transitionOpts, makeOnCompleteCallback);
      };
      exports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        plots.cleanBasePlot(exports.name, newFullData, newFullLayout, oldFullData, oldFullLayout);
      };
    }
  });

  // src/traces/pie/index.js
  var require_pie = __commonJS({
    "src/traces/pie/index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes33(),
        supplyDefaults: require_defaults29().supplyDefaults,
        supplyLayoutDefaults: require_layout_defaults9(),
        layoutAttributes: require_layout_attributes10(),
        calc: require_calc14().calc,
        crossTraceCalc: require_calc14().crossTraceCalc,
        plot: require_plot10().plot,
        style: require_style10(),
        styleOne: require_style_one(),
        moduleType: "trace",
        name: "pie",
        basePlotModule: require_base_plot(),
        categories: ["pie-like", "pie", "showLegend"],
        meta: {}
      };
    }
  });

  // lib/pie.js
  var require_pie2 = __commonJS({
    "lib/pie.js"(exports, module) {
      "use strict";
      module.exports = require_pie();
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/world-calendars/dist/main.js
  var require_main = __commonJS({
    "node_modules/world-calendars/dist/main.js"(exports, module) {
      var assign = require_object_assign();
      function Calendars() {
        this.regionalOptions = [];
        this.regionalOptions[""] = {
          invalidCalendar: "Calendar {0} not found",
          invalidDate: "Invalid {0} date",
          invalidMonth: "Invalid {0} month",
          invalidYear: "Invalid {0} year",
          differentCalendars: "Cannot mix {0} and {1} dates"
        };
        this.local = this.regionalOptions[""];
        this.calendars = {};
        this._localCals = {};
      }
      assign(Calendars.prototype, {
        /** Obtain a calendar implementation and localisation.
            @memberof Calendars
            @param [name='gregorian'] {string} The name of the calendar, e.g. 'gregorian', 'persian', 'islamic'.
            @param [language=''] {string} The language code to use for localisation (default is English).
            @return {Calendar} The calendar and localisation.
            @throws Error if calendar not found. */
        instance: function(name, language) {
          name = (name || "gregorian").toLowerCase();
          language = language || "";
          var cal = this._localCals[name + "-" + language];
          if (!cal && this.calendars[name]) {
            cal = new this.calendars[name](language);
            this._localCals[name + "-" + language] = cal;
          }
          if (!cal) {
            throw (this.local.invalidCalendar || this.regionalOptions[""].invalidCalendar).replace(/\{0\}/, name);
          }
          return cal;
        },
        /** Create a new date - for today if no other parameters given.
            @memberof Calendars
            @param year {CDate|number} The date to copy or the year for the date.
            @param [month] {number} The month for the date.
            @param [day] {number} The day for the date.
            @param [calendar='gregorian'] {BaseCalendar|string} The underlying calendar or the name of the calendar.
            @param [language=''] {string} The language to use for localisation (default English).
            @return {CDate} The new date.
            @throws Error if an invalid date. */
        newDate: function(year, month, day, calendar, language) {
          calendar = (year != null && year.year ? year.calendar() : typeof calendar === "string" ? this.instance(calendar, language) : calendar) || this.instance();
          return calendar.newDate(year, month, day);
        },
        /** A simple digit substitution function for localising numbers via the Calendar digits option.
            @member Calendars
            @param digits {string[]} The substitute digits, for 0 through 9.
            @return {function} The substitution function. */
        substituteDigits: function(digits) {
          return function(value) {
            return (value + "").replace(/[0-9]/g, function(digit) {
              return digits[digit];
            });
          };
        },
        /** Digit substitution function for localising Chinese style numbers via the Calendar digits option.
            @member Calendars
            @param digits {string[]} The substitute digits, for 0 through 9.
            @param powers {string[]} The characters denoting powers of 10, i.e. 1, 10, 100, 1000.
            @return {function} The substitution function. */
        substituteChineseDigits: function(digits, powers) {
          return function(value) {
            var localNumber = "";
            var power = 0;
            while (value > 0) {
              var units = value % 10;
              localNumber = (units === 0 ? "" : digits[units] + powers[power]) + localNumber;
              power++;
              value = Math.floor(value / 10);
            }
            if (localNumber.indexOf(digits[1] + powers[1]) === 0) {
              localNumber = localNumber.substr(1);
            }
            return localNumber || digits[0];
          };
        }
      });
      function CDate(calendar, year, month, day) {
        this._calendar = calendar;
        this._year = year;
        this._month = month;
        this._day = day;
        if (this._calendar._validateLevel === 0 && !this._calendar.isValid(this._year, this._month, this._day)) {
          throw (_exports.local.invalidDate || _exports.regionalOptions[""].invalidDate).replace(/\{0\}/, this._calendar.local.name);
        }
      }
      function pad(value, length) {
        value = "" + value;
        return "000000".substring(0, length - value.length) + value;
      }
      assign(CDate.prototype, {
        /** Create a new date.
            @memberof CDate
            @param [year] {CDate|number} The date to copy or the year for the date (default this date).
            @param [month] {number} The month for the date.
            @param [day] {number} The day for the date.
            @return {CDate} The new date.
            @throws Error if an invalid date. */
        newDate: function(year, month, day) {
          return this._calendar.newDate(year == null ? this : year, month, day);
        },
        /** Set or retrieve the year for this date.
            @memberof CDate
            @param [year] {number} The year for the date.
            @return {number|CDate} The date's year (if no parameter) or the updated date.
            @throws Error if an invalid date. */
        year: function(year) {
          return arguments.length === 0 ? this._year : this.set(year, "y");
        },
        /** Set or retrieve the month for this date.
            @memberof CDate
            @param [month] {number} The month for the date.
            @return {number|CDate} The date's month (if no parameter) or the updated date.
            @throws Error if an invalid date. */
        month: function(month) {
          return arguments.length === 0 ? this._month : this.set(month, "m");
        },
        /** Set or retrieve the day for this date.
            @memberof CDate
            @param [day] {number} The day for the date.
            @return {number|CData} The date's day (if no parameter) or the updated date.
            @throws Error if an invalid date. */
        day: function(day) {
          return arguments.length === 0 ? this._day : this.set(day, "d");
        },
        /** Set new values for this date.
            @memberof CDate
            @param year {number} The year for the date.
            @param month {number} The month for the date.
            @param day {number} The day for the date.
            @return {CDate} The updated date.
            @throws Error if an invalid date. */
        date: function(year, month, day) {
          if (!this._calendar.isValid(year, month, day)) {
            throw (_exports.local.invalidDate || _exports.regionalOptions[""].invalidDate).replace(/\{0\}/, this._calendar.local.name);
          }
          this._year = year;
          this._month = month;
          this._day = day;
          return this;
        },
        /** Determine whether this date is in a leap year.
            @memberof CDate
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not. */
        leapYear: function() {
          return this._calendar.leapYear(this);
        },
        /** Retrieve the epoch designator for this date, e.g. BCE or CE.
            @memberof CDate
            @return {string} The current epoch. */
        epoch: function() {
          return this._calendar.epoch(this);
        },
        /** Format the year, if not a simple sequential number.
            @memberof CDate
            @return {string} The formatted year. */
        formatYear: function() {
          return this._calendar.formatYear(this);
        },
        /** Retrieve the month of the year for this date,
            i.e. the month's position within a numbered year.
            @memberof CDate
            @return {number} The month of the year: <code>minMonth</code> to months per year. */
        monthOfYear: function() {
          return this._calendar.monthOfYear(this);
        },
        /** Retrieve the week of the year for this date.
            @memberof CDate
            @return {number} The week of the year: 1 to weeks per year. */
        weekOfYear: function() {
          return this._calendar.weekOfYear(this);
        },
        /** Retrieve the number of days in the year for this date.
            @memberof CDate
            @return {number} The number of days in this year. */
        daysInYear: function() {
          return this._calendar.daysInYear(this);
        },
        /** Retrieve the day of the year for this date.
            @memberof CDate
            @return {number} The day of the year: 1 to days per year. */
        dayOfYear: function() {
          return this._calendar.dayOfYear(this);
        },
        /** Retrieve the number of days in the month for this date.
            @memberof CDate
            @return {number} The number of days. */
        daysInMonth: function() {
          return this._calendar.daysInMonth(this);
        },
        /** Retrieve the day of the week for this date.
            @memberof CDate
            @return {number} The day of the week: 0 to number of days - 1. */
        dayOfWeek: function() {
          return this._calendar.dayOfWeek(this);
        },
        /** Determine whether this date is a week day.
            @memberof CDate
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not. */
        weekDay: function() {
          return this._calendar.weekDay(this);
        },
        /** Retrieve additional information about this date.
            @memberof CDate
            @return {object} Additional information - contents depends on calendar. */
        extraInfo: function() {
          return this._calendar.extraInfo(this);
        },
        /** Add period(s) to a date.
            @memberof CDate
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date. */
        add: function(offset, period) {
          return this._calendar.add(this, offset, period);
        },
        /** Set a portion of the date.
            @memberof CDate
            @param value {number} The new value for the period.
            @param period {string} One of 'y' for year, 'm' for month, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if not a valid date. */
        set: function(value, period) {
          return this._calendar.set(this, value, period);
        },
        /** Compare this date to another date.
            @memberof CDate
            @param date {CDate} The other date.
            @return {number} -1 if this date is before the other date,
                    0 if they are equal, or +1 if this date is after the other date. */
        compareTo: function(date) {
          if (this._calendar.name !== date._calendar.name) {
            throw (_exports.local.differentCalendars || _exports.regionalOptions[""].differentCalendars).replace(/\{0\}/, this._calendar.local.name).replace(/\{1\}/, date._calendar.local.name);
          }
          var c = this._year !== date._year ? this._year - date._year : this._month !== date._month ? this.monthOfYear() - date.monthOfYear() : this._day - date._day;
          return c === 0 ? 0 : c < 0 ? -1 : 1;
        },
        /** Retrieve the calendar backing this date.
            @memberof CDate
            @return {BaseCalendar} The calendar implementation. */
        calendar: function() {
          return this._calendar;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof CDate
            @return {number} The equivalent Julian date. */
        toJD: function() {
          return this._calendar.toJD(this);
        },
        /** Create a new date from a Julian date.
            @memberof CDate
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          return this._calendar.fromJD(jd);
        },
        /** Convert this date to a standard (Gregorian) JavaScript Date.
            @memberof CDate
            @return {Date} The equivalent JavaScript date. */
        toJSDate: function() {
          return this._calendar.toJSDate(this);
        },
        /** Create a new date from a standard (Gregorian) JavaScript Date.
            @memberof CDate
            @param jsd {Date} The JavaScript date to convert.
            @return {CDate} The equivalent date. */
        fromJSDate: function(jsd) {
          return this._calendar.fromJSDate(jsd);
        },
        /** Convert to a string for display.
            @memberof CDate
            @return {string} This date as a string. */
        toString: function() {
          return (this.year() < 0 ? "-" : "") + pad(Math.abs(this.year()), 4) + "-" + pad(this.month(), 2) + "-" + pad(this.day(), 2);
        }
      });
      function BaseCalendar() {
        this.shortYearCutoff = "+10";
      }
      assign(BaseCalendar.prototype, {
        _validateLevel: 0,
        // "Stack" to turn validation on/off
        /** Create a new date within this calendar - today if no parameters given.
            @memberof BaseCalendar
            @param year {CDate|number} The date to duplicate or the year for the date.
            @param [month] {number} The month for the date.
            @param [day] {number} The day for the date.
            @return {CDate} The new date.
            @throws Error if not a valid date or a different calendar used. */
        newDate: function(year, month, day) {
          if (year == null) {
            return this.today();
          }
          if (year.year) {
            this._validate(
              year,
              month,
              day,
              _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
            );
            day = year.day();
            month = year.month();
            year = year.year();
          }
          return new CDate(this, year, month, day);
        },
        /** Create a new date for today.
            @memberof BaseCalendar
            @return {CDate} Today's date. */
        today: function() {
          return this.fromJSDate(/* @__PURE__ */ new Date());
        },
        /** Retrieve the epoch designator for this date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {string} The current epoch.
            @throws Error if an invalid year or a different calendar used. */
        epoch: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return date.year() < 0 ? this.local.epochs[0] : this.local.epochs[1];
        },
        /** Format the year, if not a simple sequential number
            @memberof BaseCalendar
            @param year {CDate|number} The date to format or the year to format.
            @return {string} The formatted year.
            @throws Error if an invalid year or a different calendar used. */
        formatYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return (date.year() < 0 ? "-" : "") + pad(Math.abs(date.year()), 4);
        },
        /** Retrieve the number of months in a year.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return 12;
        },
        /** Calculate the month's ordinal position within the year -
            for those calendars that don't start at month 1!
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param month {number} The month to examine.
            @return {number} The ordinal position, starting from <code>minMonth</code>.
            @throws Error if an invalid year/month or a different calendar used. */
        monthOfYear: function(year, month) {
          var date = this._validate(
            year,
            month,
            this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[""].invalidMonth
          );
          return (date.month() + this.monthsInYear(date) - this.firstMonth) % this.monthsInYear(date) + this.minMonth;
        },
        /** Calculate actual month from ordinal position, starting from minMonth.
            @memberof BaseCalendar
            @param year {number} The year to examine.
            @param ord {number} The month's ordinal position.
            @return {number} The month's number.
            @throws Error if an invalid year/month. */
        fromMonthOfYear: function(year, ord) {
          var m = (ord + this.firstMonth - 2 * this.minMonth) % this.monthsInYear(year) + this.minMonth;
          this._validate(
            year,
            m,
            this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[""].invalidMonth
          );
          return m;
        },
        /** Retrieve the number of days in a year.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return this.leapYear(date) ? 366 : 365;
        },
        /** Retrieve the day of the year for a date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The day of the year.
            @throws Error if an invalid date or a different calendar used. */
        dayOfYear: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return date.toJD() - this.newDate(
            date.year(),
            this.fromMonthOfYear(date.year(), this.minMonth),
            this.minDay
          ).toJD() + 1;
        },
        /** Retrieve the number of days in a week.
            @memberof BaseCalendar
            @return {number} The number of days. */
        daysInWeek: function() {
          return 7;
        },
        /** Retrieve the day of the week for a date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The day of the week: 0 to number of days - 1.
            @throws Error if an invalid date or a different calendar used. */
        dayOfWeek: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return (Math.floor(this.toJD(date)) + 2) % this.daysInWeek();
        },
        /** Retrieve additional information about a date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return {};
        },
        /** Add period(s) to a date.
            Cater for no year zero.
            @memberof BaseCalendar
            @param date {CDate} The starting date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if a different calendar used. */
        add: function(date, offset, period) {
          this._validate(
            date,
            this.minMonth,
            this.minDay,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return this._correctAdd(date, this._add(date, offset, period), offset, period);
        },
        /** Add period(s) to a date.
            @memberof BaseCalendar
            @private
            @param date {CDate} The starting date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date. */
        _add: function(date, offset, period) {
          this._validateLevel++;
          if (period === "d" || period === "w") {
            var jd = date.toJD() + offset * (period === "w" ? this.daysInWeek() : 1);
            var d = date.calendar().fromJD(jd);
            this._validateLevel--;
            return [d.year(), d.month(), d.day()];
          }
          try {
            var y = date.year() + (period === "y" ? offset : 0);
            var m = date.monthOfYear() + (period === "m" ? offset : 0);
            var d = date.day();
            var resyncYearMonth = function(calendar) {
              while (m < calendar.minMonth) {
                y--;
                m += calendar.monthsInYear(y);
              }
              var yearMonths = calendar.monthsInYear(y);
              while (m > yearMonths - 1 + calendar.minMonth) {
                y++;
                m -= yearMonths;
                yearMonths = calendar.monthsInYear(y);
              }
            };
            if (period === "y") {
              if (date.month() !== this.fromMonthOfYear(y, m)) {
                m = this.newDate(y, date.month(), this.minDay).monthOfYear();
              }
              m = Math.min(m, this.monthsInYear(y));
              d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
            } else if (period === "m") {
              resyncYearMonth(this);
              d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
            }
            var ymd = [y, this.fromMonthOfYear(y, m), d];
            this._validateLevel--;
            return ymd;
          } catch (e) {
            this._validateLevel--;
            throw e;
          }
        },
        /** Correct a candidate date after adding period(s) to a date.
            Handle no year zero if necessary.
            @memberof BaseCalendar
            @private
            @param date {CDate} The starting date.
            @param ymd {number[]} The added date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date. */
        _correctAdd: function(date, ymd, offset, period) {
          if (!this.hasYearZero && (period === "y" || period === "m")) {
            if (ymd[0] === 0 || // In year zero
            date.year() > 0 !== ymd[0] > 0) {
              var adj = {
                y: [1, 1, "y"],
                m: [1, this.monthsInYear(-1), "m"],
                w: [this.daysInWeek(), this.daysInYear(-1), "d"],
                d: [1, this.daysInYear(-1), "d"]
              }[period];
              var dir = offset < 0 ? -1 : 1;
              ymd = this._add(date, offset * adj[0] + dir * adj[1], adj[2]);
            }
          }
          return date.date(ymd[0], ymd[1], ymd[2]);
        },
        /** Set a portion of the date.
            @memberof BaseCalendar
            @param date {CDate} The starting date.
            @param value {number} The new value for the period.
            @param period {string} One of 'y' for year, 'm' for month, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if an invalid date or a different calendar used. */
        set: function(date, value, period) {
          this._validate(
            date,
            this.minMonth,
            this.minDay,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          var y = period === "y" ? value : date.year();
          var m = period === "m" ? value : date.month();
          var d = period === "d" ? value : date.day();
          if (period === "y" || period === "m") {
            d = Math.min(d, this.daysInMonth(y, m));
          }
          return date.date(y, m, d);
        },
        /** Determine whether a date is valid for this calendar.
            @memberof BaseCalendar
            @param year {number} The year to examine.
            @param month {number} The month to examine.
            @param day {number} The day to examine.
            @return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
        isValid: function(year, month, day) {
          this._validateLevel++;
          var valid = this.hasYearZero || year !== 0;
          if (valid) {
            var date = this.newDate(year, month, this.minDay);
            valid = month >= this.minMonth && month - this.minMonth < this.monthsInYear(date) && (day >= this.minDay && day - this.minDay < this.daysInMonth(date));
          }
          this._validateLevel--;
          return valid;
        },
        /** Convert the date to a standard (Gregorian) JavaScript Date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {Date} The equivalent JavaScript date.
            @throws Error if an invalid date or a different calendar used. */
        toJSDate: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return _exports.instance().fromJD(this.toJD(date)).toJSDate();
        },
        /** Convert the date from a standard (Gregorian) JavaScript Date.
            @memberof BaseCalendar
            @param jsd {Date} The JavaScript date.
            @return {CDate} The equivalent calendar date. */
        fromJSDate: function(jsd) {
          return this.fromJD(_exports.instance().fromJSDate(jsd).toJD());
        },
        /** Check that a candidate date is from the same calendar and is valid.
            @memberof BaseCalendar
            @private
            @param year {CDate|number} The date to validate or the year to validate.
            @param [month] {number} The month to validate.
            @param [day] {number} The day to validate.
            @param error {string} Rrror message if invalid.
            @throws Error if different calendars used or invalid date. */
        _validate: function(year, month, day, error) {
          if (year.year) {
            if (this._validateLevel === 0 && this.name !== year.calendar().name) {
              throw (_exports.local.differentCalendars || _exports.regionalOptions[""].differentCalendars).replace(/\{0\}/, this.local.name).replace(/\{1\}/, year.calendar().local.name);
            }
            return year;
          }
          try {
            this._validateLevel++;
            if (this._validateLevel === 1 && !this.isValid(year, month, day)) {
              throw error.replace(/\{0\}/, this.local.name);
            }
            var date = this.newDate(year, month, day);
            this._validateLevel--;
            return date;
          } catch (e) {
            this._validateLevel--;
            throw e;
          }
        }
      });
      function GregorianCalendar(language) {
        this.local = this.regionalOptions[language] || this.regionalOptions[""];
      }
      GregorianCalendar.prototype = new BaseCalendar();
      assign(GregorianCalendar.prototype, {
        /** The calendar name.
            @memberof GregorianCalendar */
        name: "Gregorian",
        /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
           @memberof GregorianCalendar */
        jdEpoch: 17214255e-1,
        /** Days per month in a common year.
           @memberof GregorianCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
           @memberof GregorianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof GregorianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof GregorianCalendar */
        firstMonth: 1,
        /** The minimum day number.
           @memberof GregorianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof GregorianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Gregorian",
            epochs: ["BCE", "CE"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "mm/dd/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          var year = date.year() + (date.year() < 0 ? 1 : 0);
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year, starting from 1.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(4 - (checkDate.dayOfWeek() || 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(
            year,
            month,
            this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[""].invalidMonth
          );
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          year = date.year();
          month = date.month();
          day = date.day();
          if (year < 0) {
            year++;
          }
          if (month < 3) {
            month += 12;
            year--;
          }
          var a = Math.floor(year / 100);
          var b = 2 - a + Math.floor(a / 4);
          return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + b - 1524.5;
        },
        /** Create a new date from a Julian date.
            @memberof GregorianCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var z = Math.floor(jd + 0.5);
          var a = Math.floor((z - 186721625e-2) / 36524.25);
          a = z + 1 + a - Math.floor(a / 4);
          var b = a + 1524;
          var c = Math.floor((b - 122.1) / 365.25);
          var d = Math.floor(365.25 * c);
          var e = Math.floor((b - d) / 30.6001);
          var day = b - d - Math.floor(e * 30.6001);
          var month = e - (e > 13.5 ? 13 : 1);
          var year = c - (month > 2.5 ? 4716 : 4715);
          if (year <= 0) {
            year--;
          }
          return this.newDate(year, month, day);
        },
        /** Convert this date to a standard (Gregorian) JavaScript Date.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {Date} The equivalent JavaScript date.
            @throws Error if an invalid date or a different calendar used. */
        toJSDate: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          var jsd = new Date(date.year(), date.month() - 1, date.day());
          jsd.setHours(0);
          jsd.setMinutes(0);
          jsd.setSeconds(0);
          jsd.setMilliseconds(0);
          jsd.setHours(jsd.getHours() > 12 ? jsd.getHours() + 2 : 0);
          return jsd;
        },
        /** Create a new date from a standard (Gregorian) JavaScript Date.
            @memberof GregorianCalendar
            @param jsd {Date} The JavaScript date to convert.
            @return {CDate} The equivalent date. */
        fromJSDate: function(jsd) {
          return this.newDate(jsd.getFullYear(), jsd.getMonth() + 1, jsd.getDate());
        }
      });
      var _exports = module.exports = new Calendars();
      _exports.cdate = CDate;
      _exports.baseCalendar = BaseCalendar;
      _exports.calendars.gregorian = GregorianCalendar;
    }
  });

  // node_modules/world-calendars/dist/plus.js
  var require_plus = __commonJS({
    "node_modules/world-calendars/dist/plus.js"() {
      var assign = require_object_assign();
      var main = require_main();
      assign(main.regionalOptions[""], {
        invalidArguments: "Invalid arguments",
        invalidFormat: "Cannot format a date from another calendar",
        missingNumberAt: "Missing number at position {0}",
        unknownNameAt: "Unknown name at position {0}",
        unexpectedLiteralAt: "Unexpected literal at position {0}",
        unexpectedText: "Additional text found at end"
      });
      main.local = main.regionalOptions[""];
      assign(main.cdate.prototype, {
        /** Format this date.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof CDate
            @param [format] {string} The date format to use (see <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a>).
            @param [settings] {object} Options for the <code>formatDate</code> function.
            @return {string} The formatted date. */
        formatDate: function(format, settings) {
          if (typeof format !== "string") {
            settings = format;
            format = "";
          }
          return this._calendar.formatDate(format || "", this, settings);
        }
      });
      assign(main.baseCalendar.prototype, {
        UNIX_EPOCH: main.instance().newDate(1970, 1, 1).toJD(),
        SECS_PER_DAY: 24 * 60 * 60,
        TICKS_EPOCH: main.instance().jdEpoch,
        // 1 January 0001 CE
        TICKS_PER_DAY: 24 * 60 * 60 * 1e7,
        /** Date form for ATOM (RFC 3339/ISO 8601).
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        ATOM: "yyyy-mm-dd",
        /** Date form for cookies.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        COOKIE: "D, dd M yyyy",
        /** Date form for full date.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        FULL: "DD, MM d, yyyy",
        /** Date form for ISO 8601.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        ISO_8601: "yyyy-mm-dd",
        /** Date form for Julian date.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        JULIAN: "J",
        /** Date form for RFC 822.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_822: "D, d M yy",
        /** Date form for RFC 850.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_850: "DD, dd-M-yy",
        /** Date form for RFC 1036.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_1036: "D, d M yy",
        /** Date form for RFC 1123.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_1123: "D, d M yyyy",
        /** Date form for RFC 2822.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_2822: "D, d M yyyy",
        /** Date form for RSS (RFC 822).
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RSS: "D, d M yy",
        /** Date form for Windows ticks.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        TICKS: "!",
        /** Date form for Unix timestamp.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        TIMESTAMP: "@",
        /** Date form for W3c (ISO 8601).
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        W3C: "yyyy-mm-dd",
        /** Format a date object into a string value.
            The format can be combinations of the following:
            <ul>
            <li>d  - day of month (no leading zero)</li>
            <li>dd - day of month (two digit)</li>
            <li>o  - day of year (no leading zeros)</li>
            <li>oo - day of year (three digit)</li>
            <li>D  - day name short</li>
            <li>DD - day name long</li>
            <li>w  - week of year (no leading zero)</li>
            <li>ww - week of year (two digit)</li>
            <li>m  - month of year (no leading zero)</li>
            <li>mm - month of year (two digit)</li>
            <li>M  - month name short</li>
            <li>MM - month name long</li>
            <li>yy - year (two digit)</li>
            <li>yyyy - year (four digit)</li>
            <li>YYYY - formatted year</li>
            <li>J  - Julian date (days since January 1, 4713 BCE Greenwich noon)</li>
            <li>@  - Unix timestamp (s since 01/01/1970)</li>
            <li>!  - Windows ticks (100ns since 01/01/0001)</li>
            <li>'...' - literal text</li>
            <li>'' - single quote</li>
            </ul>
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar
            @param [format] {string} The desired format of the date (defaults to calendar format).
            @param date {CDate} The date value to format.
            @param [settings] {object} Addition options, whose attributes include:
            @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
            @property [dayNames] {string[]} Names of the days from Sunday.
            @property [monthNamesShort] {string[]} Abbreviated names of the months.
            @property [monthNames] {string[]} Names of the months.
            @property [calculateWeek] {CalendarsPickerCalculateWeek} Function that determines week of the year.
            @property [localNumbers=false] {boolean} <code>true</code> to localise numbers (if available),
                      <code>false</code> to use normal Arabic numerals.
            @return {string} The date in the above format.
            @throws Errors if the date is from a different calendar. */
        formatDate: function(format, date, settings) {
          if (typeof format !== "string") {
            settings = date;
            date = format;
            format = "";
          }
          if (!date) {
            return "";
          }
          if (date.calendar() !== this) {
            throw main.local.invalidFormat || main.regionalOptions[""].invalidFormat;
          }
          format = format || this.local.dateFormat;
          settings = settings || {};
          var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
          var dayNames = settings.dayNames || this.local.dayNames;
          var monthNumbers = settings.monthNumbers || this.local.monthNumbers;
          var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
          var monthNames = settings.monthNames || this.local.monthNames;
          var calculateWeek = settings.calculateWeek || this.local.calculateWeek;
          var doubled = function(match, step) {
            var matches = 1;
            while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
              matches++;
            }
            iFormat += matches - 1;
            return Math.floor(matches / (step || 1)) > 1;
          };
          var formatNumber = function(match, value, len, step) {
            var num = "" + value;
            if (doubled(match, step)) {
              while (num.length < len) {
                num = "0" + num;
              }
            }
            return num;
          };
          var formatName = function(match, value, shortNames, longNames) {
            return doubled(match) ? longNames[value] : shortNames[value];
          };
          var calendar = this;
          var formatMonth = function(date2) {
            return typeof monthNumbers === "function" ? monthNumbers.call(calendar, date2, doubled("m")) : localiseNumbers(formatNumber("m", date2.month(), 2));
          };
          var formatMonthName = function(date2, useLongName) {
            if (useLongName) {
              return typeof monthNames === "function" ? monthNames.call(calendar, date2) : monthNames[date2.month() - calendar.minMonth];
            } else {
              return typeof monthNamesShort === "function" ? monthNamesShort.call(calendar, date2) : monthNamesShort[date2.month() - calendar.minMonth];
            }
          };
          var digits = this.local.digits;
          var localiseNumbers = function(value) {
            return settings.localNumbers && digits ? digits(value) : value;
          };
          var output = "";
          var literal = false;
          for (var iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
              if (format.charAt(iFormat) === "'" && !doubled("'")) {
                literal = false;
              } else {
                output += format.charAt(iFormat);
              }
            } else {
              switch (format.charAt(iFormat)) {
                case "d":
                  output += localiseNumbers(formatNumber("d", date.day(), 2));
                  break;
                case "D":
                  output += formatName(
                    "D",
                    date.dayOfWeek(),
                    dayNamesShort,
                    dayNames
                  );
                  break;
                case "o":
                  output += formatNumber("o", date.dayOfYear(), 3);
                  break;
                case "w":
                  output += formatNumber("w", date.weekOfYear(), 2);
                  break;
                case "m":
                  output += formatMonth(date);
                  break;
                case "M":
                  output += formatMonthName(date, doubled("M"));
                  break;
                case "y":
                  output += doubled("y", 2) ? date.year() : (date.year() % 100 < 10 ? "0" : "") + date.year() % 100;
                  break;
                case "Y":
                  doubled("Y", 2);
                  output += date.formatYear();
                  break;
                case "J":
                  output += date.toJD();
                  break;
                case "@":
                  output += (date.toJD() - this.UNIX_EPOCH) * this.SECS_PER_DAY;
                  break;
                case "!":
                  output += (date.toJD() - this.TICKS_EPOCH) * this.TICKS_PER_DAY;
                  break;
                case "'":
                  if (doubled("'")) {
                    output += "'";
                  } else {
                    literal = true;
                  }
                  break;
                default:
                  output += format.charAt(iFormat);
              }
            }
          }
          return output;
        },
        /** Parse a string value into a date object.
            See <a href="#formatDate"><code>formatDate</code></a> for the possible formats, plus:
            <ul>
            <li>* - ignore rest of string</li>
            </ul>
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar
            @param format {string} The expected format of the date ('' for default calendar format).
            @param value {string} The date in the above format.
            @param [settings] {object} Additional options whose attributes include:
            @property [shortYearCutoff] {number} The cutoff year for determining the century.
            @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
            @property [dayNames] {string[]} Names of the days from Sunday.
            @property [monthNamesShort] {string[]} Abbreviated names of the months.
            @property [monthNames] {string[]} Names of the months.
            @return {CDate} The extracted date value or <code>null</code> if value is blank.
            @throws Errors if the format and/or value are missing,
                    if the value doesn't match the format, or if the date is invalid. */
        parseDate: function(format, value, settings) {
          if (value == null) {
            throw main.local.invalidArguments || main.regionalOptions[""].invalidArguments;
          }
          value = typeof value === "object" ? value.toString() : value + "";
          if (value === "") {
            return null;
          }
          format = format || this.local.dateFormat;
          settings = settings || {};
          var shortYearCutoff = settings.shortYearCutoff || this.shortYearCutoff;
          shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : this.today().year() % 100 + parseInt(shortYearCutoff, 10);
          var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
          var dayNames = settings.dayNames || this.local.dayNames;
          var parseMonth = settings.parseMonth || this.local.parseMonth;
          var monthNumbers = settings.monthNumbers || this.local.monthNumbers;
          var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
          var monthNames = settings.monthNames || this.local.monthNames;
          var jd = -1;
          var year = -1;
          var month = -1;
          var day = -1;
          var doy = -1;
          var shortYear = false;
          var literal = false;
          var doubled = function(match, step) {
            var matches = 1;
            while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
              matches++;
            }
            iFormat += matches - 1;
            return Math.floor(matches / (step || 1)) > 1;
          };
          var getNumber = function(match, step) {
            var isDoubled = doubled(match, step);
            var size = [2, 3, isDoubled ? 4 : 2, isDoubled ? 4 : 2, 10, 11, 20]["oyYJ@!".indexOf(match) + 1];
            var digits = new RegExp("^-?\\d{1," + size + "}");
            var num = value.substring(iValue).match(digits);
            if (!num) {
              throw (main.local.missingNumberAt || main.regionalOptions[""].missingNumberAt).replace(/\{0\}/, iValue);
            }
            iValue += num[0].length;
            return parseInt(num[0], 10);
          };
          var calendar = this;
          var getMonthNumber = function() {
            if (typeof monthNumbers === "function") {
              doubled("m");
              var month2 = monthNumbers.call(calendar, value.substring(iValue));
              iValue += month2.length;
              return month2;
            }
            return getNumber("m");
          };
          var getName = function(match, shortNames, longNames, step) {
            var names = doubled(match, step) ? longNames : shortNames;
            for (var i = 0; i < names.length; i++) {
              if (value.substr(iValue, names[i].length).toLowerCase() === names[i].toLowerCase()) {
                iValue += names[i].length;
                return i + calendar.minMonth;
              }
            }
            throw (main.local.unknownNameAt || main.regionalOptions[""].unknownNameAt).replace(/\{0\}/, iValue);
          };
          var getMonthName = function() {
            if (typeof monthNames === "function") {
              var month2 = doubled("M") ? monthNames.call(calendar, value.substring(iValue)) : monthNamesShort.call(calendar, value.substring(iValue));
              iValue += month2.length;
              return month2;
            }
            return getName("M", monthNamesShort, monthNames);
          };
          var checkLiteral = function() {
            if (value.charAt(iValue) !== format.charAt(iFormat)) {
              throw (main.local.unexpectedLiteralAt || main.regionalOptions[""].unexpectedLiteralAt).replace(/\{0\}/, iValue);
            }
            iValue++;
          };
          var iValue = 0;
          for (var iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
              if (format.charAt(iFormat) === "'" && !doubled("'")) {
                literal = false;
              } else {
                checkLiteral();
              }
            } else {
              switch (format.charAt(iFormat)) {
                case "d":
                  day = getNumber("d");
                  break;
                case "D":
                  getName("D", dayNamesShort, dayNames);
                  break;
                case "o":
                  doy = getNumber("o");
                  break;
                case "w":
                  getNumber("w");
                  break;
                case "m":
                  month = getMonthNumber();
                  break;
                case "M":
                  month = getMonthName();
                  break;
                case "y":
                  var iSave = iFormat;
                  shortYear = !doubled("y", 2);
                  iFormat = iSave;
                  year = getNumber("y", 2);
                  break;
                case "Y":
                  year = getNumber("Y", 2);
                  break;
                case "J":
                  jd = getNumber("J") + 0.5;
                  if (value.charAt(iValue) === ".") {
                    iValue++;
                    getNumber("J");
                  }
                  break;
                case "@":
                  jd = getNumber("@") / this.SECS_PER_DAY + this.UNIX_EPOCH;
                  break;
                case "!":
                  jd = getNumber("!") / this.TICKS_PER_DAY + this.TICKS_EPOCH;
                  break;
                case "*":
                  iValue = value.length;
                  break;
                case "'":
                  if (doubled("'")) {
                    checkLiteral();
                  } else {
                    literal = true;
                  }
                  break;
                default:
                  checkLiteral();
              }
            }
          }
          if (iValue < value.length) {
            throw main.local.unexpectedText || main.regionalOptions[""].unexpectedText;
          }
          if (year === -1) {
            year = this.today().year();
          } else if (year < 100 && shortYear) {
            year += shortYearCutoff === -1 ? 1900 : this.today().year() - this.today().year() % 100 - (year <= shortYearCutoff ? 0 : 100);
          }
          if (typeof month === "string") {
            month = parseMonth.call(this, year, month);
          }
          if (doy > -1) {
            month = 1;
            day = doy;
            for (var dim = this.daysInMonth(year, month); day > dim; dim = this.daysInMonth(year, month)) {
              month++;
              day -= dim;
            }
          }
          return jd > -1 ? this.fromJD(jd) : this.newDate(year, month, day);
        },
        /** A date may be specified as an exact value or a relative one.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar
            @param dateSpec {CDate|number|string} The date as an object or string in the given format or
                    an offset - numeric days from today, or string amounts and periods, e.g. '+1m +2w'.
            @param defaultDate {CDate} The date to use if no other supplied, may be <code>null</code>.
            @param currentDate {CDate} The current date as a possible basis for relative dates,
                    if <code>null</code> today is used (optional)
            @param [dateFormat] {string} The expected date format - see <a href="#formatDate"><code>formatDate</code></a>.
            @param [settings] {object} Additional options whose attributes include:
            @property [shortYearCutoff] {number} The cutoff year for determining the century.
            @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
            @property [dayNames] {string[]} Names of the days from Sunday.
            @property [monthNamesShort] {string[]} Abbreviated names of the months.
            @property [monthNames] {string[]} Names of the months.
            @return {CDate} The decoded date. */
        determineDate: function(dateSpec, defaultDate, currentDate, dateFormat, settings) {
          if (currentDate && typeof currentDate !== "object") {
            settings = dateFormat;
            dateFormat = currentDate;
            currentDate = null;
          }
          if (typeof dateFormat !== "string") {
            settings = dateFormat;
            dateFormat = "";
          }
          var calendar = this;
          var offsetString = function(offset) {
            try {
              return calendar.parseDate(dateFormat, offset, settings);
            } catch (e) {
            }
            offset = offset.toLowerCase();
            var date = (offset.match(/^c/) && currentDate ? currentDate.newDate() : null) || calendar.today();
            var pattern = /([+-]?[0-9]+)\s*(d|w|m|y)?/g;
            var matches = pattern.exec(offset);
            while (matches) {
              date.add(parseInt(matches[1], 10), matches[2] || "d");
              matches = pattern.exec(offset);
            }
            return date;
          };
          defaultDate = defaultDate ? defaultDate.newDate() : null;
          dateSpec = dateSpec == null ? defaultDate : typeof dateSpec === "string" ? offsetString(dateSpec) : typeof dateSpec === "number" ? isNaN(dateSpec) || dateSpec === Infinity || dateSpec === -Infinity ? defaultDate : calendar.today().add(dateSpec, "d") : calendar.newDate(dateSpec);
          return dateSpec;
        }
      });
    }
  });

  // node_modules/world-calendars/dist/calendars/chinese.js
  var require_chinese = __commonJS({
    "node_modules/world-calendars/dist/calendars/chinese.js"() {
      var main = require_main();
      var assign = require_object_assign();
      var gregorianCalendar = main.instance();
      function ChineseCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      ChineseCalendar.prototype = new main.baseCalendar();
      assign(ChineseCalendar.prototype, {
        /** The calendar name.
            @memberof ChineseCalendar */
        name: "Chinese",
        /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
           @memberof GregorianCalendar */
        jdEpoch: 17214255e-1,
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof ChineseCalendar */
        hasYearZero: false,
        /** The minimum month number.
            This calendar uses month indices to account for intercalary months. 
            @memberof ChineseCalendar */
        minMonth: 0,
        /** The first month in the year.
            This calendar uses month indices to account for intercalary months. 
            @memberof ChineseCalendar */
        firstMonth: 0,
        /** The minimum day number.
            @memberof ChineseCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof ChineseCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Chinese",
            epochs: ["BEC", "EC"],
            monthNumbers: function(date, padded) {
              if (typeof date === "string") {
                var match = date.match(MONTH_NUMBER_REGEXP);
                return match ? match[0] : "";
              }
              var year = this._validateYear(date);
              var monthIndex = date.month();
              var month = "" + this.toChineseMonth(year, monthIndex);
              if (padded && month.length < 2) {
                month = "0" + month;
              }
              if (this.isIntercalaryMonth(year, monthIndex)) {
                month += "i";
              }
              return month;
            },
            monthNames: function(date) {
              if (typeof date === "string") {
                var match = date.match(MONTH_NAME_REGEXP);
                return match ? match[0] : "";
              }
              var year = this._validateYear(date);
              var monthIndex = date.month();
              var month = this.toChineseMonth(year, monthIndex);
              var monthName = [
                "\u4E00\u6708",
                "\u4E8C\u6708",
                "\u4E09\u6708",
                "\u56DB\u6708",
                "\u4E94\u6708",
                "\u516D\u6708",
                "\u4E03\u6708",
                "\u516B\u6708",
                "\u4E5D\u6708",
                "\u5341\u6708",
                "\u5341\u4E00\u6708",
                "\u5341\u4E8C\u6708"
              ][month - 1];
              if (this.isIntercalaryMonth(year, monthIndex)) {
                monthName = "\u95F0" + monthName;
              }
              return monthName;
            },
            monthNamesShort: function(date) {
              if (typeof date === "string") {
                var match = date.match(MONTH_SHORT_NAME_REGEXP);
                return match ? match[0] : "";
              }
              var year = this._validateYear(date);
              var monthIndex = date.month();
              var month = this.toChineseMonth(year, monthIndex);
              var monthName = [
                "\u4E00",
                "\u4E8C",
                "\u4E09",
                "\u56DB",
                "\u4E94",
                "\u516D",
                "\u4E03",
                "\u516B",
                "\u4E5D",
                "\u5341",
                "\u5341\u4E00",
                "\u5341\u4E8C"
              ][month - 1];
              if (this.isIntercalaryMonth(year, monthIndex)) {
                monthName = "\u95F0" + monthName;
              }
              return monthName;
            },
            parseMonth: function(year, monthString) {
              year = this._validateYear(year);
              var month = parseInt(monthString);
              var isIntercalary;
              if (!isNaN(month)) {
                var i = monthString[monthString.length - 1];
                isIntercalary = i === "i" || i === "I";
              } else {
                if (monthString[0] === "\u95F0") {
                  isIntercalary = true;
                  monthString = monthString.substring(1);
                }
                if (monthString[monthString.length - 1] === "\u6708") {
                  monthString = monthString.substring(0, monthString.length - 1);
                }
                month = 1 + [
                  "\u4E00",
                  "\u4E8C",
                  "\u4E09",
                  "\u56DB",
                  "\u4E94",
                  "\u516D",
                  "\u4E03",
                  "\u516B",
                  "\u4E5D",
                  "\u5341",
                  "\u5341\u4E00",
                  "\u5341\u4E8C"
                ].indexOf(monthString);
              }
              var monthIndex = this.toMonthIndex(year, month, isIntercalary);
              return monthIndex;
            },
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 1,
            isRTL: false
          }
        },
        /** Check that a candidate date is from the same calendar and is valid.
            @memberof BaseCalendar
            @private
            @param year {CDate|number} The date or the year to validate.
            @param error {string} Error message if invalid.
            @return {number} The year.
            @throws Error if year out of range. */
        _validateYear: function(year, error) {
          if (year.year) {
            year = year.year();
          }
          if (typeof year !== "number" || year < 1888 || year > 2111) {
            throw error.replace(/\{0\}/, this.local.name);
          }
          return year;
        },
        /** Retrieve the month index (i.e. accounting for intercalary months).
            @memberof ChineseCalendar
            @param year {number} The year.
            @param month {number} The month (1 for first month).
            @param [isIntercalary=false] {boolean} If month is intercalary.
            @return {number} The month index (0 for first month).
            @throws Error if an invalid month/year or a different calendar used. */
        toMonthIndex: function(year, month, isIntercalary) {
          var intercalaryMonth = this.intercalaryMonth(year);
          var invalidIntercalaryMonth = isIntercalary && month !== intercalaryMonth;
          if (invalidIntercalaryMonth || month < 1 || month > 12) {
            throw main.local.invalidMonth.replace(/\{0\}/, this.local.name);
          }
          var monthIndex;
          if (!intercalaryMonth) {
            monthIndex = month - 1;
          } else if (!isIntercalary && month <= intercalaryMonth) {
            monthIndex = month - 1;
          } else {
            monthIndex = month;
          }
          return monthIndex;
        },
        /** Retrieve the month (i.e. accounting for intercalary months).
            @memberof ChineseCalendar
            @param year {CDate|number} The date or the year to examine.
            @param monthIndex {number} The month index (0 for first month).
            @return {number} The month (1 for first month).
            @throws Error if an invalid month/year or a different calendar used. */
        toChineseMonth: function(year, monthIndex) {
          if (year.year) {
            year = year.year();
            monthIndex = year.month();
          }
          var intercalaryMonth = this.intercalaryMonth(year);
          var maxMonthIndex = intercalaryMonth ? 12 : 11;
          if (monthIndex < 0 || monthIndex > maxMonthIndex) {
            throw main.local.invalidMonth.replace(/\{0\}/, this.local.name);
          }
          var month;
          if (!intercalaryMonth) {
            month = monthIndex + 1;
          } else if (monthIndex < intercalaryMonth) {
            month = monthIndex + 1;
          } else {
            month = monthIndex;
          }
          return month;
        },
        /** Determine the intercalary month of a year (if any).
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The intercalary month number, or 0 if none.
            @throws Error if an invalid year or a different calendar used. */
        intercalaryMonth: function(year) {
          year = this._validateYear(year);
          var monthDaysTable = LUNAR_MONTH_DAYS[year - LUNAR_MONTH_DAYS[0]];
          var intercalaryMonth = monthDaysTable >> 13;
          return intercalaryMonth;
        },
        /** Determine whether this date is an intercalary month.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [monthIndex] {number} The month index to examine.
            @return {boolean} <code>true</code> if this is an intercalary month, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        isIntercalaryMonth: function(year, monthIndex) {
          if (year.year) {
            year = year.year();
            monthIndex = year.month();
          }
          var intercalaryMonth = this.intercalaryMonth(year);
          return !!intercalaryMonth && intercalaryMonth === monthIndex;
        },
        /** Determine whether this date is in a leap year.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          return this.intercalaryMonth(year) !== 0;
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [monthIndex] {number} The month index to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, monthIndex, day) {
          var validatedYear = this._validateYear(year, main.local.invalidyear);
          var packedDate = CHINESE_NEW_YEAR[validatedYear - CHINESE_NEW_YEAR[0]];
          var y = packedDate >> 9 & 4095;
          var m = packedDate >> 5 & 15;
          var d = packedDate & 31;
          var firstThursday;
          firstThursday = gregorianCalendar.newDate(y, m, d);
          firstThursday.add(4 - (firstThursday.dayOfWeek() || 7), "d");
          var offset = this.toJD(year, monthIndex, day) - firstThursday.toJD();
          return 1 + Math.floor(offset / 7);
        },
        /** Retrieve the number of months in a year.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          return this.leapYear(year) ? 13 : 12;
        },
        /** Retrieve the number of days in a month.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [monthIndex] {number} The month index.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, monthIndex) {
          if (year.year) {
            monthIndex = year.month();
            year = year.year();
          }
          year = this._validateYear(year);
          var monthDaysTable = LUNAR_MONTH_DAYS[year - LUNAR_MONTH_DAYS[0]];
          var intercalaryMonth = monthDaysTable >> 13;
          var maxMonthIndex = intercalaryMonth ? 12 : 11;
          if (monthIndex > maxMonthIndex) {
            throw main.local.invalidMonth.replace(/\{0\}/, this.local.name);
          }
          var daysInMonth = monthDaysTable & 1 << 12 - monthIndex ? 30 : 29;
          return daysInMonth;
        },
        /** Determine whether this date is a week day.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [monthIndex] {number} The month index to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, monthIndex, day) {
          return (this.dayOfWeek(year, monthIndex, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [monthIndex] {number} The month index to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, monthIndex, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = this._validateYear(date.year());
          monthIndex = date.month();
          day = date.day();
          var isIntercalary = this.isIntercalaryMonth(year, monthIndex);
          var month = this.toChineseMonth(year, monthIndex);
          var solar = toSolar(year, month, day, isIntercalary);
          return gregorianCalendar.toJD(solar.year, solar.month, solar.day);
        },
        /** Create a new date from a Julian date.
            @memberof ChineseCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var date = gregorianCalendar.fromJD(jd);
          var lunar = toLunar(date.year(), date.month(), date.day());
          var monthIndex = this.toMonthIndex(
            lunar.year,
            lunar.month,
            lunar.isIntercalary
          );
          return this.newDate(lunar.year, monthIndex, lunar.day);
        },
        /** Create a new date from a string.
            @memberof ChineseCalendar
            @param dateString {string} String representing a Chinese date
            @return {CDate} The new date.
            @throws Error if an invalid date. */
        fromString: function(dateString) {
          var match = dateString.match(DATE_REGEXP);
          var year = this._validateYear(+match[1]);
          var month = +match[2];
          var isIntercalary = !!match[3];
          var monthIndex = this.toMonthIndex(year, month, isIntercalary);
          var day = +match[4];
          return this.newDate(year, monthIndex, day);
        },
        /** Add period(s) to a date.
            Cater for no year zero.
            @memberof ChineseCalendar
            @param date {CDate} The starting date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if a different calendar used. */
        add: function(date, offset, period) {
          var year = date.year();
          var monthIndex = date.month();
          var isIntercalary = this.isIntercalaryMonth(year, monthIndex);
          var month = this.toChineseMonth(year, monthIndex);
          var cdate = Object.getPrototypeOf(ChineseCalendar.prototype).add.call(this, date, offset, period);
          if (period === "y") {
            var resultYear = cdate.year();
            var resultMonthIndex = cdate.month();
            var resultCanBeIntercalaryMonth = this.isIntercalaryMonth(resultYear, month);
            var correctedMonthIndex = isIntercalary && resultCanBeIntercalaryMonth ? this.toMonthIndex(resultYear, month, true) : this.toMonthIndex(resultYear, month, false);
            if (correctedMonthIndex !== resultMonthIndex) {
              cdate.month(correctedMonthIndex);
            }
          }
          return cdate;
        }
      });
      var DATE_REGEXP = /^\s*(-?\d\d\d\d|\d\d)[-/](\d?\d)([iI]?)[-/](\d?\d)/m;
      var MONTH_NUMBER_REGEXP = /^\d?\d[iI]?/m;
      var MONTH_NAME_REGEXP = /^??[]?/m;
      var MONTH_SHORT_NAME_REGEXP = /^??[]?/m;
      main.calendars.chinese = ChineseCalendar;
      var LUNAR_MONTH_DAYS = [
        1887,
        5780,
        5802,
        19157,
        2742,
        50359,
        1198,
        2646,
        46378,
        7466,
        3412,
        30122,
        5482,
        67949,
        2396,
        5294,
        43597,
        6732,
        6954,
        36181,
        2772,
        4954,
        18781,
        2396,
        54427,
        5274,
        6730,
        47781,
        5800,
        6868,
        21210,
        4790,
        59703,
        2350,
        5270,
        46667,
        3402,
        3496,
        38325,
        1388,
        4782,
        18735,
        2350,
        52374,
        6804,
        7498,
        44457,
        2906,
        1388,
        29294,
        4700,
        63789,
        6442,
        6804,
        56138,
        5802,
        2772,
        38235,
        1210,
        4698,
        22827,
        5418,
        63125,
        3476,
        5802,
        43701,
        2484,
        5302,
        27223,
        2646,
        70954,
        7466,
        3412,
        54698,
        5482,
        2412,
        38062,
        5294,
        2636,
        32038,
        6954,
        60245,
        2772,
        4826,
        43357,
        2394,
        5274,
        39501,
        6730,
        72357,
        5800,
        5844,
        53978,
        4790,
        2358,
        38039,
        5270,
        87627,
        3402,
        3496,
        54708,
        5484,
        4782,
        43311,
        2350,
        3222,
        27978,
        7498,
        68965,
        2904,
        5484,
        45677,
        4700,
        6444,
        39573,
        6804,
        6986,
        19285,
        2772,
        62811,
        1210,
        4698,
        47403,
        5418,
        5780,
        38570,
        5546,
        76469,
        2420,
        5302,
        51799,
        2646,
        5414,
        36501,
        3412,
        5546,
        18869,
        2412,
        54446,
        5276,
        6732,
        48422,
        6822,
        2900,
        28010,
        4826,
        92509,
        2394,
        5274,
        55883,
        6730,
        6820,
        47956,
        5812,
        2778,
        18779,
        2358,
        62615,
        5270,
        5450,
        46757,
        3492,
        5556,
        27318,
        4718,
        67887,
        2350,
        3222,
        52554,
        7498,
        3428,
        38252,
        5468,
        4700,
        31022,
        6444,
        64149,
        6804,
        6986,
        43861,
        2772,
        5338,
        35421,
        2650,
        70955,
        5418,
        5780,
        54954,
        5546,
        2740,
        38074,
        5302,
        2646,
        29991,
        3366,
        61011,
        3412,
        5546,
        43445,
        2412,
        5294,
        35406,
        6732,
        72998,
        6820,
        6996,
        52586,
        2778,
        2396,
        38045,
        5274,
        6698,
        23333,
        6820,
        64338,
        5812,
        2746,
        43355,
        2358,
        5270,
        39499,
        5450,
        79525,
        3492,
        5548
      ];
      var CHINESE_NEW_YEAR = [
        1887,
        966732,
        967231,
        967733,
        968265,
        968766,
        969297,
        969798,
        970298,
        970829,
        971330,
        971830,
        972362,
        972863,
        973395,
        973896,
        974397,
        974928,
        975428,
        975929,
        976461,
        976962,
        977462,
        977994,
        978494,
        979026,
        979526,
        980026,
        980558,
        981059,
        981559,
        982091,
        982593,
        983124,
        983624,
        984124,
        984656,
        985157,
        985656,
        986189,
        986690,
        987191,
        987722,
        988222,
        988753,
        989254,
        989754,
        990286,
        990788,
        991288,
        991819,
        992319,
        992851,
        993352,
        993851,
        994383,
        994885,
        995385,
        995917,
        996418,
        996918,
        997450,
        997949,
        998481,
        998982,
        999483,
        1000014,
        1000515,
        1001016,
        1001548,
        1002047,
        1002578,
        1003080,
        1003580,
        1004111,
        1004613,
        1005113,
        1005645,
        1006146,
        1006645,
        1007177,
        1007678,
        1008209,
        1008710,
        1009211,
        1009743,
        1010243,
        1010743,
        1011275,
        1011775,
        1012306,
        1012807,
        1013308,
        1013840,
        1014341,
        1014841,
        1015373,
        1015874,
        1016404,
        1016905,
        1017405,
        1017937,
        1018438,
        1018939,
        1019471,
        1019972,
        1020471,
        1021002,
        1021503,
        1022035,
        1022535,
        1023036,
        1023568,
        1024069,
        1024568,
        1025100,
        1025601,
        1026102,
        1026633,
        1027133,
        1027666,
        1028167,
        1028666,
        1029198,
        1029699,
        1030199,
        1030730,
        1031231,
        1031763,
        1032264,
        1032764,
        1033296,
        1033797,
        1034297,
        1034828,
        1035329,
        1035830,
        1036362,
        1036861,
        1037393,
        1037894,
        1038394,
        1038925,
        1039427,
        1039927,
        1040459,
        1040959,
        1041491,
        1041992,
        1042492,
        1043023,
        1043524,
        1044024,
        1044556,
        1045057,
        1045558,
        1046090,
        1046590,
        1047121,
        1047622,
        1048122,
        1048654,
        1049154,
        1049655,
        1050187,
        1050689,
        1051219,
        1051720,
        1052220,
        1052751,
        1053252,
        1053752,
        1054284,
        1054786,
        1055285,
        1055817,
        1056317,
        1056849,
        1057349,
        1057850,
        1058382,
        1058883,
        1059383,
        1059915,
        1060415,
        1060947,
        1061447,
        1061947,
        1062479,
        1062981,
        1063480,
        1064012,
        1064514,
        1065014,
        1065545,
        1066045,
        1066577,
        1067078,
        1067578,
        1068110,
        1068611,
        1069112,
        1069642,
        1070142,
        1070674,
        1071175,
        1071675,
        1072207,
        1072709,
        1073209,
        1073740,
        1074241,
        1074741,
        1075273,
        1075773,
        1076305,
        1076807,
        1077308,
        1077839,
        1078340,
        1078840,
        1079372,
        1079871,
        1080403,
        1080904
      ];
      function toLunar(yearOrDate, monthOrResult, day, result) {
        var solarDate;
        var lunarDate;
        if (typeof yearOrDate === "object") {
          solarDate = yearOrDate;
          lunarDate = monthOrResult || {};
        } else {
          var isValidYear = typeof yearOrDate === "number" && yearOrDate >= 1888 && yearOrDate <= 2111;
          if (!isValidYear)
            throw new Error("Solar year outside range 1888-2111");
          var isValidMonth = typeof monthOrResult === "number" && monthOrResult >= 1 && monthOrResult <= 12;
          if (!isValidMonth)
            throw new Error("Solar month outside range 1 - 12");
          var isValidDay = typeof day === "number" && day >= 1 && day <= 31;
          if (!isValidDay)
            throw new Error("Solar day outside range 1 - 31");
          solarDate = {
            year: yearOrDate,
            month: monthOrResult,
            day
          };
          lunarDate = result || {};
        }
        var chineseNewYearPackedDate = CHINESE_NEW_YEAR[solarDate.year - CHINESE_NEW_YEAR[0]];
        var packedDate = solarDate.year << 9 | solarDate.month << 5 | solarDate.day;
        lunarDate.year = packedDate >= chineseNewYearPackedDate ? solarDate.year : solarDate.year - 1;
        chineseNewYearPackedDate = CHINESE_NEW_YEAR[lunarDate.year - CHINESE_NEW_YEAR[0]];
        var y = chineseNewYearPackedDate >> 9 & 4095;
        var m = chineseNewYearPackedDate >> 5 & 15;
        var d = chineseNewYearPackedDate & 31;
        var daysFromNewYear;
        var chineseNewYearJSDate = new Date(y, m - 1, d);
        var jsDate = new Date(solarDate.year, solarDate.month - 1, solarDate.day);
        daysFromNewYear = Math.round(
          (jsDate - chineseNewYearJSDate) / (24 * 3600 * 1e3)
        );
        var monthDaysTable = LUNAR_MONTH_DAYS[lunarDate.year - LUNAR_MONTH_DAYS[0]];
        var i;
        for (i = 0; i < 13; i++) {
          var daysInMonth = monthDaysTable & 1 << 12 - i ? 30 : 29;
          if (daysFromNewYear < daysInMonth) {
            break;
          }
          daysFromNewYear -= daysInMonth;
        }
        var intercalaryMonth = monthDaysTable >> 13;
        if (!intercalaryMonth || i < intercalaryMonth) {
          lunarDate.isIntercalary = false;
          lunarDate.month = 1 + i;
        } else if (i === intercalaryMonth) {
          lunarDate.isIntercalary = true;
          lunarDate.month = i;
        } else {
          lunarDate.isIntercalary = false;
          lunarDate.month = i;
        }
        lunarDate.day = 1 + daysFromNewYear;
        return lunarDate;
      }
      function toSolar(yearOrDate, monthOrResult, day, isIntercalaryOrResult, result) {
        var solarDate;
        var lunarDate;
        if (typeof yearOrDate === "object") {
          lunarDate = yearOrDate;
          solarDate = monthOrResult || {};
        } else {
          var isValidYear = typeof yearOrDate === "number" && yearOrDate >= 1888 && yearOrDate <= 2111;
          if (!isValidYear)
            throw new Error("Lunar year outside range 1888-2111");
          var isValidMonth = typeof monthOrResult === "number" && monthOrResult >= 1 && monthOrResult <= 12;
          if (!isValidMonth)
            throw new Error("Lunar month outside range 1 - 12");
          var isValidDay = typeof day === "number" && day >= 1 && day <= 30;
          if (!isValidDay)
            throw new Error("Lunar day outside range 1 - 30");
          var isIntercalary;
          if (typeof isIntercalaryOrResult === "object") {
            isIntercalary = false;
            solarDate = isIntercalaryOrResult;
          } else {
            isIntercalary = !!isIntercalaryOrResult;
            solarDate = result || {};
          }
          lunarDate = {
            year: yearOrDate,
            month: monthOrResult,
            day,
            isIntercalary
          };
        }
        var daysFromNewYear;
        daysFromNewYear = lunarDate.day - 1;
        var monthDaysTable = LUNAR_MONTH_DAYS[lunarDate.year - LUNAR_MONTH_DAYS[0]];
        var intercalaryMonth = monthDaysTable >> 13;
        var monthsFromNewYear;
        if (!intercalaryMonth) {
          monthsFromNewYear = lunarDate.month - 1;
        } else if (lunarDate.month > intercalaryMonth) {
          monthsFromNewYear = lunarDate.month;
        } else if (lunarDate.isIntercalary) {
          monthsFromNewYear = lunarDate.month;
        } else {
          monthsFromNewYear = lunarDate.month - 1;
        }
        for (var i = 0; i < monthsFromNewYear; i++) {
          var daysInMonth = monthDaysTable & 1 << 12 - i ? 30 : 29;
          daysFromNewYear += daysInMonth;
        }
        var packedDate = CHINESE_NEW_YEAR[lunarDate.year - CHINESE_NEW_YEAR[0]];
        var y = packedDate >> 9 & 4095;
        var m = packedDate >> 5 & 15;
        var d = packedDate & 31;
        var jsDate = new Date(y, m - 1, d + daysFromNewYear);
        solarDate.year = jsDate.getFullYear();
        solarDate.month = 1 + jsDate.getMonth();
        solarDate.day = jsDate.getDate();
        return solarDate;
      }
    }
  });

  // node_modules/world-calendars/dist/calendars/coptic.js
  var require_coptic = __commonJS({
    "node_modules/world-calendars/dist/calendars/coptic.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function CopticCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      CopticCalendar.prototype = new main.baseCalendar();
      assign(CopticCalendar.prototype, {
        /** The calendar name.
            @memberof CopticCalendar */
        name: "Coptic",
        /** Julian date of start of Coptic epoch: 29 August 284 CE (Gregorian).
            @memberof CopticCalendar */
        jdEpoch: 18250295e-1,
        /** Days per month in a common year.
            @memberof CopticCalendar */
        daysPerMonth: [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 5],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof CopticCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof CopticCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof CopticCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof CopticCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof CopticCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Coptic",
            epochs: ["BAM", "AM"],
            monthNames: [
              "Thout",
              "Paopi",
              "Hathor",
              "Koiak",
              "Tobi",
              "Meshir",
              "Paremhat",
              "Paremoude",
              "Pashons",
              "Paoni",
              "Epip",
              "Mesori",
              "Pi Kogi Enavot"
            ],
            monthNamesShort: [
              "Tho",
              "Pao",
              "Hath",
              "Koi",
              "Tob",
              "Mesh",
              "Pat",
              "Pad",
              "Pash",
              "Pao",
              "Epi",
              "Meso",
              "PiK"
            ],
            dayNames: ["Tkyriaka", "Pesnau", "Pshoment", "Peftoou", "Ptiou", "Psoou", "Psabbaton"],
            dayNamesShort: ["Tky", "Pes", "Psh", "Pef", "Pti", "Pso", "Psa"],
            dayNamesMin: ["Tk", "Pes", "Psh", "Pef", "Pt", "Pso", "Psa"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = date.year() + (date.year() < 0 ? 1 : 0);
          return year % 4 === 3 || year % 4 === -1;
        },
        /** Retrieve the number of months in a year.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(
            year,
            this.minMonth,
            this.minDay,
            main.local.invalidYear || main.regionalOptions[""].invalidYear
          );
          return 13;
        },
        /** Determine the week of the year for a date.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number) the month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 13 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param month {number} The month to examine.
            @param day {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof CopticCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number) the month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          if (year < 0) {
            year++;
          }
          return date.day() + (date.month() - 1) * 30 + (year - 1) * 365 + Math.floor(year / 4) + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof CopticCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var c = Math.floor(jd) + 0.5 - this.jdEpoch;
          var year = Math.floor((c - Math.floor((c + 366) / 1461)) / 365) + 1;
          if (year <= 0) {
            year--;
          }
          c = Math.floor(jd) + 0.5 - this.newDate(year, 1, 1).toJD();
          var month = Math.floor(c / 30) + 1;
          var day = c - (month - 1) * 30 + 1;
          return this.newDate(year, month, day);
        }
      });
      main.calendars.coptic = CopticCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/discworld.js
  var require_discworld = __commonJS({
    "node_modules/world-calendars/dist/calendars/discworld.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function DiscworldCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      DiscworldCalendar.prototype = new main.baseCalendar();
      assign(DiscworldCalendar.prototype, {
        /** The calendar name.
            @memberof DiscworldCalendar */
        name: "Discworld",
        /** Julian date of start of Discworld epoch: 1 January 0001 CE.
            @memberof DiscworldCalendar */
        jdEpoch: 17214255e-1,
        /** Days per month in a common year.
            @memberof DiscworldCalendar */
        daysPerMonth: [16, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof DiscworldCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof DiscworldCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof DiscworldCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof DiscworldCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof DiscworldCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Discworld",
            epochs: ["BUC", "UC"],
            monthNames: [
              "Ick",
              "Offle",
              "February",
              "March",
              "April",
              "May",
              "June",
              "Grune",
              "August",
              "Spune",
              "Sektober",
              "Ember",
              "December"
            ],
            monthNamesShort: ["Ick", "Off", "Feb", "Mar", "Apr", "May", "Jun", "Gru", "Aug", "Spu", "Sek", "Emb", "Dec"],
            dayNames: ["Sunday", "Octeday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Oct", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Oc", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 2,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return false;
        },
        /** Retrieve the number of months in a year.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 13;
        },
        /** Retrieve the number of days in a year.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 400;
        },
        /** Determine the week of the year for a date.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 8) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1];
        },
        /** Retrieve the number of days in a week.
            @memberof DiscworldCalendar
            @return {number} The number of days. */
        daysInWeek: function() {
          return 8;
        },
        /** Retrieve the day of the week for a date.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The day of the week: 0 to number of days - 1.
            @throws Error if an invalid date or a different calendar used. */
        dayOfWeek: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return (date.day() + 1) % 8;
        },
        /** Determine whether this date is a week day.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          var dow = this.dayOfWeek(year, month, day);
          return dow >= 2 && dow <= 6;
        },
        /** Retrieve additional information about a date.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return { century: centuries[Math.floor((date.year() - 1) / 100) + 1] || "" };
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year() + (date.year() < 0 ? 1 : 0);
          month = date.month();
          day = date.day();
          return day + (month > 1 ? 16 : 0) + (month > 2 ? (month - 2) * 32 : 0) + (year - 1) * 400 + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof DiscworldCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd + 0.5) - Math.floor(this.jdEpoch) - 1;
          var year = Math.floor(jd / 400) + 1;
          jd -= (year - 1) * 400;
          jd += jd > 15 ? 16 : 0;
          var month = Math.floor(jd / 32) + 1;
          var day = jd - (month - 1) * 32 + 1;
          return this.newDate(year <= 0 ? year - 1 : year, month, day);
        }
      });
      var centuries = {
        20: "Fruitbat",
        21: "Anchovy"
      };
      main.calendars.discworld = DiscworldCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/ethiopian.js
  var require_ethiopian = __commonJS({
    "node_modules/world-calendars/dist/calendars/ethiopian.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function EthiopianCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      EthiopianCalendar.prototype = new main.baseCalendar();
      assign(EthiopianCalendar.prototype, {
        /** The calendar name.
            @memberof EthiopianCalendar */
        name: "Ethiopian",
        /** Julian date of start of Ethiopian epoch: 27 August 8 CE (Gregorian).
            @memberof EthiopianCalendar */
        jdEpoch: 17242205e-1,
        /** Days per month in a common year.
            @memberof EthiopianCalendar */
        daysPerMonth: [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 5],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof EthiopianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof EthiopianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof EthiopianCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof EthiopianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof EthiopianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Ethiopian",
            epochs: ["BEE", "EE"],
            monthNames: [
              "Meskerem",
              "Tikemet",
              "Hidar",
              "Tahesas",
              "Tir",
              "Yekatit",
              "Megabit",
              "Miazia",
              "Genbot",
              "Sene",
              "Hamle",
              "Nehase",
              "Pagume"
            ],
            monthNamesShort: [
              "Mes",
              "Tik",
              "Hid",
              "Tah",
              "Tir",
              "Yek",
              "Meg",
              "Mia",
              "Gen",
              "Sen",
              "Ham",
              "Neh",
              "Pag"
            ],
            dayNames: ["Ehud", "Segno", "Maksegno", "Irob", "Hamus", "Arb", "Kidame"],
            dayNamesShort: ["Ehu", "Seg", "Mak", "Iro", "Ham", "Arb", "Kid"],
            dayNamesMin: ["Eh", "Se", "Ma", "Ir", "Ha", "Ar", "Ki"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = date.year() + (date.year() < 0 ? 1 : 0);
          return year % 4 === 3 || year % 4 === -1;
        },
        /** Retrieve the number of months in a year.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(
            year,
            this.minMonth,
            this.minDay,
            main.local.invalidYear || main.regionalOptions[""].invalidYear
          );
          return 13;
        },
        /** Determine the week of the year for a date.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 13 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          if (year < 0) {
            year++;
          }
          return date.day() + (date.month() - 1) * 30 + (year - 1) * 365 + Math.floor(year / 4) + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof EthiopianCalendar
            @param jd {number} the Julian date to convert.
            @return {CDate} the equivalent date. */
        fromJD: function(jd) {
          var c = Math.floor(jd) + 0.5 - this.jdEpoch;
          var year = Math.floor((c - Math.floor((c + 366) / 1461)) / 365) + 1;
          if (year <= 0) {
            year--;
          }
          c = Math.floor(jd) + 0.5 - this.newDate(year, 1, 1).toJD();
          var month = Math.floor(c / 30) + 1;
          var day = c - (month - 1) * 30 + 1;
          return this.newDate(year, month, day);
        }
      });
      main.calendars.ethiopian = EthiopianCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/hebrew.js
  var require_hebrew = __commonJS({
    "node_modules/world-calendars/dist/calendars/hebrew.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function HebrewCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      HebrewCalendar.prototype = new main.baseCalendar();
      assign(HebrewCalendar.prototype, {
        /** The calendar name.
            @memberof HebrewCalendar */
        name: "Hebrew",
        /** Julian date of start of Hebrew epoch: 7 October 3761 BCE.
            @memberof HebrewCalendar */
        jdEpoch: 347995.5,
        /** Days per month in a common year.
            @memberof HebrewCalendar */
        daysPerMonth: [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 29],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof HebrewCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof HebrewCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof HebrewCalendar */
        firstMonth: 7,
        /** The minimum day number.
            @memberof HebrewCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof HebrewCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Hebrew",
            epochs: ["BAM", "AM"],
            monthNames: [
              "Nisan",
              "Iyar",
              "Sivan",
              "Tammuz",
              "Av",
              "Elul",
              "Tishrei",
              "Cheshvan",
              "Kislev",
              "Tevet",
              "Shevat",
              "Adar",
              "Adar II"
            ],
            monthNamesShort: ["Nis", "Iya", "Siv", "Tam", "Av", "Elu", "Tis", "Che", "Kis", "Tev", "She", "Ada", "Ad2"],
            dayNames: ["Yom Rishon", "Yom Sheni", "Yom Shlishi", "Yom Revi'i", "Yom Chamishi", "Yom Shishi", "Yom Shabbat"],
            dayNamesShort: ["Ris", "She", "Shl", "Rev", "Cha", "Shi", "Sha"],
            dayNamesMin: ["Ri", "She", "Shl", "Re", "Ch", "Shi", "Sha"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return this._leapYear(date.year());
        },
        /** Determine whether this date is in a leap year.
            @memberof HebrewCalendar
            @private
            @param year {number} The year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        _leapYear: function(year) {
          year = year < 0 ? year + 1 : year;
          return mod(year * 7 + 1, 19) < 7;
        },
        /** Retrieve the number of months in a year.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return this._leapYear(year.year ? year.year() : year) ? 13 : 12;
        },
        /** Determine the week of the year for a date.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          year = date.year();
          return this.toJD(year === -1 ? 1 : year + 1, 7, 1) - this.toJD(year, 7, 1);
        },
        /** Retrieve the number of days in a month.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          if (year.year) {
            month = year.month();
            year = year.year();
          }
          this._validate(year, month, this.minDay, main.local.invalidMonth);
          return month === 12 && this.leapYear(year) ? 30 : (
            // Adar I
            month === 8 && mod(this.daysInYear(year), 10) === 5 ? 30 : (
              // Cheshvan in shlemah year
              month === 9 && mod(this.daysInYear(year), 10) === 3 ? 29 : (
                // Kislev in chaserah year
                this.daysPerMonth[month - 1]
              )
            )
          );
        },
        /** Determine whether this date is a week day.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 6;
        },
        /** Retrieve additional information about a date - year type.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return { yearType: (this.leapYear(date) ? "embolismic" : "common") + " " + ["deficient", "regular", "complete"][this.daysInYear(date) % 10 - 3] };
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof HebrewCalendar
            @param year {CDate)|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          var adjYear = year <= 0 ? year + 1 : year;
          var jd = this.jdEpoch + this._delay1(adjYear) + this._delay2(adjYear) + day + 1;
          if (month < 7) {
            for (var m = 7; m <= this.monthsInYear(year); m++) {
              jd += this.daysInMonth(year, m);
            }
            for (var m = 1; m < month; m++) {
              jd += this.daysInMonth(year, m);
            }
          } else {
            for (var m = 7; m < month; m++) {
              jd += this.daysInMonth(year, m);
            }
          }
          return jd;
        },
        /** Test for delay of start of new year and to avoid
            Sunday, Wednesday, or Friday as start of the new year.
            @memberof HebrewCalendar
            @private
            @param year {number} The year to examine.
            @return {number} The days to offset by. */
        _delay1: function(year) {
          var months = Math.floor((235 * year - 234) / 19);
          var parts = 12084 + 13753 * months;
          var day = months * 29 + Math.floor(parts / 25920);
          if (mod(3 * (day + 1), 7) < 3) {
            day++;
          }
          return day;
        },
        /** Check for delay in start of new year due to length of adjacent years.
            @memberof HebrewCalendar
            @private
            @param year {number} The year to examine.
            @return {number} The days to offset by. */
        _delay2: function(year) {
          var last = this._delay1(year - 1);
          var present = this._delay1(year);
          var next = this._delay1(year + 1);
          return next - present === 356 ? 2 : present - last === 382 ? 1 : 0;
        },
        /** Create a new date from a Julian date.
            @memberof HebrewCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5;
          var year = Math.floor((jd - this.jdEpoch) * 98496 / 35975351) - 1;
          while (jd >= this.toJD(year === -1 ? 1 : year + 1, 7, 1)) {
            year++;
          }
          var month = jd < this.toJD(year, 1, 1) ? 7 : 1;
          while (jd > this.toJD(year, month, this.daysInMonth(year, month))) {
            month++;
          }
          var day = jd - this.toJD(year, month, 1) + 1;
          return this.newDate(year, month, day);
        }
      });
      function mod(a, b) {
        return a - b * Math.floor(a / b);
      }
      main.calendars.hebrew = HebrewCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/islamic.js
  var require_islamic = __commonJS({
    "node_modules/world-calendars/dist/calendars/islamic.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function IslamicCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      IslamicCalendar.prototype = new main.baseCalendar();
      assign(IslamicCalendar.prototype, {
        /** The calendar name.
            @memberof IslamicCalendar */
        name: "Islamic",
        /** Julian date of start of Islamic epoch: 16 July 622 CE.
            @memberof IslamicCalendar */
        jdEpoch: 19484395e-1,
        /** Days per month in a common year.
            @memberof IslamicCalendar */
        daysPerMonth: [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof IslamicCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof IslamicCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof IslamicCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof IslamicCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof IslamicCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Islamic",
            epochs: ["BH", "AH"],
            monthNames: [
              "Muharram",
              "Safar",
              "Rabi' al-awwal",
              "Rabi' al-thani",
              "Jumada al-awwal",
              "Jumada al-thani",
              "Rajab",
              "Sha'aban",
              "Ramadan",
              "Shawwal",
              "Dhu al-Qi'dah",
              "Dhu al-Hijjah"
            ],
            monthNamesShort: ["Muh", "Saf", "Rab1", "Rab2", "Jum1", "Jum2", "Raj", "Sha'", "Ram", "Shaw", "DhuQ", "DhuH"],
            dayNames: [
              "Yawm al-ahad",
              "Yawm al-ithnayn",
              "Yawm ath-thulaathaa'",
              "Yawm al-arbi'aa'",
              "Yawm al-kham\u012Bs",
              "Yawm al-jum'a",
              "Yawm as-sabt"
            ],
            dayNamesShort: ["Aha", "Ith", "Thu", "Arb", "Kha", "Jum", "Sab"],
            dayNamesMin: ["Ah", "It", "Th", "Ar", "Kh", "Ju", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 6,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return (date.year() * 11 + 14) % 30 < 11;
        },
        /** Determine the week of the year for a date.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          return this.leapYear(year) ? 355 : 354;
        },
        /** Retrieve the number of days in a month.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 5;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          year = year <= 0 ? year + 1 : year;
          return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof IslamicCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5;
          var year = Math.floor((30 * (jd - this.jdEpoch) + 10646) / 10631);
          year = year <= 0 ? year - 1 : year;
          var month = Math.min(12, Math.ceil((jd - 29 - this.toJD(year, 1, 1)) / 29.5) + 1);
          var day = jd - this.toJD(year, month, 1) + 1;
          return this.newDate(year, month, day);
        }
      });
      main.calendars.islamic = IslamicCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/julian.js
  var require_julian = __commonJS({
    "node_modules/world-calendars/dist/calendars/julian.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function JulianCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      JulianCalendar.prototype = new main.baseCalendar();
      assign(JulianCalendar.prototype, {
        /** The calendar name.
            @memberof JulianCalendar */
        name: "Julian",
        /** Julian date of start of Julian epoch: 1 January 0001 AD = 30 December 0001 BCE.
            @memberof JulianCalendar */
        jdEpoch: 17214235e-1,
        /** Days per month in a common year.
            @memberof JulianCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof JulianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof JulianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof JulianCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof JulianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof JulianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Julian",
            epochs: ["BC", "AD"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "mm/dd/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = date.year() < 0 ? date.year() + 1 : date.year();
          return year % 4 === 0;
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(4 - (checkDate.dayOfWeek() || 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} True if a week day, false if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof JulianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          if (year < 0) {
            year++;
          }
          if (month <= 2) {
            year--;
            month += 12;
          }
          return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day - 1524.5;
        },
        /** Create a new date from a Julian date.
            @memberof JulianCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var a = Math.floor(jd + 0.5);
          var b = a + 1524;
          var c = Math.floor((b - 122.1) / 365.25);
          var d = Math.floor(365.25 * c);
          var e = Math.floor((b - d) / 30.6001);
          var month = e - Math.floor(e < 14 ? 1 : 13);
          var year = c - Math.floor(month > 2 ? 4716 : 4715);
          var day = b - d - Math.floor(30.6001 * e);
          if (year <= 0) {
            year--;
          }
          return this.newDate(year, month, day);
        }
      });
      main.calendars.julian = JulianCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/mayan.js
  var require_mayan = __commonJS({
    "node_modules/world-calendars/dist/calendars/mayan.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function MayanCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      MayanCalendar.prototype = new main.baseCalendar();
      assign(MayanCalendar.prototype, {
        /** The calendar name.
            @memberof MayanCalendar */
        name: "Mayan",
        /** Julian date of start of Mayan epoch: 11 August 3114 BCE.
            @memberof MayanCalendar */
        jdEpoch: 584282.5,
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof MayanCalendar */
        hasYearZero: true,
        /** The minimum month number.
            @memberof MayanCalendar */
        minMonth: 0,
        /** The first month in the year.
            @memberof MayanCalendar */
        firstMonth: 0,
        /** The minimum day number.
            @memberof MayanCalendar */
        minDay: 0,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof MayanCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left.
            @property haabMonths {string[]} The names of the Haab months.
            @property tzolkinMonths {string[]} The names of the Tzolkin months. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Mayan",
            epochs: ["", ""],
            monthNames: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17"
            ],
            monthNamesShort: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17"
            ],
            dayNames: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17",
              "18",
              "19"
            ],
            dayNamesShort: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17",
              "18",
              "19"
            ],
            dayNamesMin: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17",
              "18",
              "19"
            ],
            digits: null,
            dateFormat: "YYYY.m.d",
            firstDay: 0,
            isRTL: false,
            haabMonths: [
              "Pop",
              "Uo",
              "Zip",
              "Zotz",
              "Tzec",
              "Xul",
              "Yaxkin",
              "Mol",
              "Chen",
              "Yax",
              "Zac",
              "Ceh",
              "Mac",
              "Kankin",
              "Muan",
              "Pax",
              "Kayab",
              "Cumku",
              "Uayeb"
            ],
            tzolkinMonths: [
              "Imix",
              "Ik",
              "Akbal",
              "Kan",
              "Chicchan",
              "Cimi",
              "Manik",
              "Lamat",
              "Muluc",
              "Oc",
              "Chuen",
              "Eb",
              "Ben",
              "Ix",
              "Men",
              "Cib",
              "Caban",
              "Etznab",
              "Cauac",
              "Ahau"
            ]
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return false;
        },
        /** Format the year, if not a simple sequential number.
            @memberof MayanCalendar
            @param year {CDate|number} The date to format or the year to format.
            @return {string} The formatted year.
            @throws Error if an invalid year or a different calendar used. */
        formatYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          year = date.year();
          var baktun = Math.floor(year / 400);
          year = year % 400;
          year += year < 0 ? 400 : 0;
          var katun = Math.floor(year / 20);
          return baktun + "." + katun + "." + year % 20;
        },
        /** Convert from the formatted year back to a single number.
            @memberof MayanCalendar
            @param years {string} The year as n.n.n.
            @return {number} The sequential year.
            @throws Error if an invalid value is supplied. */
        forYear: function(years) {
          years = years.split(".");
          if (years.length < 3) {
            throw "Invalid Mayan year";
          }
          var year = 0;
          for (var i = 0; i < years.length; i++) {
            var y = parseInt(years[i], 10);
            if (Math.abs(y) > 19 || i > 0 && y < 0) {
              throw "Invalid Mayan year";
            }
            year = year * 20 + y;
          }
          return year;
        },
        /** Retrieve the number of months in a year.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 18;
        },
        /** Determine the week of the year for a date.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          this._validate(year, month, day, main.local.invalidDate);
          return 0;
        },
        /** Retrieve the number of days in a year.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 360;
        },
        /** Retrieve the number of days in a month.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          this._validate(year, month, this.minDay, main.local.invalidMonth);
          return 20;
        },
        /** Retrieve the number of days in a week.
            @memberof MayanCalendar
            @return {number} The number of days. */
        daysInWeek: function() {
          return 5;
        },
        /** Retrieve the day of the week for a date.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The day of the week: 0 to number of days - 1.
            @throws Error if an invalid date or a different calendar used. */
        dayOfWeek: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return date.day();
        },
        /** Determine whether this date is a week day.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          this._validate(year, month, day, main.local.invalidDate);
          return true;
        },
        /** Retrieve additional information about a date - Haab and Tzolkin equivalents.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var jd = date.toJD();
          var haab = this._toHaab(jd);
          var tzolkin = this._toTzolkin(jd);
          return {
            haabMonthName: this.local.haabMonths[haab[0] - 1],
            haabMonth: haab[0],
            haabDay: haab[1],
            tzolkinDayName: this.local.tzolkinMonths[tzolkin[0] - 1],
            tzolkinDay: tzolkin[0],
            tzolkinTrecena: tzolkin[1]
          };
        },
        /** Retrieve Haab date from a Julian date.
            @memberof MayanCalendar
            @private
            @param jd  {number} The Julian date.
            @return {number[]} Corresponding Haab month and day. */
        _toHaab: function(jd) {
          jd -= this.jdEpoch;
          var day = mod(jd + 8 + (18 - 1) * 20, 365);
          return [Math.floor(day / 20) + 1, mod(day, 20)];
        },
        /** Retrieve Tzolkin date from a Julian date.
            @memberof MayanCalendar
            @private
            @param jd {number} The Julian date.
            @return {number[]} Corresponding Tzolkin day and trecena. */
        _toTzolkin: function(jd) {
          jd -= this.jdEpoch;
          return [amod(jd + 20, 20), amod(jd + 4, 13)];
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof MayanCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return date.day() + date.month() * 20 + date.year() * 360 + this.jdEpoch;
        },
        /** Create a new date from a Julian date.
            @memberof MayanCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5 - this.jdEpoch;
          var year = Math.floor(jd / 360);
          jd = jd % 360;
          jd += jd < 0 ? 360 : 0;
          var month = Math.floor(jd / 20);
          var day = jd % 20;
          return this.newDate(year, month, day);
        }
      });
      function mod(a, b) {
        return a - b * Math.floor(a / b);
      }
      function amod(a, b) {
        return mod(a - 1, b) + 1;
      }
      main.calendars.mayan = MayanCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/nanakshahi.js
  var require_nanakshahi = __commonJS({
    "node_modules/world-calendars/dist/calendars/nanakshahi.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function NanakshahiCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      NanakshahiCalendar.prototype = new main.baseCalendar();
      var gregorian = main.instance("gregorian");
      assign(NanakshahiCalendar.prototype, {
        /** The calendar name.
            @memberof NanakshahiCalendar */
        name: "Nanakshahi",
        /** Julian date of start of Nanakshahi epoch: 14 March 1469 CE.
            @memberof NanakshahiCalendar */
        jdEpoch: 22576735e-1,
        /** Days per month in a common year.
            @memberof NanakshahiCalendar */
        daysPerMonth: [31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 30, 30],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof NanakshahiCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof NanakshahiCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof NanakshahiCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof NanakshahiCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof NanakshahiCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Nanakshahi",
            epochs: ["BN", "AN"],
            monthNames: [
              "Chet",
              "Vaisakh",
              "Jeth",
              "Harh",
              "Sawan",
              "Bhadon",
              "Assu",
              "Katak",
              "Maghar",
              "Poh",
              "Magh",
              "Phagun"
            ],
            monthNamesShort: ["Che", "Vai", "Jet", "Har", "Saw", "Bha", "Ass", "Kat", "Mgr", "Poh", "Mgh", "Pha"],
            dayNames: ["Somvaar", "Mangalvar", "Budhvaar", "Veervaar", "Shukarvaar", "Sanicharvaar", "Etvaar"],
            dayNamesShort: ["Som", "Mangal", "Budh", "Veer", "Shukar", "Sanichar", "Et"],
            dayNamesMin: ["So", "Ma", "Bu", "Ve", "Sh", "Sa", "Et"],
            digits: null,
            dateFormat: "dd-mm-yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            main.local.invalidYear || main.regionalOptions[""].invalidYear
          );
          return gregorian.leapYear(date.year() + (date.year() < 1 ? 1 : 0) + 1469);
        },
        /** Determine the week of the year for a date.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(1 - (checkDate.dayOfWeek() || 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidMonth);
          var year = date.year();
          if (year < 0) {
            year++;
          }
          var doy = date.day();
          for (var m = 1; m < date.month(); m++) {
            doy += this.daysPerMonth[m - 1];
          }
          return doy + gregorian.toJD(year + 1468, 3, 13);
        },
        /** Create a new date from a Julian date.
            @memberof NanakshahiCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd + 0.5);
          var year = Math.floor((jd - (this.jdEpoch - 1)) / 366);
          while (jd >= this.toJD(year + 1, 1, 1)) {
            year++;
          }
          var day = jd - Math.floor(this.toJD(year, 1, 1) + 0.5) + 1;
          var month = 1;
          while (day > this.daysInMonth(year, month)) {
            day -= this.daysInMonth(year, month);
            month++;
          }
          return this.newDate(year, month, day);
        }
      });
      main.calendars.nanakshahi = NanakshahiCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/nepali.js
  var require_nepali = __commonJS({
    "node_modules/world-calendars/dist/calendars/nepali.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function NepaliCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      NepaliCalendar.prototype = new main.baseCalendar();
      assign(NepaliCalendar.prototype, {
        /** The calendar name.
            @memberof NepaliCalendar */
        name: "Nepali",
        /** Julian date of start of Nepali epoch: 14 April 57 BCE.
            @memberof NepaliCalendar */
        jdEpoch: 17007095e-1,
        /** Days per month in a common year.
            @memberof NepaliCalendar */
        daysPerMonth: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof NepaliCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof NepaliCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof NepaliCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof NepaliCalendar */
        minDay: 1,
        /** The number of days in the year.
            @memberof NepaliCalendar */
        daysPerYear: 365,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof NepaliCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Nepali",
            epochs: ["BBS", "ABS"],
            monthNames: [
              "Baisakh",
              "Jestha",
              "Ashadh",
              "Shrawan",
              "Bhadra",
              "Ashwin",
              "Kartik",
              "Mangsir",
              "Paush",
              "Mangh",
              "Falgun",
              "Chaitra"
            ],
            monthNamesShort: ["Bai", "Je", "As", "Shra", "Bha", "Ash", "Kar", "Mang", "Pau", "Ma", "Fal", "Chai"],
            dayNames: ["Aaitabaar", "Sombaar", "Manglbaar", "Budhabaar", "Bihibaar", "Shukrabaar", "Shanibaar"],
            dayNamesShort: ["Aaita", "Som", "Mangl", "Budha", "Bihi", "Shukra", "Shani"],
            dayNamesMin: ["Aai", "So", "Man", "Bu", "Bi", "Shu", "Sha"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 1,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          return this.daysInYear(year) !== this.daysPerYear;
        },
        /** Determine the week of the year for a date.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          year = date.year();
          if (typeof this.NEPALI_CALENDAR_DATA[year] === "undefined") {
            return this.daysPerYear;
          }
          var daysPerYear = 0;
          for (var month_number = this.minMonth; month_number <= 12; month_number++) {
            daysPerYear += this.NEPALI_CALENDAR_DATA[year][month_number];
          }
          return daysPerYear;
        },
        /** Retrieve the number of days in a month.
            @memberof NepaliCalendar
            @param year {CDate|number| The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          if (year.year) {
            month = year.month();
            year = year.year();
          }
          this._validate(year, month, this.minDay, main.local.invalidMonth);
          return typeof this.NEPALI_CALENDAR_DATA[year] === "undefined" ? this.daysPerMonth[month - 1] : this.NEPALI_CALENDAR_DATA[year][month];
        },
        /** Determine whether this date is a week day.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(nepaliYear, nepaliMonth, nepaliDay) {
          var date = this._validate(nepaliYear, nepaliMonth, nepaliDay, main.local.invalidDate);
          nepaliYear = date.year();
          nepaliMonth = date.month();
          nepaliDay = date.day();
          var gregorianCalendar = main.instance();
          var gregorianDayOfYear = 0;
          var nepaliMonthToCheck = nepaliMonth;
          var nepaliYearToCheck = nepaliYear;
          this._createMissingCalendarData(nepaliYear);
          var gregorianYear = nepaliYear - (nepaliMonthToCheck > 9 || nepaliMonthToCheck === 9 && nepaliDay >= this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0] ? 56 : 57);
          if (nepaliMonth !== 9) {
            gregorianDayOfYear = nepaliDay;
            nepaliMonthToCheck--;
          }
          while (nepaliMonthToCheck !== 9) {
            if (nepaliMonthToCheck <= 0) {
              nepaliMonthToCheck = 12;
              nepaliYearToCheck--;
            }
            gregorianDayOfYear += this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][nepaliMonthToCheck];
            nepaliMonthToCheck--;
          }
          if (nepaliMonth === 9) {
            gregorianDayOfYear += nepaliDay - this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0];
            if (gregorianDayOfYear < 0) {
              gregorianDayOfYear += gregorianCalendar.daysInYear(gregorianYear);
            }
          } else {
            gregorianDayOfYear += this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][9] - this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0];
          }
          return gregorianCalendar.newDate(gregorianYear, 1, 1).add(gregorianDayOfYear, "d").toJD();
        },
        /** Create a new date from a Julian date.
            @memberof NepaliCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var gregorianCalendar = main.instance();
          var gregorianDate = gregorianCalendar.fromJD(jd);
          var gregorianYear = gregorianDate.year();
          var gregorianDayOfYear = gregorianDate.dayOfYear();
          var nepaliYear = gregorianYear + 56;
          this._createMissingCalendarData(nepaliYear);
          var nepaliMonth = 9;
          var dayOfFirstJanInPaush = this.NEPALI_CALENDAR_DATA[nepaliYear][0];
          var daysSinceJanFirstToEndOfNepaliMonth = this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth] - dayOfFirstJanInPaush + 1;
          while (gregorianDayOfYear > daysSinceJanFirstToEndOfNepaliMonth) {
            nepaliMonth++;
            if (nepaliMonth > 12) {
              nepaliMonth = 1;
              nepaliYear++;
            }
            daysSinceJanFirstToEndOfNepaliMonth += this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth];
          }
          var nepaliDayOfMonth = this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth] - (daysSinceJanFirstToEndOfNepaliMonth - gregorianDayOfYear);
          return this.newDate(nepaliYear, nepaliMonth, nepaliDayOfMonth);
        },
        /** Creates missing data in the NEPALI_CALENDAR_DATA table.
            This data will not be correct but just give an estimated result. Mostly -/+ 1 day
            @private
            @param nepaliYear {number} The missing year number. */
        _createMissingCalendarData: function(nepaliYear) {
          var tmp_calendar_data = this.daysPerMonth.slice(0);
          tmp_calendar_data.unshift(17);
          for (var nepaliYearToCreate = nepaliYear - 1; nepaliYearToCreate < nepaliYear + 2; nepaliYearToCreate++) {
            if (typeof this.NEPALI_CALENDAR_DATA[nepaliYearToCreate] === "undefined") {
              this.NEPALI_CALENDAR_DATA[nepaliYearToCreate] = tmp_calendar_data;
            }
          }
        },
        NEPALI_CALENDAR_DATA: {
          // These data are from http://www.ashesh.com.np
          1970: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1971: [18, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
          1972: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          1973: [19, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          1974: [19, 31, 31, 32, 30, 31, 31, 30, 29, 30, 29, 30, 30],
          1975: [18, 31, 31, 32, 32, 30, 31, 30, 29, 30, 29, 30, 30],
          1976: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1977: [18, 31, 32, 31, 32, 31, 31, 29, 30, 29, 30, 29, 31],
          1978: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1979: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          1980: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1981: [18, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          1982: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1983: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          1984: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1985: [18, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          1986: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1987: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          1988: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1989: [18, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          1990: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1991: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          // These data are from http://nepalicalendar.rat32.com/index.php
          1992: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          1993: [18, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          1994: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1995: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          1996: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          1997: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1998: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1999: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2e3: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2001: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2002: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2003: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2004: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2005: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2006: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2007: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2008: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
          2009: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2010: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2011: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2012: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2013: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2014: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2015: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2016: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2017: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2018: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2019: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2020: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2021: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2022: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2023: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2024: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2025: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2026: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2027: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2028: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2029: [18, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
          2030: [17, 31, 32, 31, 32, 31, 30, 30, 30, 30, 30, 30, 31],
          2031: [17, 31, 32, 31, 32, 31, 31, 31, 31, 31, 31, 31, 31],
          2032: [17, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32],
          2033: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2034: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2035: [17, 30, 32, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
          2036: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2037: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2038: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2039: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2040: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2041: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2042: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2043: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2044: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2045: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2046: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2047: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2048: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2049: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2050: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2051: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2052: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2053: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2054: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2055: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 30, 29, 30],
          2056: [17, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
          2057: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2058: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2059: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2060: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2061: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2062: [17, 30, 32, 31, 32, 31, 31, 29, 30, 29, 30, 29, 31],
          2063: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2064: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2065: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2066: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
          2067: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2068: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2069: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2070: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2071: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2072: [17, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2073: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2074: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2075: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2076: [16, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2077: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2078: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2079: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2080: [16, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          // These data are from http://www.ashesh.com.np/nepali-calendar/
          2081: [17, 31, 31, 32, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2082: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2083: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
          2084: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
          2085: [17, 31, 32, 31, 32, 31, 31, 30, 30, 29, 30, 30, 30],
          2086: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2087: [16, 31, 31, 32, 31, 31, 31, 30, 30, 29, 30, 30, 30],
          2088: [16, 30, 31, 32, 32, 30, 31, 30, 30, 29, 30, 30, 30],
          2089: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2090: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2091: [16, 31, 31, 32, 31, 31, 31, 30, 30, 29, 30, 30, 30],
          2092: [16, 31, 31, 32, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2093: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2094: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
          2095: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 30, 30, 30],
          2096: [17, 30, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2097: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2098: [17, 31, 31, 32, 31, 31, 31, 29, 30, 29, 30, 30, 31],
          2099: [17, 31, 31, 32, 31, 31, 31, 30, 29, 29, 30, 30, 30],
          2100: [17, 31, 32, 31, 32, 30, 31, 30, 29, 30, 29, 30, 30]
        }
      });
      main.calendars.nepali = NepaliCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/persian.js
  var require_persian = __commonJS({
    "node_modules/world-calendars/dist/calendars/persian.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function PersianCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      PersianCalendar.prototype = new main.baseCalendar();
      assign(PersianCalendar.prototype, {
        /** The calendar name.
            @memberof PersianCalendar */
        name: "Persian",
        /** Julian date of start of Persian epoch: 19 March 622 CE.
            @memberof PersianCalendar */
        jdEpoch: 19483205e-1,
        /** Days per month in a common year.
            @memberof PersianCalendar */
        daysPerMonth: [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof PersianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof PersianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof PersianCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof PersianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof PersianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Persian",
            epochs: ["BP", "AP"],
            monthNames: [
              "Farvardin",
              "Ordibehesht",
              "Khordad",
              "Tir",
              "Mordad",
              "Shahrivar",
              "Mehr",
              "Aban",
              "Azar",
              "Day",
              "Bahman",
              "Esfand"
            ],
            monthNamesShort: ["Far", "Ord", "Kho", "Tir", "Mor", "Sha", "Meh", "Aba", "Aza", "Day", "Bah", "Esf"],
            dayNames: ["Yekshambe", "Doshambe", "Seshambe", "Ch\xE6harshambe", "Panjshambe", "Jom'e", "Shambe"],
            dayNamesShort: ["Yek", "Do", "Se", "Ch\xE6", "Panj", "Jom", "Sha"],
            dayNamesMin: ["Ye", "Do", "Se", "Ch", "Pa", "Jo", "Sh"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 6,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return ((date.year() - (date.year() > 0 ? 474 : 473)) % 2820 + 474 + 38) * 682 % 2816 < 682;
        },
        /** Determine the week of the year for a date.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-((checkDate.dayOfWeek() + 1) % 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 5;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof PersianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          var epBase = year - (year >= 0 ? 474 : 473);
          var epYear = 474 + mod(epBase, 2820);
          return day + (month <= 7 ? (month - 1) * 31 : (month - 1) * 30 + 6) + Math.floor((epYear * 682 - 110) / 2816) + (epYear - 1) * 365 + Math.floor(epBase / 2820) * 1029983 + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof PersianCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5;
          var depoch = jd - this.toJD(475, 1, 1);
          var cycle = Math.floor(depoch / 1029983);
          var cyear = mod(depoch, 1029983);
          var ycycle = 2820;
          if (cyear !== 1029982) {
            var aux1 = Math.floor(cyear / 366);
            var aux2 = mod(cyear, 366);
            ycycle = Math.floor((2134 * aux1 + 2816 * aux2 + 2815) / 1028522) + aux1 + 1;
          }
          var year = ycycle + 2820 * cycle + 474;
          year = year <= 0 ? year - 1 : year;
          var yday = jd - this.toJD(year, 1, 1) + 1;
          var month = yday <= 186 ? Math.ceil(yday / 31) : Math.ceil((yday - 6) / 30);
          var day = jd - this.toJD(year, month, 1) + 1;
          return this.newDate(year, month, day);
        }
      });
      function mod(a, b) {
        return a - b * Math.floor(a / b);
      }
      main.calendars.persian = PersianCalendar;
      main.calendars.jalali = PersianCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/taiwan.js
  var require_taiwan = __commonJS({
    "node_modules/world-calendars/dist/calendars/taiwan.js"() {
      var main = require_main();
      var assign = require_object_assign();
      var gregorianCalendar = main.instance();
      function TaiwanCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      TaiwanCalendar.prototype = new main.baseCalendar();
      assign(TaiwanCalendar.prototype, {
        /** The calendar name.
            @memberof TaiwanCalendar */
        name: "Taiwan",
        /** Julian date of start of Taiwan epoch: 1 January 1912 CE (Gregorian).
            @memberof TaiwanCalendar */
        jdEpoch: 24194025e-1,
        /** Difference in years between Taiwan and Gregorian calendars.
            @memberof TaiwanCalendar */
        yearsOffset: 1911,
        /** Days per month in a common year.
            @memberof TaiwanCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof TaiwanCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof TaiwanCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof TaiwanCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof TaiwanCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof TaiwanCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Taiwan",
            epochs: ["BROC", "ROC"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 1,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.leapYear(year);
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.weekOfYear(year, date.month(), date.day());
        },
        /** Retrieve the number of days in a month.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.toJD(year, date.month(), date.day());
        },
        /** Create a new date from a Julian date.
            @memberof TaiwanCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var date = gregorianCalendar.fromJD(jd);
          var year = this._g2tYear(date.year());
          return this.newDate(year, date.month(), date.day());
        },
        /** Convert Taiwanese to Gregorian year.
            @memberof TaiwanCalendar
            @private
            @param year {number} The Taiwanese year.
            @return {number} The corresponding Gregorian year. */
        _t2gYear: function(year) {
          return year + this.yearsOffset + (year >= -this.yearsOffset && year <= -1 ? 1 : 0);
        },
        /** Convert Gregorian to Taiwanese year.
            @memberof TaiwanCalendar
            @private
            @param year {number} The Gregorian year.
            @return {number} The corresponding Taiwanese year. */
        _g2tYear: function(year) {
          return year - this.yearsOffset - (year >= 1 && year <= this.yearsOffset ? 1 : 0);
        }
      });
      main.calendars.taiwan = TaiwanCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/thai.js
  var require_thai = __commonJS({
    "node_modules/world-calendars/dist/calendars/thai.js"() {
      var main = require_main();
      var assign = require_object_assign();
      var gregorianCalendar = main.instance();
      function ThaiCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      ThaiCalendar.prototype = new main.baseCalendar();
      assign(ThaiCalendar.prototype, {
        /** The calendar name.
            @memberof ThaiCalendar */
        name: "Thai",
        /** Julian date of start of Thai epoch: 1 January 543 BCE (Gregorian).
            @memberof ThaiCalendar */
        jdEpoch: 15230985e-1,
        /** Difference in years between Thai and Gregorian calendars.
            @memberof ThaiCalendar */
        yearsOffset: 543,
        /** Days per month in a common year.
            @memberof ThaiCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof ThaiCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof ThaiCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof ThaiCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof ThaiCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof ThaiCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Thai",
            epochs: ["BBE", "BE"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.leapYear(year);
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.weekOfYear(year, date.month(), date.day());
        },
        /** Retrieve the number of days in a month.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.toJD(year, date.month(), date.day());
        },
        /** Create a new date from a Julian date.
            @memberof ThaiCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var date = gregorianCalendar.fromJD(jd);
          var year = this._g2tYear(date.year());
          return this.newDate(year, date.month(), date.day());
        },
        /** Convert Thai to Gregorian year.
            @memberof ThaiCalendar
            @private
            @param year {number} The Thai year.
            @return {number} The corresponding Gregorian year. */
        _t2gYear: function(year) {
          return year - this.yearsOffset - (year >= 1 && year <= this.yearsOffset ? 1 : 0);
        },
        /** Convert Gregorian to Thai year.
            @memberof ThaiCalendar
            @private
            @param year {number} The Gregorian year.
            @return {number} The corresponding Thai year. */
        _g2tYear: function(year) {
          return year + this.yearsOffset + (year >= -this.yearsOffset && year <= -1 ? 1 : 0);
        }
      });
      main.calendars.thai = ThaiCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/ummalqura.js
  var require_ummalqura = __commonJS({
    "node_modules/world-calendars/dist/calendars/ummalqura.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function UmmAlQuraCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      UmmAlQuraCalendar.prototype = new main.baseCalendar();
      assign(UmmAlQuraCalendar.prototype, {
        /** The calendar name.
            @memberof UmmAlQuraCalendar */
        name: "UmmAlQura",
        //jdEpoch: 1948440, // Julian date of start of UmmAlQura epoch: 14 March 1937 CE
        //daysPerMonth: // Days per month in a common year, replaced by a method.
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof UmmAlQuraCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof UmmAlQuraCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof UmmAlQuraCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof UmmAlQuraCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof UmmAlQuraCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Umm al-Qura",
            epochs: ["BH", "AH"],
            monthNames: [
              "Al-Muharram",
              "Safar",
              "Rabi' al-awwal",
              "Rabi' Al-Thani",
              "Jumada Al-Awwal",
              "Jumada Al-Thani",
              "Rajab",
              "Sha'aban",
              "Ramadan",
              "Shawwal",
              "Dhu al-Qi'dah",
              "Dhu al-Hijjah"
            ],
            monthNamesShort: ["Muh", "Saf", "Rab1", "Rab2", "Jum1", "Jum2", "Raj", "Sha'", "Ram", "Shaw", "DhuQ", "DhuH"],
            dayNames: ["Yawm al-Ahad", "Yawm al-Ithnain", "Yawm al-Thal\u0101th\u0101\u2019", "Yawm al-Arba\u2018\u0101\u2019", "Yawm al-Kham\u012Bs", "Yawm al-Jum\u2018a", "Yawm al-Sabt"],
            dayNamesMin: ["Ah", "Ith", "Th", "Ar", "Kh", "Ju", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 6,
            isRTL: true
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return this.daysInYear(date.year()) === 355;
        },
        /** Determine the week of the year for a date.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var daysCount = 0;
          for (var i = 1; i <= 12; i++) {
            daysCount += this.daysInMonth(year, i);
          }
          return daysCount;
        },
        /** Retrieve the number of days in a month.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          var mcjdn = date.toJD() - 24e5 + 0.5;
          var index = 0;
          for (var i = 0; i < ummalqura_dat.length; i++) {
            if (ummalqura_dat[i] > mcjdn) {
              return ummalqura_dat[index] - ummalqura_dat[index - 1];
            }
            index++;
          }
          return 30;
        },
        /** Determine whether this date is a week day.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 5;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var index = 12 * (date.year() - 1) + date.month() - 15292;
          var mcjdn = date.day() + ummalqura_dat[index - 1] - 1;
          return mcjdn + 24e5 - 0.5;
        },
        /** Create a new date from a Julian date.
            @memberof UmmAlQuraCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var mcjdn = jd - 24e5 + 0.5;
          var index = 0;
          for (var i = 0; i < ummalqura_dat.length; i++) {
            if (ummalqura_dat[i] > mcjdn) break;
            index++;
          }
          var lunation = index + 15292;
          var ii = Math.floor((lunation - 1) / 12);
          var year = ii + 1;
          var month = lunation - 12 * ii;
          var day = mcjdn - ummalqura_dat[index - 1] + 1;
          return this.newDate(year, month, day);
        },
        /** Determine whether a date is valid for this calendar.
            @memberof UmmAlQuraCalendar
            @param year {number} The year to examine.
            @param month {number} The month to examine.
            @param day {number} The day to examine.
            @return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
        isValid: function(year, month, day) {
          var valid = main.baseCalendar.prototype.isValid.apply(this, arguments);
          if (valid) {
            year = year.year != null ? year.year : year;
            valid = year >= 1276 && year <= 1500;
          }
          return valid;
        },
        /** Check that a candidate date is from the same calendar and is valid.
            @memberof UmmAlQuraCalendar
            @private
            @param year {CDate|number} The date to validate or the year to validate.
            @param month {number} The month to validate.
            @param day {number} The day to validate.
            @param error {string} Error message if invalid.
            @throws Error if different calendars used or invalid date. */
        _validate: function(year, month, day, error) {
          var date = main.baseCalendar.prototype._validate.apply(this, arguments);
          if (date.year < 1276 || date.year > 1500) {
            throw error.replace(/\{0\}/, this.local.name);
          }
          return date;
        }
      });
      main.calendars.ummalqura = UmmAlQuraCalendar;
      var ummalqura_dat = [
        20,
        50,
        79,
        109,
        138,
        168,
        197,
        227,
        256,
        286,
        315,
        345,
        374,
        404,
        433,
        463,
        492,
        522,
        551,
        581,
        611,
        641,
        670,
        700,
        729,
        759,
        788,
        818,
        847,
        877,
        906,
        936,
        965,
        995,
        1024,
        1054,
        1083,
        1113,
        1142,
        1172,
        1201,
        1231,
        1260,
        1290,
        1320,
        1350,
        1379,
        1409,
        1438,
        1468,
        1497,
        1527,
        1556,
        1586,
        1615,
        1645,
        1674,
        1704,
        1733,
        1763,
        1792,
        1822,
        1851,
        1881,
        1910,
        1940,
        1969,
        1999,
        2028,
        2058,
        2087,
        2117,
        2146,
        2176,
        2205,
        2235,
        2264,
        2294,
        2323,
        2353,
        2383,
        2413,
        2442,
        2472,
        2501,
        2531,
        2560,
        2590,
        2619,
        2649,
        2678,
        2708,
        2737,
        2767,
        2796,
        2826,
        2855,
        2885,
        2914,
        2944,
        2973,
        3003,
        3032,
        3062,
        3091,
        3121,
        3150,
        3180,
        3209,
        3239,
        3268,
        3298,
        3327,
        3357,
        3386,
        3416,
        3446,
        3476,
        3505,
        3535,
        3564,
        3594,
        3623,
        3653,
        3682,
        3712,
        3741,
        3771,
        3800,
        3830,
        3859,
        3889,
        3918,
        3948,
        3977,
        4007,
        4036,
        4066,
        4095,
        4125,
        4155,
        4185,
        4214,
        4244,
        4273,
        4303,
        4332,
        4362,
        4391,
        4421,
        4450,
        4480,
        4509,
        4539,
        4568,
        4598,
        4627,
        4657,
        4686,
        4716,
        4745,
        4775,
        4804,
        4834,
        4863,
        4893,
        4922,
        4952,
        4981,
        5011,
        5040,
        5070,
        5099,
        5129,
        5158,
        5188,
        5218,
        5248,
        5277,
        5307,
        5336,
        5366,
        5395,
        5425,
        5454,
        5484,
        5513,
        5543,
        5572,
        5602,
        5631,
        5661,
        5690,
        5720,
        5749,
        5779,
        5808,
        5838,
        5867,
        5897,
        5926,
        5956,
        5985,
        6015,
        6044,
        6074,
        6103,
        6133,
        6162,
        6192,
        6221,
        6251,
        6281,
        6311,
        6340,
        6370,
        6399,
        6429,
        6458,
        6488,
        6517,
        6547,
        6576,
        6606,
        6635,
        6665,
        6694,
        6724,
        6753,
        6783,
        6812,
        6842,
        6871,
        6901,
        6930,
        6960,
        6989,
        7019,
        7048,
        7078,
        7107,
        7137,
        7166,
        7196,
        7225,
        7255,
        7284,
        7314,
        7344,
        7374,
        7403,
        7433,
        7462,
        7492,
        7521,
        7551,
        7580,
        7610,
        7639,
        7669,
        7698,
        7728,
        7757,
        7787,
        7816,
        7846,
        7875,
        7905,
        7934,
        7964,
        7993,
        8023,
        8053,
        8083,
        8112,
        8142,
        8171,
        8201,
        8230,
        8260,
        8289,
        8319,
        8348,
        8378,
        8407,
        8437,
        8466,
        8496,
        8525,
        8555,
        8584,
        8614,
        8643,
        8673,
        8702,
        8732,
        8761,
        8791,
        8821,
        8850,
        8880,
        8909,
        8938,
        8968,
        8997,
        9027,
        9056,
        9086,
        9115,
        9145,
        9175,
        9205,
        9234,
        9264,
        9293,
        9322,
        9352,
        9381,
        9410,
        9440,
        9470,
        9499,
        9529,
        9559,
        9589,
        9618,
        9648,
        9677,
        9706,
        9736,
        9765,
        9794,
        9824,
        9853,
        9883,
        9913,
        9943,
        9972,
        10002,
        10032,
        10061,
        10090,
        10120,
        10149,
        10178,
        10208,
        10237,
        10267,
        10297,
        10326,
        10356,
        10386,
        10415,
        10445,
        10474,
        10504,
        10533,
        10562,
        10592,
        10621,
        10651,
        10680,
        10710,
        10740,
        10770,
        10799,
        10829,
        10858,
        10888,
        10917,
        10947,
        10976,
        11005,
        11035,
        11064,
        11094,
        11124,
        11153,
        11183,
        11213,
        11242,
        11272,
        11301,
        11331,
        11360,
        11389,
        11419,
        11448,
        11478,
        11507,
        11537,
        11567,
        11596,
        11626,
        11655,
        11685,
        11715,
        11744,
        11774,
        11803,
        11832,
        11862,
        11891,
        11921,
        11950,
        11980,
        12010,
        12039,
        12069,
        12099,
        12128,
        12158,
        12187,
        12216,
        12246,
        12275,
        12304,
        12334,
        12364,
        12393,
        12423,
        12453,
        12483,
        12512,
        12542,
        12571,
        12600,
        12630,
        12659,
        12688,
        12718,
        12747,
        12777,
        12807,
        12837,
        12866,
        12896,
        12926,
        12955,
        12984,
        13014,
        13043,
        13072,
        13102,
        13131,
        13161,
        13191,
        13220,
        13250,
        13280,
        13310,
        13339,
        13368,
        13398,
        13427,
        13456,
        13486,
        13515,
        13545,
        13574,
        13604,
        13634,
        13664,
        13693,
        13723,
        13752,
        13782,
        13811,
        13840,
        13870,
        13899,
        13929,
        13958,
        13988,
        14018,
        14047,
        14077,
        14107,
        14136,
        14166,
        14195,
        14224,
        14254,
        14283,
        14313,
        14342,
        14372,
        14401,
        14431,
        14461,
        14490,
        14520,
        14550,
        14579,
        14609,
        14638,
        14667,
        14697,
        14726,
        14756,
        14785,
        14815,
        14844,
        14874,
        14904,
        14933,
        14963,
        14993,
        15021,
        15051,
        15081,
        15110,
        15140,
        15169,
        15199,
        15228,
        15258,
        15287,
        15317,
        15347,
        15377,
        15406,
        15436,
        15465,
        15494,
        15524,
        15553,
        15582,
        15612,
        15641,
        15671,
        15701,
        15731,
        15760,
        15790,
        15820,
        15849,
        15878,
        15908,
        15937,
        15966,
        15996,
        16025,
        16055,
        16085,
        16114,
        16144,
        16174,
        16204,
        16233,
        16262,
        16292,
        16321,
        16350,
        16380,
        16409,
        16439,
        16468,
        16498,
        16528,
        16558,
        16587,
        16617,
        16646,
        16676,
        16705,
        16734,
        16764,
        16793,
        16823,
        16852,
        16882,
        16912,
        16941,
        16971,
        17001,
        17030,
        17060,
        17089,
        17118,
        17148,
        17177,
        17207,
        17236,
        17266,
        17295,
        17325,
        17355,
        17384,
        17414,
        17444,
        17473,
        17502,
        17532,
        17561,
        17591,
        17620,
        17650,
        17679,
        17709,
        17738,
        17768,
        17798,
        17827,
        17857,
        17886,
        17916,
        17945,
        17975,
        18004,
        18034,
        18063,
        18093,
        18122,
        18152,
        18181,
        18211,
        18241,
        18270,
        18300,
        18330,
        18359,
        18388,
        18418,
        18447,
        18476,
        18506,
        18535,
        18565,
        18595,
        18625,
        18654,
        18684,
        18714,
        18743,
        18772,
        18802,
        18831,
        18860,
        18890,
        18919,
        18949,
        18979,
        19008,
        19038,
        19068,
        19098,
        19127,
        19156,
        19186,
        19215,
        19244,
        19274,
        19303,
        19333,
        19362,
        19392,
        19422,
        19452,
        19481,
        19511,
        19540,
        19570,
        19599,
        19628,
        19658,
        19687,
        19717,
        19746,
        19776,
        19806,
        19836,
        19865,
        19895,
        19924,
        19954,
        19983,
        20012,
        20042,
        20071,
        20101,
        20130,
        20160,
        20190,
        20219,
        20249,
        20279,
        20308,
        20338,
        20367,
        20396,
        20426,
        20455,
        20485,
        20514,
        20544,
        20573,
        20603,
        20633,
        20662,
        20692,
        20721,
        20751,
        20780,
        20810,
        20839,
        20869,
        20898,
        20928,
        20957,
        20987,
        21016,
        21046,
        21076,
        21105,
        21135,
        21164,
        21194,
        21223,
        21253,
        21282,
        21312,
        21341,
        21371,
        21400,
        21430,
        21459,
        21489,
        21519,
        21548,
        21578,
        21607,
        21637,
        21666,
        21696,
        21725,
        21754,
        21784,
        21813,
        21843,
        21873,
        21902,
        21932,
        21962,
        21991,
        22021,
        22050,
        22080,
        22109,
        22138,
        22168,
        22197,
        22227,
        22256,
        22286,
        22316,
        22346,
        22375,
        22405,
        22434,
        22464,
        22493,
        22522,
        22552,
        22581,
        22611,
        22640,
        22670,
        22700,
        22730,
        22759,
        22789,
        22818,
        22848,
        22877,
        22906,
        22936,
        22965,
        22994,
        23024,
        23054,
        23083,
        23113,
        23143,
        23173,
        23202,
        23232,
        23261,
        23290,
        23320,
        23349,
        23379,
        23408,
        23438,
        23467,
        23497,
        23527,
        23556,
        23586,
        23616,
        23645,
        23674,
        23704,
        23733,
        23763,
        23792,
        23822,
        23851,
        23881,
        23910,
        23940,
        23970,
        23999,
        24029,
        24058,
        24088,
        24117,
        24147,
        24176,
        24206,
        24235,
        24265,
        24294,
        24324,
        24353,
        24383,
        24413,
        24442,
        24472,
        24501,
        24531,
        24560,
        24590,
        24619,
        24648,
        24678,
        24707,
        24737,
        24767,
        24796,
        24826,
        24856,
        24885,
        24915,
        24944,
        24974,
        25003,
        25032,
        25062,
        25091,
        25121,
        25150,
        25180,
        25210,
        25240,
        25269,
        25299,
        25328,
        25358,
        25387,
        25416,
        25446,
        25475,
        25505,
        25534,
        25564,
        25594,
        25624,
        25653,
        25683,
        25712,
        25742,
        25771,
        25800,
        25830,
        25859,
        25888,
        25918,
        25948,
        25977,
        26007,
        26037,
        26067,
        26096,
        26126,
        26155,
        26184,
        26214,
        26243,
        26272,
        26302,
        26332,
        26361,
        26391,
        26421,
        26451,
        26480,
        26510,
        26539,
        26568,
        26598,
        26627,
        26656,
        26686,
        26715,
        26745,
        26775,
        26805,
        26834,
        26864,
        26893,
        26923,
        26952,
        26982,
        27011,
        27041,
        27070,
        27099,
        27129,
        27159,
        27188,
        27218,
        27248,
        27277,
        27307,
        27336,
        27366,
        27395,
        27425,
        27454,
        27484,
        27513,
        27542,
        27572,
        27602,
        27631,
        27661,
        27691,
        27720,
        27750,
        27779,
        27809,
        27838,
        27868,
        27897,
        27926,
        27956,
        27985,
        28015,
        28045,
        28074,
        28104,
        28134,
        28163,
        28193,
        28222,
        28252,
        28281,
        28310,
        28340,
        28369,
        28399,
        28428,
        28458,
        28488,
        28517,
        28547,
        28577,
        // From 1356
        28607,
        28636,
        28665,
        28695,
        28724,
        28754,
        28783,
        28813,
        28843,
        28872,
        28901,
        28931,
        28960,
        28990,
        29019,
        29049,
        29078,
        29108,
        29137,
        29167,
        29196,
        29226,
        29255,
        29285,
        29315,
        29345,
        29375,
        29404,
        29434,
        29463,
        29492,
        29522,
        29551,
        29580,
        29610,
        29640,
        29669,
        29699,
        29729,
        29759,
        29788,
        29818,
        29847,
        29876,
        29906,
        29935,
        29964,
        29994,
        30023,
        30053,
        30082,
        30112,
        30141,
        30171,
        30200,
        30230,
        30259,
        30289,
        30318,
        30348,
        30378,
        30408,
        30437,
        30467,
        30496,
        30526,
        30555,
        30585,
        30614,
        30644,
        30673,
        30703,
        30732,
        30762,
        30791,
        30821,
        30850,
        30880,
        30909,
        30939,
        30968,
        30998,
        31027,
        31057,
        31086,
        31116,
        31145,
        31175,
        31204,
        31234,
        31263,
        31293,
        31322,
        31352,
        31381,
        31411,
        31441,
        31471,
        31500,
        31530,
        31559,
        31589,
        31618,
        31648,
        31676,
        31706,
        31736,
        31766,
        31795,
        31825,
        31854,
        31884,
        31913,
        31943,
        31972,
        32002,
        32031,
        32061,
        32090,
        32120,
        32150,
        32180,
        32209,
        32239,
        32268,
        32298,
        32327,
        32357,
        32386,
        32416,
        32445,
        32475,
        32504,
        32534,
        32563,
        32593,
        32622,
        32652,
        32681,
        32711,
        32740,
        32770,
        32799,
        32829,
        32858,
        32888,
        32917,
        32947,
        32976,
        33006,
        33035,
        33065,
        33094,
        33124,
        33153,
        33183,
        33213,
        33243,
        33272,
        33302,
        33331,
        33361,
        33390,
        33420,
        33450,
        33479,
        33509,
        33539,
        33568,
        33598,
        33627,
        33657,
        33686,
        33716,
        33745,
        33775,
        33804,
        33834,
        33863,
        33893,
        33922,
        33952,
        33981,
        34011,
        34040,
        34069,
        34099,
        34128,
        34158,
        34187,
        34217,
        34247,
        34277,
        34306,
        34336,
        34365,
        34395,
        34424,
        34454,
        34483,
        34512,
        34542,
        34571,
        34601,
        34631,
        34660,
        34690,
        34719,
        34749,
        34778,
        34808,
        34837,
        34867,
        34896,
        34926,
        34955,
        34985,
        35015,
        35044,
        35074,
        35103,
        35133,
        35162,
        35192,
        35222,
        35251,
        35280,
        35310,
        35340,
        35370,
        35399,
        35429,
        35458,
        35488,
        35517,
        35547,
        35576,
        35605,
        35635,
        35665,
        35694,
        35723,
        35753,
        35782,
        35811,
        35841,
        35871,
        35901,
        35930,
        35960,
        35989,
        36019,
        36048,
        36078,
        36107,
        36136,
        36166,
        36195,
        36225,
        36254,
        36284,
        36314,
        36343,
        36373,
        36403,
        36433,
        36462,
        36492,
        36521,
        36551,
        36580,
        36610,
        36639,
        36669,
        36698,
        36728,
        36757,
        36786,
        36816,
        36845,
        36875,
        36904,
        36934,
        36963,
        36993,
        37022,
        37052,
        37081,
        37111,
        37141,
        37170,
        37200,
        37229,
        37259,
        37288,
        37318,
        37347,
        37377,
        37406,
        37436,
        37465,
        37495,
        37524,
        37554,
        37584,
        37613,
        37643,
        37672,
        37701,
        37731,
        37760,
        37790,
        37819,
        37849,
        37878,
        37908,
        37938,
        37967,
        37997,
        38027,
        38056,
        38085,
        38115,
        38144,
        38174,
        38203,
        38233,
        38262,
        38292,
        38322,
        38351,
        38381,
        38410,
        38440,
        38469,
        38499,
        38528,
        38558,
        38587,
        38617,
        38646,
        38676,
        38705,
        38735,
        38764,
        38794,
        38823,
        38853,
        38882,
        38912,
        38941,
        38971,
        39001,
        39030,
        39059,
        39089,
        39118,
        39148,
        39178,
        39208,
        39237,
        39267,
        39297,
        39326,
        39355,
        39385,
        39414,
        39444,
        39473,
        39503,
        39532,
        39562,
        39592,
        39621,
        39650,
        39680,
        39709,
        39739,
        39768,
        39798,
        39827,
        39857,
        39886,
        39916,
        39946,
        39975,
        40005,
        40035,
        40064,
        40094,
        40123,
        40153,
        40182,
        40212,
        40241,
        40271,
        40300,
        40330,
        40359,
        40389,
        40418,
        40448,
        40477,
        40507,
        40536,
        40566,
        40595,
        40625,
        40655,
        40685,
        40714,
        40744,
        40773,
        40803,
        40832,
        40862,
        40892,
        40921,
        40951,
        40980,
        41009,
        41039,
        41068,
        41098,
        41127,
        41157,
        41186,
        41216,
        41245,
        41275,
        41304,
        41334,
        41364,
        41393,
        41422,
        41452,
        41481,
        41511,
        41540,
        41570,
        41599,
        41629,
        41658,
        41688,
        41718,
        41748,
        41777,
        41807,
        41836,
        41865,
        41894,
        41924,
        41953,
        41983,
        42012,
        42042,
        42072,
        42102,
        42131,
        42161,
        42190,
        42220,
        42249,
        42279,
        42308,
        42337,
        42367,
        42397,
        42426,
        42456,
        42485,
        42515,
        42545,
        42574,
        42604,
        42633,
        42662,
        42692,
        42721,
        42751,
        42780,
        42810,
        42839,
        42869,
        42899,
        42929,
        42958,
        42988,
        43017,
        43046,
        43076,
        43105,
        43135,
        43164,
        43194,
        43223,
        43253,
        43283,
        43312,
        43342,
        43371,
        43401,
        43430,
        43460,
        43489,
        43519,
        43548,
        43578,
        43607,
        43637,
        43666,
        43696,
        43726,
        43755,
        43785,
        43814,
        43844,
        43873,
        43903,
        43932,
        43962,
        43991,
        44021,
        44050,
        44080,
        44109,
        44139,
        44169,
        44198,
        44228,
        44258,
        44287,
        44317,
        44346,
        44375,
        44405,
        44434,
        44464,
        44493,
        44523,
        44553,
        44582,
        44612,
        44641,
        44671,
        44700,
        44730,
        44759,
        44788,
        44818,
        44847,
        44877,
        44906,
        44936,
        44966,
        44996,
        45025,
        45055,
        45084,
        45114,
        45143,
        45172,
        45202,
        45231,
        45261,
        45290,
        45320,
        45350,
        45380,
        45409,
        45439,
        45468,
        45498,
        45527,
        45556,
        45586,
        45615,
        45644,
        45674,
        45704,
        45733,
        45763,
        45793,
        45823,
        45852,
        45882,
        45911,
        45940,
        45970,
        45999,
        46028,
        46058,
        46088,
        46117,
        46147,
        46177,
        46206,
        46236,
        46265,
        46295,
        46324,
        46354,
        46383,
        46413,
        46442,
        46472,
        46501,
        46531,
        46560,
        46590,
        46620,
        46649,
        46679,
        46708,
        46738,
        46767,
        46797,
        46826,
        46856,
        46885,
        46915,
        46944,
        46974,
        47003,
        47033,
        47063,
        47092,
        47122,
        47151,
        47181,
        47210,
        47240,
        47269,
        47298,
        47328,
        47357,
        47387,
        47417,
        47446,
        47476,
        47506,
        47535,
        47565,
        47594,
        47624,
        47653,
        47682,
        47712,
        47741,
        47771,
        47800,
        47830,
        47860,
        47890,
        47919,
        47949,
        47978,
        48008,
        48037,
        48066,
        48096,
        48125,
        48155,
        48184,
        48214,
        48244,
        48273,
        48303,
        48333,
        48362,
        48392,
        48421,
        48450,
        48480,
        48509,
        48538,
        48568,
        48598,
        48627,
        48657,
        48687,
        48717,
        48746,
        48776,
        48805,
        48834,
        48864,
        48893,
        48922,
        48952,
        48982,
        49011,
        49041,
        49071,
        49100,
        49130,
        49160,
        49189,
        49218,
        49248,
        49277,
        49306,
        49336,
        49365,
        49395,
        49425,
        49455,
        49484,
        49514,
        49543,
        49573,
        49602,
        49632,
        49661,
        49690,
        49720,
        49749,
        49779,
        49809,
        49838,
        49868,
        49898,
        49927,
        49957,
        49986,
        50016,
        50045,
        50075,
        50104,
        50133,
        50163,
        50192,
        50222,
        50252,
        50281,
        50311,
        50340,
        50370,
        50400,
        50429,
        50459,
        50488,
        50518,
        50547,
        50576,
        50606,
        50635,
        50665,
        50694,
        50724,
        50754,
        50784,
        50813,
        50843,
        50872,
        50902,
        50931,
        50960,
        50990,
        51019,
        51049,
        51078,
        51108,
        51138,
        51167,
        51197,
        51227,
        51256,
        51286,
        51315,
        51345,
        51374,
        51403,
        51433,
        51462,
        51492,
        51522,
        51552,
        51582,
        51611,
        51641,
        51670,
        51699,
        51729,
        51758,
        51787,
        51816,
        51846,
        51876,
        51906,
        51936,
        51965,
        51995,
        52025,
        52054,
        52083,
        52113,
        52142,
        52171,
        52200,
        52230,
        52260,
        52290,
        52319,
        52349,
        52379,
        52408,
        52438,
        52467,
        52497,
        52526,
        52555,
        52585,
        52614,
        52644,
        52673,
        52703,
        52733,
        52762,
        52792,
        52822,
        52851,
        52881,
        52910,
        52939,
        52969,
        52998,
        53028,
        53057,
        53087,
        53116,
        53146,
        53176,
        53205,
        53235,
        53264,
        53294,
        53324,
        53353,
        53383,
        53412,
        53441,
        53471,
        53500,
        53530,
        53559,
        53589,
        53619,
        53648,
        53678,
        53708,
        53737,
        53767,
        53796,
        53825,
        53855,
        53884,
        53913,
        53943,
        53973,
        54003,
        54032,
        54062,
        54092,
        54121,
        54151,
        54180,
        54209,
        54239,
        54268,
        54297,
        54327,
        54357,
        54387,
        54416,
        54446,
        54476,
        54505,
        54535,
        54564,
        54593,
        54623,
        54652,
        54681,
        54711,
        54741,
        54770,
        54800,
        54830,
        54859,
        54889,
        54919,
        54948,
        54977,
        55007,
        55036,
        55066,
        55095,
        55125,
        55154,
        55184,
        55213,
        55243,
        55273,
        55302,
        55332,
        55361,
        55391,
        55420,
        55450,
        55479,
        55508,
        55538,
        55567,
        55597,
        55627,
        55657,
        55686,
        55716,
        55745,
        55775,
        55804,
        55834,
        55863,
        55892,
        55922,
        55951,
        55981,
        56011,
        56040,
        56070,
        56100,
        56129,
        56159,
        56188,
        56218,
        56247,
        56276,
        56306,
        56335,
        56365,
        56394,
        56424,
        56454,
        56483,
        56513,
        56543,
        56572,
        56601,
        56631,
        56660,
        56690,
        56719,
        56749,
        56778,
        56808,
        56837,
        56867,
        56897,
        56926,
        56956,
        56985,
        57015,
        57044,
        57074,
        57103,
        57133,
        57162,
        57192,
        57221,
        57251,
        57280,
        57310,
        57340,
        57369,
        57399,
        57429,
        57458,
        57487,
        57517,
        57546,
        57576,
        57605,
        57634,
        57664,
        57694,
        57723,
        57753,
        57783,
        57813,
        57842,
        57871,
        57901,
        57930,
        57959,
        57989,
        58018,
        58048,
        58077,
        58107,
        58137,
        58167,
        58196,
        58226,
        58255,
        58285,
        58314,
        58343,
        58373,
        58402,
        58432,
        58461,
        58491,
        58521,
        58551,
        58580,
        58610,
        58639,
        58669,
        58698,
        58727,
        58757,
        58786,
        58816,
        58845,
        58875,
        58905,
        58934,
        58964,
        58994,
        59023,
        59053,
        59082,
        59111,
        59141,
        59170,
        59200,
        59229,
        59259,
        59288,
        59318,
        59348,
        59377,
        59407,
        59436,
        59466,
        59495,
        59525,
        59554,
        59584,
        59613,
        59643,
        59672,
        59702,
        59731,
        59761,
        59791,
        59820,
        59850,
        59879,
        59909,
        59939,
        59968,
        59997,
        60027,
        60056,
        60086,
        60115,
        60145,
        60174,
        60204,
        60234,
        60264,
        60293,
        60323,
        60352,
        60381,
        60411,
        60440,
        60469,
        60499,
        60528,
        60558,
        60588,
        60618,
        60648,
        60677,
        60707,
        60736,
        60765,
        60795,
        60824,
        60853,
        60883,
        60912,
        60942,
        60972,
        61002,
        61031,
        61061,
        61090,
        61120,
        61149,
        61179,
        61208,
        61237,
        61267,
        61296,
        61326,
        61356,
        61385,
        61415,
        61445,
        61474,
        61504,
        61533,
        61563,
        61592,
        61621,
        61651,
        61680,
        61710,
        61739,
        61769,
        61799,
        61828,
        61858,
        61888,
        61917,
        61947,
        61976,
        62006,
        62035,
        62064,
        62094,
        62123,
        62153,
        62182,
        62212,
        62242,
        62271,
        62301,
        62331,
        62360,
        62390,
        62419,
        62448,
        62478,
        62507,
        62537,
        62566,
        62596,
        62625,
        62655,
        62685,
        62715,
        62744,
        62774,
        62803,
        62832,
        62862,
        62891,
        62921,
        62950,
        62980,
        63009,
        63039,
        63069,
        63099,
        63128,
        63157,
        63187,
        63216,
        63246,
        63275,
        63305,
        63334,
        63363,
        63393,
        63423,
        63453,
        63482,
        63512,
        63541,
        63571,
        63600,
        63630,
        63659,
        63689,
        63718,
        63747,
        63777,
        63807,
        63836,
        63866,
        63895,
        63925,
        63955,
        63984,
        64014,
        64043,
        64073,
        64102,
        64131,
        64161,
        64190,
        64220,
        64249,
        64279,
        64309,
        64339,
        64368,
        64398,
        64427,
        64457,
        64486,
        64515,
        64545,
        64574,
        64603,
        64633,
        64663,
        64692,
        64722,
        64752,
        64782,
        64811,
        64841,
        64870,
        64899,
        64929,
        64958,
        64987,
        65017,
        65047,
        65076,
        65106,
        65136,
        65166,
        65195,
        65225,
        65254,
        65283,
        65313,
        65342,
        65371,
        65401,
        65431,
        65460,
        65490,
        65520,
        65549,
        65579,
        65608,
        65638,
        65667,
        65697,
        65726,
        65755,
        65785,
        65815,
        65844,
        65874,
        65903,
        65933,
        65963,
        65992,
        66022,
        66051,
        66081,
        66110,
        66140,
        66169,
        66199,
        66228,
        66258,
        66287,
        66317,
        66346,
        66376,
        66405,
        66435,
        66465,
        66494,
        66524,
        66553,
        66583,
        66612,
        66641,
        66671,
        66700,
        66730,
        66760,
        66789,
        66819,
        66849,
        66878,
        66908,
        66937,
        66967,
        66996,
        67025,
        67055,
        67084,
        67114,
        67143,
        67173,
        67203,
        67233,
        67262,
        67292,
        67321,
        67351,
        67380,
        67409,
        67439,
        67468,
        67497,
        67527,
        67557,
        67587,
        67617,
        67646,
        67676,
        67705,
        67735,
        67764,
        67793,
        67823,
        67852,
        67882,
        67911,
        67941,
        67971,
        68e3,
        68030,
        68060,
        68089,
        68119,
        68148,
        68177,
        68207,
        68236,
        68266,
        68295,
        68325,
        68354,
        68384,
        68414,
        68443,
        68473,
        68502,
        68532,
        68561,
        68591,
        68620,
        68650,
        68679,
        68708,
        68738,
        68768,
        68797,
        68827,
        68857,
        68886,
        68916,
        68946,
        68975,
        69004,
        69034,
        69063,
        69092,
        69122,
        69152,
        69181,
        69211,
        69240,
        69270,
        69300,
        69330,
        69359,
        69388,
        69418,
        69447,
        69476,
        69506,
        69535,
        69565,
        69595,
        69624,
        69654,
        69684,
        69713,
        69743,
        69772,
        69802,
        69831,
        69861,
        69890,
        69919,
        69949,
        69978,
        70008,
        70038,
        70067,
        70097,
        70126,
        70156,
        70186,
        70215,
        70245,
        70274,
        70303,
        70333,
        70362,
        70392,
        70421,
        70451,
        70481,
        70510,
        70540,
        70570,
        70599,
        70629,
        70658,
        70687,
        70717,
        70746,
        70776,
        70805,
        70835,
        70864,
        70894,
        70924,
        70954,
        70983,
        71013,
        71042,
        71071,
        71101,
        71130,
        71159,
        71189,
        71218,
        71248,
        71278,
        71308,
        71337,
        71367,
        71397,
        71426,
        71455,
        71485,
        71514,
        71543,
        71573,
        71602,
        71632,
        71662,
        71691,
        71721,
        71751,
        71781,
        71810,
        71839,
        71869,
        71898,
        71927,
        71957,
        71986,
        72016,
        72046,
        72075,
        72105,
        72135,
        72164,
        72194,
        72223,
        72253,
        72282,
        72311,
        72341,
        72370,
        72400,
        72429,
        72459,
        72489,
        72518,
        72548,
        72577,
        72607,
        72637,
        72666,
        72695,
        72725,
        72754,
        72784,
        72813,
        72843,
        72872,
        72902,
        72931,
        72961,
        72991,
        73020,
        73050,
        73080,
        73109,
        73139,
        73168,
        73197,
        73227,
        73256,
        73286,
        73315,
        73345,
        73375,
        73404,
        73434,
        73464,
        73493,
        73523,
        73552,
        73581,
        73611,
        73640,
        73669,
        73699,
        73729,
        73758,
        73788,
        73818,
        73848,
        73877,
        73907,
        73936,
        73965,
        73995,
        74024,
        74053,
        74083,
        74113,
        74142,
        74172,
        74202,
        74231,
        74261,
        74291,
        74320,
        74349,
        74379,
        74408,
        74437,
        74467,
        74497,
        74526,
        74556,
        74586,
        74615,
        74645,
        74675,
        74704,
        74733,
        74763,
        74792,
        74822,
        74851,
        74881,
        74910,
        74940,
        74969,
        74999,
        75029,
        75058,
        75088,
        75117,
        75147,
        75176,
        75206,
        75235,
        75264,
        75294,
        75323,
        75353,
        75383,
        75412,
        75442,
        75472,
        75501,
        75531,
        75560,
        75590,
        75619,
        75648,
        75678,
        75707,
        75737,
        75766,
        75796,
        75826,
        75856,
        75885,
        75915,
        75944,
        75974,
        76003,
        76032,
        76062,
        76091,
        76121,
        76150,
        76180,
        76210,
        76239,
        76269,
        76299,
        76328,
        76358,
        76387,
        76416,
        76446,
        76475,
        76505,
        76534,
        76564,
        76593,
        76623,
        76653,
        76682,
        76712,
        76741,
        76771,
        76801,
        76830,
        76859,
        76889,
        76918,
        76948,
        76977,
        77007,
        77036,
        77066,
        77096,
        77125,
        77155,
        77185,
        77214,
        77243,
        77273,
        77302,
        77332,
        77361,
        77390,
        77420,
        77450,
        77479,
        77509,
        77539,
        77569,
        77598,
        77627,
        77657,
        77686,
        77715,
        77745,
        77774,
        77804,
        77833,
        77863,
        77893,
        77923,
        77952,
        77982,
        78011,
        78041,
        78070,
        78099,
        78129,
        78158,
        78188,
        78217,
        78247,
        78277,
        78307,
        78336,
        78366,
        78395,
        78425,
        78454,
        78483,
        78513,
        78542,
        78572,
        78601,
        78631,
        78661,
        78690,
        78720,
        78750,
        78779,
        78808,
        78838,
        78867,
        78897,
        78926,
        78956,
        78985,
        79015,
        79044,
        79074,
        79104,
        79133,
        79163,
        79192,
        79222,
        79251,
        79281,
        79310,
        79340,
        79369,
        79399,
        79428,
        79458,
        79487,
        79517,
        79546,
        79576,
        79606,
        79635,
        79665,
        79695,
        79724,
        79753,
        79783,
        79812,
        79841,
        79871,
        79900,
        79930,
        79960,
        79990
      ];
    }
  });

  // src/components/calendars/calendars.js
  var require_calendars = __commonJS({
    "src/components/calendars/calendars.js"(exports, module) {
      "use strict";
      module.exports = require_main();
      require_plus();
      require_chinese();
      require_coptic();
      require_discworld();
      require_ethiopian();
      require_hebrew();
      require_islamic();
      require_julian();
      require_mayan();
      require_nanakshahi();
      require_nepali();
      require_persian();
      require_taiwan();
      require_thai();
      require_ummalqura();
    }
  });

  // src/components/calendars/index.js
  var require_calendars2 = __commonJS({
    "src/components/calendars/index.js"(exports, module) {
      "use strict";
      var calendars = require_calendars();
      var Lib = require_lib();
      var constants = require_numerical();
      var EPOCHJD = constants.EPOCHJD;
      var ONEDAY = constants.ONEDAY;
      var attributes = {
        valType: "enumerated",
        values: Lib.sortObjectKeys(calendars.calendars),
        editType: "calc",
        dflt: "gregorian"
      };
      var handleDefaults = function(contIn, contOut, attr, dflt) {
        var attrs = {};
        attrs[attr] = attributes;
        return Lib.coerce(contIn, contOut, attrs, attr, dflt);
      };
      var handleTraceDefaults = function(traceIn, traceOut, coords, layout) {
        for (var i = 0; i < coords.length; i++) {
          handleDefaults(traceIn, traceOut, coords[i] + "calendar", layout.calendar);
        }
      };
      var CANONICAL_TICK = {
        chinese: "2000-01-01",
        coptic: "2000-01-01",
        discworld: "2000-01-01",
        ethiopian: "2000-01-01",
        hebrew: "5000-01-01",
        islamic: "1000-01-01",
        julian: "2000-01-01",
        mayan: "5000-01-01",
        nanakshahi: "1000-01-01",
        nepali: "2000-01-01",
        persian: "1000-01-01",
        jalali: "1000-01-01",
        taiwan: "1000-01-01",
        thai: "2000-01-01",
        ummalqura: "1400-01-01"
      };
      var CANONICAL_SUNDAY = {
        chinese: "2000-01-02",
        coptic: "2000-01-03",
        discworld: "2000-01-03",
        ethiopian: "2000-01-05",
        hebrew: "5000-01-01",
        islamic: "1000-01-02",
        julian: "2000-01-03",
        mayan: "5000-01-01",
        nanakshahi: "1000-01-05",
        nepali: "2000-01-05",
        persian: "1000-01-01",
        jalali: "1000-01-01",
        taiwan: "1000-01-04",
        thai: "2000-01-04",
        ummalqura: "1400-01-06"
      };
      var DFLTRANGE = {
        chinese: ["2000-01-01", "2001-01-01"],
        coptic: ["1700-01-01", "1701-01-01"],
        discworld: ["1800-01-01", "1801-01-01"],
        ethiopian: ["2000-01-01", "2001-01-01"],
        hebrew: ["5700-01-01", "5701-01-01"],
        islamic: ["1400-01-01", "1401-01-01"],
        julian: ["2000-01-01", "2001-01-01"],
        mayan: ["5200-01-01", "5201-01-01"],
        nanakshahi: ["0500-01-01", "0501-01-01"],
        nepali: ["2000-01-01", "2001-01-01"],
        persian: ["1400-01-01", "1401-01-01"],
        jalali: ["1400-01-01", "1401-01-01"],
        taiwan: ["0100-01-01", "0101-01-01"],
        thai: ["2500-01-01", "2501-01-01"],
        ummalqura: ["1400-01-01", "1401-01-01"]
      };
      var UNKNOWN = "##";
      var d3ToWorldCalendars = {
        d: { 0: "dd", "-": "d" },
        // 2-digit or unpadded day of month
        e: { 0: "d", "-": "d" },
        // alternate, always unpadded day of month
        a: { 0: "D", "-": "D" },
        // short weekday name
        A: { 0: "DD", "-": "DD" },
        // full weekday name
        j: { 0: "oo", "-": "o" },
        // 3-digit or unpadded day of the year
        W: { 0: "ww", "-": "w" },
        // 2-digit or unpadded week of the year (Monday first)
        m: { 0: "mm", "-": "m" },
        // 2-digit or unpadded month number
        b: { 0: "M", "-": "M" },
        // short month name
        B: { 0: "MM", "-": "MM" },
        // full month name
        y: { 0: "yy", "-": "yy" },
        // 2-digit year (map unpadded to zero-padded)
        Y: { 0: "yyyy", "-": "yyyy" },
        // 4-digit year (map unpadded to zero-padded)
        U: UNKNOWN,
        // Sunday-first week of the year
        w: UNKNOWN,
        // day of the week [0(sunday),6]
        // combined format, we replace the date part with the world-calendar version
        // and the %X stays there for d3 to handle with time parts
        c: { 0: "D M d %X yyyy", "-": "D M d %X yyyy" },
        x: { 0: "mm/dd/yyyy", "-": "mm/dd/yyyy" }
      };
      function worldCalFmt(fmt, x, calendar) {
        var dateJD = Math.floor((x + 0.05) / ONEDAY) + EPOCHJD;
        var cDate = getCal(calendar).fromJD(dateJD);
        var i = 0;
        var modifier, directive, directiveLen, directiveObj, replacementPart;
        while ((i = fmt.indexOf("%", i)) !== -1) {
          modifier = fmt.charAt(i + 1);
          if (modifier === "0" || modifier === "-" || modifier === "_") {
            directiveLen = 3;
            directive = fmt.charAt(i + 2);
            if (modifier === "_") modifier = "-";
          } else {
            directive = modifier;
            modifier = "0";
            directiveLen = 2;
          }
          directiveObj = d3ToWorldCalendars[directive];
          if (!directiveObj) {
            i += directiveLen;
          } else {
            if (directiveObj === UNKNOWN) replacementPart = UNKNOWN;
            else replacementPart = cDate.formatDate(directiveObj[modifier]);
            fmt = fmt.substr(0, i) + replacementPart + fmt.substr(i + directiveLen);
            i += replacementPart.length;
          }
        }
        return fmt;
      }
      var allCals = {};
      function getCal(calendar) {
        var calendarObj = allCals[calendar];
        if (calendarObj) return calendarObj;
        calendarObj = allCals[calendar] = calendars.instance(calendar);
        return calendarObj;
      }
      function makeAttrs(description) {
        return Lib.extendFlat({}, attributes, { description });
      }
      function makeTraceAttrsDescription(coord) {
        return "Sets the calendar system to use with `" + coord + "` date data.";
      }
      var xAttrs = {
        xcalendar: makeAttrs(makeTraceAttrsDescription("x"))
      };
      var xyAttrs = Lib.extendFlat({}, xAttrs, {
        ycalendar: makeAttrs(makeTraceAttrsDescription("y"))
      });
      var xyzAttrs = Lib.extendFlat({}, xyAttrs, {
        zcalendar: makeAttrs(makeTraceAttrsDescription("z"))
      });
      var axisAttrs = makeAttrs([
        "Sets the calendar system to use for `range` and `tick0`",
        "if this is a date axis. This does not set the calendar for",
        "interpreting data on this axis, that's specified in the trace",
        "or via the global `layout.calendar`"
      ].join(" "));
      module.exports = {
        moduleType: "component",
        name: "calendars",
        schema: {
          traces: {
            scatter: xyAttrs,
            bar: xyAttrs,
            box: xyAttrs,
            heatmap: xyAttrs,
            contour: xyAttrs,
            histogram: xyAttrs,
            histogram2d: xyAttrs,
            histogram2dcontour: xyAttrs,
            scatter3d: xyzAttrs,
            surface: xyzAttrs,
            mesh3d: xyzAttrs,
            scattergl: xyAttrs,
            ohlc: xAttrs,
            candlestick: xAttrs
          },
          layout: {
            calendar: makeAttrs([
              "Sets the default calendar system to use for interpreting and",
              "displaying dates throughout the plot."
            ].join(" "))
          },
          subplots: {
            xaxis: { calendar: axisAttrs },
            yaxis: { calendar: axisAttrs },
            scene: {
              xaxis: { calendar: axisAttrs },
              // TODO: it's actually redundant to include yaxis and zaxis here
              // because in the scene attributes these are the same object so merging
              // into one merges into them all. However, I left them in for parity with
              // cartesian, where yaxis is unused until we Plotschema.get() when we
              // use its presence or absence to determine whether to delete attributes
              // from yaxis if they only apply to x (rangeselector/rangeslider)
              yaxis: { calendar: axisAttrs },
              zaxis: { calendar: axisAttrs }
            },
            polar: {
              radialaxis: { calendar: axisAttrs }
            }
          }
        },
        layoutAttributes: attributes,
        handleDefaults,
        handleTraceDefaults,
        CANONICAL_SUNDAY,
        CANONICAL_TICK,
        DFLTRANGE,
        getCal,
        worldCalFmt
      };
    }
  });

  // lib/calendars.js
  var require_calendars3 = __commonJS({
    "lib/calendars.js"(exports, module) {
      "use strict";
      module.exports = require_calendars2();
    }
  });

  // lib/index-cartesian.js
  var require_index_cartesian = __commonJS({
    "lib/index-cartesian.js"(exports, module) {
      var Plotly = require_core2();
      Plotly.register([
        // traces
        require_bar2(),
        require_box2(),
        require_heatmap2(),
        require_histogram2(),
        require_histogram2d2(),
        require_histogram2dcontour2(),
        require_contour2(),
        require_scatterternary2(),
        require_violin2(),
        require_image2(),
        require_pie2(),
        // components
        require_calendars3()
      ]);
      module.exports = Plotly;
    }
  });
  return require_index_cartesian();
})();
/*! Bundled license information:

native-promise-only/lib/npo.src.js:
  (*! Native Promise Only
      v0.8.1 (c) Kyle Simpson
      MIT License: http://getify.mit-license.org
  *)

polybooljs/index.js:
  (*
   * @copyright 2016 Sean Connelly (@voidqk), http://syntheti.cc
   * @license MIT
   * @preserve Project Home: https://github.com/voidqk/polybooljs
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

assert/build/internal/util/comparisons.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/

window.Plotly = Plotly;
return Plotly;
}));