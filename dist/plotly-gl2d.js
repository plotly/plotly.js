/**
* plotly.js (gl2d) v3.0.1
* Copyright 2012-2025, Plotly, Inc.
* All rights reserved.
* Licensed under the MIT license
*/
(
 function(root, factory) {
  if (typeof module === "object" && module.exports) {
   module.exports = factory();
  } else {
   root.moduleName = factory();
  }
} (typeof self !== "undefined" ? self : this, () => {
"use strict";
var Plotly = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/version.js
  var require_version = __commonJS({
    "src/version.js"(exports) {
      "use strict";
      exports.version = "3.0.1";
    }
  });

  // node_modules/native-promise-only/lib/npo.src.js
  var require_npo_src = __commonJS({
    "node_modules/native-promise-only/lib/npo.src.js"(exports, module) {
      (function UMD(name, context, definition) {
        context[name] = context[name] || definition();
        if (typeof module != "undefined" && module.exports) {
          module.exports = context[name];
        } else if (typeof define == "function" && false) {
          define(function $AMD$() {
            return context[name];
          });
        }
      })("Promise", typeof window != "undefined" ? window : exports, function DEF() {
        "use strict";
        var builtInProp, cycle, scheduling_queue, ToString = Object.prototype.toString, timer = typeof setImmediate != "undefined" ? function timer2(fn) {
          return setImmediate(fn);
        } : setTimeout;
        try {
          Object.defineProperty({}, "x", {});
          builtInProp = function builtInProp2(obj, name, val, config) {
            return Object.defineProperty(obj, name, {
              value: val,
              writable: true,
              configurable: config !== false
            });
          };
        } catch (err) {
          builtInProp = function builtInProp2(obj, name, val) {
            obj[name] = val;
            return obj;
          };
        }
        scheduling_queue = /* @__PURE__ */ function Queue() {
          var first, last, item;
          function Item(fn, self2) {
            this.fn = fn;
            this.self = self2;
            this.next = void 0;
          }
          return {
            add: function add(fn, self2) {
              item = new Item(fn, self2);
              if (last) {
                last.next = item;
              } else {
                first = item;
              }
              last = item;
              item = void 0;
            },
            drain: function drain() {
              var f = first;
              first = last = cycle = void 0;
              while (f) {
                f.fn.call(f.self);
                f = f.next;
              }
            }
          };
        }();
        function schedule(fn, self2) {
          scheduling_queue.add(fn, self2);
          if (!cycle) {
            cycle = timer(scheduling_queue.drain);
          }
        }
        function isThenable(o) {
          var _then, o_type = typeof o;
          if (o != null && (o_type == "object" || o_type == "function")) {
            _then = o.then;
          }
          return typeof _then == "function" ? _then : false;
        }
        function notify() {
          for (var i = 0; i < this.chain.length; i++) {
            notifyIsolated(
              this,
              this.state === 1 ? this.chain[i].success : this.chain[i].failure,
              this.chain[i]
            );
          }
          this.chain.length = 0;
        }
        function notifyIsolated(self2, cb, chain) {
          var ret, _then;
          try {
            if (cb === false) {
              chain.reject(self2.msg);
            } else {
              if (cb === true) {
                ret = self2.msg;
              } else {
                ret = cb.call(void 0, self2.msg);
              }
              if (ret === chain.promise) {
                chain.reject(TypeError("Promise-chain cycle"));
              } else if (_then = isThenable(ret)) {
                _then.call(ret, chain.resolve, chain.reject);
              } else {
                chain.resolve(ret);
              }
            }
          } catch (err) {
            chain.reject(err);
          }
        }
        function resolve(msg) {
          var _then, self2 = this;
          if (self2.triggered) {
            return;
          }
          self2.triggered = true;
          if (self2.def) {
            self2 = self2.def;
          }
          try {
            if (_then = isThenable(msg)) {
              schedule(function() {
                var def_wrapper = new MakeDefWrapper(self2);
                try {
                  _then.call(
                    msg,
                    function $resolve$() {
                      resolve.apply(def_wrapper, arguments);
                    },
                    function $reject$() {
                      reject.apply(def_wrapper, arguments);
                    }
                  );
                } catch (err) {
                  reject.call(def_wrapper, err);
                }
              });
            } else {
              self2.msg = msg;
              self2.state = 1;
              if (self2.chain.length > 0) {
                schedule(notify, self2);
              }
            }
          } catch (err) {
            reject.call(new MakeDefWrapper(self2), err);
          }
        }
        function reject(msg) {
          var self2 = this;
          if (self2.triggered) {
            return;
          }
          self2.triggered = true;
          if (self2.def) {
            self2 = self2.def;
          }
          self2.msg = msg;
          self2.state = 2;
          if (self2.chain.length > 0) {
            schedule(notify, self2);
          }
        }
        function iteratePromises(Constructor, arr, resolver, rejecter) {
          for (var idx = 0; idx < arr.length; idx++) {
            (function IIFE(idx2) {
              Constructor.resolve(arr[idx2]).then(
                function $resolver$(msg) {
                  resolver(idx2, msg);
                },
                rejecter
              );
            })(idx);
          }
        }
        function MakeDefWrapper(self2) {
          this.def = self2;
          this.triggered = false;
        }
        function MakeDef(self2) {
          this.promise = self2;
          this.state = 0;
          this.triggered = false;
          this.chain = [];
          this.msg = void 0;
        }
        function Promise2(executor) {
          if (typeof executor != "function") {
            throw TypeError("Not a function");
          }
          if (this.__NPO__ !== 0) {
            throw TypeError("Not a promise");
          }
          this.__NPO__ = 1;
          var def = new MakeDef(this);
          this["then"] = function then(success, failure) {
            var o = {
              success: typeof success == "function" ? success : true,
              failure: typeof failure == "function" ? failure : false
            };
            o.promise = new this.constructor(function extractChain(resolve2, reject2) {
              if (typeof resolve2 != "function" || typeof reject2 != "function") {
                throw TypeError("Not a function");
              }
              o.resolve = resolve2;
              o.reject = reject2;
            });
            def.chain.push(o);
            if (def.state !== 0) {
              schedule(notify, def);
            }
            return o.promise;
          };
          this["catch"] = function $catch$(failure) {
            return this.then(void 0, failure);
          };
          try {
            executor.call(
              void 0,
              function publicResolve(msg) {
                resolve.call(def, msg);
              },
              function publicReject(msg) {
                reject.call(def, msg);
              }
            );
          } catch (err) {
            reject.call(def, err);
          }
        }
        var PromisePrototype = builtInProp(
          {},
          "constructor",
          Promise2,
          /*configurable=*/
          false
        );
        Promise2.prototype = PromisePrototype;
        builtInProp(
          PromisePrototype,
          "__NPO__",
          0,
          /*configurable=*/
          false
        );
        builtInProp(Promise2, "resolve", function Promise$resolve(msg) {
          var Constructor = this;
          if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
            return msg;
          }
          return new Constructor(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            resolve2(msg);
          });
        });
        builtInProp(Promise2, "reject", function Promise$reject(msg) {
          return new this(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            reject2(msg);
          });
        });
        builtInProp(Promise2, "all", function Promise$all(arr) {
          var Constructor = this;
          if (ToString.call(arr) != "[object Array]") {
            return Constructor.reject(TypeError("Not an array"));
          }
          if (arr.length === 0) {
            return Constructor.resolve([]);
          }
          return new Constructor(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            var len = arr.length, msgs = Array(len), count = 0;
            iteratePromises(Constructor, arr, function resolver(idx, msg) {
              msgs[idx] = msg;
              if (++count === len) {
                resolve2(msgs);
              }
            }, reject2);
          });
        });
        builtInProp(Promise2, "race", function Promise$race(arr) {
          var Constructor = this;
          if (ToString.call(arr) != "[object Array]") {
            return Constructor.reject(TypeError("Not an array"));
          }
          return new Constructor(function executor(resolve2, reject2) {
            if (typeof resolve2 != "function" || typeof reject2 != "function") {
              throw TypeError("Not a function");
            }
            iteratePromises(Constructor, arr, function resolver(idx, msg) {
              resolve2(msg);
            }, reject2);
          });
        });
        return Promise2;
      });
    }
  });

  // node_modules/@plotly/d3/d3.js
  var require_d3 = __commonJS({
    "node_modules/@plotly/d3/d3.js"(exports, module) {
      !function() {
        var d3 = {
          version: "3.8.2"
        };
        var d3_arraySlice = [].slice, d3_array = function(list) {
          return d3_arraySlice.call(list);
        };
        var d3_document = self.document;
        function d3_documentElement(node) {
          return node && (node.ownerDocument || node.document || node).documentElement;
        }
        function d3_window(node) {
          return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
        }
        if (d3_document) {
          try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
          } catch (e) {
            d3_array = function(list) {
              var i = list.length, array = new Array(i);
              while (i--) array[i] = list[i];
              return array;
            };
          }
        }
        if (!Date.now) Date.now = function() {
          return +/* @__PURE__ */ new Date();
        };
        if (d3_document) {
          try {
            d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
          } catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function(name, value) {
              d3_element_setAttribute.call(this, name, value + "");
            };
            d3_element_prototype.setAttributeNS = function(space, local, value) {
              d3_element_setAttributeNS.call(this, space, local, value + "");
            };
            d3_style_prototype.setProperty = function(name, value, priority) {
              d3_style_setProperty.call(this, name, value + "", priority);
            };
          }
        }
        d3.ascending = d3_ascending;
        function d3_ascending(a, b) {
          return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }
        d3.descending = function(a, b) {
          return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
        };
        d3.min = function(array, f) {
          var i = -1, n = array.length, a, b;
          if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = array[i]) != null && a > b) a = b;
          } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
          }
          return a;
        };
        d3.max = function(array, f) {
          var i = -1, n = array.length, a, b;
          if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = array[i]) != null && b > a) a = b;
          } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = b;
              break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
          }
          return a;
        };
        d3.extent = function(array, f) {
          var i = -1, n = array.length, a, b, c;
          if (arguments.length === 1) {
            while (++i < n) if ((b = array[i]) != null && b >= b) {
              a = c = b;
              break;
            }
            while (++i < n) if ((b = array[i]) != null) {
              if (a > b) a = b;
              if (c < b) c = b;
            }
          } else {
            while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
              a = c = b;
              break;
            }
            while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
              if (a > b) a = b;
              if (c < b) c = b;
            }
          }
          return [a, c];
        };
        function d3_number(x) {
          return x === null ? NaN : +x;
        }
        function d3_numeric(x) {
          return !isNaN(x);
        }
        d3.sum = function(array, f) {
          var s = 0, n = array.length, a, i = -1;
          if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = +array[i])) s += a;
          } else {
            while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
          }
          return s;
        };
        d3.mean = function(array, f) {
          var s = 0, n = array.length, a, i = -1, j = n;
          if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a;
            else --j;
          } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a;
            else --j;
          }
          if (j) return s / j;
        };
        d3.quantile = function(values, p) {
          var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
          return e ? v + e * (values[h] - v) : v;
        };
        d3.median = function(array, f) {
          var numbers = [], n = array.length, a, i = -1;
          if (arguments.length === 1) {
            while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
          } else {
            while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
          }
          if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), 0.5);
        };
        d3.variance = function(array, f) {
          var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
          if (arguments.length === 1) {
            while (++i < n) {
              if (d3_numeric(a = d3_number(array[i]))) {
                d = a - m;
                m += d / ++j;
                s += d * (a - m);
              }
            }
          } else {
            while (++i < n) {
              if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                d = a - m;
                m += d / ++j;
                s += d * (a - m);
              }
            }
          }
          if (j > 1) return s / (j - 1);
        };
        d3.deviation = function() {
          var v = d3.variance.apply(this, arguments);
          return v ? Math.sqrt(v) : v;
        };
        function d3_bisector(compare) {
          return {
            left: function(a, x, lo, hi) {
              if (arguments.length < 3) lo = 0;
              if (arguments.length < 4) hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
              }
              return lo;
            },
            right: function(a, x, lo, hi) {
              if (arguments.length < 3) lo = 0;
              if (arguments.length < 4) hi = a.length;
              while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (compare(a[mid], x) > 0) hi = mid;
                else lo = mid + 1;
              }
              return lo;
            }
          };
        }
        var d3_bisect = d3_bisector(d3_ascending);
        d3.bisectLeft = d3_bisect.left;
        d3.bisect = d3.bisectRight = d3_bisect.right;
        d3.bisector = function(f) {
          return d3_bisector(f.length === 1 ? function(d, x) {
            return d3_ascending(f(d), x);
          } : f);
        };
        d3.shuffle = function(array, i0, i1) {
          if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2) i0 = 0;
          }
          var m = i1 - i0, t, i;
          while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
          }
          return array;
        };
        d3.permute = function(array, indexes) {
          var i = indexes.length, permutes = new Array(i);
          while (i--) permutes[i] = array[indexes[i]];
          return permutes;
        };
        d3.pairs = function(array) {
          var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
          while (i < n) pairs[i] = [p0 = p1, p1 = array[++i]];
          return pairs;
        };
        d3.transpose = function(matrix) {
          if (!(n = matrix.length)) return [];
          for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
              row[j] = matrix[j][i];
            }
          }
          return transpose;
        };
        function d3_transposeLength(d) {
          return d.length;
        }
        d3.zip = function() {
          return d3.transpose(arguments);
        };
        d3.keys = function(map) {
          var keys = [];
          for (var key in map) keys.push(key);
          return keys;
        };
        d3.values = function(map) {
          var values = [];
          for (var key in map) values.push(map[key]);
          return values;
        };
        d3.entries = function(map) {
          var entries = [];
          for (var key in map) entries.push({
            key,
            value: map[key]
          });
          return entries;
        };
        d3.merge = function(arrays) {
          var n = arrays.length, m, i = -1, j = 0, merged, array;
          while (++i < n) j += arrays[i].length;
          merged = new Array(j);
          while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
              merged[--j] = array[m];
            }
          }
          return merged;
        };
        var abs = Math.abs;
        d3.range = function(start, stop, step) {
          if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
              stop = start;
              start = 0;
            }
          }
          if ((stop - start) / step === Infinity) throw new Error("infinite range");
          var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
          start *= k, stop *= k, step *= k;
          if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);
          else while ((j = start + step * ++i) < stop) range.push(j / k);
          return range;
        };
        function d3_range_integerScale(x) {
          var k = 1;
          while (x * k % 1) k *= 10;
          return k;
        }
        function d3_class(ctor, properties) {
          for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
              value: properties[key],
              enumerable: false
            });
          }
        }
        d3.map = function(object, f) {
          var map = new d3_Map();
          if (object instanceof d3_Map) {
            object.forEach(function(key2, value) {
              map.set(key2, value);
            });
          } else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1) while (++i < n) map.set(i, object[i]);
            else while (++i < n) map.set(f.call(object, o = object[i], i), o);
          } else {
            for (var key in object) map.set(key, object[key]);
          }
          return map;
        };
        function d3_Map() {
          this._ = /* @__PURE__ */ Object.create(null);
        }
        var d3_map_proto = "__proto__", d3_map_zero = "\0";
        d3_class(d3_Map, {
          has: d3_map_has,
          get: function(key) {
            return this._[d3_map_escape(key)];
          },
          set: function(key, value) {
            return this._[d3_map_escape(key)] = value;
          },
          remove: d3_map_remove,
          keys: d3_map_keys,
          values: function() {
            var values = [];
            for (var key in this._) values.push(this._[key]);
            return values;
          },
          entries: function() {
            var entries = [];
            for (var key in this._) entries.push({
              key: d3_map_unescape(key),
              value: this._[key]
            });
            return entries;
          },
          size: d3_map_size,
          empty: d3_map_empty,
          forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
          }
        });
        function d3_map_escape(key) {
          return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
        }
        function d3_map_unescape(key) {
          return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
        }
        function d3_map_has(key) {
          return d3_map_escape(key) in this._;
        }
        function d3_map_remove(key) {
          return (key = d3_map_escape(key)) in this._ && delete this._[key];
        }
        function d3_map_keys() {
          var keys = [];
          for (var key in this._) keys.push(d3_map_unescape(key));
          return keys;
        }
        function d3_map_size() {
          var size = 0;
          for (var key in this._) ++size;
          return size;
        }
        function d3_map_empty() {
          for (var key in this._) return false;
          return true;
        }
        d3.nest = function() {
          var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
          function map(mapType, array, depth) {
            if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
              if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                values.push(object);
              } else {
                valuesByKey.set(keyValue, [object]);
              }
            }
            if (mapType) {
              object = mapType();
              setter = function(keyValue2, values2) {
                object.set(keyValue2, map(mapType, values2, depth));
              };
            } else {
              object = {};
              setter = function(keyValue2, values2) {
                object[keyValue2] = map(mapType, values2, depth);
              };
            }
            valuesByKey.forEach(setter);
            return object;
          }
          function entries(map2, depth) {
            if (depth >= keys.length) return map2;
            var array = [], sortKey = sortKeys[depth++];
            map2.forEach(function(key, keyMap) {
              array.push({
                key,
                values: entries(keyMap, depth)
              });
            });
            return sortKey ? array.sort(function(a, b) {
              return sortKey(a.key, b.key);
            }) : array;
          }
          nest.map = function(array, mapType) {
            return map(mapType, array, 0);
          };
          nest.entries = function(array) {
            return entries(map(d3.map, array, 0), 0);
          };
          nest.key = function(d) {
            keys.push(d);
            return nest;
          };
          nest.sortKeys = function(order) {
            sortKeys[keys.length - 1] = order;
            return nest;
          };
          nest.sortValues = function(order) {
            sortValues = order;
            return nest;
          };
          nest.rollup = function(f) {
            rollup = f;
            return nest;
          };
          return nest;
        };
        d3.set = function(array) {
          var set = new d3_Set();
          if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
          return set;
        };
        function d3_Set() {
          this._ = /* @__PURE__ */ Object.create(null);
        }
        d3_class(d3_Set, {
          has: d3_map_has,
          add: function(key) {
            this._[d3_map_escape(key += "")] = true;
            return key;
          },
          remove: d3_map_remove,
          values: d3_map_keys,
          size: d3_map_size,
          empty: d3_map_empty,
          forEach: function(f) {
            for (var key in this._) f.call(this, d3_map_unescape(key));
          }
        });
        d3.behavior = {};
        function d3_identity(d) {
          return d;
        }
        d3.rebind = function(target, source) {
          var i = 1, n = arguments.length, method;
          while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
          return target;
        };
        function d3_rebind(target, source, method) {
          return function() {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
          };
        }
        function d3_vendorSymbol(object, name) {
          if (name in object) return name;
          name = name.charAt(0).toUpperCase() + name.slice(1);
          for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object) return prefixName;
          }
        }
        var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
        function d3_noop() {
        }
        d3.dispatch = function() {
          var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
          while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
          return dispatch;
        };
        function d3_dispatch() {
        }
        d3_dispatch.prototype.on = function(type, listener) {
          var i = type.indexOf("."), name = "";
          if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
          }
          if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
          if (arguments.length === 2) {
            if (listener == null) for (type in this) {
              if (this.hasOwnProperty(type)) this[type].on(name, null);
            }
            return this;
          }
        };
        function d3_dispatch_event(dispatch) {
          var listeners = [], listenerByName = new d3_Map();
          function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n) if (l = z[i].on) l.apply(this, arguments);
            return dispatch;
          }
          event.on = function(name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2) return l && l.on;
            if (l) {
              l.on = null;
              listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
              listenerByName.remove(name);
            }
            if (listener) listeners.push(listenerByName.set(name, {
              on: listener
            }));
            return dispatch;
          };
          return event;
        }
        d3.event = null;
        function d3_eventPreventDefault() {
          d3.event.preventDefault();
        }
        function d3_eventSource() {
          var e = d3.event, s;
          while (s = e.sourceEvent) e = s;
          return e;
        }
        function d3_eventDispatch(target) {
          var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
          while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
          dispatch.of = function(thiz, argumentz) {
            return function(e1) {
              try {
                var e0 = e1.sourceEvent = d3.event;
                e1.target = target;
                d3.event = e1;
                dispatch[e1.type].apply(thiz, argumentz);
              } finally {
                d3.event = e0;
              }
            };
          };
          return dispatch;
        }
        d3.requote = function(s) {
          return s.replace(d3_requote_re, "\\$&");
        };
        var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
        var d3_subclass = {}.__proto__ ? function(object, prototype) {
          object.__proto__ = prototype;
        } : function(object, prototype) {
          for (var property in prototype) object[property] = prototype[property];
        };
        function d3_selection(groups) {
          d3_subclass(groups, d3_selectionPrototype);
          return groups;
        }
        var d3_select = function(s, n) {
          return n.querySelector(s);
        }, d3_selectAll = function(s, n) {
          return n.querySelectorAll(s);
        }, d3_selectMatches = function(n, s) {
          var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
          d3_selectMatches = function(n2, s2) {
            return d3_selectMatcher.call(n2, s2);
          };
          return d3_selectMatches(n, s);
        };
        if (typeof Sizzle === "function") {
          d3_select = function(s, n) {
            return Sizzle(s, n)[0] || null;
          };
          d3_selectAll = Sizzle;
          d3_selectMatches = Sizzle.matchesSelector;
        }
        d3.selection = function() {
          return d3.select(d3_document.documentElement);
        };
        var d3_selectionPrototype = d3.selection.prototype = [];
        d3_selectionPrototype.select = function(selector) {
          var subgroups = [], subgroup, subnode, group, node;
          selector = d3_selection_selector(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_selector(selector) {
          return typeof selector === "function" ? selector : function() {
            return d3_select(selector, this);
          };
        }
        d3_selectionPrototype.selectAll = function(selector) {
          var subgroups = [], subgroup, node;
          selector = d3_selection_selectorAll(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                subgroup.parentNode = node;
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_selectorAll(selector) {
          return typeof selector === "function" ? selector : function() {
            return d3_selectAll(selector, this);
          };
        }
        var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
        var d3_nsPrefix = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: d3_nsXhtml,
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/"
        };
        d3.ns = {
          prefix: d3_nsPrefix,
          qualify: function(name) {
            var i = name.indexOf(":"), prefix = name;
            if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
              space: d3_nsPrefix[prefix],
              local: name
            } : name;
          }
        };
        d3_selectionPrototype.attr = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") {
              var node = this.node();
              name = d3.ns.qualify(name);
              return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name) this.each(d3_selection_attr(value, name[value]));
            return this;
          }
          return this.each(d3_selection_attr(name, value));
        };
        function d3_selection_attr(name, value) {
          name = d3.ns.qualify(name);
          function attrNull() {
            this.removeAttribute(name);
          }
          function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
          }
          function attrConstant() {
            this.setAttribute(name, value);
          }
          function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
          }
          function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttribute(name);
            else this.setAttribute(name, x);
          }
          function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null) this.removeAttributeNS(name.space, name.local);
            else this.setAttributeNS(name.space, name.local, x);
          }
          return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
        }
        function d3_collapse(s) {
          return s.trim().replace(/\s+/g, " ");
        }
        d3_selectionPrototype.classed = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") {
              var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
              if (value = node.classList) {
                while (++i < n) if (!value.contains(name[i])) return false;
              } else {
                value = node.getAttribute("class");
                while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
              }
              return true;
            }
            for (value in name) this.each(d3_selection_classed(value, name[value]));
            return this;
          }
          return this.each(d3_selection_classed(name, value));
        };
        function d3_selection_classedRe(name) {
          return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
        }
        function d3_selection_classes(name) {
          return (name + "").trim().split(/^|\s+/);
        }
        function d3_selection_classed(name, value) {
          name = d3_selection_classes(name).map(d3_selection_classedName);
          var n = name.length;
          function classedConstant() {
            var i = -1;
            while (++i < n) name[i](this, value);
          }
          function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n) name[i](this, x);
          }
          return typeof value === "function" ? classedFunction : classedConstant;
        }
        function d3_selection_classedName(name) {
          var re = d3_selection_classedRe(name);
          return function(node, value) {
            if (c = node.classList) return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            if (value) {
              re.lastIndex = 0;
              if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
            } else {
              node.setAttribute("class", d3_collapse(c.replace(re, " ")));
            }
          };
        }
        d3_selectionPrototype.style = function(name, value, priority) {
          var n = arguments.length;
          if (n < 3) {
            if (typeof name !== "string") {
              if (n < 2) value = "";
              for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
              return this;
            }
            if (n < 2) {
              var node = this.node();
              return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = "";
          }
          return this.each(d3_selection_style(name, value, priority));
        };
        function d3_selection_style(name, value, priority) {
          function styleNull() {
            this.style.removeProperty(name);
          }
          function styleConstant() {
            this.style.setProperty(name, value, priority);
          }
          function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null) this.style.removeProperty(name);
            else this.style.setProperty(name, x, priority);
          }
          return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
        }
        d3_selectionPrototype.property = function(name, value) {
          if (arguments.length < 2) {
            if (typeof name === "string") return this.node()[name];
            for (value in name) this.each(d3_selection_property(value, name[value]));
            return this;
          }
          return this.each(d3_selection_property(name, value));
        };
        function d3_selection_property(name, value) {
          function propertyNull() {
            delete this[name];
          }
          function propertyConstant() {
            this[name] = value;
          }
          function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null) delete this[name];
            else this[name] = x;
          }
          return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
        }
        d3_selectionPrototype.text = function(value) {
          return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
          } : value == null ? function() {
            this.textContent = "";
          } : function() {
            this.textContent = value;
          }) : this.node().textContent;
        };
        d3_selectionPrototype.html = function(value) {
          return arguments.length ? this.each(typeof value === "function" ? function() {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
          } : value == null ? function() {
            this.innerHTML = "";
          } : function() {
            this.innerHTML = value;
          }) : this.node().innerHTML;
        };
        d3_selectionPrototype.append = function(name) {
          name = d3_selection_creator(name);
          return this.select(function() {
            return this.appendChild(name.apply(this, arguments));
          });
        };
        function d3_selection_creator(name) {
          function create() {
            var document2 = this.ownerDocument, namespace = this.namespaceURI;
            return namespace === d3_nsXhtml && document2.documentElement.namespaceURI === d3_nsXhtml ? document2.createElement(name) : document2.createElementNS(namespace, name);
          }
          function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
          }
          return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
        }
        d3_selectionPrototype.insert = function(name, before) {
          name = d3_selection_creator(name);
          before = d3_selection_selector(before);
          return this.select(function() {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
          });
        };
        d3_selectionPrototype.remove = function() {
          return this.each(d3_selectionRemove);
        };
        function d3_selectionRemove() {
          var parent = this.parentNode;
          if (parent) parent.removeChild(this);
        }
        d3_selectionPrototype.data = function(value, key) {
          var i = -1, n = this.length, group, node;
          if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
              if (node = group[i]) {
                value[i] = node.__data__;
              }
            }
            return value;
          }
          function bind(group2, groupData) {
            var i2, n2 = group2.length, m = groupData.length, n0 = Math.min(n2, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n2), node2, nodeData;
            if (key) {
              var nodeByKeyValue = new d3_Map(), keyValues = new Array(n2), keyValue;
              for (i2 = -1; ++i2 < n2; ) {
                if (node2 = group2[i2]) {
                  if (nodeByKeyValue.has(keyValue = key.call(node2, node2.__data__, i2))) {
                    exitNodes[i2] = node2;
                  } else {
                    nodeByKeyValue.set(keyValue, node2);
                  }
                  keyValues[i2] = keyValue;
                }
              }
              for (i2 = -1; ++i2 < m; ) {
                if (!(node2 = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i2], i2)))) {
                  enterNodes[i2] = d3_selection_dataNode(nodeData);
                } else if (node2 !== true) {
                  updateNodes[i2] = node2;
                  node2.__data__ = nodeData;
                }
                nodeByKeyValue.set(keyValue, true);
              }
              for (i2 = -1; ++i2 < n2; ) {
                if (i2 in keyValues && nodeByKeyValue.get(keyValues[i2]) !== true) {
                  exitNodes[i2] = group2[i2];
                }
              }
            } else {
              for (i2 = -1; ++i2 < n0; ) {
                node2 = group2[i2];
                nodeData = groupData[i2];
                if (node2) {
                  node2.__data__ = nodeData;
                  updateNodes[i2] = node2;
                } else {
                  enterNodes[i2] = d3_selection_dataNode(nodeData);
                }
              }
              for (; i2 < m; ++i2) {
                enterNodes[i2] = d3_selection_dataNode(groupData[i2]);
              }
              for (; i2 < n2; ++i2) {
                exitNodes[i2] = group2[i2];
              }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group2.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
          }
          var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
          if (typeof value === "function") {
            while (++i < n) {
              bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
          } else {
            while (++i < n) {
              bind(group = this[i], value);
            }
          }
          update.enter = function() {
            return enter;
          };
          update.exit = function() {
            return exit;
          };
          return update;
        };
        function d3_selection_dataNode(data) {
          return {
            __data__: data
          };
        }
        d3_selectionPrototype.datum = function(value) {
          return arguments.length ? this.property("__data__", value) : this.property("__data__");
        };
        d3_selectionPrototype.filter = function(filter) {
          var subgroups = [], subgroup, group, node;
          if (typeof filter !== "function") filter = d3_selection_filter(filter);
          for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
              if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                subgroup.push(node);
              }
            }
          }
          return d3_selection(subgroups);
        };
        function d3_selection_filter(selector) {
          return function() {
            return d3_selectMatches(this, selector);
          };
        }
        d3_selectionPrototype.order = function() {
          for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
              if (node = group[i]) {
                if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                next = node;
              }
            }
          }
          return this;
        };
        d3_selectionPrototype.sort = function(comparator) {
          comparator = d3_selection_sortComparator.apply(this, arguments);
          for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
          return this.order();
        };
        function d3_selection_sortComparator(comparator) {
          if (!arguments.length) comparator = d3_ascending;
          return function(a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
          };
        }
        d3_selectionPrototype.each = function(callback) {
          return d3_selection_each(this, function(node, i, j) {
            callback.call(node, node.__data__, i, j);
          });
        };
        function d3_selection_each(groups, callback) {
          for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
              if (node = group[i]) callback(node, i, j);
            }
          }
          return groups;
        }
        d3_selectionPrototype.call = function(callback) {
          var args = d3_array(arguments);
          callback.apply(args[0] = this, args);
          return this;
        };
        d3_selectionPrototype.empty = function() {
          return !this.node();
        };
        d3_selectionPrototype.node = function() {
          for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
              var node = group[i];
              if (node) return node;
            }
          }
          return null;
        };
        d3_selectionPrototype.size = function() {
          var n = 0;
          d3_selection_each(this, function() {
            ++n;
          });
          return n;
        };
        function d3_selection_enter(selection) {
          d3_subclass(selection, d3_selection_enterPrototype);
          return selection;
        }
        var d3_selection_enterPrototype = [];
        d3.selection.enter = d3_selection_enter;
        d3.selection.enter.prototype = d3_selection_enterPrototype;
        d3_selection_enterPrototype.append = d3_selectionPrototype.append;
        d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
        d3_selection_enterPrototype.node = d3_selectionPrototype.node;
        d3_selection_enterPrototype.call = d3_selectionPrototype.call;
        d3_selection_enterPrototype.size = d3_selectionPrototype.size;
        d3_selection_enterPrototype.select = function(selector) {
          var subgroups = [], subgroup, subnode, upgroup, group, node;
          for (var j = -1, m = this.length; ++j < m; ) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                subnode.__data__ = node.__data__;
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_selection(subgroups);
        };
        d3_selection_enterPrototype.insert = function(name, before) {
          if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
          return d3_selectionPrototype.insert.call(this, name, before);
        };
        function d3_selection_enterInsertBefore(enter) {
          var i0, j0;
          return function(d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0) j0 = j, i0 = 0;
            if (i >= i0) i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n) ;
            return node;
          };
        }
        d3.select = function(node) {
          var group;
          if (typeof node === "string") {
            group = [d3_select(node, d3_document)];
            group.parentNode = d3_document.documentElement;
          } else {
            group = [node];
            group.parentNode = d3_documentElement(node);
          }
          return d3_selection([group]);
        };
        d3.selectAll = function(nodes) {
          var group;
          if (typeof nodes === "string") {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
          } else {
            group = d3_array(nodes);
            group.parentNode = null;
          }
          return d3_selection([group]);
        };
        d3_selectionPrototype.on = function(type, listener, capture) {
          var n = arguments.length;
          if (n < 3) {
            if (typeof type !== "string") {
              if (n < 2) listener = false;
              for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
              return this;
            }
            if (n < 2) return (n = this.node()["__on" + type]) && n._;
            capture = false;
          }
          return this.each(d3_selection_on(type, listener, capture));
        };
        function d3_selection_on(type, listener, capture) {
          var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
          if (i > 0) type = type.slice(0, i);
          var filter = d3_selection_onFilters.get(type);
          if (filter) type = filter, wrap = d3_selection_onFilter;
          function onRemove() {
            var l = this[name];
            if (l) {
              this.removeEventListener(type, l, l.$);
              delete this[name];
            }
          }
          function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
          }
          function removeAll() {
            var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
            for (var name2 in this) {
              if (match = name2.match(re)) {
                var l = this[name2];
                this.removeEventListener(match[1], l, l.$);
                delete this[name2];
              }
            }
          }
          return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
        }
        var d3_selection_onFilters = d3.map({
          mouseenter: "mouseover",
          mouseleave: "mouseout"
        });
        if (d3_document) {
          d3_selection_onFilters.forEach(function(k) {
            if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
          });
        }
        function d3_selection_onListener(listener, argumentz) {
          return function(e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
              listener.apply(this, argumentz);
            } finally {
              d3.event = o;
            }
          };
        }
        function d3_selection_onFilter(listener, argumentz) {
          var l = d3_selection_onListener(listener, argumentz);
          return function(e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
              l.call(target, e);
            }
          };
        }
        var d3_event_dragSelect, d3_event_dragId = 0;
        function d3_event_dragSuppress(node) {
          var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
          if (d3_event_dragSelect == null) {
            d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
          }
          if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none";
          }
          return function(suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
            if (suppressClick) {
              var off = function() {
                w.on(click, null);
              };
              w.on(click, function() {
                d3_eventPreventDefault();
                off();
              }, true);
              setTimeout(off, 0);
            }
          };
        }
        d3.mouse = function(container) {
          return d3_mousePoint(container, d3_eventSource());
        };
        var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
        function d3_mousePoint(container, e) {
          if (e.changedTouches) e = e.changedTouches[0];
          var svg = container.ownerSVGElement || container;
          if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
              var window2 = d3_window(container);
              if (window2.scrollX || window2.scrollY) {
                svg = d3.select("body").append("svg").style({
                  position: "absolute",
                  top: 0,
                  left: 0,
                  margin: 0,
                  padding: 0,
                  border: "none"
                }, "important");
                var ctm = svg[0][0].getScreenCTM();
                d3_mouse_bug44083 = !(ctm.f || ctm.e);
                svg.remove();
              }
            }
            if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY;
            else point.x = e.clientX, point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [point.x, point.y];
          }
          var rect = container.getBoundingClientRect();
          return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
        }
        d3.touch = function(container, touches, identifier) {
          if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
          if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
              return d3_mousePoint(container, touch);
            }
          }
        };
        d3.behavior.drag = function() {
          var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
          function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
          }
          function dragstart(id, position, subject, move, end) {
            return function() {
              var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
              if (origin) {
                dragOffset = origin.apply(that, arguments);
                dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
              } else {
                dragOffset = [0, 0];
              }
              dispatch({
                type: "dragstart"
              });
              function moved() {
                var position1 = position(parent, dragId), dx, dy;
                if (!position1) return;
                dx = position1[0] - position0[0];
                dy = position1[1] - position0[1];
                dragged |= dx | dy;
                position0 = position1;
                dispatch({
                  type: "drag",
                  x: position1[0] + dragOffset[0],
                  y: position1[1] + dragOffset[1],
                  dx,
                  dy
                });
              }
              function ended() {
                if (!position(parent, dragId)) return;
                dragSubject.on(move + dragName, null).on(end + dragName, null);
                dragRestore(dragged);
                dispatch({
                  type: "dragend"
                });
              }
            };
          }
          drag.origin = function(x) {
            if (!arguments.length) return origin;
            origin = x;
            return drag;
          };
          return d3.rebind(drag, event, "on");
        };
        function d3_behavior_dragTouchId() {
          return d3.event.changedTouches[0].identifier;
        }
        d3.touches = function(container, touches) {
          if (arguments.length < 2) touches = d3_eventSource().touches;
          return touches ? d3_array(touches).map(function(touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
          }) : [];
        };
        var \u03B5 = 1e-6, \u03B52 = \u03B5 * \u03B5, \u03C0 = Math.PI, \u03C4 = 2 * \u03C0, \u03C4\u03B5 = \u03C4 - \u03B5, half\u03C0 = \u03C0 / 2, d3_radians = \u03C0 / 180, d3_degrees = 180 / \u03C0;
        function d3_sgn(x) {
          return x > 0 ? 1 : x < 0 ? -1 : 0;
        }
        function d3_cross2d(a, b, c) {
          return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
        }
        function d3_acos(x) {
          return x > 1 ? 0 : x < -1 ? \u03C0 : Math.acos(x);
        }
        function d3_asin(x) {
          return x > 1 ? half\u03C0 : x < -1 ? -half\u03C0 : Math.asin(x);
        }
        function d3_sinh(x) {
          return ((x = Math.exp(x)) - 1 / x) / 2;
        }
        function d3_cosh(x) {
          return ((x = Math.exp(x)) + 1 / x) / 2;
        }
        function d3_tanh(x) {
          return ((x = Math.exp(2 * x)) - 1) / (x + 1);
        }
        function d3_haversin(x) {
          return (x = Math.sin(x / 2)) * x;
        }
        var \u03C1 = Math.SQRT2, \u03C12 = 2, \u03C14 = 4;
        d3.interpolateZoom = function(p0, p1) {
          var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
          if (d2 < \u03B52) {
            S = Math.log(w1 / w0) / \u03C1;
            i = function(t) {
              return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(\u03C1 * t * S)];
            };
          } else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + \u03C14 * d2) / (2 * w0 * \u03C12 * d1), b1 = (w1 * w1 - w0 * w0 - \u03C14 * d2) / (2 * w1 * \u03C12 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / \u03C1;
            i = function(t) {
              var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (\u03C12 * d1) * (coshr0 * d3_tanh(\u03C1 * s + r0) - d3_sinh(r0));
              return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(\u03C1 * s + r0)];
            };
          }
          i.duration = S * 1e3;
          return i;
        };
        d3.behavior.zoom = function() {
          var view = {
            x: 0,
            y: 0,
            k: 1
          }, translate0, center0, center, size = [960, 500], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
          if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
              return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
            }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
              return d3.event.wheelDelta;
            }, "mousewheel") : (d3_behavior_zoomDelta = function() {
              return -d3.event.detail;
            }, "MozMousePixelScroll");
          }
          function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
          }
          zoom.event = function(g) {
            g.each(function() {
              var dispatch = event.of(this, arguments), view1 = view;
              if (d3_transitionInheritId) {
                d3.select(this).transition().each("start.zoom", function() {
                  view = this.__chart__ || {
                    x: 0,
                    y: 0,
                    k: 1
                  };
                  zoomstarted(dispatch);
                }).tween("zoom:zoom", function() {
                  var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                  return function(t) {
                    var l = i(t), k = dx / l[2];
                    this.__chart__ = view = {
                      x: cx - l[0] * k,
                      y: cy - l[1] * k,
                      k
                    };
                    zoomed(dispatch);
                  };
                }).each("interrupt.zoom", function() {
                  zoomended(dispatch);
                }).each("end.zoom", function() {
                  zoomended(dispatch);
                });
              } else {
                this.__chart__ = view;
                zoomstarted(dispatch);
                zoomed(dispatch);
                zoomended(dispatch);
              }
            });
          };
          zoom.translate = function(_) {
            if (!arguments.length) return [view.x, view.y];
            view = {
              x: +_[0],
              y: +_[1],
              k: view.k
            };
            rescale();
            return zoom;
          };
          zoom.scale = function(_) {
            if (!arguments.length) return view.k;
            view = {
              x: view.x,
              y: view.y,
              k: null
            };
            scaleTo(+_);
            rescale();
            return zoom;
          };
          zoom.scaleExtent = function(_) {
            if (!arguments.length) return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
            return zoom;
          };
          zoom.center = function(_) {
            if (!arguments.length) return center;
            center = _ && [+_[0], +_[1]];
            return zoom;
          };
          zoom.size = function(_) {
            if (!arguments.length) return size;
            size = _ && [+_[0], +_[1]];
            return zoom;
          };
          zoom.duration = function(_) {
            if (!arguments.length) return duration;
            duration = +_;
            return zoom;
          };
          zoom.x = function(z) {
            if (!arguments.length) return x1;
            x1 = z;
            x0 = z.copy();
            view = {
              x: 0,
              y: 0,
              k: 1
            };
            return zoom;
          };
          zoom.y = function(z) {
            if (!arguments.length) return y1;
            y1 = z;
            y0 = z.copy();
            view = {
              x: 0,
              y: 0,
              k: 1
            };
            return zoom;
          };
          function location(p) {
            return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
          }
          function point(l) {
            return [l[0] * view.k + view.x, l[1] * view.k + view.y];
          }
          function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
          }
          function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
          }
          function zoomTo(that, p, l, k) {
            that.__chart__ = {
              x: view.x,
              y: view.y,
              k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0) that = that.transition().duration(duration);
            that.call(zoom.event);
          }
          function rescale() {
            if (x1) x1.domain(x0.range().map(function(x) {
              return (x - view.x) / view.k;
            }).map(x0.invert));
            if (y1) y1.domain(y0.range().map(function(y) {
              return (y - view.y) / view.k;
            }).map(y0.invert));
          }
          function zoomstarted(dispatch) {
            if (!zooming++) dispatch({
              type: "zoomstart"
            });
          }
          function zoomed(dispatch) {
            rescale();
            dispatch({
              type: "zoom",
              scale: view.k,
              translate: [view.x, view.y]
            });
          }
          function zoomended(dispatch) {
            if (!--zooming) dispatch({
              type: "zoomend"
            }), center0 = null;
          }
          function mousedowned() {
            var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
              dragged = 1;
              translateTo(d3.mouse(that), location0);
              zoomed(dispatch);
            }
            function ended() {
              subject.on(mousemove, null).on(mouseup, null);
              dragRestore(dragged);
              zoomended(dispatch);
            }
          }
          function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
              var touches = d3.touches(that);
              scale0 = view.k;
              touches.forEach(function(t) {
                if (t.identifier in locations0) locations0[t.identifier] = location(t);
              });
              return touches;
            }
            function started() {
              var target = d3.event.target;
              d3.select(target).on(touchmove, moved).on(touchend, ended);
              targets.push(target);
              var changed = d3.event.changedTouches;
              for (var i = 0, n = changed.length; i < n; ++i) {
                locations0[changed[i].identifier] = null;
              }
              var touches = relocate(), now = Date.now();
              if (touches.length === 1) {
                if (now - touchtime < 500) {
                  var p = touches[0];
                  zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                  d3_eventPreventDefault();
                }
                touchtime = now;
              } else if (touches.length > 1) {
                var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                distance0 = dx * dx + dy * dy;
              }
            }
            function moved() {
              var touches = d3.touches(that), p0, l0, p1, l1;
              d3_selection_interrupt.call(that);
              for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                p1 = touches[i];
                if (l1 = locations0[p1.identifier]) {
                  if (l0) break;
                  p0 = p1, l0 = l1;
                }
              }
              if (l1) {
                var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
                l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
                scaleTo(scale1 * scale0);
              }
              touchtime = null;
              translateTo(p0, l0);
              zoomed(dispatch);
            }
            function ended() {
              if (d3.event.touches.length) {
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                  delete locations0[changed[i].identifier];
                }
                for (var identifier in locations0) {
                  return void relocate();
                }
              }
              d3.selectAll(targets).on(zoomName, null);
              subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
              dragRestore();
              zoomended(dispatch);
            }
          }
          function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer) clearTimeout(mousewheelTimer);
            else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function() {
              mousewheelTimer = null;
              zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * 2e-3) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
          }
          function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
          }
          return d3.rebind(zoom, event, "on");
        };
        var d3_behavior_zoomInfinity = [0, Infinity], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
        d3.color = d3_color;
        function d3_color() {
        }
        d3_color.prototype.toString = function() {
          return this.rgb() + "";
        };
        d3.hsl = d3_hsl;
        function d3_hsl(h, s, l) {
          return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
        }
        var d3_hslPrototype = d3_hsl.prototype = new d3_color();
        d3_hslPrototype.brighter = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_hsl(this.h, this.s, this.l / k);
        };
        d3_hslPrototype.darker = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_hsl(this.h, this.s, k * this.l);
        };
        d3_hslPrototype.rgb = function() {
          return d3_hsl_rgb(this.h, this.s, this.l);
        };
        function d3_hsl_rgb(h, s, l) {
          var m1, m2;
          h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
          s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
          l = l < 0 ? 0 : l > 1 ? 1 : l;
          m2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
          m1 = 2 * l - m2;
          function v(h2) {
            if (h2 > 360) h2 -= 360;
            else if (h2 < 0) h2 += 360;
            if (h2 < 60) return m1 + (m2 - m1) * h2 / 60;
            if (h2 < 180) return m2;
            if (h2 < 240) return m1 + (m2 - m1) * (240 - h2) / 60;
            return m1;
          }
          function vv(h2) {
            return Math.round(v(h2) * 255);
          }
          return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
        }
        d3.hcl = d3_hcl;
        function d3_hcl(h, c, l) {
          return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
        }
        var d3_hclPrototype = d3_hcl.prototype = new d3_color();
        d3_hclPrototype.brighter = function(k) {
          return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
        };
        d3_hclPrototype.darker = function(k) {
          return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
        };
        d3_hclPrototype.rgb = function() {
          return d3_hcl_lab(this.h, this.c, this.l).rgb();
        };
        function d3_hcl_lab(h, c, l) {
          if (isNaN(h)) h = 0;
          if (isNaN(c)) c = 0;
          return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
        }
        d3.lab = d3_lab;
        function d3_lab(l, a, b) {
          return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
        }
        var d3_lab_K = 18;
        var d3_lab_X = 0.95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
        var d3_labPrototype = d3_lab.prototype = new d3_color();
        d3_labPrototype.brighter = function(k) {
          return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
        };
        d3_labPrototype.darker = function(k) {
          return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
        };
        d3_labPrototype.rgb = function() {
          return d3_lab_rgb(this.l, this.a, this.b);
        };
        function d3_lab_rgb(l, a, b) {
          var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
          x = d3_lab_xyz(x) * d3_lab_X;
          y = d3_lab_xyz(y) * d3_lab_Y;
          z = d3_lab_xyz(z) * d3_lab_Z;
          return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), d3_xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), d3_xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z));
        }
        function d3_lab_hcl(l, a, b) {
          return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
        }
        function d3_lab_xyz(x) {
          return x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
        }
        function d3_xyz_lab(x) {
          return x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
        }
        function d3_xyz_rgb(r) {
          return Math.round(255 * (r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));
        }
        d3.rgb = d3_rgb;
        function d3_rgb(r, g, b) {
          return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
        }
        function d3_rgbNumber(value) {
          return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
        }
        function d3_rgbString(value) {
          return d3_rgbNumber(value) + "";
        }
        var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
        d3_rgbPrototype.brighter = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          var r = this.r, g = this.g, b = this.b, i = 30;
          if (!r && !g && !b) return new d3_rgb(i, i, i);
          if (r && r < i) r = i;
          if (g && g < i) g = i;
          if (b && b < i) b = i;
          return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
        };
        d3_rgbPrototype.darker = function(k) {
          k = Math.pow(0.7, arguments.length ? k : 1);
          return new d3_rgb(k * this.r, k * this.g, k * this.b);
        };
        d3_rgbPrototype.hsl = function() {
          return d3_rgb_hsl(this.r, this.g, this.b);
        };
        d3_rgbPrototype.toString = function() {
          return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
        };
        function d3_rgb_hex(v) {
          return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
        }
        function d3_rgb_parse(format, rgb, hsl) {
          var r = 0, g = 0, b = 0, m1, m2, color;
          m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
          if (m1) {
            m2 = m1[2].split(",");
            switch (m1[1]) {
              case "hsl": {
                return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
              }
              case "rgb": {
                return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
              }
            }
          }
          if (color = d3_rgb_names.get(format)) {
            return rgb(color.r, color.g, color.b);
          }
          if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
              r = (color & 3840) >> 4;
              r = r >> 4 | r;
              g = color & 240;
              g = g >> 4 | g;
              b = color & 15;
              b = b << 4 | b;
            } else if (format.length === 7) {
              r = (color & 16711680) >> 16;
              g = (color & 65280) >> 8;
              b = color & 255;
            }
          }
          return rgb(r, g, b);
        }
        function d3_rgb_hsl(r, g, b) {
          var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
          if (d) {
            s = l < 0.5 ? d / (max + min) : d / (2 - max - min);
            if (r == max) h = (g - b) / d + (g < b ? 6 : 0);
            else if (g == max) h = (b - r) / d + 2;
            else h = (r - g) / d + 4;
            h *= 60;
          } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
          }
          return new d3_hsl(h, s, l);
        }
        function d3_rgb_lab(r, g, b) {
          r = d3_rgb_xyz(r);
          g = d3_rgb_xyz(g);
          b = d3_rgb_xyz(b);
          var x = d3_xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / d3_lab_X), y = d3_xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / d3_lab_Y), z = d3_xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / d3_lab_Z);
          return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
        }
        function d3_rgb_xyz(r) {
          return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
        }
        function d3_rgb_parseNumber(c) {
          var f = parseFloat(c);
          return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
        }
        var d3_rgb_names = d3.map({
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074
        });
        d3_rgb_names.forEach(function(key, value) {
          d3_rgb_names.set(key, d3_rgbNumber(value));
        });
        function d3_functor(v) {
          return typeof v === "function" ? v : function() {
            return v;
          };
        }
        d3.functor = d3_functor;
        d3.xhr = d3_xhrType(d3_identity);
        function d3_xhrType(response) {
          return function(url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
          };
        }
        function d3_xhr(url, mimeType, response, callback) {
          var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
          if (self.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
          "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
            request.readyState > 3 && respond();
          };
          function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
              try {
                result = response.call(xhr, request);
              } catch (e) {
                dispatch.error.call(xhr, e);
                return;
              }
              dispatch.load.call(xhr, result);
            } else {
              dispatch.error.call(xhr, request);
            }
          }
          request.onprogress = function(event) {
            var o = d3.event;
            d3.event = event;
            try {
              dispatch.progress.call(xhr, request);
            } finally {
              d3.event = o;
            }
          };
          xhr.header = function(name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2) return headers[name];
            if (value == null) delete headers[name];
            else headers[name] = value + "";
            return xhr;
          };
          xhr.mimeType = function(value) {
            if (!arguments.length) return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
          };
          xhr.responseType = function(value) {
            if (!arguments.length) return responseType;
            responseType = value;
            return xhr;
          };
          xhr.response = function(value) {
            response = value;
            return xhr;
          };
          ["get", "post"].forEach(function(method) {
            xhr[method] = function() {
              return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
            };
          });
          xhr.send = function(method, data, callback2) {
            if (arguments.length === 2 && typeof data === "function") callback2 = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
            if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
            if (responseType != null) request.responseType = responseType;
            if (callback2 != null) xhr.on("error", callback2).on("load", function(request2) {
              callback2(null, request2);
            });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
          };
          xhr.abort = function() {
            request.abort();
            return xhr;
          };
          d3.rebind(xhr, dispatch, "on");
          return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
        }
        function d3_xhr_fixCallback(callback) {
          return callback.length === 1 ? function(error, request) {
            callback(error == null ? request : null);
          } : callback;
        }
        function d3_xhrHasResponse(request) {
          var type = request.responseType;
          return type && type !== "text" ? request.response : request.responseText;
        }
        d3.dsv = function(delimiter, mimeType) {
          var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
          function dsv(url, row, callback) {
            if (arguments.length < 3) callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function(_) {
              return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
          }
          function response(request) {
            return dsv.parse(request.responseText);
          }
          function typedResponse(f) {
            return function(request) {
              return dsv.parse(request.responseText, f);
            };
          }
          dsv.parse = function(text, f) {
            var o;
            return dsv.parseRows(text, function(row, i) {
              if (o) return o(row, i - 1);
              var a = function(d) {
                var obj = {};
                var len = row.length;
                for (var k = 0; k < len; ++k) {
                  obj[row[k]] = d[k];
                }
                return obj;
              };
              o = f ? function(row2, i2) {
                return f(a(row2), i2);
              } : a;
            });
          };
          dsv.parseRows = function(text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
              if (I >= N) return EOF;
              if (eol) return eol = false, EOL;
              var j = I;
              if (text.charCodeAt(j) === 34) {
                var i = j;
                while (i++ < N) {
                  if (text.charCodeAt(i) === 34) {
                    if (text.charCodeAt(i + 1) !== 34) break;
                    ++i;
                  }
                }
                I = i + 2;
                var c = text.charCodeAt(i + 1);
                if (c === 13) {
                  eol = true;
                  if (text.charCodeAt(i + 2) === 10) ++I;
                } else if (c === 10) {
                  eol = true;
                }
                return text.slice(j + 1, i).replace(/""/g, '"');
              }
              while (I < N) {
                var c = text.charCodeAt(I++), k = 1;
                if (c === 10) eol = true;
                else if (c === 13) {
                  eol = true;
                  if (text.charCodeAt(I) === 10) ++I, ++k;
                } else if (c !== delimiterCode) continue;
                return text.slice(j, I - k);
              }
              return text.slice(j);
            }
            while ((t = token()) !== EOF) {
              var a = [];
              while (t !== EOL && t !== EOF) {
                a.push(t);
                t = token();
              }
              if (f && (a = f(a, n++)) == null) continue;
              rows.push(a);
            }
            return rows;
          };
          dsv.format = function(rows) {
            if (Array.isArray(rows[0])) return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function(row) {
              for (var field in row) {
                if (!fieldSet.has(field)) {
                  fields.push(fieldSet.add(field));
                }
              }
            });
            return [fields.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
              return fields.map(function(field) {
                return formatValue(row[field]);
              }).join(delimiter);
            })).join("\n");
          };
          dsv.formatRows = function(rows) {
            return rows.map(formatRow).join("\n");
          };
          function formatRow(row) {
            return row.map(formatValue).join(delimiter);
          }
          function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
          }
          return dsv;
        };
        d3.csv = d3.dsv(",", "text/csv");
        d3.tsv = d3.dsv("	", "text/tab-separated-values");
        var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
          setTimeout(callback, 17);
        };
        d3.timer = function() {
          d3_timer.apply(this, arguments);
        };
        function d3_timer(callback, delay, then) {
          var n = arguments.length;
          if (n < 2) delay = 0;
          if (n < 3) then = Date.now();
          var time = then + delay, timer = {
            c: callback,
            t: time,
            n: null
          };
          if (d3_timer_queueTail) d3_timer_queueTail.n = timer;
          else d3_timer_queueHead = timer;
          d3_timer_queueTail = timer;
          if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
          }
          return timer;
        }
        function d3_timer_step() {
          var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
          if (delay > 24) {
            if (isFinite(delay)) {
              clearTimeout(d3_timer_timeout);
              d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
          } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
          }
        }
        d3.timer.flush = function() {
          d3_timer_mark();
          d3_timer_sweep();
        };
        function d3_timer_mark() {
          var now = Date.now(), timer = d3_timer_queueHead;
          while (timer) {
            if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
            timer = timer.n;
          }
          return now;
        }
        function d3_timer_sweep() {
          var t0, t1 = d3_timer_queueHead, time = Infinity;
          while (t1) {
            if (t1.c) {
              if (t1.t < time) time = t1.t;
              t1 = (t0 = t1).n;
            } else {
              t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            }
          }
          d3_timer_queueTail = t0;
          return time;
        }
        d3.round = function(x, n) {
          return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
        };
        d3.geom = {};
        function d3_geom_pointX(d) {
          return d[0];
        }
        function d3_geom_pointY(d) {
          return d[1];
        }
        d3.geom.hull = function(vertices) {
          var x = d3_geom_pointX, y = d3_geom_pointY;
          if (arguments.length) return hull(vertices);
          function hull(data) {
            if (data.length < 3) return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
              points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++) flippedPoints.push([points[i][0], -points[i][1]]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
            return polygon;
          }
          hull.x = function(_) {
            return arguments.length ? (x = _, hull) : x;
          };
          hull.y = function(_) {
            return arguments.length ? (y = _, hull) : y;
          };
          return hull;
        };
        function d3_geom_hullUpper(points) {
          var n = points.length, hull = [0, 1], hs = 2;
          for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
            hull[hs++] = i;
          }
          return hull.slice(0, hs);
        }
        function d3_geom_hullOrder(a, b) {
          return a[0] - b[0] || a[1] - b[1];
        }
        d3.geom.polygon = function(coordinates) {
          d3_subclass(coordinates, d3_geom_polygonPrototype);
          return coordinates;
        };
        var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
        d3_geom_polygonPrototype.area = function() {
          var i = -1, n = this.length, a, b = this[n - 1], area = 0;
          while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
          }
          return area * 0.5;
        };
        d3_geom_polygonPrototype.centroid = function(k) {
          var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
          if (!arguments.length) k = -1 / (6 * this.area());
          while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
          }
          return [x * k, y * k];
        };
        d3_geom_polygonPrototype.clip = function(subject) {
          var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
          while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
              d = input[j];
              if (d3_geom_polygonInside(d, a, b)) {
                if (!d3_geom_polygonInside(c, a, b)) {
                  subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                subject.push(d);
              } else if (d3_geom_polygonInside(c, a, b)) {
                subject.push(d3_geom_polygonIntersect(c, d, a, b));
              }
              c = d;
            }
            if (closed) subject.push(subject[0]);
            a = b;
          }
          return subject;
        };
        function d3_geom_polygonInside(p, a, b) {
          return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
        }
        function d3_geom_polygonIntersect(c, d, a, b) {
          var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
          return [x1 + ua * x21, y1 + ua * y21];
        }
        function d3_geom_polygonClosed(coordinates) {
          var a = coordinates[0], b = coordinates[coordinates.length - 1];
          return !(a[0] - b[0] || a[1] - b[1]);
        }
        var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
        function d3_geom_voronoiBeach() {
          d3_geom_voronoiRedBlackNode(this);
          this.edge = this.site = this.circle = null;
        }
        function d3_geom_voronoiCreateBeach(site) {
          var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
          beach.site = site;
          return beach;
        }
        function d3_geom_voronoiDetachBeach(beach) {
          d3_geom_voronoiDetachCircle(beach);
          d3_geom_voronoiBeaches.remove(beach);
          d3_geom_voronoiBeachPool.push(beach);
          d3_geom_voronoiRedBlackNode(beach);
        }
        function d3_geom_voronoiRemoveBeach(beach) {
          var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
            x,
            y
          }, previous = beach.P, next = beach.N, disappearing = [beach];
          d3_geom_voronoiDetachBeach(beach);
          var lArc = previous;
          while (lArc.circle && abs(x - lArc.circle.x) < \u03B5 && abs(y - lArc.circle.cy) < \u03B5) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
          }
          disappearing.unshift(lArc);
          d3_geom_voronoiDetachCircle(lArc);
          var rArc = next;
          while (rArc.circle && abs(x - rArc.circle.x) < \u03B5 && abs(y - rArc.circle.cy) < \u03B5) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
          }
          disappearing.push(rArc);
          d3_geom_voronoiDetachCircle(rArc);
          var nArcs = disappearing.length, iArc;
          for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
          }
          lArc = disappearing[0];
          rArc = disappearing[nArcs - 1];
          rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
        }
        function d3_geom_voronoiAddBeach(site) {
          var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
          while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > \u03B5) node = node.L;
            else {
              dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
              if (dxr > \u03B5) {
                if (!node.R) {
                  lArc = node;
                  break;
                }
                node = node.R;
              } else {
                if (dxl > -\u03B5) {
                  lArc = node.P;
                  rArc = node;
                } else if (dxr > -\u03B5) {
                  lArc = node;
                  rArc = node.N;
                } else {
                  lArc = rArc = node;
                }
                break;
              }
            }
          }
          var newArc = d3_geom_voronoiCreateBeach(site);
          d3_geom_voronoiBeaches.insert(lArc, newArc);
          if (!lArc && !rArc) return;
          if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
          }
          if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
          }
          d3_geom_voronoiDetachCircle(lArc);
          d3_geom_voronoiDetachCircle(rArc);
          var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
            x: (cy * hb - by * hc) / d + ax,
            y: (bx * hc - cx * hb) / d + ay
          };
          d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
          newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
          rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
          d3_geom_voronoiAttachCircle(lArc);
          d3_geom_voronoiAttachCircle(rArc);
        }
        function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
          var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
          if (!pby2) return rfocx;
          var lArc = arc.P;
          if (!lArc) return -Infinity;
          site = lArc.site;
          var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
          if (!plby2) return lfocx;
          var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
          if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
          return (rfocx + lfocx) / 2;
        }
        function d3_geom_voronoiRightBreakPoint(arc, directrix) {
          var rArc = arc.N;
          if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
          var site = arc.site;
          return site.y === directrix ? site.x : Infinity;
        }
        function d3_geom_voronoiCell(site) {
          this.site = site;
          this.edges = [];
        }
        d3_geom_voronoiCell.prototype.prepare = function() {
          var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
          while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
          }
          halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
          return halfEdges.length;
        };
        function d3_geom_voronoiCloseCells(extent) {
          var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
          while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare()) continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
              end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
              start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
              if (abs(x3 - x2) > \u03B5 || abs(y3 - y2) > \u03B5) {
                halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < \u03B5 && y1 - y3 > \u03B5 ? {
                  x: x0,
                  y: abs(x2 - x0) < \u03B5 ? y2 : y1
                } : abs(y3 - y1) < \u03B5 && x1 - x3 > \u03B5 ? {
                  x: abs(y2 - y1) < \u03B5 ? x2 : x1,
                  y: y1
                } : abs(x3 - x1) < \u03B5 && y3 - y0 > \u03B5 ? {
                  x: x1,
                  y: abs(x2 - x1) < \u03B5 ? y2 : y0
                } : abs(y3 - y0) < \u03B5 && x3 - x0 > \u03B5 ? {
                  x: abs(y2 - y0) < \u03B5 ? x2 : x0,
                  y: y0
                } : null), cell.site, null));
                ++nHalfEdges;
              }
            }
          }
        }
        function d3_geom_voronoiHalfEdgeOrder(a, b) {
          return b.angle - a.angle;
        }
        function d3_geom_voronoiCircle() {
          d3_geom_voronoiRedBlackNode(this);
          this.x = this.y = this.arc = this.site = this.cy = null;
        }
        function d3_geom_voronoiAttachCircle(arc) {
          var lArc = arc.P, rArc = arc.N;
          if (!lArc || !rArc) return;
          var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
          if (lSite === rSite) return;
          var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
          var d = 2 * (ax * cy - ay * cx);
          if (d >= -\u03B52) return;
          var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
          var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
          circle.arc = arc;
          circle.site = cSite;
          circle.x = x + bx;
          circle.y = cy + Math.sqrt(x * x + y * y);
          circle.cy = cy;
          arc.circle = circle;
          var before = null, node = d3_geom_voronoiCircles._;
          while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
              if (node.L) node = node.L;
              else {
                before = node.P;
                break;
              }
            } else {
              if (node.R) node = node.R;
              else {
                before = node;
                break;
              }
            }
          }
          d3_geom_voronoiCircles.insert(before, circle);
          if (!before) d3_geom_voronoiFirstCircle = circle;
        }
        function d3_geom_voronoiDetachCircle(arc) {
          var circle = arc.circle;
          if (circle) {
            if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
          }
        }
        function d3_geom_clipLine(x0, y0, x1, y1) {
          return function(line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0) return;
            r /= dx;
            if (dx < 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            } else if (dx > 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0) return;
            r /= dx;
            if (dx < 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            } else if (dx > 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0) return;
            r /= dy;
            if (dy < 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            } else if (dy > 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0) return;
            r /= dy;
            if (dy < 0) {
              if (r > t1) return;
              if (r > t0) t0 = r;
            } else if (dy > 0) {
              if (r < t0) return;
              if (r < t1) t1 = r;
            }
            if (t0 > 0) line.a = {
              x: ax + t0 * dx,
              y: ay + t0 * dy
            };
            if (t1 < 1) line.b = {
              x: ax + t1 * dx,
              y: ay + t1 * dy
            };
            return line;
          };
        }
        function d3_geom_voronoiClipEdges(extent) {
          var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
          while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < \u03B5 && abs(e.a.y - e.b.y) < \u03B5) {
              e.a = e.b = null;
              edges.splice(i, 1);
            }
          }
        }
        function d3_geom_voronoiConnectEdge(edge, extent) {
          var vb = edge.b;
          if (vb) return true;
          var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
          if (ry === ly) {
            if (fx < x0 || fx >= x1) return;
            if (lx > rx) {
              if (!va) va = {
                x: fx,
                y: y0
              };
              else if (va.y >= y1) return;
              vb = {
                x: fx,
                y: y1
              };
            } else {
              if (!va) va = {
                x: fx,
                y: y1
              };
              else if (va.y < y0) return;
              vb = {
                x: fx,
                y: y0
              };
            }
          } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
              if (lx > rx) {
                if (!va) va = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
                else if (va.y >= y1) return;
                vb = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
              } else {
                if (!va) va = {
                  x: (y1 - fb) / fm,
                  y: y1
                };
                else if (va.y < y0) return;
                vb = {
                  x: (y0 - fb) / fm,
                  y: y0
                };
              }
            } else {
              if (ly < ry) {
                if (!va) va = {
                  x: x0,
                  y: fm * x0 + fb
                };
                else if (va.x >= x1) return;
                vb = {
                  x: x1,
                  y: fm * x1 + fb
                };
              } else {
                if (!va) va = {
                  x: x1,
                  y: fm * x1 + fb
                };
                else if (va.x < x0) return;
                vb = {
                  x: x0,
                  y: fm * x0 + fb
                };
              }
            }
          }
          edge.a = va;
          edge.b = vb;
          return true;
        }
        function d3_geom_voronoiEdge(lSite, rSite) {
          this.l = lSite;
          this.r = rSite;
          this.a = this.b = null;
        }
        function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
          var edge = new d3_geom_voronoiEdge(lSite, rSite);
          d3_geom_voronoiEdges.push(edge);
          if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
          if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
          d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
          d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
          return edge;
        }
        function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
          var edge = new d3_geom_voronoiEdge(lSite, null);
          edge.a = va;
          edge.b = vb;
          d3_geom_voronoiEdges.push(edge);
          return edge;
        }
        function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
          if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
          } else if (edge.l === rSite) {
            edge.b = vertex;
          } else {
            edge.a = vertex;
          }
        }
        function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
          var va = edge.a, vb = edge.b;
          this.edge = edge;
          this.site = lSite;
          this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
        }
        d3_geom_voronoiHalfEdge.prototype = {
          start: function() {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
          },
          end: function() {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
          }
        };
        function d3_geom_voronoiRedBlackTree() {
          this._ = null;
        }
        function d3_geom_voronoiRedBlackNode(node) {
          node.U = node.C = node.L = node.R = node.P = node.N = null;
        }
        d3_geom_voronoiRedBlackTree.prototype = {
          insert: function(after, node) {
            var parent, grandpa, uncle;
            if (after) {
              node.P = after;
              node.N = after.N;
              if (after.N) after.N.P = node;
              after.N = node;
              if (after.R) {
                after = after.R;
                while (after.L) after = after.L;
                after.L = node;
              } else {
                after.R = node;
              }
              parent = after;
            } else if (this._) {
              after = d3_geom_voronoiRedBlackFirst(this._);
              node.P = null;
              node.N = after;
              after.P = after.L = node;
              parent = after;
            } else {
              node.P = node.N = null;
              this._ = node;
              parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
              grandpa = parent.U;
              if (parent === grandpa.L) {
                uncle = grandpa.R;
                if (uncle && uncle.C) {
                  parent.C = uncle.C = false;
                  grandpa.C = true;
                  after = grandpa;
                } else {
                  if (after === parent.R) {
                    d3_geom_voronoiRedBlackRotateLeft(this, parent);
                    after = parent;
                    parent = after.U;
                  }
                  parent.C = false;
                  grandpa.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                }
              } else {
                uncle = grandpa.L;
                if (uncle && uncle.C) {
                  parent.C = uncle.C = false;
                  grandpa.C = true;
                  after = grandpa;
                } else {
                  if (after === parent.L) {
                    d3_geom_voronoiRedBlackRotateRight(this, parent);
                    after = parent;
                    parent = after.U;
                  }
                  parent.C = false;
                  grandpa.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                }
              }
              parent = after.U;
            }
            this._.C = false;
          },
          remove: function(node) {
            if (node.N) node.N.P = node.P;
            if (node.P) node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left) next = right;
            else if (!right) next = left;
            else next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
              if (parent.L === node) parent.L = next;
              else parent.R = next;
            } else {
              this._ = next;
            }
            if (left && right) {
              red = next.C;
              next.C = node.C;
              next.L = left;
              left.U = next;
              if (next !== right) {
                parent = next.U;
                next.U = node.U;
                node = next.R;
                parent.L = node;
                next.R = right;
                right.U = next;
              } else {
                next.U = parent;
                parent = next;
                node = next.R;
              }
            } else {
              red = node.C;
              node = next;
            }
            if (node) node.U = parent;
            if (red) return;
            if (node && node.C) {
              node.C = false;
              return;
            }
            do {
              if (node === this._) break;
              if (node === parent.L) {
                sibling = parent.R;
                if (sibling.C) {
                  sibling.C = false;
                  parent.C = true;
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  sibling = parent.R;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                  if (!sibling.R || !sibling.R.C) {
                    sibling.L.C = false;
                    sibling.C = true;
                    d3_geom_voronoiRedBlackRotateRight(this, sibling);
                    sibling = parent.R;
                  }
                  sibling.C = parent.C;
                  parent.C = sibling.R.C = false;
                  d3_geom_voronoiRedBlackRotateLeft(this, parent);
                  node = this._;
                  break;
                }
              } else {
                sibling = parent.L;
                if (sibling.C) {
                  sibling.C = false;
                  parent.C = true;
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  sibling = parent.L;
                }
                if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                  if (!sibling.L || !sibling.L.C) {
                    sibling.R.C = false;
                    sibling.C = true;
                    d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                    sibling = parent.L;
                  }
                  sibling.C = parent.C;
                  parent.C = sibling.L.C = false;
                  d3_geom_voronoiRedBlackRotateRight(this, parent);
                  node = this._;
                  break;
                }
              }
              sibling.C = true;
              node = parent;
              parent = parent.U;
            } while (!node.C);
            if (node) node.C = false;
          }
        };
        function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
          var p = node, q = node.R, parent = p.U;
          if (parent) {
            if (parent.L === p) parent.L = q;
            else parent.R = q;
          } else {
            tree._ = q;
          }
          q.U = parent;
          p.U = q;
          p.R = q.L;
          if (p.R) p.R.U = p;
          q.L = p;
        }
        function d3_geom_voronoiRedBlackRotateRight(tree, node) {
          var p = node, q = node.L, parent = p.U;
          if (parent) {
            if (parent.L === p) parent.L = q;
            else parent.R = q;
          } else {
            tree._ = q;
          }
          q.U = parent;
          p.U = q;
          p.L = q.R;
          if (p.L) p.L.U = p;
          q.R = p;
        }
        function d3_geom_voronoiRedBlackFirst(node) {
          while (node.L) node = node.L;
          return node;
        }
        function d3_geom_voronoi(sites, bbox) {
          var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
          d3_geom_voronoiEdges = [];
          d3_geom_voronoiCells = new Array(sites.length);
          d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
          d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
          while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
              if (site.x !== x0 || site.y !== y0) {
                d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                d3_geom_voronoiAddBeach(site);
                x0 = site.x, y0 = site.y;
              }
              site = sites.pop();
            } else if (circle) {
              d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
              break;
            }
          }
          if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
          var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
          };
          d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
          return diagram;
        }
        function d3_geom_voronoiVertexOrder(a, b) {
          return b.y - a.y || b.x - a.x;
        }
        d3.geom.voronoi = function(points) {
          var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
          if (points) return voronoi(points);
          function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
              var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
                var s = e.start();
                return [s.x, s.y];
              }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
              polygon.point = data[i];
            });
            return polygons;
          }
          function sites(data) {
            return data.map(function(d, i) {
              return {
                x: Math.round(fx(d, i) / \u03B5) * \u03B5,
                y: Math.round(fy(d, i) / \u03B5) * \u03B5,
                i
              };
            });
          }
          voronoi.links = function(data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
              return edge.l && edge.r;
            }).map(function(edge) {
              return {
                source: data[edge.l.i],
                target: data[edge.r.i]
              };
            });
          };
          voronoi.triangles = function(data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
              var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
              while (++j < m) {
                e0 = e1;
                s0 = s1;
                e1 = edges[j].edge;
                s1 = e1.l === site ? e1.r : e1.l;
                if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                  triangles.push([data[i], data[s0.i], data[s1.i]]);
                }
              }
            });
            return triangles;
          };
          voronoi.x = function(_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
          };
          voronoi.y = function(_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
          };
          voronoi.clipExtent = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
          };
          voronoi.size = function(_) {
            if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [[0, 0], _]);
          };
          return voronoi;
        };
        var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
        function d3_geom_voronoiTriangleArea(a, b, c) {
          return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
        }
        d3.geom.delaunay = function(vertices) {
          return d3.geom.voronoi().triangles(vertices);
        };
        d3.geom.quadtree = function(points, x1, y1, x2, y2) {
          var x = d3_geom_pointX, y = d3_geom_pointY, compat;
          if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
              y2 = y1;
              x2 = x1;
              y1 = x1 = 0;
            }
            return quadtree(points);
          }
          function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
              x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
              x2_ = y2_ = -(x1_ = y1_ = Infinity);
              xs = [], ys = [];
              n = data.length;
              if (compat) for (i = 0; i < n; ++i) {
                d = data[i];
                if (d.x < x1_) x1_ = d.x;
                if (d.y < y1_) y1_ = d.y;
                if (d.x > x2_) x2_ = d.x;
                if (d.y > y2_) y2_ = d.y;
                xs.push(d.x);
                ys.push(d.y);
              }
              else for (i = 0; i < n; ++i) {
                var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                if (x_ < x1_) x1_ = x_;
                if (y_ < y1_) y1_ = y_;
                if (x_ > x2_) x2_ = x_;
                if (y_ > y2_) y2_ = y_;
                xs.push(x_);
                ys.push(y_);
              }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy) y2_ = y1_ + dx;
            else x2_ = x1_ + dy;
            function insert(n2, d2, x3, y3, x12, y12, x22, y22) {
              if (isNaN(x3) || isNaN(y3)) return;
              if (n2.leaf) {
                var nx = n2.x, ny = n2.y;
                if (nx != null) {
                  if (abs(nx - x3) + abs(ny - y3) < 0.01) {
                    insertChild(n2, d2, x3, y3, x12, y12, x22, y22);
                  } else {
                    var nPoint = n2.point;
                    n2.x = n2.y = n2.point = null;
                    insertChild(n2, nPoint, nx, ny, x12, y12, x22, y22);
                    insertChild(n2, d2, x3, y3, x12, y12, x22, y22);
                  }
                } else {
                  n2.x = x3, n2.y = y3, n2.point = d2;
                }
              } else {
                insertChild(n2, d2, x3, y3, x12, y12, x22, y22);
              }
            }
            function insertChild(n2, d2, x3, y3, x12, y12, x22, y22) {
              var xm = (x12 + x22) * 0.5, ym = (y12 + y22) * 0.5, right = x3 >= xm, below = y3 >= ym, i2 = below << 1 | right;
              n2.leaf = false;
              n2 = n2.nodes[i2] || (n2.nodes[i2] = d3_geom_quadtreeNode());
              if (right) x12 = xm;
              else x22 = xm;
              if (below) y12 = ym;
              else y22 = ym;
              insert(n2, d2, x3, y3, x12, y12, x22, y22);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function(d2) {
              insert(root, d2, +fx(d2, ++i), +fy(d2, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function(f) {
              d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function(point) {
              return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
              while (++i < n) {
                insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
              }
              --i;
            } else data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
          }
          quadtree.x = function(_) {
            return arguments.length ? (x = _, quadtree) : x;
          };
          quadtree.y = function(_) {
            return arguments.length ? (y = _, quadtree) : y;
          };
          quadtree.extent = function(_) {
            if (!arguments.length) return x1 == null ? null : [[x1, y1], [x2, y2]];
            if (_ == null) x1 = y1 = x2 = y2 = null;
            else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
            return quadtree;
          };
          quadtree.size = function(_) {
            if (!arguments.length) return x1 == null ? null : [x2 - x1, y2 - y1];
            if (_ == null) x1 = y1 = x2 = y2 = null;
            else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            return quadtree;
          };
          return quadtree;
        };
        function d3_geom_quadtreeCompatX(d) {
          return d.x;
        }
        function d3_geom_quadtreeCompatY(d) {
          return d.y;
        }
        function d3_geom_quadtreeNode() {
          return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
          };
        }
        function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
          if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * 0.5, sy = (y1 + y2) * 0.5, children = node.nodes;
            if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
          }
        }
        function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
          var minDistance2 = Infinity, closestPoint;
          (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
            if (point = node.point) {
              var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
              if (distance2 < minDistance2) {
                var distance = Math.sqrt(minDistance2 = distance2);
                x0 = x - distance, y0 = y - distance;
                x3 = x + distance, y3 = y + distance;
                closestPoint = point;
              }
            }
            var children = node.nodes, xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
              if (node = children[i & 3]) switch (i & 3) {
                case 0:
                  find(node, x1, y1, xm, ym);
                  break;
                case 1:
                  find(node, xm, y1, x2, ym);
                  break;
                case 2:
                  find(node, x1, ym, xm, y2);
                  break;
                case 3:
                  find(node, xm, ym, x2, y2);
                  break;
              }
            }
          })(root, x0, y0, x3, y3);
          return closestPoint;
        }
        d3.interpolateRgb = d3_interpolateRgb;
        function d3_interpolateRgb(a, b) {
          a = d3.rgb(a);
          b = d3.rgb(b);
          var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
          return function(t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
          };
        }
        d3.interpolateObject = d3_interpolateObject;
        function d3_interpolateObject(a, b) {
          var i = {}, c = {}, k;
          for (k in a) {
            if (k in b) {
              i[k] = d3_interpolate(a[k], b[k]);
            } else {
              c[k] = a[k];
            }
          }
          for (k in b) {
            if (!(k in a)) {
              c[k] = b[k];
            }
          }
          return function(t) {
            for (k in i) c[k] = i[k](t);
            return c;
          };
        }
        d3.interpolateNumber = d3_interpolateNumber;
        function d3_interpolateNumber(a, b) {
          a = +a, b = +b;
          return function(t) {
            return a * (1 - t) + b * t;
          };
        }
        d3.interpolateString = d3_interpolateString;
        function d3_interpolateString(a, b) {
          var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
          a = a + "", b = b + "";
          while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
              bs = b.slice(bi, bs);
              if (s[i]) s[i] += bs;
              else s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
              if (s[i]) s[i] += bm;
              else s[++i] = bm;
            } else {
              s[++i] = null;
              q.push({
                i,
                x: d3_interpolateNumber(am, bm)
              });
            }
            bi = d3_interpolate_numberB.lastIndex;
          }
          if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i]) s[i] += bs;
            else s[++i] = bs;
          }
          return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
            return b(t) + "";
          }) : function() {
            return b;
          } : (b = q.length, function(t) {
            for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
            return s.join("");
          });
        }
        var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
        d3.interpolate = d3_interpolate;
        function d3_interpolate(a, b) {
          var i = d3.interpolators.length, f;
          while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
          return f;
        }
        d3.interpolators = [function(a, b) {
          var t = typeof b;
          return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
        }];
        d3.interpolateArray = d3_interpolateArray;
        function d3_interpolateArray(a, b) {
          var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
          for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
          for (; i < na; ++i) c[i] = a[i];
          for (; i < nb; ++i) c[i] = b[i];
          return function(t) {
            for (i = 0; i < n0; ++i) c[i] = x[i](t);
            return c;
          };
        }
        var d3_ease_default = function() {
          return d3_identity;
        };
        var d3_ease = d3.map({
          linear: d3_ease_default,
          poly: d3_ease_poly,
          quad: function() {
            return d3_ease_quad;
          },
          cubic: function() {
            return d3_ease_cubic;
          },
          sin: function() {
            return d3_ease_sin;
          },
          exp: function() {
            return d3_ease_exp;
          },
          circle: function() {
            return d3_ease_circle;
          },
          elastic: d3_ease_elastic,
          back: d3_ease_back,
          bounce: function() {
            return d3_ease_bounce;
          }
        });
        var d3_ease_mode = d3.map({
          "in": d3_identity,
          out: d3_ease_reverse,
          "in-out": d3_ease_reflect,
          "out-in": function(f) {
            return d3_ease_reflect(d3_ease_reverse(f));
          }
        });
        d3.ease = function(name) {
          var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
          t = d3_ease.get(t) || d3_ease_default;
          m = d3_ease_mode.get(m) || d3_identity;
          return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
        };
        function d3_ease_clamp(f) {
          return function(t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
          };
        }
        function d3_ease_reverse(f) {
          return function(t) {
            return 1 - f(1 - t);
          };
        }
        function d3_ease_reflect(f) {
          return function(t) {
            return 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
          };
        }
        function d3_ease_quad(t) {
          return t * t;
        }
        function d3_ease_cubic(t) {
          return t * t * t;
        }
        function d3_ease_cubicInOut(t) {
          if (t <= 0) return 0;
          if (t >= 1) return 1;
          var t2 = t * t, t3 = t2 * t;
          return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
        }
        function d3_ease_poly(e) {
          return function(t) {
            return Math.pow(t, e);
          };
        }
        function d3_ease_sin(t) {
          return 1 - Math.cos(t * half\u03C0);
        }
        function d3_ease_exp(t) {
          return Math.pow(2, 10 * (t - 1));
        }
        function d3_ease_circle(t) {
          return 1 - Math.sqrt(1 - t * t);
        }
        function d3_ease_elastic(a, p) {
          var s;
          if (arguments.length < 2) p = 0.45;
          if (arguments.length) s = p / \u03C4 * Math.asin(1 / a);
          else a = 1, s = p / 4;
          return function(t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * \u03C4 / p);
          };
        }
        function d3_ease_back(s) {
          if (!s) s = 1.70158;
          return function(t) {
            return t * t * ((s + 1) * t - s);
          };
        }
        function d3_ease_bounce(t) {
          return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        }
        d3.interpolateHcl = d3_interpolateHcl;
        function d3_interpolateHcl(a, b) {
          a = d3.hcl(a);
          b = d3.hcl(b);
          var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
          if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
          if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;
          else if (bh > 180) bh -= 360;
          else if (bh < -180) bh += 360;
          return function(t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
          };
        }
        d3.interpolateHsl = d3_interpolateHsl;
        function d3_interpolateHsl(a, b) {
          a = d3.hsl(a);
          b = d3.hsl(b);
          var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
          if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
          if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah;
          else if (bh > 180) bh -= 360;
          else if (bh < -180) bh += 360;
          return function(t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
          };
        }
        d3.interpolateLab = d3_interpolateLab;
        function d3_interpolateLab(a, b) {
          a = d3.lab(a);
          b = d3.lab(b);
          var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
          return function(t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
          };
        }
        d3.interpolateRound = d3_interpolateRound;
        function d3_interpolateRound(a, b) {
          b -= a;
          return function(t) {
            return Math.round(a + b * t);
          };
        }
        d3.transform = function(string) {
          var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
          return (d3.transform = function(string2) {
            if (string2 != null) {
              g.setAttribute("transform", string2);
              var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
          })(string);
        };
        function d3_transform(m) {
          var r0 = [m.a, m.b], r1 = [m.c, m.d], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
          if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
          }
          this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
          this.translate = [m.e, m.f];
          this.scale = [kx, ky];
          this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
        }
        d3_transform.prototype.toString = function() {
          return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
        };
        function d3_transformDot(a, b) {
          return a[0] * b[0] + a[1] * b[1];
        }
        function d3_transformNormalize(a) {
          var k = Math.sqrt(d3_transformDot(a, a));
          if (k) {
            a[0] /= k;
            a[1] /= k;
          }
          return k;
        }
        function d3_transformCombine(a, b, k) {
          a[0] += k * b[0];
          a[1] += k * b[1];
          return a;
        }
        var d3_transformIdentity = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: 0,
          f: 0
        };
        d3.interpolateTransform = d3_interpolateTransform;
        function d3_interpolateTransformPop(s) {
          return s.length ? s.pop() + "," : "";
        }
        function d3_interpolateTranslate(ta, tb, s, q) {
          if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
            var i = s.push("translate(", null, ",", null, ")");
            q.push({
              i: i - 4,
              x: d3_interpolateNumber(ta[0], tb[0])
            }, {
              i: i - 2,
              x: d3_interpolateNumber(ta[1], tb[1])
            });
          } else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
          }
        }
        function d3_interpolateRotate(ra, rb, s, q) {
          if (ra !== rb) {
            if (ra - rb > 180) rb += 360;
            else if (rb - ra > 180) ra += 360;
            q.push({
              i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
              x: d3_interpolateNumber(ra, rb)
            });
          } else if (rb) {
            s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
          }
        }
        function d3_interpolateSkew(wa, wb, s, q) {
          if (wa !== wb) {
            q.push({
              i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
              x: d3_interpolateNumber(wa, wb)
            });
          } else if (wb) {
            s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
          }
        }
        function d3_interpolateScale(ka, kb, s, q) {
          if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
            var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
            q.push({
              i: i - 4,
              x: d3_interpolateNumber(ka[0], kb[0])
            }, {
              i: i - 2,
              x: d3_interpolateNumber(ka[1], kb[1])
            });
          } else if (kb[0] !== 1 || kb[1] !== 1) {
            s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
          }
        }
        function d3_interpolateTransform(a, b) {
          var s = [], q = [];
          a = d3.transform(a), b = d3.transform(b);
          d3_interpolateTranslate(a.translate, b.translate, s, q);
          d3_interpolateRotate(a.rotate, b.rotate, s, q);
          d3_interpolateSkew(a.skew, b.skew, s, q);
          d3_interpolateScale(a.scale, b.scale, s, q);
          a = b = null;
          return function(t) {
            var i = -1, n = q.length, o;
            while (++i < n) s[(o = q[i]).i] = o.x(t);
            return s.join("");
          };
        }
        function d3_uninterpolateNumber(a, b) {
          b = (b -= a = +a) || 1 / b;
          return function(x) {
            return (x - a) / b;
          };
        }
        function d3_uninterpolateClamp(a, b) {
          b = (b -= a = +a) || 1 / b;
          return function(x) {
            return Math.max(0, Math.min(1, (x - a) / b));
          };
        }
        d3.layout = {};
        d3.layout.bundle = function() {
          return function(links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
            return paths;
          };
        };
        function d3_layout_bundlePath(link) {
          var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [start];
          while (start !== lca) {
            start = start.parent;
            points.push(start);
          }
          var k = points.length;
          while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
          }
          return points;
        }
        function d3_layout_bundleAncestors(node) {
          var ancestors = [], parent = node.parent;
          while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
          }
          ancestors.push(node);
          return ancestors;
        }
        function d3_layout_bundleLeastCommonAncestor(a, b) {
          if (a === b) return a;
          var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
          while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
          }
          return sharedNode;
        }
        d3.layout.chord = function() {
          var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
          function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
              x = 0, j = -1;
              while (++j < n) {
                x += matrix[i][j];
              }
              groupSums.push(x);
              subgroupIndex.push(d3.range(n));
              k += x;
            }
            if (sortGroups) {
              groupIndex.sort(function(a, b) {
                return sortGroups(groupSums[a], groupSums[b]);
              });
            }
            if (sortSubgroups) {
              subgroupIndex.forEach(function(d, i2) {
                d.sort(function(a, b) {
                  return sortSubgroups(matrix[i2][a], matrix[i2][b]);
                });
              });
            }
            k = (\u03C4 - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
              x0 = x, j = -1;
              while (++j < n) {
                var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                subgroups[di + "-" + dj] = {
                  index: di,
                  subindex: dj,
                  startAngle: a0,
                  endAngle: a1,
                  value: v
                };
              }
              groups[di] = {
                index: di,
                startAngle: x0,
                endAngle: x,
                value: groupSums[di]
              };
              x += padding;
            }
            i = -1;
            while (++i < n) {
              j = i - 1;
              while (++j < n) {
                var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                if (source.value || target.value) {
                  chords.push(source.value < target.value ? {
                    source: target,
                    target: source
                  } : {
                    source,
                    target
                  });
                }
              }
            }
            if (sortChords) resort();
          }
          function resort() {
            chords.sort(function(a, b) {
              return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
          }
          chord.matrix = function(x) {
            if (!arguments.length) return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
          };
          chord.padding = function(x) {
            if (!arguments.length) return padding;
            padding = x;
            chords = groups = null;
            return chord;
          };
          chord.sortGroups = function(x) {
            if (!arguments.length) return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
          };
          chord.sortSubgroups = function(x) {
            if (!arguments.length) return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
          };
          chord.sortChords = function(x) {
            if (!arguments.length) return sortChords;
            sortChords = x;
            if (chords) resort();
            return chord;
          };
          chord.chords = function() {
            if (!chords) relayout();
            return chords;
          };
          chord.groups = function() {
            if (!groups) relayout();
            return groups;
          };
          return chord;
        };
        d3.layout.force = function() {
          var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [1, 1], drag, alpha, friction = 0.9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = 0.1, theta2 = 0.64, nodes = [], links = [], distances, strengths, charges;
          function repulse(node) {
            return function(quad, x1, _, x2) {
              if (quad.point !== node) {
                var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                if (dw * dw / theta2 < dn) {
                  if (dn < chargeDistance2) {
                    var k = quad.charge / dn;
                    node.px -= dx * k;
                    node.py -= dy * k;
                  }
                  return true;
                }
                if (quad.point && dn && dn < chargeDistance2) {
                  var k = quad.pointCharge / dn;
                  node.px -= dx * k;
                  node.py -= dy * k;
                }
              }
              return !quad.charge;
            };
          }
          force.tick = function() {
            if ((alpha *= 0.99) < 5e-3) {
              timer = null;
              event.end({
                type: "end",
                alpha: alpha = 0
              });
              return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
              o = links[i];
              s = o.source;
              t = o.target;
              x = t.x - s.x;
              y = t.y - s.y;
              if (l = x * x + y * y) {
                l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                x *= l;
                y *= l;
                t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : 0.5);
                t.y -= y * k;
                s.x += x * (k = 1 - k);
                s.y += y * k;
              }
            }
            if (k = alpha * gravity) {
              x = size[0] / 2;
              y = size[1] / 2;
              i = -1;
              if (k) while (++i < n) {
                o = nodes[i];
                o.x += (x - o.x) * k;
                o.y += (y - o.y) * k;
              }
            }
            if (charge) {
              d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
              i = -1;
              while (++i < n) {
                if (!(o = nodes[i]).fixed) {
                  q.visit(repulse(o));
                }
              }
            }
            i = -1;
            while (++i < n) {
              o = nodes[i];
              if (o.fixed) {
                o.x = o.px;
                o.y = o.py;
              } else {
                o.x -= (o.px - (o.px = o.x)) * friction;
                o.y -= (o.py - (o.py = o.y)) * friction;
              }
            }
            event.tick({
              type: "tick",
              alpha
            });
          };
          force.nodes = function(x) {
            if (!arguments.length) return nodes;
            nodes = x;
            return force;
          };
          force.links = function(x) {
            if (!arguments.length) return links;
            links = x;
            return force;
          };
          force.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return force;
          };
          force.linkDistance = function(x) {
            if (!arguments.length) return linkDistance;
            linkDistance = typeof x === "function" ? x : +x;
            return force;
          };
          force.distance = force.linkDistance;
          force.linkStrength = function(x) {
            if (!arguments.length) return linkStrength;
            linkStrength = typeof x === "function" ? x : +x;
            return force;
          };
          force.friction = function(x) {
            if (!arguments.length) return friction;
            friction = +x;
            return force;
          };
          force.charge = function(x) {
            if (!arguments.length) return charge;
            charge = typeof x === "function" ? x : +x;
            return force;
          };
          force.chargeDistance = function(x) {
            if (!arguments.length) return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
          };
          force.gravity = function(x) {
            if (!arguments.length) return gravity;
            gravity = +x;
            return force;
          };
          force.theta = function(x) {
            if (!arguments.length) return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
          };
          force.alpha = function(x) {
            if (!arguments.length) return alpha;
            x = +x;
            if (alpha) {
              if (x > 0) {
                alpha = x;
              } else {
                timer.c = null, timer.t = NaN, timer = null;
                event.end({
                  type: "end",
                  alpha: alpha = 0
                });
              }
            } else if (x > 0) {
              event.start({
                type: "start",
                alpha: alpha = x
              });
              timer = d3_timer(force.tick);
            }
            return force;
          };
          force.start = function() {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
              (o = nodes[i]).index = i;
              o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
              o = links[i];
              if (typeof o.source == "number") o.source = nodes[o.source];
              if (typeof o.target == "number") o.target = nodes[o.target];
              ++o.source.weight;
              ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
              o = nodes[i];
              if (isNaN(o.x)) o.x = position("x", w);
              if (isNaN(o.y)) o.y = position("y", h);
              if (isNaN(o.px)) o.px = o.x;
              if (isNaN(o.py)) o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i);
            else for (i = 0; i < m; ++i) distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i);
            else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i);
            else for (i = 0; i < n; ++i) charges[i] = charge;
            function position(dimension, size2) {
              if (!neighbors) {
                neighbors = new Array(n);
                for (j = 0; j < n; ++j) {
                  neighbors[j] = [];
                }
                for (j = 0; j < m; ++j) {
                  var o2 = links[j];
                  neighbors[o2.source.index].push(o2.target);
                  neighbors[o2.target.index].push(o2.source);
                }
              }
              var candidates = neighbors[i], j = -1, l = candidates.length, x;
              while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
              return Math.random() * size2;
            }
            return force.resume();
          };
          force.resume = function() {
            return force.alpha(0.1);
          };
          force.stop = function() {
            return force.alpha(0);
          };
          force.drag = function() {
            if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length) return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
          };
          function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
          }
          return d3.rebind(force, event, "on");
        };
        function d3_layout_forceDragstart(d) {
          d.fixed |= 2;
        }
        function d3_layout_forceDragend(d) {
          d.fixed &= ~6;
        }
        function d3_layout_forceMouseover(d) {
          d.fixed |= 4;
          d.px = d.x, d.py = d.y;
        }
        function d3_layout_forceMouseout(d) {
          d.fixed &= ~4;
        }
        function d3_layout_forceAccumulate(quad, alpha, charges) {
          var cx = 0, cy = 0;
          quad.charge = 0;
          if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
              c = nodes[i];
              if (c == null) continue;
              d3_layout_forceAccumulate(c, alpha, charges);
              quad.charge += c.charge;
              cx += c.charge * c.cx;
              cy += c.charge * c.cy;
            }
          }
          if (quad.point) {
            if (!quad.leaf) {
              quad.point.x += Math.random() - 0.5;
              quad.point.y += Math.random() - 0.5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
          }
          quad.cx = cx / quad.charge;
          quad.cy = cy / quad.charge;
        }
        var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
        d3.layout.hierarchy = function() {
          var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
          function hierarchy(root) {
            var stack = [root], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
              nodes.push(node);
              if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                var n, childs, child;
                while (--n >= 0) {
                  stack.push(child = childs[n]);
                  child.parent = node;
                  child.depth = node.depth + 1;
                }
                if (value) node.value = 0;
                node.children = childs;
              } else {
                if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
                delete node.children;
              }
            }
            d3_layout_hierarchyVisitAfter(root, function(node2) {
              var childs2, parent;
              if (sort && (childs2 = node2.children)) childs2.sort(sort);
              if (value && (parent = node2.parent)) parent.value += node2.value;
            });
            return nodes;
          }
          hierarchy.sort = function(x) {
            if (!arguments.length) return sort;
            sort = x;
            return hierarchy;
          };
          hierarchy.children = function(x) {
            if (!arguments.length) return children;
            children = x;
            return hierarchy;
          };
          hierarchy.value = function(x) {
            if (!arguments.length) return value;
            value = x;
            return hierarchy;
          };
          hierarchy.revalue = function(root) {
            if (value) {
              d3_layout_hierarchyVisitBefore(root, function(node) {
                if (node.children) node.value = 0;
              });
              d3_layout_hierarchyVisitAfter(root, function(node) {
                var parent;
                if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
                if (parent = node.parent) parent.value += node.value;
              });
            }
            return root;
          };
          return hierarchy;
        };
        function d3_layout_hierarchyRebind(object, hierarchy) {
          d3.rebind(object, hierarchy, "sort", "children", "value");
          object.nodes = object;
          object.links = d3_layout_hierarchyLinks;
          return object;
        }
        function d3_layout_hierarchyVisitBefore(node, callback) {
          var nodes = [node];
          while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
              var n, children;
              while (--n >= 0) nodes.push(children[n]);
            }
          }
        }
        function d3_layout_hierarchyVisitAfter(node, callback) {
          var nodes = [node], nodes2 = [];
          while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
              var i = -1, n, children;
              while (++i < n) nodes.push(children[i]);
            }
          }
          while ((node = nodes2.pop()) != null) {
            callback(node);
          }
        }
        function d3_layout_hierarchyChildren(d) {
          return d.children;
        }
        function d3_layout_hierarchyValue(d) {
          return d.value;
        }
        function d3_layout_hierarchySort(a, b) {
          return b.value - a.value;
        }
        function d3_layout_hierarchyLinks(nodes) {
          return d3.merge(nodes.map(function(parent) {
            return (parent.children || []).map(function(child) {
              return {
                source: parent,
                target: child
              };
            });
          }));
        }
        d3.layout.partition = function() {
          var hierarchy = d3.layout.hierarchy(), size = [1, 1];
          function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
              var i = -1, n, c, d;
              dx = node.value ? dx / node.value : 0;
              while (++i < n) {
                position(c = children[i], x, d = c.value * dx, dy);
                x += d;
              }
            }
          }
          function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
              var i = -1, n;
              while (++i < n) d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
          }
          function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
          }
          partition.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return partition;
          };
          return d3_layout_hierarchyRebind(partition, hierarchy);
        };
        d3.layout.pie = function() {
          var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = \u03C4, padAngle = 0;
          function pie(data) {
            var n = data.length, values = data.map(function(d, i) {
              return +value.call(pie, d, i);
            }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
            if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
              return values[j] - values[i];
            } : function(i, j) {
              return sort(data[i], data[j]);
            });
            index.forEach(function(i) {
              arcs[i] = {
                data: data[i],
                value: v = values[i],
                startAngle: a,
                endAngle: a += v * k + pa,
                padAngle: p
              };
            });
            return arcs;
          }
          pie.value = function(_) {
            if (!arguments.length) return value;
            value = _;
            return pie;
          };
          pie.sort = function(_) {
            if (!arguments.length) return sort;
            sort = _;
            return pie;
          };
          pie.startAngle = function(_) {
            if (!arguments.length) return startAngle;
            startAngle = _;
            return pie;
          };
          pie.endAngle = function(_) {
            if (!arguments.length) return endAngle;
            endAngle = _;
            return pie;
          };
          pie.padAngle = function(_) {
            if (!arguments.length) return padAngle;
            padAngle = _;
            return pie;
          };
          return pie;
        };
        var d3_layout_pieSortByValue = {};
        d3.layout.stack = function() {
          var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
          function stack(data, index) {
            if (!(n = data.length)) return data;
            var series = data.map(function(d, i2) {
              return values.call(stack, d, i2);
            });
            var points = series.map(function(d) {
              return d.map(function(v, i2) {
                return [x.call(stack, v, i2), y.call(stack, v, i2)];
              });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i, j, o;
            for (j = 0; j < m; ++j) {
              out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
              for (i = 1; i < n; ++i) {
                out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
              }
            }
            return data;
          }
          stack.values = function(x2) {
            if (!arguments.length) return values;
            values = x2;
            return stack;
          };
          stack.order = function(x2) {
            if (!arguments.length) return order;
            order = typeof x2 === "function" ? x2 : d3_layout_stackOrders.get(x2) || d3_layout_stackOrderDefault;
            return stack;
          };
          stack.offset = function(x2) {
            if (!arguments.length) return offset;
            offset = typeof x2 === "function" ? x2 : d3_layout_stackOffsets.get(x2) || d3_layout_stackOffsetZero;
            return stack;
          };
          stack.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            return stack;
          };
          stack.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            return stack;
          };
          stack.out = function(z) {
            if (!arguments.length) return out;
            out = z;
            return stack;
          };
          return stack;
        };
        function d3_layout_stackX(d) {
          return d.x;
        }
        function d3_layout_stackY(d) {
          return d.y;
        }
        function d3_layout_stackOut(d, y0, y) {
          d.y0 = y0;
          d.y = y;
        }
        var d3_layout_stackOrders = d3.map({
          "inside-out": function(data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
              return max[a] - max[b];
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
              j = index[i];
              if (top < bottom) {
                top += sums[j];
                tops.push(j);
              } else {
                bottom += sums[j];
                bottoms.push(j);
              }
            }
            return bottoms.reverse().concat(tops);
          },
          reverse: function(data) {
            return d3.range(data.length).reverse();
          },
          "default": d3_layout_stackOrderDefault
        });
        var d3_layout_stackOffsets = d3.map({
          silhouette: function(data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
              for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
              if (o > max) max = o;
              sums.push(o);
            }
            for (j = 0; j < m; ++j) {
              y0[j] = (max - sums[j]) / 2;
            }
            return y0;
          },
          wiggle: function(data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
              for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
              for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                  s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                }
                s2 += s3 * data[i][j][1];
              }
              y0[j] = o -= s1 ? s2 / s1 * dx : 0;
              if (o < o0) o0 = o;
            }
            for (j = 0; j < m; ++j) y0[j] -= o0;
            return y0;
          },
          expand: function(data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
              for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
              if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;
              else for (i = 0; i < n; i++) data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j) y0[j] = 0;
            return y0;
          },
          zero: d3_layout_stackOffsetZero
        });
        function d3_layout_stackOrderDefault(data) {
          return d3.range(data.length);
        }
        function d3_layout_stackOffsetZero(data) {
          var j = -1, m = data[0].length, y0 = [];
          while (++j < m) y0[j] = 0;
          return y0;
        }
        function d3_layout_stackMaxIndex(array) {
          var i = 1, j = 0, v = array[0][1], k, n = array.length;
          for (; i < n; ++i) {
            if ((k = array[i][1]) > v) {
              j = i;
              v = k;
            }
          }
          return j;
        }
        function d3_layout_stackReduceSum(d) {
          return d.reduce(d3_layout_stackSum, 0);
        }
        function d3_layout_stackSum(p, d) {
          return p + d[1];
        }
        d3.layout.histogram = function() {
          var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
          function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
              bin = bins[i] = [];
              bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
              bin.y = 0;
            }
            if (m > 0) {
              i = -1;
              while (++i < n) {
                x = values[i];
                if (x >= range[0] && x <= range[1]) {
                  bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                  bin.y += k;
                  bin.push(data[i]);
                }
              }
            }
            return bins;
          }
          histogram.value = function(x) {
            if (!arguments.length) return valuer;
            valuer = x;
            return histogram;
          };
          histogram.range = function(x) {
            if (!arguments.length) return ranger;
            ranger = d3_functor(x);
            return histogram;
          };
          histogram.bins = function(x) {
            if (!arguments.length) return binner;
            binner = typeof x === "number" ? function(range) {
              return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
          };
          histogram.frequency = function(x) {
            if (!arguments.length) return frequency;
            frequency = !!x;
            return histogram;
          };
          return histogram;
        };
        function d3_layout_histogramBinSturges(range, values) {
          return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
        }
        function d3_layout_histogramBinFixed(range, n) {
          var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
          while (++x <= n) f[x] = m * x + b;
          return f;
        }
        function d3_layout_histogramRange(values) {
          return [d3.min(values), d3.max(values)];
        }
        d3.layout.pack = function() {
          var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [1, 1], radius;
          function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
              return radius;
            };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function(d2) {
              d2.r = +r(d2.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
              var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
              d3_layout_hierarchyVisitAfter(root, function(d2) {
                d2.r += dr;
              });
              d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
              d3_layout_hierarchyVisitAfter(root, function(d2) {
                d2.r -= dr;
              });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
          }
          pack.size = function(_) {
            if (!arguments.length) return size;
            size = _;
            return pack;
          };
          pack.radius = function(_) {
            if (!arguments.length) return radius;
            radius = _ == null || typeof _ === "function" ? _ : +_;
            return pack;
          };
          pack.padding = function(_) {
            if (!arguments.length) return padding;
            padding = +_;
            return pack;
          };
          return d3_layout_hierarchyRebind(pack, hierarchy);
        };
        function d3_layout_packSort(a, b) {
          return a.value - b.value;
        }
        function d3_layout_packInsert(a, b) {
          var c = a._pack_next;
          a._pack_next = b;
          b._pack_prev = a;
          b._pack_next = c;
          c._pack_prev = b;
        }
        function d3_layout_packSplice(a, b) {
          a._pack_next = b;
          b._pack_prev = a;
        }
        function d3_layout_packIntersects(a, b) {
          var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
          return 0.999 * dr * dr > dx * dx + dy * dy;
        }
        function d3_layout_packSiblings(node) {
          if (!(nodes = node.children) || !(n = nodes.length)) return;
          var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
          function bound(node2) {
            xMin = Math.min(node2.x - node2.r, xMin);
            xMax = Math.max(node2.x + node2.r, xMax);
            yMin = Math.min(node2.y - node2.r, yMin);
            yMax = Math.max(node2.y + node2.r, yMax);
          }
          nodes.forEach(d3_layout_packLink);
          a = nodes[0];
          a.x = -a.r;
          a.y = 0;
          bound(a);
          if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
              c = nodes[2];
              d3_layout_packPlace(a, b, c);
              bound(c);
              d3_layout_packInsert(a, c);
              a._pack_prev = c;
              d3_layout_packInsert(c, b);
              b = a._pack_next;
              for (i = 3; i < n; i++) {
                d3_layout_packPlace(a, b, c = nodes[i]);
                var isect = 0, s1 = 1, s2 = 1;
                for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                  if (d3_layout_packIntersects(j, c)) {
                    isect = 1;
                    break;
                  }
                }
                if (isect == 1) {
                  for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                    if (d3_layout_packIntersects(k, c)) {
                      break;
                    }
                  }
                }
                if (isect) {
                  if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j);
                  else d3_layout_packSplice(a = k, b);
                  i--;
                } else {
                  d3_layout_packInsert(a, c);
                  b = c;
                  bound(c);
                }
              }
            }
          }
          var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
          for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
          }
          node.r = cr;
          nodes.forEach(d3_layout_packUnlink);
        }
        function d3_layout_packLink(node) {
          node._pack_next = node._pack_prev = node;
        }
        function d3_layout_packUnlink(node) {
          delete node._pack_next;
          delete node._pack_prev;
        }
        function d3_layout_packTransform(node, x, y, k) {
          var children = node.children;
          node.x = x += k * node.x;
          node.y = y += k * node.y;
          node.r *= k;
          if (children) {
            var i = -1, n = children.length;
            while (++i < n) d3_layout_packTransform(children[i], x, y, k);
          }
        }
        function d3_layout_packPlace(a, b, c) {
          var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
          if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = 0.5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
          } else {
            c.x = a.x + db;
            c.y = a.y;
          }
        }
        d3.layout.tree = function() {
          var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = null;
          function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode);
            else {
              var left = root0, right = root0, bottom = root0;
              d3_layout_hierarchyVisitBefore(root0, function(node) {
                if (node.x < left.x) left = node;
                if (node.x > right.x) right = node;
                if (node.depth > bottom.depth) bottom = node;
              });
              var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
              d3_layout_hierarchyVisitBefore(root0, function(node) {
                node.x = (node.x + tx) * kx;
                node.y = node.depth * ky;
              });
            }
            return nodes;
          }
          function wrapTree(root0) {
            var root1 = {
              A: null,
              children: [root0]
            }, queue = [root1], node1;
            while ((node1 = queue.pop()) != null) {
              for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                queue.push((children[i] = child = {
                  _: children[i],
                  parent: node1,
                  children: (child = children[i].children) && child.slice() || [],
                  A: null,
                  a: null,
                  z: 0,
                  m: 0,
                  c: 0,
                  s: 0,
                  t: null,
                  i
                }).a = child);
              }
            }
            return root1.children[0];
          }
          function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
              d3_layout_treeShift(v);
              var midpoint = (children[0].z + children[children.length - 1].z) / 2;
              if (w) {
                v.z = w.z + separation(v._, w._);
                v.m = v.z - midpoint;
              } else {
                v.z = midpoint;
              }
            } else if (w) {
              v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
          }
          function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
          }
          function apportion(v, w, ancestor) {
            if (w) {
              var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
              while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                vom = d3_layout_treeLeft(vom);
                vop = d3_layout_treeRight(vop);
                vop.a = v;
                shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                if (shift > 0) {
                  d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                  sip += shift;
                  sop += shift;
                }
                sim += vim.m;
                sip += vip.m;
                som += vom.m;
                sop += vop.m;
              }
              if (vim && !d3_layout_treeRight(vop)) {
                vop.t = vim;
                vop.m += sim - sop;
              }
              if (vip && !d3_layout_treeLeft(vom)) {
                vom.t = vip;
                vom.m += sip - som;
                ancestor = v;
              }
            }
            return ancestor;
          }
          function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
          }
          tree.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return tree;
          };
          tree.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
          };
          tree.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
          };
          return d3_layout_hierarchyRebind(tree, hierarchy);
        };
        function d3_layout_treeSeparation(a, b) {
          return a.parent == b.parent ? 1 : 2;
        }
        function d3_layout_treeLeft(v) {
          var children = v.children;
          return children.length ? children[0] : v.t;
        }
        function d3_layout_treeRight(v) {
          var children = v.children, n;
          return (n = children.length) ? children[n - 1] : v.t;
        }
        function d3_layout_treeMove(wm, wp, shift) {
          var change = shift / (wp.i - wm.i);
          wp.c -= change;
          wp.s += shift;
          wm.c += change;
          wp.z += shift;
          wp.m += shift;
        }
        function d3_layout_treeShift(v) {
          var shift = 0, change = 0, children = v.children, i = children.length, w;
          while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
          }
        }
        function d3_layout_treeAncestor(vim, v, ancestor) {
          return vim.a.parent === v.parent ? vim.a : ancestor;
        }
        d3.layout.cluster = function() {
          var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = false;
          function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function(node) {
              var children = node.children;
              if (children && children.length) {
                node.x = d3_layout_clusterX(children);
                node.y = d3_layout_clusterY(children);
              } else {
                node.x = previousNode ? x += separation(node, previousNode) : 0;
                node.y = 0;
                previousNode = node;
              }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
              node.x = (node.x - root.x) * size[0];
              node.y = (root.y - node.y) * size[1];
            } : function(node) {
              node.x = (node.x - x0) / (x1 - x0) * size[0];
              node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
          }
          cluster.separation = function(x) {
            if (!arguments.length) return separation;
            separation = x;
            return cluster;
          };
          cluster.size = function(x) {
            if (!arguments.length) return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
          };
          cluster.nodeSize = function(x) {
            if (!arguments.length) return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
          };
          return d3_layout_hierarchyRebind(cluster, hierarchy);
        };
        function d3_layout_clusterY(children) {
          return 1 + d3.max(children, function(child) {
            return child.y;
          });
        }
        function d3_layout_clusterX(children) {
          return children.reduce(function(x, child) {
            return x + child.x;
          }, 0) / children.length;
        }
        function d3_layout_clusterLeft(node) {
          var children = node.children;
          return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
        }
        function d3_layout_clusterRight(node) {
          var children = node.children, n;
          return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
        }
        d3.layout.treemap = function() {
          var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [1, 1], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = 0.5 * (1 + Math.sqrt(5));
          function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
              area = (child = children[i]).value * (k < 0 ? 0 : k);
              child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
          }
          function squarify(node) {
            var children = node.children;
            if (children && children.length) {
              var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
              scale(remaining, rect.dx * rect.dy / node.value);
              row.area = 0;
              while ((n = remaining.length) > 0) {
                row.push(child = remaining[n - 1]);
                row.area += child.area;
                if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                  remaining.pop();
                  best = score;
                } else {
                  row.area -= row.pop().area;
                  position(row, u, rect, false);
                  u = Math.min(rect.dx, rect.dy);
                  row.length = row.area = 0;
                  best = Infinity;
                }
              }
              if (row.length) {
                position(row, u, rect, true);
                row.length = row.area = 0;
              }
              children.forEach(squarify);
            }
          }
          function stickify(node) {
            var children = node.children;
            if (children && children.length) {
              var rect = pad(node), remaining = children.slice(), child, row = [];
              scale(remaining, rect.dx * rect.dy / node.value);
              row.area = 0;
              while (child = remaining.pop()) {
                row.push(child);
                row.area += child.area;
                if (child.z != null) {
                  position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                  row.length = row.area = 0;
                }
              }
              children.forEach(stickify);
            }
          }
          function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
              if (!(r = row[i].area)) continue;
              if (r < rmin) rmin = r;
              if (r > rmax) rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
          }
          function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
              if (flush || v > rect.dy) v = rect.dy;
              while (++i < n) {
                o = row[i];
                o.x = x;
                o.y = y;
                o.dy = v;
                x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
              }
              o.z = true;
              o.dx += rect.x + rect.dx - x;
              rect.y += v;
              rect.dy -= v;
            } else {
              if (flush || v > rect.dx) v = rect.dx;
              while (++i < n) {
                o = row[i];
                o.x = x;
                o.y = y;
                o.dx = v;
                y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
              }
              o.z = false;
              o.dy += rect.y + rect.dy - y;
              rect.x += v;
              rect.dx -= v;
            }
          }
          function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = root.y = 0;
            if (root.value) root.dx = size[0], root.dy = size[1];
            else root.dx = root.dy = 0;
            if (stickies) hierarchy.revalue(root);
            scale([root], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky) stickies = nodes;
            return nodes;
          }
          treemap.size = function(x) {
            if (!arguments.length) return size;
            size = x;
            return treemap;
          };
          treemap.padding = function(x) {
            if (!arguments.length) return padding;
            function padFunction(node) {
              var p = x.call(treemap, node, node.depth);
              return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
            }
            function padConstant(node) {
              return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x], padConstant) : padConstant;
            return treemap;
          };
          treemap.round = function(x) {
            if (!arguments.length) return round != Number;
            round = x ? Math.round : Number;
            return treemap;
          };
          treemap.sticky = function(x) {
            if (!arguments.length) return sticky;
            sticky = x;
            stickies = null;
            return treemap;
          };
          treemap.ratio = function(x) {
            if (!arguments.length) return ratio;
            ratio = x;
            return treemap;
          };
          treemap.mode = function(x) {
            if (!arguments.length) return mode;
            mode = x + "";
            return treemap;
          };
          return d3_layout_hierarchyRebind(treemap, hierarchy);
        };
        function d3_layout_treemapPadNull(node) {
          return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
          };
        }
        function d3_layout_treemapPad(node, padding) {
          var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
          if (dx < 0) {
            x += dx / 2;
            dx = 0;
          }
          if (dy < 0) {
            y += dy / 2;
            dy = 0;
          }
          return {
            x,
            y,
            dx,
            dy
          };
        }
        d3.random = {
          normal: function(mu, sigma) {
            var n = arguments.length;
            if (n < 2) sigma = 1;
            if (n < 1) mu = 0;
            return function() {
              var x, y, r;
              do {
                x = Math.random() * 2 - 1;
                y = Math.random() * 2 - 1;
                r = x * x + y * y;
              } while (!r || r > 1);
              return mu + sigma * x * Math.sqrt(-2 * Math.log(r) / r);
            };
          },
          logNormal: function() {
            var random = d3.random.normal.apply(d3, arguments);
            return function() {
              return Math.exp(random());
            };
          },
          bates: function(m) {
            var random = d3.random.irwinHall(m);
            return function() {
              return random() / m;
            };
          },
          irwinHall: function(m) {
            return function() {
              for (var s = 0, j = 0; j < m; j++) s += Math.random();
              return s;
            };
          }
        };
        d3.scale = {};
        function d3_scaleExtent(domain) {
          var start = domain[0], stop = domain[domain.length - 1];
          return start < stop ? [start, stop] : [stop, start];
        }
        function d3_scaleRange(scale) {
          return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
        }
        function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
          var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
          return function(x) {
            return i(u(x));
          };
        }
        function d3_scale_nice(domain, nice) {
          var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
          if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
          }
          domain[i0] = nice.floor(x0);
          domain[i1] = nice.ceil(x1);
          return domain;
        }
        function d3_scale_niceStep(step) {
          return step ? {
            floor: function(x) {
              return Math.floor(x / step) * step;
            },
            ceil: function(x) {
              return Math.ceil(x / step) * step;
            }
          } : d3_scale_niceIdentity;
        }
        var d3_scale_niceIdentity = {
          floor: d3_identity,
          ceil: d3_identity
        };
        function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
          var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
          if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
          }
          while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
          }
          return function(x) {
            var j2 = d3.bisect(domain, x, 1, k) - 1;
            return i[j2](u[j2](x));
          };
        }
        d3.scale.linear = function() {
          return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
        };
        function d3_scale_linear(domain, range, interpolate, clamp) {
          var output, input;
          function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
          }
          function scale(x) {
            return output(x);
          }
          scale.invert = function(y) {
            return input(y);
          };
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(Number);
            return rescale();
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
          };
          scale.rangeRound = function(x) {
            return scale.range(x).interpolate(d3_interpolateRound);
          };
          scale.clamp = function(x) {
            if (!arguments.length) return clamp;
            clamp = x;
            return rescale();
          };
          scale.interpolate = function(x) {
            if (!arguments.length) return interpolate;
            interpolate = x;
            return rescale();
          };
          scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
          };
          scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
          };
          scale.nice = function(m) {
            d3_scale_linearNice(domain, m);
            return rescale();
          };
          scale.copy = function() {
            return d3_scale_linear(domain, range, interpolate, clamp);
          };
          return rescale();
        }
        function d3_scale_linearRebind(scale, linear) {
          return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
        }
        function d3_scale_linearNice(domain, m) {
          d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
          d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
          return domain;
        }
        function d3_scale_linearTickRange(domain, m) {
          if (m == null) m = 10;
          var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
          if (err <= 0.15) step *= 10;
          else if (err <= 0.35) step *= 5;
          else if (err <= 0.75) step *= 2;
          extent[0] = Math.ceil(extent[0] / step) * step;
          extent[1] = Math.floor(extent[1] / step) * step + step * 0.5;
          extent[2] = step;
          return extent;
        }
        function d3_scale_linearTicks(domain, m) {
          return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
        }
        var d3_scale_linearFormatSignificant = {
          s: 1,
          g: 1,
          p: 1,
          r: 1,
          e: 1
        };
        function d3_scale_linearPrecision(value) {
          return -Math.floor(Math.log(value) / Math.LN10 + 0.01);
        }
        function d3_scale_linearFormatPrecision(type, range) {
          var p = d3_scale_linearPrecision(range[2]);
          return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
        }
        d3.scale.log = function() {
          return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
        };
        function d3_scale_log(linear, base, positive, domain) {
          function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
          }
          function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
          }
          function scale(x) {
            return linear(log(x));
          }
          scale.invert = function(x) {
            return pow(linear.invert(x));
          };
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
          };
          scale.base = function(_) {
            if (!arguments.length) return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
          };
          scale.nice = function() {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
          };
          scale.ticks = function() {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
              if (positive) {
                for (; i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
                ticks.push(pow(i));
              } else {
                ticks.push(pow(i));
                for (; i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
              }
              for (i = 0; ticks[i] < u; i++) {
              }
              for (j = ticks.length; ticks[j - 1] > v; j--) {
              }
              ticks = ticks.slice(i, j);
            }
            return ticks;
          };
          scale.copy = function() {
            return d3_scale_log(linear.copy(), base, positive, domain);
          };
          return d3_scale_linearRebind(scale, linear);
        }
        var d3_scale_logNiceNegative = {
          floor: function(x) {
            return -Math.ceil(-x);
          },
          ceil: function(x) {
            return -Math.floor(-x);
          }
        };
        d3.scale.pow = function() {
          return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
        };
        function d3_scale_pow(linear, exponent, domain) {
          var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
          function scale(x) {
            return linear(powp(x));
          }
          scale.invert = function(x) {
            return powb(linear.invert(x));
          };
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
          };
          scale.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
          };
          scale.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
          };
          scale.nice = function(m) {
            return scale.domain(d3_scale_linearNice(domain, m));
          };
          scale.exponent = function(x) {
            if (!arguments.length) return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
          };
          scale.copy = function() {
            return d3_scale_pow(linear.copy(), exponent, domain);
          };
          return d3_scale_linearRebind(scale, linear);
        }
        function d3_scale_powPow(e) {
          return function(x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
          };
        }
        d3.scale.sqrt = function() {
          return d3.scale.pow().exponent(0.5);
        };
        d3.scale.ordinal = function() {
          return d3_scale_ordinal([], {
            t: "range",
            a: [[]]
          });
        };
        function d3_scale_ordinal(domain, ranger) {
          var index, range, rangeBand;
          function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
          }
          function steps(start, step) {
            return d3.range(domain.length).map(function(i) {
              return start + step * i;
            });
          }
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            rangeBand = 0;
            ranger = {
              t: "range",
              a: arguments
            };
            return scale;
          };
          scale.rangePoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
              t: "rangePoints",
              a: arguments
            };
            return scale;
          };
          scale.rangeRoundPoints = function(x, padding) {
            if (arguments.length < 2) padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
              t: "rangeRoundPoints",
              a: arguments
            };
            return scale;
          };
          scale.rangeBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse) range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
              t: "rangeBands",
              a: arguments
            };
            return scale;
          };
          scale.rangeRoundBands = function(x, padding, outerPadding) {
            if (arguments.length < 2) padding = 0;
            if (arguments.length < 3) outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse) range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
              t: "rangeRoundBands",
              a: arguments
            };
            return scale;
          };
          scale.rangeBand = function() {
            return rangeBand;
          };
          scale.rangeExtent = function() {
            return d3_scaleExtent(ranger.a[0]);
          };
          scale.copy = function() {
            return d3_scale_ordinal(domain, ranger);
          };
          return scale.domain(domain);
        }
        d3.scale.category10 = function() {
          return d3.scale.ordinal().range(d3_category10);
        };
        d3.scale.category20 = function() {
          return d3.scale.ordinal().range(d3_category20);
        };
        d3.scale.category20b = function() {
          return d3.scale.ordinal().range(d3_category20b);
        };
        d3.scale.category20c = function() {
          return d3.scale.ordinal().range(d3_category20c);
        };
        var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
        var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
        var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
        var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
        d3.scale.quantile = function() {
          return d3_scale_quantile([], []);
        };
        function d3_scale_quantile(domain, range) {
          var thresholds;
          function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
          }
          function scale(x) {
            if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
          }
          scale.domain = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
          };
          scale.quantiles = function() {
            return thresholds;
          };
          scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
          };
          scale.copy = function() {
            return d3_scale_quantile(domain, range);
          };
          return rescale();
        }
        d3.scale.quantize = function() {
          return d3_scale_quantize(0, 1, [0, 1]);
        };
        function d3_scale_quantize(x0, x1, range) {
          var kx, i;
          function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
          }
          function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
          }
          scale.domain = function(x) {
            if (!arguments.length) return [x0, x1];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
          };
          scale.range = function(x) {
            if (!arguments.length) return range;
            range = x;
            return rescale();
          };
          scale.invertExtent = function(y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [y, y + 1 / kx];
          };
          scale.copy = function() {
            return d3_scale_quantize(x0, x1, range);
          };
          return rescale();
        }
        d3.scale.threshold = function() {
          return d3_scale_threshold([0.5], [0, 1]);
        };
        function d3_scale_threshold(domain, range) {
          function scale(x) {
            if (x <= x) return range[d3.bisect(domain, x)];
          }
          scale.domain = function(_) {
            if (!arguments.length) return domain;
            domain = _;
            return scale;
          };
          scale.range = function(_) {
            if (!arguments.length) return range;
            range = _;
            return scale;
          };
          scale.invertExtent = function(y) {
            y = range.indexOf(y);
            return [domain[y - 1], domain[y]];
          };
          scale.copy = function() {
            return d3_scale_threshold(domain, range);
          };
          return scale;
        }
        d3.scale.identity = function() {
          return d3_scale_identity([0, 1]);
        };
        function d3_scale_identity(domain) {
          function identity(x) {
            return +x;
          }
          identity.invert = identity;
          identity.domain = identity.range = function(x) {
            if (!arguments.length) return domain;
            domain = x.map(identity);
            return identity;
          };
          identity.ticks = function(m) {
            return d3_scale_linearTicks(domain, m);
          };
          identity.tickFormat = function(m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
          };
          identity.copy = function() {
            return d3_scale_identity(domain);
          };
          return identity;
        }
        d3.svg = {};
        function d3_zero() {
          return 0;
        }
        d3.svg.arc = function() {
          var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
          function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half\u03C0, a1 = endAngle.apply(this, arguments) - half\u03C0, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
            if (da >= \u03C4\u03B5) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
              rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
              if (!cw) p1 *= -1;
              if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
              if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
              x0 = r1 * Math.cos(a0 + p1);
              y0 = r1 * Math.sin(a0 + p1);
              x1 = r1 * Math.cos(a1 - p1);
              y1 = r1 * Math.sin(a1 - p1);
              var l1 = Math.abs(a1 - a0 - 2 * p1) <= \u03C0 ? 0 : 1;
              if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                var h1 = (a0 + a1) / 2;
                x0 = r1 * Math.cos(h1);
                y0 = r1 * Math.sin(h1);
                x1 = y1 = null;
              }
            } else {
              x0 = y0 = 0;
            }
            if (r0) {
              x2 = r0 * Math.cos(a1 - p0);
              y2 = r0 * Math.sin(a1 - p0);
              x3 = r0 * Math.cos(a0 + p0);
              y3 = r0 * Math.sin(a0 + p0);
              var l0 = Math.abs(a0 - a1 + 2 * p0) <= \u03C0 ? 0 : 1;
              if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                var h0 = (a0 + a1) / 2;
                x2 = r0 * Math.cos(h0);
                y2 = r0 * Math.sin(h0);
                x3 = y3 = null;
              }
            } else {
              x2 = y2 = 0;
            }
            if (da > \u03B5 && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > 1e-3) {
              cr = r0 < r1 ^ cw ? 0 : 1;
              var rc1 = rc, rc0 = rc;
              if (da < \u03C0) {
                var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
              }
              if (x1 != null) {
                var t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
                if (rc === rc1) {
                  path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                } else {
                  path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                }
              } else {
                path.push("M", x0, ",", y0);
              }
              if (x3 != null) {
                var t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
                if (rc === rc0) {
                  path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                } else {
                  path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                }
              } else {
                path.push("L", x2, ",", y2);
              }
            } else {
              path.push("M", x0, ",", y0);
              if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
              path.push("L", x2, ",", y2);
              if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
            }
            path.push("Z");
            return path.join("");
          }
          function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
          }
          arc.innerRadius = function(v) {
            if (!arguments.length) return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
          };
          arc.outerRadius = function(v) {
            if (!arguments.length) return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
          };
          arc.cornerRadius = function(v) {
            if (!arguments.length) return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
          };
          arc.padRadius = function(v) {
            if (!arguments.length) return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
          };
          arc.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return arc;
          };
          arc.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return arc;
          };
          arc.padAngle = function(v) {
            if (!arguments.length) return padAngle;
            padAngle = d3_functor(v);
            return arc;
          };
          arc.centroid = function() {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half\u03C0;
            return [Math.cos(a) * r, Math.sin(a) * r];
          };
          return arc;
        };
        var d3_svg_arcAuto = "auto";
        function d3_svg_arcInnerRadius(d) {
          return d.innerRadius;
        }
        function d3_svg_arcOuterRadius(d) {
          return d.outerRadius;
        }
        function d3_svg_arcStartAngle(d) {
          return d.startAngle;
        }
        function d3_svg_arcEndAngle(d) {
          return d.endAngle;
        }
        function d3_svg_arcPadAngle(d) {
          return d && d.padAngle;
        }
        function d3_svg_arcSweep(x0, y0, x1, y1) {
          return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
        }
        function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
          var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
          if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
          return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
        }
        function d3_true() {
          return true;
        }
        function d3_svg_line(projection) {
          var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = 0.7;
          function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
              segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
              if (defined.call(this, d = data[i], i)) {
                points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
              } else if (points.length) {
                segment();
                points = [];
              }
            }
            if (points.length) segment();
            return segments.length ? segments.join("") : null;
          }
          line.x = function(_) {
            if (!arguments.length) return x;
            x = _;
            return line;
          };
          line.y = function(_) {
            if (!arguments.length) return y;
            y = _;
            return line;
          };
          line.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return line;
          };
          line.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _;
            else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
          };
          line.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return line;
          };
          return line;
        }
        d3.svg.line = function() {
          return d3_svg_line(d3_identity);
        };
        var d3_svg_lineInterpolators = d3.map({
          linear: d3_svg_lineLinear,
          "linear-closed": d3_svg_lineLinearClosed,
          step: d3_svg_lineStep,
          "step-before": d3_svg_lineStepBefore,
          "step-after": d3_svg_lineStepAfter,
          basis: d3_svg_lineBasis,
          "basis-open": d3_svg_lineBasisOpen,
          "basis-closed": d3_svg_lineBasisClosed,
          bundle: d3_svg_lineBundle,
          cardinal: d3_svg_lineCardinal,
          "cardinal-open": d3_svg_lineCardinalOpen,
          "cardinal-closed": d3_svg_lineCardinalClosed,
          monotone: d3_svg_lineMonotone
        });
        d3_svg_lineInterpolators.forEach(function(key, value) {
          value.key = key;
          value.closed = /-closed$/.test(key);
        });
        function d3_svg_lineLinear(points) {
          return points.length > 1 ? points.join("L") : points + "Z";
        }
        function d3_svg_lineLinearClosed(points) {
          return points.join("L") + "Z";
        }
        function d3_svg_lineStep(points) {
          var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
          while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
          if (n > 1) path.push("H", p[0]);
          return path.join("");
        }
        function d3_svg_lineStepBefore(points) {
          var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
          while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
          return path.join("");
        }
        function d3_svg_lineStepAfter(points) {
          var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
          while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
          return path.join("");
        }
        function d3_svg_lineCardinalOpen(points, tension) {
          return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
        }
        function d3_svg_lineCardinalClosed(points, tension) {
          return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
        }
        function d3_svg_lineCardinal(points, tension) {
          return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
        }
        function d3_svg_lineHermite(points, tangents) {
          if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
          }
          var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
          if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
          }
          if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
              p = points[pi];
              t = tangents[i];
              path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
          }
          if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
          }
          return path;
        }
        function d3_svg_lineCardinalTangents(points, tension) {
          var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
          while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
          }
          return tangents;
        }
        function d3_svg_lineBasis(points) {
          if (points.length < 3) return d3_svg_lineLinear(points);
          var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [x0, x0, x0, (pi = points[1])[0]], py = [y0, y0, y0, pi[1]], path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
          points.push(points[n - 1]);
          while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          points.pop();
          path.push("L", pi);
          return path.join("");
        }
        function d3_svg_lineBasisOpen(points) {
          if (points.length < 4) return d3_svg_lineLinear(points);
          var path = [], i = -1, n = points.length, pi, px = [0], py = [0];
          while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
          }
          path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
          --i;
          while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          return path.join("");
        }
        function d3_svg_lineBasisClosed(points) {
          var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
          while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
          }
          path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
          --i;
          while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
          }
          return path.join("");
        }
        function d3_svg_lineBundle(points, tension) {
          var n = points.length - 1;
          if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
              p = points[i];
              t = i / n;
              p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
              p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
          }
          return d3_svg_lineBasis(points);
        }
        function d3_svg_lineDot4(a, b) {
          return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        }
        var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0], d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0], d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
        function d3_svg_lineBasisBezier(path, x, y) {
          path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
        }
        function d3_svg_lineSlope(p0, p1) {
          return (p1[1] - p0[1]) / (p1[0] - p0[0]);
        }
        function d3_svg_lineFiniteDifferences(points) {
          var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
          while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
          }
          m[i] = d;
          return m;
        }
        function d3_svg_lineMonotoneTangents(points) {
          var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
          while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < \u03B5) {
              m[i] = m[i + 1] = 0;
            } else {
              a = m[i] / d;
              b = m[i + 1] / d;
              s = a * a + b * b;
              if (s > 9) {
                s = d * 3 / Math.sqrt(s);
                m[i] = s * a;
                m[i + 1] = s * b;
              }
            }
          }
          i = -1;
          while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([s || 0, m[i] * s || 0]);
          }
          return tangents;
        }
        function d3_svg_lineMonotone(points) {
          return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
        }
        d3.svg.line.radial = function() {
          var line = d3_svg_line(d3_svg_lineRadial);
          line.radius = line.x, delete line.x;
          line.angle = line.y, delete line.y;
          return line;
        };
        function d3_svg_lineRadial(points) {
          var point, i = -1, n = points.length, r, a;
          while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - half\u03C0;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
          }
          return points;
        }
        function d3_svg_area(projection) {
          var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = 0.7;
          function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
              return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function() {
              return y;
            } : d3_functor(y1), x, y;
            function segment() {
              segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
              if (defined.call(this, d = data[i], i)) {
                points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
                points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
              } else if (points0.length) {
                segment();
                points0 = [];
                points1 = [];
              }
            }
            if (points0.length) segment();
            return segments.length ? segments.join("") : null;
          }
          area.x = function(_) {
            if (!arguments.length) return x1;
            x0 = x1 = _;
            return area;
          };
          area.x0 = function(_) {
            if (!arguments.length) return x0;
            x0 = _;
            return area;
          };
          area.x1 = function(_) {
            if (!arguments.length) return x1;
            x1 = _;
            return area;
          };
          area.y = function(_) {
            if (!arguments.length) return y1;
            y0 = y1 = _;
            return area;
          };
          area.y0 = function(_) {
            if (!arguments.length) return y0;
            y0 = _;
            return area;
          };
          area.y1 = function(_) {
            if (!arguments.length) return y1;
            y1 = _;
            return area;
          };
          area.defined = function(_) {
            if (!arguments.length) return defined;
            defined = _;
            return area;
          };
          area.interpolate = function(_) {
            if (!arguments.length) return interpolateKey;
            if (typeof _ === "function") interpolateKey = interpolate = _;
            else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
          };
          area.tension = function(_) {
            if (!arguments.length) return tension;
            tension = _;
            return area;
          };
          return area;
        }
        d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
        d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
        d3.svg.area = function() {
          return d3_svg_area(d3_identity);
        };
        d3.svg.area.radial = function() {
          var area = d3_svg_area(d3_svg_lineRadial);
          area.radius = area.x, delete area.x;
          area.innerRadius = area.x0, delete area.x0;
          area.outerRadius = area.x1, delete area.x1;
          area.angle = area.y, delete area.y;
          area.startAngle = area.y0, delete area.y0;
          area.endAngle = area.y1, delete area.y1;
          return area;
        };
        function d3_source(d) {
          return d.source;
        }
        function d3_target(d) {
          return d.target;
        }
        d3.svg.chord = function() {
          var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
          function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
          }
          function subgroup(self2, f, d, i) {
            var subgroup2 = f.call(self2, d, i), r = radius.call(self2, subgroup2, i), a0 = startAngle.call(self2, subgroup2, i) - half\u03C0, a1 = endAngle.call(self2, subgroup2, i) - half\u03C0;
            return {
              r,
              a0,
              a1,
              p0: [r * Math.cos(a0), r * Math.sin(a0)],
              p1: [r * Math.cos(a1), r * Math.sin(a1)]
            };
          }
          function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
          }
          function arc(r, p, a) {
            return "A" + r + "," + r + " 0 " + +(a > \u03C0) + ",1 " + p;
          }
          function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
          }
          chord.radius = function(v) {
            if (!arguments.length) return radius;
            radius = d3_functor(v);
            return chord;
          };
          chord.source = function(v) {
            if (!arguments.length) return source;
            source = d3_functor(v);
            return chord;
          };
          chord.target = function(v) {
            if (!arguments.length) return target;
            target = d3_functor(v);
            return chord;
          };
          chord.startAngle = function(v) {
            if (!arguments.length) return startAngle;
            startAngle = d3_functor(v);
            return chord;
          };
          chord.endAngle = function(v) {
            if (!arguments.length) return endAngle;
            endAngle = d3_functor(v);
            return chord;
          };
          return chord;
        };
        function d3_svg_chordRadius(d) {
          return d.radius;
        }
        d3.svg.diagonal = function() {
          var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
          function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [p0, {
              x: p0.x,
              y: m
            }, {
              x: p3.x,
              y: m
            }, p3];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
          }
          diagonal.source = function(x) {
            if (!arguments.length) return source;
            source = d3_functor(x);
            return diagonal;
          };
          diagonal.target = function(x) {
            if (!arguments.length) return target;
            target = d3_functor(x);
            return diagonal;
          };
          diagonal.projection = function(x) {
            if (!arguments.length) return projection;
            projection = x;
            return diagonal;
          };
          return diagonal;
        };
        function d3_svg_diagonalProjection(d) {
          return [d.x, d.y];
        }
        d3.svg.diagonal.radial = function() {
          var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
          diagonal.projection = function(x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
          };
          return diagonal;
        };
        function d3_svg_diagonalRadialProjection(projection) {
          return function() {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - half\u03C0;
            return [r * Math.cos(a), r * Math.sin(a)];
          };
        }
        d3.svg.symbol = function() {
          var type = d3_svg_symbolType, size = d3_svg_symbolSize;
          function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
          }
          symbol.type = function(x) {
            if (!arguments.length) return type;
            type = d3_functor(x);
            return symbol;
          };
          symbol.size = function(x) {
            if (!arguments.length) return size;
            size = d3_functor(x);
            return symbol;
          };
          return symbol;
        };
        function d3_svg_symbolSize() {
          return 64;
        }
        function d3_svg_symbolType() {
          return "circle";
        }
        function d3_svg_symbolCircle(size) {
          var r = Math.sqrt(size / \u03C0);
          return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
        }
        var d3_svg_symbols = d3.map({
          circle: d3_svg_symbolCircle,
          cross: function(size) {
            var r = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
          },
          diamond: function(size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z";
          },
          square: function(size) {
            var r = Math.sqrt(size) / 2;
            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
          },
          "triangle-down": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
          },
          "triangle-up": function(size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
          }
        });
        d3.svg.symbolTypes = d3_svg_symbols.keys();
        var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
        d3_selectionPrototype.transition = function(name) {
          var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
            time: Date.now(),
            ease: d3_ease_cubicInOut,
            delay: 0,
            duration: 250
          };
          for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
              subgroup.push(node);
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_selectionPrototype.interrupt = function(name) {
          return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
        };
        var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
        function d3_selection_interruptNS(ns) {
          return function() {
            var lock, activeId, active;
            if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
              active.timer.c = null;
              active.timer.t = NaN;
              if (--lock.count) delete lock[activeId];
              else delete this[ns];
              lock.active += 0.5;
              active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
          };
        }
        function d3_transition(groups, ns, id) {
          d3_subclass(groups, d3_transitionPrototype);
          groups.namespace = ns;
          groups.id = id;
          return groups;
        }
        var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
        d3_transitionPrototype.call = d3_selectionPrototype.call;
        d3_transitionPrototype.empty = d3_selectionPrototype.empty;
        d3_transitionPrototype.node = d3_selectionPrototype.node;
        d3_transitionPrototype.size = d3_selectionPrototype.size;
        d3.transition = function(selection, name) {
          return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
        };
        d3.transition.prototype = d3_transitionPrototype;
        d3_transitionPrototype.select = function(selector) {
          var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
          selector = d3_selection_selector(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                if ("__data__" in node) subnode.__data__ = node.__data__;
                d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                subgroup.push(subnode);
              } else {
                subgroup.push(null);
              }
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_transitionPrototype.selectAll = function(selector) {
          var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
          selector = d3_selection_selectorAll(selector);
          for (var j = -1, m = this.length; ++j < m; ) {
            for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
              if (node = group[i]) {
                transition = node[ns][id];
                subnodes = selector.call(node, node.__data__, i, j);
                subgroups.push(subgroup = []);
                for (var k = -1, o = subnodes.length; ++k < o; ) {
                  if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                  subgroup.push(subnode);
                }
              }
            }
          }
          return d3_transition(subgroups, ns, id);
        };
        d3_transitionPrototype.filter = function(filter) {
          var subgroups = [], subgroup, group, node;
          if (typeof filter !== "function") filter = d3_selection_filter(filter);
          for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
              if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                subgroup.push(node);
              }
            }
          }
          return d3_transition(subgroups, this.namespace, this.id);
        };
        d3_transitionPrototype.tween = function(name, tween) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
          return d3_selection_each(this, tween == null ? function(node) {
            node[ns][id].tween.remove(name);
          } : function(node) {
            node[ns][id].tween.set(name, tween);
          });
        };
        function d3_transition_tween(groups, name, value, tween) {
          var id = groups.id, ns = groups.namespace;
          return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
          } : (value = tween(value), function(node) {
            node[ns][id].tween.set(name, value);
          }));
        }
        d3_transitionPrototype.attr = function(nameNS, value) {
          if (arguments.length < 2) {
            for (value in nameNS) this.attr(value, nameNS[value]);
            return this;
          }
          var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
          function attrNull() {
            this.removeAttribute(name);
          }
          function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
          }
          function attrTween(b) {
            return b == null ? attrNull : (b += "", function() {
              var a = this.getAttribute(name), i;
              return a !== b && (i = interpolate(a, b), function(t) {
                this.setAttribute(name, i(t));
              });
            });
          }
          function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += "", function() {
              var a = this.getAttributeNS(name.space, name.local), i;
              return a !== b && (i = interpolate(a, b), function(t) {
                this.setAttributeNS(name.space, name.local, i(t));
              });
            });
          }
          return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
        };
        d3_transitionPrototype.attrTween = function(nameNS, tween) {
          var name = d3.ns.qualify(nameNS);
          function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function(t) {
              this.setAttribute(name, f(t));
            };
          }
          function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function(t) {
              this.setAttributeNS(name.space, name.local, f(t));
            };
          }
          return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
        };
        d3_transitionPrototype.style = function(name, value, priority) {
          var n = arguments.length;
          if (n < 3) {
            if (typeof name !== "string") {
              if (n < 2) value = "";
              for (priority in name) this.style(priority, name[priority], value);
              return this;
            }
            priority = "";
          }
          function styleNull() {
            this.style.removeProperty(name);
          }
          function styleString(b) {
            return b == null ? styleNull : (b += "", function() {
              var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
              return a !== b && (i = d3_interpolate(a, b), function(t) {
                this.style.setProperty(name, i(t), priority);
              });
            });
          }
          return d3_transition_tween(this, "style." + name, value, styleString);
        };
        d3_transitionPrototype.styleTween = function(name, tween, priority) {
          if (arguments.length < 3) priority = "";
          function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function(t) {
              this.style.setProperty(name, f(t), priority);
            };
          }
          return this.tween("style." + name, styleTween);
        };
        d3_transitionPrototype.text = function(value) {
          return d3_transition_tween(this, "text", value, d3_transition_text);
        };
        function d3_transition_text(b) {
          if (b == null) b = "";
          return function() {
            this.textContent = b;
          };
        }
        d3_transitionPrototype.remove = function() {
          var ns = this.namespace;
          return this.each("end.transition", function() {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
          });
        };
        d3_transitionPrototype.ease = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].ease;
          if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
          return d3_selection_each(this, function(node) {
            node[ns][id].ease = value;
          });
        };
        d3_transitionPrototype.delay = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].delay;
          return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
          } : (value = +value, function(node) {
            node[ns][id].delay = value;
          }));
        };
        d3_transitionPrototype.duration = function(value) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 1) return this.node()[ns][id].duration;
          return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
          } : (value = Math.max(1, value), function(node) {
            node[ns][id].duration = value;
          }));
        };
        d3_transitionPrototype.each = function(type, listener) {
          var id = this.id, ns = this.namespace;
          if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
              d3_transitionInheritId = id;
              d3_selection_each(this, function(node, i, j) {
                d3_transitionInherit = node[ns][id];
                type.call(node, node.__data__, i, j);
              });
            } finally {
              d3_transitionInherit = inherit;
              d3_transitionInheritId = inheritId;
            }
          } else {
            d3_selection_each(this, function(node) {
              var transition = node[ns][id];
              (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
            });
          }
          return this;
        };
        d3_transitionPrototype.transition = function() {
          var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
          for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
              if (node = group[i]) {
                transition = node[ns][id0];
                d3_transitionNode(node, i, ns, id1, {
                  time: transition.time,
                  ease: transition.ease,
                  delay: transition.delay + transition.duration,
                  duration: transition.duration
                });
              }
              subgroup.push(node);
            }
          }
          return d3_transition(subgroups, ns, id1);
        };
        function d3_transitionNamespace(name) {
          return name == null ? "__transition__" : "__transition_" + name + "__";
        }
        function d3_transitionNode(node, i, ns, id, inherit) {
          var lock = node[ns] || (node[ns] = {
            active: 0,
            count: 0
          }), transition = lock[id], time, timer, duration, ease, tweens;
          function schedule(elapsed) {
            var delay = transition.delay;
            timer.t = delay + time;
            if (delay <= elapsed) return start(elapsed - delay);
            timer.c = start;
          }
          function start(elapsed) {
            var activeId = lock.active, active = lock[activeId];
            if (active) {
              active.timer.c = null;
              active.timer.t = NaN;
              --lock.count;
              delete lock[activeId];
              active.event && active.event.interrupt.call(node, node.__data__, active.index);
            }
            for (var cancelId in lock) {
              if (+cancelId < id) {
                var cancel = lock[cancelId];
                cancel.timer.c = null;
                cancel.timer.t = NaN;
                --lock.count;
                delete lock[cancelId];
              }
            }
            timer.c = tick;
            d3_timer(function() {
              if (timer.c && tick(elapsed || 1)) {
                timer.c = null;
                timer.t = NaN;
              }
              return 1;
            }, 0, time);
            lock.active = id;
            transition.event && transition.event.start.call(node, node.__data__, i);
            tweens = [];
            transition.tween.forEach(function(key, value) {
              if (value = value.call(node, node.__data__, i)) {
                tweens.push(value);
              }
            });
            ease = transition.ease;
            duration = transition.duration;
          }
          function tick(elapsed) {
            var t = elapsed / duration, e = ease(t), n = tweens.length;
            while (n > 0) {
              tweens[--n].call(node, e);
            }
            if (t >= 1) {
              transition.event && transition.event.end.call(node, node.__data__, i);
              if (--lock.count) delete lock[id];
              else delete node[ns];
              return 1;
            }
          }
          if (!transition) {
            time = inherit.time;
            timer = d3_timer(schedule, 0, time);
            transition = lock[id] = {
              tween: new d3_Map(),
              time,
              timer,
              delay: inherit.delay,
              duration: inherit.duration,
              ease: inherit.ease,
              index: i
            };
            inherit = null;
            ++lock.count;
          }
        }
        d3.svg.axis = function() {
          var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [10], tickValues = null, tickFormat_;
          function axis(g) {
            g.each(function() {
              var g2 = d3.select(this);
              var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
              var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g2.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", \u03B5), tickExit = d3.transition(tick.exit()).style("opacity", \u03B5).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
              var range = d3_scaleRange(scale1), path = g2.selectAll(".domain").data([0]), pathUpdate = (path.enter().append("path").attr("class", "domain"), d3.transition(path));
              tickEnter.append("line");
              tickEnter.append("text");
              var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
              if (orient === "bottom" || orient === "top") {
                tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
                text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
              } else {
                tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
                text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
                pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
              }
              lineEnter.attr(y2, sign * innerTickSize);
              textEnter.attr(y1, sign * tickSpacing);
              lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
              textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
              if (scale1.rangeBand) {
                var x = scale1, dx = x.rangeBand() / 2;
                scale0 = scale1 = function(d) {
                  return x(d) + dx;
                };
              } else if (scale0.rangeBand) {
                scale0 = scale1;
              } else {
                tickExit.call(tickTransform, scale1, scale0);
              }
              tickEnter.call(tickTransform, scale0, scale1);
              tickUpdate.call(tickTransform, scale1, scale1);
            });
          }
          axis.scale = function(x) {
            if (!arguments.length) return scale;
            scale = x;
            return axis;
          };
          axis.orient = function(x) {
            if (!arguments.length) return orient;
            orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
            return axis;
          };
          axis.ticks = function() {
            if (!arguments.length) return tickArguments_;
            tickArguments_ = d3_array(arguments);
            return axis;
          };
          axis.tickValues = function(x) {
            if (!arguments.length) return tickValues;
            tickValues = x;
            return axis;
          };
          axis.tickFormat = function(x) {
            if (!arguments.length) return tickFormat_;
            tickFormat_ = x;
            return axis;
          };
          axis.tickSize = function(x) {
            var n = arguments.length;
            if (!n) return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
          };
          axis.innerTickSize = function(x) {
            if (!arguments.length) return innerTickSize;
            innerTickSize = +x;
            return axis;
          };
          axis.outerTickSize = function(x) {
            if (!arguments.length) return outerTickSize;
            outerTickSize = +x;
            return axis;
          };
          axis.tickPadding = function(x) {
            if (!arguments.length) return tickPadding;
            tickPadding = +x;
            return axis;
          };
          axis.tickSubdivide = function() {
            return arguments.length && axis;
          };
          return axis;
        };
        var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
          top: 1,
          right: 1,
          bottom: 1,
          left: 1
        };
        function d3_svg_axisX(selection, x0, x1) {
          selection.attr("transform", function(d) {
            var v0 = x0(d);
            return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
          });
        }
        function d3_svg_axisY(selection, y0, y1) {
          selection.attr("transform", function(d) {
            var v0 = y0(d);
            return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
          });
        }
        d3.svg.brush = function() {
          var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [0, 0], yExtent = [0, 0], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
          function brush(g) {
            g.each(function() {
              var g2 = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
              var background = g2.selectAll(".background").data([0]);
              background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
              g2.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
              var resize = g2.selectAll(".resize").data(resizes, d3_identity);
              resize.exit().remove();
              resize.enter().append("g").attr("class", function(d) {
                return "resize " + d;
              }).style("cursor", function(d) {
                return d3_svg_brushCursor[d];
              }).append("rect").attr("x", function(d) {
                return /[ew]$/.test(d) ? -3 : null;
              }).attr("y", function(d) {
                return /^[ns]/.test(d) ? -3 : null;
              }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
              resize.style("display", brush.empty() ? "none" : null);
              var gUpdate = d3.transition(g2), backgroundUpdate = d3.transition(background), range;
              if (x) {
                range = d3_scaleRange(x);
                backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                redrawX(gUpdate);
              }
              if (y) {
                range = d3_scaleRange(y);
                backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                redrawY(gUpdate);
              }
              redraw(gUpdate);
            });
          }
          brush.event = function(g) {
            g.each(function() {
              var event_ = event.of(this, arguments), extent1 = {
                x: xExtent,
                y: yExtent,
                i: xExtentDomain,
                j: yExtentDomain
              }, extent0 = this.__chart__ || extent1;
              this.__chart__ = extent1;
              if (d3_transitionInheritId) {
                d3.select(this).transition().each("start.brush", function() {
                  xExtentDomain = extent0.i;
                  yExtentDomain = extent0.j;
                  xExtent = extent0.x;
                  yExtent = extent0.y;
                  event_({
                    type: "brushstart"
                  });
                }).tween("brush:brush", function() {
                  var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                  xExtentDomain = yExtentDomain = null;
                  return function(t) {
                    xExtent = extent1.x = xi(t);
                    yExtent = extent1.y = yi(t);
                    event_({
                      type: "brush",
                      mode: "resize"
                    });
                  };
                }).each("end.brush", function() {
                  xExtentDomain = extent1.i;
                  yExtentDomain = extent1.j;
                  event_({
                    type: "brush",
                    mode: "resize"
                  });
                  event_({
                    type: "brushend"
                  });
                });
              } else {
                event_({
                  type: "brushstart"
                });
                event_({
                  type: "brush",
                  mode: "resize"
                });
                event_({
                  type: "brushend"
                });
              }
            });
          };
          function redraw(g) {
            g.selectAll(".resize").attr("transform", function(d) {
              return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
            });
          }
          function redrawX(g) {
            g.select(".extent").attr("x", xExtent[0]);
            g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
          }
          function redrawY(g) {
            g.select(".extent").attr("y", yExtent[0]);
            g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
          }
          function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d3.event.changedTouches) {
              w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
            } else {
              w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
            }
            g.interrupt().selectAll("*").interrupt();
            if (dragging) {
              origin[0] = xExtent[0] - origin[0];
              origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
              var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
              offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
              origin[0] = xExtent[ex];
              origin[1] = yExtent[ey];
            } else if (d3.event.altKey) center = origin.slice();
            g.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d3.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
              type: "brushstart"
            });
            brushmove();
            function keydown() {
              if (d3.event.keyCode == 32) {
                if (!dragging) {
                  center = null;
                  origin[0] -= xExtent[1];
                  origin[1] -= yExtent[1];
                  dragging = 2;
                }
                d3_eventPreventDefault();
              }
            }
            function keyup() {
              if (d3.event.keyCode == 32 && dragging == 2) {
                origin[0] += xExtent[1];
                origin[1] += yExtent[1];
                dragging = 0;
                d3_eventPreventDefault();
              }
            }
            function brushmove() {
              var point = d3.mouse(target), moved = false;
              if (offset) {
                point[0] += offset[0];
                point[1] += offset[1];
              }
              if (!dragging) {
                if (d3.event.altKey) {
                  if (!center) center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                  origin[0] = xExtent[+(point[0] < center[0])];
                  origin[1] = yExtent[+(point[1] < center[1])];
                } else center = null;
              }
              if (resizingX && move1(point, x, 0)) {
                redrawX(g);
                moved = true;
              }
              if (resizingY && move1(point, y, 1)) {
                redrawY(g);
                moved = true;
              }
              if (moved) {
                redraw(g);
                event_({
                  type: "brush",
                  mode: dragging ? "move" : "resize"
                });
              }
            }
            function move1(point, scale, i) {
              var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
              if (dragging) {
                r0 -= position;
                r1 -= size + position;
              }
              min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
              if (dragging) {
                max = (min += position) + size;
              } else {
                if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                if (position < min) {
                  max = min;
                  min = position;
                } else {
                  max = position;
                }
              }
              if (extent[0] != min || extent[1] != max) {
                if (i) yExtentDomain = null;
                else xExtentDomain = null;
                extent[0] = min;
                extent[1] = max;
                return true;
              }
            }
            function brushend() {
              brushmove();
              g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
              d3.select("body").style("cursor", null);
              w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
              dragRestore();
              event_({
                type: "brushend"
              });
            }
          }
          brush.x = function(z) {
            if (!arguments.length) return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
          };
          brush.y = function(z) {
            if (!arguments.length) return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
          };
          brush.clamp = function(z) {
            if (!arguments.length) return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
            if (x && y) xClamp = !!z[0], yClamp = !!z[1];
            else if (x) xClamp = !!z;
            else if (y) yClamp = !!z;
            return brush;
          };
          brush.extent = function(z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
              if (x) {
                if (xExtentDomain) {
                  x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                } else {
                  x0 = xExtent[0], x1 = xExtent[1];
                  if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                  if (x1 < x0) t = x0, x0 = x1, x1 = t;
                }
              }
              if (y) {
                if (yExtentDomain) {
                  y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                } else {
                  y0 = yExtent[0], y1 = yExtent[1];
                  if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                  if (y1 < y0) t = y0, y0 = y1, y1 = t;
                }
              }
              return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
            }
            if (x) {
              x0 = z[0], x1 = z[1];
              if (y) x0 = x0[0], x1 = x1[0];
              xExtentDomain = [x0, x1];
              if (x.invert) x0 = x(x0), x1 = x(x1);
              if (x1 < x0) t = x0, x0 = x1, x1 = t;
              if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [x0, x1];
            }
            if (y) {
              y0 = z[0], y1 = z[1];
              if (x) y0 = y0[1], y1 = y1[1];
              yExtentDomain = [y0, y1];
              if (y.invert) y0 = y(y0), y1 = y(y1);
              if (y1 < y0) t = y0, y0 = y1, y1 = t;
              if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [y0, y1];
            }
            return brush;
          };
          brush.clear = function() {
            if (!brush.empty()) {
              xExtent = [0, 0], yExtent = [0, 0];
              xExtentDomain = yExtentDomain = null;
            }
            return brush;
          };
          brush.empty = function() {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
          };
          return d3.rebind(brush, event, "on");
        };
        var d3_svg_brushCursor = {
          n: "ns-resize",
          e: "ew-resize",
          s: "ns-resize",
          w: "ew-resize",
          nw: "nwse-resize",
          ne: "nesw-resize",
          se: "nwse-resize",
          sw: "nesw-resize"
        };
        var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
        d3.text = d3_xhrType(function(request) {
          return request.responseText;
        });
        d3.json = function(url, callback) {
          return d3_xhr(url, "application/json", d3_json, callback);
        };
        function d3_json(request) {
          return JSON.parse(request.responseText);
        }
        d3.html = function(url, callback) {
          return d3_xhr(url, "text/html", d3_html, callback);
        };
        function d3_html(request) {
          var range = d3_document.createRange();
          range.selectNode(d3_document.body);
          return range.createContextualFragment(request.responseText);
        }
        d3.xml = d3_xhrType(function(request) {
          return request.responseXML;
        });
        if (typeof define === "function" && false) define(d3);
        else if (typeof module === "object" && module.exports) module.exports = d3;
        else this.d3 = d3;
      }.apply(self);
    }
  });

  // node_modules/d3-time/dist/d3-time.js
  var require_d3_time = __commonJS({
    "node_modules/d3-time/dist/d3-time.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        var t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
        function newInterval(floori, offseti, count, field) {
          function interval(date) {
            return floori(date = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date)), date;
          }
          interval.floor = function(date) {
            return floori(date = /* @__PURE__ */ new Date(+date)), date;
          };
          interval.ceil = function(date) {
            return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
          };
          interval.round = function(date) {
            var d0 = interval(date), d1 = interval.ceil(date);
            return date - d0 < d1 - date ? d0 : d1;
          };
          interval.offset = function(date, step) {
            return offseti(date = /* @__PURE__ */ new Date(+date), step == null ? 1 : Math.floor(step)), date;
          };
          interval.range = function(start, stop, step) {
            var range = [], previous;
            start = interval.ceil(start);
            step = step == null ? 1 : Math.floor(step);
            if (!(start < stop) || !(step > 0)) return range;
            do
              range.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
            while (previous < start && start < stop);
            return range;
          };
          interval.filter = function(test) {
            return newInterval(function(date) {
              if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
            }, function(date, step) {
              if (date >= date) {
                if (step < 0) while (++step <= 0) {
                  while (offseti(date, -1), !test(date)) {
                  }
                }
                else while (--step >= 0) {
                  while (offseti(date, 1), !test(date)) {
                  }
                }
              }
            });
          };
          if (count) {
            interval.count = function(start, end) {
              t0.setTime(+start), t1.setTime(+end);
              floori(t0), floori(t1);
              return Math.floor(count(t0, t1));
            };
            interval.every = function(step) {
              step = Math.floor(step);
              return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function(d) {
                return field(d) % step === 0;
              } : function(d) {
                return interval.count(0, d) % step === 0;
              });
            };
          }
          return interval;
        }
        var millisecond = newInterval(function() {
        }, function(date, step) {
          date.setTime(+date + step);
        }, function(start, end) {
          return end - start;
        });
        millisecond.every = function(k) {
          k = Math.floor(k);
          if (!isFinite(k) || !(k > 0)) return null;
          if (!(k > 1)) return millisecond;
          return newInterval(function(date) {
            date.setTime(Math.floor(date / k) * k);
          }, function(date, step) {
            date.setTime(+date + step * k);
          }, function(start, end) {
            return (end - start) / k;
          });
        };
        var milliseconds = millisecond.range;
        var durationSecond = 1e3;
        var durationMinute = 6e4;
        var durationHour = 36e5;
        var durationDay = 864e5;
        var durationWeek = 6048e5;
        var second = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds());
        }, function(date, step) {
          date.setTime(+date + step * durationSecond);
        }, function(start, end) {
          return (end - start) / durationSecond;
        }, function(date) {
          return date.getUTCSeconds();
        });
        var seconds = second.range;
        var minute = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
        }, function(date, step) {
          date.setTime(+date + step * durationMinute);
        }, function(start, end) {
          return (end - start) / durationMinute;
        }, function(date) {
          return date.getMinutes();
        });
        var minutes = minute.range;
        var hour = newInterval(function(date) {
          date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
        }, function(date, step) {
          date.setTime(+date + step * durationHour);
        }, function(start, end) {
          return (end - start) / durationHour;
        }, function(date) {
          return date.getHours();
        });
        var hours = hour.range;
        var day = newInterval(function(date) {
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setDate(date.getDate() + step);
        }, function(start, end) {
          return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
        }, function(date) {
          return date.getDate() - 1;
        });
        var days = day.range;
        function weekday(i) {
          return newInterval(function(date) {
            date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
            date.setHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setDate(date.getDate() + step * 7);
          }, function(start, end) {
            return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
          });
        }
        var sunday = weekday(0);
        var monday = weekday(1);
        var tuesday = weekday(2);
        var wednesday = weekday(3);
        var thursday = weekday(4);
        var friday = weekday(5);
        var saturday = weekday(6);
        var sundays = sunday.range;
        var mondays = monday.range;
        var tuesdays = tuesday.range;
        var wednesdays = wednesday.range;
        var thursdays = thursday.range;
        var fridays = friday.range;
        var saturdays = saturday.range;
        var month = newInterval(function(date) {
          date.setDate(1);
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setMonth(date.getMonth() + step);
        }, function(start, end) {
          return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
        }, function(date) {
          return date.getMonth();
        });
        var months = month.range;
        var year = newInterval(function(date) {
          date.setMonth(0, 1);
          date.setHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setFullYear(date.getFullYear() + step);
        }, function(start, end) {
          return end.getFullYear() - start.getFullYear();
        }, function(date) {
          return date.getFullYear();
        });
        year.every = function(k) {
          return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
            date.setFullYear(Math.floor(date.getFullYear() / k) * k);
            date.setMonth(0, 1);
            date.setHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setFullYear(date.getFullYear() + step * k);
          });
        };
        var years = year.range;
        var utcMinute = newInterval(function(date) {
          date.setUTCSeconds(0, 0);
        }, function(date, step) {
          date.setTime(+date + step * durationMinute);
        }, function(start, end) {
          return (end - start) / durationMinute;
        }, function(date) {
          return date.getUTCMinutes();
        });
        var utcMinutes = utcMinute.range;
        var utcHour = newInterval(function(date) {
          date.setUTCMinutes(0, 0, 0);
        }, function(date, step) {
          date.setTime(+date + step * durationHour);
        }, function(start, end) {
          return (end - start) / durationHour;
        }, function(date) {
          return date.getUTCHours();
        });
        var utcHours = utcHour.range;
        var utcDay = newInterval(function(date) {
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCDate(date.getUTCDate() + step);
        }, function(start, end) {
          return (end - start) / durationDay;
        }, function(date) {
          return date.getUTCDate() - 1;
        });
        var utcDays = utcDay.range;
        function utcWeekday(i) {
          return newInterval(function(date) {
            date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
            date.setUTCHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setUTCDate(date.getUTCDate() + step * 7);
          }, function(start, end) {
            return (end - start) / durationWeek;
          });
        }
        var utcSunday = utcWeekday(0);
        var utcMonday = utcWeekday(1);
        var utcTuesday = utcWeekday(2);
        var utcWednesday = utcWeekday(3);
        var utcThursday = utcWeekday(4);
        var utcFriday = utcWeekday(5);
        var utcSaturday = utcWeekday(6);
        var utcSundays = utcSunday.range;
        var utcMondays = utcMonday.range;
        var utcTuesdays = utcTuesday.range;
        var utcWednesdays = utcWednesday.range;
        var utcThursdays = utcThursday.range;
        var utcFridays = utcFriday.range;
        var utcSaturdays = utcSaturday.range;
        var utcMonth = newInterval(function(date) {
          date.setUTCDate(1);
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCMonth(date.getUTCMonth() + step);
        }, function(start, end) {
          return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
        }, function(date) {
          return date.getUTCMonth();
        });
        var utcMonths = utcMonth.range;
        var utcYear = newInterval(function(date) {
          date.setUTCMonth(0, 1);
          date.setUTCHours(0, 0, 0, 0);
        }, function(date, step) {
          date.setUTCFullYear(date.getUTCFullYear() + step);
        }, function(start, end) {
          return end.getUTCFullYear() - start.getUTCFullYear();
        }, function(date) {
          return date.getUTCFullYear();
        });
        utcYear.every = function(k) {
          return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
            date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
            date.setUTCMonth(0, 1);
            date.setUTCHours(0, 0, 0, 0);
          }, function(date, step) {
            date.setUTCFullYear(date.getUTCFullYear() + step * k);
          });
        };
        var utcYears = utcYear.range;
        exports2.timeDay = day;
        exports2.timeDays = days;
        exports2.timeFriday = friday;
        exports2.timeFridays = fridays;
        exports2.timeHour = hour;
        exports2.timeHours = hours;
        exports2.timeInterval = newInterval;
        exports2.timeMillisecond = millisecond;
        exports2.timeMilliseconds = milliseconds;
        exports2.timeMinute = minute;
        exports2.timeMinutes = minutes;
        exports2.timeMonday = monday;
        exports2.timeMondays = mondays;
        exports2.timeMonth = month;
        exports2.timeMonths = months;
        exports2.timeSaturday = saturday;
        exports2.timeSaturdays = saturdays;
        exports2.timeSecond = second;
        exports2.timeSeconds = seconds;
        exports2.timeSunday = sunday;
        exports2.timeSundays = sundays;
        exports2.timeThursday = thursday;
        exports2.timeThursdays = thursdays;
        exports2.timeTuesday = tuesday;
        exports2.timeTuesdays = tuesdays;
        exports2.timeWednesday = wednesday;
        exports2.timeWednesdays = wednesdays;
        exports2.timeWeek = sunday;
        exports2.timeWeeks = sundays;
        exports2.timeYear = year;
        exports2.timeYears = years;
        exports2.utcDay = utcDay;
        exports2.utcDays = utcDays;
        exports2.utcFriday = utcFriday;
        exports2.utcFridays = utcFridays;
        exports2.utcHour = utcHour;
        exports2.utcHours = utcHours;
        exports2.utcMillisecond = millisecond;
        exports2.utcMilliseconds = milliseconds;
        exports2.utcMinute = utcMinute;
        exports2.utcMinutes = utcMinutes;
        exports2.utcMonday = utcMonday;
        exports2.utcMondays = utcMondays;
        exports2.utcMonth = utcMonth;
        exports2.utcMonths = utcMonths;
        exports2.utcSaturday = utcSaturday;
        exports2.utcSaturdays = utcSaturdays;
        exports2.utcSecond = second;
        exports2.utcSeconds = seconds;
        exports2.utcSunday = utcSunday;
        exports2.utcSundays = utcSundays;
        exports2.utcThursday = utcThursday;
        exports2.utcThursdays = utcThursdays;
        exports2.utcTuesday = utcTuesday;
        exports2.utcTuesdays = utcTuesdays;
        exports2.utcWednesday = utcWednesday;
        exports2.utcWednesdays = utcWednesdays;
        exports2.utcWeek = utcSunday;
        exports2.utcWeeks = utcSundays;
        exports2.utcYear = utcYear;
        exports2.utcYears = utcYears;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/d3-time-format/dist/d3-time-format.js
  var require_d3_time_format = __commonJS({
    "node_modules/d3-time-format/dist/d3-time-format.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_d3_time()) : typeof define === "function" && false ? define(["exports", "d3-time"], factory) : (global2 = global2 || self, factory(global2.d3 = global2.d3 || {}, global2.d3));
      })(exports, function(exports2, d3Time) {
        "use strict";
        function localDate(d) {
          if (0 <= d.y && d.y < 100) {
            var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
            date.setFullYear(d.y);
            return date;
          }
          return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
        }
        function utcDate(d) {
          if (0 <= d.y && d.y < 100) {
            var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
            date.setUTCFullYear(d.y);
            return date;
          }
          return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
        }
        function newDate(y, m, d) {
          return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
        }
        function formatLocale(locale2) {
          var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
          var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
          var formats = {
            "a": formatShortWeekday,
            "A": formatWeekday,
            "b": formatShortMonth,
            "B": formatMonth,
            "c": null,
            "d": formatDayOfMonth,
            "e": formatDayOfMonth,
            "f": formatMicroseconds,
            "H": formatHour24,
            "I": formatHour12,
            "j": formatDayOfYear,
            "L": formatMilliseconds,
            "m": formatMonthNumber,
            "M": formatMinutes,
            "p": formatPeriod,
            "q": formatQuarter,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatSeconds,
            "u": formatWeekdayNumberMonday,
            "U": formatWeekNumberSunday,
            "V": formatWeekNumberISO,
            "w": formatWeekdayNumberSunday,
            "W": formatWeekNumberMonday,
            "x": null,
            "X": null,
            "y": formatYear,
            "Y": formatFullYear,
            "Z": formatZone,
            "%": formatLiteralPercent
          };
          var utcFormats = {
            "a": formatUTCShortWeekday,
            "A": formatUTCWeekday,
            "b": formatUTCShortMonth,
            "B": formatUTCMonth,
            "c": null,
            "d": formatUTCDayOfMonth,
            "e": formatUTCDayOfMonth,
            "f": formatUTCMicroseconds,
            "H": formatUTCHour24,
            "I": formatUTCHour12,
            "j": formatUTCDayOfYear,
            "L": formatUTCMilliseconds,
            "m": formatUTCMonthNumber,
            "M": formatUTCMinutes,
            "p": formatUTCPeriod,
            "q": formatUTCQuarter,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatUTCSeconds,
            "u": formatUTCWeekdayNumberMonday,
            "U": formatUTCWeekNumberSunday,
            "V": formatUTCWeekNumberISO,
            "w": formatUTCWeekdayNumberSunday,
            "W": formatUTCWeekNumberMonday,
            "x": null,
            "X": null,
            "y": formatUTCYear,
            "Y": formatUTCFullYear,
            "Z": formatUTCZone,
            "%": formatLiteralPercent
          };
          var parses = {
            "a": parseShortWeekday,
            "A": parseWeekday,
            "b": parseShortMonth,
            "B": parseMonth,
            "c": parseLocaleDateTime,
            "d": parseDayOfMonth,
            "e": parseDayOfMonth,
            "f": parseMicroseconds,
            "H": parseHour24,
            "I": parseHour24,
            "j": parseDayOfYear,
            "L": parseMilliseconds,
            "m": parseMonthNumber,
            "M": parseMinutes,
            "p": parsePeriod,
            "q": parseQuarter,
            "Q": parseUnixTimestamp,
            "s": parseUnixTimestampSeconds,
            "S": parseSeconds,
            "u": parseWeekdayNumberMonday,
            "U": parseWeekNumberSunday,
            "V": parseWeekNumberISO,
            "w": parseWeekdayNumberSunday,
            "W": parseWeekNumberMonday,
            "x": parseLocaleDate,
            "X": parseLocaleTime,
            "y": parseYear,
            "Y": parseFullYear,
            "Z": parseZone,
            "%": parseLiteralPercent
          };
          formats.x = newFormat(locale_date, formats);
          formats.X = newFormat(locale_time, formats);
          formats.c = newFormat(locale_dateTime, formats);
          utcFormats.x = newFormat(locale_date, utcFormats);
          utcFormats.X = newFormat(locale_time, utcFormats);
          utcFormats.c = newFormat(locale_dateTime, utcFormats);
          function newFormat(specifier, formats2) {
            return function(date) {
              var string = [], i = -1, j = 0, n = specifier.length, c, pad2, format;
              if (!(date instanceof Date)) date = /* @__PURE__ */ new Date(+date);
              while (++i < n) {
                if (specifier.charCodeAt(i) === 37) {
                  string.push(specifier.slice(j, i));
                  if ((pad2 = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
                  else pad2 = c === "e" ? " " : "0";
                  if (format = formats2[c]) c = format(date, pad2);
                  string.push(c);
                  j = i + 1;
                }
              }
              string.push(specifier.slice(j, i));
              return string.join("");
            };
          }
          function newParse(specifier, Z) {
            return function(string) {
              var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
              if (i != string.length) return null;
              if ("Q" in d) return new Date(d.Q);
              if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
              if (Z && !("Z" in d)) d.Z = 0;
              if ("p" in d) d.H = d.H % 12 + d.p * 12;
              if (d.m === void 0) d.m = "q" in d ? d.q : 0;
              if ("V" in d) {
                if (d.V < 1 || d.V > 53) return null;
                if (!("w" in d)) d.w = 1;
                if ("Z" in d) {
                  week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
                  week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
                  week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
                  d.y = week.getUTCFullYear();
                  d.m = week.getUTCMonth();
                  d.d = week.getUTCDate() + (d.w + 6) % 7;
                } else {
                  week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
                  week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
                  week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
                  d.y = week.getFullYear();
                  d.m = week.getMonth();
                  d.d = week.getDate() + (d.w + 6) % 7;
                }
              } else if ("W" in d || "U" in d) {
                if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
                day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
                d.m = 0;
                d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
              }
              if ("Z" in d) {
                d.H += d.Z / 100 | 0;
                d.M += d.Z % 100;
                return utcDate(d);
              }
              return localDate(d);
            };
          }
          function parseSpecifier(d, specifier, string, j) {
            var i = 0, n = specifier.length, m = string.length, c, parse2;
            while (i < n) {
              if (j >= m) return -1;
              c = specifier.charCodeAt(i++);
              if (c === 37) {
                c = specifier.charAt(i++);
                parse2 = parses[c in pads ? specifier.charAt(i++) : c];
                if (!parse2 || (j = parse2(d, string, j)) < 0) return -1;
              } else if (c != string.charCodeAt(j++)) {
                return -1;
              }
            }
            return j;
          }
          function parsePeriod(d, string, i) {
            var n = periodRe.exec(string.slice(i));
            return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseShortWeekday(d, string, i) {
            var n = shortWeekdayRe.exec(string.slice(i));
            return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseWeekday(d, string, i) {
            var n = weekdayRe.exec(string.slice(i));
            return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseShortMonth(d, string, i) {
            var n = shortMonthRe.exec(string.slice(i));
            return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseMonth(d, string, i) {
            var n = monthRe.exec(string.slice(i));
            return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
          }
          function parseLocaleDateTime(d, string, i) {
            return parseSpecifier(d, locale_dateTime, string, i);
          }
          function parseLocaleDate(d, string, i) {
            return parseSpecifier(d, locale_date, string, i);
          }
          function parseLocaleTime(d, string, i) {
            return parseSpecifier(d, locale_time, string, i);
          }
          function formatShortWeekday(d) {
            return locale_shortWeekdays[d.getDay()];
          }
          function formatWeekday(d) {
            return locale_weekdays[d.getDay()];
          }
          function formatShortMonth(d) {
            return locale_shortMonths[d.getMonth()];
          }
          function formatMonth(d) {
            return locale_months[d.getMonth()];
          }
          function formatPeriod(d) {
            return locale_periods[+(d.getHours() >= 12)];
          }
          function formatQuarter(d) {
            return 1 + ~~(d.getMonth() / 3);
          }
          function formatUTCShortWeekday(d) {
            return locale_shortWeekdays[d.getUTCDay()];
          }
          function formatUTCWeekday(d) {
            return locale_weekdays[d.getUTCDay()];
          }
          function formatUTCShortMonth(d) {
            return locale_shortMonths[d.getUTCMonth()];
          }
          function formatUTCMonth(d) {
            return locale_months[d.getUTCMonth()];
          }
          function formatUTCPeriod(d) {
            return locale_periods[+(d.getUTCHours() >= 12)];
          }
          function formatUTCQuarter(d) {
            return 1 + ~~(d.getUTCMonth() / 3);
          }
          return {
            format: function(specifier) {
              var f = newFormat(specifier += "", formats);
              f.toString = function() {
                return specifier;
              };
              return f;
            },
            parse: function(specifier) {
              var p = newParse(specifier += "", false);
              p.toString = function() {
                return specifier;
              };
              return p;
            },
            utcFormat: function(specifier) {
              var f = newFormat(specifier += "", utcFormats);
              f.toString = function() {
                return specifier;
              };
              return f;
            },
            utcParse: function(specifier) {
              var p = newParse(specifier += "", true);
              p.toString = function() {
                return specifier;
              };
              return p;
            }
          };
        }
        var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
        function pad(value, fill, width) {
          var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
          return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
        }
        function requote(s) {
          return s.replace(requoteRe, "\\$&");
        }
        function formatRe(names2) {
          return new RegExp("^(?:" + names2.map(requote).join("|") + ")", "i");
        }
        function formatLookup(names2) {
          var map = {}, i = -1, n = names2.length;
          while (++i < n) map[names2[i].toLowerCase()] = i;
          return map;
        }
        function parseWeekdayNumberSunday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.w = +n[0], i + n[0].length) : -1;
        }
        function parseWeekdayNumberMonday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.u = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberSunday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.U = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberISO(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.V = +n[0], i + n[0].length) : -1;
        }
        function parseWeekNumberMonday(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.W = +n[0], i + n[0].length) : -1;
        }
        function parseFullYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 4));
          return n ? (d.y = +n[0], i + n[0].length) : -1;
        }
        function parseYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
        }
        function parseZone(d, string, i) {
          var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
          return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
        }
        function parseQuarter(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 1));
          return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
        }
        function parseMonthNumber(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
        }
        function parseDayOfMonth(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.d = +n[0], i + n[0].length) : -1;
        }
        function parseDayOfYear(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 3));
          return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
        }
        function parseHour24(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.H = +n[0], i + n[0].length) : -1;
        }
        function parseMinutes(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.M = +n[0], i + n[0].length) : -1;
        }
        function parseSeconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 2));
          return n ? (d.S = +n[0], i + n[0].length) : -1;
        }
        function parseMilliseconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 3));
          return n ? (d.L = +n[0], i + n[0].length) : -1;
        }
        function parseMicroseconds(d, string, i) {
          var n = numberRe.exec(string.slice(i, i + 6));
          return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
        }
        function parseLiteralPercent(d, string, i) {
          var n = percentRe.exec(string.slice(i, i + 1));
          return n ? i + n[0].length : -1;
        }
        function parseUnixTimestamp(d, string, i) {
          var n = numberRe.exec(string.slice(i));
          return n ? (d.Q = +n[0], i + n[0].length) : -1;
        }
        function parseUnixTimestampSeconds(d, string, i) {
          var n = numberRe.exec(string.slice(i));
          return n ? (d.s = +n[0], i + n[0].length) : -1;
        }
        function formatDayOfMonth(d, p) {
          return pad(d.getDate(), p, 2);
        }
        function formatHour24(d, p) {
          return pad(d.getHours(), p, 2);
        }
        function formatHour12(d, p) {
          return pad(d.getHours() % 12 || 12, p, 2);
        }
        function formatDayOfYear(d, p) {
          return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
        }
        function formatMilliseconds(d, p) {
          return pad(d.getMilliseconds(), p, 3);
        }
        function formatMicroseconds(d, p) {
          return formatMilliseconds(d, p) + "000";
        }
        function formatMonthNumber(d, p) {
          return pad(d.getMonth() + 1, p, 2);
        }
        function formatMinutes(d, p) {
          return pad(d.getMinutes(), p, 2);
        }
        function formatSeconds(d, p) {
          return pad(d.getSeconds(), p, 2);
        }
        function formatWeekdayNumberMonday(d) {
          var day = d.getDay();
          return day === 0 ? 7 : day;
        }
        function formatWeekNumberSunday(d, p) {
          return pad(d3Time.timeSunday.count(d3Time.timeYear(d) - 1, d), p, 2);
        }
        function formatWeekNumberISO(d, p) {
          var day = d.getDay();
          d = day >= 4 || day === 0 ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
          return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
        }
        function formatWeekdayNumberSunday(d) {
          return d.getDay();
        }
        function formatWeekNumberMonday(d, p) {
          return pad(d3Time.timeMonday.count(d3Time.timeYear(d) - 1, d), p, 2);
        }
        function formatYear(d, p) {
          return pad(d.getFullYear() % 100, p, 2);
        }
        function formatFullYear(d, p) {
          return pad(d.getFullYear() % 1e4, p, 4);
        }
        function formatZone(d) {
          var z = d.getTimezoneOffset();
          return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
        }
        function formatUTCDayOfMonth(d, p) {
          return pad(d.getUTCDate(), p, 2);
        }
        function formatUTCHour24(d, p) {
          return pad(d.getUTCHours(), p, 2);
        }
        function formatUTCHour12(d, p) {
          return pad(d.getUTCHours() % 12 || 12, p, 2);
        }
        function formatUTCDayOfYear(d, p) {
          return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
        }
        function formatUTCMilliseconds(d, p) {
          return pad(d.getUTCMilliseconds(), p, 3);
        }
        function formatUTCMicroseconds(d, p) {
          return formatUTCMilliseconds(d, p) + "000";
        }
        function formatUTCMonthNumber(d, p) {
          return pad(d.getUTCMonth() + 1, p, 2);
        }
        function formatUTCMinutes(d, p) {
          return pad(d.getUTCMinutes(), p, 2);
        }
        function formatUTCSeconds(d, p) {
          return pad(d.getUTCSeconds(), p, 2);
        }
        function formatUTCWeekdayNumberMonday(d) {
          var dow = d.getUTCDay();
          return dow === 0 ? 7 : dow;
        }
        function formatUTCWeekNumberSunday(d, p) {
          return pad(d3Time.utcSunday.count(d3Time.utcYear(d) - 1, d), p, 2);
        }
        function formatUTCWeekNumberISO(d, p) {
          var day = d.getUTCDay();
          d = day >= 4 || day === 0 ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
          return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
        }
        function formatUTCWeekdayNumberSunday(d) {
          return d.getUTCDay();
        }
        function formatUTCWeekNumberMonday(d, p) {
          return pad(d3Time.utcMonday.count(d3Time.utcYear(d) - 1, d), p, 2);
        }
        function formatUTCYear(d, p) {
          return pad(d.getUTCFullYear() % 100, p, 2);
        }
        function formatUTCFullYear(d, p) {
          return pad(d.getUTCFullYear() % 1e4, p, 4);
        }
        function formatUTCZone() {
          return "+0000";
        }
        function formatLiteralPercent() {
          return "%";
        }
        function formatUnixTimestamp(d) {
          return +d;
        }
        function formatUnixTimestampSeconds(d) {
          return Math.floor(+d / 1e3);
        }
        var locale;
        defaultLocale({
          dateTime: "%x, %X",
          date: "%-m/%-d/%Y",
          time: "%-I:%M:%S %p",
          periods: ["AM", "PM"],
          days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
          shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        });
        function defaultLocale(definition) {
          locale = formatLocale(definition);
          exports2.timeFormat = locale.format;
          exports2.timeParse = locale.parse;
          exports2.utcFormat = locale.utcFormat;
          exports2.utcParse = locale.utcParse;
          return locale;
        }
        var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
        function formatIsoNative(date) {
          return date.toISOString();
        }
        var formatIso = Date.prototype.toISOString ? formatIsoNative : exports2.utcFormat(isoSpecifier);
        function parseIsoNative(string) {
          var date = new Date(string);
          return isNaN(date) ? null : date;
        }
        var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : exports2.utcParse(isoSpecifier);
        exports2.isoFormat = formatIso;
        exports2.isoParse = parseIso;
        exports2.timeFormatDefaultLocale = defaultLocale;
        exports2.timeFormatLocale = formatLocale;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/d3-format/dist/d3-format.js
  var require_d3_format = __commonJS({
    "node_modules/d3-format/dist/d3-format.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.d3 = global2.d3 || {}));
      })(exports, function(exports2) {
        "use strict";
        function formatDecimal(x) {
          return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
        }
        function formatDecimalParts(x, p) {
          if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
          var i, coefficient = x.slice(0, i);
          return [
            coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
            +x.slice(i + 1)
          ];
        }
        function exponent(x) {
          return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
        }
        function formatGroup(grouping, thousands) {
          return function(value, width) {
            var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
            while (i > 0 && g > 0) {
              if (length + g + 1 > width) g = Math.max(1, width - length);
              t.push(value.substring(i -= g, i + g));
              if ((length += g + 1) > width) break;
              g = grouping[j = (j + 1) % grouping.length];
            }
            return t.reverse().join(thousands);
          };
        }
        function formatNumerals(numerals) {
          return function(value) {
            return value.replace(/[0-9]/g, function(i) {
              return numerals[+i];
            });
          };
        }
        var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
        function formatSpecifier(specifier) {
          if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
          var match;
          return new FormatSpecifier({
            fill: match[1],
            align: match[2],
            sign: match[3],
            symbol: match[4],
            zero: match[5],
            width: match[6],
            comma: match[7],
            precision: match[8] && match[8].slice(1),
            trim: match[9],
            type: match[10]
          });
        }
        formatSpecifier.prototype = FormatSpecifier.prototype;
        function FormatSpecifier(specifier) {
          this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
          this.align = specifier.align === void 0 ? ">" : specifier.align + "";
          this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
          this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
          this.zero = !!specifier.zero;
          this.width = specifier.width === void 0 ? void 0 : +specifier.width;
          this.comma = !!specifier.comma;
          this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
          this.trim = !!specifier.trim;
          this.type = specifier.type === void 0 ? "" : specifier.type + "";
        }
        FormatSpecifier.prototype.toString = function() {
          return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
        };
        function formatTrim(s) {
          out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
            switch (s[i]) {
              case ".":
                i0 = i1 = i;
                break;
              case "0":
                if (i0 === 0) i0 = i;
                i1 = i;
                break;
              default:
                if (!+s[i]) break out;
                if (i0 > 0) i0 = 0;
                break;
            }
          }
          return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
        }
        var prefixExponent;
        function formatPrefixAuto(x, p) {
          var d = formatDecimalParts(x, p);
          if (!d) return x + "";
          var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
          return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
        }
        function formatRounded(x, p) {
          var d = formatDecimalParts(x, p);
          if (!d) return x + "";
          var coefficient = d[0], exponent2 = d[1];
          return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
        }
        var formatTypes = {
          "%": function(x, p) {
            return (x * 100).toFixed(p);
          },
          "b": function(x) {
            return Math.round(x).toString(2);
          },
          "c": function(x) {
            return x + "";
          },
          "d": formatDecimal,
          "e": function(x, p) {
            return x.toExponential(p);
          },
          "f": function(x, p) {
            return x.toFixed(p);
          },
          "g": function(x, p) {
            return x.toPrecision(p);
          },
          "o": function(x) {
            return Math.round(x).toString(8);
          },
          "p": function(x, p) {
            return formatRounded(x * 100, p);
          },
          "r": formatRounded,
          "s": formatPrefixAuto,
          "X": function(x) {
            return Math.round(x).toString(16).toUpperCase();
          },
          "x": function(x) {
            return Math.round(x).toString(16);
          }
        };
        function identity(x) {
          return x;
        }
        var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
        function formatLocale(locale2) {
          var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "-" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
          function newFormat(specifier) {
            specifier = formatSpecifier(specifier);
            var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
            if (type === "n") comma = true, type = "g";
            else if (!formatTypes[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
            if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
            var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
            var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
            precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
            function format(value) {
              var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
              if (type === "c") {
                valueSuffix = formatType(value) + valueSuffix;
                value = "";
              } else {
                value = +value;
                var valueNegative = value < 0 || 1 / value < 0;
                value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                if (trim) value = formatTrim(value);
                if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
                valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                if (maybeSuffix) {
                  i = -1, n = value.length;
                  while (++i < n) {
                    if (c = value.charCodeAt(i), 48 > c || c > 57) {
                      valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                      value = value.slice(0, i);
                      break;
                    }
                  }
                }
              }
              if (comma && !zero) value = group(value, Infinity);
              var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
              if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
              switch (align) {
                case "<":
                  value = valuePrefix + value + valueSuffix + padding;
                  break;
                case "=":
                  value = valuePrefix + padding + value + valueSuffix;
                  break;
                case "^":
                  value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                  break;
                default:
                  value = padding + valuePrefix + value + valueSuffix;
                  break;
              }
              return numerals(value);
            }
            format.toString = function() {
              return specifier + "";
            };
            return format;
          }
          function formatPrefix(specifier, value) {
            var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
            return function(value2) {
              return f(k * value2) + prefix;
            };
          }
          return {
            format: newFormat,
            formatPrefix
          };
        }
        var locale;
        defaultLocale({
          decimal: ".",
          thousands: ",",
          grouping: [3],
          currency: ["$", ""],
          minus: "-"
        });
        function defaultLocale(definition) {
          locale = formatLocale(definition);
          exports2.format = locale.format;
          exports2.formatPrefix = locale.formatPrefix;
          return locale;
        }
        function precisionFixed(step) {
          return Math.max(0, -exponent(Math.abs(step)));
        }
        function precisionPrefix(step, value) {
          return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
        }
        function precisionRound(step, max) {
          step = Math.abs(step), max = Math.abs(max) - step;
          return Math.max(0, exponent(max) - exponent(step)) + 1;
        }
        exports2.FormatSpecifier = FormatSpecifier;
        exports2.formatDefaultLocale = defaultLocale;
        exports2.formatLocale = formatLocale;
        exports2.formatSpecifier = formatSpecifier;
        exports2.precisionFixed = precisionFixed;
        exports2.precisionPrefix = precisionPrefix;
        exports2.precisionRound = precisionRound;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/is-string-blank/index.js
  var require_is_string_blank = __commonJS({
    "node_modules/is-string-blank/index.js"(exports, module) {
      "use strict";
      module.exports = function(str) {
        var l = str.length, a;
        for (var i = 0; i < l; i++) {
          a = str.charCodeAt(i);
          if ((a < 9 || a > 13) && a !== 32 && a !== 133 && a !== 160 && a !== 5760 && a !== 6158 && (a < 8192 || a > 8205) && a !== 8232 && a !== 8233 && a !== 8239 && a !== 8287 && a !== 8288 && a !== 12288 && a !== 65279) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/fast-isnumeric/index.js
  var require_fast_isnumeric = __commonJS({
    "node_modules/fast-isnumeric/index.js"(exports, module) {
      "use strict";
      var allBlankCharCodes = require_is_string_blank();
      module.exports = function(n) {
        var type = typeof n;
        if (type === "string") {
          var original = n;
          n = +n;
          if (n === 0 && allBlankCharCodes(original)) return false;
        } else if (type !== "number") return false;
        return n - n < 1;
      };
    }
  });

  // src/constants/numerical.js
  var require_numerical = __commonJS({
    "src/constants/numerical.js"(exports, module) {
      "use strict";
      module.exports = {
        /**
         * Standardize all missing data in calcdata to use undefined
         * never null or NaN.
         * That way we can use !==undefined, or !== BADNUM,
         * to test for real data
         */
        BADNUM: void 0,
        /*
         * Limit certain operations to well below floating point max value
         * to avoid glitches: Make sure that even when you multiply it by the
         * number of pixels on a giant screen it still works
         */
        FP_SAFE: Number.MAX_VALUE * 1e-4,
        /*
         * conversion of date units to milliseconds
         * year and month constants are marked "AVG"
         * to remind us that not all years and months
         * have the same length
         */
        ONEMAXYEAR: 316224e5,
        // 366 * ONEDAY
        ONEAVGYEAR: 315576e5,
        // 365.25 days
        ONEMINYEAR: 31536e6,
        // 365 * ONEDAY
        ONEMAXQUARTER: 79488e5,
        // 92 * ONEDAY
        ONEAVGQUARTER: 78894e5,
        // 1/4 of ONEAVGYEAR
        ONEMINQUARTER: 76896e5,
        // 89 * ONEDAY
        ONEMAXMONTH: 26784e5,
        // 31 * ONEDAY
        ONEAVGMONTH: 26298e5,
        // 1/12 of ONEAVGYEAR
        ONEMINMONTH: 24192e5,
        // 28 * ONEDAY
        ONEWEEK: 6048e5,
        // 7 * ONEDAY
        ONEDAY: 864e5,
        // 24 * ONEHOUR
        ONEHOUR: 36e5,
        ONEMIN: 6e4,
        ONESEC: 1e3,
        ONEMILLI: 1,
        ONEMICROSEC: 1e-3,
        /*
         * For fast conversion btwn world calendars and epoch ms, the Julian Day Number
         * of the unix epoch. From calendars.instance().newDate(1970, 1, 1).toJD()
         */
        EPOCHJD: 24405875e-1,
        /*
         * Are two values nearly equal? Compare to 1PPM
         */
        ALMOST_EQUAL: 1 - 1e-6,
        /*
         * If we're asked to clip a non-positive log value, how far off-screen
         * do we put it?
         */
        LOG_CLIP: 10,
        /*
         * not a number, but for displaying numbers: the "minus sign" symbol is
         * wider than the regular ascii dash "-"
         */
        MINUS_SIGN: "\u2212"
      };
    }
  });

  // node_modules/base64-arraybuffer/dist/base64-arraybuffer.umd.js
  var require_base64_arraybuffer_umd = __commonJS({
    "node_modules/base64-arraybuffer/dist/base64-arraybuffer.umd.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && false ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["base64-arraybuffer"] = {}));
      })(exports, function(exports2) {
        "use strict";
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
        for (var i = 0; i < chars.length; i++) {
          lookup[chars.charCodeAt(i)] = i;
        }
        var encode = function(arraybuffer) {
          var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = "";
          for (i2 = 0; i2 < len; i2 += 3) {
            base64 += chars[bytes[i2] >> 2];
            base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
            base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
            base64 += chars[bytes[i2 + 2] & 63];
          }
          if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
          return base64;
        };
        var decode = function(base64) {
          var bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
          if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }
          var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
          for (i2 = 0; i2 < len; i2 += 4) {
            encoded1 = lookup[base64.charCodeAt(i2)];
            encoded2 = lookup[base64.charCodeAt(i2 + 1)];
            encoded3 = lookup[base64.charCodeAt(i2 + 2)];
            encoded4 = lookup[base64.charCodeAt(i2 + 3)];
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return arraybuffer;
        };
        exports2.decode = decode;
        exports2.encode = encode;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // src/lib/is_plain_object.js
  var require_is_plain_object = __commonJS({
    "src/lib/is_plain_object.js"(exports, module) {
      "use strict";
      module.exports = function isPlainObject(obj) {
        if (window && window.process && window.process.versions) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        }
        return Object.prototype.toString.call(obj) === "[object Object]" && Object.getPrototypeOf(obj).hasOwnProperty("hasOwnProperty");
      };
    }
  });

  // src/lib/array.js
  var require_array = __commonJS({
    "src/lib/array.js"(exports) {
      "use strict";
      var b64decode = require_base64_arraybuffer_umd().decode;
      var isPlainObject = require_is_plain_object();
      var isArray = Array.isArray;
      var ab = ArrayBuffer;
      var dv = DataView;
      function isTypedArray(a) {
        return ab.isView(a) && !(a instanceof dv);
      }
      exports.isTypedArray = isTypedArray;
      function isArrayOrTypedArray(a) {
        return isArray(a) || isTypedArray(a);
      }
      exports.isArrayOrTypedArray = isArrayOrTypedArray;
      function isArray1D(a) {
        return !isArrayOrTypedArray(a[0]);
      }
      exports.isArray1D = isArray1D;
      exports.ensureArray = function(out, n) {
        if (!isArray(out)) out = [];
        out.length = n;
        return out;
      };
      var typedArrays = {
        u1c: typeof Uint8ClampedArray === "undefined" ? void 0 : Uint8ClampedArray,
        // not supported in numpy?
        i1: typeof Int8Array === "undefined" ? void 0 : Int8Array,
        u1: typeof Uint8Array === "undefined" ? void 0 : Uint8Array,
        i2: typeof Int16Array === "undefined" ? void 0 : Int16Array,
        u2: typeof Uint16Array === "undefined" ? void 0 : Uint16Array,
        i4: typeof Int32Array === "undefined" ? void 0 : Int32Array,
        u4: typeof Uint32Array === "undefined" ? void 0 : Uint32Array,
        f4: typeof Float32Array === "undefined" ? void 0 : Float32Array,
        f8: typeof Float64Array === "undefined" ? void 0 : Float64Array
        /* TODO: potentially add Big Int
        
            i8: typeof BigInt64Array === 'undefined' ? undefined :
                       BigInt64Array,
        
            u8: typeof BigUint64Array === 'undefined' ? undefined :
                       BigUint64Array,
            */
      };
      typedArrays.uint8c = typedArrays.u1c;
      typedArrays.uint8 = typedArrays.u1;
      typedArrays.int8 = typedArrays.i1;
      typedArrays.uint16 = typedArrays.u2;
      typedArrays.int16 = typedArrays.i2;
      typedArrays.uint32 = typedArrays.u4;
      typedArrays.int32 = typedArrays.i4;
      typedArrays.float32 = typedArrays.f4;
      typedArrays.float64 = typedArrays.f8;
      function isArrayBuffer(a) {
        return a.constructor === ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      exports.decodeTypedArraySpec = function(vIn) {
        var out = [];
        var v = coerceTypedArraySpec(vIn);
        var dtype = v.dtype;
        var T = typedArrays[dtype];
        if (!T) throw new Error('Error in dtype: "' + dtype + '"');
        var BYTES_PER_ELEMENT = T.BYTES_PER_ELEMENT;
        var buffer = v.bdata;
        if (!isArrayBuffer(buffer)) {
          buffer = b64decode(buffer);
        }
        var shape = v.shape === void 0 ? (
          // detect 1-d length
          [buffer.byteLength / BYTES_PER_ELEMENT]
        ) : (
          // convert number to string and split to array
          ("" + v.shape).split(",")
        );
        shape.reverse();
        var ndim = shape.length;
        var nj, j;
        var ni = +shape[0];
        var rowBytes = BYTES_PER_ELEMENT * ni;
        var pos = 0;
        if (ndim === 1) {
          out = new T(buffer);
        } else if (ndim === 2) {
          nj = +shape[1];
          for (j = 0; j < nj; j++) {
            out[j] = new T(buffer, pos, ni);
            pos += rowBytes;
          }
        } else if (ndim === 3) {
          nj = +shape[1];
          var nk = +shape[2];
          for (var k = 0; k < nk; k++) {
            out[k] = [];
            for (j = 0; j < nj; j++) {
              out[k][j] = new T(buffer, pos, ni);
              pos += rowBytes;
            }
          }
        } else {
          throw new Error("ndim: " + ndim + 'is not supported with the shape:"' + v.shape + '"');
        }
        out.bdata = v.bdata;
        out.dtype = v.dtype;
        out.shape = shape.reverse().join(",");
        vIn._inputArray = out;
        return out;
      };
      exports.isTypedArraySpec = function(v) {
        return isPlainObject(v) && v.hasOwnProperty("dtype") && typeof v.dtype === "string" && v.hasOwnProperty("bdata") && (typeof v.bdata === "string" || isArrayBuffer(v.bdata)) && (v.shape === void 0 || v.hasOwnProperty("shape") && (typeof v.shape === "string" || typeof v.shape === "number"));
      };
      function coerceTypedArraySpec(v) {
        return {
          bdata: v.bdata,
          dtype: v.dtype,
          shape: v.shape
        };
      }
      exports.concat = function() {
        var args = [];
        var allArray = true;
        var totalLen = 0;
        var _constructor, arg0, i, argi, posi, leni, out, j;
        for (i = 0; i < arguments.length; i++) {
          argi = arguments[i];
          leni = argi.length;
          if (leni) {
            if (arg0) args.push(argi);
            else {
              arg0 = argi;
              posi = leni;
            }
            if (isArray(argi)) {
              _constructor = false;
            } else {
              allArray = false;
              if (!totalLen) {
                _constructor = argi.constructor;
              } else if (_constructor !== argi.constructor) {
                _constructor = false;
              }
            }
            totalLen += leni;
          }
        }
        if (!totalLen) return [];
        if (!args.length) return arg0;
        if (allArray) return arg0.concat.apply(arg0, args);
        if (_constructor) {
          out = new _constructor(totalLen);
          out.set(arg0);
          for (i = 0; i < args.length; i++) {
            argi = args[i];
            out.set(argi, posi);
            posi += argi.length;
          }
          return out;
        }
        out = new Array(totalLen);
        for (j = 0; j < arg0.length; j++) out[j] = arg0[j];
        for (i = 0; i < args.length; i++) {
          argi = args[i];
          for (j = 0; j < argi.length; j++) out[posi + j] = argi[j];
          posi += j;
        }
        return out;
      };
      exports.maxRowLength = function(z) {
        return _rowLength(z, Math.max, 0);
      };
      exports.minRowLength = function(z) {
        return _rowLength(z, Math.min, Infinity);
      };
      function _rowLength(z, fn, len0) {
        if (isArrayOrTypedArray(z)) {
          if (isArrayOrTypedArray(z[0])) {
            var len = len0;
            for (var i = 0; i < z.length; i++) {
              len = fn(len, z[i].length);
            }
            return len;
          } else {
            return z.length;
          }
        }
        return 0;
      }
    }
  });

  // src/lib/nested_property.js
  var require_nested_property = __commonJS({
    "src/lib/nested_property.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      module.exports = function nestedProperty(container, propStr) {
        if (isNumeric(propStr)) propStr = String(propStr);
        else if (typeof propStr !== "string" || propStr.substr(propStr.length - 4) === "[-1]") {
          throw "bad property string";
        }
        var propParts = propStr.split(".");
        var indexed;
        var indices;
        var i, j;
        for (j = 0; j < propParts.length; j++) {
          if (String(propParts[j]).slice(0, 2) === "__") {
            throw "bad property string";
          }
        }
        j = 0;
        while (j < propParts.length) {
          indexed = String(propParts[j]).match(/^([^\[\]]*)((\[\-?[0-9]*\])+)$/);
          if (indexed) {
            if (indexed[1]) propParts[j] = indexed[1];
            else if (j === 0) propParts.splice(0, 1);
            else throw "bad property string";
            indices = indexed[2].substr(1, indexed[2].length - 2).split("][");
            for (i = 0; i < indices.length; i++) {
              j++;
              propParts.splice(j, 0, Number(indices[i]));
            }
          }
          j++;
        }
        if (typeof container !== "object") {
          return badContainer(container, propStr, propParts);
        }
        return {
          set: npSet(container, propParts, propStr),
          get: npGet(container, propParts),
          astr: propStr,
          parts: propParts,
          obj: container
        };
      };
      function npGet(cont, parts) {
        return function(retainNull) {
          var curCont = cont;
          var curPart;
          var allSame;
          var out;
          var i;
          var j;
          for (i = 0; i < parts.length - 1; i++) {
            curPart = parts[i];
            if (curPart === -1) {
              allSame = true;
              out = [];
              for (j = 0; j < curCont.length; j++) {
                out[j] = npGet(curCont[j], parts.slice(i + 1))(retainNull);
                if (out[j] !== out[0]) allSame = false;
              }
              return allSame ? out[0] : out;
            }
            if (typeof curPart === "number" && !isArrayOrTypedArray(curCont)) {
              return void 0;
            }
            curCont = curCont[curPart];
            if (typeof curCont !== "object" || curCont === null) {
              return void 0;
            }
          }
          if (typeof curCont !== "object" || curCont === null) return void 0;
          out = curCont[parts[i]];
          if (!retainNull && out === null) return void 0;
          return out;
        };
      }
      var ARGS_PATTERN = /(^|\.)args\[/;
      function isDeletable(val, propStr) {
        return val === void 0 || val === null && !propStr.match(ARGS_PATTERN);
      }
      function npSet(cont, parts, propStr) {
        return function(val) {
          var curCont = cont;
          var propPart = "";
          var containerLevels = [[cont, propPart]];
          var toDelete = isDeletable(val, propStr);
          var curPart;
          var i;
          for (i = 0; i < parts.length - 1; i++) {
            curPart = parts[i];
            if (typeof curPart === "number" && !isArrayOrTypedArray(curCont)) {
              throw "array index but container is not an array";
            }
            if (curPart === -1) {
              toDelete = !setArrayAll(curCont, parts.slice(i + 1), val, propStr);
              if (toDelete) break;
              else return;
            }
            if (!checkNewContainer(curCont, curPart, parts[i + 1], toDelete)) {
              break;
            }
            curCont = curCont[curPart];
            if (typeof curCont !== "object" || curCont === null) {
              throw "container is not an object";
            }
            propPart = joinPropStr(propPart, curPart);
            containerLevels.push([curCont, propPart]);
          }
          if (toDelete) {
            if (i === parts.length - 1) {
              delete curCont[parts[i]];
              if (Array.isArray(curCont) && +parts[i] === curCont.length - 1) {
                while (curCont.length && curCont[curCont.length - 1] === void 0) {
                  curCont.pop();
                }
              }
            }
          } else curCont[parts[i]] = val;
        };
      }
      function joinPropStr(propStr, newPart) {
        var toAdd = newPart;
        if (isNumeric(newPart)) toAdd = "[" + newPart + "]";
        else if (propStr) toAdd = "." + newPart;
        return propStr + toAdd;
      }
      function setArrayAll(containerArray, innerParts, val, propStr) {
        var arrayVal = isArrayOrTypedArray(val);
        var allSet = true;
        var thisVal = val;
        var thisPropStr = propStr.replace("-1", 0);
        var deleteThis = arrayVal ? false : isDeletable(val, thisPropStr);
        var firstPart = innerParts[0];
        var i;
        for (i = 0; i < containerArray.length; i++) {
          thisPropStr = propStr.replace("-1", i);
          if (arrayVal) {
            thisVal = val[i % val.length];
            deleteThis = isDeletable(thisVal, thisPropStr);
          }
          if (deleteThis) allSet = false;
          if (!checkNewContainer(containerArray, i, firstPart, deleteThis)) {
            continue;
          }
          npSet(containerArray[i], innerParts, propStr.replace("-1", i))(thisVal);
        }
        return allSet;
      }
      function checkNewContainer(container, part, nextPart, toDelete) {
        if (container[part] === void 0) {
          if (toDelete) return false;
          if (typeof nextPart === "number") container[part] = [];
          else container[part] = {};
        }
        return true;
      }
      function badContainer(container, propStr, propParts) {
        return {
          set: function() {
            throw "bad container";
          },
          get: function() {
          },
          astr: propStr,
          parts: propParts,
          obj: container
        };
      }
    }
  });

  // src/lib/keyed_container.js
  var require_keyed_container = __commonJS({
    "src/lib/keyed_container.js"(exports, module) {
      "use strict";
      var nestedProperty = require_nested_property();
      var SIMPLE_PROPERTY_REGEX = /^\w*$/;
      var NONE = 0;
      var NAME = 1;
      var VALUE = 2;
      var BOTH = 3;
      var UNSET = 4;
      module.exports = function keyedContainer(baseObj, path, keyName, valueName) {
        keyName = keyName || "name";
        valueName = valueName || "value";
        var i, arr, baseProp;
        var changeTypes = {};
        if (path && path.length) {
          baseProp = nestedProperty(baseObj, path);
          arr = baseProp.get();
        } else {
          arr = baseObj;
        }
        path = path || "";
        var indexLookup = {};
        if (arr) {
          for (i = 0; i < arr.length; i++) {
            indexLookup[arr[i][keyName]] = i;
          }
        }
        var isSimpleValueProp = SIMPLE_PROPERTY_REGEX.test(valueName);
        var obj = {
          set: function(name, value) {
            var changeType = value === null ? UNSET : NONE;
            if (!arr) {
              if (!baseProp || changeType === UNSET) return;
              arr = [];
              baseProp.set(arr);
            }
            var idx = indexLookup[name];
            if (idx === void 0) {
              if (changeType === UNSET) return;
              changeType = changeType | BOTH;
              idx = arr.length;
              indexLookup[name] = idx;
            } else if (value !== (isSimpleValueProp ? arr[idx][valueName] : nestedProperty(arr[idx], valueName).get())) {
              changeType = changeType | VALUE;
            }
            var newValue = arr[idx] = arr[idx] || {};
            newValue[keyName] = name;
            if (isSimpleValueProp) {
              newValue[valueName] = value;
            } else {
              nestedProperty(newValue, valueName).set(value);
            }
            if (value !== null) {
              changeType = changeType & ~UNSET;
            }
            changeTypes[idx] = changeTypes[idx] | changeType;
            return obj;
          },
          get: function(name) {
            if (!arr) return;
            var idx = indexLookup[name];
            if (idx === void 0) {
              return void 0;
            } else if (isSimpleValueProp) {
              return arr[idx][valueName];
            } else {
              return nestedProperty(arr[idx], valueName).get();
            }
          },
          rename: function(name, newName) {
            var idx = indexLookup[name];
            if (idx === void 0) return obj;
            changeTypes[idx] = changeTypes[idx] | NAME;
            indexLookup[newName] = idx;
            delete indexLookup[name];
            arr[idx][keyName] = newName;
            return obj;
          },
          remove: function(name) {
            var idx = indexLookup[name];
            if (idx === void 0) return obj;
            var object = arr[idx];
            if (Object.keys(object).length > 2) {
              changeTypes[idx] = changeTypes[idx] | VALUE;
              return obj.set(name, null);
            }
            if (isSimpleValueProp) {
              for (i = idx; i < arr.length; i++) {
                changeTypes[i] = changeTypes[i] | BOTH;
              }
              for (i = idx; i < arr.length; i++) {
                indexLookup[arr[i][keyName]]--;
              }
              arr.splice(idx, 1);
              delete indexLookup[name];
            } else {
              nestedProperty(object, valueName).set(null);
              changeTypes[idx] = changeTypes[idx] | VALUE | UNSET;
            }
            return obj;
          },
          constructUpdate: function() {
            var astr, idx;
            var update = {};
            var changed = Object.keys(changeTypes);
            for (var i2 = 0; i2 < changed.length; i2++) {
              idx = changed[i2];
              astr = path + "[" + idx + "]";
              if (arr[idx]) {
                if (changeTypes[idx] & NAME) {
                  update[astr + "." + keyName] = arr[idx][keyName];
                }
                if (changeTypes[idx] & VALUE) {
                  if (isSimpleValueProp) {
                    update[astr + "." + valueName] = changeTypes[idx] & UNSET ? null : arr[idx][valueName];
                  } else {
                    update[astr + "." + valueName] = changeTypes[idx] & UNSET ? null : nestedProperty(arr[idx], valueName).get();
                  }
                }
              } else {
                update[astr] = null;
              }
            }
            return update;
          }
        };
        return obj;
      };
    }
  });

  // src/lib/relative_attr.js
  var require_relative_attr = __commonJS({
    "src/lib/relative_attr.js"(exports, module) {
      "use strict";
      var ASCEND = /^(.*)(\.[^\.\[\]]+|\[\d\])$/;
      var SIMPLEATTR = /^[^\.\[\]]+$/;
      module.exports = function(baseAttr, relativeAttr) {
        while (relativeAttr) {
          var match = baseAttr.match(ASCEND);
          if (match) baseAttr = match[1];
          else if (baseAttr.match(SIMPLEATTR)) baseAttr = "";
          else throw new Error("bad relativeAttr call:" + [baseAttr, relativeAttr]);
          if (relativeAttr.charAt(0) === "^") relativeAttr = relativeAttr.slice(1);
          else break;
        }
        if (baseAttr && relativeAttr.charAt(0) !== "[") {
          return baseAttr + "." + relativeAttr;
        }
        return baseAttr + relativeAttr;
      };
    }
  });

  // src/lib/to_log_range.js
  var require_to_log_range = __commonJS({
    "src/lib/to_log_range.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      module.exports = function toLogRange(val, range) {
        if (val > 0) return Math.log(val) / Math.LN10;
        var newVal = Math.log(Math.min(range[0], range[1])) / Math.LN10;
        if (!isNumeric(newVal)) newVal = Math.log(Math.max(range[0], range[1])) / Math.LN10 - 6;
        return newVal;
      };
    }
  });

  // src/lib/relink_private.js
  var require_relink_private = __commonJS({
    "src/lib/relink_private.js"(exports, module) {
      "use strict";
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      var isPlainObject = require_is_plain_object();
      module.exports = function relinkPrivateKeys(toContainer, fromContainer) {
        for (var k in fromContainer) {
          var fromVal = fromContainer[k];
          var toVal = toContainer[k];
          if (toVal === fromVal) continue;
          if (k.charAt(0) === "_" || typeof fromVal === "function") {
            if (k in toContainer) continue;
            toContainer[k] = fromVal;
          } else if (isArrayOrTypedArray(fromVal) && isArrayOrTypedArray(toVal) && isPlainObject(fromVal[0])) {
            if (k === "customdata" || k === "ids") continue;
            var minLen = Math.min(fromVal.length, toVal.length);
            for (var j = 0; j < minLen; j++) {
              if (toVal[j] !== fromVal[j] && isPlainObject(fromVal[j]) && isPlainObject(toVal[j])) {
                relinkPrivateKeys(toVal[j], fromVal[j]);
              }
            }
          } else if (isPlainObject(fromVal) && isPlainObject(toVal)) {
            relinkPrivateKeys(toVal, fromVal);
            if (!Object.keys(toVal).length) delete toContainer[k];
          }
        }
      };
    }
  });

  // src/lib/mod.js
  var require_mod = __commonJS({
    "src/lib/mod.js"(exports, module) {
      "use strict";
      function mod(v, d) {
        var out = v % d;
        return out < 0 ? out + d : out;
      }
      function modHalf(v, d) {
        return Math.abs(v) > d / 2 ? v - Math.round(v / d) * d : v;
      }
      module.exports = {
        mod,
        modHalf
      };
    }
  });

  // node_modules/tinycolor2/tinycolor.js
  var require_tinycolor = __commonJS({
    "node_modules/tinycolor2/tinycolor.js"(exports, module) {
      (function(Math2) {
        var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
        function tinycolor(color, opts) {
          color = color ? color : "";
          opts = opts || {};
          if (color instanceof tinycolor) {
            return color;
          }
          if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
          }
          var rgb = inputToRGB(color);
          this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
          this._gradientType = opts.gradientType;
          if (this._r < 1) {
            this._r = mathRound(this._r);
          }
          if (this._g < 1) {
            this._g = mathRound(this._g);
          }
          if (this._b < 1) {
            this._b = mathRound(this._b);
          }
          this._ok = rgb.ok;
          this._tc_id = tinyCounter++;
        }
        tinycolor.prototype = {
          isDark: function() {
            return this.getBrightness() < 128;
          },
          isLight: function() {
            return !this.isDark();
          },
          isValid: function() {
            return this._ok;
          },
          getOriginalInput: function() {
            return this._originalInput;
          },
          getFormat: function() {
            return this._format;
          },
          getAlpha: function() {
            return this._a;
          },
          getBrightness: function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
          },
          getLuminance: function() {
            var rgb = this.toRgb();
            var RsRGB, GsRGB, BsRGB, R, G, B;
            RsRGB = rgb.r / 255;
            GsRGB = rgb.g / 255;
            BsRGB = rgb.b / 255;
            if (RsRGB <= 0.03928) {
              R = RsRGB / 12.92;
            } else {
              R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
            }
            if (GsRGB <= 0.03928) {
              G = GsRGB / 12.92;
            } else {
              G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
            }
            if (BsRGB <= 0.03928) {
              B = BsRGB / 12.92;
            } else {
              B = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
            }
            return 0.2126 * R + 0.7152 * G + 0.0722 * B;
          },
          setAlpha: function(value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(100 * this._a) / 100;
            return this;
          },
          toHsv: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
          },
          toHsvString: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
          },
          toHsl: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
          },
          toHslString: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
          },
          toHex: function(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
          },
          toHexString: function(allow3Char) {
            return "#" + this.toHex(allow3Char);
          },
          toHex8: function(allow4Char) {
            return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
          },
          toHex8String: function(allow4Char) {
            return "#" + this.toHex8(allow4Char);
          },
          toRgb: function() {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
          },
          toRgbString: function() {
            return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
          },
          toPercentageRgb: function() {
            return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
          },
          toPercentageRgbString: function() {
            return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
          },
          toName: function() {
            if (this._a === 0) {
              return "transparent";
            }
            if (this._a < 1) {
              return false;
            }
            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
          },
          toFilter: function(secondColor) {
            var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";
            if (secondColor) {
              var s = tinycolor(secondColor);
              secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
            }
            return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
          },
          toString: function(format) {
            var formatSet = !!format;
            format = format || this._format;
            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
            if (needsAlphaFormat) {
              if (format === "name" && this._a === 0) {
                return this.toName();
              }
              return this.toRgbString();
            }
            if (format === "rgb") {
              formattedString = this.toRgbString();
            }
            if (format === "prgb") {
              formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
              formattedString = this.toHexString();
            }
            if (format === "hex3") {
              formattedString = this.toHexString(true);
            }
            if (format === "hex4") {
              formattedString = this.toHex8String(true);
            }
            if (format === "hex8") {
              formattedString = this.toHex8String();
            }
            if (format === "name") {
              formattedString = this.toName();
            }
            if (format === "hsl") {
              formattedString = this.toHslString();
            }
            if (format === "hsv") {
              formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
          },
          clone: function() {
            return tinycolor(this.toString());
          },
          _applyModification: function(fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
          },
          lighten: function() {
            return this._applyModification(lighten, arguments);
          },
          brighten: function() {
            return this._applyModification(brighten, arguments);
          },
          darken: function() {
            return this._applyModification(darken, arguments);
          },
          desaturate: function() {
            return this._applyModification(desaturate, arguments);
          },
          saturate: function() {
            return this._applyModification(saturate, arguments);
          },
          greyscale: function() {
            return this._applyModification(greyscale, arguments);
          },
          spin: function() {
            return this._applyModification(spin, arguments);
          },
          _applyCombination: function(fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
          },
          analogous: function() {
            return this._applyCombination(analogous, arguments);
          },
          complement: function() {
            return this._applyCombination(complement, arguments);
          },
          monochromatic: function() {
            return this._applyCombination(monochromatic, arguments);
          },
          splitcomplement: function() {
            return this._applyCombination(splitcomplement, arguments);
          },
          triad: function() {
            return this._applyCombination(triad, arguments);
          },
          tetrad: function() {
            return this._applyCombination(tetrad, arguments);
          }
        };
        tinycolor.fromRatio = function(color, opts) {
          if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
              if (color.hasOwnProperty(i)) {
                if (i === "a") {
                  newColor[i] = color[i];
                } else {
                  newColor[i] = convertToPercentage(color[i]);
                }
              }
            }
            color = newColor;
          }
          return tinycolor(color, opts);
        };
        function inputToRGB(color) {
          var rgb = { r: 0, g: 0, b: 0 };
          var a = 1;
          var s = null;
          var v = null;
          var l = null;
          var ok = false;
          var format = false;
          if (typeof color == "string") {
            color = stringInputToObject(color);
          }
          if (typeof color == "object") {
            if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
              rgb = rgbToRgb(color.r, color.g, color.b);
              ok = true;
              format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
              s = convertToPercentage(color.s);
              v = convertToPercentage(color.v);
              rgb = hsvToRgb(color.h, s, v);
              ok = true;
              format = "hsv";
            } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
              s = convertToPercentage(color.s);
              l = convertToPercentage(color.l);
              rgb = hslToRgb(color.h, s, l);
              ok = true;
              format = "hsl";
            }
            if (color.hasOwnProperty("a")) {
              a = color.a;
            }
          }
          a = boundAlpha(a);
          return {
            ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a
          };
        }
        function rgbToRgb(r, g, b) {
          return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
          };
        }
        function rgbToHsl(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = mathMax(r, g, b), min = mathMin(r, g, b);
          var h, s, l = (max + min) / 2;
          if (max == min) {
            h = s = 0;
          } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h, s, l };
        }
        function hslToRgb(h, s, l) {
          var r, g, b;
          h = bound01(h, 360);
          s = bound01(s, 100);
          l = bound01(l, 100);
          function hue2rgb(p2, q2, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
            if (t < 1 / 2) return q2;
            if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
            return p2;
          }
          if (s === 0) {
            r = g = b = l;
          } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }
          return { r: r * 255, g: g * 255, b: b * 255 };
        }
        function rgbToHsv(r, g, b) {
          r = bound01(r, 255);
          g = bound01(g, 255);
          b = bound01(b, 255);
          var max = mathMax(r, g, b), min = mathMin(r, g, b);
          var h, s, v = max;
          var d = max - min;
          s = max === 0 ? 0 : d / max;
          if (max == min) {
            h = 0;
          } else {
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }
          return { h, s, v };
        }
        function hsvToRgb(h, s, v) {
          h = bound01(h, 360) * 6;
          s = bound01(s, 100);
          v = bound01(v, 100);
          var i = Math2.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
          return { r: r * 255, g: g * 255, b: b * 255 };
        }
        function rgbToHex(r, g, b, allow3Char) {
          var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
          ];
          if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
          }
          return hex.join("");
        }
        function rgbaToHex(r, g, b, a, allow4Char) {
          var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16)),
            pad2(convertDecimalToHex(a))
          ];
          if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
          }
          return hex.join("");
        }
        function rgbaToArgbHex(r, g, b, a) {
          var hex = [
            pad2(convertDecimalToHex(a)),
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
          ];
          return hex.join("");
        }
        tinycolor.equals = function(color1, color2) {
          if (!color1 || !color2) {
            return false;
          }
          return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
        };
        tinycolor.random = function() {
          return tinycolor.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
          });
        };
        function desaturate(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function saturate(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return tinycolor(hsl);
        }
        function greyscale(color) {
          return tinycolor(color).desaturate(100);
        }
        function lighten(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }
        function brighten(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var rgb = tinycolor(color).toRgb();
          rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
          rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
          rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
          return tinycolor(rgb);
        }
        function darken(color, amount) {
          amount = amount === 0 ? 0 : amount || 10;
          var hsl = tinycolor(color).toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return tinycolor(hsl);
        }
        function spin(color, amount) {
          var hsl = tinycolor(color).toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return tinycolor(hsl);
        }
        function complement(color) {
          var hsl = tinycolor(color).toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return tinycolor(hsl);
        }
        function triad(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [
            tinycolor(color),
            tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
          ];
        }
        function tetrad(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [
            tinycolor(color),
            tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
          ];
        }
        function splitcomplement(color) {
          var hsl = tinycolor(color).toHsl();
          var h = hsl.h;
          return [
            tinycolor(color),
            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        }
        function analogous(color, results, slices) {
          results = results || 6;
          slices = slices || 30;
          var hsl = tinycolor(color).toHsl();
          var part = 360 / slices;
          var ret = [tinycolor(color)];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
          }
          return ret;
        }
        function monochromatic(color, results) {
          results = results || 6;
          var hsv = tinycolor(color).toHsv();
          var h = hsv.h, s = hsv.s, v = hsv.v;
          var ret = [];
          var modification = 1 / results;
          while (results--) {
            ret.push(tinycolor({ h, s, v }));
            v = (v + modification) % 1;
          }
          return ret;
        }
        tinycolor.mix = function(color1, color2, amount) {
          amount = amount === 0 ? 0 : amount || 50;
          var rgb1 = tinycolor(color1).toRgb();
          var rgb2 = tinycolor(color2).toRgb();
          var p = amount / 100;
          var rgba2 = {
            r: (rgb2.r - rgb1.r) * p + rgb1.r,
            g: (rgb2.g - rgb1.g) * p + rgb1.g,
            b: (rgb2.b - rgb1.b) * p + rgb1.b,
            a: (rgb2.a - rgb1.a) * p + rgb1.a
          };
          return tinycolor(rgba2);
        };
        tinycolor.readability = function(color1, color2) {
          var c1 = tinycolor(color1);
          var c2 = tinycolor(color2);
          return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
        };
        tinycolor.isReadable = function(color1, color2, wcag2) {
          var readability = tinycolor.readability(color1, color2);
          var wcag2Parms, out;
          out = false;
          wcag2Parms = validateWCAG2Parms(wcag2);
          switch (wcag2Parms.level + wcag2Parms.size) {
            case "AAsmall":
            case "AAAlarge":
              out = readability >= 4.5;
              break;
            case "AAlarge":
              out = readability >= 3;
              break;
            case "AAAsmall":
              out = readability >= 7;
              break;
          }
          return out;
        };
        tinycolor.mostReadable = function(baseColor, colorList, args) {
          var bestColor = null;
          var bestScore = 0;
          var readability;
          var includeFallbackColors, level, size;
          args = args || {};
          includeFallbackColors = args.includeFallbackColors;
          level = args.level;
          size = args.size;
          for (var i = 0; i < colorList.length; i++) {
            readability = tinycolor.readability(baseColor, colorList[i]);
            if (readability > bestScore) {
              bestScore = readability;
              bestColor = tinycolor(colorList[i]);
            }
          }
          if (tinycolor.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
            return bestColor;
          } else {
            args.includeFallbackColors = false;
            return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
          }
        };
        var names2 = tinycolor.names = {
          aliceblue: "f0f8ff",
          antiquewhite: "faebd7",
          aqua: "0ff",
          aquamarine: "7fffd4",
          azure: "f0ffff",
          beige: "f5f5dc",
          bisque: "ffe4c4",
          black: "000",
          blanchedalmond: "ffebcd",
          blue: "00f",
          blueviolet: "8a2be2",
          brown: "a52a2a",
          burlywood: "deb887",
          burntsienna: "ea7e5d",
          cadetblue: "5f9ea0",
          chartreuse: "7fff00",
          chocolate: "d2691e",
          coral: "ff7f50",
          cornflowerblue: "6495ed",
          cornsilk: "fff8dc",
          crimson: "dc143c",
          cyan: "0ff",
          darkblue: "00008b",
          darkcyan: "008b8b",
          darkgoldenrod: "b8860b",
          darkgray: "a9a9a9",
          darkgreen: "006400",
          darkgrey: "a9a9a9",
          darkkhaki: "bdb76b",
          darkmagenta: "8b008b",
          darkolivegreen: "556b2f",
          darkorange: "ff8c00",
          darkorchid: "9932cc",
          darkred: "8b0000",
          darksalmon: "e9967a",
          darkseagreen: "8fbc8f",
          darkslateblue: "483d8b",
          darkslategray: "2f4f4f",
          darkslategrey: "2f4f4f",
          darkturquoise: "00ced1",
          darkviolet: "9400d3",
          deeppink: "ff1493",
          deepskyblue: "00bfff",
          dimgray: "696969",
          dimgrey: "696969",
          dodgerblue: "1e90ff",
          firebrick: "b22222",
          floralwhite: "fffaf0",
          forestgreen: "228b22",
          fuchsia: "f0f",
          gainsboro: "dcdcdc",
          ghostwhite: "f8f8ff",
          gold: "ffd700",
          goldenrod: "daa520",
          gray: "808080",
          green: "008000",
          greenyellow: "adff2f",
          grey: "808080",
          honeydew: "f0fff0",
          hotpink: "ff69b4",
          indianred: "cd5c5c",
          indigo: "4b0082",
          ivory: "fffff0",
          khaki: "f0e68c",
          lavender: "e6e6fa",
          lavenderblush: "fff0f5",
          lawngreen: "7cfc00",
          lemonchiffon: "fffacd",
          lightblue: "add8e6",
          lightcoral: "f08080",
          lightcyan: "e0ffff",
          lightgoldenrodyellow: "fafad2",
          lightgray: "d3d3d3",
          lightgreen: "90ee90",
          lightgrey: "d3d3d3",
          lightpink: "ffb6c1",
          lightsalmon: "ffa07a",
          lightseagreen: "20b2aa",
          lightskyblue: "87cefa",
          lightslategray: "789",
          lightslategrey: "789",
          lightsteelblue: "b0c4de",
          lightyellow: "ffffe0",
          lime: "0f0",
          limegreen: "32cd32",
          linen: "faf0e6",
          magenta: "f0f",
          maroon: "800000",
          mediumaquamarine: "66cdaa",
          mediumblue: "0000cd",
          mediumorchid: "ba55d3",
          mediumpurple: "9370db",
          mediumseagreen: "3cb371",
          mediumslateblue: "7b68ee",
          mediumspringgreen: "00fa9a",
          mediumturquoise: "48d1cc",
          mediumvioletred: "c71585",
          midnightblue: "191970",
          mintcream: "f5fffa",
          mistyrose: "ffe4e1",
          moccasin: "ffe4b5",
          navajowhite: "ffdead",
          navy: "000080",
          oldlace: "fdf5e6",
          olive: "808000",
          olivedrab: "6b8e23",
          orange: "ffa500",
          orangered: "ff4500",
          orchid: "da70d6",
          palegoldenrod: "eee8aa",
          palegreen: "98fb98",
          paleturquoise: "afeeee",
          palevioletred: "db7093",
          papayawhip: "ffefd5",
          peachpuff: "ffdab9",
          peru: "cd853f",
          pink: "ffc0cb",
          plum: "dda0dd",
          powderblue: "b0e0e6",
          purple: "800080",
          rebeccapurple: "663399",
          red: "f00",
          rosybrown: "bc8f8f",
          royalblue: "4169e1",
          saddlebrown: "8b4513",
          salmon: "fa8072",
          sandybrown: "f4a460",
          seagreen: "2e8b57",
          seashell: "fff5ee",
          sienna: "a0522d",
          silver: "c0c0c0",
          skyblue: "87ceeb",
          slateblue: "6a5acd",
          slategray: "708090",
          slategrey: "708090",
          snow: "fffafa",
          springgreen: "00ff7f",
          steelblue: "4682b4",
          tan: "d2b48c",
          teal: "008080",
          thistle: "d8bfd8",
          tomato: "ff6347",
          turquoise: "40e0d0",
          violet: "ee82ee",
          wheat: "f5deb3",
          white: "fff",
          whitesmoke: "f5f5f5",
          yellow: "ff0",
          yellowgreen: "9acd32"
        };
        var hexNames = tinycolor.hexNames = flip(names2);
        function flip(o) {
          var flipped = {};
          for (var i in o) {
            if (o.hasOwnProperty(i)) {
              flipped[o[i]] = i;
            }
          }
          return flipped;
        }
        function boundAlpha(a) {
          a = parseFloat(a);
          if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
          }
          return a;
        }
        function bound01(n, max) {
          if (isOnePointZero(n)) {
            n = "100%";
          }
          var processPercent = isPercentage(n);
          n = mathMin(max, mathMax(0, parseFloat(n)));
          if (processPercent) {
            n = parseInt(n * max, 10) / 100;
          }
          if (Math2.abs(n - max) < 1e-6) {
            return 1;
          }
          return n % max / parseFloat(max);
        }
        function clamp01(val) {
          return mathMin(1, mathMax(0, val));
        }
        function parseIntFromHex(val) {
          return parseInt(val, 16);
        }
        function isOnePointZero(n) {
          return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
        }
        function isPercentage(n) {
          return typeof n === "string" && n.indexOf("%") != -1;
        }
        function pad2(c) {
          return c.length == 1 ? "0" + c : "" + c;
        }
        function convertToPercentage(n) {
          if (n <= 1) {
            n = n * 100 + "%";
          }
          return n;
        }
        function convertDecimalToHex(d) {
          return Math2.round(parseFloat(d) * 255).toString(16);
        }
        function convertHexToDecimal(h) {
          return parseIntFromHex(h) / 255;
        }
        var matchers = function() {
          var CSS_INTEGER = "[-\\+]?\\d+%?";
          var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
          var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
          var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
          return {
            CSS_UNIT: new RegExp(CSS_UNIT),
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
          };
        }();
        function isValidCSSUnit(color) {
          return !!matchers.CSS_UNIT.exec(color);
        }
        function stringInputToObject(color) {
          color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
          var named = false;
          if (names2[color]) {
            color = names2[color];
            named = true;
          } else if (color == "transparent") {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
          }
          var match;
          if (match = matchers.rgb.exec(color)) {
            return { r: match[1], g: match[2], b: match[3] };
          }
          if (match = matchers.rgba.exec(color)) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
          }
          if (match = matchers.hsl.exec(color)) {
            return { h: match[1], s: match[2], l: match[3] };
          }
          if (match = matchers.hsla.exec(color)) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
          }
          if (match = matchers.hsv.exec(color)) {
            return { h: match[1], s: match[2], v: match[3] };
          }
          if (match = matchers.hsva.exec(color)) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
          }
          if (match = matchers.hex8.exec(color)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              a: convertHexToDecimal(match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex6.exec(color)) {
            return {
              r: parseIntFromHex(match[1]),
              g: parseIntFromHex(match[2]),
              b: parseIntFromHex(match[3]),
              format: named ? "name" : "hex"
            };
          }
          if (match = matchers.hex4.exec(color)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              a: convertHexToDecimal(match[4] + "" + match[4]),
              format: named ? "name" : "hex8"
            };
          }
          if (match = matchers.hex3.exec(color)) {
            return {
              r: parseIntFromHex(match[1] + "" + match[1]),
              g: parseIntFromHex(match[2] + "" + match[2]),
              b: parseIntFromHex(match[3] + "" + match[3]),
              format: named ? "name" : "hex"
            };
          }
          return false;
        }
        function validateWCAG2Parms(parms) {
          var level, size;
          parms = parms || { "level": "AA", "size": "small" };
          level = (parms.level || "AA").toUpperCase();
          size = (parms.size || "small").toLowerCase();
          if (level !== "AA" && level !== "AAA") {
            level = "AA";
          }
          if (size !== "small" && size !== "large") {
            size = "small";
          }
          return { "level": level, "size": size };
        }
        if (typeof module !== "undefined" && module.exports) {
          module.exports = tinycolor;
        } else if (typeof define === "function" && false) {
          define(function() {
            return tinycolor;
          });
        } else {
          window.tinycolor = tinycolor;
        }
      })(Math);
    }
  });

  // src/lib/extend.js
  var require_extend = __commonJS({
    "src/lib/extend.js"(exports) {
      "use strict";
      var isPlainObject = require_is_plain_object();
      var isArray = Array.isArray;
      function primitivesLoopSplice(source, target) {
        var i, value;
        for (i = 0; i < source.length; i++) {
          value = source[i];
          if (value !== null && typeof value === "object") {
            return false;
          }
          if (value !== void 0) {
            target[i] = value;
          }
        }
        return true;
      }
      exports.extendFlat = function() {
        return _extend(arguments, false, false, false);
      };
      exports.extendDeep = function() {
        return _extend(arguments, true, false, false);
      };
      exports.extendDeepAll = function() {
        return _extend(arguments, true, true, false);
      };
      exports.extendDeepNoArrays = function() {
        return _extend(arguments, true, false, true);
      };
      function _extend(inputs, isDeep, keepAllKeys, noArrayCopies) {
        var target = inputs[0];
        var length = inputs.length;
        var input, key, src, copy, copyIsArray, clone, allPrimitives;
        if (length === 2 && isArray(target) && isArray(inputs[1]) && target.length === 0) {
          allPrimitives = primitivesLoopSplice(inputs[1], target);
          if (allPrimitives) {
            return target;
          } else {
            target.splice(0, target.length);
          }
        }
        for (var i = 1; i < length; i++) {
          input = inputs[i];
          for (key in input) {
            src = target[key];
            copy = input[key];
            if (noArrayCopies && isArray(copy)) {
              target[key] = copy;
            } else if (isDeep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }
              target[key] = _extend([clone, copy], isDeep, keepAllKeys, noArrayCopies);
            } else if (typeof copy !== "undefined" || keepAllKeys) {
              target[key] = copy;
            }
          }
        }
        return target;
      }
    }
  });

  // src/plots/font_attributes.js
  var require_font_attributes = __commonJS({
    "src/plots/font_attributes.js"(exports, module) {
      "use strict";
      module.exports = function(opts) {
        var variantValues = opts.variantValues;
        var editType = opts.editType;
        var colorEditType = opts.colorEditType;
        if (colorEditType === void 0) colorEditType = editType;
        var weight = {
          editType,
          valType: "integer",
          min: 1,
          max: 1e3,
          extras: ["normal", "bold"],
          dflt: "normal"
        };
        if (opts.noNumericWeightValues) {
          weight.valType = "enumerated";
          weight.values = weight.extras;
          weight.extras = void 0;
          weight.min = void 0;
          weight.max = void 0;
        }
        var attrs = {
          family: {
            valType: "string",
            noBlank: true,
            strict: true,
            editType
          },
          size: {
            valType: "number",
            min: 1,
            editType
          },
          color: {
            valType: "color",
            editType: colorEditType
          },
          weight,
          style: {
            editType,
            valType: "enumerated",
            values: ["normal", "italic"],
            dflt: "normal"
          },
          variant: opts.noFontVariant ? void 0 : {
            editType,
            valType: "enumerated",
            values: variantValues || [
              "normal",
              "small-caps",
              "all-small-caps",
              "all-petite-caps",
              "petite-caps",
              "unicase"
            ],
            dflt: "normal"
          },
          textcase: opts.noFontTextcase ? void 0 : {
            editType,
            valType: "enumerated",
            values: ["normal", "word caps", "upper", "lower"],
            dflt: "normal"
          },
          lineposition: opts.noFontLineposition ? void 0 : {
            editType,
            valType: "flaglist",
            flags: ["under", "over", "through"],
            extras: ["none"],
            dflt: "none"
          },
          shadow: opts.noFontShadow ? void 0 : {
            editType,
            valType: "string",
            dflt: opts.autoShadowDflt ? "auto" : "none"
          },
          editType
          // blank strings so compress_attributes can remove
          // TODO - that's uber hacky... better solution?
        };
        if (opts.autoSize) attrs.size.dflt = "auto";
        if (opts.autoColor) attrs.color.dflt = "auto";
        if (opts.arrayOk) {
          attrs.family.arrayOk = true;
          attrs.weight.arrayOk = true;
          attrs.style.arrayOk = true;
          if (!opts.noFontVariant) {
            attrs.variant.arrayOk = true;
          }
          if (!opts.noFontTextcase) {
            attrs.textcase.arrayOk = true;
          }
          if (!opts.noFontLineposition) {
            attrs.lineposition.arrayOk = true;
          }
          if (!opts.noFontShadow) {
            attrs.shadow.arrayOk = true;
          }
          attrs.size.arrayOk = true;
          attrs.color.arrayOk = true;
        }
        return attrs;
      };
    }
  });

  // src/components/fx/constants.js
  var require_constants = __commonJS({
    "src/components/fx/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // hover labels for multiple horizontal bars get tilted by this angle
        YANGLE: 60,
        // size and display constants for hover text
        // pixel size of hover arrows
        HOVERARROWSIZE: 6,
        // pixels padding around text
        HOVERTEXTPAD: 3,
        // hover font
        HOVERFONTSIZE: 13,
        HOVERFONT: "Arial, sans-serif",
        // minimum time (msec) between hover calls
        HOVERMINTIME: 50,
        // ID suffix (with fullLayout._uid) for hover events in the throttle cache
        HOVERID: "-hover"
      };
    }
  });

  // src/components/fx/layout_attributes.js
  var require_layout_attributes = __commonJS({
    "src/components/fx/layout_attributes.js"(exports, module) {
      "use strict";
      var constants = require_constants();
      var fontAttrs = require_font_attributes();
      var font = fontAttrs({
        editType: "none"
      });
      font.family.dflt = constants.HOVERFONT;
      font.size.dflt = constants.HOVERFONTSIZE;
      module.exports = {
        clickmode: {
          valType: "flaglist",
          flags: ["event", "select"],
          dflt: "event",
          editType: "plot",
          extras: ["none"]
        },
        dragmode: {
          valType: "enumerated",
          values: [
            "zoom",
            "pan",
            "select",
            "lasso",
            "drawclosedpath",
            "drawopenpath",
            "drawline",
            "drawrect",
            "drawcircle",
            "orbit",
            "turntable",
            false
          ],
          dflt: "zoom",
          editType: "modebar"
        },
        hovermode: {
          valType: "enumerated",
          values: ["x", "y", "closest", false, "x unified", "y unified"],
          dflt: "closest",
          editType: "modebar"
        },
        hoversubplots: {
          valType: "enumerated",
          values: ["single", "overlaying", "axis"],
          dflt: "overlaying",
          editType: "none"
        },
        hoverdistance: {
          valType: "integer",
          min: -1,
          dflt: 20,
          editType: "none"
        },
        spikedistance: {
          valType: "integer",
          min: -1,
          dflt: -1,
          editType: "none"
        },
        hoverlabel: {
          bgcolor: {
            valType: "color",
            editType: "none"
          },
          bordercolor: {
            valType: "color",
            editType: "none"
          },
          font,
          grouptitlefont: fontAttrs({
            editType: "none"
          }),
          align: {
            valType: "enumerated",
            values: ["left", "right", "auto"],
            dflt: "auto",
            editType: "none"
          },
          namelength: {
            valType: "integer",
            min: -1,
            dflt: 15,
            editType: "none"
          },
          editType: "none"
        },
        selectdirection: {
          valType: "enumerated",
          values: ["h", "v", "d", "any"],
          dflt: "any",
          editType: "none"
        }
      };
    }
  });

  // src/components/fx/attributes.js
  var require_attributes = __commonJS({
    "src/components/fx/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var hoverLabelAttrs = require_layout_attributes().hoverlabel;
      var extendFlat = require_extend().extendFlat;
      module.exports = {
        hoverlabel: {
          bgcolor: extendFlat({}, hoverLabelAttrs.bgcolor, {
            arrayOk: true
          }),
          bordercolor: extendFlat({}, hoverLabelAttrs.bordercolor, {
            arrayOk: true
          }),
          font: fontAttrs({
            arrayOk: true,
            editType: "none"
          }),
          align: extendFlat({}, hoverLabelAttrs.align, { arrayOk: true }),
          namelength: extendFlat({}, hoverLabelAttrs.namelength, { arrayOk: true }),
          editType: "none"
        }
      };
    }
  });

  // src/plots/attributes.js
  var require_attributes2 = __commonJS({
    "src/plots/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var fxAttrs = require_attributes();
      module.exports = {
        type: {
          valType: "enumerated",
          values: [],
          // listed dynamically
          dflt: "scatter",
          editType: "calc+clearAxisTypes",
          _noTemplating: true
          // we handle this at a higher level
        },
        visible: {
          valType: "enumerated",
          values: [true, false, "legendonly"],
          dflt: true,
          editType: "calc"
        },
        showlegend: {
          valType: "boolean",
          dflt: true,
          editType: "style"
        },
        legend: {
          valType: "subplotid",
          dflt: "legend",
          editType: "style"
        },
        legendgroup: {
          valType: "string",
          dflt: "",
          editType: "style"
        },
        legendgrouptitle: {
          text: {
            valType: "string",
            dflt: "",
            editType: "style"
          },
          font: fontAttrs({
            editType: "style"
          }),
          editType: "style"
        },
        legendrank: {
          valType: "number",
          dflt: 1e3,
          editType: "style"
        },
        legendwidth: {
          valType: "number",
          min: 0,
          editType: "style"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "style"
        },
        name: {
          valType: "string",
          editType: "style"
        },
        uid: {
          valType: "string",
          editType: "plot",
          anim: true
        },
        ids: {
          valType: "data_array",
          editType: "calc",
          anim: true
        },
        customdata: {
          valType: "data_array",
          editType: "calc"
        },
        meta: {
          valType: "any",
          arrayOk: true,
          editType: "plot"
        },
        // N.B. these cannot be 'data_array' as they do not have the same length as
        // other data arrays and arrayOk attributes in general
        //
        // Maybe add another valType:
        // https://github.com/plotly/plotly.js/issues/1894
        selectedpoints: {
          valType: "any",
          editType: "calc"
        },
        hoverinfo: {
          valType: "flaglist",
          flags: ["x", "y", "z", "text", "name"],
          extras: ["all", "none", "skip"],
          arrayOk: true,
          dflt: "all",
          editType: "none"
        },
        hoverlabel: fxAttrs.hoverlabel,
        stream: {
          token: {
            valType: "string",
            noBlank: true,
            strict: true,
            editType: "calc"
          },
          maxpoints: {
            valType: "number",
            min: 0,
            max: 1e4,
            dflt: 500,
            editType: "calc"
          },
          editType: "calc"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        }
      };
    }
  });

  // src/components/colorscale/scales.js
  var require_scales = __commonJS({
    "src/components/colorscale/scales.js"(exports, module) {
      "use strict";
      var tinycolor = require_tinycolor();
      var scales = {
        Greys: [
          [0, "rgb(0,0,0)"],
          [1, "rgb(255,255,255)"]
        ],
        YlGnBu: [
          [0, "rgb(8,29,88)"],
          [0.125, "rgb(37,52,148)"],
          [0.25, "rgb(34,94,168)"],
          [0.375, "rgb(29,145,192)"],
          [0.5, "rgb(65,182,196)"],
          [0.625, "rgb(127,205,187)"],
          [0.75, "rgb(199,233,180)"],
          [0.875, "rgb(237,248,217)"],
          [1, "rgb(255,255,217)"]
        ],
        Greens: [
          [0, "rgb(0,68,27)"],
          [0.125, "rgb(0,109,44)"],
          [0.25, "rgb(35,139,69)"],
          [0.375, "rgb(65,171,93)"],
          [0.5, "rgb(116,196,118)"],
          [0.625, "rgb(161,217,155)"],
          [0.75, "rgb(199,233,192)"],
          [0.875, "rgb(229,245,224)"],
          [1, "rgb(247,252,245)"]
        ],
        YlOrRd: [
          [0, "rgb(128,0,38)"],
          [0.125, "rgb(189,0,38)"],
          [0.25, "rgb(227,26,28)"],
          [0.375, "rgb(252,78,42)"],
          [0.5, "rgb(253,141,60)"],
          [0.625, "rgb(254,178,76)"],
          [0.75, "rgb(254,217,118)"],
          [0.875, "rgb(255,237,160)"],
          [1, "rgb(255,255,204)"]
        ],
        Bluered: [
          [0, "rgb(0,0,255)"],
          [1, "rgb(255,0,0)"]
        ],
        // modified RdBu based on
        // http://www.kennethmoreland.com/color-maps/
        RdBu: [
          [0, "rgb(5,10,172)"],
          [0.35, "rgb(106,137,247)"],
          [0.5, "rgb(190,190,190)"],
          [0.6, "rgb(220,170,132)"],
          [0.7, "rgb(230,145,90)"],
          [1, "rgb(178,10,28)"]
        ],
        // Scale for non-negative numeric values
        Reds: [
          [0, "rgb(220,220,220)"],
          [0.2, "rgb(245,195,157)"],
          [0.4, "rgb(245,160,105)"],
          [1, "rgb(178,10,28)"]
        ],
        // Scale for non-positive numeric values
        Blues: [
          [0, "rgb(5,10,172)"],
          [0.35, "rgb(40,60,190)"],
          [0.5, "rgb(70,100,245)"],
          [0.6, "rgb(90,120,245)"],
          [0.7, "rgb(106,137,247)"],
          [1, "rgb(220,220,220)"]
        ],
        Picnic: [
          [0, "rgb(0,0,255)"],
          [0.1, "rgb(51,153,255)"],
          [0.2, "rgb(102,204,255)"],
          [0.3, "rgb(153,204,255)"],
          [0.4, "rgb(204,204,255)"],
          [0.5, "rgb(255,255,255)"],
          [0.6, "rgb(255,204,255)"],
          [0.7, "rgb(255,153,255)"],
          [0.8, "rgb(255,102,204)"],
          [0.9, "rgb(255,102,102)"],
          [1, "rgb(255,0,0)"]
        ],
        Rainbow: [
          [0, "rgb(150,0,90)"],
          [0.125, "rgb(0,0,200)"],
          [0.25, "rgb(0,25,255)"],
          [0.375, "rgb(0,152,255)"],
          [0.5, "rgb(44,255,150)"],
          [0.625, "rgb(151,255,0)"],
          [0.75, "rgb(255,234,0)"],
          [0.875, "rgb(255,111,0)"],
          [1, "rgb(255,0,0)"]
        ],
        Portland: [
          [0, "rgb(12,51,131)"],
          [0.25, "rgb(10,136,186)"],
          [0.5, "rgb(242,211,56)"],
          [0.75, "rgb(242,143,56)"],
          [1, "rgb(217,30,30)"]
        ],
        Jet: [
          [0, "rgb(0,0,131)"],
          [0.125, "rgb(0,60,170)"],
          [0.375, "rgb(5,255,255)"],
          [0.625, "rgb(255,255,0)"],
          [0.875, "rgb(250,0,0)"],
          [1, "rgb(128,0,0)"]
        ],
        Hot: [
          [0, "rgb(0,0,0)"],
          [0.3, "rgb(230,0,0)"],
          [0.6, "rgb(255,210,0)"],
          [1, "rgb(255,255,255)"]
        ],
        Blackbody: [
          [0, "rgb(0,0,0)"],
          [0.2, "rgb(230,0,0)"],
          [0.4, "rgb(230,210,0)"],
          [0.7, "rgb(255,255,255)"],
          [1, "rgb(160,200,255)"]
        ],
        Earth: [
          [0, "rgb(0,0,130)"],
          [0.1, "rgb(0,180,180)"],
          [0.2, "rgb(40,210,40)"],
          [0.4, "rgb(230,230,50)"],
          [0.6, "rgb(120,70,20)"],
          [1, "rgb(255,255,255)"]
        ],
        Electric: [
          [0, "rgb(0,0,0)"],
          [0.15, "rgb(30,0,100)"],
          [0.4, "rgb(120,0,100)"],
          [0.6, "rgb(160,90,0)"],
          [0.8, "rgb(230,200,0)"],
          [1, "rgb(255,250,220)"]
        ],
        Viridis: [
          [0, "#440154"],
          [0.06274509803921569, "#48186a"],
          [0.12549019607843137, "#472d7b"],
          [0.18823529411764706, "#424086"],
          [0.25098039215686274, "#3b528b"],
          [0.3137254901960784, "#33638d"],
          [0.3764705882352941, "#2c728e"],
          [0.4392156862745098, "#26828e"],
          [0.5019607843137255, "#21918c"],
          [0.5647058823529412, "#1fa088"],
          [0.6274509803921569, "#28ae80"],
          [0.6901960784313725, "#3fbc73"],
          [0.7529411764705882, "#5ec962"],
          [0.8156862745098039, "#84d44b"],
          [0.8784313725490196, "#addc30"],
          [0.9411764705882353, "#d8e219"],
          [1, "#fde725"]
        ],
        Cividis: [
          [0, "rgb(0,32,76)"],
          [0.058824, "rgb(0,42,102)"],
          [0.117647, "rgb(0,52,110)"],
          [0.176471, "rgb(39,63,108)"],
          [0.235294, "rgb(60,74,107)"],
          [0.294118, "rgb(76,85,107)"],
          [0.352941, "rgb(91,95,109)"],
          [0.411765, "rgb(104,106,112)"],
          [0.470588, "rgb(117,117,117)"],
          [0.529412, "rgb(131,129,120)"],
          [0.588235, "rgb(146,140,120)"],
          [0.647059, "rgb(161,152,118)"],
          [0.705882, "rgb(176,165,114)"],
          [0.764706, "rgb(192,177,109)"],
          [0.823529, "rgb(209,191,102)"],
          [0.882353, "rgb(225,204,92)"],
          [0.941176, "rgb(243,219,79)"],
          [1, "rgb(255,233,69)"]
        ]
      };
      var defaultScale = scales.RdBu;
      function getScale(scl, dflt) {
        if (!dflt) dflt = defaultScale;
        if (!scl) return dflt;
        function parseScale() {
          try {
            scl = scales[scl] || JSON.parse(scl);
          } catch (e) {
            scl = dflt;
          }
        }
        if (typeof scl === "string") {
          parseScale();
          if (typeof scl === "string") parseScale();
        }
        if (!isValidScaleArray(scl)) return dflt;
        return scl;
      }
      function isValidScaleArray(scl) {
        var highestVal = 0;
        if (!Array.isArray(scl) || scl.length < 2) return false;
        if (!scl[0] || !scl[scl.length - 1]) return false;
        if (+scl[0][0] !== 0 || +scl[scl.length - 1][0] !== 1) return false;
        for (var i = 0; i < scl.length; i++) {
          var si = scl[i];
          if (si.length !== 2 || +si[0] < highestVal || !tinycolor(si[1]).isValid()) {
            return false;
          }
          highestVal = +si[0];
        }
        return true;
      }
      function isValidScale(scl) {
        if (scales[scl] !== void 0) return true;
        else return isValidScaleArray(scl);
      }
      module.exports = {
        scales,
        defaultScale,
        get: getScale,
        isValid: isValidScale
      };
    }
  });

  // src/components/color/attributes.js
  var require_attributes3 = __commonJS({
    "src/components/color/attributes.js"(exports) {
      "use strict";
      exports.defaults = [
        "#1f77b4",
        // muted blue
        "#ff7f0e",
        // safety orange
        "#2ca02c",
        // cooked asparagus green
        "#d62728",
        // brick red
        "#9467bd",
        // muted purple
        "#8c564b",
        // chestnut brown
        "#e377c2",
        // raspberry yogurt pink
        "#7f7f7f",
        // middle gray
        "#bcbd22",
        // curry yellow-green
        "#17becf"
        // blue-teal
      ];
      exports.defaultLine = "#444";
      exports.lightLine = "#eee";
      exports.background = "#fff";
      exports.borderLine = "#BEC8D9";
      exports.lightFraction = 100 * (14 - 4) / (15 - 4);
    }
  });

  // src/components/color/index.js
  var require_color = __commonJS({
    "src/components/color/index.js"(exports, module) {
      "use strict";
      var tinycolor = require_tinycolor();
      var isNumeric = require_fast_isnumeric();
      var isTypedArray = require_array().isTypedArray;
      var color = module.exports = {};
      var colorAttrs = require_attributes3();
      color.defaults = colorAttrs.defaults;
      var defaultLine = color.defaultLine = colorAttrs.defaultLine;
      color.lightLine = colorAttrs.lightLine;
      var background = color.background = colorAttrs.background;
      color.tinyRGB = function(tc) {
        var c = tc.toRgb();
        return "rgb(" + Math.round(c.r) + ", " + Math.round(c.g) + ", " + Math.round(c.b) + ")";
      };
      color.rgb = function(cstr) {
        return color.tinyRGB(tinycolor(cstr));
      };
      color.opacity = function(cstr) {
        return cstr ? tinycolor(cstr).getAlpha() : 0;
      };
      color.addOpacity = function(cstr, op) {
        var c = tinycolor(cstr).toRgb();
        return "rgba(" + Math.round(c.r) + ", " + Math.round(c.g) + ", " + Math.round(c.b) + ", " + op + ")";
      };
      color.combine = function(front, back) {
        var fc = tinycolor(front).toRgb();
        if (fc.a === 1) return tinycolor(front).toRgbString();
        var bc = tinycolor(back || background).toRgb();
        var bcflat = bc.a === 1 ? bc : {
          r: 255 * (1 - bc.a) + bc.r * bc.a,
          g: 255 * (1 - bc.a) + bc.g * bc.a,
          b: 255 * (1 - bc.a) + bc.b * bc.a
        };
        var fcflat = {
          r: bcflat.r * (1 - fc.a) + fc.r * fc.a,
          g: bcflat.g * (1 - fc.a) + fc.g * fc.a,
          b: bcflat.b * (1 - fc.a) + fc.b * fc.a
        };
        return tinycolor(fcflat).toRgbString();
      };
      color.interpolate = function(first, second, factor) {
        var fc = tinycolor(first).toRgb();
        var sc = tinycolor(second).toRgb();
        var ic = {
          r: factor * fc.r + (1 - factor) * sc.r,
          g: factor * fc.g + (1 - factor) * sc.g,
          b: factor * fc.b + (1 - factor) * sc.b
        };
        return tinycolor(ic).toRgbString();
      };
      color.contrast = function(cstr, lightAmount, darkAmount) {
        var tc = tinycolor(cstr);
        if (tc.getAlpha() !== 1) tc = tinycolor(color.combine(cstr, background));
        var newColor = tc.isDark() ? lightAmount ? tc.lighten(lightAmount) : background : darkAmount ? tc.darken(darkAmount) : defaultLine;
        return newColor.toString();
      };
      color.stroke = function(s, c) {
        var tc = tinycolor(c);
        s.style({ stroke: color.tinyRGB(tc), "stroke-opacity": tc.getAlpha() });
      };
      color.fill = function(s, c) {
        var tc = tinycolor(c);
        s.style({
          fill: color.tinyRGB(tc),
          "fill-opacity": tc.getAlpha()
        });
      };
      color.clean = function(container) {
        if (!container || typeof container !== "object") return;
        var keys = Object.keys(container);
        var i, j, key, val;
        for (i = 0; i < keys.length; i++) {
          key = keys[i];
          val = container[key];
          if (key.substr(key.length - 5) === "color") {
            if (Array.isArray(val)) {
              for (j = 0; j < val.length; j++) val[j] = cleanOne(val[j]);
            } else container[key] = cleanOne(val);
          } else if (key.substr(key.length - 10) === "colorscale" && Array.isArray(val)) {
            for (j = 0; j < val.length; j++) {
              if (Array.isArray(val[j])) val[j][1] = cleanOne(val[j][1]);
            }
          } else if (Array.isArray(val)) {
            var el0 = val[0];
            if (!Array.isArray(el0) && el0 && typeof el0 === "object") {
              for (j = 0; j < val.length; j++) color.clean(val[j]);
            }
          } else if (val && typeof val === "object" && !isTypedArray(val)) color.clean(val);
        }
      };
      function cleanOne(val) {
        if (isNumeric(val) || typeof val !== "string") return val;
        var valTrim = val.trim();
        if (valTrim.substr(0, 3) !== "rgb") return val;
        var match = valTrim.match(/^rgba?\s*\(([^()]*)\)$/);
        if (!match) return val;
        var parts = match[1].trim().split(/\s*[\s,]\s*/);
        var rgba2 = valTrim.charAt(3) === "a" && parts.length === 4;
        if (!rgba2 && parts.length !== 3) return val;
        for (var i = 0; i < parts.length; i++) {
          if (!parts[i].length) return val;
          parts[i] = Number(parts[i]);
          if (!(parts[i] >= 0)) {
            return val;
          }
          if (i === 3) {
            if (parts[i] > 1) parts[i] = 1;
          } else if (parts[i] >= 1) {
            return val;
          }
        }
        var rgbStr = Math.round(parts[0] * 255) + ", " + Math.round(parts[1] * 255) + ", " + Math.round(parts[2] * 255);
        if (rgba2) return "rgba(" + rgbStr + ", " + parts[3] + ")";
        return "rgb(" + rgbStr + ")";
      }
    }
  });

  // src/constants/interactions.js
  var require_interactions = __commonJS({
    "src/constants/interactions.js"(exports, module) {
      "use strict";
      module.exports = {
        /**
         * Timing information for interactive elements
         */
        SHOW_PLACEHOLDER: 100,
        HIDE_PLACEHOLDER: 1e3,
        // opacity dimming fraction for points that are not in selection
        DESELECTDIM: 0.2
      };
    }
  });

  // src/lib/regex.js
  var require_regex = __commonJS({
    "src/lib/regex.js"(exports) {
      "use strict";
      exports.counter = function(head, tail, openEnded, matchBeginning) {
        var fullTail = (tail || "") + (openEnded ? "" : "$");
        var startWithPrefix = matchBeginning === false ? "" : "^";
        if (head === "xy") {
          return new RegExp(startWithPrefix + "x([2-9]|[1-9][0-9]+)?y([2-9]|[1-9][0-9]+)?" + fullTail);
        }
        return new RegExp(startWithPrefix + head + "([2-9]|[1-9][0-9]+)?" + fullTail);
      };
    }
  });

  // src/lib/coerce.js
  var require_coerce = __commonJS({
    "src/lib/coerce.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var extendFlat = require_extend().extendFlat;
      var baseTraceAttrs = require_attributes2();
      var colorscales = require_scales();
      var Color = require_color();
      var DESELECTDIM = require_interactions().DESELECTDIM;
      var nestedProperty = require_nested_property();
      var counterRegex = require_regex().counter;
      var modHalf = require_mod().modHalf;
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      var isTypedArraySpec = require_array().isTypedArraySpec;
      var decodeTypedArraySpec = require_array().decodeTypedArraySpec;
      exports.valObjectMeta = {
        data_array: {
          // You can use *dflt=[] to force said array to exist though.
          coerceFunction: function(v, propOut, dflt) {
            propOut.set(
              isArrayOrTypedArray(v) ? v : isTypedArraySpec(v) ? decodeTypedArraySpec(v) : dflt
            );
          }
        },
        enumerated: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if (opts.coerceNumber) v = +v;
            if (opts.values.indexOf(v) === -1) propOut.set(dflt);
            else propOut.set(v);
          },
          validateFunction: function(v, opts) {
            if (opts.coerceNumber) v = +v;
            var values = opts.values;
            for (var i = 0; i < values.length; i++) {
              var k = String(values[i]);
              if (k.charAt(0) === "/" && k.charAt(k.length - 1) === "/") {
                var regex = new RegExp(k.substr(1, k.length - 2));
                if (regex.test(v)) return true;
              } else if (v === values[i]) return true;
            }
            return false;
          }
        },
        boolean: {
          coerceFunction: function(v, propOut, dflt) {
            if (v === true || v === false) propOut.set(v);
            else propOut.set(dflt);
          }
        },
        number: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (!isNumeric(v) || opts.min !== void 0 && v < opts.min || opts.max !== void 0 && v > opts.max) {
              propOut.set(dflt);
            } else propOut.set(+v);
          }
        },
        integer: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if ((opts.extras || []).indexOf(v) !== -1) {
              propOut.set(v);
              return;
            }
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (v % 1 || !isNumeric(v) || opts.min !== void 0 && v < opts.min || opts.max !== void 0 && v > opts.max) {
              propOut.set(dflt);
            } else propOut.set(+v);
          }
        },
        string: {
          // TODO 'values shouldn't be in there (edge case: 'dash' in Scatter)
          coerceFunction: function(v, propOut, dflt, opts) {
            if (typeof v !== "string") {
              var okToCoerce = typeof v === "number";
              if (opts.strict === true || !okToCoerce) propOut.set(dflt);
              else propOut.set(String(v));
            } else if (opts.noBlank && !v) propOut.set(dflt);
            else propOut.set(v);
          }
        },
        color: {
          coerceFunction: function(v, propOut, dflt) {
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (tinycolor(v).isValid()) propOut.set(v);
            else propOut.set(dflt);
          }
        },
        colorlist: {
          coerceFunction: function(v, propOut, dflt) {
            function isColor(color) {
              return tinycolor(color).isValid();
            }
            if (!Array.isArray(v) || !v.length) propOut.set(dflt);
            else if (v.every(isColor)) propOut.set(v);
            else propOut.set(dflt);
          }
        },
        colorscale: {
          coerceFunction: function(v, propOut, dflt) {
            propOut.set(colorscales.get(v, dflt));
          }
        },
        angle: {
          coerceFunction: function(v, propOut, dflt) {
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (v === "auto") propOut.set("auto");
            else if (!isNumeric(v)) propOut.set(dflt);
            else propOut.set(modHalf(+v, 360));
          }
        },
        subplotid: {
          coerceFunction: function(v, propOut, dflt, opts) {
            var regex = opts.regex || counterRegex(dflt);
            if (typeof v === "string" && regex.test(v)) {
              propOut.set(v);
              return;
            }
            propOut.set(dflt);
          },
          validateFunction: function(v, opts) {
            var dflt = opts.dflt;
            if (v === dflt) return true;
            if (typeof v !== "string") return false;
            if (counterRegex(dflt).test(v)) return true;
            return false;
          }
        },
        flaglist: {
          coerceFunction: function(v, propOut, dflt, opts) {
            if ((opts.extras || []).indexOf(v) !== -1) {
              propOut.set(v);
              return;
            }
            if (typeof v !== "string") {
              propOut.set(dflt);
              return;
            }
            var vParts = v.split("+");
            var i = 0;
            while (i < vParts.length) {
              var vi = vParts[i];
              if (opts.flags.indexOf(vi) === -1 || vParts.indexOf(vi) < i) {
                vParts.splice(i, 1);
              } else i++;
            }
            if (!vParts.length) propOut.set(dflt);
            else propOut.set(vParts.join("+"));
          }
        },
        any: {
          coerceFunction: function(v, propOut, dflt) {
            if (v === void 0) {
              propOut.set(dflt);
            } else {
              propOut.set(
                isTypedArraySpec(v) ? decodeTypedArraySpec(v) : v
              );
            }
          }
        },
        info_array: {
          // set `dimensions=2` for a 2D array or '1-2' for either
          // `items` may be a single object instead of an array, in which case
          // `freeLength` must be true.
          // if `dimensions='1-2'` and items is a 1D array, then the value can
          // either be a matching 1D array or an array of such matching 1D arrays
          coerceFunction: function(v, propOut, dflt, opts) {
            function coercePart(v2, opts2, dflt2) {
              var out;
              var propPart = { set: function(v3) {
                out = v3;
              } };
              if (dflt2 === void 0) dflt2 = opts2.dflt;
              exports.valObjectMeta[opts2.valType].coerceFunction(v2, propPart, dflt2, opts2);
              return out;
            }
            if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
            if (!isArrayOrTypedArray(v)) {
              propOut.set(dflt);
              return;
            }
            var twoD = opts.dimensions === 2 || opts.dimensions === "1-2" && Array.isArray(v) && isArrayOrTypedArray(v[0]);
            var items = opts.items;
            var vOut = [];
            var arrayItems = Array.isArray(items);
            var arrayItems2D = arrayItems && twoD && isArrayOrTypedArray(items[0]);
            var innerItemsOnly = twoD && arrayItems && !arrayItems2D;
            var len = arrayItems && !innerItemsOnly ? items.length : v.length;
            var i, j, row, item, len2, vNew;
            dflt = Array.isArray(dflt) ? dflt : [];
            if (twoD) {
              for (i = 0; i < len; i++) {
                vOut[i] = [];
                row = isArrayOrTypedArray(v[i]) ? v[i] : [];
                if (innerItemsOnly) len2 = items.length;
                else if (arrayItems) len2 = items[i].length;
                else len2 = row.length;
                for (j = 0; j < len2; j++) {
                  if (innerItemsOnly) item = items[j];
                  else if (arrayItems) item = items[i][j];
                  else item = items;
                  vNew = coercePart(row[j], item, (dflt[i] || [])[j]);
                  if (vNew !== void 0) vOut[i][j] = vNew;
                }
              }
            } else {
              for (i = 0; i < len; i++) {
                vNew = coercePart(v[i], arrayItems ? items[i] : items, dflt[i]);
                if (vNew !== void 0) vOut[i] = vNew;
              }
            }
            propOut.set(vOut);
          },
          validateFunction: function(v, opts) {
            if (!isArrayOrTypedArray(v)) return false;
            var items = opts.items;
            var arrayItems = Array.isArray(items);
            var twoD = opts.dimensions === 2;
            if (!opts.freeLength && v.length !== items.length) return false;
            for (var i = 0; i < v.length; i++) {
              if (twoD) {
                if (!isArrayOrTypedArray(v[i]) || !opts.freeLength && v[i].length !== items[i].length) {
                  return false;
                }
                for (var j = 0; j < v[i].length; j++) {
                  if (!validate(v[i][j], arrayItems ? items[i][j] : items)) {
                    return false;
                  }
                }
              } else if (!validate(v[i], arrayItems ? items[i] : items)) return false;
            }
            return true;
          }
        }
      };
      exports.coerce = function(containerIn, containerOut, attributes, attribute, dflt) {
        var opts = nestedProperty(attributes, attribute).get();
        var propIn = nestedProperty(containerIn, attribute);
        var propOut = nestedProperty(containerOut, attribute);
        var v = propIn.get();
        var template = containerOut._template;
        if (v === void 0 && template) {
          v = nestedProperty(template, attribute).get();
          template = 0;
        }
        if (dflt === void 0) dflt = opts.dflt;
        if (opts.arrayOk) {
          if (isArrayOrTypedArray(v)) {
            propOut.set(v);
            return v;
          } else {
            if (isTypedArraySpec(v)) {
              v = decodeTypedArraySpec(v);
              propOut.set(v);
              return v;
            }
          }
        }
        var coerceFunction = exports.valObjectMeta[opts.valType].coerceFunction;
        coerceFunction(v, propOut, dflt, opts);
        var out = propOut.get();
        if (template && out === dflt && !validate(v, opts)) {
          v = nestedProperty(template, attribute).get();
          coerceFunction(v, propOut, dflt, opts);
          out = propOut.get();
        }
        return out;
      };
      exports.coerce2 = function(containerIn, containerOut, attributes, attribute, dflt) {
        var propIn = nestedProperty(containerIn, attribute);
        var propOut = exports.coerce(containerIn, containerOut, attributes, attribute, dflt);
        var valIn = propIn.get();
        return valIn !== void 0 && valIn !== null ? propOut : false;
      };
      exports.coerceFont = function(coerce, attr, dfltObj, opts) {
        if (!opts) opts = {};
        dfltObj = extendFlat({}, dfltObj);
        dfltObj = extendFlat(dfltObj, opts.overrideDflt || {});
        var out = {
          family: coerce(attr + ".family", dfltObj.family),
          size: coerce(attr + ".size", dfltObj.size),
          color: coerce(attr + ".color", dfltObj.color),
          weight: coerce(attr + ".weight", dfltObj.weight),
          style: coerce(attr + ".style", dfltObj.style)
        };
        if (!opts.noFontVariant) out.variant = coerce(attr + ".variant", dfltObj.variant);
        if (!opts.noFontLineposition) out.lineposition = coerce(attr + ".lineposition", dfltObj.lineposition);
        if (!opts.noFontTextcase) out.textcase = coerce(attr + ".textcase", dfltObj.textcase);
        if (!opts.noFontShadow) {
          var dfltShadow = dfltObj.shadow;
          if (dfltShadow === "none" && opts.autoShadowDflt) {
            dfltShadow = "auto";
          }
          out.shadow = coerce(attr + ".shadow", dfltShadow);
        }
        return out;
      };
      exports.coercePattern = function(coerce, attr, markerColor, hasMarkerColorscale) {
        var shape = coerce(attr + ".shape");
        if (shape) {
          coerce(attr + ".solidity");
          coerce(attr + ".size");
          var fillmode = coerce(attr + ".fillmode");
          var isOverlay = fillmode === "overlay";
          if (!hasMarkerColorscale) {
            var bgcolor = coerce(
              attr + ".bgcolor",
              isOverlay ? markerColor : void 0
            );
            coerce(
              attr + ".fgcolor",
              isOverlay ? Color.contrast(bgcolor) : markerColor
            );
          }
          coerce(
            attr + ".fgopacity",
            isOverlay ? 0.5 : 1
          );
        }
      };
      exports.coerceHoverinfo = function(traceIn, traceOut, layoutOut) {
        var moduleAttrs = traceOut._module.attributes;
        var attrs = moduleAttrs.hoverinfo ? moduleAttrs : baseTraceAttrs;
        var valObj = attrs.hoverinfo;
        var dflt;
        if (layoutOut._dataLength === 1) {
          var flags = valObj.dflt === "all" ? valObj.flags.slice() : valObj.dflt.split("+");
          flags.splice(flags.indexOf("name"), 1);
          dflt = flags.join("+");
        }
        return exports.coerce(traceIn, traceOut, attrs, "hoverinfo", dflt);
      };
      exports.coerceSelectionMarkerOpacity = function(traceOut, coerce) {
        if (!traceOut.marker) return;
        var mo = traceOut.marker.opacity;
        if (mo === void 0) return;
        var smoDflt;
        var usmoDflt;
        if (!isArrayOrTypedArray(mo) && !traceOut.selected && !traceOut.unselected) {
          smoDflt = mo;
          usmoDflt = DESELECTDIM * mo;
        }
        coerce("selected.marker.opacity", smoDflt);
        coerce("unselected.marker.opacity", usmoDflt);
      };
      function validate(value, opts) {
        var valObjectDef = exports.valObjectMeta[opts.valType];
        if (opts.arrayOk && isArrayOrTypedArray(value)) return true;
        if (valObjectDef.validateFunction) {
          return valObjectDef.validateFunction(value, opts);
        }
        var failed = {};
        var out = failed;
        var propMock = { set: function(v) {
          out = v;
        } };
        valObjectDef.coerceFunction(value, propMock, failed, opts);
        return out !== failed;
      }
      exports.validate = validate;
    }
  });

  // src/plot_api/plot_config.js
  var require_plot_config = __commonJS({
    "src/plot_api/plot_config.js"(exports, module) {
      "use strict";
      var configAttributes = {
        staticPlot: {
          valType: "boolean",
          dflt: false
        },
        typesetMath: {
          valType: "boolean",
          dflt: true
        },
        plotlyServerURL: {
          valType: "string",
          dflt: ""
        },
        editable: {
          valType: "boolean",
          dflt: false
        },
        edits: {
          annotationPosition: {
            valType: "boolean",
            dflt: false
          },
          annotationTail: {
            valType: "boolean",
            dflt: false
          },
          annotationText: {
            valType: "boolean",
            dflt: false
          },
          axisTitleText: {
            valType: "boolean",
            dflt: false
          },
          colorbarPosition: {
            valType: "boolean",
            dflt: false
          },
          colorbarTitleText: {
            valType: "boolean",
            dflt: false
          },
          legendPosition: {
            valType: "boolean",
            dflt: false
          },
          legendText: {
            valType: "boolean",
            dflt: false
          },
          shapePosition: {
            valType: "boolean",
            dflt: false
          },
          titleText: {
            valType: "boolean",
            dflt: false
          }
        },
        editSelection: {
          valType: "boolean",
          dflt: true
        },
        autosizable: {
          valType: "boolean",
          dflt: false
        },
        responsive: {
          valType: "boolean",
          dflt: false
        },
        fillFrame: {
          valType: "boolean",
          dflt: false
        },
        frameMargins: {
          valType: "number",
          dflt: 0,
          min: 0,
          max: 0.5
        },
        scrollZoom: {
          valType: "flaglist",
          flags: ["cartesian", "gl3d", "geo", "mapbox", "map"],
          extras: [true, false],
          dflt: "gl3d+geo+map"
        },
        doubleClick: {
          valType: "enumerated",
          values: [false, "reset", "autosize", "reset+autosize"],
          dflt: "reset+autosize"
        },
        doubleClickDelay: {
          valType: "number",
          dflt: 300,
          min: 0
        },
        showAxisDragHandles: {
          valType: "boolean",
          dflt: true
        },
        showAxisRangeEntryBoxes: {
          valType: "boolean",
          dflt: true
        },
        showTips: {
          valType: "boolean",
          dflt: true
        },
        showLink: {
          valType: "boolean",
          dflt: false
        },
        linkText: {
          valType: "string",
          dflt: "Edit chart",
          noBlank: true
        },
        sendData: {
          valType: "boolean",
          dflt: true
        },
        showSources: {
          valType: "any",
          dflt: false
        },
        displayModeBar: {
          valType: "enumerated",
          values: ["hover", true, false],
          dflt: "hover"
        },
        showSendToCloud: {
          valType: "boolean",
          dflt: false
        },
        showEditInChartStudio: {
          valType: "boolean",
          dflt: false
        },
        modeBarButtonsToRemove: {
          valType: "any",
          dflt: []
        },
        modeBarButtonsToAdd: {
          valType: "any",
          dflt: []
        },
        modeBarButtons: {
          valType: "any",
          dflt: false
        },
        toImageButtonOptions: {
          valType: "any",
          dflt: {}
        },
        displaylogo: {
          valType: "boolean",
          dflt: true
        },
        watermark: {
          valType: "boolean",
          dflt: false
        },
        plotGlPixelRatio: {
          valType: "number",
          dflt: 2,
          min: 1,
          max: 4
        },
        setBackground: {
          valType: "any",
          dflt: "transparent"
        },
        topojsonURL: {
          valType: "string",
          noBlank: true,
          dflt: "https://cdn.plot.ly/"
        },
        mapboxAccessToken: {
          valType: "string",
          dflt: null
        },
        logging: {
          valType: "integer",
          min: 0,
          max: 2,
          dflt: 1
        },
        notifyOnLogging: {
          valType: "integer",
          min: 0,
          max: 2,
          dflt: 0
        },
        queueLength: {
          valType: "integer",
          min: 0,
          dflt: 0
        },
        locale: {
          valType: "string",
          dflt: "en-US"
        },
        locales: {
          valType: "any",
          dflt: {}
        }
      };
      var dfltConfig = {};
      function crawl(src, target) {
        for (var k in src) {
          var obj = src[k];
          if (obj.valType) {
            target[k] = obj.dflt;
          } else {
            if (!target[k]) {
              target[k] = {};
            }
            crawl(obj, target[k]);
          }
        }
      }
      crawl(configAttributes, dfltConfig);
      module.exports = {
        configAttributes,
        dfltConfig
      };
    }
  });

  // src/lib/notifier.js
  var require_notifier = __commonJS({
    "src/lib/notifier.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var NOTEDATA = [];
      module.exports = function(text, displayLength) {
        if (NOTEDATA.indexOf(text) !== -1) return;
        NOTEDATA.push(text);
        var ts = 1e3;
        if (isNumeric(displayLength)) ts = displayLength;
        else if (displayLength === "long") ts = 3e3;
        var notifierContainer = d3.select("body").selectAll(".plotly-notifier").data([0]);
        notifierContainer.enter().append("div").classed("plotly-notifier", true);
        var notes = notifierContainer.selectAll(".notifier-note").data(NOTEDATA);
        function killNote(transition) {
          transition.duration(700).style("opacity", 0).each("end", function(thisText) {
            var thisIndex = NOTEDATA.indexOf(thisText);
            if (thisIndex !== -1) NOTEDATA.splice(thisIndex, 1);
            d3.select(this).remove();
          });
        }
        notes.enter().append("div").classed("notifier-note", true).style("opacity", 0).each(function(thisText) {
          var note = d3.select(this);
          note.append("button").classed("notifier-close", true).html("&times;").on("click", function() {
            note.transition().call(killNote);
          });
          var p = note.append("p");
          var lines = thisText.split(/<br\s*\/?>/g);
          for (var i = 0; i < lines.length; i++) {
            if (i) p.append("br");
            p.append("span").text(lines[i]);
          }
          if (displayLength === "stick") {
            note.transition().duration(350).style("opacity", 1);
          } else {
            note.transition().duration(700).style("opacity", 1).transition().delay(ts).call(killNote);
          }
        });
      };
    }
  });

  // src/lib/loggers.js
  var require_loggers = __commonJS({
    "src/lib/loggers.js"(exports, module) {
      "use strict";
      var dfltConfig = require_plot_config().dfltConfig;
      var notifier = require_notifier();
      var loggers = module.exports = {};
      loggers.log = function() {
        var i;
        if (dfltConfig.logging > 1) {
          var messages = ["LOG:"];
          for (i = 0; i < arguments.length; i++) {
            messages.push(arguments[i]);
          }
          console.trace.apply(console, messages);
        }
        if (dfltConfig.notifyOnLogging > 1) {
          var lines = [];
          for (i = 0; i < arguments.length; i++) {
            lines.push(arguments[i]);
          }
          notifier(lines.join("<br>"), "long");
        }
      };
      loggers.warn = function() {
        var i;
        if (dfltConfig.logging > 0) {
          var messages = ["WARN:"];
          for (i = 0; i < arguments.length; i++) {
            messages.push(arguments[i]);
          }
          console.trace.apply(console, messages);
        }
        if (dfltConfig.notifyOnLogging > 0) {
          var lines = [];
          for (i = 0; i < arguments.length; i++) {
            lines.push(arguments[i]);
          }
          notifier(lines.join("<br>"), "stick");
        }
      };
      loggers.error = function() {
        var i;
        if (dfltConfig.logging > 0) {
          var messages = ["ERROR:"];
          for (i = 0; i < arguments.length; i++) {
            messages.push(arguments[i]);
          }
          console.error.apply(console, messages);
        }
        if (dfltConfig.notifyOnLogging > 0) {
          var lines = [];
          for (i = 0; i < arguments.length; i++) {
            lines.push(arguments[i]);
          }
          notifier(lines.join("<br>"), "stick");
        }
      };
    }
  });

  // src/lib/noop.js
  var require_noop = __commonJS({
    "src/lib/noop.js"(exports, module) {
      "use strict";
      module.exports = function noop() {
      };
    }
  });

  // src/lib/push_unique.js
  var require_push_unique = __commonJS({
    "src/lib/push_unique.js"(exports, module) {
      "use strict";
      module.exports = function pushUnique(array, item) {
        if (item instanceof RegExp) {
          var itemStr = item.toString();
          for (var i = 0; i < array.length; i++) {
            if (array[i] instanceof RegExp && array[i].toString() === itemStr) {
              return array;
            }
          }
          array.push(item);
        } else if ((item || item === 0) && array.indexOf(item) === -1) array.push(item);
        return array;
      };
    }
  });

  // node_modules/gl-mat4/create.js
  var require_create = __commonJS({
    "node_modules/gl-mat4/create.js"(exports, module) {
      module.exports = create;
      function create() {
        var out = new Float32Array(16);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/clone.js
  var require_clone = __commonJS({
    "node_modules/gl-mat4/clone.js"(exports, module) {
      module.exports = clone;
      function clone(a) {
        var out = new Float32Array(16);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      }
    }
  });

  // node_modules/gl-mat4/copy.js
  var require_copy = __commonJS({
    "node_modules/gl-mat4/copy.js"(exports, module) {
      module.exports = copy;
      function copy(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      }
    }
  });

  // node_modules/gl-mat4/identity.js
  var require_identity = __commonJS({
    "node_modules/gl-mat4/identity.js"(exports, module) {
      module.exports = identity;
      function identity(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/transpose.js
  var require_transpose = __commonJS({
    "node_modules/gl-mat4/transpose.js"(exports, module) {
      module.exports = transpose;
      function transpose(out, a) {
        if (out === a) {
          var a01 = a[1], a02 = a[2], a03 = a[3], a12 = a[6], a13 = a[7], a23 = a[11];
          out[1] = a[4];
          out[2] = a[8];
          out[3] = a[12];
          out[4] = a01;
          out[6] = a[9];
          out[7] = a[13];
          out[8] = a02;
          out[9] = a12;
          out[11] = a[14];
          out[12] = a03;
          out[13] = a13;
          out[14] = a23;
        } else {
          out[0] = a[0];
          out[1] = a[4];
          out[2] = a[8];
          out[3] = a[12];
          out[4] = a[1];
          out[5] = a[5];
          out[6] = a[9];
          out[7] = a[13];
          out[8] = a[2];
          out[9] = a[6];
          out[10] = a[10];
          out[11] = a[14];
          out[12] = a[3];
          out[13] = a[7];
          out[14] = a[11];
          out[15] = a[15];
        }
        return out;
      }
    }
  });

  // node_modules/gl-mat4/invert.js
  var require_invert = __commonJS({
    "node_modules/gl-mat4/invert.js"(exports, module) {
      module.exports = invert;
      function invert(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
          return null;
        }
        det = 1 / det;
        out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/adjoint.js
  var require_adjoint = __commonJS({
    "node_modules/gl-mat4/adjoint.js"(exports, module) {
      module.exports = adjoint;
      function adjoint(out, a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
        out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
        out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
        out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
        out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
        out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
        out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
        out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
        out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
        out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
        out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
        out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
        out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
        out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
        out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
        out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
        out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
        return out;
      }
    }
  });

  // node_modules/gl-mat4/determinant.js
  var require_determinant = __commonJS({
    "node_modules/gl-mat4/determinant.js"(exports, module) {
      module.exports = determinant;
      function determinant(a) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      }
    }
  });

  // node_modules/gl-mat4/multiply.js
  var require_multiply = __commonJS({
    "node_modules/gl-mat4/multiply.js"(exports, module) {
      module.exports = multiply;
      function multiply(out, a, b) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];
        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];
        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];
        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/translate.js
  var require_translate = __commonJS({
    "node_modules/gl-mat4/translate.js"(exports, module) {
      module.exports = translate;
      function translate(out, a, v) {
        var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
        if (a === out) {
          out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        } else {
          a00 = a[0];
          a01 = a[1];
          a02 = a[2];
          a03 = a[3];
          a10 = a[4];
          a11 = a[5];
          a12 = a[6];
          a13 = a[7];
          a20 = a[8];
          a21 = a[9];
          a22 = a[10];
          a23 = a[11];
          out[0] = a00;
          out[1] = a01;
          out[2] = a02;
          out[3] = a03;
          out[4] = a10;
          out[5] = a11;
          out[6] = a12;
          out[7] = a13;
          out[8] = a20;
          out[9] = a21;
          out[10] = a22;
          out[11] = a23;
          out[12] = a00 * x + a10 * y + a20 * z + a[12];
          out[13] = a01 * x + a11 * y + a21 * z + a[13];
          out[14] = a02 * x + a12 * y + a22 * z + a[14];
          out[15] = a03 * x + a13 * y + a23 * z + a[15];
        }
        return out;
      }
    }
  });

  // node_modules/gl-mat4/scale.js
  var require_scale = __commonJS({
    "node_modules/gl-mat4/scale.js"(exports, module) {
      module.exports = scale;
      function scale(out, a, v) {
        var x = v[0], y = v[1], z = v[2];
        out[0] = a[0] * x;
        out[1] = a[1] * x;
        out[2] = a[2] * x;
        out[3] = a[3] * x;
        out[4] = a[4] * y;
        out[5] = a[5] * y;
        out[6] = a[6] * y;
        out[7] = a[7] * y;
        out[8] = a[8] * z;
        out[9] = a[9] * z;
        out[10] = a[10] * z;
        out[11] = a[11] * z;
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotate.js
  var require_rotate = __commonJS({
    "node_modules/gl-mat4/rotate.js"(exports, module) {
      module.exports = rotate;
      function rotate(out, a, rad, axis) {
        var x = axis[0], y = axis[1], z = axis[2], len = Math.sqrt(x * x + y * y + z * z), s, c, t, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, b00, b01, b02, b10, b11, b12, b20, b21, b22;
        if (Math.abs(len) < 1e-6) {
          return null;
        }
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        b00 = x * x * t + c;
        b01 = y * x * t + z * s;
        b02 = z * x * t - y * s;
        b10 = x * y * t - z * s;
        b11 = y * y * t + c;
        b12 = z * y * t + x * s;
        b20 = x * z * t + y * s;
        b21 = y * z * t - x * s;
        b22 = z * z * t + c;
        out[0] = a00 * b00 + a10 * b01 + a20 * b02;
        out[1] = a01 * b00 + a11 * b01 + a21 * b02;
        out[2] = a02 * b00 + a12 * b01 + a22 * b02;
        out[3] = a03 * b00 + a13 * b01 + a23 * b02;
        out[4] = a00 * b10 + a10 * b11 + a20 * b12;
        out[5] = a01 * b10 + a11 * b11 + a21 * b12;
        out[6] = a02 * b10 + a12 * b11 + a22 * b12;
        out[7] = a03 * b10 + a13 * b11 + a23 * b12;
        out[8] = a00 * b20 + a10 * b21 + a20 * b22;
        out[9] = a01 * b20 + a11 * b21 + a21 * b22;
        out[10] = a02 * b20 + a12 * b21 + a22 * b22;
        out[11] = a03 * b20 + a13 * b21 + a23 * b22;
        if (a !== out) {
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotateX.js
  var require_rotateX = __commonJS({
    "node_modules/gl-mat4/rotateX.js"(exports, module) {
      module.exports = rotateX;
      function rotateX(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        if (a !== out) {
          out[0] = a[0];
          out[1] = a[1];
          out[2] = a[2];
          out[3] = a[3];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[4] = a10 * c + a20 * s;
        out[5] = a11 * c + a21 * s;
        out[6] = a12 * c + a22 * s;
        out[7] = a13 * c + a23 * s;
        out[8] = a20 * c - a10 * s;
        out[9] = a21 * c - a11 * s;
        out[10] = a22 * c - a12 * s;
        out[11] = a23 * c - a13 * s;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotateY.js
  var require_rotateY = __commonJS({
    "node_modules/gl-mat4/rotateY.js"(exports, module) {
      module.exports = rotateY;
      function rotateY(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        if (a !== out) {
          out[4] = a[4];
          out[5] = a[5];
          out[6] = a[6];
          out[7] = a[7];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[0] = a00 * c - a20 * s;
        out[1] = a01 * c - a21 * s;
        out[2] = a02 * c - a22 * s;
        out[3] = a03 * c - a23 * s;
        out[8] = a00 * s + a20 * c;
        out[9] = a01 * s + a21 * c;
        out[10] = a02 * s + a22 * c;
        out[11] = a03 * s + a23 * c;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/rotateZ.js
  var require_rotateZ = __commonJS({
    "node_modules/gl-mat4/rotateZ.js"(exports, module) {
      module.exports = rotateZ;
      function rotateZ(out, a, rad) {
        var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        if (a !== out) {
          out[8] = a[8];
          out[9] = a[9];
          out[10] = a[10];
          out[11] = a[11];
          out[12] = a[12];
          out[13] = a[13];
          out[14] = a[14];
          out[15] = a[15];
        }
        out[0] = a00 * c + a10 * s;
        out[1] = a01 * c + a11 * s;
        out[2] = a02 * c + a12 * s;
        out[3] = a03 * c + a13 * s;
        out[4] = a10 * c - a00 * s;
        out[5] = a11 * c - a01 * s;
        out[6] = a12 * c - a02 * s;
        out[7] = a13 * c - a03 * s;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromRotation.js
  var require_fromRotation = __commonJS({
    "node_modules/gl-mat4/fromRotation.js"(exports, module) {
      module.exports = fromRotation;
      function fromRotation(out, rad, axis) {
        var s, c, t;
        var x = axis[0];
        var y = axis[1];
        var z = axis[2];
        var len = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(len) < 1e-6) {
          return null;
        }
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(rad);
        c = Math.cos(rad);
        t = 1 - c;
        out[0] = x * x * t + c;
        out[1] = y * x * t + z * s;
        out[2] = z * x * t - y * s;
        out[3] = 0;
        out[4] = x * y * t - z * s;
        out[5] = y * y * t + c;
        out[6] = z * y * t + x * s;
        out[7] = 0;
        out[8] = x * z * t + y * s;
        out[9] = y * z * t - x * s;
        out[10] = z * z * t + c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromRotationTranslation.js
  var require_fromRotationTranslation = __commonJS({
    "node_modules/gl-mat4/fromRotationTranslation.js"(exports, module) {
      module.exports = fromRotationTranslation;
      function fromRotationTranslation(out, q, v) {
        var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
        out[0] = 1 - (yy + zz);
        out[1] = xy + wz;
        out[2] = xz - wy;
        out[3] = 0;
        out[4] = xy - wz;
        out[5] = 1 - (xx + zz);
        out[6] = yz + wx;
        out[7] = 0;
        out[8] = xz + wy;
        out[9] = yz - wx;
        out[10] = 1 - (xx + yy);
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromScaling.js
  var require_fromScaling = __commonJS({
    "node_modules/gl-mat4/fromScaling.js"(exports, module) {
      module.exports = fromScaling;
      function fromScaling(out, v) {
        out[0] = v[0];
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = v[1];
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = v[2];
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromTranslation.js
  var require_fromTranslation = __commonJS({
    "node_modules/gl-mat4/fromTranslation.js"(exports, module) {
      module.exports = fromTranslation;
      function fromTranslation(out, v) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = v[0];
        out[13] = v[1];
        out[14] = v[2];
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromXRotation.js
  var require_fromXRotation = __commonJS({
    "node_modules/gl-mat4/fromXRotation.js"(exports, module) {
      module.exports = fromXRotation;
      function fromXRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = c;
        out[6] = s;
        out[7] = 0;
        out[8] = 0;
        out[9] = -s;
        out[10] = c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromYRotation.js
  var require_fromYRotation = __commonJS({
    "node_modules/gl-mat4/fromYRotation.js"(exports, module) {
      module.exports = fromYRotation;
      function fromYRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out[0] = c;
        out[1] = 0;
        out[2] = -s;
        out[3] = 0;
        out[4] = 0;
        out[5] = 1;
        out[6] = 0;
        out[7] = 0;
        out[8] = s;
        out[9] = 0;
        out[10] = c;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromZRotation.js
  var require_fromZRotation = __commonJS({
    "node_modules/gl-mat4/fromZRotation.js"(exports, module) {
      module.exports = fromZRotation;
      function fromZRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        out[0] = c;
        out[1] = s;
        out[2] = 0;
        out[3] = 0;
        out[4] = -s;
        out[5] = c;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 1;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/fromQuat.js
  var require_fromQuat = __commonJS({
    "node_modules/gl-mat4/fromQuat.js"(exports, module) {
      module.exports = fromQuat;
      function fromQuat(out, q) {
        var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
        out[0] = 1 - yy - zz;
        out[1] = yx + wz;
        out[2] = zx - wy;
        out[3] = 0;
        out[4] = yx - wz;
        out[5] = 1 - xx - zz;
        out[6] = zy + wx;
        out[7] = 0;
        out[8] = zx + wy;
        out[9] = zy - wx;
        out[10] = 1 - xx - yy;
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/frustum.js
  var require_frustum = __commonJS({
    "node_modules/gl-mat4/frustum.js"(exports, module) {
      module.exports = frustum;
      function frustum(out, left, right, bottom, top, near, far) {
        var rl = 1 / (right - left), tb = 1 / (top - bottom), nf = 1 / (near - far);
        out[0] = near * 2 * rl;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = near * 2 * tb;
        out[6] = 0;
        out[7] = 0;
        out[8] = (right + left) * rl;
        out[9] = (top + bottom) * tb;
        out[10] = (far + near) * nf;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = far * near * 2 * nf;
        out[15] = 0;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/perspective.js
  var require_perspective = __commonJS({
    "node_modules/gl-mat4/perspective.js"(exports, module) {
      module.exports = perspective;
      function perspective(out, fovy, aspect, near, far) {
        var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
        out[0] = f / aspect;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = f;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = (far + near) * nf;
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = 2 * far * near * nf;
        out[15] = 0;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/perspectiveFromFieldOfView.js
  var require_perspectiveFromFieldOfView = __commonJS({
    "node_modules/gl-mat4/perspectiveFromFieldOfView.js"(exports, module) {
      module.exports = perspectiveFromFieldOfView;
      function perspectiveFromFieldOfView(out, fov, near, far) {
        var upTan = Math.tan(fov.upDegrees * Math.PI / 180), downTan = Math.tan(fov.downDegrees * Math.PI / 180), leftTan = Math.tan(fov.leftDegrees * Math.PI / 180), rightTan = Math.tan(fov.rightDegrees * Math.PI / 180), xScale = 2 / (leftTan + rightTan), yScale = 2 / (upTan + downTan);
        out[0] = xScale;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = yScale;
        out[6] = 0;
        out[7] = 0;
        out[8] = -((leftTan - rightTan) * xScale * 0.5);
        out[9] = (upTan - downTan) * yScale * 0.5;
        out[10] = far / (near - far);
        out[11] = -1;
        out[12] = 0;
        out[13] = 0;
        out[14] = far * near / (near - far);
        out[15] = 0;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/ortho.js
  var require_ortho = __commonJS({
    "node_modules/gl-mat4/ortho.js"(exports, module) {
      module.exports = ortho;
      function ortho(out, left, right, bottom, top, near, far) {
        var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
        out[0] = -2 * lr;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = -2 * bt;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 2 * nf;
        out[11] = 0;
        out[12] = (left + right) * lr;
        out[13] = (top + bottom) * bt;
        out[14] = (far + near) * nf;
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/lookAt.js
  var require_lookAt = __commonJS({
    "node_modules/gl-mat4/lookAt.js"(exports, module) {
      var identity = require_identity();
      module.exports = lookAt;
      function lookAt(out, eye, center, up) {
        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len, eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center[0], centery = center[1], centerz = center[2];
        if (Math.abs(eyex - centerx) < 1e-6 && Math.abs(eyey - centery) < 1e-6 && Math.abs(eyez - centerz) < 1e-6) {
          return identity(out);
        }
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
          x0 = 0;
          x1 = 0;
          x2 = 0;
        } else {
          len = 1 / len;
          x0 *= len;
          x1 *= len;
          x2 *= len;
        }
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;
        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
          y0 = 0;
          y1 = 0;
          y2 = 0;
        } else {
          len = 1 / len;
          y0 *= len;
          y1 *= len;
          y2 *= len;
        }
        out[0] = x0;
        out[1] = y0;
        out[2] = z0;
        out[3] = 0;
        out[4] = x1;
        out[5] = y1;
        out[6] = z1;
        out[7] = 0;
        out[8] = x2;
        out[9] = y2;
        out[10] = z2;
        out[11] = 0;
        out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        out[15] = 1;
        return out;
      }
    }
  });

  // node_modules/gl-mat4/str.js
  var require_str = __commonJS({
    "node_modules/gl-mat4/str.js"(exports, module) {
      module.exports = str;
      function str(a) {
        return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
      }
    }
  });

  // node_modules/gl-mat4/index.js
  var require_gl_mat4 = __commonJS({
    "node_modules/gl-mat4/index.js"(exports, module) {
      module.exports = {
        create: require_create(),
        clone: require_clone(),
        copy: require_copy(),
        identity: require_identity(),
        transpose: require_transpose(),
        invert: require_invert(),
        adjoint: require_adjoint(),
        determinant: require_determinant(),
        multiply: require_multiply(),
        translate: require_translate(),
        scale: require_scale(),
        rotate: require_rotate(),
        rotateX: require_rotateX(),
        rotateY: require_rotateY(),
        rotateZ: require_rotateZ(),
        fromRotation: require_fromRotation(),
        fromRotationTranslation: require_fromRotationTranslation(),
        fromScaling: require_fromScaling(),
        fromTranslation: require_fromTranslation(),
        fromXRotation: require_fromXRotation(),
        fromYRotation: require_fromYRotation(),
        fromZRotation: require_fromZRotation(),
        fromQuat: require_fromQuat(),
        frustum: require_frustum(),
        perspective: require_perspective(),
        perspectiveFromFieldOfView: require_perspectiveFromFieldOfView(),
        ortho: require_ortho(),
        lookAt: require_lookAt(),
        str: require_str()
      };
    }
  });

  // src/lib/matrix.js
  var require_matrix = __commonJS({
    "src/lib/matrix.js"(exports) {
      "use strict";
      var mat4X4 = require_gl_mat4();
      exports.init2dArray = function(rowLength, colLength) {
        var array = new Array(rowLength);
        for (var i = 0; i < rowLength; i++) array[i] = new Array(colLength);
        return array;
      };
      exports.transposeRagged = function(z) {
        var maxlen = 0;
        var zlen = z.length;
        var i, j;
        for (i = 0; i < zlen; i++) maxlen = Math.max(maxlen, z[i].length);
        var t = new Array(maxlen);
        for (i = 0; i < maxlen; i++) {
          t[i] = new Array(zlen);
          for (j = 0; j < zlen; j++) t[i][j] = z[j][i];
        }
        return t;
      };
      exports.dot = function(x, y) {
        if (!(x.length && y.length) || x.length !== y.length) return null;
        var len = x.length;
        var out;
        var i;
        if (x[0].length) {
          out = new Array(len);
          for (i = 0; i < len; i++) out[i] = exports.dot(x[i], y);
        } else if (y[0].length) {
          var yTranspose = exports.transposeRagged(y);
          out = new Array(yTranspose.length);
          for (i = 0; i < yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
        } else {
          out = 0;
          for (i = 0; i < len; i++) out += x[i] * y[i];
        }
        return out;
      };
      exports.translationMatrix = function(x, y) {
        return [[1, 0, x], [0, 1, y], [0, 0, 1]];
      };
      exports.rotationMatrix = function(alpha) {
        var a = alpha * Math.PI / 180;
        return [
          [Math.cos(a), -Math.sin(a), 0],
          [Math.sin(a), Math.cos(a), 0],
          [0, 0, 1]
        ];
      };
      exports.rotationXYMatrix = function(a, x, y) {
        return exports.dot(
          exports.dot(
            exports.translationMatrix(x, y),
            exports.rotationMatrix(a)
          ),
          exports.translationMatrix(-x, -y)
        );
      };
      exports.apply3DTransform = function(transform) {
        return function() {
          var args = arguments;
          var xyz = arguments.length === 1 ? args[0] : [args[0], args[1], args[2] || 0];
          return exports.dot(transform, [xyz[0], xyz[1], xyz[2], 1]).slice(0, 3);
        };
      };
      exports.apply2DTransform = function(transform) {
        return function() {
          var args = arguments;
          if (args.length === 3) {
            args = args[0];
          }
          var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];
          return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);
        };
      };
      exports.apply2DTransform2 = function(transform) {
        var at = exports.apply2DTransform(transform);
        return function(xys) {
          return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));
        };
      };
      exports.convertCssMatrix = function(m) {
        if (m) {
          var len = m.length;
          if (len === 16) return m;
          if (len === 6) {
            return [
              m[0],
              m[1],
              0,
              0,
              m[2],
              m[3],
              0,
              0,
              0,
              0,
              1,
              0,
              m[4],
              m[5],
              0,
              1
            ];
          }
        }
        return [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
      };
      exports.inverseTransformMatrix = function(m) {
        var out = [];
        mat4X4.invert(out, m);
        return [
          [out[0], out[1], out[2], out[3]],
          [out[4], out[5], out[6], out[7]],
          [out[8], out[9], out[10], out[11]],
          [out[12], out[13], out[14], out[15]]
        ];
      };
    }
  });

  // src/lib/dom.js
  var require_dom = __commonJS({
    "src/lib/dom.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var loggers = require_loggers();
      var matrix = require_matrix();
      var mat4X4 = require_gl_mat4();
      function getGraphDiv(gd) {
        var gdElement;
        if (typeof gd === "string") {
          gdElement = document.getElementById(gd);
          if (gdElement === null) {
            throw new Error("No DOM element with id '" + gd + "' exists on the page.");
          }
          return gdElement;
        } else if (gd === null || gd === void 0) {
          throw new Error("DOM element provided is null or undefined");
        }
        return gd;
      }
      function isPlotDiv(el) {
        var el3 = d3.select(el);
        return el3.node() instanceof HTMLElement && el3.size() && el3.classed("js-plotly-plot");
      }
      function removeElement(el) {
        var elParent = el && el.parentNode;
        if (elParent) elParent.removeChild(el);
      }
      function addStyleRule(selector, styleString) {
        addRelatedStyleRule("global", selector, styleString);
      }
      function addRelatedStyleRule(uid, selector, styleString) {
        var id = "plotly.js-style-" + uid;
        var style = document.getElementById(id);
        if (style && style.matches(".no-inline-styles")) {
          return;
        }
        if (!style) {
          style = document.createElement("style");
          style.setAttribute("id", id);
          style.appendChild(document.createTextNode(""));
          document.head.appendChild(style);
        }
        var styleSheet = style.sheet;
        if (!styleSheet) {
          loggers.warn("Cannot addRelatedStyleRule, probably due to strict CSP...");
        } else if (styleSheet.insertRule) {
          styleSheet.insertRule(selector + "{" + styleString + "}", 0);
        } else if (styleSheet.addRule) {
          styleSheet.addRule(selector, styleString, 0);
        } else loggers.warn("addStyleRule failed");
      }
      function deleteRelatedStyleRule(uid) {
        var id = "plotly.js-style-" + uid;
        var style = document.getElementById(id);
        if (style) removeElement(style);
      }
      function setStyleOnHover(selector, activeSelector, childSelector, activeStyle, inactiveStyle, element) {
        var activeStyleParts = activeStyle.split(":");
        var inactiveStyleParts = inactiveStyle.split(":");
        var eventAddedAttrName = "data-btn-style-event-added";
        if (!element) {
          element = document;
        }
        element.querySelectorAll(selector).forEach(function(el) {
          if (!el.getAttribute(eventAddedAttrName)) {
            el.addEventListener("mouseenter", function() {
              var childEl = this.querySelector(childSelector);
              if (childEl) {
                childEl.style[activeStyleParts[0]] = activeStyleParts[1];
              }
            });
            el.addEventListener("mouseleave", function() {
              var childEl = this.querySelector(childSelector);
              if (childEl) {
                if (activeSelector && this.matches(activeSelector)) {
                  childEl.style[activeStyleParts[0]] = activeStyleParts[1];
                } else {
                  childEl.style[inactiveStyleParts[0]] = inactiveStyleParts[1];
                }
              }
            });
            el.setAttribute(eventAddedAttrName, true);
          }
        });
      }
      function getFullTransformMatrix(element) {
        var allElements = getElementAndAncestors(element);
        var out = [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
        allElements.forEach(function(e) {
          var t = getElementTransformMatrix(e);
          if (t) {
            var m = matrix.convertCssMatrix(t);
            out = mat4X4.multiply(out, out, m);
          }
        });
        return out;
      }
      function getElementTransformMatrix(element) {
        var style = window.getComputedStyle(element, null);
        var transform = style.getPropertyValue("-webkit-transform") || style.getPropertyValue("-moz-transform") || style.getPropertyValue("-ms-transform") || style.getPropertyValue("-o-transform") || style.getPropertyValue("transform");
        if (transform === "none") return null;
        return transform.replace("matrix", "").replace("3d", "").slice(1, -1).split(",").map(function(n) {
          return +n;
        });
      }
      function getElementAndAncestors(element) {
        var allElements = [];
        while (isTransformableElement(element)) {
          allElements.push(element);
          element = element.parentNode;
          if (typeof ShadowRoot === "function" && element instanceof ShadowRoot) {
            element = element.host;
          }
        }
        return allElements;
      }
      function isTransformableElement(element) {
        return element && (element instanceof Element || element instanceof HTMLElement);
      }
      function equalDomRects(a, b) {
        return a && b && a.top === b.top && a.left === b.left && a.right === b.right && a.bottom === b.bottom;
      }
      module.exports = {
        getGraphDiv,
        isPlotDiv,
        removeElement,
        addStyleRule,
        addRelatedStyleRule,
        deleteRelatedStyleRule,
        setStyleOnHover,
        getFullTransformMatrix,
        getElementTransformMatrix,
        getElementAndAncestors,
        equalDomRects
      };
    }
  });

  // src/plots/animation_attributes.js
  var require_animation_attributes = __commonJS({
    "src/plots/animation_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        mode: {
          valType: "enumerated",
          dflt: "afterall",
          values: ["immediate", "next", "afterall"]
        },
        direction: {
          valType: "enumerated",
          values: ["forward", "reverse"],
          dflt: "forward"
        },
        fromcurrent: {
          valType: "boolean",
          dflt: false
        },
        frame: {
          duration: {
            valType: "number",
            min: 0,
            dflt: 500
          },
          redraw: {
            valType: "boolean",
            dflt: true
          }
        },
        transition: {
          duration: {
            valType: "number",
            min: 0,
            dflt: 500,
            editType: "none"
          },
          easing: {
            valType: "enumerated",
            dflt: "cubic-in-out",
            values: [
              "linear",
              "quad",
              "cubic",
              "sin",
              "exp",
              "circle",
              "elastic",
              "back",
              "bounce",
              "linear-in",
              "quad-in",
              "cubic-in",
              "sin-in",
              "exp-in",
              "circle-in",
              "elastic-in",
              "back-in",
              "bounce-in",
              "linear-out",
              "quad-out",
              "cubic-out",
              "sin-out",
              "exp-out",
              "circle-out",
              "elastic-out",
              "back-out",
              "bounce-out",
              "linear-in-out",
              "quad-in-out",
              "cubic-in-out",
              "sin-in-out",
              "exp-in-out",
              "circle-in-out",
              "elastic-in-out",
              "back-in-out",
              "bounce-in-out"
            ],
            editType: "none"
          },
          ordering: {
            valType: "enumerated",
            values: ["layout first", "traces first"],
            dflt: "layout first",
            editType: "none"
          }
        }
      };
    }
  });

  // src/plot_api/edit_types.js
  var require_edit_types = __commonJS({
    "src/plot_api/edit_types.js"(exports, module) {
      "use strict";
      var extendFlat = require_extend().extendFlat;
      var isPlainObject = require_is_plain_object();
      var traceOpts = {
        valType: "flaglist",
        extras: ["none"],
        flags: ["calc", "clearAxisTypes", "plot", "style", "markerSize", "colorbars"]
      };
      var layoutOpts = {
        valType: "flaglist",
        extras: ["none"],
        flags: [
          "calc",
          "plot",
          "legend",
          "ticks",
          "axrange",
          "layoutstyle",
          "modebar",
          "camera",
          "arraydraw",
          "colorbars"
        ]
      };
      var traceEditTypeFlags = traceOpts.flags.slice().concat(["fullReplot"]);
      var layoutEditTypeFlags = layoutOpts.flags.slice().concat("layoutReplot");
      module.exports = {
        traces: traceOpts,
        layout: layoutOpts,
        /*
         * default (all false) edit flags for restyle (traces)
         * creates a new object each call, so the caller can mutate freely
         */
        traceFlags: function() {
          return falseObj(traceEditTypeFlags);
        },
        /*
         * default (all false) edit flags for relayout
         * creates a new object each call, so the caller can mutate freely
         */
        layoutFlags: function() {
          return falseObj(layoutEditTypeFlags);
        },
        /*
         * update `flags` with the `editType` values found in `attr`
         */
        update: function(flags, attr) {
          var editType = attr.editType;
          if (editType && editType !== "none") {
            var editTypeParts = editType.split("+");
            for (var i = 0; i < editTypeParts.length; i++) {
              flags[editTypeParts[i]] = true;
            }
          }
        },
        overrideAll
      };
      function falseObj(keys) {
        var out = {};
        for (var i = 0; i < keys.length; i++) out[keys[i]] = false;
        return out;
      }
      function overrideAll(attrs, editTypeOverride, overrideContainers) {
        var out = extendFlat({}, attrs);
        for (var key in out) {
          var attr = out[key];
          if (isPlainObject(attr)) {
            out[key] = overrideOne(attr, editTypeOverride, overrideContainers, key);
          }
        }
        if (overrideContainers === "from-root") out.editType = editTypeOverride;
        return out;
      }
      function overrideOne(attr, editTypeOverride, overrideContainers, key) {
        if (attr.valType) {
          var out = extendFlat({}, attr);
          out.editType = editTypeOverride;
          if (Array.isArray(attr.items)) {
            out.items = new Array(attr.items.length);
            for (var i = 0; i < attr.items.length; i++) {
              out.items[i] = overrideOne(attr.items[i], editTypeOverride, "from-root");
            }
          }
          return out;
        } else {
          return overrideAll(
            attr,
            editTypeOverride,
            key.charAt(0) === "_" ? "nested" : "from-root"
          );
        }
      }
    }
  });

  // src/components/drawing/attributes.js
  var require_attributes4 = __commonJS({
    "src/components/drawing/attributes.js"(exports) {
      "use strict";
      exports.dash = {
        valType: "string",
        // string type usually doesn't take values... this one should really be
        // a special type or at least a special coercion function, from the GUI
        // you only get these values but elsewhere the user can supply a list of
        // dash lengths in px, and it will be honored
        values: ["solid", "dot", "dash", "longdash", "dashdot", "longdashdot"],
        dflt: "solid",
        editType: "style"
      };
      exports.pattern = {
        shape: {
          valType: "enumerated",
          values: ["", "/", "\\", "x", "-", "|", "+", "."],
          dflt: "",
          arrayOk: true,
          editType: "style"
        },
        fillmode: {
          valType: "enumerated",
          values: ["replace", "overlay"],
          dflt: "replace",
          editType: "style"
        },
        bgcolor: {
          valType: "color",
          arrayOk: true,
          editType: "style"
        },
        fgcolor: {
          valType: "color",
          arrayOk: true,
          editType: "style"
        },
        fgopacity: {
          valType: "number",
          editType: "style",
          min: 0,
          max: 1
        },
        size: {
          valType: "number",
          min: 0,
          dflt: 8,
          arrayOk: true,
          editType: "style"
        },
        solidity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0.3,
          arrayOk: true,
          editType: "style"
        },
        editType: "style"
      };
    }
  });

  // src/constants/docs.js
  var require_docs = __commonJS({
    "src/constants/docs.js"(exports, module) {
      "use strict";
      module.exports = {
        FORMAT_LINK: "https://github.com/d3/d3-format/tree/v1.4.5#d3-format",
        DATE_FORMAT_LINK: "https://github.com/d3/d3-time-format/tree/v2.2.3#locale_format"
      };
    }
  });

  // src/plots/template_attributes.js
  var require_template_attributes = __commonJS({
    "src/plots/template_attributes.js"(exports) {
      "use strict";
      var docs = require_docs();
      var FORMAT_LINK = docs.FORMAT_LINK;
      var DATE_FORMAT_LINK = docs.DATE_FORMAT_LINK;
      function describeVariables(extra) {
        var descPart = extra.description ? " " + extra.description : "";
        var keys = extra.keys || [];
        if (keys.length > 0) {
          var quotedKeys = [];
          for (var i = 0; i < keys.length; i++) {
            quotedKeys[i] = "`" + keys[i] + "`";
          }
          descPart = descPart + "Finally, the template string has access to ";
          if (keys.length === 1) {
            descPart = descPart + "variable " + quotedKeys[0];
          } else {
            descPart = descPart + "variables " + quotedKeys.slice(0, -1).join(", ") + " and " + quotedKeys.slice(-1) + ".";
          }
        }
        return descPart;
      }
      exports.hovertemplateAttrs = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var descPart = describeVariables(extra);
        var hovertemplate = {
          valType: "string",
          dflt: "",
          editType: opts.editType || "none"
        };
        if (opts.arrayOk !== false) {
          hovertemplate.arrayOk = true;
        }
        return hovertemplate;
      };
      exports.texttemplateAttrs = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var descPart = describeVariables(extra);
        var texttemplate = {
          valType: "string",
          dflt: "",
          editType: opts.editType || "calc"
        };
        if (opts.arrayOk !== false) {
          texttemplate.arrayOk = true;
        }
        return texttemplate;
      };
      exports.shapeTexttemplateAttrs = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var newStr = opts.newshape ? "new " : "";
        var descPart = describeVariables(extra);
        var texttemplate = {
          valType: "string",
          dflt: "",
          editType: opts.editType || "arraydraw"
        };
        return texttemplate;
      };
    }
  });

  // src/components/shapes/label_texttemplate.js
  var require_label_texttemplate = __commonJS({
    "src/components/shapes/label_texttemplate.js"(exports, module) {
      "use strict";
      function d2l(v, axis) {
        return axis ? axis.d2l(v) : v;
      }
      function l2d(v, axis) {
        return axis ? axis.l2d(v) : v;
      }
      function x0Fn(shape) {
        return shape.x0;
      }
      function x1Fn(shape) {
        return shape.x1;
      }
      function y0Fn(shape) {
        return shape.y0;
      }
      function y1Fn(shape) {
        return shape.y1;
      }
      function x0shiftFn(shape) {
        return shape.x0shift || 0;
      }
      function x1shiftFn(shape) {
        return shape.x1shift || 0;
      }
      function y0shiftFn(shape) {
        return shape.y0shift || 0;
      }
      function y1shiftFn(shape) {
        return shape.y1shift || 0;
      }
      function dxFn(shape, xa) {
        return d2l(shape.x1, xa) + x1shiftFn(shape) - d2l(shape.x0, xa) - x0shiftFn(shape);
      }
      function dyFn(shape, xa, ya) {
        return d2l(shape.y1, ya) + y1shiftFn(shape) - d2l(shape.y0, ya) - y0shiftFn(shape);
      }
      function widthFn(shape, xa) {
        return Math.abs(dxFn(shape, xa));
      }
      function heightFn(shape, xa, ya) {
        return Math.abs(dyFn(shape, xa, ya));
      }
      function lengthFn(shape, xa, ya) {
        return shape.type !== "line" ? void 0 : Math.sqrt(
          Math.pow(dxFn(shape, xa), 2) + Math.pow(dyFn(shape, xa, ya), 2)
        );
      }
      function xcenterFn(shape, xa) {
        return l2d((d2l(shape.x1, xa) + x1shiftFn(shape) + d2l(shape.x0, xa) + x0shiftFn(shape)) / 2, xa);
      }
      function ycenterFn(shape, xa, ya) {
        return l2d((d2l(shape.y1, ya) + y1shiftFn(shape) + d2l(shape.y0, ya) + y0shiftFn(shape)) / 2, ya);
      }
      function slopeFn(shape, xa, ya) {
        return shape.type !== "line" ? void 0 : dyFn(shape, xa, ya) / dxFn(shape, xa);
      }
      module.exports = {
        x0: x0Fn,
        x1: x1Fn,
        y0: y0Fn,
        y1: y1Fn,
        slope: slopeFn,
        dx: dxFn,
        dy: dyFn,
        width: widthFn,
        height: heightFn,
        length: lengthFn,
        xcenter: xcenterFn,
        ycenter: ycenterFn
      };
    }
  });

  // src/components/shapes/draw_newshape/attributes.js
  var require_attributes5 = __commonJS({
    "src/components/shapes/draw_newshape/attributes.js"(exports, module) {
      "use strict";
      var overrideAll = require_edit_types().overrideAll;
      var basePlotAttributes = require_attributes2();
      var fontAttrs = require_font_attributes();
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var shapeTexttemplateAttrs = require_template_attributes().shapeTexttemplateAttrs;
      var shapeLabelTexttemplateVars = require_label_texttemplate();
      module.exports = overrideAll({
        newshape: {
          visible: extendFlat({}, basePlotAttributes.visible, {}),
          showlegend: {
            valType: "boolean",
            dflt: false
          },
          legend: extendFlat({}, basePlotAttributes.legend, {}),
          legendgroup: extendFlat({}, basePlotAttributes.legendgroup, {}),
          legendgrouptitle: {
            text: extendFlat({}, basePlotAttributes.legendgrouptitle.text, {}),
            font: fontAttrs({})
          },
          legendrank: extendFlat({}, basePlotAttributes.legendrank, {}),
          legendwidth: extendFlat({}, basePlotAttributes.legendwidth, {}),
          line: {
            color: {
              valType: "color"
            },
            width: {
              valType: "number",
              min: 0,
              dflt: 4
            },
            dash: extendFlat({}, dash, {
              dflt: "solid"
            })
          },
          fillcolor: {
            valType: "color",
            dflt: "rgba(0,0,0,0)"
          },
          fillrule: {
            valType: "enumerated",
            values: ["evenodd", "nonzero"],
            dflt: "evenodd"
          },
          opacity: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 1
          },
          layer: {
            valType: "enumerated",
            values: ["below", "above", "between"],
            dflt: "above"
          },
          drawdirection: {
            valType: "enumerated",
            values: ["ortho", "horizontal", "vertical", "diagonal"],
            dflt: "diagonal"
          },
          name: extendFlat({}, basePlotAttributes.name, {}),
          label: {
            text: {
              valType: "string",
              dflt: ""
            },
            texttemplate: shapeTexttemplateAttrs({ newshape: true }, { keys: Object.keys(shapeLabelTexttemplateVars) }),
            font: fontAttrs({}),
            textposition: {
              valType: "enumerated",
              values: [
                "top left",
                "top center",
                "top right",
                "middle left",
                "middle center",
                "middle right",
                "bottom left",
                "bottom center",
                "bottom right",
                "start",
                "middle",
                "end"
              ]
            },
            textangle: {
              valType: "angle",
              dflt: "auto"
            },
            xanchor: {
              valType: "enumerated",
              values: ["auto", "left", "center", "right"],
              dflt: "auto"
            },
            yanchor: {
              valType: "enumerated",
              values: ["top", "middle", "bottom"]
            },
            padding: {
              valType: "number",
              dflt: 3,
              min: 0
            }
          }
        },
        activeshape: {
          fillcolor: {
            valType: "color",
            dflt: "rgb(255,0,255)"
          },
          opacity: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 0.5
          }
        }
      }, "none", "from-root");
    }
  });

  // src/components/selections/draw_newselection/attributes.js
  var require_attributes6 = __commonJS({
    "src/components/selections/draw_newselection/attributes.js"(exports, module) {
      "use strict";
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      module.exports = {
        newselection: {
          mode: {
            valType: "enumerated",
            values: ["immediate", "gradual"],
            dflt: "immediate",
            editType: "none"
          },
          line: {
            color: {
              valType: "color",
              editType: "none"
            },
            width: {
              valType: "number",
              min: 1,
              dflt: 1,
              editType: "none"
            },
            dash: extendFlat({}, dash, {
              dflt: "dot",
              editType: "none"
            }),
            editType: "none"
          },
          // no drawdirection here noting that layout.selectdirection is used instead.
          editType: "none"
        },
        activeselection: {
          fillcolor: {
            valType: "color",
            dflt: "rgba(0,0,0,0)",
            editType: "none"
          },
          opacity: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 0.5,
            editType: "none"
          },
          editType: "none"
        }
      };
    }
  });

  // src/plots/pad_attributes.js
  var require_pad_attributes = __commonJS({
    "src/plots/pad_attributes.js"(exports, module) {
      "use strict";
      module.exports = function(opts) {
        var editType = opts.editType;
        return {
          t: {
            valType: "number",
            dflt: 0,
            editType
          },
          r: {
            valType: "number",
            dflt: 0,
            editType
          },
          b: {
            valType: "number",
            dflt: 0,
            editType
          },
          l: {
            valType: "number",
            dflt: 0,
            editType
          },
          editType
        };
      };
    }
  });

  // src/plots/layout_attributes.js
  var require_layout_attributes2 = __commonJS({
    "src/plots/layout_attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var animationAttrs = require_animation_attributes();
      var colorAttrs = require_attributes3();
      var drawNewShapeAttrs = require_attributes5();
      var drawNewSelectionAttrs = require_attributes6();
      var padAttrs = require_pad_attributes();
      var extendFlat = require_extend().extendFlat;
      var globalFont = fontAttrs({
        editType: "calc"
      });
      globalFont.family.dflt = '"Open Sans", verdana, arial, sans-serif';
      globalFont.size.dflt = 12;
      globalFont.color.dflt = colorAttrs.defaultLine;
      module.exports = {
        font: globalFont,
        title: {
          text: {
            valType: "string",
            editType: "layoutstyle"
          },
          font: fontAttrs({
            editType: "layoutstyle"
          }),
          subtitle: {
            text: {
              valType: "string",
              editType: "layoutstyle"
            },
            font: fontAttrs({
              editType: "layoutstyle"
            }),
            editType: "layoutstyle"
          },
          xref: {
            valType: "enumerated",
            dflt: "container",
            values: ["container", "paper"],
            editType: "layoutstyle"
          },
          yref: {
            valType: "enumerated",
            dflt: "container",
            values: ["container", "paper"],
            editType: "layoutstyle"
          },
          x: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: 0.5,
            editType: "layoutstyle"
          },
          y: {
            valType: "number",
            min: 0,
            max: 1,
            dflt: "auto",
            editType: "layoutstyle"
          },
          xanchor: {
            valType: "enumerated",
            dflt: "auto",
            values: ["auto", "left", "center", "right"],
            editType: "layoutstyle"
          },
          yanchor: {
            valType: "enumerated",
            dflt: "auto",
            values: ["auto", "top", "middle", "bottom"],
            editType: "layoutstyle"
          },
          pad: extendFlat(padAttrs({ editType: "layoutstyle" }), {}),
          automargin: {
            valType: "boolean",
            dflt: false,
            editType: "plot"
          },
          editType: "layoutstyle"
        },
        uniformtext: {
          mode: {
            valType: "enumerated",
            values: [false, "hide", "show"],
            dflt: false,
            editType: "plot"
          },
          minsize: {
            valType: "number",
            min: 0,
            dflt: 0,
            editType: "plot"
          },
          editType: "plot"
        },
        autosize: {
          valType: "boolean",
          dflt: false,
          // autosize, width, and height get special editType treatment in _relayout
          // so we can handle noop resizes more efficiently
          editType: "none"
        },
        width: {
          valType: "number",
          min: 10,
          dflt: 700,
          editType: "plot"
        },
        height: {
          valType: "number",
          min: 10,
          dflt: 450,
          editType: "plot"
        },
        minreducedwidth: {
          valType: "number",
          min: 2,
          dflt: 64,
          editType: "plot"
        },
        minreducedheight: {
          valType: "number",
          min: 2,
          dflt: 64,
          editType: "plot"
        },
        margin: {
          l: {
            valType: "number",
            min: 0,
            dflt: 80,
            editType: "plot"
          },
          r: {
            valType: "number",
            min: 0,
            dflt: 80,
            editType: "plot"
          },
          t: {
            valType: "number",
            min: 0,
            dflt: 100,
            editType: "plot"
          },
          b: {
            valType: "number",
            min: 0,
            dflt: 80,
            editType: "plot"
          },
          pad: {
            valType: "number",
            min: 0,
            dflt: 0,
            editType: "plot"
          },
          autoexpand: {
            valType: "boolean",
            dflt: true,
            editType: "plot"
          },
          editType: "plot"
        },
        computed: {
          valType: "any",
          editType: "none"
        },
        paper_bgcolor: {
          valType: "color",
          dflt: colorAttrs.background,
          editType: "plot"
        },
        plot_bgcolor: {
          // defined here, but set in cartesian.supplyLayoutDefaults
          // because it needs to know if there are (2D) axes or not
          valType: "color",
          dflt: colorAttrs.background,
          editType: "layoutstyle"
        },
        autotypenumbers: {
          valType: "enumerated",
          values: ["convert types", "strict"],
          dflt: "convert types",
          editType: "calc"
        },
        separators: {
          valType: "string",
          editType: "plot"
        },
        hidesources: {
          valType: "boolean",
          dflt: false,
          editType: "plot"
        },
        showlegend: {
          // handled in legend.supplyLayoutDefaults
          // but included here because it's not in the legend object
          valType: "boolean",
          editType: "legend"
        },
        colorway: {
          valType: "colorlist",
          dflt: colorAttrs.defaults,
          editType: "calc"
        },
        datarevision: {
          valType: "any",
          editType: "calc"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        editrevision: {
          valType: "any",
          editType: "none"
        },
        selectionrevision: {
          valType: "any",
          editType: "none"
        },
        template: {
          valType: "any",
          editType: "calc"
        },
        newshape: drawNewShapeAttrs.newshape,
        activeshape: drawNewShapeAttrs.activeshape,
        newselection: drawNewSelectionAttrs.newselection,
        activeselection: drawNewSelectionAttrs.activeselection,
        meta: {
          valType: "any",
          arrayOk: true,
          editType: "plot"
        },
        transition: extendFlat({}, animationAttrs.transition, {
          editType: "none"
        })
      };
    }
  });

  // temp_stylePlugin:node_modules/maplibre-gl/dist/maplibre-gl.css
  var init_maplibre_gl = __esm({
    "temp_stylePlugin:node_modules/maplibre-gl/dist/maplibre-gl.css"() {
    }
  });

  // stylePlugin:/Users/ekl/code/plotly.js/node_modules/maplibre-gl/dist/maplibre-gl.css
  var maplibre_gl_exports = {};
  var init_maplibre_gl2 = __esm({
    "stylePlugin:/Users/ekl/code/plotly.js/node_modules/maplibre-gl/dist/maplibre-gl.css"() {
      init_maplibre_gl();
    }
  });

  // src/registry.js
  var require_registry = __commonJS({
    "src/registry.js"(exports) {
      "use strict";
      var Loggers = require_loggers();
      var noop = require_noop();
      var pushUnique = require_push_unique();
      var isPlainObject = require_is_plain_object();
      var addStyleRule = require_dom().addStyleRule;
      var ExtendModule = require_extend();
      var basePlotAttributes = require_attributes2();
      var baseLayoutAttributes = require_layout_attributes2();
      var extendFlat = ExtendModule.extendFlat;
      var extendDeepAll = ExtendModule.extendDeepAll;
      exports.modules = {};
      exports.allCategories = {};
      exports.allTypes = [];
      exports.subplotsRegistry = {};
      exports.componentsRegistry = {};
      exports.layoutArrayContainers = [];
      exports.layoutArrayRegexes = [];
      exports.traceLayoutAttributes = {};
      exports.localeRegistry = {};
      exports.apiMethodRegistry = {};
      exports.collectableSubplotTypes = null;
      exports.register = function register(_modules) {
        exports.collectableSubplotTypes = null;
        if (!_modules) {
          throw new Error("No argument passed to Plotly.register.");
        } else if (_modules && !Array.isArray(_modules)) {
          _modules = [_modules];
        }
        for (var i = 0; i < _modules.length; i++) {
          var newModule = _modules[i];
          if (!newModule) {
            throw new Error("Invalid module was attempted to be registered!");
          }
          switch (newModule.moduleType) {
            case "trace":
              registerTraceModule(newModule);
              break;
            case "transform":
              registerTransformModule(newModule);
              break;
            case "component":
              registerComponentModule(newModule);
              break;
            case "locale":
              registerLocale(newModule);
              break;
            case "apiMethod":
              var name = newModule.name;
              exports.apiMethodRegistry[name] = newModule.fn;
              break;
            default:
              throw new Error("Invalid module was attempted to be registered!");
          }
        }
      };
      exports.getModule = function(trace) {
        var _module = exports.modules[getTraceType(trace)];
        if (!_module) return false;
        return _module._module;
      };
      exports.traceIs = function(traceType, category) {
        traceType = getTraceType(traceType);
        if (traceType === "various") return false;
        var _module = exports.modules[traceType];
        if (!_module) {
          if (traceType) {
            Loggers.log("Unrecognized trace type " + traceType + ".");
          }
          _module = exports.modules[basePlotAttributes.type.dflt];
        }
        return !!_module.categories[category];
      };
      exports.getComponentMethod = function(name, method) {
        var _module = exports.componentsRegistry[name];
        if (!_module) return noop;
        return _module[method] || noop;
      };
      exports.call = function() {
        var name = arguments[0];
        var args = [].slice.call(arguments, 1);
        return exports.apiMethodRegistry[name].apply(null, args);
      };
      function registerTraceModule(_module) {
        var thisType = _module.name;
        var categoriesIn = _module.categories;
        var meta = _module.meta;
        if (exports.modules[thisType]) {
          Loggers.log("Type " + thisType + " already registered");
          return;
        }
        if (!exports.subplotsRegistry[_module.basePlotModule.name]) {
          registerSubplot(_module.basePlotModule);
        }
        var categoryObj = {};
        for (var i = 0; i < categoriesIn.length; i++) {
          categoryObj[categoriesIn[i]] = true;
          exports.allCategories[categoriesIn[i]] = true;
        }
        exports.modules[thisType] = {
          _module,
          categories: categoryObj
        };
        if (meta && Object.keys(meta).length) {
          exports.modules[thisType].meta = meta;
        }
        exports.allTypes.push(thisType);
        for (var componentName in exports.componentsRegistry) {
          mergeComponentAttrsToTrace(componentName, thisType);
        }
        if (_module.layoutAttributes) {
          extendFlat(exports.traceLayoutAttributes, _module.layoutAttributes);
        }
        var basePlotModule = _module.basePlotModule;
        var bpmName = basePlotModule.name;
        if (bpmName === "mapbox") {
          var styleRules = basePlotModule.constants.styleRules;
          for (var k in styleRules) {
            addStyleRule(".js-plotly-plot .plotly .mapboxgl-" + k, styleRules[k]);
          }
        }
        if (bpmName === "map") {
          init_maplibre_gl2();
        }
        if ((bpmName === "geo" || bpmName === "mapbox" || bpmName === "map") && window.PlotlyGeoAssets === void 0) {
          window.PlotlyGeoAssets = { topojson: {} };
        }
      }
      function registerSubplot(_module) {
        var plotType = _module.name;
        if (exports.subplotsRegistry[plotType]) {
          Loggers.log("Plot type " + plotType + " already registered.");
          return;
        }
        findArrayRegexps(_module);
        exports.subplotsRegistry[plotType] = _module;
        for (var componentName in exports.componentsRegistry) {
          mergeComponentAttrsToSubplot(componentName, _module.name);
        }
      }
      function registerComponentModule(_module) {
        if (typeof _module.name !== "string") {
          throw new Error("Component module *name* must be a string.");
        }
        var name = _module.name;
        exports.componentsRegistry[name] = _module;
        if (_module.layoutAttributes) {
          if (_module.layoutAttributes._isLinkedToArray) {
            pushUnique(exports.layoutArrayContainers, name);
          }
          findArrayRegexps(_module);
        }
        for (var traceType in exports.modules) {
          mergeComponentAttrsToTrace(name, traceType);
        }
        for (var subplotName in exports.subplotsRegistry) {
          mergeComponentAttrsToSubplot(name, subplotName);
        }
        if (_module.schema && _module.schema.layout) {
          extendDeepAll(baseLayoutAttributes, _module.schema.layout);
        }
      }
      function registerTransformModule(_module) {
        if (typeof _module.name !== "string") {
          throw new Error("Transform module *name* must be a string.");
        }
        var prefix = "Transform module " + _module.name;
        var hasTransform = typeof _module.transform === "function";
        var hasCalcTransform = typeof _module.calcTransform === "function";
        if (!hasTransform && !hasCalcTransform) {
          throw new Error(prefix + " is missing a *transform* or *calcTransform* method.");
        }
        if (hasTransform && hasCalcTransform) {
          Loggers.log([
            prefix + " has both a *transform* and *calcTransform* methods.",
            "Please note that all *transform* methods are executed",
            "before all *calcTransform* methods."
          ].join(" "));
        }
        if (!isPlainObject(_module.attributes)) {
          Loggers.log(prefix + " registered without an *attributes* object.");
        }
        if (typeof _module.supplyDefaults !== "function") {
          Loggers.log(prefix + " registered without a *supplyDefaults* method.");
        }
      }
      function registerLocale(_module) {
        var locale = _module.name;
        var baseLocale = locale.split("-")[0];
        var newDict = _module.dictionary;
        var newFormat = _module.format;
        var hasDict = newDict && Object.keys(newDict).length;
        var hasFormat = newFormat && Object.keys(newFormat).length;
        var locales = exports.localeRegistry;
        var localeObj = locales[locale];
        if (!localeObj) locales[locale] = localeObj = {};
        if (baseLocale !== locale) {
          var baseLocaleObj = locales[baseLocale];
          if (!baseLocaleObj) locales[baseLocale] = baseLocaleObj = {};
          if (hasDict && baseLocaleObj.dictionary === localeObj.dictionary) {
            baseLocaleObj.dictionary = newDict;
          }
          if (hasFormat && baseLocaleObj.format === localeObj.format) {
            baseLocaleObj.format = newFormat;
          }
        }
        if (hasDict) localeObj.dictionary = newDict;
        if (hasFormat) localeObj.format = newFormat;
      }
      function findArrayRegexps(_module) {
        if (_module.layoutAttributes) {
          var arrayAttrRegexps = _module.layoutAttributes._arrayAttrRegexps;
          if (arrayAttrRegexps) {
            for (var i = 0; i < arrayAttrRegexps.length; i++) {
              pushUnique(exports.layoutArrayRegexes, arrayAttrRegexps[i]);
            }
          }
        }
      }
      function mergeComponentAttrsToTrace(componentName, traceType) {
        var componentSchema = exports.componentsRegistry[componentName].schema;
        if (!componentSchema || !componentSchema.traces) return;
        var traceAttrs = componentSchema.traces[traceType];
        if (traceAttrs) {
          extendDeepAll(exports.modules[traceType]._module.attributes, traceAttrs);
        }
      }
      function mergeComponentAttrsToSubplot(componentName, subplotName) {
        var componentSchema = exports.componentsRegistry[componentName].schema;
        if (!componentSchema || !componentSchema.subplots) return;
        var subplotModule = exports.subplotsRegistry[subplotName];
        var subplotAttrs = subplotModule.layoutAttributes;
        var subplotAttr = subplotModule.attr === "subplot" ? subplotModule.name : subplotModule.attr;
        if (Array.isArray(subplotAttr)) subplotAttr = subplotAttr[0];
        var componentLayoutAttrs = componentSchema.subplots[subplotAttr];
        if (subplotAttrs && componentLayoutAttrs) {
          extendDeepAll(subplotAttrs, componentLayoutAttrs);
        }
      }
      function getTraceType(traceType) {
        if (typeof traceType === "object") traceType = traceType.type;
        return traceType;
      }
    }
  });

  // src/lib/dates.js
  var require_dates = __commonJS({
    "src/lib/dates.js"(exports) {
      "use strict";
      var timeFormat = require_d3_time_format().timeFormat;
      var isNumeric = require_fast_isnumeric();
      var Loggers = require_loggers();
      var mod = require_mod().mod;
      var constants = require_numerical();
      var BADNUM = constants.BADNUM;
      var ONEDAY = constants.ONEDAY;
      var ONEHOUR = constants.ONEHOUR;
      var ONEMIN = constants.ONEMIN;
      var ONESEC = constants.ONESEC;
      var EPOCHJD = constants.EPOCHJD;
      var Registry = require_registry();
      var utcFormat = require_d3_time_format().utcFormat;
      var DATETIME_REGEXP = /^\s*(-?\d\d\d\d|\d\d)(-(\d?\d)(-(\d?\d)([ Tt]([01]?\d|2[0-3])(:([0-5]\d)(:([0-5]\d(\.\d+)?))?(Z|z|[+\-]\d\d(:?\d\d)?)?)?)?)?)?\s*$/m;
      var DATETIME_REGEXP_CN = /^\s*(-?\d\d\d\d|\d\d)(-(\d?\di?)(-(\d?\d)([ Tt]([01]?\d|2[0-3])(:([0-5]\d)(:([0-5]\d(\.\d+)?))?(Z|z|[+\-]\d\d(:?\d\d)?)?)?)?)?)?\s*$/m;
      var YFIRST = (/* @__PURE__ */ new Date()).getFullYear() - 70;
      function isWorldCalendar(calendar) {
        return calendar && Registry.componentsRegistry.calendars && typeof calendar === "string" && calendar !== "gregorian";
      }
      exports.dateTick0 = function(calendar, dayOfWeek) {
        var tick0 = _dateTick0(calendar, !!dayOfWeek);
        if (dayOfWeek < 2) return tick0;
        var v = exports.dateTime2ms(tick0, calendar);
        v += ONEDAY * (dayOfWeek - 1);
        return exports.ms2DateTime(v, 0, calendar);
      };
      function _dateTick0(calendar, sunday) {
        if (isWorldCalendar(calendar)) {
          return sunday ? Registry.getComponentMethod("calendars", "CANONICAL_SUNDAY")[calendar] : Registry.getComponentMethod("calendars", "CANONICAL_TICK")[calendar];
        } else {
          return sunday ? "2000-01-02" : "2000-01-01";
        }
      }
      exports.dfltRange = function(calendar) {
        if (isWorldCalendar(calendar)) {
          return Registry.getComponentMethod("calendars", "DFLTRANGE")[calendar];
        } else {
          return ["2000-01-01", "2001-01-01"];
        }
      };
      exports.isJSDate = function(v) {
        return typeof v === "object" && v !== null && typeof v.getTime === "function";
      };
      var MIN_MS;
      var MAX_MS;
      exports.dateTime2ms = function(s, calendar) {
        if (exports.isJSDate(s)) {
          var tzOffset = s.getTimezoneOffset() * ONEMIN;
          var offsetTweak = (s.getUTCMinutes() - s.getMinutes()) * ONEMIN + (s.getUTCSeconds() - s.getSeconds()) * ONESEC + (s.getUTCMilliseconds() - s.getMilliseconds());
          if (offsetTweak) {
            var comb = 3 * ONEMIN;
            tzOffset = tzOffset - comb / 2 + mod(offsetTweak - tzOffset + comb / 2, comb);
          }
          s = Number(s) - tzOffset;
          if (s >= MIN_MS && s <= MAX_MS) return s;
          return BADNUM;
        }
        if (typeof s !== "string" && typeof s !== "number") return BADNUM;
        s = String(s);
        var isWorld = isWorldCalendar(calendar);
        var s0 = s.charAt(0);
        if (isWorld && (s0 === "G" || s0 === "g")) {
          s = s.substr(1);
          calendar = "";
        }
        var isChinese = isWorld && calendar.substr(0, 7) === "chinese";
        var match = s.match(isChinese ? DATETIME_REGEXP_CN : DATETIME_REGEXP);
        if (!match) return BADNUM;
        var y = match[1];
        var m = match[3] || "1";
        var d = Number(match[5] || 1);
        var H = Number(match[7] || 0);
        var M = Number(match[9] || 0);
        var S = Number(match[11] || 0);
        if (isWorld) {
          if (y.length === 2) return BADNUM;
          y = Number(y);
          var cDate;
          try {
            var calInstance = Registry.getComponentMethod("calendars", "getCal")(calendar);
            if (isChinese) {
              var isIntercalary = m.charAt(m.length - 1) === "i";
              m = parseInt(m, 10);
              cDate = calInstance.newDate(y, calInstance.toMonthIndex(y, m, isIntercalary), d);
            } else {
              cDate = calInstance.newDate(y, Number(m), d);
            }
          } catch (e) {
            return BADNUM;
          }
          if (!cDate) return BADNUM;
          return (cDate.toJD() - EPOCHJD) * ONEDAY + H * ONEHOUR + M * ONEMIN + S * ONESEC;
        }
        if (y.length === 2) {
          y = (Number(y) + 2e3 - YFIRST) % 100 + YFIRST;
        } else y = Number(y);
        m -= 1;
        var date = new Date(Date.UTC(2e3, m, d, H, M));
        date.setUTCFullYear(y);
        if (date.getUTCMonth() !== m) return BADNUM;
        if (date.getUTCDate() !== d) return BADNUM;
        return date.getTime() + S * ONESEC;
      };
      MIN_MS = exports.MIN_MS = exports.dateTime2ms("-9999");
      MAX_MS = exports.MAX_MS = exports.dateTime2ms("9999-12-31 23:59:59.9999");
      exports.isDateTime = function(s, calendar) {
        return exports.dateTime2ms(s, calendar) !== BADNUM;
      };
      function lpad(val, digits) {
        return String(val + Math.pow(10, digits)).substr(1);
      }
      var NINETYDAYS = 90 * ONEDAY;
      var THREEHOURS = 3 * ONEHOUR;
      var FIVEMIN = 5 * ONEMIN;
      exports.ms2DateTime = function(ms, r, calendar) {
        if (typeof ms !== "number" || !(ms >= MIN_MS && ms <= MAX_MS)) return BADNUM;
        if (!r) r = 0;
        var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10);
        var msRounded = Math.round(ms - msecTenths / 10);
        var dateStr, h, m, s, msec10, d;
        if (isWorldCalendar(calendar)) {
          var dateJD = Math.floor(msRounded / ONEDAY) + EPOCHJD;
          var timeMs = Math.floor(mod(ms, ONEDAY));
          try {
            dateStr = Registry.getComponentMethod("calendars", "getCal")(calendar).fromJD(dateJD).formatDate("yyyy-mm-dd");
          } catch (e) {
            dateStr = utcFormat("G%Y-%m-%d")(new Date(msRounded));
          }
          if (dateStr.charAt(0) === "-") {
            while (dateStr.length < 11) dateStr = "-0" + dateStr.substr(1);
          } else {
            while (dateStr.length < 10) dateStr = "0" + dateStr;
          }
          h = r < NINETYDAYS ? Math.floor(timeMs / ONEHOUR) : 0;
          m = r < NINETYDAYS ? Math.floor(timeMs % ONEHOUR / ONEMIN) : 0;
          s = r < THREEHOURS ? Math.floor(timeMs % ONEMIN / ONESEC) : 0;
          msec10 = r < FIVEMIN ? timeMs % ONESEC * 10 + msecTenths : 0;
        } else {
          d = new Date(msRounded);
          dateStr = utcFormat("%Y-%m-%d")(d);
          h = r < NINETYDAYS ? d.getUTCHours() : 0;
          m = r < NINETYDAYS ? d.getUTCMinutes() : 0;
          s = r < THREEHOURS ? d.getUTCSeconds() : 0;
          msec10 = r < FIVEMIN ? d.getUTCMilliseconds() * 10 + msecTenths : 0;
        }
        return includeTime(dateStr, h, m, s, msec10);
      };
      exports.ms2DateTimeLocal = function(ms) {
        if (!(ms >= MIN_MS + ONEDAY && ms <= MAX_MS - ONEDAY)) return BADNUM;
        var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10);
        var d = new Date(Math.round(ms - msecTenths / 10));
        var dateStr = timeFormat("%Y-%m-%d")(d);
        var h = d.getHours();
        var m = d.getMinutes();
        var s = d.getSeconds();
        var msec10 = d.getUTCMilliseconds() * 10 + msecTenths;
        return includeTime(dateStr, h, m, s, msec10);
      };
      function includeTime(dateStr, h, m, s, msec10) {
        if (h || m || s || msec10) {
          dateStr += " " + lpad(h, 2) + ":" + lpad(m, 2);
          if (s || msec10) {
            dateStr += ":" + lpad(s, 2);
            if (msec10) {
              var digits = 4;
              while (msec10 % 10 === 0) {
                digits -= 1;
                msec10 /= 10;
              }
              dateStr += "." + lpad(msec10, digits);
            }
          }
        }
        return dateStr;
      }
      exports.cleanDate = function(v, dflt, calendar) {
        if (v === BADNUM) return dflt;
        if (exports.isJSDate(v) || typeof v === "number" && isFinite(v)) {
          if (isWorldCalendar(calendar)) {
            Loggers.error("JS Dates and milliseconds are incompatible with world calendars", v);
            return dflt;
          }
          v = exports.ms2DateTimeLocal(+v);
          if (!v && dflt !== void 0) return dflt;
        } else if (!exports.isDateTime(v, calendar)) {
          Loggers.error("unrecognized date", v);
          return dflt;
        }
        return v;
      };
      var fracMatch = /%\d?f/g;
      var halfYearMatch = /%h/g;
      var quarterToHalfYear = {
        1: "1",
        2: "1",
        3: "2",
        4: "2"
      };
      function modDateFormat(fmt, x, formatter, calendar) {
        fmt = fmt.replace(fracMatch, function(match) {
          var digits = Math.min(+match.charAt(1) || 6, 6);
          var fracSecs = (x / 1e3 % 1 + 2).toFixed(digits).substr(2).replace(/0+$/, "") || "0";
          return fracSecs;
        });
        var d = new Date(Math.floor(x + 0.05));
        fmt = fmt.replace(halfYearMatch, function() {
          return quarterToHalfYear[formatter("%q")(d)];
        });
        if (isWorldCalendar(calendar)) {
          try {
            fmt = Registry.getComponentMethod("calendars", "worldCalFmt")(fmt, x, calendar);
          } catch (e) {
            return "Invalid";
          }
        }
        return formatter(fmt)(d);
      }
      var MAXSECONDS = [59, 59.9, 59.99, 59.999, 59.9999];
      function formatTime(x, tr) {
        var timePart = mod(x + 0.05, ONEDAY);
        var timeStr = lpad(Math.floor(timePart / ONEHOUR), 2) + ":" + lpad(mod(Math.floor(timePart / ONEMIN), 60), 2);
        if (tr !== "M") {
          if (!isNumeric(tr)) tr = 0;
          var sec = Math.min(mod(x / ONESEC, 60), MAXSECONDS[tr]);
          var secStr = (100 + sec).toFixed(tr).substr(1);
          if (tr > 0) {
            secStr = secStr.replace(/0+$/, "").replace(/[\.]$/, "");
          }
          timeStr += ":" + secStr;
        }
        return timeStr;
      }
      exports.formatDate = function(x, fmt, tr, formatter, calendar, extraFormat) {
        calendar = isWorldCalendar(calendar) && calendar;
        if (!fmt) {
          if (tr === "y") fmt = extraFormat.year;
          else if (tr === "m") fmt = extraFormat.month;
          else if (tr === "d") {
            fmt = extraFormat.dayMonth + "\n" + extraFormat.year;
          } else {
            return formatTime(x, tr) + "\n" + modDateFormat(extraFormat.dayMonthYear, x, formatter, calendar);
          }
        }
        return modDateFormat(fmt, x, formatter, calendar);
      };
      var THREEDAYS = 3 * ONEDAY;
      exports.incrementMonth = function(ms, dMonth, calendar) {
        calendar = isWorldCalendar(calendar) && calendar;
        var timeMs = mod(ms, ONEDAY);
        ms = Math.round(ms - timeMs);
        if (calendar) {
          try {
            var dateJD = Math.round(ms / ONEDAY) + EPOCHJD;
            var calInstance = Registry.getComponentMethod("calendars", "getCal")(calendar);
            var cDate = calInstance.fromJD(dateJD);
            if (dMonth % 12) calInstance.add(cDate, dMonth, "m");
            else calInstance.add(cDate, dMonth / 12, "y");
            return (cDate.toJD() - EPOCHJD) * ONEDAY + timeMs;
          } catch (e) {
            Loggers.error("invalid ms " + ms + " in calendar " + calendar);
          }
        }
        var y = new Date(ms + THREEDAYS);
        return y.setUTCMonth(y.getUTCMonth() + dMonth) + timeMs - THREEDAYS;
      };
      exports.findExactDates = function(data, calendar) {
        var exactYears = 0;
        var exactMonths = 0;
        var exactDays = 0;
        var blankCount = 0;
        var d;
        var di;
        var calInstance = isWorldCalendar(calendar) && Registry.getComponentMethod("calendars", "getCal")(calendar);
        for (var i = 0; i < data.length; i++) {
          di = data[i];
          if (!isNumeric(di)) {
            blankCount++;
            continue;
          }
          if (di % ONEDAY) continue;
          if (calInstance) {
            try {
              d = calInstance.fromJD(di / ONEDAY + EPOCHJD);
              if (d.day() === 1) {
                if (d.month() === 1) exactYears++;
                else exactMonths++;
              } else exactDays++;
            } catch (e) {
            }
          } else {
            d = new Date(di);
            if (d.getUTCDate() === 1) {
              if (d.getUTCMonth() === 0) exactYears++;
              else exactMonths++;
            } else exactDays++;
          }
        }
        exactMonths += exactYears;
        exactDays += exactMonths;
        var dataCount = data.length - blankCount;
        return {
          exactYears: exactYears / dataCount,
          exactMonths: exactMonths / dataCount,
          exactDays: exactDays / dataCount
        };
      };
    }
  });

  // src/lib/identity.js
  var require_identity2 = __commonJS({
    "src/lib/identity.js"(exports, module) {
      "use strict";
      module.exports = function identity(d) {
        return d;
      };
    }
  });

  // src/lib/search.js
  var require_search = __commonJS({
    "src/lib/search.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var loggers = require_loggers();
      var identity = require_identity2();
      var BADNUM = require_numerical().BADNUM;
      var roundingError = 1e-9;
      exports.findBin = function(val, bins, linelow) {
        if (isNumeric(bins.start)) {
          return linelow ? Math.ceil((val - bins.start) / bins.size - roundingError) - 1 : Math.floor((val - bins.start) / bins.size + roundingError);
        } else {
          var n1 = 0;
          var n2 = bins.length;
          var c = 0;
          var binSize = n2 > 1 ? (bins[n2 - 1] - bins[0]) / (n2 - 1) : 1;
          var n, test;
          if (binSize >= 0) {
            test = linelow ? lessThan : lessOrEqual;
          } else {
            test = linelow ? greaterOrEqual : greaterThan;
          }
          val += binSize * roundingError * (linelow ? -1 : 1) * (binSize >= 0 ? 1 : -1);
          while (n1 < n2 && c++ < 100) {
            n = Math.floor((n1 + n2) / 2);
            if (test(bins[n], val)) n1 = n + 1;
            else n2 = n;
          }
          if (c > 90) loggers.log("Long binary search...");
          return n1 - 1;
        }
      };
      function lessThan(a, b) {
        return a < b;
      }
      function lessOrEqual(a, b) {
        return a <= b;
      }
      function greaterThan(a, b) {
        return a > b;
      }
      function greaterOrEqual(a, b) {
        return a >= b;
      }
      exports.sorterAsc = function(a, b) {
        return a - b;
      };
      exports.sorterDes = function(a, b) {
        return b - a;
      };
      exports.distinctVals = function(valsIn) {
        var vals = valsIn.slice();
        vals.sort(exports.sorterAsc);
        var last;
        for (last = vals.length - 1; last > -1; last--) {
          if (vals[last] !== BADNUM) break;
        }
        var minDiff = vals[last] - vals[0] || 1;
        var errDiff = minDiff / (last || 1) / 1e4;
        var newVals = [];
        var preV;
        for (var i = 0; i <= last; i++) {
          var v = vals[i];
          var diff = v - preV;
          if (preV === void 0) {
            newVals.push(v);
            preV = v;
          } else if (diff > errDiff) {
            minDiff = Math.min(minDiff, diff);
            newVals.push(v);
            preV = v;
          }
        }
        return { vals: newVals, minDiff };
      };
      exports.roundUp = function(val, arrayIn, reverse) {
        var low = 0;
        var high = arrayIn.length - 1;
        var mid;
        var c = 0;
        var dlow = reverse ? 0 : 1;
        var dhigh = reverse ? 1 : 0;
        var rounded = reverse ? Math.ceil : Math.floor;
        while (low < high && c++ < 100) {
          mid = rounded((low + high) / 2);
          if (arrayIn[mid] <= val) low = mid + dlow;
          else high = mid - dhigh;
        }
        return arrayIn[low];
      };
      exports.sort = function(array, sortFn) {
        var notOrdered = 0;
        var notReversed = 0;
        for (var i = 1; i < array.length; i++) {
          var pairOrder = sortFn(array[i], array[i - 1]);
          if (pairOrder < 0) notOrdered = 1;
          else if (pairOrder > 0) notReversed = 1;
          if (notOrdered && notReversed) return array.sort(sortFn);
        }
        return notReversed ? array : array.reverse();
      };
      exports.findIndexOfMin = function(arr, fn) {
        fn = fn || identity;
        var min = Infinity;
        var ind;
        for (var i = 0; i < arr.length; i++) {
          var v = fn(arr[i]);
          if (v < min) {
            min = v;
            ind = i;
          }
        }
        return ind;
      };
    }
  });

  // src/lib/sort_object_keys.js
  var require_sort_object_keys = __commonJS({
    "src/lib/sort_object_keys.js"(exports, module) {
      "use strict";
      module.exports = function sortObjectKeys(obj) {
        return Object.keys(obj).sort();
      };
    }
  });

  // src/lib/stats.js
  var require_stats = __commonJS({
    "src/lib/stats.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      exports.aggNums = function(f, v, a, len) {
        var i, b;
        if (!len || len > a.length) len = a.length;
        if (!isNumeric(v)) v = false;
        if (isArrayOrTypedArray(a[0])) {
          b = new Array(len);
          for (i = 0; i < len; i++) b[i] = exports.aggNums(f, v, a[i]);
          a = b;
        }
        for (i = 0; i < len; i++) {
          if (!isNumeric(v)) v = a[i];
          else if (isNumeric(a[i])) v = f(+v, +a[i]);
        }
        return v;
      };
      exports.len = function(data) {
        return exports.aggNums(function(a) {
          return a + 1;
        }, 0, data);
      };
      exports.mean = function(data, len) {
        if (!len) len = exports.len(data);
        return exports.aggNums(function(a, b) {
          return a + b;
        }, 0, data) / len;
      };
      exports.geometricMean = function(data, len) {
        if (!len) len = exports.len(data);
        return Math.pow(exports.aggNums(function(a, b) {
          return a * b;
        }, 1, data), 1 / len);
      };
      exports.midRange = function(numArr) {
        if (numArr === void 0 || numArr.length === 0) return void 0;
        return (exports.aggNums(Math.max, null, numArr) + exports.aggNums(Math.min, null, numArr)) / 2;
      };
      exports.variance = function(data, len, mean) {
        if (!len) len = exports.len(data);
        if (!isNumeric(mean)) mean = exports.mean(data, len);
        return exports.aggNums(function(a, b) {
          return a + Math.pow(b - mean, 2);
        }, 0, data) / len;
      };
      exports.stdev = function(data, len, mean) {
        return Math.sqrt(exports.variance(data, len, mean));
      };
      exports.median = function(data) {
        var b = data.slice().sort();
        return exports.interp(b, 0.5);
      };
      exports.interp = function(arr, n) {
        if (!isNumeric(n)) throw "n should be a finite number";
        n = n * arr.length - 0.5;
        if (n < 0) return arr[0];
        if (n > arr.length - 1) return arr[arr.length - 1];
        var frac = n % 1;
        return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];
      };
    }
  });

  // src/lib/angles.js
  var require_angles = __commonJS({
    "src/lib/angles.js"(exports, module) {
      "use strict";
      var modModule = require_mod();
      var mod = modModule.mod;
      var modHalf = modModule.modHalf;
      var PI = Math.PI;
      var twoPI = 2 * PI;
      function deg2rad(deg) {
        return deg / 180 * PI;
      }
      function rad2deg(rad) {
        return rad / PI * 180;
      }
      function isFullCircle(aBnds) {
        return Math.abs(aBnds[1] - aBnds[0]) > twoPI - 1e-14;
      }
      function angleDelta(a, b) {
        return modHalf(b - a, twoPI);
      }
      function angleDist(a, b) {
        return Math.abs(angleDelta(a, b));
      }
      function isAngleInsideSector(a, aBnds) {
        if (isFullCircle(aBnds)) return true;
        var s0, s1;
        if (aBnds[0] < aBnds[1]) {
          s0 = aBnds[0];
          s1 = aBnds[1];
        } else {
          s0 = aBnds[1];
          s1 = aBnds[0];
        }
        s0 = mod(s0, twoPI);
        s1 = mod(s1, twoPI);
        if (s0 > s1) s1 += twoPI;
        var a0 = mod(a, twoPI);
        var a1 = a0 + twoPI;
        return a0 >= s0 && a0 <= s1 || a1 >= s0 && a1 <= s1;
      }
      function isPtInsideSector(r, a, rBnds, aBnds) {
        if (!isAngleInsideSector(a, aBnds)) return false;
        var r0, r1;
        if (rBnds[0] < rBnds[1]) {
          r0 = rBnds[0];
          r1 = rBnds[1];
        } else {
          r0 = rBnds[1];
          r1 = rBnds[0];
        }
        return r >= r0 && r <= r1;
      }
      function _path(r0, r1, a0, a1, cx, cy, isClosed) {
        cx = cx || 0;
        cy = cy || 0;
        var isCircle = isFullCircle([a0, a1]);
        var aStart, aMid, aEnd;
        var rStart, rEnd;
        if (isCircle) {
          aStart = 0;
          aMid = PI;
          aEnd = twoPI;
        } else {
          if (a0 < a1) {
            aStart = a0;
            aEnd = a1;
          } else {
            aStart = a1;
            aEnd = a0;
          }
        }
        if (r0 < r1) {
          rStart = r0;
          rEnd = r1;
        } else {
          rStart = r1;
          rEnd = r0;
        }
        function pt(r, a) {
          return [r * Math.cos(a) + cx, cy - r * Math.sin(a)];
        }
        var largeArc = Math.abs(aEnd - aStart) <= PI ? 0 : 1;
        function arc(r, a, cw) {
          return "A" + [r, r] + " " + [0, largeArc, cw] + " " + pt(r, a);
        }
        var p;
        if (isCircle) {
          if (rStart === null) {
            p = "M" + pt(rEnd, aStart) + arc(rEnd, aMid, 0) + arc(rEnd, aEnd, 0) + "Z";
          } else {
            p = "M" + pt(rStart, aStart) + arc(rStart, aMid, 0) + arc(rStart, aEnd, 0) + "ZM" + pt(rEnd, aStart) + arc(rEnd, aMid, 1) + arc(rEnd, aEnd, 1) + "Z";
          }
        } else {
          if (rStart === null) {
            p = "M" + pt(rEnd, aStart) + arc(rEnd, aEnd, 0);
            if (isClosed) p += "L0,0Z";
          } else {
            p = "M" + pt(rStart, aStart) + "L" + pt(rEnd, aStart) + arc(rEnd, aEnd, 0) + "L" + pt(rStart, aEnd) + arc(rStart, aStart, 1) + "Z";
          }
        }
        return p;
      }
      function pathArc(r, a0, a1, cx, cy) {
        return _path(null, r, a0, a1, cx, cy, 0);
      }
      function pathSector(r, a0, a1, cx, cy) {
        return _path(null, r, a0, a1, cx, cy, 1);
      }
      function pathAnnulus(r0, r1, a0, a1, cx, cy) {
        return _path(r0, r1, a0, a1, cx, cy, 1);
      }
      module.exports = {
        deg2rad,
        rad2deg,
        angleDelta,
        angleDist,
        isFullCircle,
        isAngleInsideSector,
        isPtInsideSector,
        pathArc,
        pathSector,
        pathAnnulus
      };
    }
  });

  // src/lib/anchor_utils.js
  var require_anchor_utils = __commonJS({
    "src/lib/anchor_utils.js"(exports) {
      "use strict";
      exports.isLeftAnchor = function isLeftAnchor(opts) {
        return opts.xanchor === "left" || opts.xanchor === "auto" && opts.x <= 1 / 3;
      };
      exports.isCenterAnchor = function isCenterAnchor(opts) {
        return opts.xanchor === "center" || opts.xanchor === "auto" && opts.x > 1 / 3 && opts.x < 2 / 3;
      };
      exports.isRightAnchor = function isRightAnchor(opts) {
        return opts.xanchor === "right" || opts.xanchor === "auto" && opts.x >= 2 / 3;
      };
      exports.isTopAnchor = function isTopAnchor(opts) {
        return opts.yanchor === "top" || opts.yanchor === "auto" && opts.y >= 2 / 3;
      };
      exports.isMiddleAnchor = function isMiddleAnchor(opts) {
        return opts.yanchor === "middle" || opts.yanchor === "auto" && opts.y > 1 / 3 && opts.y < 2 / 3;
      };
      exports.isBottomAnchor = function isBottomAnchor(opts) {
        return opts.yanchor === "bottom" || opts.yanchor === "auto" && opts.y <= 1 / 3;
      };
    }
  });

  // src/lib/geometry2d.js
  var require_geometry2d = __commonJS({
    "src/lib/geometry2d.js"(exports) {
      "use strict";
      var mod = require_mod().mod;
      exports.segmentsIntersect = segmentsIntersect;
      function segmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        var a = x2 - x1;
        var b = x3 - x1;
        var c = x4 - x3;
        var d = y2 - y1;
        var e = y3 - y1;
        var f = y4 - y3;
        var det = a * f - c * d;
        if (det === 0) return null;
        var t = (b * f - c * e) / det;
        var u = (b * d - a * e) / det;
        if (u < 0 || u > 1 || t < 0 || t > 1) return null;
        return { x: x1 + a * t, y: y1 + d * t };
      }
      exports.segmentDistance = function segmentDistance(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (segmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4)) return 0;
        var x12 = x2 - x1;
        var y12 = y2 - y1;
        var x34 = x4 - x3;
        var y34 = y4 - y3;
        var ll12 = x12 * x12 + y12 * y12;
        var ll34 = x34 * x34 + y34 * y34;
        var dist2 = Math.min(
          perpDistance2(x12, y12, ll12, x3 - x1, y3 - y1),
          perpDistance2(x12, y12, ll12, x4 - x1, y4 - y1),
          perpDistance2(x34, y34, ll34, x1 - x3, y1 - y3),
          perpDistance2(x34, y34, ll34, x2 - x3, y2 - y3)
        );
        return Math.sqrt(dist2);
      };
      function perpDistance2(xab, yab, llab, xac, yac) {
        var fcAB = xac * xab + yac * yab;
        if (fcAB < 0) {
          return xac * xac + yac * yac;
        } else if (fcAB > llab) {
          var xbc = xac - xab;
          var ybc = yac - yab;
          return xbc * xbc + ybc * ybc;
        } else {
          var crossProduct = xac * yab - yac * xab;
          return crossProduct * crossProduct / llab;
        }
      }
      var locationCache;
      var workingPath;
      var workingTextWidth;
      exports.getTextLocation = function getTextLocation(path, totalPathLen, positionOnPath, textWidth) {
        if (path !== workingPath || textWidth !== workingTextWidth) {
          locationCache = {};
          workingPath = path;
          workingTextWidth = textWidth;
        }
        if (locationCache[positionOnPath]) {
          return locationCache[positionOnPath];
        }
        var p0 = path.getPointAtLength(mod(positionOnPath - textWidth / 2, totalPathLen));
        var p1 = path.getPointAtLength(mod(positionOnPath + textWidth / 2, totalPathLen));
        var theta = Math.atan((p1.y - p0.y) / (p1.x - p0.x));
        var pCenter = path.getPointAtLength(mod(positionOnPath, totalPathLen));
        var x = (pCenter.x * 4 + p0.x + p1.x) / 6;
        var y = (pCenter.y * 4 + p0.y + p1.y) / 6;
        var out = { x, y, theta };
        locationCache[positionOnPath] = out;
        return out;
      };
      exports.clearLocationCache = function() {
        workingPath = null;
      };
      exports.getVisibleSegment = function getVisibleSegment(path, bounds, buffer) {
        var left = bounds.left;
        var right = bounds.right;
        var top = bounds.top;
        var bottom = bounds.bottom;
        var pMin = 0;
        var pTotal = path.getTotalLength();
        var pMax = pTotal;
        var pt0, ptTotal;
        function getDistToPlot(len) {
          var pt = path.getPointAtLength(len);
          if (len === 0) pt0 = pt;
          else if (len === pTotal) ptTotal = pt;
          var dx = pt.x < left ? left - pt.x : pt.x > right ? pt.x - right : 0;
          var dy = pt.y < top ? top - pt.y : pt.y > bottom ? pt.y - bottom : 0;
          return Math.sqrt(dx * dx + dy * dy);
        }
        var distToPlot = getDistToPlot(pMin);
        while (distToPlot) {
          pMin += distToPlot + buffer;
          if (pMin > pMax) return;
          distToPlot = getDistToPlot(pMin);
        }
        distToPlot = getDistToPlot(pMax);
        while (distToPlot) {
          pMax -= distToPlot + buffer;
          if (pMin > pMax) return;
          distToPlot = getDistToPlot(pMax);
        }
        return {
          min: pMin,
          max: pMax,
          len: pMax - pMin,
          total: pTotal,
          isClosed: pMin === 0 && pMax === pTotal && Math.abs(pt0.x - ptTotal.x) < 0.1 && Math.abs(pt0.y - ptTotal.y) < 0.1
        };
      };
      exports.findPointOnPath = function findPointOnPath(path, val, coord, opts) {
        opts = opts || {};
        var pathLength = opts.pathLength || path.getTotalLength();
        var tolerance = opts.tolerance || 1e-3;
        var iterationLimit = opts.iterationLimit || 30;
        var mul = path.getPointAtLength(0)[coord] > path.getPointAtLength(pathLength)[coord] ? -1 : 1;
        var i = 0;
        var b0 = 0;
        var b1 = pathLength;
        var mid;
        var pt;
        var diff;
        while (i < iterationLimit) {
          mid = (b0 + b1) / 2;
          pt = path.getPointAtLength(mid);
          diff = pt[coord] - val;
          if (Math.abs(diff) < tolerance) {
            return pt;
          } else {
            if (mul * diff > 0) {
              b1 = mid;
            } else {
              b0 = mid;
            }
            i++;
          }
        }
        return pt;
      };
    }
  });

  // src/lib/throttle.js
  var require_throttle = __commonJS({
    "src/lib/throttle.js"(exports) {
      "use strict";
      var timerCache = {};
      exports.throttle = function throttle(id, minInterval, callback) {
        var cache = timerCache[id];
        var now = Date.now();
        if (!cache) {
          for (var idi in timerCache) {
            if (timerCache[idi].ts < now - 6e4) {
              delete timerCache[idi];
            }
          }
          cache = timerCache[id] = { ts: 0, timer: null };
        }
        _clearTimeout(cache);
        function exec() {
          callback();
          cache.ts = Date.now();
          if (cache.onDone) {
            cache.onDone();
            cache.onDone = null;
          }
        }
        if (now > cache.ts + minInterval) {
          exec();
          return;
        }
        cache.timer = setTimeout(function() {
          exec();
          cache.timer = null;
        }, minInterval);
      };
      exports.done = function(id) {
        var cache = timerCache[id];
        if (!cache || !cache.timer) return Promise.resolve();
        return new Promise(function(resolve) {
          var previousOnDone = cache.onDone;
          cache.onDone = function onDone() {
            if (previousOnDone) previousOnDone();
            resolve();
            cache.onDone = null;
          };
        });
      };
      exports.clear = function(id) {
        if (id) {
          _clearTimeout(timerCache[id]);
          delete timerCache[id];
        } else {
          for (var idi in timerCache) exports.clear(idi);
        }
      };
      function _clearTimeout(cache) {
        if (cache && cache.timer !== null) {
          clearTimeout(cache.timer);
          cache.timer = null;
        }
      }
    }
  });

  // src/lib/clear_responsive.js
  var require_clear_responsive = __commonJS({
    "src/lib/clear_responsive.js"(exports, module) {
      "use strict";
      module.exports = function clearResponsive(gd) {
        if (gd._responsiveChartHandler) {
          window.removeEventListener("resize", gd._responsiveChartHandler);
          delete gd._responsiveChartHandler;
        }
      };
    }
  });

  // node_modules/is-mobile/index.js
  var require_is_mobile = __commonJS({
    "node_modules/is-mobile/index.js"(exports, module) {
      "use strict";
      module.exports = isMobile;
      module.exports.isMobile = isMobile;
      module.exports.default = isMobile;
      var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
      var notMobileRE = /CrOS/;
      var tabletRE = /android|ipad|playbook|silk/i;
      function isMobile(opts) {
        if (!opts) opts = {};
        let ua = opts.ua;
        if (!ua && typeof navigator !== "undefined") ua = navigator.userAgent;
        if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
          ua = ua.headers["user-agent"];
        }
        if (typeof ua !== "string") return false;
        let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
        if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
          result = true;
        }
        return result;
      }
    }
  });

  // src/lib/preserve_drawing_buffer.js
  var require_preserve_drawing_buffer = __commonJS({
    "src/lib/preserve_drawing_buffer.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isMobileOrTablet = require_is_mobile();
      module.exports = function preserveDrawingBuffer(opts) {
        var ua;
        if (opts && opts.hasOwnProperty("userAgent")) {
          ua = opts.userAgent;
        } else {
          ua = getUserAgent();
        }
        if (typeof ua !== "string") return true;
        var enable = isMobileOrTablet({
          ua: { headers: { "user-agent": ua } },
          tablet: true,
          featureDetect: false
        });
        if (!enable) {
          var allParts = ua.split(" ");
          for (var i = 1; i < allParts.length; i++) {
            var part = allParts[i];
            if (part.indexOf("Safari") !== -1) {
              for (var k = i - 1; k > -1; k--) {
                var prevPart = allParts[k];
                if (prevPart.substr(0, 8) === "Version/") {
                  var v = prevPart.substr(8).split(".")[0];
                  if (isNumeric(v)) v = +v;
                  if (v >= 13) return true;
                }
              }
            }
          }
        }
        return enable;
      };
      function getUserAgent() {
        var ua;
        if (typeof navigator !== "undefined") {
          ua = navigator.userAgent;
        }
        if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
          ua = ua.headers["user-agent"];
        }
        return ua;
      }
    }
  });

  // src/lib/make_trace_groups.js
  var require_make_trace_groups = __commonJS({
    "src/lib/make_trace_groups.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      module.exports = function makeTraceGroups(traceLayer, cdModule, cls) {
        var traces = traceLayer.selectAll("g." + cls.replace(/\s/g, ".")).data(cdModule, function(cd) {
          return cd[0].trace.uid;
        });
        traces.exit().remove();
        traces.enter().append("g").attr("class", cls);
        traces.order();
        var k = traceLayer.classed("rangeplot") ? "nodeRangePlot3" : "node3";
        traces.each(function(cd) {
          cd[0][k] = d3.select(this);
        });
        return traces;
      };
    }
  });

  // src/lib/localize.js
  var require_localize = __commonJS({
    "src/lib/localize.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      module.exports = function localize(gd, s) {
        var locale = gd._context.locale;
        for (var i = 0; i < 2; i++) {
          var locales = gd._context.locales;
          for (var j = 0; j < 2; j++) {
            var dict = (locales[locale] || {}).dictionary;
            if (dict) {
              var out = dict[s];
              if (out) return out;
            }
            locales = Registry.localeRegistry;
          }
          var baseLocale = locale.split("-")[0];
          if (baseLocale === locale) break;
          locale = baseLocale;
        }
        return s;
      };
    }
  });

  // src/lib/filter_unique.js
  var require_filter_unique = __commonJS({
    "src/lib/filter_unique.js"(exports, module) {
      "use strict";
      module.exports = function filterUnique(array) {
        var seen = {};
        var out = [];
        var j = 0;
        for (var i = 0; i < array.length; i++) {
          var item = array[i];
          if (seen[item] !== 1) {
            seen[item] = 1;
            out[j++] = item;
          }
        }
        return out;
      };
    }
  });

  // src/lib/filter_visible.js
  var require_filter_visible = __commonJS({
    "src/lib/filter_visible.js"(exports, module) {
      "use strict";
      module.exports = function filterVisible(container) {
        var filterFn = isCalcData(container) ? calcDataFilter : baseFilter;
        var out = [];
        for (var i = 0; i < container.length; i++) {
          var item = container[i];
          if (filterFn(item)) out.push(item);
        }
        return out;
      };
      function baseFilter(item) {
        return item.visible === true;
      }
      function calcDataFilter(item) {
        var trace = item[0].trace;
        return trace.visible === true && trace._length !== 0;
      }
      function isCalcData(cont) {
        return Array.isArray(cont) && Array.isArray(cont[0]) && cont[0][0] && cont[0][0].trace;
      }
    }
  });

  // src/lib/increment.js
  var require_increment = __commonJS({
    "src/lib/increment.js"(exports, module) {
      "use strict";
      module.exports = function incrementNumeric(x, delta) {
        if (!delta) return x;
        var scale = 1 / Math.abs(delta);
        var newX = scale > 1 ? (scale * x + scale * delta) / scale : x + delta;
        var lenX1 = String(newX).length;
        if (lenX1 > 16) {
          var lenDt = String(delta).length;
          var lenX0 = String(x).length;
          if (lenX1 >= lenX0 + lenDt) {
            var s = parseFloat(newX).toPrecision(12);
            if (s.indexOf("e+") === -1) newX = +s;
          }
        }
        return newX;
      };
    }
  });

  // src/lib/clean_number.js
  var require_clean_number = __commonJS({
    "src/lib/clean_number.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var BADNUM = require_numerical().BADNUM;
      var JUNK = /^['"%,$#\s']+|[, ]|['"%,$#\s']+$/g;
      module.exports = function cleanNumber(v) {
        if (typeof v === "string") {
          v = v.replace(JUNK, "");
        }
        if (isNumeric(v)) return Number(v);
        return BADNUM;
      };
    }
  });

  // src/lib/index.js
  var require_lib = __commonJS({
    "src/lib/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var utcFormat = require_d3_time_format().utcFormat;
      var d3Format = require_d3_format().format;
      var isNumeric = require_fast_isnumeric();
      var numConstants = require_numerical();
      var MAX_SAFE = numConstants.FP_SAFE;
      var MIN_SAFE = -MAX_SAFE;
      var BADNUM = numConstants.BADNUM;
      var lib = module.exports = {};
      lib.adjustFormat = function adjustFormat(formatStr) {
        if (!formatStr || /^\d[.]\df/.test(formatStr) || /[.]\d%/.test(formatStr)) return formatStr;
        if (formatStr === "0.f") return "~f";
        if (/^\d%/.test(formatStr)) return "~%";
        if (/^\ds/.test(formatStr)) return "~s";
        if (!/^[~,.0$]/.test(formatStr) && /[&fps]/.test(formatStr)) return "~" + formatStr;
        return formatStr;
      };
      var seenBadFormats = {};
      lib.warnBadFormat = function(f) {
        var key = String(f);
        if (!seenBadFormats[key]) {
          seenBadFormats[key] = 1;
          lib.warn('encountered bad format: "' + key + '"');
        }
      };
      lib.noFormat = function(value) {
        return String(value);
      };
      lib.numberFormat = function(formatStr) {
        var fn;
        try {
          fn = d3Format(lib.adjustFormat(formatStr));
        } catch (e) {
          lib.warnBadFormat(formatStr);
          return lib.noFormat;
        }
        return fn;
      };
      lib.nestedProperty = require_nested_property();
      lib.keyedContainer = require_keyed_container();
      lib.relativeAttr = require_relative_attr();
      lib.isPlainObject = require_is_plain_object();
      lib.toLogRange = require_to_log_range();
      lib.relinkPrivateKeys = require_relink_private();
      var arrayModule = require_array();
      lib.isArrayBuffer = arrayModule.isArrayBuffer;
      lib.isTypedArray = arrayModule.isTypedArray;
      lib.isArrayOrTypedArray = arrayModule.isArrayOrTypedArray;
      lib.isArray1D = arrayModule.isArray1D;
      lib.ensureArray = arrayModule.ensureArray;
      lib.concat = arrayModule.concat;
      lib.maxRowLength = arrayModule.maxRowLength;
      lib.minRowLength = arrayModule.minRowLength;
      var modModule = require_mod();
      lib.mod = modModule.mod;
      lib.modHalf = modModule.modHalf;
      var coerceModule = require_coerce();
      lib.valObjectMeta = coerceModule.valObjectMeta;
      lib.coerce = coerceModule.coerce;
      lib.coerce2 = coerceModule.coerce2;
      lib.coerceFont = coerceModule.coerceFont;
      lib.coercePattern = coerceModule.coercePattern;
      lib.coerceHoverinfo = coerceModule.coerceHoverinfo;
      lib.coerceSelectionMarkerOpacity = coerceModule.coerceSelectionMarkerOpacity;
      lib.validate = coerceModule.validate;
      var datesModule = require_dates();
      lib.dateTime2ms = datesModule.dateTime2ms;
      lib.isDateTime = datesModule.isDateTime;
      lib.ms2DateTime = datesModule.ms2DateTime;
      lib.ms2DateTimeLocal = datesModule.ms2DateTimeLocal;
      lib.cleanDate = datesModule.cleanDate;
      lib.isJSDate = datesModule.isJSDate;
      lib.formatDate = datesModule.formatDate;
      lib.incrementMonth = datesModule.incrementMonth;
      lib.dateTick0 = datesModule.dateTick0;
      lib.dfltRange = datesModule.dfltRange;
      lib.findExactDates = datesModule.findExactDates;
      lib.MIN_MS = datesModule.MIN_MS;
      lib.MAX_MS = datesModule.MAX_MS;
      var searchModule = require_search();
      lib.findBin = searchModule.findBin;
      lib.sorterAsc = searchModule.sorterAsc;
      lib.sorterDes = searchModule.sorterDes;
      lib.distinctVals = searchModule.distinctVals;
      lib.roundUp = searchModule.roundUp;
      lib.sort = searchModule.sort;
      lib.findIndexOfMin = searchModule.findIndexOfMin;
      lib.sortObjectKeys = require_sort_object_keys();
      var statsModule = require_stats();
      lib.aggNums = statsModule.aggNums;
      lib.len = statsModule.len;
      lib.mean = statsModule.mean;
      lib.geometricMean = statsModule.geometricMean;
      lib.median = statsModule.median;
      lib.midRange = statsModule.midRange;
      lib.variance = statsModule.variance;
      lib.stdev = statsModule.stdev;
      lib.interp = statsModule.interp;
      var matrixModule = require_matrix();
      lib.init2dArray = matrixModule.init2dArray;
      lib.transposeRagged = matrixModule.transposeRagged;
      lib.dot = matrixModule.dot;
      lib.translationMatrix = matrixModule.translationMatrix;
      lib.rotationMatrix = matrixModule.rotationMatrix;
      lib.rotationXYMatrix = matrixModule.rotationXYMatrix;
      lib.apply3DTransform = matrixModule.apply3DTransform;
      lib.apply2DTransform = matrixModule.apply2DTransform;
      lib.apply2DTransform2 = matrixModule.apply2DTransform2;
      lib.convertCssMatrix = matrixModule.convertCssMatrix;
      lib.inverseTransformMatrix = matrixModule.inverseTransformMatrix;
      var anglesModule = require_angles();
      lib.deg2rad = anglesModule.deg2rad;
      lib.rad2deg = anglesModule.rad2deg;
      lib.angleDelta = anglesModule.angleDelta;
      lib.angleDist = anglesModule.angleDist;
      lib.isFullCircle = anglesModule.isFullCircle;
      lib.isAngleInsideSector = anglesModule.isAngleInsideSector;
      lib.isPtInsideSector = anglesModule.isPtInsideSector;
      lib.pathArc = anglesModule.pathArc;
      lib.pathSector = anglesModule.pathSector;
      lib.pathAnnulus = anglesModule.pathAnnulus;
      var anchorUtils = require_anchor_utils();
      lib.isLeftAnchor = anchorUtils.isLeftAnchor;
      lib.isCenterAnchor = anchorUtils.isCenterAnchor;
      lib.isRightAnchor = anchorUtils.isRightAnchor;
      lib.isTopAnchor = anchorUtils.isTopAnchor;
      lib.isMiddleAnchor = anchorUtils.isMiddleAnchor;
      lib.isBottomAnchor = anchorUtils.isBottomAnchor;
      var geom2dModule = require_geometry2d();
      lib.segmentsIntersect = geom2dModule.segmentsIntersect;
      lib.segmentDistance = geom2dModule.segmentDistance;
      lib.getTextLocation = geom2dModule.getTextLocation;
      lib.clearLocationCache = geom2dModule.clearLocationCache;
      lib.getVisibleSegment = geom2dModule.getVisibleSegment;
      lib.findPointOnPath = geom2dModule.findPointOnPath;
      var extendModule = require_extend();
      lib.extendFlat = extendModule.extendFlat;
      lib.extendDeep = extendModule.extendDeep;
      lib.extendDeepAll = extendModule.extendDeepAll;
      lib.extendDeepNoArrays = extendModule.extendDeepNoArrays;
      var loggersModule = require_loggers();
      lib.log = loggersModule.log;
      lib.warn = loggersModule.warn;
      lib.error = loggersModule.error;
      var regexModule = require_regex();
      lib.counterRegex = regexModule.counter;
      var throttleModule = require_throttle();
      lib.throttle = throttleModule.throttle;
      lib.throttleDone = throttleModule.done;
      lib.clearThrottle = throttleModule.clear;
      var domModule = require_dom();
      lib.getGraphDiv = domModule.getGraphDiv;
      lib.isPlotDiv = domModule.isPlotDiv;
      lib.removeElement = domModule.removeElement;
      lib.addStyleRule = domModule.addStyleRule;
      lib.addRelatedStyleRule = domModule.addRelatedStyleRule;
      lib.deleteRelatedStyleRule = domModule.deleteRelatedStyleRule;
      lib.setStyleOnHover = domModule.setStyleOnHover;
      lib.getFullTransformMatrix = domModule.getFullTransformMatrix;
      lib.getElementTransformMatrix = domModule.getElementTransformMatrix;
      lib.getElementAndAncestors = domModule.getElementAndAncestors;
      lib.equalDomRects = domModule.equalDomRects;
      lib.clearResponsive = require_clear_responsive();
      lib.preserveDrawingBuffer = require_preserve_drawing_buffer();
      lib.makeTraceGroups = require_make_trace_groups();
      lib._ = require_localize();
      lib.notifier = require_notifier();
      lib.filterUnique = require_filter_unique();
      lib.filterVisible = require_filter_visible();
      lib.pushUnique = require_push_unique();
      lib.increment = require_increment();
      lib.cleanNumber = require_clean_number();
      lib.ensureNumber = function ensureNumber(v) {
        if (!isNumeric(v)) return BADNUM;
        v = Number(v);
        return v > MAX_SAFE || v < MIN_SAFE ? BADNUM : v;
      };
      lib.isIndex = function(v, len) {
        if (len !== void 0 && v >= len) return false;
        return isNumeric(v) && v >= 0 && v % 1 === 0;
      };
      lib.noop = require_noop();
      lib.identity = require_identity2();
      lib.repeat = function(v, cnt) {
        var out = new Array(cnt);
        for (var i = 0; i < cnt; i++) {
          out[i] = v;
        }
        return out;
      };
      lib.swapAttrs = function(cont, attrList, part1, part2) {
        if (!part1) part1 = "x";
        if (!part2) part2 = "y";
        for (var i = 0; i < attrList.length; i++) {
          var attr = attrList[i];
          var xp = lib.nestedProperty(cont, attr.replace("?", part1));
          var yp = lib.nestedProperty(cont, attr.replace("?", part2));
          var temp = xp.get();
          xp.set(yp.get());
          yp.set(temp);
        }
      };
      lib.raiseToTop = function raiseToTop(elem) {
        elem.parentNode.appendChild(elem);
      };
      lib.cancelTransition = function(selection) {
        return selection.transition().duration(0);
      };
      lib.constrain = function(v, v0, v1) {
        if (v0 > v1) return Math.max(v1, Math.min(v0, v));
        return Math.max(v0, Math.min(v1, v));
      };
      lib.bBoxIntersect = function(a, b, pad) {
        pad = pad || 0;
        return a.left <= b.right + pad && b.left <= a.right + pad && a.top <= b.bottom + pad && b.top <= a.bottom + pad;
      };
      lib.simpleMap = function(array, func, x1, x2, opts) {
        var len = array.length;
        var out = new Array(len);
        for (var i = 0; i < len; i++) out[i] = func(array[i], x1, x2, opts);
        return out;
      };
      lib.randstr = function randstr(existing, bits, base, _recursion) {
        if (!base) base = 16;
        if (bits === void 0) bits = 24;
        if (bits <= 0) return "0";
        var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
        var res = "";
        var i, b, x;
        for (i = 2; digits === Infinity; i *= 2) {
          digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
        }
        var rem = digits - Math.floor(digits);
        for (i = 0; i < Math.floor(digits); i++) {
          x = Math.floor(Math.random() * base).toString(base);
          res = x + res;
        }
        if (rem) {
          b = Math.pow(base, rem);
          x = Math.floor(Math.random() * b).toString(base);
          res = x + res;
        }
        var parsed = parseInt(res, base);
        if (existing && existing[res] || parsed !== Infinity && parsed >= Math.pow(2, bits)) {
          if (_recursion > 10) {
            lib.warn("randstr failed uniqueness");
            return res;
          }
          return randstr(existing, bits, base, (_recursion || 0) + 1);
        } else return res;
      };
      lib.OptionControl = function(opt, optname) {
        if (!opt) opt = {};
        if (!optname) optname = "opt";
        var self2 = {};
        self2.optionList = [];
        self2._newoption = function(optObj) {
          optObj[optname] = opt;
          self2[optObj.name] = optObj;
          self2.optionList.push(optObj);
        };
        self2["_" + optname] = opt;
        return self2;
      };
      lib.smooth = function(arrayIn, FWHM) {
        FWHM = Math.round(FWHM) || 0;
        if (FWHM < 2) return arrayIn;
        var alen = arrayIn.length;
        var alen2 = 2 * alen;
        var wlen = 2 * FWHM - 1;
        var w = new Array(wlen);
        var arrayOut = new Array(alen);
        var i;
        var j;
        var k;
        var v;
        for (i = 0; i < wlen; i++) {
          w[i] = (1 - Math.cos(Math.PI * (i + 1) / FWHM)) / (2 * FWHM);
        }
        for (i = 0; i < alen; i++) {
          v = 0;
          for (j = 0; j < wlen; j++) {
            k = i + j + 1 - FWHM;
            if (k < -alen) k -= alen2 * Math.round(k / alen2);
            else if (k >= alen2) k -= alen2 * Math.floor(k / alen2);
            if (k < 0) k = -1 - k;
            else if (k >= alen) k = alen2 - 1 - k;
            v += arrayIn[k] * w[j];
          }
          arrayOut[i] = v;
        }
        return arrayOut;
      };
      lib.syncOrAsync = function(sequence, arg, finalStep) {
        var ret, fni;
        function continueAsync() {
          return lib.syncOrAsync(sequence, arg, finalStep);
        }
        while (sequence.length) {
          fni = sequence.splice(0, 1)[0];
          ret = fni(arg);
          if (ret && ret.then) {
            return ret.then(continueAsync);
          }
        }
        return finalStep && finalStep(arg);
      };
      lib.stripTrailingSlash = function(str) {
        if (str.substr(-1) === "/") return str.substr(0, str.length - 1);
        return str;
      };
      lib.noneOrAll = function(containerIn, containerOut, attrList) {
        if (!containerIn) return;
        var hasAny = false;
        var hasAll = true;
        var i;
        var val;
        for (i = 0; i < attrList.length; i++) {
          val = containerIn[attrList[i]];
          if (val !== void 0 && val !== null) hasAny = true;
          else hasAll = false;
        }
        if (hasAny && !hasAll) {
          for (i = 0; i < attrList.length; i++) {
            containerIn[attrList[i]] = containerOut[attrList[i]];
          }
        }
      };
      lib.mergeArray = function(traceAttr, cd, cdAttr, fn) {
        var hasFn = typeof fn === "function";
        if (lib.isArrayOrTypedArray(traceAttr)) {
          var imax = Math.min(traceAttr.length, cd.length);
          for (var i = 0; i < imax; i++) {
            var v = traceAttr[i];
            cd[i][cdAttr] = hasFn ? fn(v) : v;
          }
        }
      };
      lib.mergeArrayCastPositive = function(traceAttr, cd, cdAttr) {
        return lib.mergeArray(traceAttr, cd, cdAttr, function(v) {
          var w = +v;
          return !isFinite(w) ? 0 : w > 0 ? w : 0;
        });
      };
      lib.fillArray = function(traceAttr, cd, cdAttr, fn) {
        fn = fn || lib.identity;
        if (lib.isArrayOrTypedArray(traceAttr)) {
          for (var i = 0; i < cd.length; i++) {
            cd[i][cdAttr] = fn(traceAttr[i]);
          }
        }
      };
      lib.castOption = function(trace, ptNumber, astr, fn) {
        fn = fn || lib.identity;
        var val = lib.nestedProperty(trace, astr).get();
        if (lib.isArrayOrTypedArray(val)) {
          if (Array.isArray(ptNumber) && lib.isArrayOrTypedArray(val[ptNumber[0]])) {
            return fn(val[ptNumber[0]][ptNumber[1]]);
          } else {
            return fn(val[ptNumber]);
          }
        } else {
          return val;
        }
      };
      lib.extractOption = function(calcPt, trace, calcKey, traceKey) {
        if (calcKey in calcPt) return calcPt[calcKey];
        var traceVal = lib.nestedProperty(trace, traceKey).get();
        if (!Array.isArray(traceVal)) return traceVal;
      };
      function makePtIndex2PtNumber(indexToPoints) {
        var ptIndex2ptNumber = {};
        for (var k in indexToPoints) {
          var pts = indexToPoints[k];
          for (var j = 0; j < pts.length; j++) {
            ptIndex2ptNumber[pts[j]] = +k;
          }
        }
        return ptIndex2ptNumber;
      }
      lib.tagSelected = function(calcTrace, trace, ptNumber2cdIndex) {
        var selectedpoints = trace.selectedpoints;
        var indexToPoints = trace._indexToPoints;
        var ptIndex2ptNumber;
        if (indexToPoints) {
          ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);
        }
        function isCdIndexValid(v) {
          return v !== void 0 && v < calcTrace.length;
        }
        for (var i = 0; i < selectedpoints.length; i++) {
          var ptIndex = selectedpoints[i];
          if (lib.isIndex(ptIndex) || lib.isArrayOrTypedArray(ptIndex) && lib.isIndex(ptIndex[0]) && lib.isIndex(ptIndex[1])) {
            var ptNumber = ptIndex2ptNumber ? ptIndex2ptNumber[ptIndex] : ptIndex;
            var cdIndex = ptNumber2cdIndex ? ptNumber2cdIndex[ptNumber] : ptNumber;
            if (isCdIndexValid(cdIndex)) {
              calcTrace[cdIndex].selected = 1;
            }
          }
        }
      };
      lib.selIndices2selPoints = function(trace) {
        var selectedpoints = trace.selectedpoints;
        var indexToPoints = trace._indexToPoints;
        if (indexToPoints) {
          var ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);
          var out = [];
          for (var i = 0; i < selectedpoints.length; i++) {
            var ptIndex = selectedpoints[i];
            if (lib.isIndex(ptIndex)) {
              var ptNumber = ptIndex2ptNumber[ptIndex];
              if (lib.isIndex(ptNumber)) {
                out.push(ptNumber);
              }
            }
          }
          return out;
        } else {
          return selectedpoints;
        }
      };
      lib.getTargetArray = function(trace, transformOpts) {
        var target = transformOpts.target;
        if (typeof target === "string" && target) {
          var array = lib.nestedProperty(trace, target).get();
          return lib.isArrayOrTypedArray(array) ? array : false;
        } else if (lib.isArrayOrTypedArray(target)) {
          return target;
        }
        return false;
      };
      function minExtend(obj1, obj2, opt) {
        var objOut = {};
        if (typeof obj2 !== "object") obj2 = {};
        var arrayLen = opt === "pieLike" ? -1 : 3;
        var keys = Object.keys(obj1);
        var i, k, v;
        for (i = 0; i < keys.length; i++) {
          k = keys[i];
          v = obj1[k];
          if (k.charAt(0) === "_" || typeof v === "function") continue;
          else if (k === "module") objOut[k] = v;
          else if (Array.isArray(v)) {
            if (k === "colorscale" || arrayLen === -1) {
              objOut[k] = v.slice();
            } else {
              objOut[k] = v.slice(0, arrayLen);
            }
          } else if (lib.isTypedArray(v)) {
            if (arrayLen === -1) {
              objOut[k] = v.subarray();
            } else {
              objOut[k] = v.subarray(0, arrayLen);
            }
          } else if (v && typeof v === "object") objOut[k] = minExtend(obj1[k], obj2[k], opt);
          else objOut[k] = v;
        }
        keys = Object.keys(obj2);
        for (i = 0; i < keys.length; i++) {
          k = keys[i];
          v = obj2[k];
          if (typeof v !== "object" || !(k in objOut) || typeof objOut[k] !== "object") {
            objOut[k] = v;
          }
        }
        return objOut;
      }
      lib.minExtend = minExtend;
      lib.titleCase = function(s) {
        return s.charAt(0).toUpperCase() + s.substr(1);
      };
      lib.containsAny = function(s, fragments) {
        for (var i = 0; i < fragments.length; i++) {
          if (s.indexOf(fragments[i]) !== -1) return true;
        }
        return false;
      };
      var IS_SAFARI_REGEX = /Version\/[\d\.]+.*Safari/;
      lib.isSafari = function() {
        return IS_SAFARI_REGEX.test(window.navigator.userAgent);
      };
      var IS_IOS_REGEX = /iPad|iPhone|iPod/;
      lib.isIOS = function() {
        return IS_IOS_REGEX.test(window.navigator.userAgent);
      };
      var FIREFOX_VERSION_REGEX = /Firefox\/(\d+)\.\d+/;
      lib.getFirefoxVersion = function() {
        var match = FIREFOX_VERSION_REGEX.exec(window.navigator.userAgent);
        if (match && match.length === 2) {
          var versionInt = parseInt(match[1]);
          if (!isNaN(versionInt)) {
            return versionInt;
          }
        }
        return null;
      };
      lib.isD3Selection = function(obj) {
        return obj instanceof d3.selection;
      };
      lib.ensureSingle = function(parent, nodeType, className, enterFn) {
        var sel = parent.select(nodeType + (className ? "." + className : ""));
        if (sel.size()) return sel;
        var layer = parent.append(nodeType);
        if (className) layer.classed(className, true);
        if (enterFn) layer.call(enterFn);
        return layer;
      };
      lib.ensureSingleById = function(parent, nodeType, id, enterFn) {
        var sel = parent.select(nodeType + "#" + id);
        if (sel.size()) return sel;
        var layer = parent.append(nodeType).attr("id", id);
        if (enterFn) layer.call(enterFn);
        return layer;
      };
      lib.objectFromPath = function(path, value) {
        var keys = path.split(".");
        var tmpObj;
        var obj = tmpObj = {};
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var el = null;
          var parts = keys[i].match(/(.*)\[([0-9]+)\]/);
          if (parts) {
            key = parts[1];
            el = parts[2];
            tmpObj = tmpObj[key] = [];
            if (i === keys.length - 1) {
              tmpObj[el] = value;
            } else {
              tmpObj[el] = {};
            }
            tmpObj = tmpObj[el];
          } else {
            if (i === keys.length - 1) {
              tmpObj[key] = value;
            } else {
              tmpObj[key] = {};
            }
            tmpObj = tmpObj[key];
          }
        }
        return obj;
      };
      var dottedPropertyRegex = /^([^\[\.]+)\.(.+)?/;
      var indexedPropertyRegex = /^([^\.]+)\[([0-9]+)\](\.)?(.+)?/;
      function notValid(prop) {
        return prop.slice(0, 2) === "__";
      }
      lib.expandObjectPaths = function(data) {
        var match, key, prop, datum, idx, dest, trailingPath;
        if (typeof data === "object" && !Array.isArray(data)) {
          for (key in data) {
            if (data.hasOwnProperty(key)) {
              if (match = key.match(dottedPropertyRegex)) {
                datum = data[key];
                prop = match[1];
                if (notValid(prop)) continue;
                delete data[key];
                data[prop] = lib.extendDeepNoArrays(data[prop] || {}, lib.objectFromPath(key, lib.expandObjectPaths(datum))[prop]);
              } else if (match = key.match(indexedPropertyRegex)) {
                datum = data[key];
                prop = match[1];
                if (notValid(prop)) continue;
                idx = parseInt(match[2]);
                delete data[key];
                data[prop] = data[prop] || [];
                if (match[3] === ".") {
                  trailingPath = match[4];
                  dest = data[prop][idx] = data[prop][idx] || {};
                  lib.extendDeepNoArrays(dest, lib.objectFromPath(trailingPath, lib.expandObjectPaths(datum)));
                } else {
                  if (notValid(prop)) continue;
                  data[prop][idx] = lib.expandObjectPaths(datum);
                }
              } else {
                if (notValid(key)) continue;
                data[key] = lib.expandObjectPaths(data[key]);
              }
            }
          }
        }
        return data;
      };
      lib.numSeparate = function(value, separators, separatethousands) {
        if (!separatethousands) separatethousands = false;
        if (typeof separators !== "string" || separators.length === 0) {
          throw new Error("Separator string required for formatting!");
        }
        if (typeof value === "number") {
          value = String(value);
        }
        var thousandsRe = /(\d+)(\d{3})/;
        var decimalSep = separators.charAt(0);
        var thouSep = separators.charAt(1);
        var x = value.split(".");
        var x1 = x[0];
        var x2 = x.length > 1 ? decimalSep + x[1] : "";
        if (thouSep && (x.length > 1 || x1.length > 4 || separatethousands)) {
          while (thousandsRe.test(x1)) {
            x1 = x1.replace(thousandsRe, "$1" + thouSep + "$2");
          }
        }
        return x1 + x2;
      };
      lib.TEMPLATE_STRING_REGEX = /%{([^\s%{}:]*)([:|\|][^}]*)?}/g;
      var SIMPLE_PROPERTY_REGEX = /^\w*$/;
      lib.templateString = function(string, obj) {
        var getterCache = {};
        return string.replace(lib.TEMPLATE_STRING_REGEX, function(dummy, key) {
          var v;
          if (SIMPLE_PROPERTY_REGEX.test(key)) {
            v = obj[key];
          } else {
            getterCache[key] = getterCache[key] || lib.nestedProperty(obj, key).get;
            v = getterCache[key](true);
          }
          return v !== void 0 ? v : "";
        });
      };
      var hovertemplateWarnings = {
        max: 10,
        count: 0,
        name: "hovertemplate"
      };
      lib.hovertemplateString = function() {
        return templateFormatString.apply(hovertemplateWarnings, arguments);
      };
      var texttemplateWarnings = {
        max: 10,
        count: 0,
        name: "texttemplate"
      };
      lib.texttemplateString = function() {
        return templateFormatString.apply(texttemplateWarnings, arguments);
      };
      var MULT_DIV_REGEX = /^(\S+)([\*\/])(-?\d+(\.\d+)?)$/;
      function multDivParser(inputStr) {
        var match = inputStr.match(MULT_DIV_REGEX);
        if (match) return { key: match[1], op: match[2], number: Number(match[3]) };
        return { key: inputStr, op: null, number: null };
      }
      var texttemplateWarningsForShapes = {
        max: 10,
        count: 0,
        name: "texttemplate",
        parseMultDiv: true
      };
      lib.texttemplateStringForShapes = function() {
        return templateFormatString.apply(texttemplateWarningsForShapes, arguments);
      };
      var TEMPLATE_STRING_FORMAT_SEPARATOR = /^[:|\|]/;
      function templateFormatString(string, labels, d3locale) {
        var opts = this;
        var args = arguments;
        if (!labels) labels = {};
        return string.replace(lib.TEMPLATE_STRING_REGEX, function(match, rawKey, format) {
          var isOther = rawKey === "xother" || rawKey === "yother";
          var isSpaceOther = rawKey === "_xother" || rawKey === "_yother";
          var isSpaceOtherSpace = rawKey === "_xother_" || rawKey === "_yother_";
          var isOtherSpace = rawKey === "xother_" || rawKey === "yother_";
          var hasOther = isOther || isSpaceOther || isOtherSpace || isSpaceOtherSpace;
          var key = rawKey;
          if (isSpaceOther || isSpaceOtherSpace) key = key.substring(1);
          if (isOtherSpace || isSpaceOtherSpace) key = key.substring(0, key.length - 1);
          var parsedOp = null;
          var parsedNumber = null;
          if (opts.parseMultDiv) {
            var _match = multDivParser(key);
            key = _match.key;
            parsedOp = _match.op;
            parsedNumber = _match.number;
          }
          var value;
          if (hasOther) {
            value = labels[key];
            if (value === void 0) return "";
          } else {
            var obj, i;
            for (i = 3; i < args.length; i++) {
              obj = args[i];
              if (!obj) continue;
              if (obj.hasOwnProperty(key)) {
                value = obj[key];
                break;
              }
              if (!SIMPLE_PROPERTY_REGEX.test(key)) {
                value = lib.nestedProperty(obj, key).get(true);
              }
              if (value !== void 0) break;
            }
          }
          if (value !== void 0) {
            if (parsedOp === "*") value *= parsedNumber;
            if (parsedOp === "/") value /= parsedNumber;
          }
          if (value === void 0 && opts) {
            if (opts.count < opts.max) {
              lib.warn("Variable '" + key + "' in " + opts.name + " could not be found!");
              value = match;
            }
            if (opts.count === opts.max) {
              lib.warn("Too many " + opts.name + " warnings - additional warnings will be suppressed");
            }
            opts.count++;
            return match;
          }
          if (format) {
            var fmt;
            if (format[0] === ":") {
              fmt = d3locale ? d3locale.numberFormat : lib.numberFormat;
              if (value !== "") {
                value = fmt(format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR, ""))(value);
              }
            }
            if (format[0] === "|") {
              fmt = d3locale ? d3locale.timeFormat : utcFormat;
              var ms = lib.dateTime2ms(value);
              value = lib.formatDate(ms, format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR, ""), false, fmt);
            }
          } else {
            var keyLabel = key + "Label";
            if (labels.hasOwnProperty(keyLabel)) value = labels[keyLabel];
          }
          if (hasOther) {
            value = "(" + value + ")";
            if (isSpaceOther || isSpaceOtherSpace) value = " " + value;
            if (isOtherSpace || isSpaceOtherSpace) value = value + " ";
          }
          return value;
        });
      }
      var char0 = 48;
      var char9 = 57;
      lib.subplotSort = function(a, b) {
        var l = Math.min(a.length, b.length) + 1;
        var numA = 0;
        var numB = 0;
        for (var i = 0; i < l; i++) {
          var charA = a.charCodeAt(i) || 0;
          var charB = b.charCodeAt(i) || 0;
          var isNumA = charA >= char0 && charA <= char9;
          var isNumB = charB >= char0 && charB <= char9;
          if (isNumA) numA = 10 * numA + charA - char0;
          if (isNumB) numB = 10 * numB + charB - char0;
          if (!isNumA || !isNumB) {
            if (numA !== numB) return numA - numB;
            if (charA !== charB) return charA - charB;
          }
        }
        return numB - numA;
      };
      var randSeed = 2e9;
      lib.seedPseudoRandom = function() {
        randSeed = 2e9;
      };
      lib.pseudoRandom = function() {
        var lastVal = randSeed;
        randSeed = (69069 * randSeed + 1) % 4294967296;
        if (Math.abs(randSeed - lastVal) < 429496729) return lib.pseudoRandom();
        return randSeed / 4294967296;
      };
      lib.fillText = function(calcPt, trace, contOut) {
        var fill = Array.isArray(contOut) ? function(v) {
          contOut.push(v);
        } : function(v) {
          contOut.text = v;
        };
        var htx = lib.extractOption(calcPt, trace, "htx", "hovertext");
        if (lib.isValidTextValue(htx)) return fill(htx);
        var tx = lib.extractOption(calcPt, trace, "tx", "text");
        if (lib.isValidTextValue(tx)) return fill(tx);
      };
      lib.isValidTextValue = function(v) {
        return v || v === 0;
      };
      lib.formatPercent = function(ratio, n) {
        n = n || 0;
        var str = (Math.round(100 * ratio * Math.pow(10, n)) * Math.pow(0.1, n)).toFixed(n) + "%";
        for (var i = 0; i < n; i++) {
          if (str.indexOf(".") !== -1) {
            str = str.replace("0%", "%");
            str = str.replace(".%", "%");
          }
        }
        return str;
      };
      lib.isHidden = function(gd) {
        var display = window.getComputedStyle(gd).display;
        return !display || display === "none";
      };
      lib.strTranslate = function(x, y) {
        return x || y ? "translate(" + x + "," + y + ")" : "";
      };
      lib.strRotate = function(a) {
        return a ? "rotate(" + a + ")" : "";
      };
      lib.strScale = function(s) {
        return s !== 1 ? "scale(" + s + ")" : "";
      };
      lib.getTextTransform = function(transform) {
        var noCenter = transform.noCenter;
        var textX = transform.textX;
        var textY = transform.textY;
        var targetX = transform.targetX;
        var targetY = transform.targetY;
        var anchorX = transform.anchorX || 0;
        var anchorY = transform.anchorY || 0;
        var rotate = transform.rotate;
        var scale = transform.scale;
        if (!scale) scale = 0;
        else if (scale > 1) scale = 1;
        return lib.strTranslate(
          targetX - scale * (textX + anchorX),
          targetY - scale * (textY + anchorY)
        ) + lib.strScale(scale) + (rotate ? "rotate(" + rotate + (noCenter ? "" : " " + textX + " " + textY) + ")" : "");
      };
      lib.setTransormAndDisplay = function(s, transform) {
        s.attr("transform", lib.getTextTransform(transform));
        s.style("display", transform.scale ? null : "none");
      };
      lib.ensureUniformFontSize = function(gd, baseFont) {
        var out = lib.extendFlat({}, baseFont);
        out.size = Math.max(
          baseFont.size,
          gd._fullLayout.uniformtext.minsize || 0
        );
        return out;
      };
      lib.join2 = function(arr, mainSeparator, lastSeparator) {
        var len = arr.length;
        if (len > 1) {
          return arr.slice(0, -1).join(mainSeparator) + lastSeparator + arr[len - 1];
        }
        return arr.join(mainSeparator);
      };
      lib.bigFont = function(size) {
        return Math.round(1.2 * size);
      };
      var firefoxVersion = lib.getFirefoxVersion();
      var isProblematicFirefox = firefoxVersion !== null && firefoxVersion < 86;
      lib.getPositionFromD3Event = function() {
        if (isProblematicFirefox) {
          return [
            d3.event.layerX,
            d3.event.layerY
          ];
        } else {
          return [
            d3.event.offsetX,
            d3.event.offsetY
          ];
        }
      };
    }
  });

  // build/plotcss.js
  var require_plotcss = __commonJS({
    "build/plotcss.js"() {
      "use strict";
      var Lib = require_lib();
      var rules = {
        "X,X div": 'direction:ltr;font-family:"Open Sans",verdana,arial,sans-serif;margin:0;padding:0;',
        "X input,X button": 'font-family:"Open Sans",verdana,arial,sans-serif;',
        "X input:focus,X button:focus": "outline:none;",
        "X a": "text-decoration:none;",
        "X a:hover": "text-decoration:none;",
        "X .crisp": "shape-rendering:crispEdges;",
        "X .user-select-none": "-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;",
        "X svg a": "fill:#447adb;",
        "X svg a:hover": "fill:#3c6dc5;",
        "X .main-svg": "position:absolute;top:0;left:0;pointer-events:none;",
        "X .main-svg .draglayer": "pointer-events:all;",
        "X .cursor-default": "cursor:default;",
        "X .cursor-pointer": "cursor:pointer;",
        "X .cursor-crosshair": "cursor:crosshair;",
        "X .cursor-move": "cursor:move;",
        "X .cursor-col-resize": "cursor:col-resize;",
        "X .cursor-row-resize": "cursor:row-resize;",
        "X .cursor-ns-resize": "cursor:ns-resize;",
        "X .cursor-ew-resize": "cursor:ew-resize;",
        "X .cursor-sw-resize": "cursor:sw-resize;",
        "X .cursor-s-resize": "cursor:s-resize;",
        "X .cursor-se-resize": "cursor:se-resize;",
        "X .cursor-w-resize": "cursor:w-resize;",
        "X .cursor-e-resize": "cursor:e-resize;",
        "X .cursor-nw-resize": "cursor:nw-resize;",
        "X .cursor-n-resize": "cursor:n-resize;",
        "X .cursor-ne-resize": "cursor:ne-resize;",
        "X .cursor-grab": "cursor:-webkit-grab;cursor:grab;",
        "X .modebar": "position:absolute;top:2px;right:2px;",
        "X .ease-bg": "-webkit-transition:background-color .3s ease 0s;-moz-transition:background-color .3s ease 0s;-ms-transition:background-color .3s ease 0s;-o-transition:background-color .3s ease 0s;transition:background-color .3s ease 0s;",
        "X .modebar--hover>:not(.watermark)": "opacity:0;-webkit-transition:opacity .3s ease 0s;-moz-transition:opacity .3s ease 0s;-ms-transition:opacity .3s ease 0s;-o-transition:opacity .3s ease 0s;transition:opacity .3s ease 0s;",
        "X:hover .modebar--hover .modebar-group": "opacity:1;",
        "X .modebar-group": "float:left;display:inline-block;box-sizing:border-box;padding-left:8px;position:relative;vertical-align:middle;white-space:nowrap;",
        "X .modebar-btn": "position:relative;font-size:16px;padding:3px 4px;height:22px;cursor:pointer;line-height:normal;box-sizing:border-box;",
        "X .modebar-btn svg": "position:relative;top:2px;",
        "X .modebar.vertical": "display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-end;max-height:100%;",
        "X .modebar.vertical svg": "top:-1px;",
        "X .modebar.vertical .modebar-group": "display:block;float:none;padding-left:0px;padding-bottom:8px;",
        "X .modebar.vertical .modebar-group .modebar-btn": "display:block;text-align:center;",
        "X [data-title]:before,X [data-title]:after": "position:absolute;-webkit-transform:translate3d(0, 0, 0);-moz-transform:translate3d(0, 0, 0);-ms-transform:translate3d(0, 0, 0);-o-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);display:none;opacity:0;z-index:1001;pointer-events:none;top:110%;right:50%;",
        "X [data-title]:hover:before,X [data-title]:hover:after": "display:block;opacity:1;",
        "X [data-title]:before": 'content:"";position:absolute;background:rgba(0,0,0,0);border:6px solid rgba(0,0,0,0);z-index:1002;margin-top:-12px;border-bottom-color:#69738a;margin-right:-6px;',
        "X [data-title]:after": "content:attr(data-title);background:#69738a;color:#fff;padding:8px 10px;font-size:12px;line-height:12px;white-space:nowrap;margin-right:-18px;border-radius:2px;",
        "X .vertical [data-title]:before,X .vertical [data-title]:after": "top:0%;right:200%;",
        "X .vertical [data-title]:before": "border:6px solid rgba(0,0,0,0);border-left-color:#69738a;margin-top:8px;margin-right:-30px;",
        Y: 'font-family:"Open Sans",verdana,arial,sans-serif;position:fixed;top:50px;right:20px;z-index:10000;font-size:10pt;max-width:180px;',
        "Y p": "margin:0;",
        "Y .notifier-note": "min-width:180px;max-width:250px;border:1px solid #fff;z-index:3000;margin:0;background-color:#8c97af;background-color:rgba(140,151,175,.9);color:#fff;padding:10px;overflow-wrap:break-word;word-wrap:break-word;-ms-hyphens:auto;-webkit-hyphens:auto;hyphens:auto;",
        "Y .notifier-close": "color:#fff;opacity:.8;float:right;padding:0 5px;background:none;border:none;font-size:20px;font-weight:bold;line-height:20px;",
        "Y .notifier-close:hover": "color:#444;text-decoration:none;cursor:pointer;"
      };
      for (selector in rules) {
        fullSelector = selector.replace(/^,/, " ,").replace(/X/g, ".js-plotly-plot .plotly").replace(/Y/g, ".plotly-notifier");
        Lib.addStyleRule(fullSelector, rules[selector]);
      }
      var fullSelector;
      var selector;
    }
  });

  // node_modules/is-browser/client.js
  var require_client = __commonJS({
    "node_modules/is-browser/client.js"(exports, module) {
      module.exports = true;
    }
  });

  // node_modules/has-hover/index.js
  var require_has_hover = __commonJS({
    "node_modules/has-hover/index.js"(exports, module) {
      "use strict";
      var isBrowser = require_client();
      var hasHover;
      if (typeof window.matchMedia === "function") {
        hasHover = !window.matchMedia("(hover: none)").matches;
      } else {
        hasHover = isBrowser;
      }
      module.exports = hasHover;
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // src/lib/events.js
  var require_events2 = __commonJS({
    "src/lib/events.js"(exports, module) {
      "use strict";
      var EventEmitter = require_events().EventEmitter;
      var Events = {
        init: function(plotObj) {
          if (plotObj._ev instanceof EventEmitter) return plotObj;
          var ev = new EventEmitter();
          var internalEv = new EventEmitter();
          plotObj._ev = ev;
          plotObj._internalEv = internalEv;
          plotObj.on = ev.on.bind(ev);
          plotObj.once = ev.once.bind(ev);
          plotObj.removeListener = ev.removeListener.bind(ev);
          plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);
          plotObj._internalOn = internalEv.on.bind(internalEv);
          plotObj._internalOnce = internalEv.once.bind(internalEv);
          plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);
          plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);
          plotObj.emit = function(event, data) {
            ev.emit(event, data);
            internalEv.emit(event, data);
          };
          return plotObj;
        },
        /*
         * This function behaves like jQuery's triggerHandler. It calls
         * all handlers for a particular event and returns the return value
         * of the LAST handler.
         */
        triggerHandler: function(plotObj, event, data) {
          var nodeEventHandlerValue;
          var ev = plotObj._ev;
          if (!ev) return;
          var handlers = ev._events[event];
          if (!handlers) return;
          function apply(handler) {
            if (handler.listener) {
              ev.removeListener(event, handler.listener);
              if (!handler.fired) {
                handler.fired = true;
                return handler.listener.apply(ev, [data]);
              }
            } else {
              return handler.apply(ev, [data]);
            }
          }
          handlers = Array.isArray(handlers) ? handlers : [handlers];
          var i;
          for (i = 0; i < handlers.length - 1; i++) {
            apply(handlers[i]);
          }
          nodeEventHandlerValue = apply(handlers[i]);
          return nodeEventHandlerValue;
        },
        purge: function(plotObj) {
          delete plotObj._ev;
          delete plotObj.on;
          delete plotObj.once;
          delete plotObj.removeListener;
          delete plotObj.removeAllListeners;
          delete plotObj.emit;
          delete plotObj._ev;
          delete plotObj._internalEv;
          delete plotObj._internalOn;
          delete plotObj._internalOnce;
          delete plotObj._removeInternalListener;
          delete plotObj._removeAllInternalListeners;
          return plotObj;
        }
      };
      module.exports = Events;
    }
  });

  // src/lib/queue.js
  var require_queue = __commonJS({
    "src/lib/queue.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var dfltConfig = require_plot_config().dfltConfig;
      function copyArgArray(gd, args) {
        var copy = [];
        var arg;
        for (var i = 0; i < args.length; i++) {
          arg = args[i];
          if (arg === gd) copy[i] = arg;
          else if (typeof arg === "object") {
            copy[i] = Array.isArray(arg) ? Lib.extendDeep([], arg) : Lib.extendDeepAll({}, arg);
          } else copy[i] = arg;
        }
        return copy;
      }
      var queue = {};
      queue.add = function(gd, undoFunc, undoArgs, redoFunc, redoArgs) {
        var queueObj, queueIndex;
        gd.undoQueue = gd.undoQueue || { index: 0, queue: [], sequence: false };
        queueIndex = gd.undoQueue.index;
        if (gd.autoplay) {
          if (!gd.undoQueue.inSequence) gd.autoplay = false;
          return;
        }
        if (!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {
          queueObj = { undo: { calls: [], args: [] }, redo: { calls: [], args: [] } };
          gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);
          gd.undoQueue.index += 1;
        } else {
          queueObj = gd.undoQueue.queue[queueIndex - 1];
        }
        gd.undoQueue.beginSequence = false;
        if (queueObj) {
          queueObj.undo.calls.unshift(undoFunc);
          queueObj.undo.args.unshift(undoArgs);
          queueObj.redo.calls.push(redoFunc);
          queueObj.redo.args.push(redoArgs);
        }
        if (gd.undoQueue.queue.length > dfltConfig.queueLength) {
          gd.undoQueue.queue.shift();
          gd.undoQueue.index--;
        }
      };
      queue.startSequence = function(gd) {
        gd.undoQueue = gd.undoQueue || { index: 0, queue: [], sequence: false };
        gd.undoQueue.sequence = true;
        gd.undoQueue.beginSequence = true;
      };
      queue.stopSequence = function(gd) {
        gd.undoQueue = gd.undoQueue || { index: 0, queue: [], sequence: false };
        gd.undoQueue.sequence = false;
        gd.undoQueue.beginSequence = false;
      };
      queue.undo = function undo(gd) {
        var queueObj, i;
        if (gd.undoQueue === void 0 || isNaN(gd.undoQueue.index) || gd.undoQueue.index <= 0) {
          return;
        }
        gd.undoQueue.index--;
        queueObj = gd.undoQueue.queue[gd.undoQueue.index];
        gd.undoQueue.inSequence = true;
        for (i = 0; i < queueObj.undo.calls.length; i++) {
          queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);
        }
        gd.undoQueue.inSequence = false;
        gd.autoplay = false;
      };
      queue.redo = function redo(gd) {
        var queueObj, i;
        if (gd.undoQueue === void 0 || isNaN(gd.undoQueue.index) || gd.undoQueue.index >= gd.undoQueue.queue.length) {
          return;
        }
        queueObj = gd.undoQueue.queue[gd.undoQueue.index];
        gd.undoQueue.inSequence = true;
        for (i = 0; i < queueObj.redo.calls.length; i++) {
          queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);
        }
        gd.undoQueue.inSequence = false;
        gd.autoplay = false;
        gd.undoQueue.index++;
      };
      queue.plotDo = function(gd, func, args) {
        gd.autoplay = true;
        args = copyArgArray(gd, args);
        func.apply(null, args);
      };
      module.exports = queue;
    }
  });

  // src/plots/frame_attributes.js
  var require_frame_attributes = __commonJS({
    "src/plots/frame_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        _isLinkedToArray: "frames_entry",
        group: {
          valType: "string"
        },
        name: {
          valType: "string"
        },
        traces: {
          valType: "any"
        },
        baseframe: {
          valType: "string"
        },
        data: {
          valType: "any"
        },
        layout: {
          valType: "any"
        }
      };
    }
  });

  // src/plot_api/plot_schema.js
  var require_plot_schema = __commonJS({
    "src/plot_api/plot_schema.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var baseAttributes = require_attributes2();
      var baseLayoutAttributes = require_layout_attributes2();
      var frameAttributes = require_frame_attributes();
      var animationAttributes = require_animation_attributes();
      var configAttributes = require_plot_config().configAttributes;
      var editTypes = require_edit_types();
      var extendDeepAll = Lib.extendDeepAll;
      var isPlainObject = Lib.isPlainObject;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var nestedProperty = Lib.nestedProperty;
      var valObjectMeta = Lib.valObjectMeta;
      var IS_SUBPLOT_OBJ = "_isSubplotObj";
      var IS_LINKED_TO_ARRAY = "_isLinkedToArray";
      var ARRAY_ATTR_REGEXPS = "_arrayAttrRegexps";
      var DEPRECATED = "_deprecated";
      var UNDERSCORE_ATTRS = [IS_SUBPLOT_OBJ, IS_LINKED_TO_ARRAY, ARRAY_ATTR_REGEXPS, DEPRECATED];
      exports.IS_SUBPLOT_OBJ = IS_SUBPLOT_OBJ;
      exports.IS_LINKED_TO_ARRAY = IS_LINKED_TO_ARRAY;
      exports.DEPRECATED = DEPRECATED;
      exports.UNDERSCORE_ATTRS = UNDERSCORE_ATTRS;
      exports.get = function() {
        var traces = {};
        Registry.allTypes.forEach(function(type) {
          traces[type] = getTraceAttributes(type);
        });
        return {
          defs: {
            valObjects: valObjectMeta,
            metaKeys: UNDERSCORE_ATTRS.concat(["description", "role", "editType", "impliedEdits"]),
            editType: {
              traces: editTypes.traces,
              layout: editTypes.layout
            },
            impliedEdits: {}
          },
          traces,
          layout: getLayoutAttributes(),
          frames: getFramesAttributes(),
          animation: formatAttributes(animationAttributes),
          config: formatAttributes(configAttributes)
        };
      };
      exports.crawl = function(attrs, callback, specifiedLevel, attrString) {
        var level = specifiedLevel || 0;
        attrString = attrString || "";
        Object.keys(attrs).forEach(function(attrName) {
          var attr = attrs[attrName];
          if (UNDERSCORE_ATTRS.indexOf(attrName) !== -1) return;
          var fullAttrString = (attrString ? attrString + "." : "") + attrName;
          callback(attr, attrName, attrs, level, fullAttrString);
          if (exports.isValObject(attr)) return;
          if (isPlainObject(attr) && attrName !== "impliedEdits") {
            exports.crawl(attr, callback, level + 1, fullAttrString);
          }
        });
      };
      exports.isValObject = function(obj) {
        return obj && obj.valType !== void 0;
      };
      exports.findArrayAttributes = function(trace) {
        var arrayAttributes = [];
        var stack = [];
        var isArrayStack = [];
        var baseContainer, baseAttrName;
        function callback(attr, attrName, attrs, level) {
          stack = stack.slice(0, level).concat([attrName]);
          isArrayStack = isArrayStack.slice(0, level).concat([attr && attr._isLinkedToArray]);
          var splittableAttr = attr && (attr.valType === "data_array" || attr.arrayOk === true) && !(stack[level - 1] === "colorbar" && (attrName === "ticktext" || attrName === "tickvals"));
          if (!splittableAttr) return;
          crawlIntoTrace(baseContainer, 0, "");
        }
        function crawlIntoTrace(container, i, astrPartial) {
          var item = container[stack[i]];
          var newAstrPartial = astrPartial + stack[i];
          if (i === stack.length - 1) {
            if (isArrayOrTypedArray(item)) {
              arrayAttributes.push(baseAttrName + newAstrPartial);
            }
          } else {
            if (isArrayStack[i]) {
              if (Array.isArray(item)) {
                for (var j = 0; j < item.length; j++) {
                  if (isPlainObject(item[j])) {
                    crawlIntoTrace(item[j], i + 1, newAstrPartial + "[" + j + "].");
                  }
                }
              }
            } else if (isPlainObject(item)) {
              crawlIntoTrace(item, i + 1, newAstrPartial + ".");
            }
          }
        }
        baseContainer = trace;
        baseAttrName = "";
        exports.crawl(baseAttributes, callback);
        if (trace._module && trace._module.attributes) {
          exports.crawl(trace._module.attributes, callback);
        }
        return arrayAttributes;
      };
      exports.getTraceValObject = function(trace, parts) {
        var head = parts[0];
        var i = 1;
        var moduleAttrs, valObject;
        var _module = trace._module;
        if (!_module) _module = (Registry.modules[trace.type || baseAttributes.type.dflt] || {})._module;
        if (!_module) return false;
        moduleAttrs = _module.attributes;
        valObject = moduleAttrs && moduleAttrs[head];
        if (!valObject) {
          var subplotModule = _module.basePlotModule;
          if (subplotModule && subplotModule.attributes) {
            valObject = subplotModule.attributes[head];
          }
        }
        if (!valObject) valObject = baseAttributes[head];
        return recurseIntoValObject(valObject, parts, i);
      };
      exports.getLayoutValObject = function(fullLayout, parts) {
        var valObject = layoutHeadAttr(fullLayout, parts[0]);
        return recurseIntoValObject(valObject, parts, 1);
      };
      function layoutHeadAttr(fullLayout, head) {
        var i, key, _module, attributes;
        var basePlotModules = fullLayout._basePlotModules;
        if (basePlotModules) {
          var out;
          for (i = 0; i < basePlotModules.length; i++) {
            _module = basePlotModules[i];
            if (_module.attrRegex && _module.attrRegex.test(head)) {
              if (_module.layoutAttrOverrides) return _module.layoutAttrOverrides;
              if (!out && _module.layoutAttributes) out = _module.layoutAttributes;
            }
            var baseOverrides = _module.baseLayoutAttrOverrides;
            if (baseOverrides && head in baseOverrides) return baseOverrides[head];
          }
          if (out) return out;
        }
        var modules = fullLayout._modules;
        if (modules) {
          for (i = 0; i < modules.length; i++) {
            attributes = modules[i].layoutAttributes;
            if (attributes && head in attributes) {
              return attributes[head];
            }
          }
        }
        for (key in Registry.componentsRegistry) {
          _module = Registry.componentsRegistry[key];
          if (_module.name === "colorscale" && head.indexOf("coloraxis") === 0) {
            return _module.layoutAttributes[head];
          } else if (!_module.schema && head === _module.name) {
            return _module.layoutAttributes;
          }
        }
        if (head in baseLayoutAttributes) return baseLayoutAttributes[head];
        return false;
      }
      function recurseIntoValObject(valObject, parts, i) {
        if (!valObject) return false;
        if (valObject._isLinkedToArray) {
          if (isIndex(parts[i])) i++;
          else if (i < parts.length) return false;
        }
        for (; i < parts.length; i++) {
          var newValObject = valObject[parts[i]];
          if (isPlainObject(newValObject)) valObject = newValObject;
          else break;
          if (i === parts.length - 1) break;
          if (valObject._isLinkedToArray) {
            i++;
            if (!isIndex(parts[i])) return false;
          } else if (valObject.valType === "info_array") {
            i++;
            var index = parts[i];
            if (!isIndex(index)) return false;
            var items = valObject.items;
            if (Array.isArray(items)) {
              if (index >= items.length) return false;
              if (valObject.dimensions === 2) {
                i++;
                if (parts.length === i) return valObject;
                var index2 = parts[i];
                if (!isIndex(index2)) return false;
                valObject = items[index][index2];
              } else valObject = items[index];
            } else {
              valObject = items;
            }
          }
        }
        return valObject;
      }
      function isIndex(val) {
        return val === Math.round(val) && val >= 0;
      }
      function getTraceAttributes(type) {
        var _module, basePlotModule;
        _module = Registry.modules[type]._module, basePlotModule = _module.basePlotModule;
        var attributes = {};
        attributes.type = null;
        var copyBaseAttributes = extendDeepAll({}, baseAttributes);
        var copyModuleAttributes = extendDeepAll({}, _module.attributes);
        exports.crawl(copyModuleAttributes, function(attr, attrName, attrs, level, fullAttrString) {
          nestedProperty(copyBaseAttributes, fullAttrString).set(void 0);
          if (attr === void 0) nestedProperty(copyModuleAttributes, fullAttrString).set(void 0);
        });
        extendDeepAll(attributes, copyBaseAttributes);
        if (Registry.traceIs(type, "noOpacity")) {
          delete attributes.opacity;
        }
        if (!Registry.traceIs(type, "showLegend")) {
          delete attributes.showlegend;
          delete attributes.legendgroup;
        }
        if (Registry.traceIs(type, "noHover")) {
          delete attributes.hoverinfo;
          delete attributes.hoverlabel;
        }
        if (!_module.selectPoints) {
          delete attributes.selectedpoints;
        }
        extendDeepAll(attributes, copyModuleAttributes);
        if (basePlotModule.attributes) {
          extendDeepAll(attributes, basePlotModule.attributes);
        }
        attributes.type = type;
        var out = {
          meta: _module.meta || {},
          categories: _module.categories || {},
          animatable: Boolean(_module.animatable),
          type,
          attributes: formatAttributes(attributes)
        };
        if (_module.layoutAttributes) {
          var layoutAttributes = {};
          extendDeepAll(layoutAttributes, _module.layoutAttributes);
          out.layoutAttributes = formatAttributes(layoutAttributes);
        }
        if (!_module.animatable) {
          exports.crawl(out, function(attr) {
            if (exports.isValObject(attr) && "anim" in attr) {
              delete attr.anim;
            }
          });
        }
        return out;
      }
      function getLayoutAttributes() {
        var layoutAttributes = {};
        var key, _module;
        extendDeepAll(layoutAttributes, baseLayoutAttributes);
        for (key in Registry.subplotsRegistry) {
          _module = Registry.subplotsRegistry[key];
          if (!_module.layoutAttributes) continue;
          if (Array.isArray(_module.attr)) {
            for (var i = 0; i < _module.attr.length; i++) {
              handleBasePlotModule(layoutAttributes, _module, _module.attr[i]);
            }
          } else {
            var astr = _module.attr === "subplot" ? _module.name : _module.attr;
            handleBasePlotModule(layoutAttributes, _module, astr);
          }
        }
        for (key in Registry.componentsRegistry) {
          _module = Registry.componentsRegistry[key];
          var schema = _module.schema;
          if (schema && (schema.subplots || schema.layout)) {
            var subplots = schema.subplots;
            if (subplots && subplots.xaxis && !subplots.yaxis) {
              for (var xkey in subplots.xaxis) {
                delete layoutAttributes.yaxis[xkey];
              }
            }
            delete layoutAttributes.xaxis.shift;
            delete layoutAttributes.xaxis.autoshift;
          } else if (_module.name === "colorscale") {
            extendDeepAll(layoutAttributes, _module.layoutAttributes);
          } else if (_module.layoutAttributes) {
            insertAttrs(layoutAttributes, _module.layoutAttributes, _module.name);
          }
        }
        return {
          layoutAttributes: formatAttributes(layoutAttributes)
        };
      }
      function getFramesAttributes() {
        var attrs = {
          frames: extendDeepAll({}, frameAttributes)
        };
        formatAttributes(attrs);
        return attrs.frames;
      }
      function formatAttributes(attrs) {
        mergeValTypeAndRole(attrs);
        formatArrayContainers(attrs);
        stringify(attrs);
        return attrs;
      }
      function mergeValTypeAndRole(attrs) {
        function makeSrcAttr(attrName) {
          return {
            valType: "string",
            editType: "none"
          };
        }
        function callback(attr, attrName, attrs2) {
          if (exports.isValObject(attr)) {
            if (attr.arrayOk === true || attr.valType === "data_array") {
              attrs2[attrName + "src"] = makeSrcAttr(attrName);
            }
          } else if (isPlainObject(attr)) {
            attr.role = "object";
          }
        }
        exports.crawl(attrs, callback);
      }
      function formatArrayContainers(attrs) {
        function callback(attr, attrName, attrs2) {
          if (!attr) return;
          var itemName = attr[IS_LINKED_TO_ARRAY];
          if (!itemName) return;
          delete attr[IS_LINKED_TO_ARRAY];
          attrs2[attrName] = { items: {} };
          attrs2[attrName].items[itemName] = attr;
          attrs2[attrName].role = "object";
        }
        exports.crawl(attrs, callback);
      }
      function stringify(attrs) {
        function walk(attr) {
          for (var k in attr) {
            if (isPlainObject(attr[k])) {
              walk(attr[k]);
            } else if (Array.isArray(attr[k])) {
              for (var i = 0; i < attr[k].length; i++) {
                walk(attr[k][i]);
              }
            } else {
              if (attr[k] instanceof RegExp) {
                attr[k] = attr[k].toString();
              }
            }
          }
        }
        walk(attrs);
      }
      function handleBasePlotModule(layoutAttributes, _module, astr) {
        var np = nestedProperty(layoutAttributes, astr);
        var attrs = extendDeepAll({}, _module.layoutAttributes);
        attrs[IS_SUBPLOT_OBJ] = true;
        np.set(attrs);
      }
      function insertAttrs(baseAttrs, newAttrs, astr) {
        var np = nestedProperty(baseAttrs, astr);
        np.set(extendDeepAll(np.get() || {}, newAttrs));
      }
    }
  });

  // src/plot_api/plot_template.js
  var require_plot_template = __commonJS({
    "src/plot_api/plot_template.js"(exports) {
      "use strict";
      var Lib = require_lib();
      var plotAttributes = require_attributes2();
      var TEMPLATEITEMNAME = "templateitemname";
      var templateAttrs = {
        name: {
          valType: "string",
          editType: "none"
        }
      };
      templateAttrs[TEMPLATEITEMNAME] = {
        valType: "string",
        editType: "calc"
      };
      exports.templatedArray = function(name, attrs) {
        attrs._isLinkedToArray = name;
        attrs.name = templateAttrs.name;
        attrs[TEMPLATEITEMNAME] = templateAttrs[TEMPLATEITEMNAME];
        return attrs;
      };
      exports.traceTemplater = function(dataTemplate) {
        var traceCounts = {};
        var traceType, typeTemplates;
        for (traceType in dataTemplate) {
          typeTemplates = dataTemplate[traceType];
          if (Array.isArray(typeTemplates) && typeTemplates.length) {
            traceCounts[traceType] = 0;
          }
        }
        function newTrace(traceIn) {
          traceType = Lib.coerce(traceIn, {}, plotAttributes, "type");
          var traceOut = { type: traceType, _template: null };
          if (traceType in traceCounts) {
            typeTemplates = dataTemplate[traceType];
            var typei = traceCounts[traceType] % typeTemplates.length;
            traceCounts[traceType]++;
            traceOut._template = typeTemplates[typei];
          } else {
          }
          return traceOut;
        }
        return {
          newTrace
          // TODO: function to figure out what's left & what didn't work
        };
      };
      exports.newContainer = function(container, name, baseName) {
        var template = container._template;
        var part = template && (template[name] || baseName && template[baseName]);
        if (!Lib.isPlainObject(part)) part = null;
        var out = container[name] = { _template: part };
        return out;
      };
      exports.arrayTemplater = function(container, name, inclusionAttr) {
        var template = container._template;
        var defaultsTemplate = template && template[arrayDefaultKey(name)];
        var templateItems = template && template[name];
        if (!Array.isArray(templateItems) || !templateItems.length) {
          templateItems = [];
        }
        var usedNames = {};
        function newItem(itemIn) {
          var out = { name: itemIn.name, _input: itemIn };
          var templateItemName = out[TEMPLATEITEMNAME] = itemIn[TEMPLATEITEMNAME];
          if (!validItemName(templateItemName)) {
            out._template = defaultsTemplate;
            return out;
          }
          for (var i = 0; i < templateItems.length; i++) {
            var templateItem = templateItems[i];
            if (templateItem.name === templateItemName) {
              usedNames[templateItemName] = 1;
              out._template = templateItem;
              return out;
            }
          }
          out[inclusionAttr] = itemIn[inclusionAttr] || false;
          out._template = false;
          return out;
        }
        function defaultItems() {
          var out = [];
          for (var i = 0; i < templateItems.length; i++) {
            var templateItem = templateItems[i];
            var name2 = templateItem.name;
            if (validItemName(name2) && !usedNames[name2]) {
              var outi = {
                _template: templateItem,
                name: name2,
                _input: { _templateitemname: name2 }
              };
              outi[TEMPLATEITEMNAME] = templateItem[TEMPLATEITEMNAME];
              out.push(outi);
              usedNames[name2] = 1;
            }
          }
          return out;
        }
        return {
          newItem,
          defaultItems
        };
      };
      function validItemName(name) {
        return name && typeof name === "string";
      }
      function arrayDefaultKey(name) {
        var lastChar = name.length - 1;
        if (name.charAt(lastChar) !== "s") {
          Lib.warn("bad argument to arrayDefaultKey: " + name);
        }
        return name.substr(0, name.length - 1) + "defaults";
      }
      exports.arrayDefaultKey = arrayDefaultKey;
      exports.arrayEditor = function(parentIn, containerStr, itemOut) {
        var lengthIn = (Lib.nestedProperty(parentIn, containerStr).get() || []).length;
        var index = itemOut._index;
        var templateItemName = index >= lengthIn && (itemOut._input || {})._templateitemname;
        if (templateItemName) index = lengthIn;
        var itemStr = containerStr + "[" + index + "]";
        var update;
        function resetUpdate() {
          update = {};
          if (templateItemName) {
            update[itemStr] = {};
            update[itemStr][TEMPLATEITEMNAME] = templateItemName;
          }
        }
        resetUpdate();
        function modifyBase(attr, value) {
          update[attr] = value;
        }
        function modifyItem(attr, value) {
          if (templateItemName) {
            Lib.nestedProperty(update[itemStr], attr).set(value);
          } else {
            update[itemStr + "." + attr] = value;
          }
        }
        function getUpdateObj() {
          var updateOut = update;
          resetUpdate();
          return updateOut;
        }
        function applyUpdate(attr, value) {
          if (attr) modifyItem(attr, value);
          var updateToApply = getUpdateObj();
          for (var key in updateToApply) {
            Lib.nestedProperty(parentIn, key).set(updateToApply[key]);
          }
        }
        return {
          modifyBase,
          modifyItem,
          getUpdateObj,
          applyUpdate
        };
      };
    }
  });

  // src/plots/cartesian/constants.js
  var require_constants2 = __commonJS({
    "src/plots/cartesian/constants.js"(exports, module) {
      "use strict";
      var counterRegex = require_regex().counter;
      module.exports = {
        idRegex: {
          x: counterRegex("x", "( domain)?"),
          y: counterRegex("y", "( domain)?")
        },
        attrRegex: counterRegex("[xy]axis"),
        // axis match regular expression
        xAxisMatch: counterRegex("xaxis"),
        yAxisMatch: counterRegex("yaxis"),
        // pattern matching axis ids and names
        // note that this is more permissive than counterRegex, as
        // id2name, name2id, and cleanId accept "x1" etc
        AX_ID_PATTERN: /^[xyz][0-9]*( domain)?$/,
        AX_NAME_PATTERN: /^[xyz]axis[0-9]*$/,
        // and for 2D subplots
        SUBPLOT_PATTERN: /^x([0-9]*)y([0-9]*)$/,
        HOUR_PATTERN: "hour",
        WEEKDAY_PATTERN: "day of week",
        // pixels to move mouse before you stop clamping to starting point
        MINDRAG: 8,
        // smallest dimension allowed for a zoombox
        MINZOOM: 20,
        // width of axis drag regions
        DRAGGERSIZE: 20,
        // delay before a redraw (relayout) after smooth panning and zooming
        REDRAWDELAY: 50,
        // last resort axis ranges for x and y axes if we have no data
        DFLTRANGEX: [-1, 6],
        DFLTRANGEY: [-1, 4],
        // Layers to keep trace types in the right order
        // N.B. each  'unique' plot method must have its own layer
        traceLayerClasses: [
          "imagelayer",
          "heatmaplayer",
          "contourcarpetlayer",
          "contourlayer",
          "funnellayer",
          "waterfalllayer",
          "barlayer",
          "carpetlayer",
          "violinlayer",
          "boxlayer",
          "ohlclayer",
          "scattercarpetlayer",
          "scatterlayer"
        ],
        clipOnAxisFalseQuery: [
          ".scatterlayer",
          ".barlayer",
          ".funnellayer",
          ".waterfalllayer"
        ],
        layerValue2layerClass: {
          "above traces": "above",
          "below traces": "below"
        },
        zindexSeparator: "z"
        // used for zindex of cartesian subplots e.g. xy, xyz2, xyz3, etc.
      };
    }
  });

  // src/plots/cartesian/axis_ids.js
  var require_axis_ids = __commonJS({
    "src/plots/cartesian/axis_ids.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var constants = require_constants2();
      exports.id2name = function id2name(id) {
        if (typeof id !== "string" || !id.match(constants.AX_ID_PATTERN)) return;
        var axNum = id.split(" ")[0].substr(1);
        if (axNum === "1") axNum = "";
        return id.charAt(0) + "axis" + axNum;
      };
      exports.name2id = function name2id(name) {
        if (!name.match(constants.AX_NAME_PATTERN)) return;
        var axNum = name.substr(5);
        if (axNum === "1") axNum = "";
        return name.charAt(0) + axNum;
      };
      exports.cleanId = function cleanId(id, axLetter, domainId) {
        var domainTest = /( domain)$/.test(id);
        if (typeof id !== "string" || !id.match(constants.AX_ID_PATTERN)) return;
        if (axLetter && id.charAt(0) !== axLetter) return;
        if (domainTest && !domainId) return;
        var axNum = id.split(" ")[0].substr(1).replace(/^0+/, "");
        if (axNum === "1") axNum = "";
        return id.charAt(0) + axNum + (domainTest && domainId ? " domain" : "");
      };
      exports.list = function(gd, axLetter, only2d) {
        var fullLayout = gd._fullLayout;
        if (!fullLayout) return [];
        var idList = exports.listIds(gd, axLetter);
        var out = new Array(idList.length);
        var i;
        for (i = 0; i < idList.length; i++) {
          var idi = idList[i];
          out[i] = fullLayout[idi.charAt(0) + "axis" + idi.substr(1)];
        }
        if (!only2d) {
          var sceneIds3D = fullLayout._subplots.gl3d || [];
          for (i = 0; i < sceneIds3D.length; i++) {
            var scene = fullLayout[sceneIds3D[i]];
            if (axLetter) out.push(scene[axLetter + "axis"]);
            else out.push(scene.xaxis, scene.yaxis, scene.zaxis);
          }
        }
        return out;
      };
      exports.listIds = function(gd, axLetter) {
        var fullLayout = gd._fullLayout;
        if (!fullLayout) return [];
        var subplotLists = fullLayout._subplots;
        if (axLetter) return subplotLists[axLetter + "axis"];
        return subplotLists.xaxis.concat(subplotLists.yaxis);
      };
      exports.getFromId = function(gd, id, type) {
        var fullLayout = gd._fullLayout;
        id = id === void 0 || typeof id !== "string" ? id : id.replace(" domain", "");
        if (type === "x") id = id.replace(/y[0-9]*/, "");
        else if (type === "y") id = id.replace(/x[0-9]*/, "");
        return fullLayout[exports.id2name(id)];
      };
      exports.getFromTrace = function(gd, fullTrace, type) {
        var fullLayout = gd._fullLayout;
        var ax = null;
        if (Registry.traceIs(fullTrace, "gl3d")) {
          var scene = fullTrace.scene;
          if (scene.substr(0, 5) === "scene") {
            ax = fullLayout[scene][type + "axis"];
          }
        } else {
          ax = exports.getFromId(gd, fullTrace[type + "axis"] || type);
        }
        return ax;
      };
      exports.idSort = function(id1, id2) {
        var letter1 = id1.charAt(0);
        var letter2 = id2.charAt(0);
        if (letter1 !== letter2) return letter1 > letter2 ? 1 : -1;
        return +(id1.substr(1) || 1) - +(id2.substr(1) || 1);
      };
      exports.ref2id = function(ar) {
        return /^[xyz]/.test(ar) ? ar.split(" ")[0] : false;
      };
      function isFound(axId, list) {
        if (list && list.length) {
          for (var i = 0; i < list.length; i++) {
            if (list[i][axId]) return true;
          }
        }
        return false;
      }
      exports.isLinked = function(fullLayout, axId) {
        return isFound(axId, fullLayout._axisMatchGroups) || isFound(axId, fullLayout._axisConstraintGroups);
      };
    }
  });

  // src/components/shapes/handle_outline.js
  var require_handle_outline = __commonJS({
    "src/components/shapes/handle_outline.js"(exports, module) {
      "use strict";
      function clearOutlineControllers(gd) {
        var zoomLayer = gd._fullLayout._zoomlayer;
        if (zoomLayer) {
          zoomLayer.selectAll(".outline-controllers").remove();
        }
      }
      function clearOutline(gd) {
        var zoomLayer = gd._fullLayout._zoomlayer;
        if (zoomLayer) {
          zoomLayer.selectAll(".select-outline").remove();
        }
        gd._fullLayout._outlining = false;
      }
      module.exports = {
        clearOutlineControllers,
        clearOutline
      };
    }
  });

  // src/traces/scatter/layout_attributes.js
  var require_layout_attributes3 = __commonJS({
    "src/traces/scatter/layout_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        scattermode: {
          valType: "enumerated",
          values: ["group", "overlay"],
          dflt: "overlay",
          editType: "calc"
        },
        scattergap: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "calc"
        }
      };
    }
  });

  // src/plots/get_data.js
  var require_get_data = __commonJS({
    "src/plots/get_data.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var SUBPLOT_PATTERN = require_constants2().SUBPLOT_PATTERN;
      exports.getSubplotCalcData = function(calcData, type, subplotId) {
        var basePlotModule = Registry.subplotsRegistry[type];
        if (!basePlotModule) return [];
        var attr = basePlotModule.attr;
        var subplotCalcData = [];
        for (var i = 0; i < calcData.length; i++) {
          var calcTrace = calcData[i];
          var trace = calcTrace[0].trace;
          if (trace[attr] === subplotId) subplotCalcData.push(calcTrace);
        }
        return subplotCalcData;
      };
      exports.getModuleCalcData = function(calcdata, arg1, arg2) {
        var moduleCalcData = [];
        var remainingCalcData = [];
        var plotMethod;
        if (typeof arg1 === "string") {
          plotMethod = Registry.getModule(arg1).plot;
        } else if (typeof arg1 === "function") {
          plotMethod = arg1;
        } else {
          plotMethod = arg1.plot;
        }
        if (!plotMethod) {
          return [moduleCalcData, calcdata];
        }
        var zorder = arg2;
        for (var i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var trace = cd[0].trace;
          var filterByZ = trace.zorder !== void 0;
          if (trace.visible !== true || trace._length === 0) continue;
          if (trace._module && trace._module.plot === plotMethod && (!filterByZ || trace.zorder === zorder)) {
            moduleCalcData.push(cd);
          } else {
            remainingCalcData.push(cd);
          }
        }
        return [moduleCalcData, remainingCalcData];
      };
      exports.getSubplotData = function getSubplotData(data, type, subplotId) {
        if (!Registry.subplotsRegistry[type]) return [];
        var attr = Registry.subplotsRegistry[type].attr;
        var subplotData = [];
        var trace, subplotX, subplotY;
        for (var i = 0; i < data.length; i++) {
          trace = data[i];
          if (trace[attr] === subplotId) subplotData.push(trace);
        }
        return subplotData;
      };
    }
  });

  // src/plots/command.js
  var require_command = __commonJS({
    "src/plots/command.js"(exports) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      exports.manageCommandObserver = function(gd, container, commandList, onchange) {
        var ret = {};
        var enabled = true;
        if (container && container._commandObserver) {
          ret = container._commandObserver;
        }
        if (!ret.cache) {
          ret.cache = {};
        }
        ret.lookupTable = {};
        var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);
        if (container && container._commandObserver) {
          if (!binding) {
            if (container._commandObserver.remove) {
              container._commandObserver.remove();
              container._commandObserver = null;
              return ret;
            }
          } else {
            return ret;
          }
        }
        if (binding) {
          bindingValueHasChanged(gd, binding, ret.cache);
          ret.check = function check() {
            if (!enabled) return;
            var update = bindingValueHasChanged(gd, binding, ret.cache);
            if (update.changed && onchange) {
              if (ret.lookupTable[update.value] !== void 0) {
                ret.disable();
                Promise.resolve(onchange({
                  value: update.value,
                  type: binding.type,
                  prop: binding.prop,
                  traces: binding.traces,
                  index: ret.lookupTable[update.value]
                })).then(ret.enable, ret.enable);
              }
            }
            return update.changed;
          };
          var checkEvents = [
            "plotly_relayout",
            "plotly_redraw",
            "plotly_restyle",
            "plotly_update",
            "plotly_animatingframe",
            "plotly_afterplot"
          ];
          for (var i = 0; i < checkEvents.length; i++) {
            gd._internalOn(checkEvents[i], ret.check);
          }
          ret.remove = function() {
            for (var i2 = 0; i2 < checkEvents.length; i2++) {
              gd._removeInternalListener(checkEvents[i2], ret.check);
            }
          };
        } else {
          Lib.log("Unable to automatically bind plot updates to API command");
          ret.lookupTable = {};
          ret.remove = function() {
          };
        }
        ret.disable = function disable() {
          enabled = false;
        };
        ret.enable = function enable() {
          enabled = true;
        };
        if (container) {
          container._commandObserver = ret;
        }
        return ret;
      };
      exports.hasSimpleAPICommandBindings = function(gd, commandList, bindingsByValue) {
        var i;
        var n = commandList.length;
        var refBinding;
        for (i = 0; i < n; i++) {
          var binding;
          var command = commandList[i];
          var method = command.method;
          var args = command.args;
          if (!Array.isArray(args)) args = [];
          if (!method) {
            return false;
          }
          var bindings = exports.computeAPICommandBindings(gd, method, args);
          if (bindings.length !== 1) {
            return false;
          }
          if (!refBinding) {
            refBinding = bindings[0];
            if (Array.isArray(refBinding.traces)) {
              refBinding.traces.sort();
            }
          } else {
            binding = bindings[0];
            if (binding.type !== refBinding.type) {
              return false;
            }
            if (binding.prop !== refBinding.prop) {
              return false;
            }
            if (Array.isArray(refBinding.traces)) {
              if (Array.isArray(binding.traces)) {
                binding.traces.sort();
                for (var j = 0; j < refBinding.traces.length; j++) {
                  if (refBinding.traces[j] !== binding.traces[j]) {
                    return false;
                  }
                }
              } else {
                return false;
              }
            } else {
              if (binding.prop !== refBinding.prop) {
                return false;
              }
            }
          }
          binding = bindings[0];
          var value = binding.value;
          if (Array.isArray(value)) {
            if (value.length === 1) {
              value = value[0];
            } else {
              return false;
            }
          }
          if (bindingsByValue) {
            bindingsByValue[value] = i;
          }
        }
        return refBinding;
      };
      function bindingValueHasChanged(gd, binding, cache) {
        var container, value, obj;
        var changed = false;
        if (binding.type === "data") {
          container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];
        } else if (binding.type === "layout") {
          container = gd._fullLayout;
        } else {
          return false;
        }
        value = Lib.nestedProperty(container, binding.prop).get();
        obj = cache[binding.type] = cache[binding.type] || {};
        if (obj.hasOwnProperty(binding.prop)) {
          if (obj[binding.prop] !== value) {
            changed = true;
          }
        }
        obj[binding.prop] = value;
        return {
          changed,
          value
        };
      }
      exports.executeAPICommand = function(gd, method, args) {
        if (method === "skip") return Promise.resolve();
        var _method = Registry.apiMethodRegistry[method];
        var allArgs = [gd];
        if (!Array.isArray(args)) args = [];
        for (var i = 0; i < args.length; i++) {
          allArgs.push(args[i]);
        }
        return _method.apply(null, allArgs).catch(function(err) {
          Lib.warn("API call to Plotly." + method + " rejected.", err);
          return Promise.reject(err);
        });
      };
      exports.computeAPICommandBindings = function(gd, method, args) {
        var bindings;
        if (!Array.isArray(args)) args = [];
        switch (method) {
          case "restyle":
            bindings = computeDataBindings(gd, args);
            break;
          case "relayout":
            bindings = computeLayoutBindings(gd, args);
            break;
          case "update":
            bindings = computeDataBindings(gd, [args[0], args[2]]).concat(computeLayoutBindings(gd, [args[1]]));
            break;
          case "animate":
            bindings = computeAnimateBindings(gd, args);
            break;
          default:
            bindings = [];
        }
        return bindings;
      };
      function computeAnimateBindings(gd, args) {
        if (Array.isArray(args[0]) && args[0].length === 1 && ["string", "number"].indexOf(typeof args[0][0]) !== -1) {
          return [{ type: "layout", prop: "_currentFrame", value: args[0][0].toString() }];
        } else {
          return [];
        }
      }
      function computeLayoutBindings(gd, args) {
        var bindings = [];
        var astr = args[0];
        var aobj = {};
        if (typeof astr === "string") {
          aobj[astr] = args[1];
        } else if (Lib.isPlainObject(astr)) {
          aobj = astr;
        } else {
          return bindings;
        }
        crawl(aobj, function(path, attrName, attr) {
          bindings.push({ type: "layout", prop: path, value: attr });
        }, "", 0);
        return bindings;
      }
      function computeDataBindings(gd, args) {
        var traces, astr, val, aobj;
        var bindings = [];
        astr = args[0];
        val = args[1];
        traces = args[2];
        aobj = {};
        if (typeof astr === "string") {
          aobj[astr] = val;
        } else if (Lib.isPlainObject(astr)) {
          aobj = astr;
          if (traces === void 0) {
            traces = val;
          }
        } else {
          return bindings;
        }
        if (traces === void 0) {
          traces = null;
        }
        crawl(aobj, function(path, attrName, _attr) {
          var thisTraces;
          var attr;
          if (Array.isArray(_attr)) {
            attr = _attr.slice();
            var nAttr = Math.min(attr.length, gd.data.length);
            if (traces) {
              nAttr = Math.min(nAttr, traces.length);
            }
            thisTraces = [];
            for (var j = 0; j < nAttr; j++) {
              thisTraces[j] = traces ? traces[j] : j;
            }
          } else {
            attr = _attr;
            thisTraces = traces ? traces.slice() : null;
          }
          if (thisTraces === null) {
            if (Array.isArray(attr)) {
              attr = attr[0];
            }
          } else if (Array.isArray(thisTraces)) {
            if (!Array.isArray(attr)) {
              var tmp = attr;
              attr = [];
              for (var i = 0; i < thisTraces.length; i++) {
                attr[i] = tmp;
              }
            }
            attr.length = Math.min(thisTraces.length, attr.length);
          }
          bindings.push({
            type: "data",
            prop: path,
            traces: thisTraces,
            value: attr
          });
        }, "", 0);
        return bindings;
      }
      function crawl(attrs, callback, path, depth) {
        Object.keys(attrs).forEach(function(attrName) {
          var attr = attrs[attrName];
          if (attrName[0] === "_") return;
          var thisPath = path + (depth > 0 ? "." : "") + attrName;
          if (Lib.isPlainObject(attr)) {
            crawl(attr, callback, thisPath, depth + 1);
          } else {
            callback(thisPath, attrName, attr);
          }
        });
      }
    }
  });

  // src/plots/plots.js
  var require_plots = __commonJS({
    "src/plots/plots.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var timeFormatLocale = require_d3_time_format().timeFormatLocale;
      var formatLocale = require_d3_format().formatLocale;
      var isNumeric = require_fast_isnumeric();
      var b64encode = require_base64_arraybuffer_umd();
      var Registry = require_registry();
      var PlotSchema = require_plot_schema();
      var Template = require_plot_template();
      var Lib = require_lib();
      var Color = require_color();
      var BADNUM = require_numerical().BADNUM;
      var axisIDs = require_axis_ids();
      var clearOutline = require_handle_outline().clearOutline;
      var scatterAttrs = require_layout_attributes3();
      var animationAttrs = require_animation_attributes();
      var frameAttrs = require_frame_attributes();
      var getModuleCalcData = require_get_data().getModuleCalcData;
      var relinkPrivateKeys = Lib.relinkPrivateKeys;
      var _ = Lib._;
      var plots = module.exports = {};
      Lib.extendFlat(plots, Registry);
      plots.attributes = require_attributes2();
      plots.attributes.type.values = plots.allTypes;
      plots.fontAttrs = require_font_attributes();
      plots.layoutAttributes = require_layout_attributes2();
      var commandModule = require_command();
      plots.executeAPICommand = commandModule.executeAPICommand;
      plots.computeAPICommandBindings = commandModule.computeAPICommandBindings;
      plots.manageCommandObserver = commandModule.manageCommandObserver;
      plots.hasSimpleAPICommandBindings = commandModule.hasSimpleAPICommandBindings;
      plots.redrawText = function(gd) {
        gd = Lib.getGraphDiv(gd);
        return new Promise(function(resolve) {
          setTimeout(function() {
            if (!gd._fullLayout) return;
            Registry.getComponentMethod("annotations", "draw")(gd);
            Registry.getComponentMethod("legend", "draw")(gd);
            Registry.getComponentMethod("colorbar", "draw")(gd);
            resolve(plots.previousPromises(gd));
          }, 300);
        });
      };
      plots.resize = function(gd) {
        gd = Lib.getGraphDiv(gd);
        var resolveLastResize;
        var p = new Promise(function(resolve, reject) {
          if (!gd || Lib.isHidden(gd)) {
            reject(new Error("Resize must be passed a displayed plot div element."));
          }
          if (gd._redrawTimer) clearTimeout(gd._redrawTimer);
          if (gd._resolveResize) resolveLastResize = gd._resolveResize;
          gd._resolveResize = resolve;
          gd._redrawTimer = setTimeout(function() {
            if (!gd.layout || gd.layout.width && gd.layout.height || Lib.isHidden(gd)) {
              resolve(gd);
              return;
            }
            delete gd.layout.width;
            delete gd.layout.height;
            var oldchanged = gd.changed;
            gd.autoplay = true;
            Registry.call("relayout", gd, { autosize: true }).then(function() {
              gd.changed = oldchanged;
              if (gd._resolveResize === resolve) {
                delete gd._resolveResize;
                resolve(gd);
              }
            });
          }, 100);
        });
        if (resolveLastResize) resolveLastResize(p);
        return p;
      };
      plots.previousPromises = function(gd) {
        if ((gd._promises || []).length) {
          return Promise.all(gd._promises).then(function() {
            gd._promises = [];
          });
        }
      };
      plots.addLinks = function(gd) {
        if (!gd._context.showLink && !gd._context.showSources) return;
        var fullLayout = gd._fullLayout;
        var linkContainer = Lib.ensureSingle(fullLayout._paper, "text", "js-plot-link-container", function(s) {
          s.style({
            "font-family": '"Open Sans", Arial, sans-serif',
            "font-size": "12px",
            fill: Color.defaultLine,
            "pointer-events": "all"
          }).each(function() {
            var links = d3.select(this);
            links.append("tspan").classed("js-link-to-tool", true);
            links.append("tspan").classed("js-link-spacer", true);
            links.append("tspan").classed("js-sourcelinks", true);
          });
        });
        var text = linkContainer.node();
        var attrs = { y: fullLayout._paper.attr("height") - 9 };
        if (document.body.contains(text) && text.getComputedTextLength() >= fullLayout.width - 20) {
          attrs["text-anchor"] = "start";
          attrs.x = 5;
        } else {
          attrs["text-anchor"] = "end";
          attrs.x = fullLayout._paper.attr("width") - 7;
        }
        linkContainer.attr(attrs);
        var toolspan = linkContainer.select(".js-link-to-tool");
        var spacespan = linkContainer.select(".js-link-spacer");
        var sourcespan = linkContainer.select(".js-sourcelinks");
        if (gd._context.showSources) gd._context.showSources(gd);
        if (gd._context.showLink) positionPlayWithData(gd, toolspan);
        spacespan.text(toolspan.text() && sourcespan.text() ? " - " : "");
      };
      function positionPlayWithData(gd, container) {
        container.text("");
        var link = container.append("a").attr({
          "xlink:xlink:href": "#",
          class: "link--impt link--embedview",
          "font-weight": "bold"
        }).text(gd._context.linkText + " " + String.fromCharCode(187));
        if (gd._context.sendData) {
          link.on("click", function() {
            plots.sendDataToCloud(gd);
          });
        } else {
          var path = window.location.pathname.split("/");
          var query = window.location.search;
          link.attr({
            "xlink:xlink:show": "new",
            "xlink:xlink:href": "/" + path[2].split(".")[0] + "/" + path[1] + query
          });
        }
      }
      plots.sendDataToCloud = function(gd) {
        var baseUrl = (window.PLOTLYENV || {}).BASE_URL || gd._context.plotlyServerURL;
        if (!baseUrl) return;
        gd.emit("plotly_beforeexport");
        var hiddenformDiv = d3.select(gd).append("div").attr("id", "hiddenform").style("display", "none");
        var hiddenform = hiddenformDiv.append("form").attr({
          action: baseUrl + "/external",
          method: "post",
          target: "_blank"
        });
        var hiddenformInput = hiddenform.append("input").attr({
          type: "text",
          name: "data"
        });
        hiddenformInput.node().value = plots.graphJson(gd, false, "keepdata");
        hiddenform.node().submit();
        hiddenformDiv.remove();
        gd.emit("plotly_afterexport");
        return false;
      };
      var d3FormatKeys = [
        "days",
        "shortDays",
        "months",
        "shortMonths",
        "periods",
        "dateTime",
        "date",
        "time",
        "decimal",
        "thousands",
        "grouping",
        "currency"
      ];
      var extraFormatKeys = [
        "year",
        "month",
        "dayMonth",
        "dayMonthYear"
      ];
      plots.supplyDefaults = function(gd, opts) {
        var skipUpdateCalc = opts && opts.skipUpdateCalc;
        var oldFullLayout = gd._fullLayout || {};
        if (oldFullLayout._skipDefaults) {
          delete oldFullLayout._skipDefaults;
          return;
        }
        var newFullLayout = gd._fullLayout = {};
        var newLayout = gd.layout || {};
        var oldFullData = gd._fullData || [];
        var newFullData = gd._fullData = [];
        var newData = gd.data || [];
        var oldCalcdata = gd.calcdata || [];
        var context = gd._context || {};
        var i;
        if (!gd._transitionData) plots.createTransitionData(gd);
        newFullLayout._dfltTitle = {
          plot: _(gd, "Click to enter Plot title"),
          subtitle: _(gd, "Click to enter Plot subtitle"),
          x: _(gd, "Click to enter X axis title"),
          y: _(gd, "Click to enter Y axis title"),
          colorbar: _(gd, "Click to enter Colorscale title"),
          annotation: _(gd, "new text")
        };
        newFullLayout._traceWord = _(gd, "trace");
        var formatObj = getFormatObj(gd, d3FormatKeys);
        newFullLayout._mapboxAccessToken = context.mapboxAccessToken;
        if (oldFullLayout._initialAutoSizeIsDone) {
          var oldWidth = oldFullLayout.width;
          var oldHeight = oldFullLayout.height;
          plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);
          if (!newLayout.width) newFullLayout.width = oldWidth;
          if (!newLayout.height) newFullLayout.height = oldHeight;
          plots.sanitizeMargins(newFullLayout);
        } else {
          plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);
          var missingWidthOrHeight = !newLayout.width || !newLayout.height;
          var autosize = newFullLayout.autosize;
          var autosizable = context.autosizable;
          var initialAutoSize = missingWidthOrHeight && (autosize || autosizable);
          if (initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);
          else if (missingWidthOrHeight) plots.sanitizeMargins(newFullLayout);
          if (!autosize && missingWidthOrHeight) {
            newLayout.width = newFullLayout.width;
            newLayout.height = newFullLayout.height;
          }
        }
        newFullLayout._d3locale = getFormatter(formatObj, newFullLayout.separators);
        newFullLayout._extraFormat = getFormatObj(gd, extraFormatKeys);
        newFullLayout._initialAutoSizeIsDone = true;
        newFullLayout._dataLength = newData.length;
        newFullLayout._modules = [];
        newFullLayout._visibleModules = [];
        newFullLayout._basePlotModules = [];
        var subplots = newFullLayout._subplots = emptySubplotLists();
        var splomAxes = newFullLayout._splomAxes = { x: {}, y: {} };
        var splomSubplots = newFullLayout._splomSubplots = {};
        newFullLayout._splomGridDflt = {};
        newFullLayout._scatterStackOpts = {};
        newFullLayout._firstScatter = {};
        newFullLayout._alignmentOpts = {};
        newFullLayout._colorAxes = {};
        newFullLayout._requestRangeslider = {};
        newFullLayout._traceUids = getTraceUids(oldFullData, newData);
        plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout);
        var splomXa = Object.keys(splomAxes.x);
        var splomYa = Object.keys(splomAxes.y);
        if (splomXa.length > 1 && splomYa.length > 1) {
          Registry.getComponentMethod("grid", "sizeDefaults")(newLayout, newFullLayout);
          for (i = 0; i < splomXa.length; i++) {
            Lib.pushUnique(subplots.xaxis, splomXa[i]);
          }
          for (i = 0; i < splomYa.length; i++) {
            Lib.pushUnique(subplots.yaxis, splomYa[i]);
          }
          for (var k in splomSubplots) {
            Lib.pushUnique(subplots.cartesian, k);
          }
        }
        newFullLayout._has = plots._hasPlotType.bind(newFullLayout);
        if (oldFullData.length === newFullData.length) {
          for (i = 0; i < newFullData.length; i++) {
            relinkPrivateKeys(newFullData[i], oldFullData[i]);
          }
        }
        plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData);
        var _modules = newFullLayout._visibleModules;
        var crossTraceDefaultsFuncs = [];
        for (i = 0; i < _modules.length; i++) {
          var funci = _modules[i].crossTraceDefaults;
          if (funci) Lib.pushUnique(crossTraceDefaultsFuncs, funci);
        }
        for (i = 0; i < crossTraceDefaultsFuncs.length; i++) {
          crossTraceDefaultsFuncs[i](newFullData, newFullLayout);
        }
        newFullLayout._hasOnlyLargeSploms = newFullLayout._basePlotModules.length === 1 && newFullLayout._basePlotModules[0].name === "splom" && splomXa.length > 15 && splomYa.length > 15 && newFullLayout.shapes.length === 0 && newFullLayout.images.length === 0;
        plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout);
        plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);
        var hadCartesian = !!(oldFullLayout._has && oldFullLayout._has("cartesian"));
        var hasCartesian = !!(newFullLayout._has && newFullLayout._has("cartesian"));
        var hadBgLayer = hadCartesian;
        var hasBgLayer = hasCartesian;
        if (hadBgLayer && !hasBgLayer) {
          oldFullLayout._bgLayer.remove();
        } else if (hasBgLayer && !hadBgLayer) {
          newFullLayout._shouldCreateBgLayer = true;
        }
        if (oldFullLayout._zoomlayer && !gd._dragging) {
          clearOutline({
            // mock old gd
            _fullLayout: oldFullLayout
          });
        }
        fillMetaTextHelpers(newFullData, newFullLayout);
        relinkPrivateKeys(newFullLayout, oldFullLayout);
        Registry.getComponentMethod("colorscale", "crossTraceDefaults")(newFullData, newFullLayout);
        if (!newFullLayout._preGUI) newFullLayout._preGUI = {};
        if (!newFullLayout._tracePreGUI) newFullLayout._tracePreGUI = {};
        var tracePreGUI = newFullLayout._tracePreGUI;
        var uids = {};
        var uid;
        for (uid in tracePreGUI) uids[uid] = "old";
        for (i = 0; i < newFullData.length; i++) {
          uid = newFullData[i]._fullInput.uid;
          if (!uids[uid]) tracePreGUI[uid] = {};
          uids[uid] = "new";
        }
        for (uid in uids) {
          if (uids[uid] === "old") delete tracePreGUI[uid];
        }
        initMargins(newFullLayout);
        Registry.getComponentMethod("rangeslider", "makeData")(newFullLayout);
        if (!skipUpdateCalc && oldCalcdata.length === newFullData.length) {
          plots.supplyDefaultsUpdateCalc(oldCalcdata, newFullData);
        }
      };
      plots.supplyDefaultsUpdateCalc = function(oldCalcdata, newFullData) {
        for (var i = 0; i < newFullData.length; i++) {
          var newTrace = newFullData[i];
          var cd0 = (oldCalcdata[i] || [])[0];
          if (cd0 && cd0.trace) {
            var oldTrace = cd0.trace;
            if (oldTrace._hasCalcTransform) {
              var arrayAttrs = oldTrace._arrayAttrs;
              var j, astr, oldArrayVal;
              for (j = 0; j < arrayAttrs.length; j++) {
                astr = arrayAttrs[j];
                oldArrayVal = Lib.nestedProperty(oldTrace, astr).get().slice();
                Lib.nestedProperty(newTrace, astr).set(oldArrayVal);
              }
            }
            cd0.trace = newTrace;
          }
        }
      };
      function getTraceUids(oldFullData, newData) {
        var len = newData.length;
        var oldFullInput = [];
        var i, prevFullInput;
        for (i = 0; i < oldFullData.length; i++) {
          var thisFullInput = oldFullData[i]._fullInput;
          if (thisFullInput !== prevFullInput) oldFullInput.push(thisFullInput);
          prevFullInput = thisFullInput;
        }
        var oldLen = oldFullInput.length;
        var out = new Array(len);
        var seenUids = {};
        function setUid(uid, i2) {
          out[i2] = uid;
          seenUids[uid] = 1;
        }
        function tryUid(uid, i2) {
          if (uid && typeof uid === "string" && !seenUids[uid]) {
            setUid(uid, i2);
            return true;
          }
        }
        for (i = 0; i < len; i++) {
          var newUid = newData[i].uid;
          if (typeof newUid === "number") newUid = String(newUid);
          if (tryUid(newUid, i)) continue;
          if (i < oldLen && tryUid(oldFullInput[i].uid, i)) continue;
          setUid(Lib.randstr(seenUids), i);
        }
        return out;
      }
      function emptySubplotLists() {
        var collectableSubplotTypes = Registry.collectableSubplotTypes;
        var out = {};
        var i, j;
        if (!collectableSubplotTypes) {
          collectableSubplotTypes = [];
          var subplotsRegistry = Registry.subplotsRegistry;
          for (var subplotType in subplotsRegistry) {
            var subplotModule = subplotsRegistry[subplotType];
            var subplotAttr = subplotModule.attr;
            if (subplotAttr) {
              collectableSubplotTypes.push(subplotType);
              if (Array.isArray(subplotAttr)) {
                for (j = 0; j < subplotAttr.length; j++) {
                  Lib.pushUnique(collectableSubplotTypes, subplotAttr[j]);
                }
              }
            }
          }
        }
        for (i = 0; i < collectableSubplotTypes.length; i++) {
          out[collectableSubplotTypes[i]] = [];
        }
        return out;
      }
      function getFormatObj(gd, formatKeys) {
        var locale = gd._context.locale;
        if (!locale) locale = "en-US";
        var formatDone = false;
        var formatObj = {};
        function includeFormat(newFormat) {
          var formatFinished = true;
          for (var i2 = 0; i2 < formatKeys.length; i2++) {
            var formatKey = formatKeys[i2];
            if (!formatObj[formatKey]) {
              if (newFormat[formatKey]) {
                formatObj[formatKey] = newFormat[formatKey];
              } else formatFinished = false;
            }
          }
          if (formatFinished) formatDone = true;
        }
        for (var i = 0; i < 2; i++) {
          var locales = gd._context.locales;
          for (var j = 0; j < 2; j++) {
            var formatj = (locales[locale] || {}).format;
            if (formatj) {
              includeFormat(formatj);
              if (formatDone) break;
            }
            locales = Registry.localeRegistry;
          }
          var baseLocale = locale.split("-")[0];
          if (formatDone || baseLocale === locale) break;
          locale = baseLocale;
        }
        if (!formatDone) includeFormat(Registry.localeRegistry.en.format);
        return formatObj;
      }
      function getFormatter(formatObj, separators) {
        formatObj.decimal = separators.charAt(0);
        formatObj.thousands = separators.charAt(1);
        return {
          numberFormat: function(formatStr) {
            try {
              formatStr = formatLocale(formatObj).format(
                Lib.adjustFormat(formatStr)
              );
            } catch (e) {
              Lib.warnBadFormat(formatStr);
              return Lib.noFormat;
            }
            return formatStr;
          },
          timeFormat: timeFormatLocale(formatObj).utcFormat
        };
      }
      function fillMetaTextHelpers(newFullData, newFullLayout) {
        var _meta;
        var meta4data = [];
        if (newFullLayout.meta) {
          _meta = newFullLayout._meta = {
            meta: newFullLayout.meta,
            layout: { meta: newFullLayout.meta }
          };
        }
        for (var i = 0; i < newFullData.length; i++) {
          var trace = newFullData[i];
          if (trace.meta) {
            meta4data[trace.index] = trace._meta = { meta: trace.meta };
          } else if (newFullLayout.meta) {
            trace._meta = { meta: newFullLayout.meta };
          }
          if (newFullLayout.meta) {
            trace._meta.layout = { meta: newFullLayout.meta };
          }
        }
        if (meta4data.length) {
          if (!_meta) {
            _meta = newFullLayout._meta = {};
          }
          _meta.data = meta4data;
        }
      }
      plots.createTransitionData = function(gd) {
        if (!gd._transitionData) {
          gd._transitionData = {};
        }
        if (!gd._transitionData._frames) {
          gd._transitionData._frames = [];
        }
        if (!gd._transitionData._frameHash) {
          gd._transitionData._frameHash = {};
        }
        if (!gd._transitionData._counter) {
          gd._transitionData._counter = 0;
        }
        if (!gd._transitionData._interruptCallbacks) {
          gd._transitionData._interruptCallbacks = [];
        }
      };
      plots._hasPlotType = function(category) {
        var i;
        var basePlotModules = this._basePlotModules || [];
        for (i = 0; i < basePlotModules.length; i++) {
          if (basePlotModules[i].name === category) return true;
        }
        var modules = this._modules || [];
        for (i = 0; i < modules.length; i++) {
          var name = modules[i].name;
          if (name === category) return true;
          var _module = Registry.modules[name];
          if (_module && _module.categories[category]) return true;
        }
        return false;
      };
      plots.cleanPlot = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var i, j;
        var basePlotModules = oldFullLayout._basePlotModules || [];
        for (i = 0; i < basePlotModules.length; i++) {
          var _module = basePlotModules[i];
          if (_module.clean) {
            _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);
          }
        }
        var hadGl = oldFullLayout._has && oldFullLayout._has("gl");
        var hasGl = newFullLayout._has && newFullLayout._has("gl");
        if (hadGl && !hasGl) {
          if (oldFullLayout._glcontainer !== void 0) {
            oldFullLayout._glcontainer.selectAll(".gl-canvas").remove();
            oldFullLayout._glcontainer.selectAll(".no-webgl").remove();
            oldFullLayout._glcanvas = null;
          }
        }
        var hasInfoLayer = !!oldFullLayout._infolayer;
        oldLoop:
          for (i = 0; i < oldFullData.length; i++) {
            var oldTrace = oldFullData[i];
            var oldUid = oldTrace.uid;
            for (j = 0; j < newFullData.length; j++) {
              var newTrace = newFullData[j];
              if (oldUid === newTrace.uid) continue oldLoop;
            }
            if (hasInfoLayer) {
              oldFullLayout._infolayer.select(".cb" + oldUid).remove();
            }
          }
      };
      plots.linkSubplots = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var i, j;
        var oldSubplots = oldFullLayout._plots || {};
        var newSubplots = newFullLayout._plots = {};
        var newSubplotList = newFullLayout._subplots;
        var mockGd = {
          _fullData: newFullData,
          _fullLayout: newFullLayout
        };
        var ids = newSubplotList.cartesian || [];
        for (i = 0; i < ids.length; i++) {
          var id = ids[i];
          var oldSubplot = oldSubplots[id];
          var xaxis = axisIDs.getFromId(mockGd, id, "x");
          var yaxis = axisIDs.getFromId(mockGd, id, "y");
          var plotinfo;
          if (oldSubplot) {
            plotinfo = newSubplots[id] = oldSubplot;
          } else {
            plotinfo = newSubplots[id] = {};
            plotinfo.id = id;
          }
          xaxis._counterAxes.push(yaxis._id);
          yaxis._counterAxes.push(xaxis._id);
          xaxis._subplotsWith.push(id);
          yaxis._subplotsWith.push(id);
          plotinfo.xaxis = xaxis;
          plotinfo.yaxis = yaxis;
          plotinfo._hasClipOnAxisFalse = false;
          for (j = 0; j < newFullData.length; j++) {
            var trace = newFullData[j];
            if (trace.xaxis === plotinfo.xaxis._id && trace.yaxis === plotinfo.yaxis._id && trace.cliponaxis === false) {
              plotinfo._hasClipOnAxisFalse = true;
              break;
            }
          }
        }
        var axList = axisIDs.list(mockGd, null, true);
        var ax;
        for (i = 0; i < axList.length; i++) {
          ax = axList[i];
          var mainAx = null;
          if (ax.overlaying) {
            mainAx = axisIDs.getFromId(mockGd, ax.overlaying);
            if (mainAx && mainAx.overlaying) {
              ax.overlaying = false;
              mainAx = null;
            }
          }
          ax._mainAxis = mainAx || ax;
          if (mainAx) ax.domain = mainAx.domain.slice();
          ax._anchorAxis = ax.anchor === "free" ? null : axisIDs.getFromId(mockGd, ax.anchor);
        }
        for (i = 0; i < axList.length; i++) {
          ax = axList[i];
          ax._counterAxes.sort(axisIDs.idSort);
          ax._subplotsWith.sort(Lib.subplotSort);
          ax._mainSubplot = findMainSubplot(ax, newFullLayout);
          if (ax._counterAxes.length && (ax.spikemode && ax.spikemode.indexOf("across") !== -1 || ax.automargin && ax.mirror && ax.anchor !== "free" || Registry.getComponentMethod("rangeslider", "isVisible")(ax))) {
            var min = 1;
            var max = 0;
            for (j = 0; j < ax._counterAxes.length; j++) {
              var ax2 = axisIDs.getFromId(mockGd, ax._counterAxes[j]);
              min = Math.min(min, ax2.domain[0]);
              max = Math.max(max, ax2.domain[1]);
            }
            if (min < max) {
              ax._counterDomainMin = min;
              ax._counterDomainMax = max;
            }
          }
        }
      };
      function findMainSubplot(ax, fullLayout) {
        var mockGd = { _fullLayout: fullLayout };
        var isX = ax._id.charAt(0) === "x";
        var anchorAx = ax._mainAxis._anchorAxis;
        var mainSubplotID = "";
        var nextBestMainSubplotID = "";
        var anchorID = "";
        if (anchorAx) {
          anchorID = anchorAx._mainAxis._id;
          mainSubplotID = isX ? ax._id + anchorID : anchorID + ax._id;
        }
        if (!mainSubplotID || !fullLayout._plots[mainSubplotID]) {
          mainSubplotID = "";
          var counterIDs = ax._counterAxes;
          for (var j = 0; j < counterIDs.length; j++) {
            var counterPart = counterIDs[j];
            var id = isX ? ax._id + counterPart : counterPart + ax._id;
            if (!nextBestMainSubplotID) nextBestMainSubplotID = id;
            var counterAx = axisIDs.getFromId(mockGd, counterPart);
            if (anchorID && counterAx.overlaying === anchorID) {
              mainSubplotID = id;
              break;
            }
          }
        }
        return mainSubplotID || nextBestMainSubplotID;
      }
      plots.clearExpandedTraceDefaultColors = function(trace) {
        var colorAttrs, path, i;
        function locateColorAttrs(attr, attrName, attrs, level) {
          path[level] = attrName;
          path.length = level + 1;
          if (attr.valType === "color" && attr.dflt === void 0) {
            colorAttrs.push(path.join("."));
          }
        }
        path = [];
        colorAttrs = trace._module._colorAttrs;
        if (!colorAttrs) {
          trace._module._colorAttrs = colorAttrs = [];
          PlotSchema.crawl(
            trace._module.attributes,
            locateColorAttrs
          );
        }
        for (i = 0; i < colorAttrs.length; i++) {
          var origprop = Lib.nestedProperty(trace, "_input." + colorAttrs[i]);
          if (!origprop.get()) {
            Lib.nestedProperty(trace, colorAttrs[i]).set(null);
          }
        }
      };
      plots.supplyDataDefaults = function(dataIn, dataOut, layout, fullLayout) {
        var modules = fullLayout._modules;
        var visibleModules = fullLayout._visibleModules;
        var basePlotModules = fullLayout._basePlotModules;
        var cnt = 0;
        var colorCnt = 0;
        var i, fullTrace, trace;
        fullLayout._transformModules = [];
        function pushModule(fullTrace2) {
          dataOut.push(fullTrace2);
          var _module = fullTrace2._module;
          if (!_module) return;
          Lib.pushUnique(modules, _module);
          if (fullTrace2.visible === true) Lib.pushUnique(visibleModules, _module);
          Lib.pushUnique(basePlotModules, fullTrace2._module.basePlotModule);
          cnt++;
          if (fullTrace2._input.visible !== false) colorCnt++;
        }
        var carpetIndex = {};
        var carpetDependents = [];
        var dataTemplate = (layout.template || {}).data || {};
        var templater = Template.traceTemplater(dataTemplate);
        for (i = 0; i < dataIn.length; i++) {
          trace = dataIn[i];
          fullTrace = templater.newTrace(trace);
          fullTrace.uid = fullLayout._traceUids[i];
          plots.supplyTraceDefaults(trace, fullTrace, colorCnt, fullLayout, i);
          fullTrace.index = i;
          fullTrace._input = trace;
          fullTrace._fullInput = fullTrace;
          pushModule(fullTrace);
          if (Registry.traceIs(fullTrace, "carpetAxis")) {
            carpetIndex[fullTrace.carpet] = fullTrace;
          }
          if (Registry.traceIs(fullTrace, "carpetDependent")) {
            carpetDependents.push(i);
          }
        }
        for (i = 0; i < carpetDependents.length; i++) {
          fullTrace = dataOut[carpetDependents[i]];
          if (!fullTrace.visible) continue;
          var carpetAxis = carpetIndex[fullTrace.carpet];
          fullTrace._carpet = carpetAxis;
          if (!carpetAxis || !carpetAxis.visible) {
            fullTrace.visible = false;
            continue;
          }
          fullTrace.xaxis = carpetAxis.xaxis;
          fullTrace.yaxis = carpetAxis.yaxis;
        }
      };
      plots.supplyAnimationDefaults = function(opts) {
        opts = opts || {};
        var i;
        var optsOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);
        }
        coerce("mode");
        coerce("direction");
        coerce("fromcurrent");
        if (Array.isArray(opts.frame)) {
          optsOut.frame = [];
          for (i = 0; i < opts.frame.length; i++) {
            optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});
          }
        } else {
          optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});
        }
        if (Array.isArray(opts.transition)) {
          optsOut.transition = [];
          for (i = 0; i < opts.transition.length; i++) {
            optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});
          }
        } else {
          optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});
        }
        return optsOut;
      };
      plots.supplyAnimationFrameDefaults = function(opts) {
        var optsOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);
        }
        coerce("duration");
        coerce("redraw");
        return optsOut;
      };
      plots.supplyAnimationTransitionDefaults = function(opts) {
        var optsOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);
        }
        coerce("duration");
        coerce("easing");
        return optsOut;
      };
      plots.supplyFrameDefaults = function(frameIn) {
        var frameOut = {};
        function coerce(attr, dflt) {
          return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);
        }
        coerce("group");
        coerce("name");
        coerce("traces");
        coerce("baseframe");
        coerce("data");
        coerce("layout");
        return frameOut;
      };
      plots.supplyTraceDefaults = function(traceIn, traceOut, colorIndex, layout, traceInIndex) {
        var colorway = layout.colorway || Color.defaults;
        var defaultColor = colorway[colorIndex % colorway.length];
        var i;
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);
        }
        var visible = coerce("visible");
        coerce("type");
        coerce("name", layout._traceWord + " " + traceInIndex);
        coerce("uirevision", layout.uirevision);
        var _module = plots.getModule(traceOut);
        traceOut._module = _module;
        if (_module) {
          var basePlotModule = _module.basePlotModule;
          var subplotAttr = basePlotModule.attr;
          var subplotAttrs = basePlotModule.attributes;
          if (subplotAttr && subplotAttrs) {
            var subplots = layout._subplots;
            var subplotId = "";
            if (Array.isArray(subplotAttr)) {
              for (i = 0; i < subplotAttr.length; i++) {
                var attri = subplotAttr[i];
                var vali = Lib.coerce(traceIn, traceOut, subplotAttrs, attri);
                if (subplots[attri]) Lib.pushUnique(subplots[attri], vali);
                subplotId += vali;
              }
            } else {
              subplotId = Lib.coerce(traceIn, traceOut, subplotAttrs, subplotAttr);
            }
            if (subplots[basePlotModule.name]) {
              Lib.pushUnique(subplots[basePlotModule.name], subplotId);
            }
          }
        }
        if (visible) {
          coerce("customdata");
          coerce("ids");
          coerce("meta");
          if (Registry.traceIs(traceOut, "showLegend")) {
            Lib.coerce(
              traceIn,
              traceOut,
              _module.attributes.showlegend ? _module.attributes : plots.attributes,
              "showlegend"
            );
            coerce("legend");
            coerce("legendwidth");
            coerce("legendgroup");
            coerce("legendgrouptitle.text");
            coerce("legendrank");
            traceOut._dfltShowLegend = true;
          } else {
            traceOut._dfltShowLegend = false;
          }
          if (_module) {
            _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);
          }
          if (!Registry.traceIs(traceOut, "noOpacity")) {
            coerce("opacity");
          }
          if (Registry.traceIs(traceOut, "notLegendIsolatable")) {
            traceOut.visible = !!traceOut.visible;
          }
          if (!Registry.traceIs(traceOut, "noHover")) {
            if (!traceOut.hovertemplate) Lib.coerceHoverinfo(traceIn, traceOut, layout);
            if (traceOut.type !== "parcats") {
              Registry.getComponentMethod("fx", "supplyDefaults")(traceIn, traceOut, defaultColor, layout);
            }
          }
          if (_module && _module.selectPoints) {
            var selectedpoints = coerce("selectedpoints");
            if (Lib.isTypedArray(selectedpoints)) {
              traceOut.selectedpoints = Array.from(selectedpoints);
            }
          }
        }
        return traceOut;
      };
      plots.supplyLayoutGlobalDefaults = function(layoutIn, layoutOut, formatObj) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);
        }
        var template = layoutIn.template;
        if (Lib.isPlainObject(template)) {
          layoutOut.template = template;
          layoutOut._template = template.layout;
          layoutOut._dataTemplate = template.data;
        }
        coerce("autotypenumbers");
        var font = Lib.coerceFont(coerce, "font");
        var fontSize = font.size;
        Lib.coerceFont(coerce, "title.font", font, { overrideDflt: {
          size: Math.round(fontSize * 1.4)
        } });
        coerce("title.text", layoutOut._dfltTitle.plot);
        coerce("title.xref");
        var titleYref = coerce("title.yref");
        coerce("title.pad.t");
        coerce("title.pad.r");
        coerce("title.pad.b");
        coerce("title.pad.l");
        var titleAutomargin = coerce("title.automargin");
        coerce("title.x");
        coerce("title.xanchor");
        coerce("title.y");
        coerce("title.yanchor");
        coerce("title.subtitle.text", layoutOut._dfltTitle.subtitle);
        Lib.coerceFont(coerce, "title.subtitle.font", font, {
          overrideDflt: {
            size: Math.round(layoutOut.title.font.size * 0.7)
          }
        });
        if (titleAutomargin) {
          if (titleYref === "paper") {
            if (layoutOut.title.y !== 0) layoutOut.title.y = 1;
            if (layoutOut.title.yanchor === "auto") {
              layoutOut.title.yanchor = layoutOut.title.y === 0 ? "top" : "bottom";
            }
          }
          if (titleYref === "container") {
            if (layoutOut.title.y === "auto") layoutOut.title.y = 1;
            if (layoutOut.title.yanchor === "auto") {
              layoutOut.title.yanchor = layoutOut.title.y < 0.5 ? "bottom" : "top";
            }
          }
        }
        var uniformtextMode = coerce("uniformtext.mode");
        if (uniformtextMode) {
          coerce("uniformtext.minsize");
        }
        coerce("autosize", !(layoutIn.width && layoutIn.height));
        coerce("width");
        coerce("height");
        coerce("minreducedwidth");
        coerce("minreducedheight");
        coerce("margin.l");
        coerce("margin.r");
        coerce("margin.t");
        coerce("margin.b");
        coerce("margin.pad");
        coerce("margin.autoexpand");
        if (layoutIn.width && layoutIn.height) plots.sanitizeMargins(layoutOut);
        Registry.getComponentMethod("grid", "sizeDefaults")(layoutIn, layoutOut);
        coerce("paper_bgcolor");
        coerce("separators", formatObj.decimal + formatObj.thousands);
        coerce("hidesources");
        coerce("colorway");
        coerce("datarevision");
        var uirevision = coerce("uirevision");
        coerce("editrevision", uirevision);
        coerce("selectionrevision", uirevision);
        Registry.getComponentMethod(
          "modebar",
          "supplyLayoutDefaults"
        )(layoutIn, layoutOut);
        Registry.getComponentMethod(
          "shapes",
          "supplyDrawNewShapeDefaults"
        )(layoutIn, layoutOut, coerce);
        Registry.getComponentMethod(
          "selections",
          "supplyDrawNewSelectionDefaults"
        )(layoutIn, layoutOut, coerce);
        coerce("meta");
        if (Lib.isPlainObject(layoutIn.transition)) {
          coerce("transition.duration");
          coerce("transition.easing");
          coerce("transition.ordering");
        }
        Registry.getComponentMethod(
          "calendars",
          "handleDefaults"
        )(layoutIn, layoutOut, "calendar");
        Registry.getComponentMethod(
          "fx",
          "supplyLayoutGlobalDefaults"
        )(layoutIn, layoutOut, coerce);
        Lib.coerce(layoutIn, layoutOut, scatterAttrs, "scattermode");
      };
      function getComputedSize(attr) {
        return typeof attr === "string" && attr.substr(attr.length - 2) === "px" && parseFloat(attr);
      }
      plots.plotAutoSize = function plotAutoSize(gd, layout, fullLayout) {
        var context = gd._context || {};
        var frameMargins = context.frameMargins;
        var newWidth;
        var newHeight;
        var isPlotDiv = Lib.isPlotDiv(gd);
        if (isPlotDiv) gd.emit("plotly_autosize");
        if (context.fillFrame) {
          newWidth = window.innerWidth;
          newHeight = window.innerHeight;
          document.body.style.overflow = "hidden";
        } else {
          var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};
          newWidth = getComputedSize(computedStyle.width) || getComputedSize(computedStyle.maxWidth) || fullLayout.width;
          newHeight = getComputedSize(computedStyle.height) || getComputedSize(computedStyle.maxHeight) || fullLayout.height;
          if (isNumeric(frameMargins) && frameMargins > 0) {
            var factor = 1 - 2 * frameMargins;
            newWidth = Math.round(factor * newWidth);
            newHeight = Math.round(factor * newHeight);
          }
        }
        var minWidth = plots.layoutAttributes.width.min;
        var minHeight = plots.layoutAttributes.height.min;
        if (newWidth < minWidth) newWidth = minWidth;
        if (newHeight < minHeight) newHeight = minHeight;
        var widthHasChanged = !layout.width && Math.abs(fullLayout.width - newWidth) > 1;
        var heightHasChanged = !layout.height && Math.abs(fullLayout.height - newHeight) > 1;
        if (heightHasChanged || widthHasChanged) {
          if (widthHasChanged) fullLayout.width = newWidth;
          if (heightHasChanged) fullLayout.height = newHeight;
        }
        if (!gd._initialAutoSize) {
          gd._initialAutoSize = { width: newWidth, height: newHeight };
        }
        plots.sanitizeMargins(fullLayout);
      };
      plots.supplyLayoutModuleDefaults = function(layoutIn, layoutOut, fullData, transitionData) {
        var componentsRegistry = Registry.componentsRegistry;
        var basePlotModules = layoutOut._basePlotModules;
        var component, i, _module;
        var Cartesian = Registry.subplotsRegistry.cartesian;
        for (component in componentsRegistry) {
          _module = componentsRegistry[component];
          if (_module.includeBasePlot) {
            _module.includeBasePlot(layoutIn, layoutOut);
          }
        }
        if (!basePlotModules.length) {
          basePlotModules.push(Cartesian);
        }
        if (layoutOut._has("cartesian")) {
          Registry.getComponentMethod("grid", "contentDefaults")(layoutIn, layoutOut);
          Cartesian.finalizeSubplots(layoutIn, layoutOut);
        }
        for (var subplotType in layoutOut._subplots) {
          layoutOut._subplots[subplotType].sort(Lib.subplotSort);
        }
        for (i = 0; i < basePlotModules.length; i++) {
          _module = basePlotModules[i];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
          }
        }
        var modules = layoutOut._modules;
        for (i = 0; i < modules.length; i++) {
          _module = modules[i];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
          }
        }
        var transformModules = layoutOut._transformModules;
        for (i = 0; i < transformModules.length; i++) {
          _module = transformModules[i];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);
          }
        }
        for (component in componentsRegistry) {
          _module = componentsRegistry[component];
          if (_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
          }
        }
      };
      plots.purge = function(gd) {
        var fullLayout = gd._fullLayout || {};
        if (fullLayout._glcontainer !== void 0) {
          fullLayout._glcontainer.selectAll(".gl-canvas").remove();
          fullLayout._glcontainer.remove();
          fullLayout._glcanvas = null;
        }
        if (fullLayout._modeBar) fullLayout._modeBar.destroy();
        if (gd._transitionData) {
          if (gd._transitionData._interruptCallbacks) {
            gd._transitionData._interruptCallbacks.length = 0;
          }
          if (gd._transitionData._animationRaf) {
            window.cancelAnimationFrame(gd._transitionData._animationRaf);
          }
        }
        Lib.clearThrottle();
        Lib.clearResponsive(gd);
        delete gd.data;
        delete gd.layout;
        delete gd._fullData;
        delete gd._fullLayout;
        delete gd.calcdata;
        delete gd.empty;
        delete gd.fid;
        delete gd.undoqueue;
        delete gd.undonum;
        delete gd.autoplay;
        delete gd.changed;
        delete gd._promises;
        delete gd._redrawTimer;
        delete gd._hmlumcount;
        delete gd._hmpixcount;
        delete gd._transitionData;
        delete gd._transitioning;
        delete gd._initialAutoSize;
        delete gd._transitioningWithDuration;
        delete gd._dragging;
        delete gd._dragged;
        delete gd._dragdata;
        delete gd._hoverdata;
        delete gd._snapshotInProgress;
        delete gd._editing;
        delete gd._mouseDownTime;
        delete gd._legendMouseDownTime;
        if (gd.removeAllListeners) gd.removeAllListeners();
      };
      plots.style = function(gd) {
        var _modules = gd._fullLayout._visibleModules;
        var styleModules = [];
        var i;
        for (i = 0; i < _modules.length; i++) {
          var _module = _modules[i];
          if (_module.style) {
            Lib.pushUnique(styleModules, _module.style);
          }
        }
        for (i = 0; i < styleModules.length; i++) {
          styleModules[i](gd);
        }
      };
      plots.sanitizeMargins = function(fullLayout) {
        if (!fullLayout || !fullLayout.margin) return;
        var width = fullLayout.width;
        var height = fullLayout.height;
        var margin = fullLayout.margin;
        var plotWidth = width - (margin.l + margin.r);
        var plotHeight = height - (margin.t + margin.b);
        var correction;
        if (plotWidth < 0) {
          correction = (width - 1) / (margin.l + margin.r);
          margin.l = Math.floor(correction * margin.l);
          margin.r = Math.floor(correction * margin.r);
        }
        if (plotHeight < 0) {
          correction = (height - 1) / (margin.t + margin.b);
          margin.t = Math.floor(correction * margin.t);
          margin.b = Math.floor(correction * margin.b);
        }
      };
      plots.clearAutoMarginIds = function(gd) {
        gd._fullLayout._pushmarginIds = {};
      };
      plots.allowAutoMargin = function(gd, id) {
        gd._fullLayout._pushmarginIds[id] = 1;
      };
      function initMargins(fullLayout) {
        var margin = fullLayout.margin;
        if (!fullLayout._size) {
          var gs = fullLayout._size = {
            l: Math.round(margin.l),
            r: Math.round(margin.r),
            t: Math.round(margin.t),
            b: Math.round(margin.b),
            p: Math.round(margin.pad)
          };
          gs.w = Math.round(fullLayout.width) - gs.l - gs.r;
          gs.h = Math.round(fullLayout.height) - gs.t - gs.b;
        }
        if (!fullLayout._pushmargin) fullLayout._pushmargin = {};
        if (!fullLayout._pushmarginIds) fullLayout._pushmarginIds = {};
        if (!fullLayout._reservedMargin) fullLayout._reservedMargin = {};
      }
      var MIN_SPECIFIED_WIDTH = 2;
      var MIN_SPECIFIED_HEIGHT = 2;
      plots.autoMargin = function(gd, id, o) {
        var fullLayout = gd._fullLayout;
        var width = fullLayout.width;
        var height = fullLayout.height;
        var margin = fullLayout.margin;
        var minreducedwidth = fullLayout.minreducedwidth;
        var minreducedheight = fullLayout.minreducedheight;
        var minFinalWidth = Lib.constrain(
          width - margin.l - margin.r,
          MIN_SPECIFIED_WIDTH,
          minreducedwidth
        );
        var minFinalHeight = Lib.constrain(
          height - margin.t - margin.b,
          MIN_SPECIFIED_HEIGHT,
          minreducedheight
        );
        var maxSpaceW = Math.max(0, width - minFinalWidth);
        var maxSpaceH = Math.max(0, height - minFinalHeight);
        var pushMargin = fullLayout._pushmargin;
        var pushMarginIds = fullLayout._pushmarginIds;
        if (margin.autoexpand !== false) {
          if (!o) {
            delete pushMargin[id];
            delete pushMarginIds[id];
          } else {
            var pad = o.pad;
            if (pad === void 0) {
              pad = Math.min(12, margin.l, margin.r, margin.t, margin.b);
            }
            if (maxSpaceW) {
              var rW = (o.l + o.r) / maxSpaceW;
              if (rW > 1) {
                o.l /= rW;
                o.r /= rW;
              }
            }
            if (maxSpaceH) {
              var rH = (o.t + o.b) / maxSpaceH;
              if (rH > 1) {
                o.t /= rH;
                o.b /= rH;
              }
            }
            var xl = o.xl !== void 0 ? o.xl : o.x;
            var xr = o.xr !== void 0 ? o.xr : o.x;
            var yt = o.yt !== void 0 ? o.yt : o.y;
            var yb = o.yb !== void 0 ? o.yb : o.y;
            pushMargin[id] = {
              l: { val: xl, size: o.l + pad },
              r: { val: xr, size: o.r + pad },
              b: { val: yb, size: o.b + pad },
              t: { val: yt, size: o.t + pad }
            };
            pushMarginIds[id] = 1;
          }
          if (!fullLayout._replotting) {
            return plots.doAutoMargin(gd);
          }
        }
      };
      function needsRedrawForShift(gd) {
        if ("_redrawFromAutoMarginCount" in gd._fullLayout) {
          return false;
        }
        var axList = axisIDs.list(gd, "", true);
        for (var ax in axList) {
          if (axList[ax].autoshift || axList[ax].shift) return true;
        }
        return false;
      }
      plots.doAutoMargin = function(gd) {
        var fullLayout = gd._fullLayout;
        var width = fullLayout.width;
        var height = fullLayout.height;
        if (!fullLayout._size) fullLayout._size = {};
        initMargins(fullLayout);
        var gs = fullLayout._size;
        var margin = fullLayout.margin;
        var reservedMargins = { t: 0, b: 0, l: 0, r: 0 };
        var oldMargins = Lib.extendFlat({}, gs);
        var ml = margin.l;
        var mr = margin.r;
        var mt = margin.t;
        var mb = margin.b;
        var pushMargin = fullLayout._pushmargin;
        var pushMarginIds = fullLayout._pushmarginIds;
        var minreducedwidth = fullLayout.minreducedwidth;
        var minreducedheight = fullLayout.minreducedheight;
        if (margin.autoexpand !== false) {
          for (var k in pushMargin) {
            if (!pushMarginIds[k]) delete pushMargin[k];
          }
          var margins = gd._fullLayout._reservedMargin;
          for (var key in margins) {
            for (var side in margins[key]) {
              var val = margins[key][side];
              reservedMargins[side] = Math.max(reservedMargins[side], val);
            }
          }
          pushMargin.base = {
            l: { val: 0, size: ml },
            r: { val: 1, size: mr },
            t: { val: 1, size: mt },
            b: { val: 0, size: mb }
          };
          for (var s in reservedMargins) {
            var autoMarginPush = 0;
            for (var m in pushMargin) {
              if (m !== "base") {
                if (isNumeric(pushMargin[m][s].size)) {
                  autoMarginPush = pushMargin[m][s].size > autoMarginPush ? pushMargin[m][s].size : autoMarginPush;
                }
              }
            }
            var extraMargin = Math.max(0, margin[s] - autoMarginPush);
            reservedMargins[s] = Math.max(0, reservedMargins[s] - extraMargin);
          }
          for (var k1 in pushMargin) {
            var pushleft = pushMargin[k1].l || {};
            var pushbottom = pushMargin[k1].b || {};
            var fl = pushleft.val;
            var pl = pushleft.size;
            var fb = pushbottom.val;
            var pb = pushbottom.size;
            var availableWidth = width - reservedMargins.r - reservedMargins.l;
            var availableHeight = height - reservedMargins.t - reservedMargins.b;
            for (var k2 in pushMargin) {
              if (isNumeric(pl) && pushMargin[k2].r) {
                var fr = pushMargin[k2].r.val;
                var pr = pushMargin[k2].r.size;
                if (fr > fl) {
                  var newL = (pl * fr + (pr - availableWidth) * fl) / (fr - fl);
                  var newR = (pr * (1 - fl) + (pl - availableWidth) * (1 - fr)) / (fr - fl);
                  if (newL + newR > ml + mr) {
                    ml = newL;
                    mr = newR;
                  }
                }
              }
              if (isNumeric(pb) && pushMargin[k2].t) {
                var ft = pushMargin[k2].t.val;
                var pt = pushMargin[k2].t.size;
                if (ft > fb) {
                  var newB = (pb * ft + (pt - availableHeight) * fb) / (ft - fb);
                  var newT = (pt * (1 - fb) + (pb - availableHeight) * (1 - ft)) / (ft - fb);
                  if (newB + newT > mb + mt) {
                    mb = newB;
                    mt = newT;
                  }
                }
              }
            }
          }
        }
        var minFinalWidth = Lib.constrain(
          width - margin.l - margin.r,
          MIN_SPECIFIED_WIDTH,
          minreducedwidth
        );
        var minFinalHeight = Lib.constrain(
          height - margin.t - margin.b,
          MIN_SPECIFIED_HEIGHT,
          minreducedheight
        );
        var maxSpaceW = Math.max(0, width - minFinalWidth);
        var maxSpaceH = Math.max(0, height - minFinalHeight);
        if (maxSpaceW) {
          var rW = (ml + mr) / maxSpaceW;
          if (rW > 1) {
            ml /= rW;
            mr /= rW;
          }
        }
        if (maxSpaceH) {
          var rH = (mb + mt) / maxSpaceH;
          if (rH > 1) {
            mb /= rH;
            mt /= rH;
          }
        }
        gs.l = Math.round(ml) + reservedMargins.l;
        gs.r = Math.round(mr) + reservedMargins.r;
        gs.t = Math.round(mt) + reservedMargins.t;
        gs.b = Math.round(mb) + reservedMargins.b;
        gs.p = Math.round(margin.pad);
        gs.w = Math.round(width) - gs.l - gs.r;
        gs.h = Math.round(height) - gs.t - gs.b;
        if (!fullLayout._replotting && (plots.didMarginChange(oldMargins, gs) || needsRedrawForShift(gd))) {
          if ("_redrawFromAutoMarginCount" in fullLayout) {
            fullLayout._redrawFromAutoMarginCount++;
          } else {
            fullLayout._redrawFromAutoMarginCount = 1;
          }
          var maxNumberOfRedraws = 3 * (1 + Object.keys(pushMarginIds).length);
          if (fullLayout._redrawFromAutoMarginCount < maxNumberOfRedraws) {
            return Registry.call("_doPlot", gd);
          } else {
            fullLayout._size = oldMargins;
            Lib.warn("Too many auto-margin redraws.");
          }
        }
        refineTicks(gd);
      };
      function refineTicks(gd) {
        var axList = axisIDs.list(gd, "", true);
        [
          "_adjustTickLabelsOverflow",
          "_hideCounterAxisInsideTickLabels"
        ].forEach(function(k) {
          for (var i = 0; i < axList.length; i++) {
            var hideFn = axList[i][k];
            if (hideFn) hideFn();
          }
        });
      }
      var marginKeys = ["l", "r", "t", "b", "p", "w", "h"];
      plots.didMarginChange = function(margin0, margin1) {
        for (var i = 0; i < marginKeys.length; i++) {
          var k = marginKeys[i];
          var m0 = margin0[k];
          var m1 = margin1[k];
          if (!isNumeric(m0) || Math.abs(m1 - m0) > 1) {
            return true;
          }
        }
        return false;
      };
      plots.graphJson = function(gd, dataonly, mode, output, useDefaults, includeConfig) {
        if (useDefaults && dataonly && !gd._fullData || useDefaults && !dataonly && !gd._fullLayout) {
          plots.supplyDefaults(gd);
        }
        var data = useDefaults ? gd._fullData : gd.data;
        var layout = useDefaults ? gd._fullLayout : gd.layout;
        var frames = (gd._transitionData || {})._frames;
        function stripObj(d, keepFunction) {
          if (typeof d === "function") {
            return keepFunction ? "_function_" : null;
          }
          if (Lib.isPlainObject(d)) {
            var o = {};
            var src;
            Object.keys(d).sort().forEach(function(v) {
              if (["_", "["].indexOf(v.charAt(0)) !== -1) return;
              if (typeof d[v] === "function") {
                if (keepFunction) o[v] = "_function";
                return;
              }
              if (mode === "keepdata") {
                if (v.substr(v.length - 3) === "src") {
                  return;
                }
              } else if (mode === "keepstream") {
                src = d[v + "src"];
                if (typeof src === "string" && src.indexOf(":") > 0) {
                  if (!Lib.isPlainObject(d.stream)) {
                    return;
                  }
                }
              } else if (mode !== "keepall") {
                src = d[v + "src"];
                if (typeof src === "string" && src.indexOf(":") > 0) {
                  return;
                }
              }
              o[v] = stripObj(d[v], keepFunction);
            });
            return o;
          }
          var dIsArray = Array.isArray(d);
          var dIsTypedArray = Lib.isTypedArray(d);
          if ((dIsArray || dIsTypedArray) && d.dtype && d.shape) {
            var bdata = d.bdata;
            return stripObj({
              dtype: d.dtype,
              shape: d.shape,
              bdata: (
                // case of ArrayBuffer
                Lib.isArrayBuffer(bdata) ? b64encode.encode(bdata) : (
                  // case of b64 string
                  bdata
                )
              )
            }, keepFunction);
          }
          if (dIsArray) {
            return d.map(function(x) {
              return stripObj(x, keepFunction);
            });
          }
          if (dIsTypedArray) {
            return Lib.simpleMap(d, Lib.identity);
          }
          if (Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);
          return d;
        }
        var obj = {
          data: (data || []).map(function(v) {
            var d = stripObj(v);
            if (dataonly) {
              delete d.fit;
            }
            return d;
          })
        };
        if (!dataonly) {
          obj.layout = stripObj(layout);
          if (useDefaults) {
            var gs = layout._size;
            obj.layout.computed = {
              margin: {
                b: gs.b,
                l: gs.l,
                r: gs.r,
                t: gs.t
              }
            };
          }
        }
        if (frames) obj.frames = stripObj(frames);
        if (includeConfig) obj.config = stripObj(gd._context, true);
        return output === "object" ? obj : JSON.stringify(obj);
      };
      plots.modifyFrames = function(gd, operations) {
        var i, op, frame;
        var _frames = gd._transitionData._frames;
        var _frameHash = gd._transitionData._frameHash;
        for (i = 0; i < operations.length; i++) {
          op = operations[i];
          switch (op.type) {
            // No reason this couldn't exist, but is currently unused/untested:
            /* case 'rename':
                frame = _frames[op.index];
                delete _frameHash[frame.name];
                _frameHash[op.name] = frame;
                frame.name = op.name;
                break;*/
            case "replace":
              frame = op.value;
              var oldName = (_frames[op.index] || {}).name;
              var newName = frame.name;
              _frames[op.index] = _frameHash[newName] = frame;
              if (newName !== oldName) {
                delete _frameHash[oldName];
                _frameHash[newName] = frame;
              }
              break;
            case "insert":
              frame = op.value;
              _frameHash[frame.name] = frame;
              _frames.splice(op.index, 0, frame);
              break;
            case "delete":
              frame = _frames[op.index];
              delete _frameHash[frame.name];
              _frames.splice(op.index, 1);
              break;
          }
        }
        return Promise.resolve();
      };
      plots.computeFrame = function(gd, frameName) {
        var frameLookup = gd._transitionData._frameHash;
        var i, traceIndices, traceIndex, destIndex;
        if (!frameName) {
          throw new Error("computeFrame must be given a string frame name");
        }
        var framePtr = frameLookup[frameName.toString()];
        if (!framePtr) {
          return false;
        }
        var frameStack = [framePtr];
        var frameNameStack = [framePtr.name];
        while (framePtr.baseframe && (framePtr = frameLookup[framePtr.baseframe.toString()])) {
          if (frameNameStack.indexOf(framePtr.name) !== -1) break;
          frameStack.push(framePtr);
          frameNameStack.push(framePtr.name);
        }
        var result = {};
        while (framePtr = frameStack.pop()) {
          if (framePtr.layout) {
            result.layout = plots.extendLayout(result.layout, framePtr.layout);
          }
          if (framePtr.data) {
            if (!result.data) {
              result.data = [];
            }
            traceIndices = framePtr.traces;
            if (!traceIndices) {
              traceIndices = [];
              for (i = 0; i < framePtr.data.length; i++) {
                traceIndices[i] = i;
              }
            }
            if (!result.traces) {
              result.traces = [];
            }
            for (i = 0; i < framePtr.data.length; i++) {
              traceIndex = traceIndices[i];
              if (traceIndex === void 0 || traceIndex === null) {
                continue;
              }
              destIndex = result.traces.indexOf(traceIndex);
              if (destIndex === -1) {
                destIndex = result.data.length;
                result.traces[destIndex] = traceIndex;
              }
              result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);
            }
          }
        }
        return result;
      };
      plots.recomputeFrameHash = function(gd) {
        var hash = gd._transitionData._frameHash = {};
        var frames = gd._transitionData._frames;
        for (var i = 0; i < frames.length; i++) {
          var frame = frames[i];
          if (frame && frame.name) {
            hash[frame.name] = frame;
          }
        }
      };
      plots.extendObjectWithContainers = function(dest, src, containerPaths) {
        var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;
        var copy = Lib.extendDeepNoArrays({}, src || {});
        var expandedObj = Lib.expandObjectPaths(copy);
        var containerObj = {};
        if (containerPaths && containerPaths.length) {
          for (i = 0; i < containerPaths.length; i++) {
            containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);
            containerVal = containerProp.get();
            if (containerVal === void 0) {
              Lib.nestedProperty(containerObj, containerPaths[i]).set(null);
            } else {
              containerProp.set(null);
              Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);
            }
          }
        }
        dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);
        if (containerPaths && containerPaths.length) {
          for (i = 0; i < containerPaths.length; i++) {
            srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);
            srcContainer = srcProp.get();
            if (!srcContainer) continue;
            destProp = Lib.nestedProperty(dest, containerPaths[i]);
            destContainer = destProp.get();
            if (!Array.isArray(destContainer)) {
              destContainer = [];
              destProp.set(destContainer);
            }
            for (j = 0; j < srcContainer.length; j++) {
              var srcObj = srcContainer[j];
              if (srcObj === null) destContainer[j] = null;
              else {
                destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);
              }
            }
            destProp.set(destContainer);
          }
        }
        return dest;
      };
      plots.dataArrayContainers = ["transforms", "dimensions"];
      plots.layoutArrayContainers = Registry.layoutArrayContainers;
      plots.extendTrace = function(destTrace, srcTrace) {
        return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);
      };
      plots.extendLayout = function(destLayout, srcLayout) {
        return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);
      };
      plots.transition = function(gd, data, layout, traces, frameOpts, transitionOpts) {
        var opts = { redraw: frameOpts.redraw };
        var transitionedTraces = {};
        var axEdits = [];
        opts.prepareFn = function() {
          var dataLength = Array.isArray(data) ? data.length : 0;
          var traceIndices = traces.slice(0, dataLength);
          for (var i = 0; i < traceIndices.length; i++) {
            var traceIdx = traceIndices[i];
            var trace = gd._fullData[traceIdx];
            var _module = trace._module;
            if (!_module) continue;
            if (_module.animatable) {
              var n = _module.basePlotModule.name;
              if (!transitionedTraces[n]) transitionedTraces[n] = [];
              transitionedTraces[n].push(traceIdx);
            }
            gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);
          }
          var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout));
          var axisAttrRe = /^[xy]axis[0-9]*$/;
          for (var attr in layoutUpdate) {
            if (!axisAttrRe.test(attr)) continue;
            delete layoutUpdate[attr].range;
          }
          plots.extendLayout(gd.layout, layoutUpdate);
          delete gd.calcdata;
          plots.supplyDefaults(gd);
          plots.doCalcdata(gd);
          var newLayout = Lib.expandObjectPaths(layout);
          if (newLayout) {
            var subplots = gd._fullLayout._plots;
            for (var k in subplots) {
              var plotinfo = subplots[k];
              var xa = plotinfo.xaxis;
              var ya = plotinfo.yaxis;
              var xr0 = xa.range.slice();
              var yr0 = ya.range.slice();
              var xr1 = null;
              var yr1 = null;
              var editX = null;
              var editY = null;
              if (Array.isArray(newLayout[xa._name + ".range"])) {
                xr1 = newLayout[xa._name + ".range"].slice();
              } else if (Array.isArray((newLayout[xa._name] || {}).range)) {
                xr1 = newLayout[xa._name].range.slice();
              }
              if (Array.isArray(newLayout[ya._name + ".range"])) {
                yr1 = newLayout[ya._name + ".range"].slice();
              } else if (Array.isArray((newLayout[ya._name] || {}).range)) {
                yr1 = newLayout[ya._name].range.slice();
              }
              if (xr0 && xr1 && (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1]))) {
                editX = { xr0, xr1 };
              }
              if (yr0 && yr1 && (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1]))) {
                editY = { yr0, yr1 };
              }
              if (editX || editY) {
                axEdits.push(Lib.extendFlat({ plotinfo }, editX, editY));
              }
            }
          }
          return Promise.resolve();
        };
        opts.runFn = function(makeCallback) {
          var traceTransitionOpts;
          var basePlotModules = gd._fullLayout._basePlotModules;
          var hasAxisTransition = axEdits.length;
          var i;
          if (layout) {
            for (i = 0; i < basePlotModules.length; i++) {
              if (basePlotModules[i].transitionAxes) {
                basePlotModules[i].transitionAxes(gd, axEdits, transitionOpts, makeCallback);
              }
            }
          }
          if (hasAxisTransition) {
            traceTransitionOpts = Lib.extendFlat({}, transitionOpts);
            traceTransitionOpts.duration = 0;
            delete transitionedTraces.cartesian;
          } else {
            traceTransitionOpts = transitionOpts;
          }
          for (var n in transitionedTraces) {
            var traceIndices = transitionedTraces[n];
            var _module = gd._fullData[traceIndices[0]]._module;
            _module.basePlotModule.plot(gd, traceIndices, traceTransitionOpts, makeCallback);
          }
        };
        return _transition(gd, transitionOpts, opts);
      };
      plots.transitionFromReact = function(gd, restyleFlags, relayoutFlags, oldFullLayout) {
        var fullLayout = gd._fullLayout;
        var transitionOpts = fullLayout.transition;
        var opts = {};
        var axEdits = [];
        opts.prepareFn = function() {
          var subplots = fullLayout._plots;
          opts.redraw = false;
          if (restyleFlags.anim === "some") opts.redraw = true;
          if (relayoutFlags.anim === "some") opts.redraw = true;
          for (var k in subplots) {
            var plotinfo = subplots[k];
            var xa = plotinfo.xaxis;
            var ya = plotinfo.yaxis;
            var xr0 = oldFullLayout[xa._name].range.slice();
            var yr0 = oldFullLayout[ya._name].range.slice();
            var xr1 = xa.range.slice();
            var yr1 = ya.range.slice();
            xa.setScale();
            ya.setScale();
            var editX = null;
            var editY = null;
            if (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1])) {
              editX = { xr0, xr1 };
            }
            if (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1])) {
              editY = { yr0, yr1 };
            }
            if (editX || editY) {
              axEdits.push(Lib.extendFlat({ plotinfo }, editX, editY));
            }
          }
          return Promise.resolve();
        };
        opts.runFn = function(makeCallback) {
          var fullData = gd._fullData;
          var fullLayout2 = gd._fullLayout;
          var basePlotModules = fullLayout2._basePlotModules;
          var axisTransitionOpts;
          var traceTransitionOpts;
          var transitionedTraces;
          var allTraceIndices = [];
          for (var i = 0; i < fullData.length; i++) {
            allTraceIndices.push(i);
          }
          function transitionAxes() {
            if (!gd._fullLayout) return;
            for (var j = 0; j < basePlotModules.length; j++) {
              if (basePlotModules[j].transitionAxes) {
                basePlotModules[j].transitionAxes(gd, axEdits, axisTransitionOpts, makeCallback);
              }
            }
          }
          function transitionTraces() {
            if (!gd._fullLayout) return;
            for (var j = 0; j < basePlotModules.length; j++) {
              basePlotModules[j].plot(gd, transitionedTraces, traceTransitionOpts, makeCallback);
            }
          }
          if (axEdits.length && restyleFlags.anim) {
            if (transitionOpts.ordering === "traces first") {
              axisTransitionOpts = Lib.extendFlat({}, transitionOpts, { duration: 0 });
              transitionedTraces = allTraceIndices;
              traceTransitionOpts = transitionOpts;
              setTimeout(transitionAxes, transitionOpts.duration);
              transitionTraces();
            } else {
              axisTransitionOpts = transitionOpts;
              transitionedTraces = null;
              traceTransitionOpts = Lib.extendFlat({}, transitionOpts, { duration: 0 });
              setTimeout(transitionTraces, axisTransitionOpts.duration);
              transitionAxes();
            }
          } else if (axEdits.length) {
            axisTransitionOpts = transitionOpts;
            transitionAxes();
          } else if (restyleFlags.anim) {
            transitionedTraces = allTraceIndices;
            traceTransitionOpts = transitionOpts;
            transitionTraces();
          }
        };
        return _transition(gd, transitionOpts, opts);
      };
      function _transition(gd, transitionOpts, opts) {
        var aborted = false;
        function executeCallbacks(list) {
          var p = Promise.resolve();
          if (!list) return p;
          while (list.length) {
            p = p.then(list.shift());
          }
          return p;
        }
        function flushCallbacks(list) {
          if (!list) return;
          while (list.length) {
            list.shift();
          }
        }
        function executeTransitions() {
          gd.emit("plotly_transitioning", []);
          return new Promise(function(resolve) {
            gd._transitioning = true;
            if (transitionOpts.duration > 0) {
              gd._transitioningWithDuration = true;
            }
            gd._transitionData._interruptCallbacks.push(function() {
              aborted = true;
            });
            if (opts.redraw) {
              gd._transitionData._interruptCallbacks.push(function() {
                return Registry.call("redraw", gd);
              });
            }
            gd._transitionData._interruptCallbacks.push(function() {
              gd.emit("plotly_transitioninterrupted", []);
            });
            var numCallbacks = 0;
            var numCompleted = 0;
            function makeCallback() {
              numCallbacks++;
              return function() {
                numCompleted++;
                if (!aborted && numCompleted === numCallbacks) {
                  completeTransition(resolve);
                }
              };
            }
            opts.runFn(makeCallback);
            setTimeout(makeCallback());
          });
        }
        function completeTransition(callback) {
          if (!gd._transitionData) return;
          flushCallbacks(gd._transitionData._interruptCallbacks);
          return Promise.resolve().then(function() {
            if (opts.redraw) {
              return Registry.call("redraw", gd);
            }
          }).then(function() {
            gd._transitioning = false;
            gd._transitioningWithDuration = false;
            gd.emit("plotly_transitioned", []);
          }).then(callback);
        }
        function interruptPreviousTransitions() {
          if (!gd._transitionData) return;
          gd._transitioning = false;
          return executeCallbacks(gd._transitionData._interruptCallbacks);
        }
        var seq = [
          plots.previousPromises,
          interruptPreviousTransitions,
          opts.prepareFn,
          plots.rehover,
          plots.reselect,
          executeTransitions
        ];
        var transitionStarting = Lib.syncOrAsync(seq, gd);
        if (!transitionStarting || !transitionStarting.then) {
          transitionStarting = Promise.resolve();
        }
        return transitionStarting.then(function() {
          return gd;
        });
      }
      plots.doCalcdata = function(gd, traces) {
        var axList = axisIDs.list(gd);
        var fullData = gd._fullData;
        var fullLayout = gd._fullLayout;
        var trace, _module, i, j;
        var calcdata = new Array(fullData.length);
        var oldCalcdata = (gd.calcdata || []).slice();
        gd.calcdata = calcdata;
        fullLayout._numBoxes = 0;
        fullLayout._numViolins = 0;
        fullLayout._violinScaleGroupStats = {};
        gd._hmpixcount = 0;
        gd._hmlumcount = 0;
        fullLayout._piecolormap = {};
        fullLayout._sunburstcolormap = {};
        fullLayout._treemapcolormap = {};
        fullLayout._iciclecolormap = {};
        fullLayout._funnelareacolormap = {};
        for (i = 0; i < fullData.length; i++) {
          if (Array.isArray(traces) && traces.indexOf(i) === -1) {
            calcdata[i] = oldCalcdata[i];
            continue;
          }
        }
        for (i = 0; i < fullData.length; i++) {
          trace = fullData[i];
          trace._arrayAttrs = PlotSchema.findArrayAttributes(trace);
          trace._extremes = {};
        }
        var polarIds = fullLayout._subplots.polar || [];
        for (i = 0; i < polarIds.length; i++) {
          axList.push(
            fullLayout[polarIds[i]].radialaxis,
            fullLayout[polarIds[i]].angularaxis
          );
        }
        for (var k in fullLayout._colorAxes) {
          var cOpts = fullLayout[k];
          if (cOpts.cauto !== false) {
            delete cOpts.cmin;
            delete cOpts.cmax;
          }
        }
        var hasCalcTransform = false;
        function transformCalci(i2) {
          trace = fullData[i2];
          _module = trace._module;
          if (trace.visible === true && trace.transforms) {
            if (_module && _module.calc) {
              var cdi = _module.calc(gd, trace);
              if (cdi[0] && cdi[0].t && cdi[0].t._scene) {
                delete cdi[0].t._scene.dirty;
              }
            }
            for (j = 0; j < trace.transforms.length; j++) {
              var transform = trace.transforms[j];
              _module = transformsRegistry[transform.type];
              if (_module && _module.calcTransform) {
                trace._hasCalcTransform = true;
                hasCalcTransform = true;
                _module.calcTransform(gd, trace, transform);
              }
            }
          }
        }
        function calci(i2, isContainer) {
          trace = fullData[i2];
          _module = trace._module;
          if (!!_module.isContainer !== isContainer) return;
          var cd = [];
          if (trace.visible === true && trace._length !== 0) {
            delete trace._indexToPoints;
            var transforms = trace.transforms || [];
            for (j = transforms.length - 1; j >= 0; j--) {
              if (transforms[j].enabled) {
                trace._indexToPoints = transforms[j]._indexToPoints;
                break;
              }
            }
            if (_module && _module.calc) {
              cd = _module.calc(gd, trace);
            }
          }
          if (!Array.isArray(cd) || !cd[0]) {
            cd = [{ x: BADNUM, y: BADNUM }];
          }
          if (!cd[0].t) cd[0].t = {};
          cd[0].trace = trace;
          calcdata[i2] = cd;
        }
        setupAxisCategories(axList, fullData, fullLayout);
        for (i = 0; i < fullData.length; i++) calci(i, true);
        for (i = 0; i < fullData.length; i++) transformCalci(i);
        if (hasCalcTransform) setupAxisCategories(axList, fullData, fullLayout);
        for (i = 0; i < fullData.length; i++) calci(i, true);
        for (i = 0; i < fullData.length; i++) calci(i, false);
        doCrossTraceCalc(gd);
        var sorted = sortAxisCategoriesByValue(axList, gd);
        if (sorted.length) {
          fullLayout._numBoxes = 0;
          fullLayout._numViolins = 0;
          for (i = 0; i < sorted.length; i++) calci(sorted[i], true);
          for (i = 0; i < sorted.length; i++) calci(sorted[i], false);
          doCrossTraceCalc(gd);
        }
        Registry.getComponentMethod("fx", "calc")(gd);
        Registry.getComponentMethod("errorbars", "calc")(gd);
      };
      var sortAxisCategoriesByValueRegex = /(total|sum|min|max|mean|geometric mean|median) (ascending|descending)/;
      function sortAxisCategoriesByValue(axList, gd) {
        var affectedTraces = [];
        var i, j, k, l, o;
        function zMapCategory(type2, ax2, value2) {
          var axLetter2 = ax2._id.charAt(0);
          if (type2 === "histogram2dcontour") {
            var counterAxLetter = ax2._counterAxes[0];
            var counterAx = axisIDs.getFromId(gd, counterAxLetter);
            var xCategorical = axLetter2 === "x" || counterAxLetter === "x" && counterAx.type === "category";
            var yCategorical = axLetter2 === "y" || counterAxLetter === "y" && counterAx.type === "category";
            return function(o2, l2) {
              if (o2 === 0 || l2 === 0) return -1;
              if (xCategorical && o2 === value2[l2].length - 1) return -1;
              if (yCategorical && l2 === value2.length - 1) return -1;
              return (axLetter2 === "y" ? l2 : o2) - 1;
            };
          } else {
            return function(o2, l2) {
              return axLetter2 === "y" ? l2 : o2;
            };
          }
        }
        var aggFn = {
          min: function(values) {
            return Lib.aggNums(Math.min, null, values);
          },
          max: function(values) {
            return Lib.aggNums(Math.max, null, values);
          },
          sum: function(values) {
            return Lib.aggNums(function(a, b) {
              return a + b;
            }, null, values);
          },
          total: function(values) {
            return Lib.aggNums(function(a, b) {
              return a + b;
            }, null, values);
          },
          mean: function(values) {
            return Lib.mean(values);
          },
          "geometric mean": function(values) {
            return Lib.geometricMean(values);
          },
          median: function(values) {
            return Lib.median(values);
          }
        };
        function sortAscending(a, b) {
          return a[1] - b[1];
        }
        function sortDescending(a, b) {
          return b[1] - a[1];
        }
        for (i = 0; i < axList.length; i++) {
          var ax = axList[i];
          if (ax.type !== "category") continue;
          var match = ax.categoryorder.match(sortAxisCategoriesByValueRegex);
          if (match) {
            var aggregator = match[1];
            var order = match[2];
            var axLetter = ax._id.charAt(0);
            var isX = axLetter === "x";
            var categoriesValue = [];
            for (j = 0; j < ax._categories.length; j++) {
              categoriesValue.push([ax._categories[j], []]);
            }
            for (j = 0; j < ax._traceIndices.length; j++) {
              var traceIndex = ax._traceIndices[j];
              var fullTrace = gd._fullData[traceIndex];
              if (fullTrace.visible !== true) continue;
              var type = fullTrace.type;
              if (Registry.traceIs(fullTrace, "histogram")) {
                delete fullTrace._xautoBinFinished;
                delete fullTrace._yautoBinFinished;
              }
              var isSplom = type === "splom";
              var isScattergl = type === "scattergl";
              var cd = gd.calcdata[traceIndex];
              for (k = 0; k < cd.length; k++) {
                var cdi = cd[k];
                var catIndex, value;
                if (isSplom) {
                  var currentDimensionIndex = fullTrace._axesDim[ax._id];
                  if (!isX) {
                    var associatedXAxisID = fullTrace._diag[currentDimensionIndex][0];
                    if (associatedXAxisID) ax = gd._fullLayout[axisIDs.id2name(associatedXAxisID)];
                  }
                  var categories = cdi.trace.dimensions[currentDimensionIndex].values;
                  for (l = 0; l < categories.length; l++) {
                    catIndex = ax._categoriesMap[categories[l]];
                    for (o = 0; o < cdi.trace.dimensions.length; o++) {
                      if (o === currentDimensionIndex) continue;
                      var dimension = cdi.trace.dimensions[o];
                      categoriesValue[catIndex][1].push(dimension.values[l]);
                    }
                  }
                } else if (isScattergl) {
                  for (l = 0; l < cdi.t.x.length; l++) {
                    if (isX) {
                      catIndex = cdi.t.x[l];
                      value = cdi.t.y[l];
                    } else {
                      catIndex = cdi.t.y[l];
                      value = cdi.t.x[l];
                    }
                    categoriesValue[catIndex][1].push(value);
                  }
                  if (cdi.t && cdi.t._scene) {
                    delete cdi.t._scene.dirty;
                  }
                } else if (cdi.hasOwnProperty("z")) {
                  value = cdi.z;
                  var mapping = zMapCategory(fullTrace.type, ax, value);
                  for (l = 0; l < value.length; l++) {
                    for (o = 0; o < value[l].length; o++) {
                      catIndex = mapping(o, l);
                      if (catIndex + 1) categoriesValue[catIndex][1].push(value[l][o]);
                    }
                  }
                } else {
                  catIndex = cdi.p;
                  if (catIndex === void 0) catIndex = cdi[axLetter];
                  value = cdi.s;
                  if (value === void 0) value = cdi.v;
                  if (value === void 0) value = isX ? cdi.y : cdi.x;
                  if (!Array.isArray(value)) {
                    if (value === void 0) value = [];
                    else value = [value];
                  }
                  for (l = 0; l < value.length; l++) {
                    categoriesValue[catIndex][1].push(value[l]);
                  }
                }
              }
            }
            ax._categoriesValue = categoriesValue;
            var categoriesAggregatedValue = [];
            for (j = 0; j < categoriesValue.length; j++) {
              categoriesAggregatedValue.push([
                categoriesValue[j][0],
                aggFn[aggregator](categoriesValue[j][1])
              ]);
            }
            categoriesAggregatedValue.sort(order === "descending" ? sortDescending : sortAscending);
            ax._categoriesAggregatedValue = categoriesAggregatedValue;
            ax._initialCategories = categoriesAggregatedValue.map(function(c) {
              return c[0];
            });
            affectedTraces = affectedTraces.concat(ax.sortByInitialCategories());
          }
        }
        return affectedTraces;
      }
      function setupAxisCategories(axList, fullData, fullLayout) {
        var axLookup = {};
        function setupOne(ax) {
          ax.clearCalc();
          if (ax.type === "multicategory") {
            ax.setupMultiCategory(fullData);
          }
          axLookup[ax._id] = 1;
        }
        Lib.simpleMap(axList, setupOne);
        var matchGroups = fullLayout._axisMatchGroups || [];
        for (var i = 0; i < matchGroups.length; i++) {
          for (var axId in matchGroups[i]) {
            if (!axLookup[axId]) {
              setupOne(fullLayout[axisIDs.id2name(axId)]);
            }
          }
        }
      }
      function doCrossTraceCalc(gd) {
        var fullLayout = gd._fullLayout;
        var modules = fullLayout._visibleModules;
        var hash = {};
        var i, j, k;
        for (j = 0; j < modules.length; j++) {
          var _module = modules[j];
          var fn = _module.crossTraceCalc;
          if (fn) {
            var spType = _module.basePlotModule.name;
            if (hash[spType]) {
              Lib.pushUnique(hash[spType], fn);
            } else {
              hash[spType] = [fn];
            }
          }
        }
        for (k in hash) {
          var methods = hash[k];
          var subplots = fullLayout._subplots[k];
          if (Array.isArray(subplots)) {
            for (i = 0; i < subplots.length; i++) {
              var sp = subplots[i];
              var spInfo = k === "cartesian" ? fullLayout._plots[sp] : fullLayout[sp];
              for (j = 0; j < methods.length; j++) {
                methods[j](gd, spInfo, sp);
              }
            }
          } else {
            for (j = 0; j < methods.length; j++) {
              methods[j](gd);
            }
          }
        }
      }
      plots.rehover = function(gd) {
        if (gd._fullLayout._rehover) {
          gd._fullLayout._rehover();
        }
      };
      plots.redrag = function(gd) {
        if (gd._fullLayout._redrag) {
          gd._fullLayout._redrag();
        }
      };
      plots.reselect = function(gd) {
        var fullLayout = gd._fullLayout;
        var A = (gd.layout || {}).selections;
        var B = fullLayout._previousSelections;
        fullLayout._previousSelections = A;
        var mayEmitSelected = fullLayout._reselect || JSON.stringify(A) !== JSON.stringify(B);
        Registry.getComponentMethod("selections", "reselect")(gd, mayEmitSelected);
      };
      plots.generalUpdatePerTraceModule = function(gd, subplot, subplotCalcData, subplotLayout) {
        var traceHashOld = subplot.traceHash;
        var traceHash = {};
        var i;
        for (i = 0; i < subplotCalcData.length; i++) {
          var calcTraces = subplotCalcData[i];
          var trace = calcTraces[0].trace;
          if (trace.visible) {
            traceHash[trace.type] = traceHash[trace.type] || [];
            traceHash[trace.type].push(calcTraces);
          }
        }
        for (var moduleNameOld in traceHashOld) {
          if (!traceHash[moduleNameOld]) {
            var fakeCalcTrace = traceHashOld[moduleNameOld][0];
            var fakeTrace = fakeCalcTrace[0].trace;
            fakeTrace.visible = false;
            traceHash[moduleNameOld] = [fakeCalcTrace];
          }
        }
        for (var moduleName in traceHash) {
          var moduleCalcData = traceHash[moduleName];
          var _module = moduleCalcData[0][0].trace._module;
          _module.plot(gd, subplot, Lib.filterVisible(moduleCalcData), subplotLayout);
        }
        subplot.traceHash = traceHash;
      };
      plots.plotBasePlot = function(desiredType, gd, traces, transitionOpts, makeOnCompleteCallback) {
        var _module = Registry.getModule(desiredType);
        var cdmodule = getModuleCalcData(gd.calcdata, _module)[0];
        _module.plot(gd, cdmodule, transitionOpts, makeOnCompleteCallback);
      };
      plots.cleanBasePlot = function(desiredType, newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var had = oldFullLayout._has && oldFullLayout._has(desiredType);
        var has = newFullLayout._has && newFullLayout._has(desiredType);
        if (had && !has) {
          oldFullLayout["_" + desiredType + "layer"].selectAll("g.trace").remove();
        }
      };
    }
  });

  // src/constants/xmlns_namespaces.js
  var require_xmlns_namespaces = __commonJS({
    "src/constants/xmlns_namespaces.js"(exports) {
      "use strict";
      exports.xmlns = "http://www.w3.org/2000/xmlns/";
      exports.svg = "http://www.w3.org/2000/svg";
      exports.xlink = "http://www.w3.org/1999/xlink";
      exports.svgAttrs = {
        xmlns: exports.svg,
        "xmlns:xlink": exports.xlink
      };
    }
  });

  // src/constants/alignment.js
  var require_alignment = __commonJS({
    "src/constants/alignment.js"(exports, module) {
      "use strict";
      module.exports = {
        // from bottom left: this is the origin of our paper-reference
        // positioning system
        FROM_BL: {
          left: 0,
          center: 0.5,
          right: 1,
          bottom: 0,
          middle: 0.5,
          top: 1
        },
        // from top left: this is the screen pixel positioning origin
        FROM_TL: {
          left: 0,
          center: 0.5,
          right: 1,
          bottom: 1,
          middle: 0.5,
          top: 0
        },
        // from bottom right: sometimes you just need the opposite of ^^
        FROM_BR: {
          left: 1,
          center: 0.5,
          right: 0,
          bottom: 0,
          middle: 0.5,
          top: 1
        },
        // multiple of fontSize to get the vertical offset between lines
        LINE_SPACING: 1.3,
        // multiple of fontSize to shift from the baseline
        // to the cap (captical letter) line
        // (to use when we don't calculate this shift from Drawing.bBox)
        // This is an approximation since in reality cap height can differ
        // from font to font. However, according to Wikipedia
        //   an "average" font might have a cap height of 70% of the em
        // https://en.wikipedia.org/wiki/Em_(typography)#History
        CAP_SHIFT: 0.7,
        // half the cap height (distance between baseline and cap line)
        // of an "average" font (for more info see above).
        MID_SHIFT: 0.35,
        OPPOSITE_SIDE: {
          left: "right",
          right: "left",
          top: "bottom",
          bottom: "top"
        }
      };
    }
  });

  // src/lib/svg_text_utils.js
  var require_svg_text_utils = __commonJS({
    "src/lib/svg_text_utils.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var xmlnsNamespaces = require_xmlns_namespaces();
      var LINE_SPACING = require_alignment().LINE_SPACING;
      var FIND_TEX = /([^$]*)([$]+[^$]*[$]+)([^$]*)/;
      exports.convertToTspans = function(_context, gd, _callback) {
        var str = _context.text();
        var tex = !_context.attr("data-notex") && gd && gd._context.typesetMath && typeof MathJax !== "undefined" && str.match(FIND_TEX);
        var parent = d3.select(_context.node().parentNode);
        if (parent.empty()) return;
        var svgClass = _context.attr("class") ? _context.attr("class").split(" ")[0] : "text";
        svgClass += "-math";
        parent.selectAll("svg." + svgClass).remove();
        parent.selectAll("g." + svgClass + "-group").remove();
        _context.style("display", null).attr({
          // some callers use data-unformatted *from the <text> element* in 'cancel'
          // so we need it here even if we're going to turn it into math
          // these two (plus style and text-anchor attributes) form the key we're
          // going to use for Drawing.bBox
          "data-unformatted": str,
          "data-math": "N"
        });
        function showText() {
          if (!parent.empty()) {
            svgClass = _context.attr("class") + "-math";
            parent.select("svg." + svgClass).remove();
          }
          _context.text("").style("white-space", "pre");
          var hasLink = buildSVGText(_context.node(), str);
          if (hasLink) {
            _context.style("pointer-events", "all");
          }
          exports.positionText(_context);
          if (_callback) _callback.call(_context);
        }
        if (tex) {
          (gd && gd._promises || []).push(new Promise(function(resolve) {
            _context.style("display", "none");
            var fontSize = parseInt(_context.node().style.fontSize, 10);
            var config = { fontSize };
            texToSVG(tex[2], config, function(_svgEl, _glyphDefs, _svgBBox) {
              parent.selectAll("svg." + svgClass).remove();
              parent.selectAll("g." + svgClass + "-group").remove();
              var newSvg = _svgEl && _svgEl.select("svg");
              if (!newSvg || !newSvg.node()) {
                showText();
                resolve();
                return;
              }
              var mathjaxGroup = parent.append("g").classed(svgClass + "-group", true).attr({
                "pointer-events": "none",
                "data-unformatted": str,
                "data-math": "Y"
              });
              mathjaxGroup.node().appendChild(newSvg.node());
              if (_glyphDefs && _glyphDefs.node()) {
                newSvg.node().insertBefore(
                  _glyphDefs.node().cloneNode(true),
                  newSvg.node().firstChild
                );
              }
              var w0 = _svgBBox.width;
              var h0 = _svgBBox.height;
              newSvg.attr({
                class: svgClass,
                height: h0,
                preserveAspectRatio: "xMinYMin meet"
              }).style({ overflow: "visible", "pointer-events": "none" });
              var fill = _context.node().style.fill || "black";
              var g = newSvg.select("g");
              g.attr({ fill, stroke: fill });
              var bb = g.node().getBoundingClientRect();
              var w = bb.width;
              var h = bb.height;
              if (w > w0 || h > h0) {
                newSvg.style("overflow", "hidden");
                bb = newSvg.node().getBoundingClientRect();
                w = bb.width;
                h = bb.height;
              }
              var x = +_context.attr("x");
              var y = +_context.attr("y");
              var textHeight = fontSize || _context.node().getBoundingClientRect().height;
              var dy = -textHeight / 4;
              if (svgClass[0] === "y") {
                mathjaxGroup.attr({
                  transform: "rotate(" + [-90, x, y] + ")" + strTranslate(-w / 2, dy - h / 2)
                });
              } else if (svgClass[0] === "l") {
                y = dy - h / 2;
              } else if (svgClass[0] === "a" && svgClass.indexOf("atitle") !== 0) {
                x = 0;
                y = dy;
              } else {
                var anchor = _context.attr("text-anchor");
                x = x - w * (anchor === "middle" ? 0.5 : anchor === "end" ? 1 : 0);
                y = y + dy - h / 2;
              }
              newSvg.attr({
                x,
                y
              });
              if (_callback) _callback.call(_context, mathjaxGroup);
              resolve(mathjaxGroup);
            });
          }));
        } else showText();
        return _context;
      };
      var LT_MATCH = /(<|&lt;|&#60;)/g;
      var GT_MATCH = /(>|&gt;|&#62;)/g;
      function cleanEscapesForTex(s) {
        return s.replace(LT_MATCH, "\\lt ").replace(GT_MATCH, "\\gt ");
      }
      var inlineMath = [["$", "$"], ["\\(", "\\)"]];
      function texToSVG(_texString, _config, _callback) {
        var MathJaxVersion = parseInt(
          (MathJax.version || "").split(".")[0]
        );
        if (MathJaxVersion !== 2 && MathJaxVersion !== 3) {
          Lib.warn("No MathJax version:", MathJax.version);
          return;
        }
        var originalRenderer, originalConfig, originalProcessSectionDelay, tmpDiv;
        var setConfig2 = function() {
          originalConfig = Lib.extendDeepAll({}, MathJax.Hub.config);
          originalProcessSectionDelay = MathJax.Hub.processSectionDelay;
          if (MathJax.Hub.processSectionDelay !== void 0) {
            MathJax.Hub.processSectionDelay = 0;
          }
          return MathJax.Hub.Config({
            messageStyle: "none",
            tex2jax: {
              inlineMath
            },
            displayAlign: "left"
          });
        };
        var setConfig3 = function() {
          originalConfig = Lib.extendDeepAll({}, MathJax.config);
          if (!MathJax.config.tex) {
            MathJax.config.tex = {};
          }
          MathJax.config.tex.inlineMath = inlineMath;
        };
        var setRenderer2 = function() {
          originalRenderer = MathJax.Hub.config.menuSettings.renderer;
          if (originalRenderer !== "SVG") {
            return MathJax.Hub.setRenderer("SVG");
          }
        };
        var setRenderer3 = function() {
          originalRenderer = MathJax.config.startup.output;
          if (originalRenderer !== "svg") {
            MathJax.config.startup.output = "svg";
          }
        };
        var initiateMathJax = function() {
          var randomID = "math-output-" + Lib.randstr({}, 64);
          tmpDiv = d3.select("body").append("div").attr({ id: randomID }).style({
            visibility: "hidden",
            position: "absolute",
            "font-size": _config.fontSize + "px"
          }).text(cleanEscapesForTex(_texString));
          var tmpNode = tmpDiv.node();
          return MathJaxVersion === 2 ? MathJax.Hub.Typeset(tmpNode) : MathJax.typeset([tmpNode]);
        };
        var finalizeMathJax = function() {
          var sel = tmpDiv.select(
            MathJaxVersion === 2 ? ".MathJax_SVG" : ".MathJax"
          );
          var node = !sel.empty() && tmpDiv.select("svg").node();
          if (!node) {
            Lib.log("There was an error in the tex syntax.", _texString);
            _callback();
          } else {
            var nodeBBox = node.getBoundingClientRect();
            var glyphDefs;
            if (MathJaxVersion === 2) {
              glyphDefs = d3.select("body").select("#MathJax_SVG_glyphs");
            } else {
              glyphDefs = sel.select("defs");
            }
            _callback(sel, glyphDefs, nodeBBox);
          }
          tmpDiv.remove();
        };
        var resetRenderer2 = function() {
          if (originalRenderer !== "SVG") {
            return MathJax.Hub.setRenderer(originalRenderer);
          }
        };
        var resetRenderer3 = function() {
          if (originalRenderer !== "svg") {
            MathJax.config.startup.output = originalRenderer;
          }
        };
        var resetConfig2 = function() {
          if (originalProcessSectionDelay !== void 0) {
            MathJax.Hub.processSectionDelay = originalProcessSectionDelay;
          }
          return MathJax.Hub.Config(originalConfig);
        };
        var resetConfig3 = function() {
          MathJax.config = originalConfig;
        };
        if (MathJaxVersion === 2) {
          MathJax.Hub.Queue(
            setConfig2,
            setRenderer2,
            initiateMathJax,
            finalizeMathJax,
            resetRenderer2,
            resetConfig2
          );
        } else if (MathJaxVersion === 3) {
          setConfig3();
          setRenderer3();
          MathJax.startup.defaultReady();
          MathJax.startup.promise.then(function() {
            initiateMathJax();
            finalizeMathJax();
            resetRenderer3();
            resetConfig3();
          });
        }
      }
      var TAG_STYLES = {
        // would like to use baseline-shift for sub/sup but FF doesn't support it
        // so we need to use dy along with the uber hacky shift-back-to
        // baseline below
        sup: "font-size:70%",
        sub: "font-size:70%",
        s: "text-decoration:line-through",
        u: "text-decoration:underline",
        b: "font-weight:bold",
        i: "font-style:italic",
        a: "cursor:pointer",
        span: "",
        em: "font-style:italic;font-weight:bold"
      };
      var SHIFT_DY = {
        sub: "0.3em",
        sup: "-0.6em"
      };
      var RESET_DY = {
        sub: "-0.21em",
        sup: "0.42em"
      };
      var ZERO_WIDTH_SPACE = "\u200B";
      var PROTOCOLS = ["http:", "https:", "mailto:", "", void 0, ":"];
      var NEWLINES = exports.NEWLINES = /(\r\n?|\n)/g;
      var SPLIT_TAGS = /(<[^<>]*>)/;
      var ONE_TAG = /<(\/?)([^ >]*)(\s+(.*))?>/i;
      var BR_TAG = /<br(\s+.*)?>/i;
      exports.BR_TAG_ALL = /<br(\s+.*)?>/gi;
      var STYLEMATCH = /(^|[\s"'])style\s*=\s*("([^"]*);?"|'([^']*);?')/i;
      var HREFMATCH = /(^|[\s"'])href\s*=\s*("([^"]*)"|'([^']*)')/i;
      var TARGETMATCH = /(^|[\s"'])target\s*=\s*("([^"\s]*)"|'([^'\s]*)')/i;
      var POPUPMATCH = /(^|[\s"'])popup\s*=\s*("([\w=,]*)"|'([\w=,]*)')/i;
      function getQuotedMatch(_str, re) {
        if (!_str) return null;
        var match = _str.match(re);
        var result = match && (match[3] || match[4]);
        return result && convertEntities(result);
      }
      var COLORMATCH = /(^|;)\s*color:/;
      exports.plainText = function(_str, opts) {
        opts = opts || {};
        var len = opts.len !== void 0 && opts.len !== -1 ? opts.len : Infinity;
        var allowedTags = opts.allowedTags !== void 0 ? opts.allowedTags : ["br"];
        var ellipsis = "...";
        var eLen = ellipsis.length;
        var oldParts = _str.split(SPLIT_TAGS);
        var newParts = [];
        var prevTag = "";
        var l = 0;
        for (var i = 0; i < oldParts.length; i++) {
          var p = oldParts[i];
          var match = p.match(ONE_TAG);
          var tagType = match && match[2].toLowerCase();
          if (tagType) {
            if (allowedTags.indexOf(tagType) !== -1) {
              newParts.push(p);
              prevTag = tagType;
            }
          } else {
            var pLen = p.length;
            if (l + pLen < len) {
              newParts.push(p);
              l += pLen;
            } else if (l < len) {
              var pLen2 = len - l;
              if (prevTag && (prevTag !== "br" || pLen2 <= eLen || pLen <= eLen)) {
                newParts.pop();
              }
              if (len > eLen) {
                newParts.push(p.substr(0, pLen2 - eLen) + ellipsis);
              } else {
                newParts.push(p.substr(0, pLen2));
              }
              break;
            }
            prevTag = "";
          }
        }
        return newParts.join("");
      };
      var entityToUnicode = {
        mu: "\u03BC",
        amp: "&",
        lt: "<",
        gt: ">",
        nbsp: "\xA0",
        times: "\xD7",
        plusmn: "\xB1",
        deg: "\xB0"
      };
      var ENTITY_MATCH = /&(#\d+|#x[\da-fA-F]+|[a-z]+);/g;
      function convertEntities(_str) {
        return _str.replace(ENTITY_MATCH, function(fullMatch, innerMatch) {
          var outChar;
          if (innerMatch.charAt(0) === "#") {
            outChar = fromCodePoint(
              innerMatch.charAt(1) === "x" ? parseInt(innerMatch.substr(2), 16) : parseInt(innerMatch.substr(1), 10)
            );
          } else outChar = entityToUnicode[innerMatch];
          return outChar || fullMatch;
        });
      }
      exports.convertEntities = convertEntities;
      function fromCodePoint(code) {
        if (code > 1114111) return;
        var stringFromCodePoint = String.fromCodePoint;
        if (stringFromCodePoint) return stringFromCodePoint(code);
        var stringFromCharCode = String.fromCharCode;
        if (code <= 65535) return stringFromCharCode(code);
        return stringFromCharCode(
          (code >> 10) + 55232,
          code % 1024 + 56320
        );
      }
      function buildSVGText(containerNode, str) {
        str = str.replace(NEWLINES, " ");
        var hasLink = false;
        var nodeStack = [];
        var currentNode;
        var currentLine = -1;
        function newLine() {
          currentLine++;
          var lineNode = document.createElementNS(xmlnsNamespaces.svg, "tspan");
          d3.select(lineNode).attr({
            class: "line",
            dy: currentLine * LINE_SPACING + "em"
          });
          containerNode.appendChild(lineNode);
          currentNode = lineNode;
          var oldNodeStack = nodeStack;
          nodeStack = [{ node: lineNode }];
          if (oldNodeStack.length > 1) {
            for (var i2 = 1; i2 < oldNodeStack.length; i2++) {
              enterNode(oldNodeStack[i2]);
            }
          }
        }
        function enterNode(nodeSpec2) {
          var type = nodeSpec2.type;
          var nodeAttrs = {};
          var nodeType;
          if (type === "a") {
            nodeType = "a";
            var target = nodeSpec2.target;
            var href2 = nodeSpec2.href;
            var popup = nodeSpec2.popup;
            if (href2) {
              nodeAttrs = {
                "xlink:xlink:show": target === "_blank" || target.charAt(0) !== "_" ? "new" : "replace",
                target,
                "xlink:xlink:href": href2
              };
              if (popup) {
                nodeAttrs.onclick = 'window.open(this.href.baseVal,this.target.baseVal,"' + popup + '");return false;';
              }
            }
          } else nodeType = "tspan";
          if (nodeSpec2.style) nodeAttrs.style = nodeSpec2.style;
          var newNode = document.createElementNS(xmlnsNamespaces.svg, nodeType);
          if (type === "sup" || type === "sub") {
            addTextNode(currentNode, ZERO_WIDTH_SPACE);
            currentNode.appendChild(newNode);
            var resetter = document.createElementNS(xmlnsNamespaces.svg, "tspan");
            addTextNode(resetter, ZERO_WIDTH_SPACE);
            d3.select(resetter).attr("dy", RESET_DY[type]);
            nodeAttrs.dy = SHIFT_DY[type];
            currentNode.appendChild(newNode);
            currentNode.appendChild(resetter);
          } else {
            currentNode.appendChild(newNode);
          }
          d3.select(newNode).attr(nodeAttrs);
          currentNode = nodeSpec2.node = newNode;
          nodeStack.push(nodeSpec2);
        }
        function addTextNode(node, text) {
          node.appendChild(document.createTextNode(text));
        }
        function exitNode(type) {
          if (nodeStack.length === 1) {
            Lib.log("Ignoring unexpected end tag </" + type + ">.", str);
            return;
          }
          var innerNode = nodeStack.pop();
          if (type !== innerNode.type) {
            Lib.log("Start tag <" + innerNode.type + "> doesnt match end tag <" + type + ">. Pretending it did match.", str);
          }
          currentNode = nodeStack[nodeStack.length - 1].node;
        }
        var hasLines = BR_TAG.test(str);
        if (hasLines) newLine();
        else {
          currentNode = containerNode;
          nodeStack = [{ node: containerNode }];
        }
        var parts = str.split(SPLIT_TAGS);
        for (var i = 0; i < parts.length; i++) {
          var parti = parts[i];
          var match = parti.match(ONE_TAG);
          var tagType = match && match[2].toLowerCase();
          var tagStyle = TAG_STYLES[tagType];
          if (tagType === "br") {
            newLine();
          } else if (tagStyle === void 0) {
            addTextNode(currentNode, convertEntities(parti));
          } else {
            if (match[1]) {
              exitNode(tagType);
            } else {
              var extra = match[4];
              var nodeSpec = { type: tagType };
              var css = getQuotedMatch(extra, STYLEMATCH);
              if (css) {
                css = css.replace(COLORMATCH, "$1 fill:");
                if (tagStyle) css += ";" + tagStyle;
              } else if (tagStyle) css = tagStyle;
              if (css) nodeSpec.style = css;
              if (tagType === "a") {
                hasLink = true;
                var href = getQuotedMatch(extra, HREFMATCH);
                if (href) {
                  var safeHref = sanitizeHref(href);
                  if (safeHref) {
                    nodeSpec.href = safeHref;
                    nodeSpec.target = getQuotedMatch(extra, TARGETMATCH) || "_blank";
                    nodeSpec.popup = getQuotedMatch(extra, POPUPMATCH);
                  }
                }
              }
              enterNode(nodeSpec);
            }
          }
        }
        return hasLink;
      }
      function sanitizeHref(href) {
        var decodedHref = encodeURI(decodeURI(href));
        var dummyAnchor1 = document.createElement("a");
        var dummyAnchor2 = document.createElement("a");
        dummyAnchor1.href = href;
        dummyAnchor2.href = decodedHref;
        var p1 = dummyAnchor1.protocol;
        var p2 = dummyAnchor2.protocol;
        if (PROTOCOLS.indexOf(p1) !== -1 && PROTOCOLS.indexOf(p2) !== -1) {
          return decodedHref;
        } else {
          return "";
        }
      }
      exports.sanitizeHTML = function sanitizeHTML(str) {
        str = str.replace(NEWLINES, " ");
        var rootNode = document.createElement("p");
        var currentNode = rootNode;
        var nodeStack = [];
        var parts = str.split(SPLIT_TAGS);
        for (var i = 0; i < parts.length; i++) {
          var parti = parts[i];
          var match = parti.match(ONE_TAG);
          var tagType = match && match[2].toLowerCase();
          if (tagType in TAG_STYLES) {
            if (match[1]) {
              if (nodeStack.length) {
                currentNode = nodeStack.pop();
              }
            } else {
              var extra = match[4];
              var css = getQuotedMatch(extra, STYLEMATCH);
              var nodeAttrs = css ? { style: css } : {};
              if (tagType === "a") {
                var href = getQuotedMatch(extra, HREFMATCH);
                if (href) {
                  var safeHref = sanitizeHref(href);
                  if (safeHref) {
                    nodeAttrs.href = safeHref;
                    var target = getQuotedMatch(extra, TARGETMATCH);
                    if (target) {
                      nodeAttrs.target = target;
                    }
                  }
                }
              }
              var newNode = document.createElement(tagType);
              currentNode.appendChild(newNode);
              d3.select(newNode).attr(nodeAttrs);
              currentNode = newNode;
              nodeStack.push(newNode);
            }
          } else {
            currentNode.appendChild(
              document.createTextNode(convertEntities(parti))
            );
          }
        }
        var key = "innerHTML";
        return rootNode[key];
      };
      exports.lineCount = function lineCount(s) {
        return s.selectAll("tspan.line").size() || 1;
      };
      exports.positionText = function positionText(s, x, y) {
        return s.each(function() {
          var text = d3.select(this);
          function setOrGet(attr, val) {
            if (val === void 0) {
              val = text.attr(attr);
              if (val === null) {
                text.attr(attr, 0);
                val = 0;
              }
            } else text.attr(attr, val);
            return val;
          }
          var thisX = setOrGet("x", x);
          var thisY = setOrGet("y", y);
          if (this.nodeName === "text") {
            text.selectAll("tspan.line").attr({ x: thisX, y: thisY });
          }
        });
      };
      function alignHTMLWith(_base, container, options) {
        var alignH = options.horizontalAlign;
        var alignV = options.verticalAlign || "top";
        var bRect = _base.node().getBoundingClientRect();
        var cRect = container.node().getBoundingClientRect();
        var thisRect;
        var getTop;
        var getLeft;
        if (alignV === "bottom") {
          getTop = function() {
            return bRect.bottom - thisRect.height;
          };
        } else if (alignV === "middle") {
          getTop = function() {
            return bRect.top + (bRect.height - thisRect.height) / 2;
          };
        } else {
          getTop = function() {
            return bRect.top;
          };
        }
        if (alignH === "right") {
          getLeft = function() {
            return bRect.right - thisRect.width;
          };
        } else if (alignH === "center") {
          getLeft = function() {
            return bRect.left + (bRect.width - thisRect.width) / 2;
          };
        } else {
          getLeft = function() {
            return bRect.left;
          };
        }
        return function() {
          thisRect = this.node().getBoundingClientRect();
          var x0 = getLeft() - cRect.left;
          var y0 = getTop() - cRect.top;
          var gd = options.gd || {};
          if (options.gd) {
            gd._fullLayout._calcInverseTransform(gd);
            var transformedCoords = Lib.apply3DTransform(gd._fullLayout._invTransform)(x0, y0);
            x0 = transformedCoords[0];
            y0 = transformedCoords[1];
          }
          this.style({
            top: y0 + "px",
            left: x0 + "px",
            "z-index": 1e3
          });
          return this;
        };
      }
      var onePx = "1px ";
      exports.makeTextShadow = function(color) {
        var x = onePx;
        var y = onePx;
        var b = onePx;
        return x + y + b + color + ", -" + x + "-" + y + b + color + ", " + x + "-" + y + b + color + ", -" + x + y + b + color;
      };
      exports.makeEditable = function(context, options) {
        var gd = options.gd;
        var _delegate = options.delegate;
        var dispatch = d3.dispatch("edit", "input", "cancel");
        var handlerElement = _delegate || context;
        context.style({ "pointer-events": _delegate ? "none" : "all" });
        if (context.size() !== 1) throw new Error("boo");
        function handleClick() {
          appendEditable();
          context.style({ opacity: 0 });
          var svgClass = handlerElement.attr("class");
          var mathjaxClass;
          if (svgClass) mathjaxClass = "." + svgClass.split(" ")[0] + "-math-group";
          else mathjaxClass = "[class*=-math-group]";
          if (mathjaxClass) {
            d3.select(context.node().parentNode).select(mathjaxClass).style({ opacity: 0 });
          }
        }
        function selectElementContents(_el) {
          var el = _el.node();
          var range = document.createRange();
          range.selectNodeContents(el);
          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
          el.focus();
        }
        function appendEditable() {
          var plotDiv = d3.select(gd);
          var container = plotDiv.select(".svg-container");
          var div = container.append("div");
          var cStyle = context.node().style;
          var fontSize = parseFloat(cStyle.fontSize || 12);
          var initialText = options.text;
          if (initialText === void 0) initialText = context.attr("data-unformatted");
          div.classed("plugin-editable editable", true).style({
            position: "absolute",
            "font-family": cStyle.fontFamily || "Arial",
            "font-size": fontSize,
            color: options.fill || cStyle.fill || "black",
            opacity: 1,
            "background-color": options.background || "transparent",
            outline: "#ffffff33 1px solid",
            margin: [-fontSize / 8 + 1, 0, 0, -1].join("px ") + "px",
            padding: "0",
            "box-sizing": "border-box"
          }).attr({ contenteditable: true }).text(initialText).call(alignHTMLWith(context, container, options)).on("blur", function() {
            gd._editing = false;
            context.text(this.textContent).style({ opacity: 1 });
            var svgClass = d3.select(this).attr("class");
            var mathjaxClass;
            if (svgClass) mathjaxClass = "." + svgClass.split(" ")[0] + "-math-group";
            else mathjaxClass = "[class*=-math-group]";
            if (mathjaxClass) {
              d3.select(context.node().parentNode).select(mathjaxClass).style({ opacity: 0 });
            }
            var text = this.textContent;
            d3.select(this).transition().duration(0).remove();
            d3.select(document).on("mouseup", null);
            dispatch.edit.call(context, text);
          }).on("focus", function() {
            var editDiv = this;
            gd._editing = true;
            d3.select(document).on("mouseup", function() {
              if (d3.event.target === editDiv) return false;
              if (document.activeElement === div.node()) div.node().blur();
            });
          }).on("keyup", function() {
            if (d3.event.which === 27) {
              gd._editing = false;
              context.style({ opacity: 1 });
              d3.select(this).style({ opacity: 0 }).on("blur", function() {
                return false;
              }).transition().remove();
              dispatch.cancel.call(context, this.textContent);
            } else {
              dispatch.input.call(context, this.textContent);
              d3.select(this).call(alignHTMLWith(context, container, options));
            }
          }).on("keydown", function() {
            if (d3.event.which === 13) this.blur();
          }).call(selectElementContents);
        }
        if (options.immediate) handleClick();
        else handlerElement.on("click", handleClick);
        return d3.rebind(context, dispatch, "on");
      };
    }
  });

  // src/components/colorscale/helpers.js
  var require_helpers = __commonJS({
    "src/components/colorscale/helpers.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var tinycolor = require_tinycolor();
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Color = require_color();
      var isValidScale = require_scales().isValid;
      function hasColorscale(trace, containerStr, colorKey) {
        var container = containerStr ? Lib.nestedProperty(trace, containerStr).get() || {} : trace;
        var color = container[colorKey || "color"];
        if (color && color._inputArray) color = color._inputArray;
        var isArrayWithOneNumber = false;
        if (Lib.isArrayOrTypedArray(color)) {
          for (var i = 0; i < color.length; i++) {
            if (isNumeric(color[i])) {
              isArrayWithOneNumber = true;
              break;
            }
          }
        }
        return Lib.isPlainObject(container) && (isArrayWithOneNumber || container.showscale === true || isNumeric(container.cmin) && isNumeric(container.cmax) || isValidScale(container.colorscale) || Lib.isPlainObject(container.colorbar));
      }
      var constantAttrs = ["showscale", "autocolorscale", "colorscale", "reversescale", "colorbar"];
      var letterAttrs = ["min", "max", "mid", "auto"];
      function extractOpts(cont) {
        var colorAx = cont._colorAx;
        var cont2 = colorAx ? colorAx : cont;
        var out = {};
        var cLetter;
        var i, k;
        for (i = 0; i < constantAttrs.length; i++) {
          k = constantAttrs[i];
          out[k] = cont2[k];
        }
        if (colorAx) {
          cLetter = "c";
          for (i = 0; i < letterAttrs.length; i++) {
            k = letterAttrs[i];
            out[k] = cont2["c" + k];
          }
        } else {
          var k2;
          for (i = 0; i < letterAttrs.length; i++) {
            k = letterAttrs[i];
            k2 = "c" + k;
            if (k2 in cont2) {
              out[k] = cont2[k2];
              continue;
            }
            k2 = "z" + k;
            if (k2 in cont2) {
              out[k] = cont2[k2];
            }
          }
          cLetter = k2.charAt(0);
        }
        out._sync = function(k3, v) {
          var k22 = letterAttrs.indexOf(k3) !== -1 ? cLetter + k3 : k3;
          cont2[k22] = cont2["_" + k22] = v;
        };
        return out;
      }
      function extractScale(cont) {
        var cOpts = extractOpts(cont);
        var cmin = cOpts.min;
        var cmax = cOpts.max;
        var scl = cOpts.reversescale ? flipScale(cOpts.colorscale) : cOpts.colorscale;
        var N = scl.length;
        var domain = new Array(N);
        var range = new Array(N);
        for (var i = 0; i < N; i++) {
          var si = scl[i];
          domain[i] = cmin + si[0] * (cmax - cmin);
          range[i] = si[1];
        }
        return { domain, range };
      }
      function flipScale(scl) {
        var N = scl.length;
        var sclNew = new Array(N);
        for (var i = N - 1, j = 0; i >= 0; i--, j++) {
          var si = scl[i];
          sclNew[j] = [1 - si[0], si[1]];
        }
        return sclNew;
      }
      function makeColorScaleFunc(specs, opts) {
        opts = opts || {};
        var domain = specs.domain;
        var range = specs.range;
        var N = range.length;
        var _range = new Array(N);
        for (var i = 0; i < N; i++) {
          var rgba2 = tinycolor(range[i]).toRgb();
          _range[i] = [rgba2.r, rgba2.g, rgba2.b, rgba2.a];
        }
        var _sclFunc = d3.scale.linear().domain(domain).range(_range).clamp(true);
        var noNumericCheck = opts.noNumericCheck;
        var returnArray = opts.returnArray;
        var sclFunc;
        if (noNumericCheck && returnArray) {
          sclFunc = _sclFunc;
        } else if (noNumericCheck) {
          sclFunc = function(v) {
            return colorArray2rbga(_sclFunc(v));
          };
        } else if (returnArray) {
          sclFunc = function(v) {
            if (isNumeric(v)) return _sclFunc(v);
            else if (tinycolor(v).isValid()) return v;
            else return Color.defaultLine;
          };
        } else {
          sclFunc = function(v) {
            if (isNumeric(v)) return colorArray2rbga(_sclFunc(v));
            else if (tinycolor(v).isValid()) return v;
            else return Color.defaultLine;
          };
        }
        sclFunc.domain = _sclFunc.domain;
        sclFunc.range = function() {
          return range;
        };
        return sclFunc;
      }
      function makeColorScaleFuncFromTrace(trace, opts) {
        return makeColorScaleFunc(extractScale(trace), opts);
      }
      function colorArray2rbga(colorArray) {
        var colorObj = {
          r: colorArray[0],
          g: colorArray[1],
          b: colorArray[2],
          a: colorArray[3]
        };
        return tinycolor(colorObj).toRgbString();
      }
      module.exports = {
        hasColorscale,
        extractOpts,
        extractScale,
        flipScale,
        makeColorScaleFunc,
        makeColorScaleFuncFromTrace
      };
    }
  });

  // src/plots/cartesian/axis_format_attributes.js
  var require_axis_format_attributes = __commonJS({
    "src/plots/cartesian/axis_format_attributes.js"(exports, module) {
      "use strict";
      var docs = require_docs();
      var FORMAT_LINK = docs.FORMAT_LINK;
      var DATE_FORMAT_LINK = docs.DATE_FORMAT_LINK;
      function axisHoverFormat(x, noDates) {
        return {
          valType: "string",
          dflt: "",
          editType: "none",
          description: (noDates ? descriptionOnlyNumbers : descriptionWithDates)("hover text", x) + [
            "By default the values are formatted using " + (noDates ? "generic number format" : "`" + x + "axis.hoverformat`") + "."
          ].join(" ")
        };
      }
      function descriptionOnlyNumbers(label, x) {
        return [
          "Sets the " + label + " formatting rule" + (x ? "for `" + x + "` " : ""),
          "using d3 formatting mini-languages",
          "which are very similar to those in Python. For numbers, see: " + FORMAT_LINK + "."
        ].join(" ");
      }
      function descriptionWithDates(label, x) {
        return descriptionOnlyNumbers(label, x) + [
          " And for dates see: " + DATE_FORMAT_LINK + ".",
          "We add two items to d3's date formatter:",
          "*%h* for half of the year as a decimal number as well as",
          "*%{n}f* for fractional seconds",
          "with n digits. For example, *2016-10-13 09:15:23.456* with tickformat",
          "*%H~%M~%S.%2f* would display *09~15~23.46*"
        ].join(" ");
      }
      module.exports = {
        axisHoverFormat,
        descriptionOnlyNumbers,
        descriptionWithDates
      };
    }
  });

  // src/plots/cartesian/layout_attributes.js
  var require_layout_attributes4 = __commonJS({
    "src/plots/cartesian/layout_attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var templatedArray = require_plot_template().templatedArray;
      var descriptionWithDates = require_axis_format_attributes().descriptionWithDates;
      var ONEDAY = require_numerical().ONEDAY;
      var constants = require_constants2();
      var HOUR = constants.HOUR_PATTERN;
      var DAY_OF_WEEK = constants.WEEKDAY_PATTERN;
      var minorTickmode = {
        valType: "enumerated",
        values: ["auto", "linear", "array"],
        editType: "ticks",
        impliedEdits: { tick0: void 0, dtick: void 0 }
      };
      var tickmode = extendFlat({}, minorTickmode, {
        values: minorTickmode.values.slice().concat(["sync"])
      });
      function makeNticks(minor) {
        return {
          valType: "integer",
          min: 0,
          dflt: minor ? 5 : 0,
          editType: "ticks"
        };
      }
      var tick0 = {
        valType: "any",
        editType: "ticks",
        impliedEdits: { tickmode: "linear" }
      };
      var dtick = {
        valType: "any",
        editType: "ticks",
        impliedEdits: { tickmode: "linear" }
      };
      var tickvals = {
        valType: "data_array",
        editType: "ticks"
      };
      var ticks = {
        valType: "enumerated",
        values: ["outside", "inside", ""],
        editType: "ticks"
      };
      function makeTicklen(minor) {
        var obj = {
          valType: "number",
          min: 0,
          editType: "ticks"
        };
        if (!minor) obj.dflt = 5;
        return obj;
      }
      function makeTickwidth(minor) {
        var obj = {
          valType: "number",
          min: 0,
          editType: "ticks"
        };
        if (!minor) obj.dflt = 1;
        return obj;
      }
      var tickcolor = {
        valType: "color",
        dflt: colorAttrs.defaultLine,
        editType: "ticks"
      };
      var gridcolor = {
        valType: "color",
        dflt: colorAttrs.lightLine,
        editType: "ticks"
      };
      function makeGridwidth(minor) {
        var obj = {
          valType: "number",
          min: 0,
          editType: "ticks"
        };
        if (!minor) obj.dflt = 1;
        return obj;
      }
      var griddash = extendFlat({}, dash, { editType: "ticks" });
      var showgrid = {
        valType: "boolean",
        editType: "ticks"
      };
      module.exports = {
        visible: {
          valType: "boolean",
          editType: "plot"
        },
        color: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "ticks"
        },
        title: {
          text: {
            valType: "string",
            editType: "ticks"
          },
          font: fontAttrs({
            editType: "ticks"
          }),
          standoff: {
            valType: "number",
            min: 0,
            editType: "ticks"
          },
          editType: "ticks"
        },
        type: {
          valType: "enumerated",
          // '-' means we haven't yet run autotype or couldn't find any data
          // it gets turned into linear in gd._fullLayout but not copied back
          // to gd.data like the others are.
          values: ["-", "linear", "log", "date", "category", "multicategory"],
          dflt: "-",
          editType: "calc",
          // we forget when an axis has been autotyped, just writing the auto
          // value back to the input - so it doesn't make sense to template this.
          // Note: we do NOT prohibit this in `coerce`, so if someone enters a
          // type in the template explicitly it will be honored as the default.
          _noTemplating: true
        },
        autotypenumbers: {
          valType: "enumerated",
          values: ["convert types", "strict"],
          dflt: "convert types",
          editType: "calc"
        },
        autorange: {
          valType: "enumerated",
          values: [true, false, "reversed", "min reversed", "max reversed", "min", "max"],
          dflt: true,
          editType: "axrange",
          impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
        },
        autorangeoptions: {
          minallowed: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          maxallowed: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          clipmin: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          clipmax: {
            valType: "any",
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          include: {
            valType: "any",
            arrayOk: true,
            editType: "plot",
            impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
          },
          editType: "plot"
        },
        rangemode: {
          valType: "enumerated",
          values: ["normal", "tozero", "nonnegative"],
          dflt: "normal",
          editType: "plot"
        },
        range: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "axrange", impliedEdits: { "^autorange": false }, anim: true },
            { valType: "any", editType: "axrange", impliedEdits: { "^autorange": false }, anim: true }
          ],
          editType: "axrange",
          impliedEdits: { autorange: false },
          anim: true
        },
        minallowed: {
          valType: "any",
          editType: "plot",
          impliedEdits: { "^autorange": false }
        },
        maxallowed: {
          valType: "any",
          editType: "plot",
          impliedEdits: { "^autorange": false }
        },
        fixedrange: {
          valType: "boolean",
          dflt: false,
          editType: "calc"
        },
        insiderange: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "plot" },
            { valType: "any", editType: "plot" }
          ],
          editType: "plot"
        },
        // scaleanchor: not used directly, just put here for reference
        // values are any opposite-letter axis id, or `false`.
        scaleanchor: {
          valType: "enumerated",
          values: [
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString(),
            false
          ],
          editType: "plot"
        },
        scaleratio: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "plot"
        },
        constrain: {
          valType: "enumerated",
          values: ["range", "domain"],
          editType: "plot"
        },
        // constraintoward: not used directly, just put here for reference
        constraintoward: {
          valType: "enumerated",
          values: ["left", "center", "right", "top", "middle", "bottom"],
          editType: "plot"
        },
        matches: {
          valType: "enumerated",
          values: [
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString()
          ],
          editType: "calc"
        },
        rangebreaks: templatedArray("rangebreak", {
          enabled: {
            valType: "boolean",
            dflt: true,
            editType: "calc"
          },
          bounds: {
            valType: "info_array",
            items: [
              { valType: "any", editType: "calc" },
              { valType: "any", editType: "calc" }
            ],
            editType: "calc"
          },
          pattern: {
            valType: "enumerated",
            values: [DAY_OF_WEEK, HOUR, ""],
            editType: "calc"
          },
          values: {
            valType: "info_array",
            freeLength: true,
            editType: "calc",
            items: {
              valType: "any",
              editType: "calc"
            }
          },
          dvalue: {
            // TODO could become 'any' to add support for 'months', 'years'
            valType: "number",
            editType: "calc",
            min: 0,
            dflt: ONEDAY
          },
          /*
          gap: {
              valType: 'number',
              min: 0,
              dflt: 0, // for *date* axes, maybe something else for *linear*
              editType: 'calc',
          },
          gapmode: {
              valType: 'enumerated',
              values: ['pixels', 'fraction'],
              dflt: 'pixels',
              editType: 'calc',
          },
          */
          // To complete https://github.com/plotly/plotly.js/issues/4210
          // we additionally need `gap` and make this work on *linear*, and
          // possibly all other cartesian axis types. We possibly would also need
          // some style attributes controlling the zig-zag on the corresponding
          // axis.
          editType: "calc"
        }),
        // ticks
        tickmode,
        nticks: makeNticks(),
        tick0,
        dtick,
        ticklabelstep: {
          valType: "integer",
          min: 1,
          dflt: 1,
          editType: "ticks"
        },
        tickvals,
        ticktext: {
          valType: "data_array",
          editType: "ticks"
        },
        ticks,
        tickson: {
          valType: "enumerated",
          values: ["labels", "boundaries"],
          dflt: "labels",
          editType: "ticks"
        },
        ticklabelmode: {
          valType: "enumerated",
          values: ["instant", "period"],
          dflt: "instant",
          editType: "ticks"
        },
        // ticklabelposition: not used directly, as values depend on direction (similar to side)
        // left/right options are for x axes, and top/bottom options are for y axes
        ticklabelposition: {
          valType: "enumerated",
          values: [
            "outside",
            "inside",
            "outside top",
            "inside top",
            "outside left",
            "inside left",
            "outside right",
            "inside right",
            "outside bottom",
            "inside bottom"
          ],
          dflt: "outside",
          editType: "calc"
        },
        ticklabeloverflow: {
          valType: "enumerated",
          values: [
            "allow",
            "hide past div",
            "hide past domain"
          ],
          editType: "calc"
        },
        ticklabelshift: {
          valType: "integer",
          dflt: 0,
          editType: "ticks"
        },
        ticklabelstandoff: {
          valType: "integer",
          dflt: 0,
          editType: "ticks"
        },
        ticklabelindex: {
          // in the future maybe add `extras: ['all', 'minor']` to allow showing labels for all ticks
          // or for all minor ticks.
          valType: "integer",
          arrayOk: true,
          editType: "calc"
        },
        mirror: {
          valType: "enumerated",
          values: [true, "ticks", false, "all", "allticks"],
          dflt: false,
          editType: "ticks+layoutstyle"
        },
        ticklen: makeTicklen(),
        tickwidth: makeTickwidth(),
        tickcolor,
        showticklabels: {
          valType: "boolean",
          dflt: true,
          editType: "ticks"
        },
        labelalias: {
          valType: "any",
          dflt: false,
          editType: "ticks"
        },
        automargin: {
          valType: "flaglist",
          flags: ["height", "width", "left", "right", "top", "bottom"],
          extras: [true, false],
          dflt: false,
          editType: "ticks"
        },
        showspikes: {
          valType: "boolean",
          dflt: false,
          editType: "modebar"
        },
        spikecolor: {
          valType: "color",
          dflt: null,
          editType: "none"
        },
        spikethickness: {
          valType: "number",
          dflt: 3,
          editType: "none"
        },
        spikedash: extendFlat({}, dash, { dflt: "dash", editType: "none" }),
        spikemode: {
          valType: "flaglist",
          flags: ["toaxis", "across", "marker"],
          dflt: "toaxis",
          editType: "none"
        },
        spikesnap: {
          valType: "enumerated",
          values: ["data", "cursor", "hovered data"],
          dflt: "hovered data",
          editType: "none"
        },
        tickfont: fontAttrs({
          editType: "ticks"
        }),
        tickangle: {
          valType: "angle",
          dflt: "auto",
          editType: "ticks"
        },
        autotickangles: {
          valType: "info_array",
          freeLength: true,
          items: {
            valType: "angle"
          },
          dflt: [0, 30, 90],
          editType: "ticks"
        },
        tickprefix: {
          valType: "string",
          dflt: "",
          editType: "ticks"
        },
        showtickprefix: {
          valType: "enumerated",
          values: ["all", "first", "last", "none"],
          dflt: "all",
          editType: "ticks"
        },
        ticksuffix: {
          valType: "string",
          dflt: "",
          editType: "ticks"
        },
        showticksuffix: {
          valType: "enumerated",
          values: ["all", "first", "last", "none"],
          dflt: "all",
          editType: "ticks"
        },
        showexponent: {
          valType: "enumerated",
          values: ["all", "first", "last", "none"],
          dflt: "all",
          editType: "ticks"
        },
        exponentformat: {
          valType: "enumerated",
          values: ["none", "e", "E", "power", "SI", "B"],
          dflt: "B",
          editType: "ticks"
        },
        minexponent: {
          valType: "number",
          dflt: 3,
          min: 0,
          editType: "ticks"
        },
        separatethousands: {
          valType: "boolean",
          dflt: false,
          editType: "ticks"
        },
        tickformat: {
          valType: "string",
          dflt: "",
          editType: "ticks",
          description: descriptionWithDates("tick label")
        },
        tickformatstops: templatedArray("tickformatstop", {
          enabled: {
            valType: "boolean",
            dflt: true,
            editType: "ticks"
          },
          dtickrange: {
            valType: "info_array",
            items: [
              { valType: "any", editType: "ticks" },
              { valType: "any", editType: "ticks" }
            ],
            editType: "ticks"
          },
          value: {
            valType: "string",
            dflt: "",
            editType: "ticks"
          },
          editType: "ticks"
        }),
        hoverformat: {
          valType: "string",
          dflt: "",
          editType: "none",
          description: descriptionWithDates("hover text")
        },
        // lines and grids
        showline: {
          valType: "boolean",
          dflt: false,
          editType: "ticks+layoutstyle"
        },
        linecolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "layoutstyle"
        },
        linewidth: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "ticks+layoutstyle"
        },
        showgrid,
        gridcolor,
        gridwidth: makeGridwidth(),
        griddash,
        zeroline: {
          valType: "boolean",
          editType: "ticks"
        },
        zerolinecolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "ticks"
        },
        zerolinewidth: {
          valType: "number",
          dflt: 1,
          editType: "ticks"
        },
        showdividers: {
          valType: "boolean",
          dflt: true,
          editType: "ticks"
        },
        dividercolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "ticks"
        },
        dividerwidth: {
          valType: "number",
          dflt: 1,
          editType: "ticks"
        },
        // TODO dividerlen: that would override "to label base" length?
        // positioning attributes
        // anchor: not used directly, just put here for reference
        // values are any opposite-letter axis id
        anchor: {
          valType: "enumerated",
          values: [
            "free",
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString()
          ],
          editType: "plot"
        },
        // side: not used directly, as values depend on direction
        // values are top, bottom for x axes, and left, right for y
        side: {
          valType: "enumerated",
          values: ["top", "bottom", "left", "right"],
          editType: "plot"
        },
        // overlaying: not used directly, just put here for reference
        // values are false and any other same-letter axis id that's not
        // itself overlaying anything
        overlaying: {
          valType: "enumerated",
          values: [
            "free",
            constants.idRegex.x.toString(),
            constants.idRegex.y.toString()
          ],
          editType: "plot"
        },
        minor: {
          tickmode: minorTickmode,
          nticks: makeNticks("minor"),
          tick0,
          dtick,
          tickvals,
          ticks,
          ticklen: makeTicklen("minor"),
          tickwidth: makeTickwidth("minor"),
          tickcolor,
          gridcolor,
          gridwidth: makeGridwidth("minor"),
          griddash,
          showgrid,
          editType: "ticks"
        },
        layer: {
          valType: "enumerated",
          values: ["above traces", "below traces"],
          dflt: "above traces",
          editType: "plot"
        },
        domain: {
          valType: "info_array",
          items: [
            { valType: "number", min: 0, max: 1, editType: "plot" },
            { valType: "number", min: 0, max: 1, editType: "plot" }
          ],
          dflt: [0, 1],
          editType: "plot"
        },
        position: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0,
          editType: "plot"
        },
        autoshift: {
          valType: "boolean",
          dflt: false,
          editType: "plot"
        },
        shift: {
          valType: "number",
          editType: "plot"
        },
        categoryorder: {
          valType: "enumerated",
          values: [
            "trace",
            "category ascending",
            "category descending",
            "array",
            "total ascending",
            "total descending",
            "min ascending",
            "min descending",
            "max ascending",
            "max descending",
            "sum ascending",
            "sum descending",
            "mean ascending",
            "mean descending",
            "geometric mean ascending",
            "geometric mean descending",
            "median ascending",
            "median descending"
          ],
          dflt: "trace",
          editType: "calc"
        },
        categoryarray: {
          valType: "data_array",
          editType: "calc"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        editType: "calc"
      };
    }
  });

  // src/components/colorbar/attributes.js
  var require_attributes7 = __commonJS({
    "src/components/colorbar/attributes.js"(exports, module) {
      "use strict";
      var axesAttrs = require_layout_attributes4();
      var fontAttrs = require_font_attributes();
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      module.exports = overrideAll({
        orientation: {
          valType: "enumerated",
          values: ["h", "v"],
          dflt: "v"
        },
        thicknessmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "pixels"
        },
        thickness: {
          valType: "number",
          min: 0,
          dflt: 30
        },
        lenmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "fraction"
        },
        len: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        x: {
          valType: "number"
        },
        xref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        xanchor: {
          valType: "enumerated",
          values: ["left", "center", "right"]
        },
        xpad: {
          valType: "number",
          min: 0,
          dflt: 10
        },
        y: {
          valType: "number"
        },
        yref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        yanchor: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"]
        },
        ypad: {
          valType: "number",
          min: 0,
          dflt: 10
        },
        // a possible line around the bar itself
        outlinecolor: axesAttrs.linecolor,
        outlinewidth: axesAttrs.linewidth,
        // Should outlinewidth have {dflt: 0} ?
        // another possible line outside the padding and tick labels
        bordercolor: axesAttrs.linecolor,
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 0
        },
        bgcolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)"
        },
        // tick and title properties named and function exactly as in axes
        tickmode: axesAttrs.minor.tickmode,
        nticks: axesAttrs.nticks,
        tick0: axesAttrs.tick0,
        dtick: axesAttrs.dtick,
        tickvals: axesAttrs.tickvals,
        ticktext: axesAttrs.ticktext,
        ticks: extendFlat({}, axesAttrs.ticks, { dflt: "" }),
        ticklabeloverflow: extendFlat({}, axesAttrs.ticklabeloverflow, {}),
        // ticklabelposition: not used directly, as values depend on orientation
        // left/right options are for x axes, and top/bottom options are for y axes
        ticklabelposition: {
          valType: "enumerated",
          values: [
            "outside",
            "inside",
            "outside top",
            "inside top",
            "outside left",
            "inside left",
            "outside right",
            "inside right",
            "outside bottom",
            "inside bottom"
          ],
          dflt: "outside"
        },
        ticklen: axesAttrs.ticklen,
        tickwidth: axesAttrs.tickwidth,
        tickcolor: axesAttrs.tickcolor,
        ticklabelstep: axesAttrs.ticklabelstep,
        showticklabels: axesAttrs.showticklabels,
        labelalias: axesAttrs.labelalias,
        tickfont: fontAttrs({}),
        tickangle: axesAttrs.tickangle,
        tickformat: axesAttrs.tickformat,
        tickformatstops: axesAttrs.tickformatstops,
        tickprefix: axesAttrs.tickprefix,
        showtickprefix: axesAttrs.showtickprefix,
        ticksuffix: axesAttrs.ticksuffix,
        showticksuffix: axesAttrs.showticksuffix,
        separatethousands: axesAttrs.separatethousands,
        exponentformat: axesAttrs.exponentformat,
        minexponent: axesAttrs.minexponent,
        showexponent: axesAttrs.showexponent,
        title: {
          text: {
            valType: "string"
          },
          font: fontAttrs({}),
          side: {
            valType: "enumerated",
            values: ["right", "top", "bottom"]
          }
        }
      }, "colorbars", "from-root");
    }
  });

  // src/components/colorscale/attributes.js
  var require_attributes8 = __commonJS({
    "src/components/colorscale/attributes.js"(exports, module) {
      "use strict";
      var colorbarAttrs = require_attributes7();
      var counterRegex = require_regex().counter;
      var sortObjectKeys = require_sort_object_keys();
      var palettes = require_scales().scales;
      var paletteStr = sortObjectKeys(palettes);
      function code(s) {
        return "`" + s + "`";
      }
      module.exports = function colorScaleAttrs(context, opts) {
        context = context || "";
        opts = opts || {};
        var cLetter = opts.cLetter || "c";
        var onlyIfNumerical = "onlyIfNumerical" in opts ? opts.onlyIfNumerical : Boolean(context);
        var noScale = "noScale" in opts ? opts.noScale : context === "marker.line";
        var showScaleDflt = "showScaleDflt" in opts ? opts.showScaleDflt : cLetter === "z";
        var colorscaleDflt = typeof opts.colorscaleDflt === "string" ? palettes[opts.colorscaleDflt] : null;
        var editTypeOverride = opts.editTypeOverride || "";
        var contextHead = context ? context + "." : "";
        var colorAttr, colorAttrFull;
        if ("colorAttr" in opts) {
          colorAttr = opts.colorAttr;
          colorAttrFull = opts.colorAttr;
        } else {
          colorAttr = { z: "z", c: "color" }[cLetter];
          colorAttrFull = "in " + code(contextHead + colorAttr);
        }
        var effectDesc = onlyIfNumerical ? " Has an effect only if " + colorAttrFull + " is set to a numerical array." : "";
        var auto = cLetter + "auto";
        var min = cLetter + "min";
        var max = cLetter + "max";
        var mid = cLetter + "mid";
        var autoFull = code(contextHead + auto);
        var minFull = code(contextHead + min);
        var maxFull = code(contextHead + max);
        var minmaxFull = minFull + " and " + maxFull;
        var autoImpliedEdits = {};
        autoImpliedEdits[min] = autoImpliedEdits[max] = void 0;
        var minmaxImpliedEdits = {};
        minmaxImpliedEdits[auto] = false;
        var attrs = {};
        if (colorAttr === "color") {
          attrs.color = {
            valType: "color",
            arrayOk: true,
            editType: editTypeOverride || "style"
          };
          if (opts.anim) {
            attrs.color.anim = true;
          }
        }
        attrs[auto] = {
          valType: "boolean",
          dflt: true,
          editType: "calc",
          impliedEdits: autoImpliedEdits
        };
        attrs[min] = {
          valType: "number",
          dflt: null,
          editType: editTypeOverride || "plot",
          impliedEdits: minmaxImpliedEdits
        };
        attrs[max] = {
          valType: "number",
          dflt: null,
          editType: editTypeOverride || "plot",
          impliedEdits: minmaxImpliedEdits
        };
        attrs[mid] = {
          valType: "number",
          dflt: null,
          editType: "calc",
          impliedEdits: autoImpliedEdits
        };
        attrs.colorscale = {
          valType: "colorscale",
          editType: "calc",
          dflt: colorscaleDflt,
          impliedEdits: { autocolorscale: false }
        };
        attrs.autocolorscale = {
          valType: "boolean",
          // gets overrode in 'heatmap' & 'surface' for backwards comp.
          dflt: opts.autoColorDflt === false ? false : true,
          editType: "calc",
          impliedEdits: { colorscale: void 0 }
        };
        attrs.reversescale = {
          valType: "boolean",
          dflt: false,
          editType: "plot"
        };
        if (!noScale) {
          attrs.showscale = {
            valType: "boolean",
            dflt: showScaleDflt,
            editType: "calc"
          };
          attrs.colorbar = colorbarAttrs;
        }
        if (!opts.noColorAxis) {
          attrs.coloraxis = {
            valType: "subplotid",
            regex: counterRegex("coloraxis"),
            dflt: null,
            editType: "calc"
          };
        }
        return attrs;
      };
    }
  });

  // src/components/colorscale/layout_attributes.js
  var require_layout_attributes5 = __commonJS({
    "src/components/colorscale/layout_attributes.js"(exports, module) {
      "use strict";
      var extendFlat = require_extend().extendFlat;
      var colorScaleAttrs = require_attributes8();
      var scales = require_scales().scales;
      module.exports = {
        editType: "calc",
        colorscale: {
          editType: "calc",
          sequential: {
            valType: "colorscale",
            dflt: scales.Reds,
            editType: "calc"
          },
          sequentialminus: {
            valType: "colorscale",
            dflt: scales.Blues,
            editType: "calc"
          },
          diverging: {
            valType: "colorscale",
            dflt: scales.RdBu,
            editType: "calc"
          }
        },
        coloraxis: extendFlat({
          // not really a 'subplot' attribute container,
          // but this is the flag we use to denote attributes that
          // support yaxis, yaxis2, yaxis3, ... counters
          _isSubplotObj: true,
          editType: "calc"
        }, colorScaleAttrs("", {
          colorAttr: "corresponding trace color array(s)",
          noColorAxis: true,
          showScaleDflt: true
        }))
      };
    }
  });

  // src/components/colorbar/has_colorbar.js
  var require_has_colorbar = __commonJS({
    "src/components/colorbar/has_colorbar.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function hasColorbar(container) {
        return Lib.isPlainObject(container.colorbar);
      };
    }
  });

  // src/plots/cartesian/clean_ticks.js
  var require_clean_ticks = __commonJS({
    "src/plots/cartesian/clean_ticks.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var constants = require_numerical();
      var ONEDAY = constants.ONEDAY;
      var ONEWEEK = constants.ONEWEEK;
      exports.dtick = function(dtick, axType) {
        var isLog = axType === "log";
        var isDate = axType === "date";
        var isCat = axType === "category";
        var dtickDflt = isDate ? ONEDAY : 1;
        if (!dtick) return dtickDflt;
        if (isNumeric(dtick)) {
          dtick = Number(dtick);
          if (dtick <= 0) return dtickDflt;
          if (isCat) {
            return Math.max(1, Math.round(dtick));
          }
          if (isDate) {
            return Math.max(0.1, dtick);
          }
          return dtick;
        }
        if (typeof dtick !== "string" || !(isDate || isLog)) {
          return dtickDflt;
        }
        var prefix = dtick.charAt(0);
        var dtickNum = dtick.substr(1);
        dtickNum = isNumeric(dtickNum) ? Number(dtickNum) : 0;
        if (dtickNum <= 0 || !// "M<n>" gives ticks every (integer) n months
        (isDate && prefix === "M" && dtickNum === Math.round(dtickNum) || // "L<f>" gives ticks linearly spaced in data (not in position) every (float) f
        isLog && prefix === "L" || // "D1" gives powers of 10 with all small digits between, "D2" gives only 2 and 5
        isLog && prefix === "D" && (dtickNum === 1 || dtickNum === 2))) {
          return dtickDflt;
        }
        return dtick;
      };
      exports.tick0 = function(tick0, axType, calendar, dtick) {
        if (axType === "date") {
          return Lib.cleanDate(
            tick0,
            Lib.dateTick0(calendar, dtick % ONEWEEK === 0 ? 1 : 0)
          );
        }
        if (dtick === "D1" || dtick === "D2") {
          return void 0;
        }
        return isNumeric(tick0) ? Number(tick0) : 0;
      };
    }
  });

  // src/plots/cartesian/tick_value_defaults.js
  var require_tick_value_defaults = __commonJS({
    "src/plots/cartesian/tick_value_defaults.js"(exports, module) {
      "use strict";
      var cleanTicks = require_clean_ticks();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var isTypedArraySpec = require_array().isTypedArraySpec;
      var decodeTypedArraySpec = require_array().decodeTypedArraySpec;
      module.exports = function handleTickValueDefaults(containerIn, containerOut, coerce, axType, opts) {
        if (!opts) opts = {};
        var isMinor = opts.isMinor;
        var cIn = isMinor ? containerIn.minor || {} : containerIn;
        var cOut = isMinor ? containerOut.minor : containerOut;
        var prefix = isMinor ? "minor." : "";
        function readInput(attr) {
          var v = cIn[attr];
          if (isTypedArraySpec(v)) v = decodeTypedArraySpec(v);
          return v !== void 0 ? v : (cOut._template || {})[attr];
        }
        var _tick0 = readInput("tick0");
        var _dtick = readInput("dtick");
        var _tickvals = readInput("tickvals");
        var tickmodeDefault = isArrayOrTypedArray(_tickvals) ? "array" : _dtick ? "linear" : "auto";
        var tickmode = coerce(prefix + "tickmode", tickmodeDefault);
        if (tickmode === "auto" || tickmode === "sync") {
          coerce(prefix + "nticks");
        } else if (tickmode === "linear") {
          var dtick = cOut.dtick = cleanTicks.dtick(
            _dtick,
            axType
          );
          cOut.tick0 = cleanTicks.tick0(
            _tick0,
            axType,
            containerOut.calendar,
            dtick
          );
        } else if (axType !== "multicategory") {
          var tickvals = coerce(prefix + "tickvals");
          if (tickvals === void 0) cOut.tickmode = "auto";
          else if (!isMinor) coerce("ticktext");
        }
      };
    }
  });

  // src/plots/cartesian/tick_mark_defaults.js
  var require_tick_mark_defaults = __commonJS({
    "src/plots/cartesian/tick_mark_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes4();
      module.exports = function handleTickMarkDefaults(containerIn, containerOut, coerce, options) {
        var isMinor = options.isMinor;
        var cIn = isMinor ? containerIn.minor || {} : containerIn;
        var cOut = isMinor ? containerOut.minor : containerOut;
        var lAttr = isMinor ? layoutAttributes.minor : layoutAttributes;
        var prefix = isMinor ? "minor." : "";
        var tickLen = Lib.coerce2(cIn, cOut, lAttr, "ticklen", isMinor ? (containerOut.ticklen || 5) * 0.6 : void 0);
        var tickWidth = Lib.coerce2(cIn, cOut, lAttr, "tickwidth", isMinor ? containerOut.tickwidth || 1 : void 0);
        var tickColor = Lib.coerce2(cIn, cOut, lAttr, "tickcolor", (isMinor ? containerOut.tickcolor : void 0) || cOut.color);
        var showTicks = coerce(prefix + "ticks", !isMinor && options.outerTicks || tickLen || tickWidth || tickColor ? "outside" : "");
        if (!showTicks) {
          delete cOut.ticklen;
          delete cOut.tickwidth;
          delete cOut.tickcolor;
        }
      };
    }
  });

  // src/plots/cartesian/show_dflt.js
  var require_show_dflt = __commonJS({
    "src/plots/cartesian/show_dflt.js"(exports, module) {
      "use strict";
      module.exports = function getShowAttrDflt(containerIn) {
        var showAttrsAll = ["showexponent", "showtickprefix", "showticksuffix"];
        var showAttrs = showAttrsAll.filter(function(a) {
          return containerIn[a] !== void 0;
        });
        var sameVal = function(a) {
          return containerIn[a] === containerIn[showAttrs[0]];
        };
        if (showAttrs.every(sameVal) || showAttrs.length === 1) {
          return containerIn[showAttrs[0]];
        }
      };
    }
  });

  // src/plots/array_container_defaults.js
  var require_array_container_defaults = __commonJS({
    "src/plots/array_container_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      module.exports = function handleArrayContainerDefaults(parentObjIn, parentObjOut, opts) {
        var name = opts.name;
        var inclusionAttr = opts.inclusionAttr || "visible";
        var previousContOut = parentObjOut[name];
        var contIn = Lib.isArrayOrTypedArray(parentObjIn[name]) ? parentObjIn[name] : [];
        var contOut = parentObjOut[name] = [];
        var templater = Template.arrayTemplater(parentObjOut, name, inclusionAttr);
        var i, itemOut;
        for (i = 0; i < contIn.length; i++) {
          var itemIn = contIn[i];
          if (!Lib.isPlainObject(itemIn)) {
            itemOut = templater.newItem({});
            itemOut[inclusionAttr] = false;
          } else {
            itemOut = templater.newItem(itemIn);
          }
          itemOut._index = i;
          if (itemOut[inclusionAttr] !== false) {
            opts.handleItemDefaults(itemIn, itemOut, parentObjOut, opts);
          }
          contOut.push(itemOut);
        }
        var defaultItems = templater.defaultItems();
        for (i = 0; i < defaultItems.length; i++) {
          itemOut = defaultItems[i];
          itemOut._index = contOut.length;
          opts.handleItemDefaults({}, itemOut, parentObjOut, opts, {});
          contOut.push(itemOut);
        }
        if (Lib.isArrayOrTypedArray(previousContOut)) {
          var len = Math.min(previousContOut.length, contOut.length);
          for (i = 0; i < len; i++) {
            Lib.relinkPrivateKeys(contOut[i], previousContOut[i]);
          }
        }
        return contOut;
      };
    }
  });

  // src/plots/cartesian/tick_label_defaults.js
  var require_tick_label_defaults = __commonJS({
    "src/plots/cartesian/tick_label_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var contrast = require_color().contrast;
      var layoutAttributes = require_layout_attributes4();
      var getShowAttrDflt = require_show_dflt();
      var handleArrayContainerDefaults = require_array_container_defaults();
      module.exports = function handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options) {
        if (!options) options = {};
        var labelalias = coerce("labelalias");
        if (!Lib.isPlainObject(labelalias)) delete containerOut.labelalias;
        var showAttrDflt = getShowAttrDflt(containerIn);
        var showTickLabels = coerce("showticklabels");
        if (showTickLabels) {
          if (!options.noTicklabelshift) {
            coerce("ticklabelshift");
          }
          if (!options.noTicklabelstandoff) {
            coerce("ticklabelstandoff");
          }
          var font = options.font || {};
          var contColor = containerOut.color;
          var position = containerOut.ticklabelposition || "";
          var dfltFontColor = position.indexOf("inside") !== -1 ? contrast(options.bgColor) : (
            // as with title.font.color, inherit axis.color only if one was
            // explicitly provided
            contColor && contColor !== layoutAttributes.color.dflt ? contColor : font.color
          );
          Lib.coerceFont(coerce, "tickfont", font, { overrideDflt: {
            color: dfltFontColor
          } });
          if (!options.noTicklabelstep && axType !== "multicategory" && axType !== "log") {
            coerce("ticklabelstep");
          }
          if (!options.noAng) {
            var tickAngle = coerce("tickangle");
            if (!options.noAutotickangles && tickAngle === "auto") {
              coerce("autotickangles");
            }
          }
          if (axType !== "category") {
            var tickFormat = coerce("tickformat");
            handleArrayContainerDefaults(containerIn, containerOut, {
              name: "tickformatstops",
              inclusionAttr: "enabled",
              handleItemDefaults: tickformatstopDefaults
            });
            if (!containerOut.tickformatstops.length) {
              delete containerOut.tickformatstops;
            }
            if (!options.noExp && !tickFormat && axType !== "date") {
              coerce("showexponent", showAttrDflt);
              coerce("exponentformat");
              coerce("minexponent");
              coerce("separatethousands");
            }
          }
        }
      };
      function tickformatstopDefaults(valueIn, valueOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(valueIn, valueOut, layoutAttributes.tickformatstops, attr, dflt);
        }
        var enabled = coerce("enabled");
        if (enabled) {
          coerce("dtickrange");
          coerce("value");
        }
      }
    }
  });

  // src/plots/cartesian/prefix_suffix_defaults.js
  var require_prefix_suffix_defaults = __commonJS({
    "src/plots/cartesian/prefix_suffix_defaults.js"(exports, module) {
      "use strict";
      var getShowAttrDflt = require_show_dflt();
      module.exports = function handlePrefixSuffixDefaults(containerIn, containerOut, coerce, axType, options) {
        if (!options) options = {};
        var tickSuffixDflt = options.tickSuffixDflt;
        var showAttrDflt = getShowAttrDflt(containerIn);
        var tickPrefix = coerce("tickprefix");
        if (tickPrefix) coerce("showtickprefix", showAttrDflt);
        var tickSuffix = coerce("ticksuffix", tickSuffixDflt);
        if (tickSuffix) coerce("showticksuffix", showAttrDflt);
      };
    }
  });

  // src/components/colorbar/defaults.js
  var require_defaults = __commonJS({
    "src/components/colorbar/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var handleTickValueDefaults = require_tick_value_defaults();
      var handleTickMarkDefaults = require_tick_mark_defaults();
      var handleTickLabelDefaults = require_tick_label_defaults();
      var handlePrefixSuffixDefaults = require_prefix_suffix_defaults();
      var attributes = require_attributes7();
      module.exports = function colorbarDefaults(containerIn, containerOut, layout) {
        var colorbarOut = Template.newContainer(containerOut, "colorbar");
        var colorbarIn = containerIn.colorbar || {};
        function coerce(attr, dflt) {
          return Lib.coerce(colorbarIn, colorbarOut, attributes, attr, dflt);
        }
        var margin = layout.margin || { t: 0, b: 0, l: 0, r: 0 };
        var w = layout.width - margin.l - margin.r;
        var h = layout.height - margin.t - margin.b;
        var orientation = coerce("orientation");
        var isVertical = orientation === "v";
        var thicknessmode = coerce("thicknessmode");
        coerce(
          "thickness",
          thicknessmode === "fraction" ? 30 / (isVertical ? w : h) : 30
        );
        var lenmode = coerce("lenmode");
        coerce(
          "len",
          lenmode === "fraction" ? 1 : isVertical ? h : w
        );
        var yref = coerce("yref");
        var xref = coerce("xref");
        var isPaperY = yref === "paper";
        var isPaperX = xref === "paper";
        var defaultX, defaultY, defaultYAnchor;
        var defaultXAnchor = "left";
        if (isVertical) {
          defaultYAnchor = "middle";
          defaultXAnchor = isPaperX ? "left" : "right";
          defaultX = isPaperX ? 1.02 : 1;
          defaultY = 0.5;
        } else {
          defaultYAnchor = isPaperY ? "bottom" : "top";
          defaultXAnchor = "center";
          defaultX = 0.5;
          defaultY = isPaperY ? 1.02 : 1;
        }
        Lib.coerce(colorbarIn, colorbarOut, {
          x: {
            valType: "number",
            min: isPaperX ? -2 : 0,
            max: isPaperX ? 3 : 1,
            dflt: defaultX
          }
        }, "x");
        Lib.coerce(colorbarIn, colorbarOut, {
          y: {
            valType: "number",
            min: isPaperY ? -2 : 0,
            max: isPaperY ? 3 : 1,
            dflt: defaultY
          }
        }, "y");
        coerce("xanchor", defaultXAnchor);
        coerce("xpad");
        coerce("yanchor", defaultYAnchor);
        coerce("ypad");
        Lib.noneOrAll(colorbarIn, colorbarOut, ["x", "y"]);
        coerce("outlinecolor");
        coerce("outlinewidth");
        coerce("bordercolor");
        coerce("borderwidth");
        coerce("bgcolor");
        var ticklabelposition = Lib.coerce(colorbarIn, colorbarOut, {
          ticklabelposition: {
            valType: "enumerated",
            dflt: "outside",
            values: isVertical ? [
              "outside",
              "inside",
              "outside top",
              "inside top",
              "outside bottom",
              "inside bottom"
            ] : [
              "outside",
              "inside",
              "outside left",
              "inside left",
              "outside right",
              "inside right"
            ]
          }
        }, "ticklabelposition");
        coerce("ticklabeloverflow", ticklabelposition.indexOf("inside") !== -1 ? "hide past domain" : "hide past div");
        handleTickValueDefaults(colorbarIn, colorbarOut, coerce, "linear");
        var font = layout.font;
        var opts = {
          noAutotickangles: true,
          noTicklabelshift: true,
          noTicklabelstandoff: true,
          outerTicks: false,
          font
        };
        if (ticklabelposition.indexOf("inside") !== -1) {
          opts.bgColor = "black";
        }
        handlePrefixSuffixDefaults(colorbarIn, colorbarOut, coerce, "linear", opts);
        handleTickLabelDefaults(colorbarIn, colorbarOut, coerce, "linear", opts);
        handleTickMarkDefaults(colorbarIn, colorbarOut, coerce, "linear", opts);
        coerce("title.text", layout._dfltTitle.colorbar);
        var tickFont = colorbarOut.showticklabels ? colorbarOut.tickfont : font;
        var dfltTitleFont = Lib.extendFlat({}, font, {
          family: tickFont.family,
          size: Lib.bigFont(tickFont.size)
        });
        Lib.coerceFont(coerce, "title.font", dfltTitleFont);
        coerce("title.side", isVertical ? "top" : "right");
      };
    }
  });

  // src/components/colorscale/defaults.js
  var require_defaults2 = __commonJS({
    "src/components/colorscale/defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var hasColorbar = require_has_colorbar();
      var colorbarDefaults = require_defaults();
      var isValidScale = require_scales().isValid;
      var traceIs = require_registry().traceIs;
      function npMaybe(parentCont, prefix) {
        var containerStr = prefix.slice(0, prefix.length - 1);
        return prefix ? Lib.nestedProperty(parentCont, containerStr).get() || {} : parentCont;
      }
      module.exports = function colorScaleDefaults(parentContIn, parentContOut, layout, coerce, opts) {
        var prefix = opts.prefix;
        var cLetter = opts.cLetter;
        var inTrace = "_module" in parentContOut;
        var containerIn = npMaybe(parentContIn, prefix);
        var containerOut = npMaybe(parentContOut, prefix);
        var template = npMaybe(parentContOut._template || {}, prefix) || {};
        var thisFn = function() {
          delete parentContIn.coloraxis;
          delete parentContOut.coloraxis;
          return colorScaleDefaults(parentContIn, parentContOut, layout, coerce, opts);
        };
        if (inTrace) {
          var colorAxes = layout._colorAxes || {};
          var colorAx = coerce(prefix + "coloraxis");
          if (colorAx) {
            var colorbarVisuals = traceIs(parentContOut, "contour") && Lib.nestedProperty(parentContOut, "contours.coloring").get() || "heatmap";
            var stash = colorAxes[colorAx];
            if (stash) {
              stash[2].push(thisFn);
              if (stash[0] !== colorbarVisuals) {
                stash[0] = false;
                Lib.warn([
                  "Ignoring coloraxis:",
                  colorAx,
                  "setting",
                  "as it is linked to incompatible colorscales."
                ].join(" "));
              }
            } else {
              colorAxes[colorAx] = [colorbarVisuals, parentContOut, [thisFn]];
            }
            return;
          }
        }
        var minIn = containerIn[cLetter + "min"];
        var maxIn = containerIn[cLetter + "max"];
        var validMinMax = isNumeric(minIn) && isNumeric(maxIn) && minIn < maxIn;
        var auto = coerce(prefix + cLetter + "auto", !validMinMax);
        if (auto) {
          coerce(prefix + cLetter + "mid");
        } else {
          coerce(prefix + cLetter + "min");
          coerce(prefix + cLetter + "max");
        }
        var sclIn = containerIn.colorscale;
        var sclTemplate = template.colorscale;
        var autoColorscaleDflt;
        if (sclIn !== void 0) autoColorscaleDflt = !isValidScale(sclIn);
        if (sclTemplate !== void 0) autoColorscaleDflt = !isValidScale(sclTemplate);
        coerce(prefix + "autocolorscale", autoColorscaleDflt);
        coerce(prefix + "colorscale");
        coerce(prefix + "reversescale");
        if (prefix !== "marker.line.") {
          var showScaleDflt;
          if (prefix && inTrace) showScaleDflt = hasColorbar(containerIn);
          var showScale = coerce(prefix + "showscale", showScaleDflt);
          if (showScale) {
            if (prefix && template) containerOut._template = template;
            colorbarDefaults(containerIn, containerOut, layout);
          }
        }
      };
    }
  });

  // src/components/colorscale/layout_defaults.js
  var require_layout_defaults = __commonJS({
    "src/components/colorscale/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var colorScaleAttrs = require_layout_attributes5();
      var colorScaleDefaults = require_defaults2();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, colorScaleAttrs, attr, dflt);
        }
        coerce("colorscale.sequential");
        coerce("colorscale.sequentialminus");
        coerce("colorscale.diverging");
        var colorAxes = layoutOut._colorAxes;
        var colorAxIn, colorAxOut;
        function coerceAx(attr, dflt) {
          return Lib.coerce(colorAxIn, colorAxOut, colorScaleAttrs.coloraxis, attr, dflt);
        }
        for (var k in colorAxes) {
          var stash = colorAxes[k];
          if (stash[0]) {
            colorAxIn = layoutIn[k] || {};
            colorAxOut = Template.newContainer(layoutOut, k, "coloraxis");
            colorAxOut._name = k;
            colorScaleDefaults(colorAxIn, colorAxOut, layoutOut, coerceAx, { prefix: "", cLetter: "c" });
          } else {
            for (var i = 0; i < stash[2].length; i++) {
              stash[2][i]();
            }
            delete layoutOut._colorAxes[k];
          }
        }
      };
    }
  });

  // src/components/colorscale/cross_trace_defaults.js
  var require_cross_trace_defaults = __commonJS({
    "src/components/colorscale/cross_trace_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var hasColorscale = require_helpers().hasColorscale;
      var extractOpts = require_helpers().extractOpts;
      module.exports = function crossTraceDefaults(fullData, fullLayout) {
        function replace(cont, k2) {
          var val = cont["_" + k2];
          if (val !== void 0) {
            cont[k2] = val;
          }
        }
        function relinkColorAttrs(outerCont, cbOpt) {
          var cont = cbOpt.container ? Lib.nestedProperty(outerCont, cbOpt.container).get() : outerCont;
          if (cont) {
            if (cont.coloraxis) {
              cont._colorAx = fullLayout[cont.coloraxis];
            } else {
              var cOpts = extractOpts(cont);
              var isAuto = cOpts.auto;
              if (isAuto || cOpts.min === void 0) {
                replace(cont, cbOpt.min);
              }
              if (isAuto || cOpts.max === void 0) {
                replace(cont, cbOpt.max);
              }
              if (cOpts.autocolorscale) {
                replace(cont, "colorscale");
              }
            }
          }
        }
        for (var i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          var cbOpts = trace._module.colorbar;
          if (cbOpts) {
            if (Array.isArray(cbOpts)) {
              for (var j = 0; j < cbOpts.length; j++) {
                relinkColorAttrs(trace, cbOpts[j]);
              }
            } else {
              relinkColorAttrs(trace, cbOpts);
            }
          }
          if (hasColorscale(trace, "marker.line")) {
            relinkColorAttrs(trace, {
              container: "marker.line",
              min: "cmin",
              max: "cmax"
            });
          }
        }
        for (var k in fullLayout._colorAxes) {
          relinkColorAttrs(fullLayout[k], { min: "cmin", max: "cmax" });
        }
      };
    }
  });

  // src/components/colorscale/calc.js
  var require_calc = __commonJS({
    "src/components/colorscale/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var extractOpts = require_helpers().extractOpts;
      module.exports = function calc(gd, trace, opts) {
        var fullLayout = gd._fullLayout;
        var vals = opts.vals;
        var containerStr = opts.containerStr;
        var container = containerStr ? Lib.nestedProperty(trace, containerStr).get() : trace;
        var cOpts = extractOpts(container);
        var auto = cOpts.auto !== false;
        var min = cOpts.min;
        var max = cOpts.max;
        var mid = cOpts.mid;
        var minVal = function() {
          return Lib.aggNums(Math.min, null, vals);
        };
        var maxVal = function() {
          return Lib.aggNums(Math.max, null, vals);
        };
        if (min === void 0) {
          min = minVal();
        } else if (auto) {
          if (container._colorAx && isNumeric(min)) {
            min = Math.min(min, minVal());
          } else {
            min = minVal();
          }
        }
        if (max === void 0) {
          max = maxVal();
        } else if (auto) {
          if (container._colorAx && isNumeric(max)) {
            max = Math.max(max, maxVal());
          } else {
            max = maxVal();
          }
        }
        if (auto && mid !== void 0) {
          if (max - mid > mid - min) {
            min = mid - (max - mid);
          } else if (max - mid < mid - min) {
            max = mid + (mid - min);
          }
        }
        if (min === max) {
          min -= 0.5;
          max += 0.5;
        }
        cOpts._sync("min", min);
        cOpts._sync("max", max);
        if (cOpts.autocolorscale) {
          var scl;
          if (min * max < 0) scl = fullLayout.colorscale.diverging;
          else if (min >= 0) scl = fullLayout.colorscale.sequential;
          else scl = fullLayout.colorscale.sequentialminus;
          cOpts._sync("colorscale", scl);
        }
      };
    }
  });

  // src/components/colorscale/index.js
  var require_colorscale = __commonJS({
    "src/components/colorscale/index.js"(exports, module) {
      "use strict";
      var scales = require_scales();
      var helpers = require_helpers();
      module.exports = {
        moduleType: "component",
        name: "colorscale",
        attributes: require_attributes8(),
        layoutAttributes: require_layout_attributes5(),
        supplyLayoutDefaults: require_layout_defaults(),
        handleDefaults: require_defaults2(),
        crossTraceDefaults: require_cross_trace_defaults(),
        calc: require_calc(),
        // ./scales.js is required in lib/coerce.js ;
        // it needs to be a separate module to avoid a circular dependency
        scales: scales.scales,
        defaultScale: scales.defaultScale,
        getScale: scales.get,
        isValidScale: scales.isValid,
        hasColorscale: helpers.hasColorscale,
        extractOpts: helpers.extractOpts,
        extractScale: helpers.extractScale,
        flipScale: helpers.flipScale,
        makeColorScaleFunc: helpers.makeColorScaleFunc,
        makeColorScaleFuncFromTrace: helpers.makeColorScaleFuncFromTrace
      };
    }
  });

  // src/traces/scatter/subtypes.js
  var require_subtypes = __commonJS({
    "src/traces/scatter/subtypes.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var isTypedArraySpec = require_array().isTypedArraySpec;
      module.exports = {
        hasLines: function(trace) {
          return trace.visible && trace.mode && trace.mode.indexOf("lines") !== -1;
        },
        hasMarkers: function(trace) {
          return trace.visible && (trace.mode && trace.mode.indexOf("markers") !== -1 || // until splom implements 'mode'
          trace.type === "splom");
        },
        hasText: function(trace) {
          return trace.visible && trace.mode && trace.mode.indexOf("text") !== -1;
        },
        isBubble: function(trace) {
          var marker = trace.marker;
          return Lib.isPlainObject(marker) && (Lib.isArrayOrTypedArray(marker.size) || isTypedArraySpec(marker.size));
        }
      };
    }
  });

  // src/traces/scatter/make_bubble_size_func.js
  var require_make_bubble_size_func = __commonJS({
    "src/traces/scatter/make_bubble_size_func.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      module.exports = function makeBubbleSizeFn(trace, factor) {
        if (!factor) {
          factor = 2;
        }
        var marker = trace.marker;
        var sizeRef = marker.sizeref || 1;
        var sizeMin = marker.sizemin || 0;
        var baseFn = marker.sizemode === "area" ? function(v) {
          return Math.sqrt(v / sizeRef);
        } : function(v) {
          return v / sizeRef;
        };
        return function(v) {
          var baseSize = baseFn(v / factor);
          return isNumeric(baseSize) && baseSize > 0 ? Math.max(baseSize, sizeMin) : 0;
        };
      };
    }
  });

  // src/components/fx/helpers.js
  var require_helpers2 = __commonJS({
    "src/components/fx/helpers.js"(exports) {
      "use strict";
      var Lib = require_lib();
      exports.getSubplot = function(trace) {
        return trace.subplot || trace.xaxis + trace.yaxis || trace.geo;
      };
      exports.isTraceInSubplots = function(trace, subplots) {
        if (trace.type === "splom") {
          var xaxes = trace.xaxes || [];
          var yaxes = trace.yaxes || [];
          for (var i = 0; i < xaxes.length; i++) {
            for (var j = 0; j < yaxes.length; j++) {
              if (subplots.indexOf(xaxes[i] + yaxes[j]) !== -1) {
                return true;
              }
            }
          }
          return false;
        }
        return subplots.indexOf(exports.getSubplot(trace)) !== -1;
      };
      exports.flat = function(subplots, v) {
        var out = new Array(subplots.length);
        for (var i = 0; i < subplots.length; i++) {
          out[i] = v;
        }
        return out;
      };
      exports.p2c = function(axArray, v) {
        var out = new Array(axArray.length);
        for (var i = 0; i < axArray.length; i++) {
          out[i] = axArray[i].p2c(v);
        }
        return out;
      };
      exports.getDistanceFunction = function(mode, dx, dy, dxy) {
        if (mode === "closest") return dxy || exports.quadrature(dx, dy);
        return mode.charAt(0) === "x" ? dx : dy;
      };
      exports.getClosest = function(cd, distfn, pointData) {
        if (pointData.index !== false) {
          if (pointData.index >= 0 && pointData.index < cd.length) {
            pointData.distance = 0;
          } else pointData.index = false;
        } else {
          var newDistance = Infinity;
          var len = cd.length;
          for (var i = 0; i < len; i++) {
            newDistance = distfn(cd[i]);
            if (newDistance <= pointData.distance) {
              pointData.index = i;
              pointData.distance = newDistance;
            }
          }
        }
        return pointData;
      };
      exports.inbox = function(v0, v1, passVal) {
        return v0 * v1 < 0 || v0 === 0 ? passVal : Infinity;
      };
      exports.quadrature = function(dx, dy) {
        return function(di) {
          var x = dx(di);
          var y = dy(di);
          return Math.sqrt(x * x + y * y);
        };
      };
      exports.makeEventData = function(pt, trace, cd) {
        var pointNumber = "index" in pt ? pt.index : pt.pointNumber;
        var out = {
          data: trace._input,
          fullData: trace,
          curveNumber: trace.index,
          pointNumber
        };
        if (trace._indexToPoints) {
          var pointIndices = trace._indexToPoints[pointNumber];
          if (pointIndices.length === 1) {
            out.pointIndex = pointIndices[0];
          } else {
            out.pointIndices = pointIndices;
          }
        } else {
          out.pointIndex = pointNumber;
        }
        if (trace._module.eventData) {
          out = trace._module.eventData(out, pt, trace, cd, pointNumber);
        } else {
          if ("xVal" in pt) out.x = pt.xVal;
          else if ("x" in pt) out.x = pt.x;
          if ("yVal" in pt) out.y = pt.yVal;
          else if ("y" in pt) out.y = pt.y;
          if (pt.xa) out.xaxis = pt.xa;
          if (pt.ya) out.yaxis = pt.ya;
          if (pt.zLabelVal !== void 0) out.z = pt.zLabelVal;
        }
        exports.appendArrayPointValue(out, trace, pointNumber);
        return out;
      };
      exports.appendArrayPointValue = function(pointData, trace, pointNumber) {
        var arrayAttrs = trace._arrayAttrs;
        if (!arrayAttrs) {
          return;
        }
        for (var i = 0; i < arrayAttrs.length; i++) {
          var astr = arrayAttrs[i];
          var key = getPointKey(astr);
          if (pointData[key] === void 0) {
            var val = Lib.nestedProperty(trace, astr).get();
            var pointVal = getPointData(val, pointNumber);
            if (pointVal !== void 0) pointData[key] = pointVal;
          }
        }
      };
      exports.appendArrayMultiPointValues = function(pointData, trace, pointNumbers) {
        var arrayAttrs = trace._arrayAttrs;
        if (!arrayAttrs) {
          return;
        }
        for (var i = 0; i < arrayAttrs.length; i++) {
          var astr = arrayAttrs[i];
          var key = getPointKey(astr);
          if (pointData[key] === void 0) {
            var val = Lib.nestedProperty(trace, astr).get();
            var keyVal = new Array(pointNumbers.length);
            for (var j = 0; j < pointNumbers.length; j++) {
              keyVal[j] = getPointData(val, pointNumbers[j]);
            }
            pointData[key] = keyVal;
          }
        }
      };
      var pointKeyMap = {
        ids: "id",
        locations: "location",
        labels: "label",
        values: "value",
        "marker.colors": "color",
        parents: "parent"
      };
      function getPointKey(astr) {
        return pointKeyMap[astr] || astr;
      }
      function getPointData(val, pointNumber) {
        if (Array.isArray(pointNumber)) {
          if (Array.isArray(val) && Array.isArray(val[pointNumber[0]])) {
            return val[pointNumber[0]][pointNumber[1]];
          }
        } else {
          return val[pointNumber];
        }
      }
      var xyHoverMode = {
        x: true,
        y: true
      };
      var unifiedHoverMode = {
        "x unified": true,
        "y unified": true
      };
      exports.isUnifiedHover = function(hovermode) {
        if (typeof hovermode !== "string") return false;
        return !!unifiedHoverMode[hovermode];
      };
      exports.isXYhover = function(hovermode) {
        if (typeof hovermode !== "string") return false;
        return !!xyHoverMode[hovermode];
      };
    }
  });

  // node_modules/parse-svg-path/index.js
  var require_parse_svg_path = __commonJS({
    "node_modules/parse-svg-path/index.js"(exports, module) {
      module.exports = parse2;
      var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      function parse2(path) {
        var data = [];
        path.replace(segment, function(_, command, args) {
          var type = command.toLowerCase();
          args = parseValues(args);
          if (type == "m" && args.length > 2) {
            data.push([command].concat(args.splice(0, 2)));
            type = "l";
            command = command == "m" ? "l" : "L";
          }
          while (true) {
            if (args.length == length[type]) {
              args.unshift(command);
              return data.push(args);
            }
            if (args.length < length[type]) throw new Error("malformed path data");
            data.push([command].concat(args.splice(0, length[type])));
          }
        });
        return data;
      }
      var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
      function parseValues(args) {
        var numbers = args.match(number);
        return numbers ? numbers.map(Number) : [];
      }
    }
  });

  // src/components/drawing/symbol_defs.js
  var require_symbol_defs = __commonJS({
    "src/components/drawing/symbol_defs.js"(exports, module) {
      "use strict";
      var parseSvgPath = require_parse_svg_path();
      var round = (
        // require('@plotly/d3').round;
        function(x, n) {
          return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
        }
      );
      var emptyPath = "M0,0Z";
      var sqrt2 = Math.sqrt(2);
      var sqrt3 = Math.sqrt(3);
      var PI = Math.PI;
      var cos = Math.cos;
      var sin = Math.sin;
      module.exports = {
        circle: {
          n: 0,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            var circle = "M" + rs + ",0A" + rs + "," + rs + " 0 1,1 0,-" + rs + "A" + rs + "," + rs + " 0 0,1 " + rs + ",0Z";
            return standoff ? align(angle, standoff, circle) : circle;
          }
        },
        square: {
          n: 1,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "H-" + rs + "V-" + rs + "H" + rs + "Z");
          }
        },
        diamond: {
          n: 2,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rd = round(r * 1.3, 2);
            return align(angle, standoff, "M" + rd + ",0L0," + rd + "L-" + rd + ",0L0,-" + rd + "Z");
          }
        },
        cross: {
          n: 3,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 0.4, 2);
            var rc2 = round(r * 1.2, 2);
            return align(angle, standoff, "M" + rc2 + "," + rc + "H" + rc + "V" + rc2 + "H-" + rc + "V" + rc + "H-" + rc2 + "V-" + rc + "H-" + rc + "V-" + rc2 + "H" + rc + "V-" + rc + "H" + rc2 + "Z");
          }
        },
        x: {
          n: 4,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 0.8 / sqrt2, 2);
            var ne = "l" + rx + "," + rx;
            var se = "l" + rx + ",-" + rx;
            var sw = "l-" + rx + ",-" + rx;
            var nw = "l-" + rx + "," + rx;
            return align(angle, standoff, "M0," + rx + ne + se + sw + se + sw + nw + sw + nw + ne + nw + ne + "Z");
          }
        },
        "triangle-up": {
          n: 5,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M-" + rt + "," + r2 + "H" + rt + "L0,-" + rs + "Z");
          }
        },
        "triangle-down": {
          n: 6,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M-" + rt + ",-" + r2 + "H" + rt + "L0," + rs + "Z");
          }
        },
        "triangle-left": {
          n: 7,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M" + r2 + ",-" + rt + "V" + rt + "L-" + rs + ",0Z");
          }
        },
        "triangle-right": {
          n: 8,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rt = round(r * 2 / sqrt3, 2);
            var r2 = round(r / 2, 2);
            var rs = round(r, 2);
            return align(angle, standoff, "M-" + r2 + ",-" + rt + "V" + rt + "L" + rs + ",0Z");
          }
        },
        "triangle-ne": {
          n: 9,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M-" + r2 + ",-" + r1 + "H" + r1 + "V" + r2 + "Z");
          }
        },
        "triangle-se": {
          n: 10,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M" + r1 + ",-" + r2 + "V" + r1 + "H-" + r2 + "Z");
          }
        },
        "triangle-sw": {
          n: 11,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M" + r2 + "," + r1 + "H-" + r1 + "V-" + r2 + "Z");
          }
        },
        "triangle-nw": {
          n: 12,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r * 0.6, 2);
            var r2 = round(r * 1.2, 2);
            return align(angle, standoff, "M-" + r1 + "," + r2 + "V-" + r1 + "H" + r2 + "Z");
          }
        },
        pentagon: {
          n: 13,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x1 = round(r * 0.951, 2);
            var x2 = round(r * 0.588, 2);
            var y0 = round(-r, 2);
            var y1 = round(r * -0.309, 2);
            var y2 = round(r * 0.809, 2);
            return align(angle, standoff, "M" + x1 + "," + y1 + "L" + x2 + "," + y2 + "H-" + x2 + "L-" + x1 + "," + y1 + "L0," + y0 + "Z");
          }
        },
        hexagon: {
          n: 14,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y0 = round(r, 2);
            var y1 = round(r / 2, 2);
            var x = round(r * sqrt3 / 2, 2);
            return align(angle, standoff, "M" + x + ",-" + y1 + "V" + y1 + "L0," + y0 + "L-" + x + "," + y1 + "V-" + y1 + "L0,-" + y0 + "Z");
          }
        },
        hexagon2: {
          n: 15,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x0 = round(r, 2);
            var x1 = round(r / 2, 2);
            var y = round(r * sqrt3 / 2, 2);
            return align(angle, standoff, "M-" + x1 + "," + y + "H" + x1 + "L" + x0 + ",0L" + x1 + ",-" + y + "H-" + x1 + "L-" + x0 + ",0Z");
          }
        },
        octagon: {
          n: 16,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var a = round(r * 0.924, 2);
            var b = round(r * 0.383, 2);
            return align(angle, standoff, "M-" + b + ",-" + a + "H" + b + "L" + a + ",-" + b + "V" + b + "L" + b + "," + a + "H-" + b + "L-" + a + "," + b + "V-" + b + "Z");
          }
        },
        star: {
          n: 17,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = r * 1.4;
            var x1 = round(rs * 0.225, 2);
            var x2 = round(rs * 0.951, 2);
            var x3 = round(rs * 0.363, 2);
            var x4 = round(rs * 0.588, 2);
            var y0 = round(-rs, 2);
            var y1 = round(rs * -0.309, 2);
            var y3 = round(rs * 0.118, 2);
            var y4 = round(rs * 0.809, 2);
            var y5 = round(rs * 0.382, 2);
            return align(angle, standoff, "M" + x1 + "," + y1 + "H" + x2 + "L" + x3 + "," + y3 + "L" + x4 + "," + y4 + "L0," + y5 + "L-" + x4 + "," + y4 + "L-" + x3 + "," + y3 + "L-" + x2 + "," + y1 + "H-" + x1 + "L0," + y0 + "Z");
          }
        },
        hexagram: {
          n: 18,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y = round(r * 0.66, 2);
            var x1 = round(r * 0.38, 2);
            var x2 = round(r * 0.76, 2);
            return align(angle, standoff, "M-" + x2 + ",0l-" + x1 + ",-" + y + "h" + x2 + "l" + x1 + ",-" + y + "l" + x1 + "," + y + "h" + x2 + "l-" + x1 + "," + y + "l" + x1 + "," + y + "h-" + x2 + "l-" + x1 + "," + y + "l-" + x1 + ",-" + y + "h-" + x2 + "Z");
          }
        },
        "star-triangle-up": {
          n: 19,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * sqrt3 * 0.8, 2);
            var y1 = round(r * 0.8, 2);
            var y2 = round(r * 1.6, 2);
            var rc = round(r * 4, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M-" + x + "," + y1 + aPart + x + "," + y1 + aPart + "0,-" + y2 + aPart + "-" + x + "," + y1 + "Z");
          }
        },
        "star-triangle-down": {
          n: 20,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * sqrt3 * 0.8, 2);
            var y1 = round(r * 0.8, 2);
            var y2 = round(r * 1.6, 2);
            var rc = round(r * 4, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M" + x + ",-" + y1 + aPart + "-" + x + ",-" + y1 + aPart + "0," + y2 + aPart + x + ",-" + y1 + "Z");
          }
        },
        "star-square": {
          n: 21,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rp = round(r * 1.1, 2);
            var rc = round(r * 2, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M-" + rp + ",-" + rp + aPart + "-" + rp + "," + rp + aPart + rp + "," + rp + aPart + rp + ",-" + rp + aPart + "-" + rp + ",-" + rp + "Z");
          }
        },
        "star-diamond": {
          n: 22,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rp = round(r * 1.4, 2);
            var rc = round(r * 1.9, 2);
            var aPart = "A " + rc + "," + rc + " 0 0 1 ";
            return align(angle, standoff, "M-" + rp + ",0" + aPart + "0," + rp + aPart + rp + ",0" + aPart + "0,-" + rp + aPart + "-" + rp + ",0Z");
          }
        },
        "diamond-tall": {
          n: 23,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 0.7, 2);
            var y = round(r * 1.4, 2);
            return align(angle, standoff, "M0," + y + "L" + x + ",0L0,-" + y + "L-" + x + ",0Z");
          }
        },
        "diamond-wide": {
          n: 24,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 1.4, 2);
            var y = round(r * 0.7, 2);
            return align(angle, standoff, "M0," + y + "L" + x + ",0L0,-" + y + "L-" + x + ",0Z");
          }
        },
        hourglass: {
          n: 25,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "H-" + rs + "L" + rs + ",-" + rs + "H-" + rs + "Z");
          },
          noDot: true
        },
        bowtie: {
          n: 26,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "V-" + rs + "L-" + rs + "," + rs + "V-" + rs + "Z");
          },
          noDot: true
        },
        "circle-cross": {
          n: 27,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M0," + rs + "V-" + rs + "M" + rs + ",0H-" + rs + "M" + rs + ",0A" + rs + "," + rs + " 0 1,1 0,-" + rs + "A" + rs + "," + rs + " 0 0,1 " + rs + ",0Z");
          },
          needLine: true,
          noDot: true
        },
        "circle-x": {
          n: 28,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            var rc = round(r / sqrt2, 2);
            return align(angle, standoff, "M" + rc + "," + rc + "L-" + rc + ",-" + rc + "M" + rc + ",-" + rc + "L-" + rc + "," + rc + "M" + rs + ",0A" + rs + "," + rs + " 0 1,1 0,-" + rs + "A" + rs + "," + rs + " 0 0,1 " + rs + ",0Z");
          },
          needLine: true,
          noDot: true
        },
        "square-cross": {
          n: 29,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M0," + rs + "V-" + rs + "M" + rs + ",0H-" + rs + "M" + rs + "," + rs + "H-" + rs + "V-" + rs + "H" + rs + "Z");
          },
          needLine: true,
          noDot: true
        },
        "square-x": {
          n: 30,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rs = round(r, 2);
            return align(angle, standoff, "M" + rs + "," + rs + "L-" + rs + ",-" + rs + "M" + rs + ",-" + rs + "L-" + rs + "," + rs + "M" + rs + "," + rs + "H-" + rs + "V-" + rs + "H" + rs + "Z");
          },
          needLine: true,
          noDot: true
        },
        "diamond-cross": {
          n: 31,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rd = round(r * 1.3, 2);
            return align(angle, standoff, "M" + rd + ",0L0," + rd + "L-" + rd + ",0L0,-" + rd + "ZM0,-" + rd + "V" + rd + "M-" + rd + ",0H" + rd);
          },
          needLine: true,
          noDot: true
        },
        "diamond-x": {
          n: 32,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rd = round(r * 1.3, 2);
            var r2 = round(r * 0.65, 2);
            return align(angle, standoff, "M" + rd + ",0L0," + rd + "L-" + rd + ",0L0,-" + rd + "ZM-" + r2 + ",-" + r2 + "L" + r2 + "," + r2 + "M-" + r2 + "," + r2 + "L" + r2 + ",-" + r2);
          },
          needLine: true,
          noDot: true
        },
        "cross-thin": {
          n: 33,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.4, 2);
            return align(angle, standoff, "M0," + rc + "V-" + rc + "M" + rc + ",0H-" + rc);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "x-thin": {
          n: 34,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            return align(angle, standoff, "M" + rx + "," + rx + "L-" + rx + ",-" + rx + "M" + rx + ",-" + rx + "L-" + rx + "," + rx);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        asterisk: {
          n: 35,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.2, 2);
            var rs = round(r * 0.85, 2);
            return align(angle, standoff, "M0," + rc + "V-" + rc + "M" + rc + ",0H-" + rc + "M" + rs + "," + rs + "L-" + rs + ",-" + rs + "M" + rs + ",-" + rs + "L-" + rs + "," + rs);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        hash: {
          n: 36,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var r1 = round(r / 2, 2);
            var r2 = round(r, 2);
            return align(angle, standoff, "M" + r1 + "," + r2 + "V-" + r2 + "M" + (r1 - r2) + ",-" + r2 + "V" + r2 + "M" + r2 + "," + r1 + "H-" + r2 + "M-" + r2 + "," + (r1 - r2) + "H" + r2);
          },
          needLine: true,
          noFill: true
        },
        "y-up": {
          n: 37,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 1.2, 2);
            var y0 = round(r * 1.6, 2);
            var y1 = round(r * 0.8, 2);
            return align(angle, standoff, "M-" + x + "," + y1 + "L0,0M" + x + "," + y1 + "L0,0M0,-" + y0 + "L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "y-down": {
          n: 38,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var x = round(r * 1.2, 2);
            var y0 = round(r * 1.6, 2);
            var y1 = round(r * 0.8, 2);
            return align(angle, standoff, "M-" + x + ",-" + y1 + "L0,0M" + x + ",-" + y1 + "L0,0M0," + y0 + "L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "y-left": {
          n: 39,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y = round(r * 1.2, 2);
            var x0 = round(r * 1.6, 2);
            var x1 = round(r * 0.8, 2);
            return align(angle, standoff, "M" + x1 + "," + y + "L0,0M" + x1 + ",-" + y + "L0,0M-" + x0 + ",0L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "y-right": {
          n: 40,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var y = round(r * 1.2, 2);
            var x0 = round(r * 1.6, 2);
            var x1 = round(r * 0.8, 2);
            return align(angle, standoff, "M-" + x1 + "," + y + "L0,0M-" + x1 + ",-" + y + "L0,0M" + x0 + ",0L0,0");
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-ew": {
          n: 41,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.4, 2);
            return align(angle, standoff, "M" + rc + ",0H-" + rc);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-ns": {
          n: 42,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rc = round(r * 1.4, 2);
            return align(angle, standoff, "M0," + rc + "V-" + rc);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-ne": {
          n: 43,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            return align(angle, standoff, "M" + rx + ",-" + rx + "L-" + rx + "," + rx);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "line-nw": {
          n: 44,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            return align(angle, standoff, "M" + rx + "," + rx + "L-" + rx + ",-" + rx);
          },
          needLine: true,
          noDot: true,
          noFill: true
        },
        "arrow-up": {
          n: 45,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M0,0L-" + rx + "," + ry + "H" + rx + "Z");
          },
          backoff: 1,
          noDot: true
        },
        "arrow-down": {
          n: 46,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M0,0L-" + rx + ",-" + ry + "H" + rx + "Z");
          },
          noDot: true
        },
        "arrow-left": {
          n: 47,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,0L" + rx + ",-" + ry + "V" + ry + "Z");
          },
          noDot: true
        },
        "arrow-right": {
          n: 48,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,0L-" + rx + ",-" + ry + "V" + ry + "Z");
          },
          noDot: true
        },
        "arrow-bar-up": {
          n: 49,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M-" + rx + ",0H" + rx + "M0,0L-" + rx + "," + ry + "H" + rx + "Z");
          },
          backoff: 1,
          needLine: true,
          noDot: true
        },
        "arrow-bar-down": {
          n: 50,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r, 2);
            var ry = round(r * 2, 2);
            return align(angle, standoff, "M-" + rx + ",0H" + rx + "M0,0L-" + rx + ",-" + ry + "H" + rx + "Z");
          },
          needLine: true,
          noDot: true
        },
        "arrow-bar-left": {
          n: 51,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,-" + ry + "V" + ry + "M0,0L" + rx + ",-" + ry + "V" + ry + "Z");
          },
          needLine: true,
          noDot: true
        },
        "arrow-bar-right": {
          n: 52,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var rx = round(r * 2, 2);
            var ry = round(r, 2);
            return align(angle, standoff, "M0,-" + ry + "V" + ry + "M0,0L-" + rx + ",-" + ry + "V" + ry + "Z");
          },
          needLine: true,
          noDot: true
        },
        arrow: {
          n: 53,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var headAngle = PI / 2.5;
            var x = 2 * r * cos(headAngle);
            var y = 2 * r * sin(headAngle);
            return align(
              angle,
              standoff,
              "M0,0L" + -x + "," + y + "L" + x + "," + y + "Z"
            );
          },
          backoff: 0.9,
          noDot: true
        },
        "arrow-wide": {
          n: 54,
          f: function(r, angle, standoff) {
            if (skipAngle(angle)) return emptyPath;
            var headAngle = PI / 4;
            var x = 2 * r * cos(headAngle);
            var y = 2 * r * sin(headAngle);
            return align(
              angle,
              standoff,
              "M0,0L" + -x + "," + y + "A " + 2 * r + "," + 2 * r + " 0 0 1 " + x + "," + y + "Z"
            );
          },
          backoff: 0.4,
          noDot: true
        }
      };
      function skipAngle(angle) {
        return angle === null;
      }
      var lastPathIn;
      var lastPathOut;
      var lastAngle;
      var lastStandoff;
      function align(angle, standoff, path) {
        if ((!angle || angle % 360 === 0) && !standoff) return path;
        if (lastAngle === angle && lastStandoff === standoff && lastPathIn === path) return lastPathOut;
        lastAngle = angle;
        lastStandoff = standoff;
        lastPathIn = path;
        function rotate(t2, xy) {
          var cosT = cos(t2);
          var sinT = sin(t2);
          var x2 = xy[0];
          var y2 = xy[1] + (standoff || 0);
          return [
            x2 * cosT - y2 * sinT,
            x2 * sinT + y2 * cosT
          ];
        }
        var t = angle / 180 * PI;
        var x = 0;
        var y = 0;
        var cmd = parseSvgPath(path);
        var str = "";
        for (var i = 0; i < cmd.length; i++) {
          var cmdI = cmd[i];
          var op = cmdI[0];
          var x0 = x;
          var y0 = y;
          if (op === "M" || op === "L") {
            x = +cmdI[1];
            y = +cmdI[2];
          } else if (op === "m" || op === "l") {
            x += +cmdI[1];
            y += +cmdI[2];
          } else if (op === "H") {
            x = +cmdI[1];
          } else if (op === "h") {
            x += +cmdI[1];
          } else if (op === "V") {
            y = +cmdI[1];
          } else if (op === "v") {
            y += +cmdI[1];
          } else if (op === "A") {
            x = +cmdI[1];
            y = +cmdI[2];
            var E = rotate(t, [+cmdI[6], +cmdI[7]]);
            cmdI[6] = E[0];
            cmdI[7] = E[1];
            cmdI[3] = +cmdI[3] + angle;
          }
          if (op === "H" || op === "V") op = "L";
          if (op === "h" || op === "v") op = "l";
          if (op === "m" || op === "l") {
            x -= x0;
            y -= y0;
          }
          var B = rotate(t, [x, y]);
          if (op === "H" || op === "V") op = "L";
          if (op === "M" || op === "L" || op === "m" || op === "l") {
            cmdI[1] = B[0];
            cmdI[2] = B[1];
          }
          cmdI[0] = op;
          str += cmdI[0] + cmdI.slice(1).join(",");
        }
        lastPathOut = str;
        return str;
      }
    }
  });

  // src/components/drawing/index.js
  var require_drawing = __commonJS({
    "src/components/drawing/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var numberFormat = Lib.numberFormat;
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var Registry = require_registry();
      var Color = require_color();
      var Colorscale = require_colorscale();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var xmlnsNamespaces = require_xmlns_namespaces();
      var alignment = require_alignment();
      var LINE_SPACING = alignment.LINE_SPACING;
      var DESELECTDIM = require_interactions().DESELECTDIM;
      var subTypes = require_subtypes();
      var makeBubbleSizeFn = require_make_bubble_size_func();
      var appendArrayPointValue = require_helpers2().appendArrayPointValue;
      var drawing = module.exports = {};
      drawing.font = function(s, font) {
        var variant = font.variant;
        var style = font.style;
        var weight = font.weight;
        var color = font.color;
        var size = font.size;
        var family = font.family;
        var shadow = font.shadow;
        var lineposition = font.lineposition;
        var textcase = font.textcase;
        if (family) s.style("font-family", family);
        if (size + 1) s.style("font-size", size + "px");
        if (color) s.call(Color.fill, color);
        if (weight) s.style("font-weight", weight);
        if (style) s.style("font-style", style);
        if (variant) s.style("font-variant", variant);
        if (textcase) s.style("text-transform", dropNone(textcase2transform(textcase)));
        if (shadow) s.style("text-shadow", shadow === "auto" ? svgTextUtils.makeTextShadow(Color.contrast(color)) : dropNone(shadow));
        if (lineposition) s.style("text-decoration-line", dropNone(lineposition2decorationLine(lineposition)));
      };
      function dropNone(a) {
        return a === "none" ? void 0 : a;
      }
      var textcase2transformOptions = {
        normal: "none",
        lower: "lowercase",
        upper: "uppercase",
        "word caps": "capitalize"
      };
      function textcase2transform(textcase) {
        return textcase2transformOptions[textcase];
      }
      function lineposition2decorationLine(lineposition) {
        return lineposition.replace("under", "underline").replace("over", "overline").replace("through", "line-through").split("+").join(" ");
      }
      drawing.setPosition = function(s, x, y) {
        s.attr("x", x).attr("y", y);
      };
      drawing.setSize = function(s, w, h) {
        s.attr("width", w).attr("height", h);
      };
      drawing.setRect = function(s, x, y, w, h) {
        s.call(drawing.setPosition, x, y).call(drawing.setSize, w, h);
      };
      drawing.translatePoint = function(d, sel, xa, ya) {
        var x = xa.c2p(d.x);
        var y = ya.c2p(d.y);
        if (isNumeric(x) && isNumeric(y) && sel.node()) {
          if (sel.node().nodeName === "text") {
            sel.attr("x", x).attr("y", y);
          } else {
            sel.attr("transform", strTranslate(x, y));
          }
        } else {
          return false;
        }
        return true;
      };
      drawing.translatePoints = function(s, xa, ya) {
        s.each(function(d) {
          var sel = d3.select(this);
          drawing.translatePoint(d, sel, xa, ya);
        });
      };
      drawing.hideOutsideRangePoint = function(d, sel, xa, ya, xcalendar, ycalendar) {
        sel.attr(
          "display",
          xa.isPtWithinRange(d, xcalendar) && ya.isPtWithinRange(d, ycalendar) ? null : "none"
        );
      };
      drawing.hideOutsideRangePoints = function(traceGroups, subplot) {
        if (!subplot._hasClipOnAxisFalse) return;
        var xa = subplot.xaxis;
        var ya = subplot.yaxis;
        traceGroups.each(function(d) {
          var trace = d[0].trace;
          var xcalendar = trace.xcalendar;
          var ycalendar = trace.ycalendar;
          var selector = Registry.traceIs(trace, "bar-like") ? ".bartext" : ".point,.textpoint";
          traceGroups.selectAll(selector).each(function(d2) {
            drawing.hideOutsideRangePoint(d2, d3.select(this), xa, ya, xcalendar, ycalendar);
          });
        });
      };
      drawing.crispRound = function(gd, lineWidth, dflt) {
        if (!lineWidth || !isNumeric(lineWidth)) return dflt || 0;
        if (gd._context.staticPlot) return lineWidth;
        if (lineWidth < 1) return 1;
        return Math.round(lineWidth);
      };
      drawing.singleLineStyle = function(d, s, lw, lc, ld) {
        s.style("fill", "none");
        var line = (((d || [])[0] || {}).trace || {}).line || {};
        var lw1 = lw || line.width || 0;
        var dash = ld || line.dash || "";
        Color.stroke(s, lc || line.color);
        drawing.dashLine(s, dash, lw1);
      };
      drawing.lineGroupStyle = function(s, lw, lc, ld) {
        s.style("fill", "none").each(function(d) {
          var line = (((d || [])[0] || {}).trace || {}).line || {};
          var lw1 = lw || line.width || 0;
          var dash = ld || line.dash || "";
          d3.select(this).call(Color.stroke, lc || line.color).call(drawing.dashLine, dash, lw1);
        });
      };
      drawing.dashLine = function(s, dash, lineWidth) {
        lineWidth = +lineWidth || 0;
        dash = drawing.dashStyle(dash, lineWidth);
        s.style({
          "stroke-dasharray": dash,
          "stroke-width": lineWidth + "px"
        });
      };
      drawing.dashStyle = function(dash, lineWidth) {
        lineWidth = +lineWidth || 1;
        var dlw = Math.max(lineWidth, 3);
        if (dash === "solid") dash = "";
        else if (dash === "dot") dash = dlw + "px," + dlw + "px";
        else if (dash === "dash") dash = 3 * dlw + "px," + 3 * dlw + "px";
        else if (dash === "longdash") dash = 5 * dlw + "px," + 5 * dlw + "px";
        else if (dash === "dashdot") {
          dash = 3 * dlw + "px," + dlw + "px," + dlw + "px," + dlw + "px";
        } else if (dash === "longdashdot") {
          dash = 5 * dlw + "px," + 2 * dlw + "px," + dlw + "px," + 2 * dlw + "px";
        }
        return dash;
      };
      function setFillStyle(sel, trace, gd, forLegend) {
        var markerPattern = trace.fillpattern;
        var fillgradient = trace.fillgradient;
        var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, 0, "");
        if (patternShape) {
          var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, 0, null);
          var patternFGColor = drawing.getPatternAttr(markerPattern.fgcolor, 0, null);
          var patternFGOpacity = markerPattern.fgopacity;
          var patternSize = drawing.getPatternAttr(markerPattern.size, 0, 8);
          var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, 0, 0.3);
          var patternID = trace.uid;
          drawing.pattern(
            sel,
            "point",
            gd,
            patternID,
            patternShape,
            patternSize,
            patternSolidity,
            void 0,
            markerPattern.fillmode,
            patternBGColor,
            patternFGColor,
            patternFGOpacity
          );
        } else if (fillgradient && fillgradient.type !== "none") {
          var direction = fillgradient.type;
          var gradientID = "scatterfill-" + trace.uid;
          if (forLegend) {
            gradientID = "legendfill-" + trace.uid;
          }
          if (!forLegend && (fillgradient.start !== void 0 || fillgradient.stop !== void 0)) {
            var start, stop;
            if (direction === "horizontal") {
              start = {
                x: fillgradient.start,
                y: 0
              };
              stop = {
                x: fillgradient.stop,
                y: 0
              };
            } else if (direction === "vertical") {
              start = {
                x: 0,
                y: fillgradient.start
              };
              stop = {
                x: 0,
                y: fillgradient.stop
              };
            }
            start.x = trace._xA.c2p(
              start.x === void 0 ? trace._extremes.x.min[0].val : start.x,
              true
            );
            start.y = trace._yA.c2p(
              start.y === void 0 ? trace._extremes.y.min[0].val : start.y,
              true
            );
            stop.x = trace._xA.c2p(
              stop.x === void 0 ? trace._extremes.x.max[0].val : stop.x,
              true
            );
            stop.y = trace._yA.c2p(
              stop.y === void 0 ? trace._extremes.y.max[0].val : stop.y,
              true
            );
            sel.call(gradientWithBounds, gd, gradientID, "linear", fillgradient.colorscale, "fill", start, stop, true, false);
          } else {
            if (direction === "horizontal") {
              direction = direction + "reversed";
            }
            sel.call(drawing.gradient, gd, gradientID, direction, fillgradient.colorscale, "fill");
          }
        } else if (trace.fillcolor) {
          sel.call(Color.fill, trace.fillcolor);
        }
      }
      drawing.singleFillStyle = function(sel, gd) {
        var node = d3.select(sel.node());
        var data = node.data();
        var trace = ((data[0] || [])[0] || {}).trace || {};
        setFillStyle(sel, trace, gd, false);
      };
      drawing.fillGroupStyle = function(s, gd, forLegend) {
        s.style("stroke-width", 0).each(function(d) {
          var shape = d3.select(this);
          if (d[0].trace) {
            setFillStyle(shape, d[0].trace, gd, forLegend);
          }
        });
      };
      var SYMBOLDEFS = require_symbol_defs();
      drawing.symbolNames = [];
      drawing.symbolFuncs = [];
      drawing.symbolBackOffs = [];
      drawing.symbolNeedLines = {};
      drawing.symbolNoDot = {};
      drawing.symbolNoFill = {};
      drawing.symbolList = [];
      Object.keys(SYMBOLDEFS).forEach(function(k) {
        var symDef = SYMBOLDEFS[k];
        var n = symDef.n;
        drawing.symbolList.push(
          n,
          String(n),
          k,
          n + 100,
          String(n + 100),
          k + "-open"
        );
        drawing.symbolNames[n] = k;
        drawing.symbolFuncs[n] = symDef.f;
        drawing.symbolBackOffs[n] = symDef.backoff || 0;
        if (symDef.needLine) {
          drawing.symbolNeedLines[n] = true;
        }
        if (symDef.noDot) {
          drawing.symbolNoDot[n] = true;
        } else {
          drawing.symbolList.push(
            n + 200,
            String(n + 200),
            k + "-dot",
            n + 300,
            String(n + 300),
            k + "-open-dot"
          );
        }
        if (symDef.noFill) {
          drawing.symbolNoFill[n] = true;
        }
      });
      var MAXSYMBOL = drawing.symbolNames.length;
      var DOTPATH = "M0,0.5L0.5,0L0,-0.5L-0.5,0Z";
      drawing.symbolNumber = function(v) {
        if (isNumeric(v)) {
          v = +v;
        } else if (typeof v === "string") {
          var vbase = 0;
          if (v.indexOf("-open") > 0) {
            vbase = 100;
            v = v.replace("-open", "");
          }
          if (v.indexOf("-dot") > 0) {
            vbase += 200;
            v = v.replace("-dot", "");
          }
          v = drawing.symbolNames.indexOf(v);
          if (v >= 0) {
            v += vbase;
          }
        }
        return v % 100 >= MAXSYMBOL || v >= 400 ? 0 : Math.floor(Math.max(v, 0));
      };
      function makePointPath(symbolNumber, r, t, s) {
        var base = symbolNumber % 100;
        return drawing.symbolFuncs[base](r, t, s) + (symbolNumber >= 200 ? DOTPATH : "");
      }
      var stopFormatter = numberFormat("~f");
      var gradientInfo = {
        radial: { type: "radial" },
        radialreversed: { type: "radial", reversed: true },
        horizontal: { type: "linear", start: { x: 1, y: 0 }, stop: { x: 0, y: 0 } },
        horizontalreversed: { type: "linear", start: { x: 1, y: 0 }, stop: { x: 0, y: 0 }, reversed: true },
        vertical: { type: "linear", start: { x: 0, y: 1 }, stop: { x: 0, y: 0 } },
        verticalreversed: { type: "linear", start: { x: 0, y: 1 }, stop: { x: 0, y: 0 }, reversed: true }
      };
      drawing.gradient = function(sel, gd, gradientID, type, colorscale, prop) {
        var info = gradientInfo[type];
        return gradientWithBounds(
          sel,
          gd,
          gradientID,
          info.type,
          colorscale,
          prop,
          info.start,
          info.stop,
          false,
          info.reversed
        );
      };
      function gradientWithBounds(sel, gd, gradientID, type, colorscale, prop, start, stop, inUserSpace, reversed) {
        var len = colorscale.length;
        var info;
        if (type === "linear") {
          info = {
            node: "linearGradient",
            attrs: {
              x1: start.x,
              y1: start.y,
              x2: stop.x,
              y2: stop.y,
              gradientUnits: inUserSpace ? "userSpaceOnUse" : "objectBoundingBox"
            },
            reversed
          };
        } else if (type === "radial") {
          info = {
            node: "radialGradient",
            reversed
          };
        }
        var colorStops = new Array(len);
        for (var i = 0; i < len; i++) {
          if (info.reversed) {
            colorStops[len - 1 - i] = [stopFormatter((1 - colorscale[i][0]) * 100), colorscale[i][1]];
          } else {
            colorStops[i] = [stopFormatter(colorscale[i][0] * 100), colorscale[i][1]];
          }
        }
        var fullLayout = gd._fullLayout;
        var fullID = "g" + fullLayout._uid + "-" + gradientID;
        var gradient = fullLayout._defs.select(".gradients").selectAll("#" + fullID).data([type + colorStops.join(";")], Lib.identity);
        gradient.exit().remove();
        gradient.enter().append(info.node).each(function() {
          var el = d3.select(this);
          if (info.attrs) el.attr(info.attrs);
          el.attr("id", fullID);
          var stops = el.selectAll("stop").data(colorStops);
          stops.exit().remove();
          stops.enter().append("stop");
          stops.each(function(d) {
            var tc = tinycolor(d[1]);
            d3.select(this).attr({
              offset: d[0] + "%",
              "stop-color": Color.tinyRGB(tc),
              "stop-opacity": tc.getAlpha()
            });
          });
        });
        sel.style(prop, getFullUrl(fullID, gd)).style(prop + "-opacity", null);
        sel.classed("gradient_filled", true);
      }
      drawing.pattern = function(sel, calledBy, gd, patternID, shape, size, solidity, mcc, fillmode, bgcolor, fgcolor, fgopacity) {
        var isLegend = calledBy === "legend";
        if (mcc) {
          if (fillmode === "overlay") {
            bgcolor = mcc;
            fgcolor = Color.contrast(bgcolor);
          } else {
            bgcolor = void 0;
            fgcolor = mcc;
          }
        }
        var fullLayout = gd._fullLayout;
        var fullID = "p" + fullLayout._uid + "-" + patternID;
        var width, height;
        var linearFn = function(x, x0, x1, y0, y1) {
          return y0 + (y1 - y0) * (x - x0) / (x1 - x0);
        };
        var path, linewidth, radius;
        var patternTag;
        var patternAttrs = {};
        var fgC = tinycolor(fgcolor);
        var fgRGB = Color.tinyRGB(fgC);
        var fgAlpha = fgC.getAlpha();
        var opacity = fgopacity * fgAlpha;
        switch (shape) {
          case "/":
            width = size * Math.sqrt(2);
            height = size * Math.sqrt(2);
            path = "M-" + width / 4 + "," + height / 4 + "l" + width / 2 + ",-" + height / 2 + "M0," + height + "L" + width + ",0M" + width / 4 * 3 + "," + height / 4 * 5 + "l" + width / 2 + ",-" + height / 2;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "\\":
            width = size * Math.sqrt(2);
            height = size * Math.sqrt(2);
            path = "M" + width / 4 * 3 + ",-" + height / 4 + "l" + width / 2 + "," + height / 2 + "M0,0L" + width + "," + height + "M-" + width / 4 + "," + height / 4 * 3 + "l" + width / 2 + "," + height / 2;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "x":
            width = size * Math.sqrt(2);
            height = size * Math.sqrt(2);
            path = "M-" + width / 4 + "," + height / 4 + "l" + width / 2 + ",-" + height / 2 + "M0," + height + "L" + width + ",0M" + width / 4 * 3 + "," + height / 4 * 5 + "l" + width / 2 + ",-" + height / 2 + "M" + width / 4 * 3 + ",-" + height / 4 + "l" + width / 2 + "," + height / 2 + "M0,0L" + width + "," + height + "M-" + width / 4 + "," + height / 4 * 3 + "l" + width / 2 + "," + height / 2;
            linewidth = size - size * Math.sqrt(1 - solidity);
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "|":
            width = size;
            height = size;
            patternTag = "path";
            path = "M" + width / 2 + ",0L" + width / 2 + "," + height;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "-":
            width = size;
            height = size;
            patternTag = "path";
            path = "M0," + height / 2 + "L" + width + "," + height / 2;
            linewidth = solidity * size;
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case "+":
            width = size;
            height = size;
            patternTag = "path";
            path = "M" + width / 2 + ",0L" + width / 2 + "," + height + "M0," + height / 2 + "L" + width + "," + height / 2;
            linewidth = size - size * Math.sqrt(1 - solidity);
            patternTag = "path";
            patternAttrs = {
              d: path,
              opacity,
              stroke: fgRGB,
              "stroke-width": linewidth + "px"
            };
            break;
          case ".":
            width = size;
            height = size;
            if (solidity < Math.PI / 4) {
              radius = Math.sqrt(solidity * size * size / Math.PI);
            } else {
              radius = linearFn(solidity, Math.PI / 4, 1, size / 2, size / Math.sqrt(2));
            }
            patternTag = "circle";
            patternAttrs = {
              cx: width / 2,
              cy: height / 2,
              r: radius,
              opacity,
              fill: fgRGB
            };
            break;
        }
        var str = [
          shape || "noSh",
          bgcolor || "noBg",
          fgcolor || "noFg",
          size,
          solidity
        ].join(";");
        var pattern = fullLayout._defs.select(".patterns").selectAll("#" + fullID).data([str], Lib.identity);
        pattern.exit().remove();
        pattern.enter().append("pattern").each(function() {
          var el = d3.select(this);
          el.attr({
            id: fullID,
            width: width + "px",
            height: height + "px",
            patternUnits: "userSpaceOnUse",
            // for legends scale down patterns just a bit so that default size (i.e 8) nicely fit in small icons
            patternTransform: isLegend ? "scale(0.8)" : ""
          });
          if (bgcolor) {
            var bgC = tinycolor(bgcolor);
            var bgRGB = Color.tinyRGB(bgC);
            var bgAlpha = bgC.getAlpha();
            var rects = el.selectAll("rect").data([0]);
            rects.exit().remove();
            rects.enter().append("rect").attr({
              width: width + "px",
              height: height + "px",
              fill: bgRGB,
              "fill-opacity": bgAlpha
            });
          }
          var patterns = el.selectAll(patternTag).data([0]);
          patterns.exit().remove();
          patterns.enter().append(patternTag).attr(patternAttrs);
        });
        sel.style("fill", getFullUrl(fullID, gd)).style("fill-opacity", null);
        sel.classed("pattern_filled", true);
      };
      drawing.initGradients = function(gd) {
        var fullLayout = gd._fullLayout;
        var gradientsGroup = Lib.ensureSingle(fullLayout._defs, "g", "gradients");
        gradientsGroup.selectAll("linearGradient,radialGradient").remove();
        d3.select(gd).selectAll(".gradient_filled").classed("gradient_filled", false);
      };
      drawing.initPatterns = function(gd) {
        var fullLayout = gd._fullLayout;
        var patternsGroup = Lib.ensureSingle(fullLayout._defs, "g", "patterns");
        patternsGroup.selectAll("pattern").remove();
        d3.select(gd).selectAll(".pattern_filled").classed("pattern_filled", false);
      };
      drawing.getPatternAttr = function(mp, i, dflt) {
        if (mp && Lib.isArrayOrTypedArray(mp)) {
          return i < mp.length ? mp[i] : dflt;
        }
        return mp;
      };
      drawing.pointStyle = function(s, trace, gd, pt) {
        if (!s.size()) return;
        var fns = drawing.makePointStyleFns(trace);
        s.each(function(d) {
          drawing.singlePointStyle(d, d3.select(this), trace, fns, gd, pt);
        });
      };
      drawing.singlePointStyle = function(d, sel, trace, fns, gd, pt) {
        var marker = trace.marker;
        var markerLine = marker.line;
        if (pt && pt.i >= 0 && d.i === void 0) d.i = pt.i;
        sel.style(
          "opacity",
          fns.selectedOpacityFn ? fns.selectedOpacityFn(d) : d.mo === void 0 ? marker.opacity : d.mo
        );
        if (fns.ms2mrc) {
          var r;
          if (d.ms === "various" || marker.size === "various") {
            r = 3;
          } else {
            r = fns.ms2mrc(d.ms);
          }
          d.mrc = r;
          if (fns.selectedSizeFn) {
            r = d.mrc = fns.selectedSizeFn(d);
          }
          var x = drawing.symbolNumber(d.mx || marker.symbol) || 0;
          d.om = x % 200 >= 100;
          var angle = getMarkerAngle(d, trace);
          var standoff = getMarkerStandoff(d, trace);
          sel.attr("d", makePointPath(x, r, angle, standoff));
        }
        var perPointGradient = false;
        var fillColor, lineColor, lineWidth;
        if (d.so) {
          lineWidth = markerLine.outlierwidth;
          lineColor = markerLine.outliercolor;
          fillColor = marker.outliercolor;
        } else {
          var markerLineWidth = (markerLine || {}).width;
          lineWidth = (d.mlw + 1 || markerLineWidth + 1 || // TODO: we need the latter for legends... can we get rid of it?
          (d.trace ? (d.trace.marker.line || {}).width : 0) + 1) - 1 || 0;
          if ("mlc" in d) lineColor = d.mlcc = fns.lineScale(d.mlc);
          else if (Lib.isArrayOrTypedArray(markerLine.color)) lineColor = Color.defaultLine;
          else lineColor = markerLine.color;
          if (Lib.isArrayOrTypedArray(marker.color)) {
            fillColor = Color.defaultLine;
            perPointGradient = true;
          }
          if ("mc" in d) {
            fillColor = d.mcc = fns.markerScale(d.mc);
          } else {
            fillColor = marker.color || marker.colors || "rgba(0,0,0,0)";
          }
          if (fns.selectedColorFn) {
            fillColor = fns.selectedColorFn(d);
          }
        }
        if (d.om) {
          sel.call(Color.stroke, fillColor).style({
            "stroke-width": (lineWidth || 1) + "px",
            fill: "none"
          });
        } else {
          sel.style("stroke-width", (d.isBlank ? 0 : lineWidth) + "px");
          var markerGradient = marker.gradient;
          var gradientType = d.mgt;
          if (gradientType) perPointGradient = true;
          else gradientType = markerGradient && markerGradient.type;
          if (Lib.isArrayOrTypedArray(gradientType)) {
            gradientType = gradientType[0];
            if (!gradientInfo[gradientType]) gradientType = 0;
          }
          var markerPattern = marker.pattern;
          var patternShape = markerPattern && drawing.getPatternAttr(markerPattern.shape, d.i, "");
          if (gradientType && gradientType !== "none") {
            var gradientColor = d.mgc;
            if (gradientColor) perPointGradient = true;
            else gradientColor = markerGradient.color;
            var gradientID = trace.uid;
            if (perPointGradient) gradientID += "-" + d.i;
            drawing.gradient(
              sel,
              gd,
              gradientID,
              gradientType,
              [[0, gradientColor], [1, fillColor]],
              "fill"
            );
          } else if (patternShape) {
            var perPointPattern = false;
            var fgcolor = markerPattern.fgcolor;
            if (!fgcolor && pt && pt.color) {
              fgcolor = pt.color;
              perPointPattern = true;
            }
            var patternFGColor = drawing.getPatternAttr(fgcolor, d.i, pt && pt.color || null);
            var patternBGColor = drawing.getPatternAttr(markerPattern.bgcolor, d.i, null);
            var patternFGOpacity = markerPattern.fgopacity;
            var patternSize = drawing.getPatternAttr(markerPattern.size, d.i, 8);
            var patternSolidity = drawing.getPatternAttr(markerPattern.solidity, d.i, 0.3);
            perPointPattern = perPointPattern || d.mcc || Lib.isArrayOrTypedArray(markerPattern.shape) || Lib.isArrayOrTypedArray(markerPattern.bgcolor) || Lib.isArrayOrTypedArray(markerPattern.fgcolor) || Lib.isArrayOrTypedArray(markerPattern.size) || Lib.isArrayOrTypedArray(markerPattern.solidity);
            var patternID = trace.uid;
            if (perPointPattern) patternID += "-" + d.i;
            drawing.pattern(
              sel,
              "point",
              gd,
              patternID,
              patternShape,
              patternSize,
              patternSolidity,
              d.mcc,
              markerPattern.fillmode,
              patternBGColor,
              patternFGColor,
              patternFGOpacity
            );
          } else {
            Lib.isArrayOrTypedArray(fillColor) ? Color.fill(sel, fillColor[d.i]) : Color.fill(sel, fillColor);
          }
          if (lineWidth) {
            Color.stroke(sel, lineColor);
          }
        }
      };
      drawing.makePointStyleFns = function(trace) {
        var out = {};
        var marker = trace.marker;
        out.markerScale = drawing.tryColorscale(marker, "");
        out.lineScale = drawing.tryColorscale(marker, "line");
        if (Registry.traceIs(trace, "symbols")) {
          out.ms2mrc = subTypes.isBubble(trace) ? makeBubbleSizeFn(trace) : function() {
            return (marker.size || 6) / 2;
          };
        }
        if (trace.selectedpoints) {
          Lib.extendFlat(out, drawing.makeSelectedPointStyleFns(trace));
        }
        return out;
      };
      drawing.makeSelectedPointStyleFns = function(trace) {
        var out = {};
        var selectedAttrs = trace.selected || {};
        var unselectedAttrs = trace.unselected || {};
        var marker = trace.marker || {};
        var selectedMarker = selectedAttrs.marker || {};
        var unselectedMarker = unselectedAttrs.marker || {};
        var mo = marker.opacity;
        var smo = selectedMarker.opacity;
        var usmo = unselectedMarker.opacity;
        var smoIsDefined = smo !== void 0;
        var usmoIsDefined = usmo !== void 0;
        if (Lib.isArrayOrTypedArray(mo) || smoIsDefined || usmoIsDefined) {
          out.selectedOpacityFn = function(d) {
            var base = d.mo === void 0 ? marker.opacity : d.mo;
            if (d.selected) {
              return smoIsDefined ? smo : base;
            } else {
              return usmoIsDefined ? usmo : DESELECTDIM * base;
            }
          };
        }
        var mc = marker.color;
        var smc = selectedMarker.color;
        var usmc = unselectedMarker.color;
        if (smc || usmc) {
          out.selectedColorFn = function(d) {
            var base = d.mcc || mc;
            if (d.selected) {
              return smc || base;
            } else {
              return usmc || base;
            }
          };
        }
        var ms = marker.size;
        var sms = selectedMarker.size;
        var usms = unselectedMarker.size;
        var smsIsDefined = sms !== void 0;
        var usmsIsDefined = usms !== void 0;
        if (Registry.traceIs(trace, "symbols") && (smsIsDefined || usmsIsDefined)) {
          out.selectedSizeFn = function(d) {
            var base = d.mrc || ms / 2;
            if (d.selected) {
              return smsIsDefined ? sms / 2 : base;
            } else {
              return usmsIsDefined ? usms / 2 : base;
            }
          };
        }
        return out;
      };
      drawing.makeSelectedTextStyleFns = function(trace) {
        var out = {};
        var selectedAttrs = trace.selected || {};
        var unselectedAttrs = trace.unselected || {};
        var textFont = trace.textfont || {};
        var selectedTextFont = selectedAttrs.textfont || {};
        var unselectedTextFont = unselectedAttrs.textfont || {};
        var tc = textFont.color;
        var stc = selectedTextFont.color;
        var utc = unselectedTextFont.color;
        out.selectedTextColorFn = function(d) {
          var base = d.tc || tc;
          if (d.selected) {
            return stc || base;
          } else {
            if (utc) return utc;
            else return stc ? base : Color.addOpacity(base, DESELECTDIM);
          }
        };
        return out;
      };
      drawing.selectedPointStyle = function(s, trace) {
        if (!s.size() || !trace.selectedpoints) return;
        var fns = drawing.makeSelectedPointStyleFns(trace);
        var marker = trace.marker || {};
        var seq = [];
        if (fns.selectedOpacityFn) {
          seq.push(function(pt, d) {
            pt.style("opacity", fns.selectedOpacityFn(d));
          });
        }
        if (fns.selectedColorFn) {
          seq.push(function(pt, d) {
            Color.fill(pt, fns.selectedColorFn(d));
          });
        }
        if (fns.selectedSizeFn) {
          seq.push(function(pt, d) {
            var mx = d.mx || marker.symbol || 0;
            var mrc2 = fns.selectedSizeFn(d);
            pt.attr("d", makePointPath(drawing.symbolNumber(mx), mrc2, getMarkerAngle(d, trace), getMarkerStandoff(d, trace)));
            d.mrc2 = mrc2;
          });
        }
        if (seq.length) {
          s.each(function(d) {
            var pt = d3.select(this);
            for (var i = 0; i < seq.length; i++) {
              seq[i](pt, d);
            }
          });
        }
      };
      drawing.tryColorscale = function(marker, prefix) {
        var cont = prefix ? Lib.nestedProperty(marker, prefix).get() : marker;
        if (cont) {
          var colorArray = cont.color;
          if ((cont.colorscale || cont._colorAx) && Lib.isArrayOrTypedArray(colorArray)) {
            return Colorscale.makeColorScaleFuncFromTrace(cont);
          }
        }
        return Lib.identity;
      };
      var TEXTOFFSETSIGN = {
        start: 1,
        end: -1,
        middle: 0,
        bottom: 1,
        top: -1
      };
      function textPointPosition(s, textPosition, fontSize, markerRadius, dontTouchParent) {
        var group = d3.select(s.node().parentNode);
        var v = textPosition.indexOf("top") !== -1 ? "top" : textPosition.indexOf("bottom") !== -1 ? "bottom" : "middle";
        var h = textPosition.indexOf("left") !== -1 ? "end" : textPosition.indexOf("right") !== -1 ? "start" : "middle";
        var r = markerRadius ? markerRadius / 0.8 + 1 : 0;
        var numLines = (svgTextUtils.lineCount(s) - 1) * LINE_SPACING + 1;
        var dx = TEXTOFFSETSIGN[h] * r;
        var dy = fontSize * 0.75 + TEXTOFFSETSIGN[v] * r + (TEXTOFFSETSIGN[v] - 1) * numLines * fontSize / 2;
        s.attr("text-anchor", h);
        if (!dontTouchParent) {
          group.attr("transform", strTranslate(dx, dy));
        }
      }
      function extracTextFontSize(d, trace) {
        var fontSize = d.ts || trace.textfont.size;
        return isNumeric(fontSize) && fontSize > 0 ? fontSize : 0;
      }
      drawing.textPointStyle = function(s, trace, gd) {
        if (!s.size()) return;
        var selectedTextColorFn;
        if (trace.selectedpoints) {
          var fns = drawing.makeSelectedTextStyleFns(trace);
          selectedTextColorFn = fns.selectedTextColorFn;
        }
        var texttemplate = trace.texttemplate;
        var fullLayout = gd._fullLayout;
        s.each(function(d) {
          var p = d3.select(this);
          var text = texttemplate ? Lib.extractOption(d, trace, "txt", "texttemplate") : Lib.extractOption(d, trace, "tx", "text");
          if (!text && text !== 0) {
            p.remove();
            return;
          }
          if (texttemplate) {
            var fn = trace._module.formatLabels;
            var labels = fn ? fn(d, trace, fullLayout) : {};
            var pointValues = {};
            appendArrayPointValue(pointValues, trace, d.i);
            var meta = trace._meta || {};
            text = Lib.texttemplateString(text, labels, fullLayout._d3locale, pointValues, d, meta);
          }
          var pos = d.tp || trace.textposition;
          var fontSize = extracTextFontSize(d, trace);
          var fontColor = selectedTextColorFn ? selectedTextColorFn(d) : d.tc || trace.textfont.color;
          p.call(drawing.font, {
            family: d.tf || trace.textfont.family,
            weight: d.tw || trace.textfont.weight,
            style: d.ty || trace.textfont.style,
            variant: d.tv || trace.textfont.variant,
            textcase: d.tC || trace.textfont.textcase,
            lineposition: d.tE || trace.textfont.lineposition,
            shadow: d.tS || trace.textfont.shadow,
            size: fontSize,
            color: fontColor
          }).text(text).call(svgTextUtils.convertToTspans, gd).call(textPointPosition, pos, fontSize, d.mrc);
        });
      };
      drawing.selectedTextStyle = function(s, trace) {
        if (!s.size() || !trace.selectedpoints) return;
        var fns = drawing.makeSelectedTextStyleFns(trace);
        s.each(function(d) {
          var tx = d3.select(this);
          var tc = fns.selectedTextColorFn(d);
          var tp = d.tp || trace.textposition;
          var fontSize = extracTextFontSize(d, trace);
          Color.fill(tx, tc);
          var dontTouchParent = Registry.traceIs(trace, "bar-like");
          textPointPosition(tx, tp, fontSize, d.mrc2 || d.mrc, dontTouchParent);
        });
      };
      var CatmullRomExp = 0.5;
      drawing.smoothopen = function(pts, smoothness) {
        if (pts.length < 3) {
          return "M" + pts.join("L");
        }
        var path = "M" + pts[0];
        var tangents = [];
        var i;
        for (i = 1; i < pts.length - 1; i++) {
          tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));
        }
        path += "Q" + tangents[0][0] + " " + pts[1];
        for (i = 2; i < pts.length - 1; i++) {
          path += "C" + tangents[i - 2][1] + " " + tangents[i - 1][0] + " " + pts[i];
        }
        path += "Q" + tangents[pts.length - 3][1] + " " + pts[pts.length - 1];
        return path;
      };
      drawing.smoothclosed = function(pts, smoothness) {
        if (pts.length < 3) {
          return "M" + pts.join("L") + "Z";
        }
        var path = "M" + pts[0];
        var pLast = pts.length - 1;
        var tangents = [makeTangent(pts[pLast], pts[0], pts[1], smoothness)];
        var i;
        for (i = 1; i < pLast; i++) {
          tangents.push(makeTangent(pts[i - 1], pts[i], pts[i + 1], smoothness));
        }
        tangents.push(
          makeTangent(pts[pLast - 1], pts[pLast], pts[0], smoothness)
        );
        for (i = 1; i <= pLast; i++) {
          path += "C" + tangents[i - 1][1] + " " + tangents[i][0] + " " + pts[i];
        }
        path += "C" + tangents[pLast][1] + " " + tangents[0][0] + " " + pts[0] + "Z";
        return path;
      };
      var lastDrawnX;
      var lastDrawnY;
      function roundEnd(pt, isY, isLastPoint) {
        if (isLastPoint) pt = applyBackoff(pt);
        return isY ? roundY(pt[1]) : roundX(pt[0]);
      }
      function roundX(p) {
        var v = d3.round(p, 2);
        lastDrawnX = v;
        return v;
      }
      function roundY(p) {
        var v = d3.round(p, 2);
        lastDrawnY = v;
        return v;
      }
      function makeTangent(prevpt, thispt, nextpt, smoothness) {
        var d1x = prevpt[0] - thispt[0];
        var d1y = prevpt[1] - thispt[1];
        var d2x = nextpt[0] - thispt[0];
        var d2y = nextpt[1] - thispt[1];
        var d1a = Math.pow(d1x * d1x + d1y * d1y, CatmullRomExp / 2);
        var d2a = Math.pow(d2x * d2x + d2y * d2y, CatmullRomExp / 2);
        var numx = (d2a * d2a * d1x - d1a * d1a * d2x) * smoothness;
        var numy = (d2a * d2a * d1y - d1a * d1a * d2y) * smoothness;
        var denom1 = 3 * d2a * (d1a + d2a);
        var denom2 = 3 * d1a * (d1a + d2a);
        return [
          [
            roundX(thispt[0] + (denom1 && numx / denom1)),
            roundY(thispt[1] + (denom1 && numy / denom1))
          ],
          [
            roundX(thispt[0] - (denom2 && numx / denom2)),
            roundY(thispt[1] - (denom2 && numy / denom2))
          ]
        ];
      }
      var STEPPATH = {
        hv: function(p0, p1, isLastPoint) {
          return "H" + roundX(p1[0]) + "V" + roundEnd(p1, 1, isLastPoint);
        },
        vh: function(p0, p1, isLastPoint) {
          return "V" + roundY(p1[1]) + "H" + roundEnd(p1, 0, isLastPoint);
        },
        hvh: function(p0, p1, isLastPoint) {
          return "H" + roundX((p0[0] + p1[0]) / 2) + "V" + roundY(p1[1]) + "H" + roundEnd(p1, 0, isLastPoint);
        },
        vhv: function(p0, p1, isLastPoint) {
          return "V" + roundY((p0[1] + p1[1]) / 2) + "H" + roundX(p1[0]) + "V" + roundEnd(p1, 1, isLastPoint);
        }
      };
      var STEPLINEAR = function(p0, p1, isLastPoint) {
        return "L" + roundEnd(p1, 0, isLastPoint) + "," + roundEnd(p1, 1, isLastPoint);
      };
      drawing.steps = function(shape) {
        var onestep = STEPPATH[shape] || STEPLINEAR;
        return function(pts) {
          var path = "M" + roundX(pts[0][0]) + "," + roundY(pts[0][1]);
          var len = pts.length;
          for (var i = 1; i < len; i++) {
            path += onestep(pts[i - 1], pts[i], i === len - 1);
          }
          return path;
        };
      };
      function applyBackoff(pt, start) {
        var backoff = pt.backoff;
        var trace = pt.trace;
        var d = pt.d;
        var i = pt.i;
        if (backoff && trace && trace.marker && trace.marker.angle % 360 === 0 && trace.line && trace.line.shape !== "spline") {
          var arrayBackoff = Lib.isArrayOrTypedArray(backoff);
          var end = pt;
          var x1 = start ? start[0] : lastDrawnX || 0;
          var y1 = start ? start[1] : lastDrawnY || 0;
          var x2 = end[0];
          var y2 = end[1];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var t = Math.atan2(dy, dx);
          var b = arrayBackoff ? backoff[i] : backoff;
          if (b === "auto") {
            var endI = end.i;
            if (trace.type === "scatter") endI--;
            var endMarker = end.marker;
            var endMarkerSymbol = endMarker.symbol;
            if (Lib.isArrayOrTypedArray(endMarkerSymbol)) endMarkerSymbol = endMarkerSymbol[endI];
            var endMarkerSize = endMarker.size;
            if (Lib.isArrayOrTypedArray(endMarkerSize)) endMarkerSize = endMarkerSize[endI];
            b = endMarker ? drawing.symbolBackOffs[drawing.symbolNumber(endMarkerSymbol)] * endMarkerSize : 0;
            b += drawing.getMarkerStandoff(d[endI], trace) || 0;
          }
          var x = x2 - b * Math.cos(t);
          var y = y2 - b * Math.sin(t);
          if ((x <= x2 && x >= x1 || x >= x2 && x <= x1) && (y <= y2 && y >= y1 || y >= y2 && y <= y1)) {
            pt = [x, y];
          }
        }
        return pt;
      }
      drawing.applyBackoff = applyBackoff;
      drawing.makeTester = function() {
        var tester = Lib.ensureSingleById(d3.select("body"), "svg", "js-plotly-tester", function(s) {
          s.attr(xmlnsNamespaces.svgAttrs).style({
            position: "absolute",
            left: "-10000px",
            top: "-10000px",
            width: "9000px",
            height: "9000px",
            "z-index": "1"
          });
        });
        var testref = Lib.ensureSingle(tester, "path", "js-reference-point", function(s) {
          s.attr("d", "M0,0H1V1H0Z").style({
            "stroke-width": 0,
            fill: "black"
          });
        });
        drawing.tester = tester;
        drawing.testref = testref;
      };
      drawing.savedBBoxes = {};
      var savedBBoxesCount = 0;
      var maxSavedBBoxes = 1e4;
      drawing.bBox = function(node, inTester, hash) {
        if (!hash) hash = nodeHash(node);
        var out;
        if (hash) {
          out = drawing.savedBBoxes[hash];
          if (out) return Lib.extendFlat({}, out);
        } else if (node.childNodes.length === 1) {
          var innerNode = node.childNodes[0];
          hash = nodeHash(innerNode);
          if (hash) {
            var x = +innerNode.getAttribute("x") || 0;
            var y = +innerNode.getAttribute("y") || 0;
            var transform = innerNode.getAttribute("transform");
            if (!transform) {
              var innerBB = drawing.bBox(innerNode, false, hash);
              if (x) {
                innerBB.left += x;
                innerBB.right += x;
              }
              if (y) {
                innerBB.top += y;
                innerBB.bottom += y;
              }
              return innerBB;
            }
            hash += "~" + x + "~" + y + "~" + transform;
            out = drawing.savedBBoxes[hash];
            if (out) return Lib.extendFlat({}, out);
          }
        }
        var testNode, tester;
        if (inTester) {
          testNode = node;
        } else {
          tester = drawing.tester.node();
          testNode = node.cloneNode(true);
          tester.appendChild(testNode);
        }
        d3.select(testNode).attr("transform", null).call(svgTextUtils.positionText, 0, 0);
        var testRect = testNode.getBoundingClientRect();
        var refRect = drawing.testref.node().getBoundingClientRect();
        if (!inTester) tester.removeChild(testNode);
        var bb = {
          height: testRect.height,
          width: testRect.width,
          left: testRect.left - refRect.left,
          top: testRect.top - refRect.top,
          right: testRect.right - refRect.left,
          bottom: testRect.bottom - refRect.top
        };
        if (savedBBoxesCount >= maxSavedBBoxes) {
          drawing.savedBBoxes = {};
          savedBBoxesCount = 0;
        }
        if (hash) drawing.savedBBoxes[hash] = bb;
        savedBBoxesCount++;
        return Lib.extendFlat({}, bb);
      };
      function nodeHash(node) {
        var inputText = node.getAttribute("data-unformatted");
        if (inputText === null) return;
        return inputText + node.getAttribute("data-math") + node.getAttribute("text-anchor") + node.getAttribute("style");
      }
      drawing.setClipUrl = function(s, localId, gd) {
        s.attr("clip-path", getFullUrl(localId, gd));
      };
      function getFullUrl(localId, gd) {
        if (!localId) return null;
        var context = gd._context;
        var baseUrl = context._exportedPlot ? "" : context._baseUrl || "";
        return baseUrl ? "url('" + baseUrl + "#" + localId + "')" : "url(#" + localId + ")";
      }
      drawing.getTranslate = function(element) {
        var re = /.*\btranslate\((-?\d*\.?\d*)[^-\d]*(-?\d*\.?\d*)[^\d].*/;
        var getter = element.attr ? "attr" : "getAttribute";
        var transform = element[getter]("transform") || "";
        var translate = transform.replace(re, function(match, p1, p2) {
          return [p1, p2].join(" ");
        }).split(" ");
        return {
          x: +translate[0] || 0,
          y: +translate[1] || 0
        };
      };
      drawing.setTranslate = function(element, x, y) {
        var re = /(\btranslate\(.*?\);?)/;
        var getter = element.attr ? "attr" : "getAttribute";
        var setter = element.attr ? "attr" : "setAttribute";
        var transform = element[getter]("transform") || "";
        x = x || 0;
        y = y || 0;
        transform = transform.replace(re, "").trim();
        transform += strTranslate(x, y);
        transform = transform.trim();
        element[setter]("transform", transform);
        return transform;
      };
      drawing.getScale = function(element) {
        var re = /.*\bscale\((\d*\.?\d*)[^\d]*(\d*\.?\d*)[^\d].*/;
        var getter = element.attr ? "attr" : "getAttribute";
        var transform = element[getter]("transform") || "";
        var translate = transform.replace(re, function(match, p1, p2) {
          return [p1, p2].join(" ");
        }).split(" ");
        return {
          x: +translate[0] || 1,
          y: +translate[1] || 1
        };
      };
      drawing.setScale = function(element, x, y) {
        var re = /(\bscale\(.*?\);?)/;
        var getter = element.attr ? "attr" : "getAttribute";
        var setter = element.attr ? "attr" : "setAttribute";
        var transform = element[getter]("transform") || "";
        x = x || 1;
        y = y || 1;
        transform = transform.replace(re, "").trim();
        transform += "scale(" + x + "," + y + ")";
        transform = transform.trim();
        element[setter]("transform", transform);
        return transform;
      };
      var SCALE_RE = /\s*sc.*/;
      drawing.setPointGroupScale = function(selection, xScale, yScale) {
        xScale = xScale || 1;
        yScale = yScale || 1;
        if (!selection) return;
        var scale = xScale === 1 && yScale === 1 ? "" : "scale(" + xScale + "," + yScale + ")";
        selection.each(function() {
          var t = (this.getAttribute("transform") || "").replace(SCALE_RE, "");
          t += scale;
          t = t.trim();
          this.setAttribute("transform", t);
        });
      };
      var TEXT_POINT_LAST_TRANSLATION_RE = /translate\([^)]*\)\s*$/;
      drawing.setTextPointsScale = function(selection, xScale, yScale) {
        if (!selection) return;
        selection.each(function() {
          var transforms;
          var el = d3.select(this);
          var text = el.select("text");
          if (!text.node()) return;
          var x = parseFloat(text.attr("x") || 0);
          var y = parseFloat(text.attr("y") || 0);
          var existingTransform = (el.attr("transform") || "").match(TEXT_POINT_LAST_TRANSLATION_RE);
          if (xScale === 1 && yScale === 1) {
            transforms = [];
          } else {
            transforms = [
              strTranslate(x, y),
              "scale(" + xScale + "," + yScale + ")",
              strTranslate(-x, -y)
            ];
          }
          if (existingTransform) {
            transforms.push(existingTransform);
          }
          el.attr("transform", transforms.join(""));
        });
      };
      function getMarkerStandoff(d, trace) {
        var standoff;
        if (d) standoff = d.mf;
        if (standoff === void 0) {
          standoff = trace.marker ? trace.marker.standoff || 0 : 0;
        }
        if (!trace._geo && !trace._xA) {
          return -standoff;
        }
        return standoff;
      }
      drawing.getMarkerStandoff = getMarkerStandoff;
      var atan2 = Math.atan2;
      var cos = Math.cos;
      var sin = Math.sin;
      function rotate(t, xy) {
        var x = xy[0];
        var y = xy[1];
        return [
          x * cos(t) - y * sin(t),
          x * sin(t) + y * cos(t)
        ];
      }
      var previousLon;
      var previousLat;
      var previousX;
      var previousY;
      var previousI;
      var previousTraceUid;
      function getMarkerAngle(d, trace) {
        var angle = d.ma;
        if (angle === void 0) {
          angle = trace.marker.angle;
          if (!angle || Lib.isArrayOrTypedArray(angle)) {
            angle = 0;
          }
        }
        var x, y;
        var ref = trace.marker.angleref;
        if (ref === "previous" || ref === "north") {
          if (trace._geo) {
            var p = trace._geo.project(d.lonlat);
            x = p[0];
            y = p[1];
          } else {
            var xa = trace._xA;
            var ya = trace._yA;
            if (xa && ya) {
              x = xa.c2p(d.x);
              y = ya.c2p(d.y);
            } else {
              return 90;
            }
          }
          if (trace._geo) {
            var lon = d.lonlat[0];
            var lat = d.lonlat[1];
            var north = trace._geo.project([
              lon,
              lat + 1e-5
              // epsilon
            ]);
            var east = trace._geo.project([
              lon + 1e-5,
              // epsilon
              lat
            ]);
            var u = atan2(
              east[1] - y,
              east[0] - x
            );
            var v = atan2(
              north[1] - y,
              north[0] - x
            );
            var t;
            if (ref === "north") {
              t = angle / 180 * Math.PI;
            } else if (ref === "previous") {
              var lon1 = lon / 180 * Math.PI;
              var lat1 = lat / 180 * Math.PI;
              var lon2 = previousLon / 180 * Math.PI;
              var lat2 = previousLat / 180 * Math.PI;
              var dLon = lon2 - lon1;
              var deltaY = cos(lat2) * sin(dLon);
              var deltaX = sin(lat2) * cos(lat1) - cos(lat2) * sin(lat1) * cos(dLon);
              t = -atan2(
                deltaY,
                deltaX
              ) - Math.PI;
              previousLon = lon;
              previousLat = lat;
            }
            var A = rotate(u, [cos(t), 0]);
            var B = rotate(v, [sin(t), 0]);
            angle = atan2(
              A[1] + B[1],
              A[0] + B[0]
            ) / Math.PI * 180;
            if (ref === "previous" && !(previousTraceUid === trace.uid && d.i === previousI + 1)) {
              angle = null;
            }
          }
          if (ref === "previous" && !trace._geo) {
            if (previousTraceUid === trace.uid && d.i === previousI + 1 && isNumeric(x) && isNumeric(y)) {
              var dX = x - previousX;
              var dY = y - previousY;
              var shape = trace.line ? trace.line.shape || "" : "";
              var lastShapeChar = shape.slice(shape.length - 1);
              if (lastShapeChar === "h") dY = 0;
              if (lastShapeChar === "v") dX = 0;
              angle += atan2(dY, dX) / Math.PI * 180 + 90;
            } else {
              angle = null;
            }
          }
        }
        previousX = x;
        previousY = y;
        previousI = d.i;
        previousTraceUid = trace.uid;
        return angle;
      }
      drawing.getMarkerAngle = getMarkerAngle;
    }
  });

  // src/components/titles/index.js
  var require_titles = __commonJS({
    "src/components/titles/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Plots = require_plots();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Drawing = require_drawing();
      var Color = require_color();
      var svgTextUtils = require_svg_text_utils();
      var interactConstants = require_interactions();
      var OPPOSITE_SIDE = require_alignment().OPPOSITE_SIDE;
      var numStripRE = / [XY][0-9]* /;
      var SUBTITLE_PADDING_MATHJAX_EM = 1.6;
      var SUBTITLE_PADDING_EM = 1.6;
      function draw(gd, titleClass, options) {
        var fullLayout = gd._fullLayout;
        var cont = options.propContainer;
        var prop = options.propName;
        var placeholder = options.placeholder;
        var traceIndex = options.traceIndex;
        var avoid = options.avoid || {};
        var attributes = options.attributes;
        var transform = options.transform;
        var group = options.containerGroup;
        var opacity = 1;
        var title = cont.title;
        var txt = (title && title.text ? title.text : "").trim();
        var titleIsPlaceholder = false;
        var font = title && title.font ? title.font : {};
        var fontFamily = font.family;
        var fontSize = font.size;
        var fontColor = font.color;
        var fontWeight = font.weight;
        var fontStyle = font.style;
        var fontVariant = font.variant;
        var fontTextcase = font.textcase;
        var fontLineposition = font.lineposition;
        var fontShadow = font.shadow;
        var subtitleProp = options.subtitlePropName;
        var subtitleEnabled = !!subtitleProp;
        var subtitlePlaceholder = options.subtitlePlaceholder;
        var subtitle = (cont.title || {}).subtitle || { text: "", font: {} };
        var subtitleTxt = subtitle.text.trim();
        var subtitleIsPlaceholder = false;
        var subtitleOpacity = 1;
        var subtitleFont = subtitle.font;
        var subFontFamily = subtitleFont.family;
        var subFontSize = subtitleFont.size;
        var subFontColor = subtitleFont.color;
        var subFontWeight = subtitleFont.weight;
        var subFontStyle = subtitleFont.style;
        var subFontVariant = subtitleFont.variant;
        var subFontTextcase = subtitleFont.textcase;
        var subFontLineposition = subtitleFont.lineposition;
        var subFontShadow = subtitleFont.shadow;
        var editAttr;
        if (prop === "title.text") editAttr = "titleText";
        else if (prop.indexOf("axis") !== -1) editAttr = "axisTitleText";
        else if (prop.indexOf("colorbar" !== -1)) editAttr = "colorbarTitleText";
        var editable = gd._context.edits[editAttr];
        function matchesPlaceholder(text, placeholder2) {
          if (text === void 0 || placeholder2 === void 0) return false;
          return text.replace(numStripRE, " % ") === placeholder2.replace(numStripRE, " % ");
        }
        if (txt === "") opacity = 0;
        else if (matchesPlaceholder(txt, placeholder)) {
          if (!editable) txt = "";
          opacity = 0.2;
          titleIsPlaceholder = true;
        }
        if (subtitleEnabled) {
          if (subtitleTxt === "") subtitleOpacity = 0;
          else if (matchesPlaceholder(subtitleTxt, subtitlePlaceholder)) {
            if (!editable) subtitleTxt = "";
            subtitleOpacity = 0.2;
            subtitleIsPlaceholder = true;
          }
        }
        if (options._meta) {
          txt = Lib.templateString(txt, options._meta);
        } else if (fullLayout._meta) {
          txt = Lib.templateString(txt, fullLayout._meta);
        }
        var elShouldExist = txt || subtitleTxt || editable;
        var hColorbarMoveTitle;
        if (!group) {
          group = Lib.ensureSingle(fullLayout._infolayer, "g", "g-" + titleClass);
          hColorbarMoveTitle = fullLayout._hColorbarMoveTitle;
        }
        var el = group.selectAll("text." + titleClass).data(elShouldExist ? [0] : []);
        el.enter().append("text");
        el.text(txt).attr("class", titleClass);
        el.exit().remove();
        var subtitleEl = null;
        var subtitleClass = titleClass + "-subtitle";
        var subtitleElShouldExist = subtitleTxt || editable;
        if (subtitleEnabled && subtitleElShouldExist) {
          subtitleEl = group.selectAll("text." + subtitleClass).data(subtitleElShouldExist ? [0] : []);
          subtitleEl.enter().append("text");
          subtitleEl.text(subtitleTxt).attr("class", subtitleClass);
          subtitleEl.exit().remove();
        }
        if (!elShouldExist) return group;
        function titleLayout(titleEl, subtitleEl2) {
          Lib.syncOrAsync([drawTitle, scootTitle], { title: titleEl, subtitle: subtitleEl2 });
        }
        function drawTitle(titleAndSubtitleEls) {
          var titleEl = titleAndSubtitleEls.title;
          var subtitleEl2 = titleAndSubtitleEls.subtitle;
          var transformVal;
          if (!transform && hColorbarMoveTitle) {
            transform = {};
          }
          if (transform) {
            transformVal = "";
            if (transform.rotate) {
              transformVal += "rotate(" + [transform.rotate, attributes.x, attributes.y] + ")";
            }
            if (transform.offset || hColorbarMoveTitle) {
              transformVal += strTranslate(0, (transform.offset || 0) - (hColorbarMoveTitle || 0));
            }
          } else {
            transformVal = null;
          }
          titleEl.attr("transform", transformVal);
          function adjustSubtitlePosition(titleElMathGroup2) {
            if (!titleElMathGroup2) return;
            var subtitleElement = d3.select(titleElMathGroup2.node().parentNode).select("." + subtitleClass);
            if (!subtitleElement.empty()) {
              var titleElMathBbox2 = titleElMathGroup2.node().getBBox();
              if (titleElMathBbox2.height) {
                var subtitleY3 = titleElMathBbox2.y + titleElMathBbox2.height + SUBTITLE_PADDING_MATHJAX_EM * subFontSize;
                subtitleElement.attr("y", subtitleY3);
              }
            }
          }
          titleEl.style("opacity", opacity * Color.opacity(fontColor)).call(Drawing.font, {
            color: Color.rgb(fontColor),
            size: d3.round(fontSize, 2),
            family: fontFamily,
            weight: fontWeight,
            style: fontStyle,
            variant: fontVariant,
            textcase: fontTextcase,
            shadow: fontShadow,
            lineposition: fontLineposition
          }).attr(attributes).call(svgTextUtils.convertToTspans, gd, adjustSubtitlePosition);
          if (subtitleEl2) {
            var titleElMathGroup = group.select("." + titleClass + "-math-group");
            var titleElBbox2 = titleEl.node().getBBox();
            var titleElMathBbox = titleElMathGroup.node() ? titleElMathGroup.node().getBBox() : void 0;
            var subtitleY2 = titleElMathBbox ? titleElMathBbox.y + titleElMathBbox.height + SUBTITLE_PADDING_MATHJAX_EM * subFontSize : titleElBbox2.y + titleElBbox2.height + SUBTITLE_PADDING_EM * subFontSize;
            var subtitleAttributes = Lib.extendFlat({}, attributes, {
              y: subtitleY2
            });
            subtitleEl2.attr("transform", transformVal);
            subtitleEl2.style("opacity", subtitleOpacity * Color.opacity(subFontColor)).call(Drawing.font, {
              color: Color.rgb(subFontColor),
              size: d3.round(subFontSize, 2),
              family: subFontFamily,
              weight: subFontWeight,
              style: subFontStyle,
              variant: subFontVariant,
              textcase: subFontTextcase,
              shadow: subFontShadow,
              lineposition: subFontLineposition
            }).attr(subtitleAttributes).call(svgTextUtils.convertToTspans, gd);
          }
          return Plots.previousPromises(gd);
        }
        function scootTitle(titleAndSubtitleEls) {
          var titleElIn = titleAndSubtitleEls.title;
          var titleGroup = d3.select(titleElIn.node().parentNode);
          if (avoid && avoid.selection && avoid.side && txt) {
            titleGroup.attr("transform", null);
            var backside = OPPOSITE_SIDE[avoid.side];
            var shiftSign = avoid.side === "left" || avoid.side === "top" ? -1 : 1;
            var pad = isNumeric(avoid.pad) ? avoid.pad : 2;
            var titlebb = Drawing.bBox(titleGroup.node());
            var reservedMargins = { t: 0, b: 0, l: 0, r: 0 };
            var margins = gd._fullLayout._reservedMargin;
            for (var key in margins) {
              for (var side in margins[key]) {
                var val = margins[key][side];
                reservedMargins[side] = Math.max(reservedMargins[side], val);
              }
            }
            var paperbb = {
              left: reservedMargins.l,
              top: reservedMargins.t,
              right: fullLayout.width - reservedMargins.r,
              bottom: fullLayout.height - reservedMargins.b
            };
            var maxshift = avoid.maxShift || shiftSign * (paperbb[avoid.side] - titlebb[avoid.side]);
            var shift = 0;
            if (maxshift < 0) {
              shift = maxshift;
            } else {
              var offsetLeft = avoid.offsetLeft || 0;
              var offsetTop = avoid.offsetTop || 0;
              titlebb.left -= offsetLeft;
              titlebb.right -= offsetLeft;
              titlebb.top -= offsetTop;
              titlebb.bottom -= offsetTop;
              avoid.selection.each(function() {
                var avoidbb = Drawing.bBox(this);
                if (Lib.bBoxIntersect(titlebb, avoidbb, pad)) {
                  shift = Math.max(shift, shiftSign * (avoidbb[avoid.side] - titlebb[backside]) + pad);
                }
              });
              shift = Math.min(maxshift, shift);
              cont._titleScoot = Math.abs(shift);
            }
            if (shift > 0 || maxshift < 0) {
              var shiftTemplate = {
                left: [-shift, 0],
                right: [shift, 0],
                top: [0, -shift],
                bottom: [0, shift]
              }[avoid.side];
              titleGroup.attr("transform", strTranslate(shiftTemplate[0], shiftTemplate[1]));
            }
          }
        }
        el.call(titleLayout, subtitleEl);
        function setPlaceholder(element, placeholderText) {
          element.text(placeholderText).on("mouseover.opacity", function() {
            d3.select(this).transition().duration(interactConstants.SHOW_PLACEHOLDER).style("opacity", 1);
          }).on("mouseout.opacity", function() {
            d3.select(this).transition().duration(interactConstants.HIDE_PLACEHOLDER).style("opacity", 0);
          });
        }
        if (editable) {
          if (!txt) {
            setPlaceholder(el, placeholder);
            titleIsPlaceholder = true;
          } else el.on(".opacity", null);
          el.call(svgTextUtils.makeEditable, { gd }).on("edit", function(text) {
            if (traceIndex !== void 0) {
              Registry.call("_guiRestyle", gd, prop, text, traceIndex);
            } else {
              Registry.call("_guiRelayout", gd, prop, text);
            }
          }).on("cancel", function() {
            this.text(this.attr("data-unformatted")).call(titleLayout);
          }).on("input", function(d) {
            this.text(d || " ").call(svgTextUtils.positionText, attributes.x, attributes.y);
          });
          if (subtitleEnabled) {
            if (subtitleEnabled && !txt) {
              var titleElBbox = el.node().getBBox();
              var subtitleY = titleElBbox.y + titleElBbox.height + SUBTITLE_PADDING_EM * subFontSize;
              subtitleEl.attr("y", subtitleY);
            }
            if (!subtitleTxt) {
              setPlaceholder(subtitleEl, subtitlePlaceholder);
              subtitleIsPlaceholder = true;
            } else subtitleEl.on(".opacity", null);
            subtitleEl.call(svgTextUtils.makeEditable, { gd }).on("edit", function(text) {
              Registry.call("_guiRelayout", gd, "title.subtitle.text", text);
            }).on("cancel", function() {
              this.text(this.attr("data-unformatted")).call(titleLayout);
            }).on("input", function(d) {
              this.text(d || " ").call(svgTextUtils.positionText, subtitleEl.attr("x"), subtitleEl.attr("y"));
            });
          }
        }
        el.classed("js-placeholder", titleIsPlaceholder);
        if (subtitleEl) subtitleEl.classed("js-placeholder", subtitleIsPlaceholder);
        return group;
      }
      module.exports = {
        draw,
        SUBTITLE_PADDING_EM,
        SUBTITLE_PADDING_MATHJAX_EM
      };
    }
  });

  // src/plots/cartesian/set_convert.js
  var require_set_convert = __commonJS({
    "src/plots/cartesian/set_convert.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var utcFormat = require_d3_time_format().utcFormat;
      var Lib = require_lib();
      var numberFormat = Lib.numberFormat;
      var isNumeric = require_fast_isnumeric();
      var cleanNumber = Lib.cleanNumber;
      var ms2DateTime = Lib.ms2DateTime;
      var dateTime2ms = Lib.dateTime2ms;
      var ensureNumber = Lib.ensureNumber;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var numConstants = require_numerical();
      var FP_SAFE = numConstants.FP_SAFE;
      var BADNUM = numConstants.BADNUM;
      var LOG_CLIP = numConstants.LOG_CLIP;
      var ONEWEEK = numConstants.ONEWEEK;
      var ONEDAY = numConstants.ONEDAY;
      var ONEHOUR = numConstants.ONEHOUR;
      var ONEMIN = numConstants.ONEMIN;
      var ONESEC = numConstants.ONESEC;
      var axisIds = require_axis_ids();
      var constants = require_constants2();
      var HOUR_PATTERN = constants.HOUR_PATTERN;
      var WEEKDAY_PATTERN = constants.WEEKDAY_PATTERN;
      function fromLog(v) {
        return Math.pow(10, v);
      }
      function isValidCategory(v) {
        return v !== null && v !== void 0;
      }
      module.exports = function setConvert(ax, fullLayout) {
        fullLayout = fullLayout || {};
        var axId = ax._id || "x";
        var axLetter = axId.charAt(0);
        function toLog(v, clip) {
          if (v > 0) return Math.log(v) / Math.LN10;
          else if (v <= 0 && clip && ax.range && ax.range.length === 2) {
            var r0 = ax.range[0];
            var r1 = ax.range[1];
            return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));
          } else return BADNUM;
        }
        function dt2ms(v, _, calendar, opts) {
          if ((opts || {}).msUTC && isNumeric(v)) {
            return +v;
          }
          var ms = dateTime2ms(v, calendar || ax.calendar);
          if (ms === BADNUM) {
            if (isNumeric(v)) {
              v = +v;
              var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);
              var msRounded = Math.round(v - msecTenths / 10);
              ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;
            } else return BADNUM;
          }
          return ms;
        }
        function ms2dt(v, r, calendar) {
          return ms2DateTime(v, r, calendar || ax.calendar);
        }
        function getCategoryName(v) {
          return ax._categories[Math.round(v)];
        }
        function setCategoryIndex(v) {
          if (isValidCategory(v)) {
            if (ax._categoriesMap === void 0) {
              ax._categoriesMap = {};
            }
            if (ax._categoriesMap[v] !== void 0) {
              return ax._categoriesMap[v];
            } else {
              ax._categories.push(typeof v === "number" ? String(v) : v);
              var curLength = ax._categories.length - 1;
              ax._categoriesMap[v] = curLength;
              return curLength;
            }
          }
          return BADNUM;
        }
        function setMultiCategoryIndex(arrayIn, len) {
          var arrayOut = new Array(len);
          for (var i = 0; i < len; i++) {
            var v0 = (arrayIn[0] || [])[i];
            var v1 = (arrayIn[1] || [])[i];
            arrayOut[i] = getCategoryIndex([v0, v1]);
          }
          return arrayOut;
        }
        function getCategoryIndex(v) {
          if (ax._categoriesMap) {
            return ax._categoriesMap[v];
          }
        }
        function getCategoryPosition(v) {
          var index = getCategoryIndex(v);
          if (index !== void 0) return index;
          if (isNumeric(v)) return +v;
        }
        function getRangePosition(v) {
          return isNumeric(v) ? +v : getCategoryIndex(v);
        }
        function _l2p(v, m, b) {
          return d3.round(b + m * v, 2);
        }
        function _p2l(px, m, b) {
          return (px - b) / m;
        }
        var l2p = function l2p2(v) {
          if (!isNumeric(v)) return BADNUM;
          return _l2p(v, ax._m, ax._b);
        };
        var p2l = function(px) {
          return _p2l(px, ax._m, ax._b);
        };
        if (ax.rangebreaks) {
          var isY = axLetter === "y";
          l2p = function(v) {
            if (!isNumeric(v)) return BADNUM;
            var len = ax._rangebreaks.length;
            if (!len) return _l2p(v, ax._m, ax._b);
            var flip = isY;
            if (ax.range[0] > ax.range[1]) flip = !flip;
            var signAx = flip ? -1 : 1;
            var pos = signAx * v;
            var q = 0;
            for (var i = 0; i < len; i++) {
              var min = signAx * ax._rangebreaks[i].min;
              var max = signAx * ax._rangebreaks[i].max;
              if (pos < min) break;
              if (pos > max) q = i + 1;
              else {
                q = pos < (min + max) / 2 ? i : i + 1;
                break;
              }
            }
            var b2 = ax._B[q] || 0;
            if (!isFinite(b2)) return 0;
            return _l2p(v, ax._m2, b2);
          };
          p2l = function(px) {
            var len = ax._rangebreaks.length;
            if (!len) return _p2l(px, ax._m, ax._b);
            var q = 0;
            for (var i = 0; i < len; i++) {
              if (px < ax._rangebreaks[i].pmin) break;
              if (px > ax._rangebreaks[i].pmax) q = i + 1;
            }
            return _p2l(px, ax._m2, ax._B[q]);
          };
        }
        ax.c2l = ax.type === "log" ? toLog : ensureNumber;
        ax.l2c = ax.type === "log" ? fromLog : ensureNumber;
        ax.l2p = l2p;
        ax.p2l = p2l;
        ax.c2p = ax.type === "log" ? function(v, clip) {
          return l2p(toLog(v, clip));
        } : l2p;
        ax.p2c = ax.type === "log" ? function(px) {
          return fromLog(p2l(px));
        } : p2l;
        if (["linear", "-"].indexOf(ax.type) !== -1) {
          ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;
          ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;
          ax.d2p = ax.r2p = function(v) {
            return ax.l2p(cleanNumber(v));
          };
          ax.p2d = ax.p2r = p2l;
          ax.cleanPos = ensureNumber;
        } else if (ax.type === "log") {
          ax.d2r = ax.d2l = function(v, clip) {
            return toLog(cleanNumber(v), clip);
          };
          ax.r2d = ax.r2c = function(v) {
            return fromLog(cleanNumber(v));
          };
          ax.d2c = ax.r2l = cleanNumber;
          ax.c2d = ax.l2r = ensureNumber;
          ax.c2r = toLog;
          ax.l2d = fromLog;
          ax.d2p = function(v, clip) {
            return ax.l2p(ax.d2r(v, clip));
          };
          ax.p2d = function(px) {
            return fromLog(p2l(px));
          };
          ax.r2p = function(v) {
            return ax.l2p(cleanNumber(v));
          };
          ax.p2r = p2l;
          ax.cleanPos = ensureNumber;
        } else if (ax.type === "date") {
          ax.d2r = ax.r2d = Lib.identity;
          ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;
          ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;
          ax.d2p = ax.r2p = function(v, _, calendar) {
            return ax.l2p(dt2ms(v, 0, calendar));
          };
          ax.p2d = ax.p2r = function(px, r, calendar) {
            return ms2dt(p2l(px), r, calendar);
          };
          ax.cleanPos = function(v) {
            return Lib.cleanDate(v, BADNUM, ax.calendar);
          };
        } else if (ax.type === "category") {
          ax.d2c = ax.d2l = setCategoryIndex;
          ax.r2d = ax.c2d = ax.l2d = getCategoryName;
          ax.d2r = ax.d2l_noadd = getCategoryPosition;
          ax.r2c = function(v) {
            var index = getRangePosition(v);
            return index !== void 0 ? index : ax.fraction2r(0.5);
          };
          ax.l2r = ax.c2r = ensureNumber;
          ax.r2l = getRangePosition;
          ax.d2p = function(v) {
            return ax.l2p(ax.r2c(v));
          };
          ax.p2d = function(px) {
            return getCategoryName(p2l(px));
          };
          ax.r2p = ax.d2p;
          ax.p2r = p2l;
          ax.cleanPos = function(v) {
            if (typeof v === "string" && v !== "") return v;
            return ensureNumber(v);
          };
        } else if (ax.type === "multicategory") {
          ax.r2d = ax.c2d = ax.l2d = getCategoryName;
          ax.d2r = ax.d2l_noadd = getCategoryPosition;
          ax.r2c = function(v) {
            var index = getCategoryPosition(v);
            return index !== void 0 ? index : ax.fraction2r(0.5);
          };
          ax.r2c_just_indices = getCategoryIndex;
          ax.l2r = ax.c2r = ensureNumber;
          ax.r2l = getCategoryPosition;
          ax.d2p = function(v) {
            return ax.l2p(ax.r2c(v));
          };
          ax.p2d = function(px) {
            return getCategoryName(p2l(px));
          };
          ax.r2p = ax.d2p;
          ax.p2r = p2l;
          ax.cleanPos = function(v) {
            if (Array.isArray(v) || typeof v === "string" && v !== "") return v;
            return ensureNumber(v);
          };
          ax.setupMultiCategory = function(fullData) {
            var traceIndices = ax._traceIndices;
            var i, j;
            var group = ax._matchGroup;
            if (group && ax._categories.length === 0) {
              for (var axId2 in group) {
                if (axId2 !== axId) {
                  var ax2 = fullLayout[axisIds.id2name(axId2)];
                  traceIndices = traceIndices.concat(ax2._traceIndices);
                }
              }
            }
            var seen = [[0, {}], [0, {}]];
            var list = [];
            for (i = 0; i < traceIndices.length; i++) {
              var trace = fullData[traceIndices[i]];
              if (axLetter in trace) {
                var arrayIn = trace[axLetter];
                var len = trace._length || Lib.minRowLength(arrayIn);
                if (isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {
                  for (j = 0; j < len; j++) {
                    var v0 = arrayIn[0][j];
                    var v1 = arrayIn[1][j];
                    if (isValidCategory(v0) && isValidCategory(v1)) {
                      list.push([v0, v1]);
                      if (!(v0 in seen[0][1])) {
                        seen[0][1][v0] = seen[0][0]++;
                      }
                      if (!(v1 in seen[1][1])) {
                        seen[1][1][v1] = seen[1][0]++;
                      }
                    }
                  }
                }
              }
            }
            list.sort(function(a, b) {
              var ind0 = seen[0][1];
              var d = ind0[a[0]] - ind0[b[0]];
              if (d) return d;
              var ind1 = seen[1][1];
              return ind1[a[1]] - ind1[b[1]];
            });
            for (i = 0; i < list.length; i++) {
              setCategoryIndex(list[i]);
            }
          };
        }
        ax.fraction2r = function(v) {
          var rl0 = ax.r2l(ax.range[0]);
          var rl1 = ax.r2l(ax.range[1]);
          return ax.l2r(rl0 + v * (rl1 - rl0));
        };
        ax.r2fraction = function(v) {
          var rl0 = ax.r2l(ax.range[0]);
          var rl1 = ax.r2l(ax.range[1]);
          return (ax.r2l(v) - rl0) / (rl1 - rl0);
        };
        ax.limitRange = function(rangeAttr) {
          var minallowed = ax.minallowed;
          var maxallowed = ax.maxallowed;
          if (minallowed === void 0 && maxallowed === void 0) return;
          if (!rangeAttr) rangeAttr = "range";
          var range = Lib.nestedProperty(ax, rangeAttr).get();
          var rng = Lib.simpleMap(range, ax.r2l);
          var axrev = rng[1] < rng[0];
          if (axrev) rng.reverse();
          var bounds = Lib.simpleMap([minallowed, maxallowed], ax.r2l);
          if (minallowed !== void 0 && rng[0] < bounds[0]) range[axrev ? 1 : 0] = minallowed;
          if (maxallowed !== void 0 && rng[1] > bounds[1]) range[axrev ? 0 : 1] = maxallowed;
          if (range[0] === range[1]) {
            var minL = ax.l2r(minallowed);
            var maxL = ax.l2r(maxallowed);
            if (minallowed !== void 0) {
              var _max = minL + 1;
              if (maxallowed !== void 0) _max = Math.min(_max, maxL);
              range[axrev ? 1 : 0] = _max;
            }
            if (maxallowed !== void 0) {
              var _min = maxL + 1;
              if (minallowed !== void 0) _min = Math.max(_min, minL);
              range[axrev ? 0 : 1] = _min;
            }
          }
        };
        ax.cleanRange = function(rangeAttr, opts) {
          ax._cleanRange(rangeAttr, opts);
          ax.limitRange(rangeAttr);
        };
        ax._cleanRange = function(rangeAttr, opts) {
          if (!opts) opts = {};
          if (!rangeAttr) rangeAttr = "range";
          var range = Lib.nestedProperty(ax, rangeAttr).get();
          var i, dflt;
          if (ax.type === "date") dflt = Lib.dfltRange(ax.calendar);
          else if (axLetter === "y") dflt = constants.DFLTRANGEY;
          else if (ax._name === "realaxis") dflt = [0, 1];
          else dflt = opts.dfltRange || constants.DFLTRANGEX;
          dflt = dflt.slice();
          if (ax.rangemode === "tozero" || ax.rangemode === "nonnegative") {
            dflt[0] = 0;
          }
          if (!range || range.length !== 2) {
            Lib.nestedProperty(ax, rangeAttr).set(dflt);
            return;
          }
          var nullRange0 = range[0] === null;
          var nullRange1 = range[1] === null;
          if (ax.type === "date" && !ax.autorange) {
            range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);
            range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);
          }
          for (i = 0; i < 2; i++) {
            if (ax.type === "date") {
              if (!Lib.isDateTime(range[i], ax.calendar)) {
                ax[rangeAttr] = dflt;
                break;
              }
              if (ax.r2l(range[0]) === ax.r2l(range[1])) {
                var linCenter = Lib.constrain(
                  ax.r2l(range[0]),
                  Lib.MIN_MS + 1e3,
                  Lib.MAX_MS - 1e3
                );
                range[0] = ax.l2r(linCenter - 1e3);
                range[1] = ax.l2r(linCenter + 1e3);
                break;
              }
            } else {
              if (!isNumeric(range[i])) {
                if (!(nullRange0 || nullRange1) && isNumeric(range[1 - i])) {
                  range[i] = range[1 - i] * (i ? 10 : 0.1);
                } else {
                  ax[rangeAttr] = dflt;
                  break;
                }
              }
              if (range[i] < -FP_SAFE) range[i] = -FP_SAFE;
              else if (range[i] > FP_SAFE) range[i] = FP_SAFE;
              if (range[0] === range[1]) {
                var inc = Math.max(1, Math.abs(range[0] * 1e-6));
                range[0] -= inc;
                range[1] += inc;
              }
            }
          }
        };
        ax.setScale = function(usePrivateRange) {
          var gs = fullLayout._size;
          if (ax.overlaying) {
            var ax2 = axisIds.getFromId({ _fullLayout: fullLayout }, ax.overlaying);
            ax.domain = ax2.domain;
          }
          var rangeAttr = usePrivateRange && ax._r ? "_r" : "range";
          var calendar = ax.calendar;
          ax.cleanRange(rangeAttr);
          var rl0 = ax.r2l(ax[rangeAttr][0], calendar);
          var rl1 = ax.r2l(ax[rangeAttr][1], calendar);
          var isY2 = axLetter === "y";
          if (isY2) {
            ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;
            ax._length = gs.h * (ax.domain[1] - ax.domain[0]);
            ax._m = ax._length / (rl0 - rl1);
            ax._b = -ax._m * rl1;
          } else {
            ax._offset = gs.l + ax.domain[0] * gs.w;
            ax._length = gs.w * (ax.domain[1] - ax.domain[0]);
            ax._m = ax._length / (rl1 - rl0);
            ax._b = -ax._m * rl0;
          }
          ax._rangebreaks = [];
          ax._lBreaks = 0;
          ax._m2 = 0;
          ax._B = [];
          if (ax.rangebreaks) {
            var i, brk;
            ax._rangebreaks = ax.locateBreaks(
              Math.min(rl0, rl1),
              Math.max(rl0, rl1)
            );
            if (ax._rangebreaks.length) {
              for (i = 0; i < ax._rangebreaks.length; i++) {
                brk = ax._rangebreaks[i];
                ax._lBreaks += Math.abs(brk.max - brk.min);
              }
              var flip = isY2;
              if (rl0 > rl1) flip = !flip;
              if (flip) ax._rangebreaks.reverse();
              var sign = flip ? -1 : 1;
              ax._m2 = sign * ax._length / (Math.abs(rl1 - rl0) - ax._lBreaks);
              ax._B.push(-ax._m2 * (isY2 ? rl1 : rl0));
              for (i = 0; i < ax._rangebreaks.length; i++) {
                brk = ax._rangebreaks[i];
                ax._B.push(
                  ax._B[ax._B.length - 1] - sign * ax._m2 * (brk.max - brk.min)
                );
              }
              for (i = 0; i < ax._rangebreaks.length; i++) {
                brk = ax._rangebreaks[i];
                brk.pmin = l2p(brk.min);
                brk.pmax = l2p(brk.max);
              }
            }
          }
          if (!isFinite(ax._m) || !isFinite(ax._b) || ax._length < 0) {
            fullLayout._replotting = false;
            throw new Error("Something went wrong with axis scaling");
          }
        };
        ax.maskBreaks = function(v) {
          var rangebreaksIn = ax.rangebreaks || [];
          var bnds, b0, b1, vb, vDate;
          if (!rangebreaksIn._cachedPatterns) {
            rangebreaksIn._cachedPatterns = rangebreaksIn.map(function(brk2) {
              return brk2.enabled && brk2.bounds ? Lib.simpleMap(
                brk2.bounds,
                brk2.pattern ? cleanNumber : ax.d2c
                // case of pattern: ''
              ) : null;
            });
          }
          if (!rangebreaksIn._cachedValues) {
            rangebreaksIn._cachedValues = rangebreaksIn.map(function(brk2) {
              return brk2.enabled && brk2.values ? Lib.simpleMap(brk2.values, ax.d2c).sort(Lib.sorterAsc) : null;
            });
          }
          for (var i = 0; i < rangebreaksIn.length; i++) {
            var brk = rangebreaksIn[i];
            if (brk.enabled) {
              if (brk.bounds) {
                var pattern = brk.pattern;
                bnds = rangebreaksIn._cachedPatterns[i];
                b0 = bnds[0];
                b1 = bnds[1];
                switch (pattern) {
                  case WEEKDAY_PATTERN:
                    vDate = new Date(v);
                    vb = vDate.getUTCDay();
                    if (b0 > b1) {
                      b1 += 7;
                      if (vb < b0) vb += 7;
                    }
                    break;
                  case HOUR_PATTERN:
                    vDate = new Date(v);
                    var hours = vDate.getUTCHours();
                    var minutes = vDate.getUTCMinutes();
                    var seconds = vDate.getUTCSeconds();
                    var milliseconds = vDate.getUTCMilliseconds();
                    vb = hours + (minutes / 60 + seconds / 3600 + milliseconds / 36e5);
                    if (b0 > b1) {
                      b1 += 24;
                      if (vb < b0) vb += 24;
                    }
                    break;
                  case "":
                    vb = v;
                    break;
                }
                if (vb >= b0 && vb < b1) return BADNUM;
              } else {
                var vals = rangebreaksIn._cachedValues[i];
                for (var j = 0; j < vals.length; j++) {
                  b0 = vals[j];
                  b1 = b0 + brk.dvalue;
                  if (v >= b0 && v < b1) return BADNUM;
                }
              }
            }
          }
          return v;
        };
        ax.locateBreaks = function(r0, r1) {
          var i, bnds, b0, b1;
          var rangebreaksOut = [];
          if (!ax.rangebreaks) return rangebreaksOut;
          var rangebreaksIn = ax.rangebreaks.slice().sort(function(a, b) {
            if (a.pattern === WEEKDAY_PATTERN && b.pattern === HOUR_PATTERN) return -1;
            if (b.pattern === WEEKDAY_PATTERN && a.pattern === HOUR_PATTERN) return 1;
            return 0;
          });
          var addBreak = function(min, max) {
            min = Lib.constrain(min, r0, r1);
            max = Lib.constrain(max, r0, r1);
            if (min === max) return;
            var isNewBreak = true;
            for (var j2 = 0; j2 < rangebreaksOut.length; j2++) {
              var brkj = rangebreaksOut[j2];
              if (min < brkj.max && max >= brkj.min) {
                if (min < brkj.min) {
                  brkj.min = min;
                }
                if (max > brkj.max) {
                  brkj.max = max;
                }
                isNewBreak = false;
              }
            }
            if (isNewBreak) {
              rangebreaksOut.push({ min, max });
            }
          };
          for (i = 0; i < rangebreaksIn.length; i++) {
            var brk = rangebreaksIn[i];
            if (brk.enabled) {
              if (brk.bounds) {
                var t0 = r0;
                var t1 = r1;
                if (brk.pattern) {
                  t0 = Math.floor(t0);
                }
                bnds = Lib.simpleMap(brk.bounds, brk.pattern ? cleanNumber : ax.r2l);
                b0 = bnds[0];
                b1 = bnds[1];
                var t0Date = new Date(t0);
                var bndDelta;
                var step;
                switch (brk.pattern) {
                  case WEEKDAY_PATTERN:
                    step = ONEWEEK;
                    bndDelta = ((b1 < b0 ? 7 : 0) + (b1 - b0)) * ONEDAY;
                    t0 += b0 * ONEDAY - (t0Date.getUTCDay() * ONEDAY + t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());
                    break;
                  case HOUR_PATTERN:
                    step = ONEDAY;
                    bndDelta = ((b1 < b0 ? 24 : 0) + (b1 - b0)) * ONEHOUR;
                    t0 += b0 * ONEHOUR - (t0Date.getUTCHours() * ONEHOUR + t0Date.getUTCMinutes() * ONEMIN + t0Date.getUTCSeconds() * ONESEC + t0Date.getUTCMilliseconds());
                    break;
                  default:
                    t0 = Math.min(bnds[0], bnds[1]);
                    t1 = Math.max(bnds[0], bnds[1]);
                    step = t1 - t0;
                    bndDelta = step;
                }
                for (var t = t0; t < t1; t += step) {
                  addBreak(t, t + bndDelta);
                }
              } else {
                var vals = Lib.simpleMap(brk.values, ax.d2c);
                for (var j = 0; j < vals.length; j++) {
                  b0 = vals[j];
                  b1 = b0 + brk.dvalue;
                  addBreak(b0, b1);
                }
              }
            }
          }
          rangebreaksOut.sort(function(a, b) {
            return a.min - b.min;
          });
          return rangebreaksOut;
        };
        ax.makeCalcdata = function(trace, axLetter2, opts) {
          var arrayIn, arrayOut, i, len;
          var axType = ax.type;
          var cal = axType === "date" && trace[axLetter2 + "calendar"];
          if (axLetter2 in trace) {
            arrayIn = trace[axLetter2];
            len = trace._length || Lib.minRowLength(arrayIn);
            if (Lib.isTypedArray(arrayIn) && (axType === "linear" || axType === "log")) {
              if (len === arrayIn.length) {
                return arrayIn;
              } else if (arrayIn.subarray) {
                return arrayIn.subarray(0, len);
              }
            }
            if (axType === "multicategory") {
              return setMultiCategoryIndex(arrayIn, len);
            }
            arrayOut = new Array(len);
            for (i = 0; i < len; i++) {
              arrayOut[i] = ax.d2c(arrayIn[i], 0, cal, opts);
            }
          } else {
            var v0 = axLetter2 + "0" in trace ? ax.d2c(trace[axLetter2 + "0"], 0, cal) : 0;
            var dv = trace["d" + axLetter2] ? Number(trace["d" + axLetter2]) : 1;
            arrayIn = trace[{ x: "y", y: "x" }[axLetter2]];
            len = trace._length || arrayIn.length;
            arrayOut = new Array(len);
            for (i = 0; i < len; i++) {
              arrayOut[i] = v0 + i * dv;
            }
          }
          if (ax.rangebreaks) {
            for (i = 0; i < len; i++) {
              arrayOut[i] = ax.maskBreaks(arrayOut[i]);
            }
          }
          return arrayOut;
        };
        ax.isValidRange = function(range, nullOk) {
          return Array.isArray(range) && range.length === 2 && (nullOk && range[0] === null || isNumeric(ax.r2l(range[0]))) && (nullOk && range[1] === null || isNumeric(ax.r2l(range[1])));
        };
        ax.getAutorangeDflt = function(range, options) {
          var autorangeDflt = !ax.isValidRange(range, "nullOk");
          if (autorangeDflt && options && options.reverseDflt) autorangeDflt = "reversed";
          else if (range) {
            if (range[0] === null && range[1] === null) {
              autorangeDflt = true;
            } else if (range[0] === null && range[1] !== null) {
              autorangeDflt = "min";
            } else if (range[0] !== null && range[1] === null) {
              autorangeDflt = "max";
            }
          }
          return autorangeDflt;
        };
        ax.isReversed = function() {
          var autorange = ax.autorange;
          return autorange === "reversed" || autorange === "min reversed" || autorange === "max reversed";
        };
        ax.isPtWithinRange = function(d, calendar) {
          var coord = ax.c2l(d[axLetter], null, calendar);
          var r0 = ax.r2l(ax.range[0]);
          var r1 = ax.r2l(ax.range[1]);
          if (r0 < r1) {
            return r0 <= coord && coord <= r1;
          } else {
            return r1 <= coord && coord <= r0;
          }
        };
        ax._emptyCategories = function() {
          ax._categories = [];
          ax._categoriesMap = {};
        };
        ax.clearCalc = function() {
          var group = ax._matchGroup;
          if (group) {
            var categories = null;
            var categoriesMap = null;
            for (var axId2 in group) {
              var ax2 = fullLayout[axisIds.id2name(axId2)];
              if (ax2._categories) {
                categories = ax2._categories;
                categoriesMap = ax2._categoriesMap;
                break;
              }
            }
            if (categories && categoriesMap) {
              ax._categories = categories;
              ax._categoriesMap = categoriesMap;
            } else {
              ax._emptyCategories();
            }
          } else {
            ax._emptyCategories();
          }
          if (ax._initialCategories) {
            for (var j = 0; j < ax._initialCategories.length; j++) {
              setCategoryIndex(ax._initialCategories[j]);
            }
          }
        };
        ax.sortByInitialCategories = function() {
          var affectedTraces = [];
          ax._emptyCategories();
          if (ax._initialCategories) {
            for (var j = 0; j < ax._initialCategories.length; j++) {
              setCategoryIndex(ax._initialCategories[j]);
            }
          }
          affectedTraces = affectedTraces.concat(ax._traceIndices);
          var group = ax._matchGroup;
          for (var axId2 in group) {
            if (axId === axId2) continue;
            var ax2 = fullLayout[axisIds.id2name(axId2)];
            ax2._categories = ax._categories;
            ax2._categoriesMap = ax._categoriesMap;
            affectedTraces = affectedTraces.concat(ax2._traceIndices);
          }
          return affectedTraces;
        };
        var locale = fullLayout._d3locale;
        if (ax.type === "date") {
          ax._dateFormat = locale ? locale.timeFormat : utcFormat;
          ax._extraFormat = fullLayout._extraFormat;
        }
        ax._separators = fullLayout.separators;
        ax._numFormat = locale ? locale.numberFormat : numberFormat;
        delete ax._minDtick;
        delete ax._forceTick0;
      };
    }
  });

  // src/plots/cartesian/axis_autotype.js
  var require_axis_autotype = __commonJS({
    "src/plots/cartesian/axis_autotype.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var BADNUM = require_numerical().BADNUM;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var isDateTime = Lib.isDateTime;
      var cleanNumber = Lib.cleanNumber;
      var round = Math.round;
      module.exports = function autoType(array, calendar, opts) {
        var a = array;
        var noMultiCategory = opts.noMultiCategory;
        if (isArrayOrTypedArray(a) && !a.length) return "-";
        if (!noMultiCategory && multiCategory(a)) return "multicategory";
        if (noMultiCategory && Array.isArray(a[0])) {
          var b = [];
          for (var i = 0; i < a.length; i++) {
            if (isArrayOrTypedArray(a[i])) {
              for (var j = 0; j < a[i].length; j++) {
                b.push(a[i][j]);
              }
            }
          }
          a = b;
        }
        if (moreDates(a, calendar)) return "date";
        var convertNumeric = opts.autotypenumbers !== "strict";
        if (category(a, convertNumeric)) return "category";
        if (linearOK(a, convertNumeric)) return "linear";
        return "-";
      };
      function hasTypeNumber(v, convertNumeric) {
        return convertNumeric ? isNumeric(v) : typeof v === "number";
      }
      function linearOK(a, convertNumeric) {
        var len = a.length;
        for (var i = 0; i < len; i++) {
          if (hasTypeNumber(a[i], convertNumeric)) return true;
        }
        return false;
      }
      function moreDates(a, calendar) {
        var len = a.length;
        var inc = getIncrement(len);
        var dats = 0;
        var nums = 0;
        var seen = {};
        for (var f = 0; f < len; f += inc) {
          var i = round(f);
          var ai = a[i];
          var stri = String(ai);
          if (seen[stri]) continue;
          seen[stri] = 1;
          if (isDateTime(ai, calendar)) dats++;
          if (isNumeric(ai)) nums++;
        }
        return dats > nums * 2;
      }
      function getIncrement(len) {
        return Math.max(1, (len - 1) / 1e3);
      }
      function category(a, convertNumeric) {
        var len = a.length;
        var inc = getIncrement(len);
        var nums = 0;
        var cats = 0;
        var seen = {};
        for (var f = 0; f < len; f += inc) {
          var i = round(f);
          var ai = a[i];
          var stri = String(ai);
          if (seen[stri]) continue;
          seen[stri] = 1;
          var t = typeof ai;
          if (t === "boolean") cats++;
          else if (convertNumeric ? cleanNumber(ai) !== BADNUM : t === "number") nums++;
          else if (t === "string") cats++;
        }
        return cats > nums * 2;
      }
      function multiCategory(a) {
        return isArrayOrTypedArray(a[0]) && isArrayOrTypedArray(a[1]);
      }
    }
  });

  // src/plots/cartesian/autorange.js
  var require_autorange = __commonJS({
    "src/plots/cartesian/autorange.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var FP_SAFE = require_numerical().FP_SAFE;
      var Registry = require_registry();
      var Drawing = require_drawing();
      var axIds = require_axis_ids();
      var getFromId = axIds.getFromId;
      var isLinked = axIds.isLinked;
      module.exports = {
        applyAutorangeOptions,
        getAutoRange,
        makePadFn,
        doAutoRange,
        findExtremes,
        concatExtremes
      };
      function getAutoRange(gd, ax) {
        var i, j;
        var newRange = [];
        var fullLayout = gd._fullLayout;
        var getPadMin = makePadFn(fullLayout, ax, 0);
        var getPadMax = makePadFn(fullLayout, ax, 1);
        var extremes = concatExtremes(gd, ax);
        var minArray = extremes.min;
        var maxArray = extremes.max;
        if (minArray.length === 0 || maxArray.length === 0) {
          return Lib.simpleMap(ax.range, ax.r2l);
        }
        var minmin = minArray[0].val;
        var maxmax = maxArray[0].val;
        for (i = 1; i < minArray.length; i++) {
          if (minmin !== maxmax) break;
          minmin = Math.min(minmin, minArray[i].val);
        }
        for (i = 1; i < maxArray.length; i++) {
          if (minmin !== maxmax) break;
          maxmax = Math.max(maxmax, maxArray[i].val);
        }
        var autorange = ax.autorange;
        var axReverse = autorange === "reversed" || autorange === "min reversed" || autorange === "max reversed";
        if (!axReverse && ax.range) {
          var rng = Lib.simpleMap(ax.range, ax.r2l);
          axReverse = rng[1] < rng[0];
        }
        if (ax.autorange === "reversed") {
          ax.autorange = true;
        }
        var rangeMode = ax.rangemode;
        var toZero = rangeMode === "tozero";
        var nonNegative = rangeMode === "nonnegative";
        var axLen = ax._length;
        var minSpan = axLen / 10;
        var mbest = 0;
        var minpt, maxpt, minbest, maxbest, dp, dv;
        for (i = 0; i < minArray.length; i++) {
          minpt = minArray[i];
          for (j = 0; j < maxArray.length; j++) {
            maxpt = maxArray[j];
            dv = maxpt.val - minpt.val - calcBreaksLength(ax, minpt.val, maxpt.val);
            if (dv > 0) {
              dp = axLen - getPadMin(minpt) - getPadMax(maxpt);
              if (dp > minSpan) {
                if (dv / dp > mbest) {
                  minbest = minpt;
                  maxbest = maxpt;
                  mbest = dv / dp;
                }
              } else if (dv / axLen > mbest) {
                minbest = { val: minpt.val, nopad: 1 };
                maxbest = { val: maxpt.val, nopad: 1 };
                mbest = dv / axLen;
              }
            }
          }
        }
        function maximumPad(prev, pt) {
          return Math.max(prev, getPadMax(pt));
        }
        if (minmin === maxmax) {
          var lower = minmin - 1;
          var upper = minmin + 1;
          if (toZero) {
            if (minmin === 0) {
              newRange = [0, 1];
            } else {
              var maxPad = (minmin > 0 ? maxArray : minArray).reduce(maximumPad, 0);
              var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));
              newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];
            }
          } else if (nonNegative) {
            newRange = [Math.max(0, lower), Math.max(1, upper)];
          } else {
            newRange = [lower, upper];
          }
        } else {
          if (toZero) {
            if (minbest.val >= 0) {
              minbest = { val: 0, nopad: 1 };
            }
            if (maxbest.val <= 0) {
              maxbest = { val: 0, nopad: 1 };
            }
          } else if (nonNegative) {
            if (minbest.val - mbest * getPadMin(minbest) < 0) {
              minbest = { val: 0, nopad: 1 };
            }
            if (maxbest.val <= 0) {
              maxbest = { val: 1, nopad: 1 };
            }
          }
          mbest = (maxbest.val - minbest.val - calcBreaksLength(ax, minpt.val, maxpt.val)) / (axLen - getPadMin(minbest) - getPadMax(maxbest));
          newRange = [
            minbest.val - mbest * getPadMin(minbest),
            maxbest.val + mbest * getPadMax(maxbest)
          ];
        }
        newRange = applyAutorangeOptions(newRange, ax);
        if (ax.limitRange) ax.limitRange();
        if (axReverse) newRange.reverse();
        return Lib.simpleMap(newRange, ax.l2r || Number);
      }
      function calcBreaksLength(ax, v0, v1) {
        var lBreaks = 0;
        if (ax.rangebreaks) {
          var rangebreaksOut = ax.locateBreaks(v0, v1);
          for (var i = 0; i < rangebreaksOut.length; i++) {
            var brk = rangebreaksOut[i];
            lBreaks += brk.max - brk.min;
          }
        }
        return lBreaks;
      }
      function makePadFn(fullLayout, ax, max) {
        var extrappad = 0.05 * ax._length;
        var anchorAxis = ax._anchorAxis || {};
        if ((ax.ticklabelposition || "").indexOf("inside") !== -1 || (anchorAxis.ticklabelposition || "").indexOf("inside") !== -1) {
          var axReverse = ax.isReversed();
          if (!axReverse) {
            var rng = Lib.simpleMap(ax.range, ax.r2l);
            axReverse = rng[1] < rng[0];
          }
          if (axReverse) max = !max;
        }
        var zero = 0;
        if (!isLinked(fullLayout, ax._id)) {
          zero = padInsideLabelsOnAnchorAxis(fullLayout, ax, max);
        }
        extrappad = Math.max(zero, extrappad);
        if (ax.constrain === "domain" && ax._inputDomain) {
          extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) / (ax.domain[1] - ax.domain[0]);
        }
        return function getPad(pt) {
          if (pt.nopad) return 0;
          return pt.pad + (pt.extrapad ? extrappad : zero);
        };
      }
      var TEXTPAD = 3;
      function padInsideLabelsOnAnchorAxis(fullLayout, ax, max) {
        var pad = 0;
        var isX = ax._id.charAt(0) === "x";
        for (var subplot in fullLayout._plots) {
          var plotinfo = fullLayout._plots[subplot];
          if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
          var anchorAxis = (isX ? plotinfo.yaxis : plotinfo.xaxis) || {};
          if ((anchorAxis.ticklabelposition || "").indexOf("inside") !== -1) {
            if (!max && (anchorAxis.side === "left" || anchorAxis.side === "bottom") || max && (anchorAxis.side === "top" || anchorAxis.side === "right")) {
              if (anchorAxis._vals) {
                var rad = Lib.deg2rad(anchorAxis._tickAngles[anchorAxis._id + "tick"] || 0);
                var cosA = Math.abs(Math.cos(rad));
                var sinA = Math.abs(Math.sin(rad));
                if (!anchorAxis._vals[0].bb) {
                  var cls = anchorAxis._id + "tick";
                  var tickLabels = anchorAxis._selections[cls];
                  tickLabels.each(function(d) {
                    var thisLabel = d3.select(this);
                    var mathjaxGroup = thisLabel.select(".text-math-group");
                    if (mathjaxGroup.empty()) {
                      d.bb = Drawing.bBox(thisLabel.node());
                    }
                  });
                }
                for (var i = 0; i < anchorAxis._vals.length; i++) {
                  var t = anchorAxis._vals[i];
                  var bb = t.bb;
                  if (bb) {
                    var w = 2 * TEXTPAD + bb.width;
                    var h = 2 * TEXTPAD + bb.height;
                    pad = Math.max(
                      pad,
                      isX ? Math.max(w * cosA, h * sinA) : Math.max(h * cosA, w * sinA)
                    );
                  }
                }
              }
              if (anchorAxis.ticks === "inside" && anchorAxis.ticklabelposition === "inside") {
                pad += anchorAxis.ticklen || 0;
              }
            }
          }
        }
        return pad;
      }
      function concatExtremes(gd, ax, noMatch) {
        var axId = ax._id;
        var fullData = gd._fullData;
        var fullLayout = gd._fullLayout;
        var minArray = [];
        var maxArray = [];
        var i, j, d;
        function _concat(cont, indices) {
          for (i = 0; i < indices.length; i++) {
            var item = cont[indices[i]];
            var extremes = (item._extremes || {})[axId];
            if (item.visible === true && extremes) {
              for (j = 0; j < extremes.min.length; j++) {
                d = extremes.min[j];
                collapseMinArray(minArray, d.val, d.pad, { extrapad: d.extrapad });
              }
              for (j = 0; j < extremes.max.length; j++) {
                d = extremes.max[j];
                collapseMaxArray(maxArray, d.val, d.pad, { extrapad: d.extrapad });
              }
            }
          }
        }
        _concat(fullData, ax._traceIndices);
        _concat(fullLayout.annotations || [], ax._annIndices || []);
        _concat(fullLayout.shapes || [], ax._shapeIndices || []);
        if (ax._matchGroup && !noMatch) {
          for (var axId2 in ax._matchGroup) {
            if (axId2 !== ax._id) {
              var ax2 = getFromId(gd, axId2);
              var extremes2 = concatExtremes(gd, ax2, true);
              var lenRatio = ax._length / ax2._length;
              for (j = 0; j < extremes2.min.length; j++) {
                d = extremes2.min[j];
                collapseMinArray(minArray, d.val, d.pad * lenRatio, { extrapad: d.extrapad });
              }
              for (j = 0; j < extremes2.max.length; j++) {
                d = extremes2.max[j];
                collapseMaxArray(maxArray, d.val, d.pad * lenRatio, { extrapad: d.extrapad });
              }
            }
          }
        }
        return { min: minArray, max: maxArray };
      }
      function doAutoRange(gd, ax, presetRange) {
        ax.setScale();
        if (ax.autorange) {
          ax.range = presetRange ? presetRange.slice() : getAutoRange(gd, ax);
          ax._r = ax.range.slice();
          ax._rl = Lib.simpleMap(ax._r, ax.r2l);
          var axIn = ax._input;
          var edits = {};
          edits[ax._attr + ".range"] = ax.range;
          edits[ax._attr + ".autorange"] = ax.autorange;
          Registry.call("_storeDirectGUIEdit", gd.layout, gd._fullLayout._preGUI, edits);
          axIn.range = ax.range.slice();
          axIn.autorange = ax.autorange;
        }
        var anchorAx = ax._anchorAxis;
        if (anchorAx && anchorAx.rangeslider) {
          var axeRangeOpts = anchorAx.rangeslider[ax._name];
          if (axeRangeOpts) {
            if (axeRangeOpts.rangemode === "auto") {
              axeRangeOpts.range = getAutoRange(gd, ax);
            }
          }
          anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);
        }
      }
      function findExtremes(ax, data, opts) {
        if (!opts) opts = {};
        if (!ax._m) ax.setScale();
        var minArray = [];
        var maxArray = [];
        var len = data.length;
        var extrapad = opts.padded || false;
        var tozero = opts.tozero && (ax.type === "linear" || ax.type === "-");
        var isLog = ax.type === "log";
        var hasArrayOption = false;
        var vpadLinearized = opts.vpadLinearized || false;
        var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;
        function makePadAccessor(item) {
          if (Array.isArray(item)) {
            hasArrayOption = true;
            return function(i2) {
              return Math.max(Number(item[i2] || 0), 0);
            };
          } else {
            var v2 = Math.max(Number(item || 0), 0);
            return function() {
              return v2;
            };
          }
        }
        var ppadplus = makePadAccessor((ax._m > 0 ? opts.ppadplus : opts.ppadminus) || opts.ppad || 0);
        var ppadminus = makePadAccessor((ax._m > 0 ? opts.ppadminus : opts.ppadplus) || opts.ppad || 0);
        var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);
        var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);
        if (!hasArrayOption) {
          vmin = Infinity;
          vmax = -Infinity;
          if (isLog) {
            for (i = 0; i < len; i++) {
              v = data[i];
              if (v < vmin && v > 0) vmin = v;
              if (v > vmax && v < FP_SAFE) vmax = v;
            }
          } else {
            for (i = 0; i < len; i++) {
              v = data[i];
              if (v < vmin && v > -FP_SAFE) vmin = v;
              if (v > vmax && v < FP_SAFE) vmax = v;
            }
          }
          data = [vmin, vmax];
          len = 2;
        }
        var collapseOpts = { tozero, extrapad };
        function addItem(i2) {
          di = data[i2];
          if (!isNumeric(di)) return;
          ppadiplus = ppadplus(i2);
          ppadiminus = ppadminus(i2);
          if (vpadLinearized) {
            dmin = ax.c2l(di) - vpadminus(i2);
            dmax = ax.c2l(di) + vpadplus(i2);
          } else {
            vmin = di - vpadminus(i2);
            vmax = di + vpadplus(i2);
            if (isLog && vmin < vmax / 10) vmin = vmax / 10;
            dmin = ax.c2l(vmin);
            dmax = ax.c2l(vmax);
          }
          if (tozero) {
            dmin = Math.min(0, dmin);
            dmax = Math.max(0, dmax);
          }
          if (goodNumber(dmin)) {
            collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);
          }
          if (goodNumber(dmax)) {
            collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);
          }
        }
        var iMax = Math.min(6, len);
        for (i = 0; i < iMax; i++) addItem(i);
        for (i = len - 1; i >= iMax; i--) addItem(i);
        return {
          min: minArray,
          max: maxArray,
          opts
        };
      }
      function collapseMinArray(array, newVal, newPad, opts) {
        collapseArray(array, newVal, newPad, opts, lessOrEqual);
      }
      function collapseMaxArray(array, newVal, newPad, opts) {
        collapseArray(array, newVal, newPad, opts, greaterOrEqual);
      }
      function collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {
        var tozero = opts.tozero;
        var extrapad = opts.extrapad;
        var includeThis = true;
        for (var j = 0; j < array.length && includeThis; j++) {
          var v = array[j];
          if (atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {
            includeThis = false;
            break;
          } else if (atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {
            array.splice(j, 1);
            j--;
          }
        }
        if (includeThis) {
          var clipAtZero = tozero && newVal === 0;
          array.push({
            val: newVal,
            pad: clipAtZero ? 0 : newPad,
            extrapad: clipAtZero ? false : extrapad
          });
        }
      }
      function goodNumber(v) {
        return isNumeric(v) && Math.abs(v) < FP_SAFE;
      }
      function lessOrEqual(v0, v1) {
        return v0 <= v1;
      }
      function greaterOrEqual(v0, v1) {
        return v0 >= v1;
      }
      function applyAutorangeMinOptions(v, ax) {
        var autorangeoptions = ax.autorangeoptions;
        if (autorangeoptions && autorangeoptions.minallowed !== void 0 && hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)) {
          return autorangeoptions.minallowed;
        }
        if (autorangeoptions && autorangeoptions.clipmin !== void 0 && hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)) {
          return Math.max(v, ax.d2l(autorangeoptions.clipmin));
        }
        return v;
      }
      function applyAutorangeMaxOptions(v, ax) {
        var autorangeoptions = ax.autorangeoptions;
        if (autorangeoptions && autorangeoptions.maxallowed !== void 0 && hasValidMinAndMax(ax, autorangeoptions.minallowed, autorangeoptions.maxallowed)) {
          return autorangeoptions.maxallowed;
        }
        if (autorangeoptions && autorangeoptions.clipmax !== void 0 && hasValidMinAndMax(ax, autorangeoptions.clipmin, autorangeoptions.clipmax)) {
          return Math.min(v, ax.d2l(autorangeoptions.clipmax));
        }
        return v;
      }
      function hasValidMinAndMax(ax, min, max) {
        if (min !== void 0 && max !== void 0) {
          min = ax.d2l(min);
          max = ax.d2l(max);
          return min < max;
        }
        return true;
      }
      function applyAutorangeOptions(range, ax) {
        if (!ax || !ax.autorangeoptions) return range;
        var min = range[0];
        var max = range[1];
        var include = ax.autorangeoptions.include;
        if (include !== void 0) {
          var lMin = ax.d2l(min);
          var lMax = ax.d2l(max);
          if (!Lib.isArrayOrTypedArray(include)) include = [include];
          for (var i = 0; i < include.length; i++) {
            var v = ax.d2l(include[i]);
            if (lMin >= v) {
              lMin = v;
              min = v;
            }
            if (lMax <= v) {
              lMax = v;
              max = v;
            }
          }
        }
        min = applyAutorangeMinOptions(min, ax);
        max = applyAutorangeMaxOptions(max, ax);
        return [min, max];
      }
    }
  });

  // src/plots/cartesian/axes.js
  var require_axes = __commonJS({
    "src/plots/cartesian/axes.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Plots = require_plots();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var Titles = require_titles();
      var Color = require_color();
      var Drawing = require_drawing();
      var axAttrs = require_layout_attributes4();
      var cleanTicks = require_clean_ticks();
      var constants = require_numerical();
      var ONEMAXYEAR = constants.ONEMAXYEAR;
      var ONEAVGYEAR = constants.ONEAVGYEAR;
      var ONEMINYEAR = constants.ONEMINYEAR;
      var ONEMAXQUARTER = constants.ONEMAXQUARTER;
      var ONEAVGQUARTER = constants.ONEAVGQUARTER;
      var ONEMINQUARTER = constants.ONEMINQUARTER;
      var ONEMAXMONTH = constants.ONEMAXMONTH;
      var ONEAVGMONTH = constants.ONEAVGMONTH;
      var ONEMINMONTH = constants.ONEMINMONTH;
      var ONEWEEK = constants.ONEWEEK;
      var ONEDAY = constants.ONEDAY;
      var HALFDAY = ONEDAY / 2;
      var ONEHOUR = constants.ONEHOUR;
      var ONEMIN = constants.ONEMIN;
      var ONESEC = constants.ONESEC;
      var ONEMILLI = constants.ONEMILLI;
      var ONEMICROSEC = constants.ONEMICROSEC;
      var MINUS_SIGN = constants.MINUS_SIGN;
      var BADNUM = constants.BADNUM;
      var ZERO_PATH = { K: "zeroline" };
      var GRID_PATH = { K: "gridline", L: "path" };
      var MINORGRID_PATH = { K: "minor-gridline", L: "path" };
      var TICK_PATH = { K: "tick", L: "path" };
      var TICK_TEXT = { K: "tick", L: "text" };
      var MARGIN_MAPPING = {
        width: ["x", "r", "l", "xl", "xr"],
        height: ["y", "t", "b", "yt", "yb"],
        right: ["r", "xr"],
        left: ["l", "xl"],
        top: ["t", "yt"],
        bottom: ["b", "yb"]
      };
      var alignmentConstants = require_alignment();
      var MID_SHIFT = alignmentConstants.MID_SHIFT;
      var CAP_SHIFT = alignmentConstants.CAP_SHIFT;
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var OPPOSITE_SIDE = alignmentConstants.OPPOSITE_SIDE;
      var TEXTPAD = 3;
      var axes = module.exports = {};
      axes.setConvert = require_set_convert();
      var autoType = require_axis_autotype();
      var axisIds = require_axis_ids();
      var idSort = axisIds.idSort;
      var isLinked = axisIds.isLinked;
      axes.id2name = axisIds.id2name;
      axes.name2id = axisIds.name2id;
      axes.cleanId = axisIds.cleanId;
      axes.list = axisIds.list;
      axes.listIds = axisIds.listIds;
      axes.getFromId = axisIds.getFromId;
      axes.getFromTrace = axisIds.getFromTrace;
      var autorange = require_autorange();
      axes.getAutoRange = autorange.getAutoRange;
      axes.findExtremes = autorange.findExtremes;
      var epsilon = 1e-4;
      function expandRange(range) {
        var delta = (range[1] - range[0]) * epsilon;
        return [
          range[0] - delta,
          range[1] + delta
        ];
      }
      axes.coerceRef = function(containerIn, containerOut, gd, attr, dflt, extraOption) {
        var axLetter = attr.charAt(attr.length - 1);
        var axlist = gd._fullLayout._subplots[axLetter + "axis"];
        var refAttr = attr + "ref";
        var attrDef = {};
        if (!dflt) dflt = axlist[0] || (typeof extraOption === "string" ? extraOption : extraOption[0]);
        if (!extraOption) extraOption = dflt;
        axlist = axlist.concat(axlist.map(function(x) {
          return x + " domain";
        }));
        attrDef[refAttr] = {
          valType: "enumerated",
          values: axlist.concat(extraOption ? typeof extraOption === "string" ? [extraOption] : extraOption : []),
          dflt
        };
        return Lib.coerce(containerIn, containerOut, attrDef, refAttr);
      };
      axes.getRefType = function(ar) {
        if (ar === void 0) {
          return ar;
        }
        if (ar === "paper") {
          return "paper";
        }
        if (ar === "pixel") {
          return "pixel";
        }
        if (/( domain)$/.test(ar)) {
          return "domain";
        } else {
          return "range";
        }
      };
      axes.coercePosition = function(containerOut, gd, coerce, axRef, attr, dflt) {
        var cleanPos, pos;
        var axRefType = axes.getRefType(axRef);
        if (axRefType !== "range") {
          cleanPos = Lib.ensureNumber;
          pos = coerce(attr, dflt);
        } else {
          var ax = axes.getFromId(gd, axRef);
          dflt = ax.fraction2r(dflt);
          pos = coerce(attr, dflt);
          cleanPos = ax.cleanPos;
        }
        containerOut[attr] = cleanPos(pos);
      };
      axes.cleanPosition = function(pos, gd, axRef) {
        var cleanPos = axRef === "paper" || axRef === "pixel" ? Lib.ensureNumber : axes.getFromId(gd, axRef).cleanPos;
        return cleanPos(pos);
      };
      axes.redrawComponents = function(gd, axIds) {
        axIds = axIds ? axIds : axes.listIds(gd);
        var fullLayout = gd._fullLayout;
        function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {
          var method = Registry.getComponentMethod(moduleName, methodName);
          var stash = {};
          for (var i = 0; i < axIds.length; i++) {
            var ax = fullLayout[axes.id2name(axIds[i])];
            var indices = ax[stashName];
            for (var j = 0; j < indices.length; j++) {
              var ind = indices[j];
              if (!stash[ind]) {
                method(gd, ind);
                stash[ind] = 1;
                if (shortCircuit) return;
              }
            }
          }
        }
        _redrawOneComp("annotations", "drawOne", "_annIndices");
        _redrawOneComp("shapes", "drawOne", "_shapeIndices");
        _redrawOneComp("images", "draw", "_imgIndices", true);
        _redrawOneComp("selections", "drawOne", "_selectionIndices");
      };
      var getDataConversions = axes.getDataConversions = function(gd, trace, target, targetArray) {
        var ax;
        var d2cTarget = target === "x" || target === "y" || target === "z" ? target : targetArray;
        if (Lib.isArrayOrTypedArray(d2cTarget)) {
          ax = {
            type: autoType(targetArray, void 0, {
              autotypenumbers: gd._fullLayout.autotypenumbers
            }),
            _categories: []
          };
          axes.setConvert(ax);
          if (ax.type === "category") {
            for (var i = 0; i < targetArray.length; i++) {
              ax.d2c(targetArray[i]);
            }
          }
        } else {
          ax = axes.getFromTrace(gd, trace, d2cTarget);
        }
        if (ax) return { d2c: ax.d2c, c2d: ax.c2d };
        if (d2cTarget === "ids") return { d2c: toString, c2d: toString };
        return { d2c: toNum, c2d: toNum };
      };
      function toNum(v) {
        return +v;
      }
      function toString(v) {
        return String(v);
      }
      axes.getDataToCoordFunc = function(gd, trace, target, targetArray) {
        return getDataConversions(gd, trace, target, targetArray).d2c;
      };
      axes.counterLetter = function(id) {
        var axLetter = id.charAt(0);
        if (axLetter === "x") return "y";
        if (axLetter === "y") return "x";
      };
      axes.minDtick = function(ax, newDiff, newFirst, allow) {
        if (["log", "category", "multicategory"].indexOf(ax.type) !== -1 || !allow) {
          ax._minDtick = 0;
        } else if (ax._minDtick === void 0) {
          ax._minDtick = newDiff;
          ax._forceTick0 = newFirst;
        } else if (ax._minDtick) {
          if ((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 && // existing minDtick is an integer multiple of newDiff
          // (within rounding err)
          // and forceTick0 can be shifted to newFirst
          ((newFirst - ax._forceTick0) / newDiff % 1 + 1.000001) % 1 < 2e-6) {
            ax._minDtick = newDiff;
            ax._forceTick0 = newFirst;
          } else if ((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 || // if the converse is true (newDiff is a multiple of minDtick and
          // newFirst can be shifted to forceTick0) then do nothing - same
          // forcing stands. Otherwise, cancel forced minimum
          ((newFirst - ax._forceTick0) / ax._minDtick % 1 + 1.000001) % 1 > 2e-6) {
            ax._minDtick = 0;
          }
        }
      };
      axes.saveRangeInitial = function(gd, overwrite) {
        var axList = axes.list(gd, "", true);
        var hasOneAxisChanged = false;
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          var isNew = ax._rangeInitial0 === void 0 && ax._rangeInitial1 === void 0;
          var hasChanged = isNew || (ax.range[0] !== ax._rangeInitial0 || ax.range[1] !== ax._rangeInitial1);
          var autorange2 = ax.autorange;
          if (isNew && autorange2 !== true || overwrite && hasChanged) {
            ax._rangeInitial0 = autorange2 === "min" || autorange2 === "max reversed" ? void 0 : ax.range[0];
            ax._rangeInitial1 = autorange2 === "max" || autorange2 === "min reversed" ? void 0 : ax.range[1];
            ax._autorangeInitial = autorange2;
            hasOneAxisChanged = true;
          }
        }
        return hasOneAxisChanged;
      };
      axes.saveShowSpikeInitial = function(gd, overwrite) {
        var axList = axes.list(gd, "", true);
        var hasOneAxisChanged = false;
        var allSpikesEnabled = "on";
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          var isNew = ax._showSpikeInitial === void 0;
          var hasChanged = isNew || !(ax.showspikes === ax._showspikes);
          if (isNew || overwrite && hasChanged) {
            ax._showSpikeInitial = ax.showspikes;
            hasOneAxisChanged = true;
          }
          if (allSpikesEnabled === "on" && !ax.showspikes) {
            allSpikesEnabled = "off";
          }
        }
        gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;
        return hasOneAxisChanged;
      };
      axes.autoBin = function(data, ax, nbins, is2d, calendar, size) {
        var dataMin = Lib.aggNums(Math.min, null, data);
        var dataMax = Lib.aggNums(Math.max, null, data);
        if (ax.type === "category" || ax.type === "multicategory") {
          return {
            start: dataMin - 0.5,
            end: dataMax + 0.5,
            size: Math.max(1, Math.round(size) || 1),
            _dataSpan: dataMax - dataMin
          };
        }
        if (!calendar) calendar = ax.calendar;
        var dummyAx;
        if (ax.type === "log") {
          dummyAx = {
            type: "linear",
            range: [dataMin, dataMax]
          };
        } else {
          dummyAx = {
            type: ax.type,
            range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),
            calendar
          };
        }
        axes.setConvert(dummyAx);
        size = size && cleanTicks.dtick(size, dummyAx.type);
        if (size) {
          dummyAx.dtick = size;
          dummyAx.tick0 = cleanTicks.tick0(void 0, dummyAx.type, calendar);
        } else {
          var size0;
          if (nbins) size0 = (dataMax - dataMin) / nbins;
          else {
            var distinctData = Lib.distinctVals(data);
            var msexp = Math.pow(10, Math.floor(
              Math.log(distinctData.minDiff) / Math.LN10
            ));
            var minSize = msexp * Lib.roundUp(
              distinctData.minDiff / msexp,
              [0.9, 1.9, 4.9, 9.9],
              true
            );
            size0 = Math.max(minSize, 2 * Lib.stdev(data) / Math.pow(data.length, is2d ? 0.25 : 0.4));
            if (!isNumeric(size0)) size0 = 1;
          }
          axes.autoTicks(dummyAx, size0);
        }
        var finalSize = dummyAx.dtick;
        var binStart = axes.tickIncrement(
          axes.tickFirst(dummyAx),
          finalSize,
          "reverse",
          calendar
        );
        var binEnd, bincount;
        if (typeof finalSize === "number") {
          binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);
          bincount = 1 + Math.floor((dataMax - binStart) / finalSize);
          binEnd = binStart + bincount * finalSize;
        } else {
          if (dummyAx.dtick.charAt(0) === "M") {
            binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);
          }
          binEnd = binStart;
          bincount = 0;
          while (binEnd <= dataMax) {
            binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);
            bincount++;
          }
        }
        return {
          start: ax.c2r(binStart, 0, calendar),
          end: ax.c2r(binEnd, 0, calendar),
          size: finalSize,
          _dataSpan: dataMax - dataMin
        };
      };
      function autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {
        var edgecount = 0;
        var midcount = 0;
        var intcount = 0;
        var blankCount = 0;
        function nearEdge(v) {
          return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;
        }
        for (var i = 0; i < data.length; i++) {
          if (data[i] % 1 === 0) intcount++;
          else if (!isNumeric(data[i])) blankCount++;
          if (nearEdge(data[i])) edgecount++;
          if (nearEdge(data[i] + ax.dtick / 2)) midcount++;
        }
        var dataCount = data.length - blankCount;
        if (intcount === dataCount && ax.type !== "date") {
          if (ax.dtick < 1) {
            binStart = dataMin - 0.5 * ax.dtick;
          } else {
            binStart -= 0.5;
            if (binStart + ax.dtick < dataMin) binStart += ax.dtick;
          }
        } else if (midcount < dataCount * 0.1) {
          if (edgecount > dataCount * 0.3 || nearEdge(dataMin) || nearEdge(dataMax)) {
            var binshift = ax.dtick / 2;
            binStart += binStart + binshift < dataMin ? binshift : -binshift;
          }
        }
        return binStart;
      }
      function autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {
        var stats = Lib.findExactDates(data, calendar);
        var threshold = 0.8;
        if (stats.exactDays > threshold) {
          var numMonths = Number(dtick.substr(1));
          if (stats.exactYears > threshold && numMonths % 12 === 0) {
            binStart = axes.tickIncrement(binStart, "M6", "reverse") + ONEDAY * 1.5;
          } else if (stats.exactMonths > threshold) {
            binStart = axes.tickIncrement(binStart, "M1", "reverse") + ONEDAY * 15.5;
          } else {
            binStart -= HALFDAY;
          }
          var nextBinStart = axes.tickIncrement(binStart, dtick);
          if (nextBinStart <= dataMin) return nextBinStart;
        }
        return binStart;
      }
      axes.prepMinorTicks = function(mockAx, ax, opts) {
        if (!ax.minor.dtick) {
          delete mockAx.dtick;
          var hasMajor = ax.dtick && isNumeric(ax._tmin);
          var mockMinorRange;
          if (hasMajor) {
            var tick2 = axes.tickIncrement(ax._tmin, ax.dtick, true);
            mockMinorRange = [ax._tmin, tick2 * 0.99 + ax._tmin * 0.01];
          } else {
            var rl = Lib.simpleMap(ax.range, ax.r2l);
            mockMinorRange = [rl[0], 0.8 * rl[0] + 0.2 * rl[1]];
          }
          mockAx.range = Lib.simpleMap(mockMinorRange, ax.l2r);
          mockAx._isMinor = true;
          axes.prepTicks(mockAx, opts);
          if (hasMajor) {
            var numericMajor = isNumeric(ax.dtick);
            var numericMinor = isNumeric(mockAx.dtick);
            var majorNum = numericMajor ? ax.dtick : +ax.dtick.substring(1);
            var minorNum = numericMinor ? mockAx.dtick : +mockAx.dtick.substring(1);
            if (numericMajor && numericMinor) {
              if (!isMultiple(majorNum, minorNum)) {
                if (majorNum === 2 * ONEWEEK && minorNum === 3 * ONEDAY) {
                  mockAx.dtick = ONEWEEK;
                } else if (majorNum === ONEWEEK && !(ax._input.minor || {}).nticks) {
                  mockAx.dtick = ONEDAY;
                } else if (isClose(majorNum / minorNum, 2.5)) {
                  mockAx.dtick = majorNum / 2;
                } else {
                  mockAx.dtick = majorNum;
                }
              } else if (majorNum === 2 * ONEWEEK && minorNum === 2 * ONEDAY) {
                mockAx.dtick = ONEWEEK;
              }
            } else if (String(ax.dtick).charAt(0) === "M") {
              if (numericMinor) {
                mockAx.dtick = "M1";
              } else {
                if (!isMultiple(majorNum, minorNum)) {
                  mockAx.dtick = ax.dtick;
                } else if (majorNum >= 12 && minorNum === 2) {
                  mockAx.dtick = "M3";
                }
              }
            } else if (String(mockAx.dtick).charAt(0) === "L") {
              if (String(ax.dtick).charAt(0) === "L") {
                if (!isMultiple(majorNum, minorNum)) {
                  mockAx.dtick = isClose(majorNum / minorNum, 2.5) ? ax.dtick / 2 : ax.dtick;
                }
              } else {
                mockAx.dtick = "D1";
              }
            } else if (mockAx.dtick === "D2" && +ax.dtick > 1) {
              mockAx.dtick = 1;
            }
          }
          mockAx.range = ax.range;
        }
        if (ax.minor._tick0Init === void 0) {
          mockAx.tick0 = ax.tick0;
        }
      };
      function isMultiple(bigger, smaller) {
        return Math.abs((bigger / smaller + 0.5) % 1 - 0.5) < 1e-3;
      }
      function isClose(a, b) {
        return Math.abs(a / b - 1) < 1e-3;
      }
      axes.prepTicks = function(ax, opts) {
        var rng = Lib.simpleMap(ax.range, ax.r2l, void 0, void 0, opts);
        if (ax.tickmode === "auto" || !ax.dtick) {
          var nt = ax.nticks;
          var minPx;
          if (!nt) {
            if (ax.type === "category" || ax.type === "multicategory") {
              minPx = ax.tickfont ? Lib.bigFont(ax.tickfont.size || 12) : 15;
              nt = ax._length / minPx;
            } else {
              minPx = ax._id.charAt(0) === "y" ? 40 : 80;
              nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;
            }
            if (ax._name === "radialaxis") nt *= 2;
          }
          if (!(ax.minor && ax.minor.tickmode !== "array")) {
            if (ax.tickmode === "array") nt *= 100;
          }
          ax._roughDTick = Math.abs(rng[1] - rng[0]) / nt;
          axes.autoTicks(ax, ax._roughDTick);
          if (ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {
            ax.dtick = ax._minDtick;
            ax.tick0 = ax.l2r(ax._forceTick0);
          }
        }
        if (ax.ticklabelmode === "period") {
          adjustPeriodDelta(ax);
        }
        if (!ax.tick0) {
          ax.tick0 = ax.type === "date" ? "2000-01-01" : 0;
        }
        if (ax.type === "date" && ax.dtick < 0.1) ax.dtick = 0.1;
        autoTickRound(ax);
      };
      function nMonths(dtick) {
        return +dtick.substring(1);
      }
      function adjustPeriodDelta(ax) {
        var definedDelta;
        function mDate() {
          return !(isNumeric(ax.dtick) || ax.dtick.charAt(0) !== "M");
        }
        var isMDate = mDate();
        var tickformat = axes.getTickFormat(ax);
        if (tickformat) {
          var noDtick = ax._dtickInit !== ax.dtick;
          if (!/%[fLQsSMX]/.test(tickformat)) {
            if (/%[HI]/.test(tickformat)) {
              definedDelta = ONEHOUR;
              if (noDtick && !isMDate && ax.dtick < ONEHOUR) ax.dtick = ONEHOUR;
            } else if (/%p/.test(tickformat)) {
              definedDelta = HALFDAY;
              if (noDtick && !isMDate && ax.dtick < HALFDAY) ax.dtick = HALFDAY;
            } else if (/%[Aadejuwx]/.test(tickformat)) {
              definedDelta = ONEDAY;
              if (noDtick && !isMDate && ax.dtick < ONEDAY) ax.dtick = ONEDAY;
            } else if (/%[UVW]/.test(tickformat)) {
              definedDelta = ONEWEEK;
              if (noDtick && !isMDate && ax.dtick < ONEWEEK) ax.dtick = ONEWEEK;
            } else if (/%[Bbm]/.test(tickformat)) {
              definedDelta = ONEAVGMONTH;
              if (noDtick && (isMDate ? nMonths(ax.dtick) < 1 : ax.dtick < ONEMINMONTH)) ax.dtick = "M1";
            } else if (/%[q]/.test(tickformat)) {
              definedDelta = ONEAVGQUARTER;
              if (noDtick && (isMDate ? nMonths(ax.dtick) < 3 : ax.dtick < ONEMINQUARTER)) ax.dtick = "M3";
            } else if (/%[Yy]/.test(tickformat)) {
              definedDelta = ONEAVGYEAR;
              if (noDtick && (isMDate ? nMonths(ax.dtick) < 12 : ax.dtick < ONEMINYEAR)) ax.dtick = "M12";
            }
          }
        }
        isMDate = mDate();
        if (isMDate && ax.tick0 === ax._dowTick0) {
          ax.tick0 = ax._rawTick0;
        }
        ax._definedDelta = definedDelta;
      }
      function positionPeriodTicks(tickVals, ax, definedDelta) {
        for (var i = 0; i < tickVals.length; i++) {
          var v = tickVals[i].value;
          var a = i;
          var b = i + 1;
          if (i < tickVals.length - 1) {
            a = i;
            b = i + 1;
          } else if (i > 0) {
            a = i - 1;
            b = i;
          } else {
            a = i;
            b = i;
          }
          var A = tickVals[a].value;
          var B = tickVals[b].value;
          var actualDelta = Math.abs(B - A);
          var delta = definedDelta || actualDelta;
          var periodLength = 0;
          if (delta >= ONEMINYEAR) {
            if (actualDelta >= ONEMINYEAR && actualDelta <= ONEMAXYEAR) {
              periodLength = actualDelta;
            } else {
              periodLength = ONEAVGYEAR;
            }
          } else if (definedDelta === ONEAVGQUARTER && delta >= ONEMINQUARTER) {
            if (actualDelta >= ONEMINQUARTER && actualDelta <= ONEMAXQUARTER) {
              periodLength = actualDelta;
            } else {
              periodLength = ONEAVGQUARTER;
            }
          } else if (delta >= ONEMINMONTH) {
            if (actualDelta >= ONEMINMONTH && actualDelta <= ONEMAXMONTH) {
              periodLength = actualDelta;
            } else {
              periodLength = ONEAVGMONTH;
            }
          } else if (definedDelta === ONEWEEK && delta >= ONEWEEK) {
            periodLength = ONEWEEK;
          } else if (delta >= ONEDAY) {
            periodLength = ONEDAY;
          } else if (definedDelta === HALFDAY && delta >= HALFDAY) {
            periodLength = HALFDAY;
          } else if (definedDelta === ONEHOUR && delta >= ONEHOUR) {
            periodLength = ONEHOUR;
          }
          var inBetween;
          if (periodLength >= actualDelta) {
            periodLength = actualDelta;
            inBetween = true;
          }
          var endPeriod = v + periodLength;
          if (ax.rangebreaks && periodLength > 0) {
            var nAll = 84;
            var n = 0;
            for (var c = 0; c < nAll; c++) {
              var r = (c + 0.5) / nAll;
              if (ax.maskBreaks(v * (1 - r) + r * endPeriod) !== BADNUM) n++;
            }
            periodLength *= n / nAll;
            if (!periodLength) {
              tickVals[i].drop = true;
            }
            if (inBetween && actualDelta > ONEWEEK) periodLength = actualDelta;
          }
          if (periodLength > 0 || // not instant
          i === 0) {
            tickVals[i].periodX = v + periodLength / 2;
          }
        }
      }
      axes.calcTicks = function calcTicks(ax, opts) {
        var type = ax.type;
        var calendar = ax.calendar;
        var ticklabelstep = ax.ticklabelstep;
        var isPeriod = ax.ticklabelmode === "period";
        var isReversed = ax.range[0] > ax.range[1];
        var ticklabelIndex = !ax.ticklabelindex || Lib.isArrayOrTypedArray(ax.ticklabelindex) ? ax.ticklabelindex : [ax.ticklabelindex];
        var rng = Lib.simpleMap(ax.range, ax.r2l, void 0, void 0, opts);
        var axrev = rng[1] < rng[0];
        var minRange = Math.min(rng[0], rng[1]);
        var maxRange = Math.max(rng[0], rng[1]);
        var maxTicks = Math.max(1e3, ax._length || 0);
        var ticksOut = [];
        var minorTicks = [];
        var tickVals = [];
        var minorTickVals = [];
        var allTicklabelVals = [];
        var hasMinor = ax.minor && (ax.minor.ticks || ax.minor.showgrid);
        for (var major = 1; major >= (hasMinor ? 0 : 1); major--) {
          var isMinor = !major;
          if (major) {
            ax._dtickInit = ax.dtick;
            ax._tick0Init = ax.tick0;
          } else {
            ax.minor._dtickInit = ax.minor.dtick;
            ax.minor._tick0Init = ax.minor.tick0;
          }
          var mockAx = major ? ax : Lib.extendFlat({}, ax, ax.minor);
          if (isMinor) {
            axes.prepMinorTicks(mockAx, ax, opts);
          } else {
            axes.prepTicks(mockAx, opts);
          }
          if (mockAx.tickmode === "array") {
            if (major) {
              tickVals = [];
              ticksOut = arrayTicks(ax, !isMinor);
            } else {
              minorTickVals = [];
              minorTicks = arrayTicks(ax, !isMinor);
            }
            continue;
          }
          if (mockAx.tickmode === "sync") {
            tickVals = [];
            ticksOut = syncTicks(ax);
            continue;
          }
          var exRng = expandRange(rng);
          var startTick = exRng[0];
          var endTick = exRng[1];
          var numDtick = isNumeric(mockAx.dtick);
          var isDLog = type === "log" && !(numDtick || mockAx.dtick.charAt(0) === "L");
          var x0 = axes.tickFirst(mockAx, opts);
          if (major) {
            ax._tmin = x0;
            if (x0 < startTick !== axrev) break;
            if (type === "category" || type === "multicategory") {
              endTick = axrev ? Math.max(-0.5, endTick) : Math.min(ax._categories.length - 0.5, endTick);
            }
          }
          var prevX = null;
          var x = x0;
          var majorId;
          if (major) {
            var _dTick;
            if (numDtick) {
              _dTick = ax.dtick;
            } else {
              if (type === "date") {
                if (typeof ax.dtick === "string" && ax.dtick.charAt(0) === "M") {
                  _dTick = ONEAVGMONTH * ax.dtick.substring(1);
                }
              } else {
                _dTick = ax._roughDTick;
              }
            }
            majorId = Math.round((ax.r2l(x) - ax.r2l(ax.tick0)) / _dTick) - 1;
          }
          var dtick = mockAx.dtick;
          if (mockAx.rangebreaks && mockAx._tick0Init !== mockAx.tick0) {
            x = moveOutsideBreak(x, ax);
            if (!axrev) {
              x = axes.tickIncrement(x, dtick, !axrev, calendar);
            }
          }
          if (major && isPeriod) {
            x = axes.tickIncrement(x, dtick, !axrev, calendar);
            majorId--;
          }
          for (; axrev ? x >= endTick : x <= endTick; x = axes.tickIncrement(
            x,
            dtick,
            axrev,
            calendar
          )) {
            if (major) majorId++;
            if (mockAx.rangebreaks) {
              if (!axrev) {
                if (x < startTick) continue;
                if (mockAx.maskBreaks(x) === BADNUM && moveOutsideBreak(x, mockAx) >= maxRange) break;
              }
            }
            if (tickVals.length > maxTicks || x === prevX) break;
            prevX = x;
            var obj = { value: x };
            if (major) {
              if (isDLog && x !== (x | 0)) {
                obj.simpleLabel = true;
              }
              if (ticklabelstep > 1 && majorId % ticklabelstep) {
                obj.skipLabel = true;
              }
              tickVals.push(obj);
            } else {
              obj.minor = true;
              minorTickVals.push(obj);
            }
          }
        }
        if (!minorTickVals || minorTickVals.length < 2) {
          ticklabelIndex = false;
        } else {
          var diff = (minorTickVals[1].value - minorTickVals[0].value) * (isReversed ? -1 : 1);
          if (!periodCompatibleWithTickformat(diff, ax.tickformat)) {
            ticklabelIndex = false;
          }
        }
        if (!ticklabelIndex) {
          allTicklabelVals = tickVals;
        } else {
          var allTickVals = tickVals.concat(minorTickVals);
          if (isPeriod && tickVals.length) {
            allTickVals = allTickVals.slice(1);
          }
          allTickVals = allTickVals.sort(function(a, b) {
            return a.value - b.value;
          }).filter(function(tick, index, self2) {
            return index === 0 || tick.value !== self2[index - 1].value;
          });
          var majorTickIndices = allTickVals.map(function(item, index) {
            return item.minor === void 0 && !item.skipLabel ? index : null;
          }).filter(function(index) {
            return index !== null;
          });
          majorTickIndices.forEach(function(majorIdx) {
            ticklabelIndex.map(function(nextLabelIdx) {
              var minorIdx = majorIdx + nextLabelIdx;
              if (minorIdx >= 0 && minorIdx < allTickVals.length) {
                Lib.pushUnique(allTicklabelVals, allTickVals[minorIdx]);
              }
            });
          });
        }
        if (hasMinor) {
          var canOverlap = ax.minor.ticks === "inside" && ax.ticks === "outside" || ax.minor.ticks === "outside" && ax.ticks === "inside";
          if (!canOverlap) {
            var majorValues = tickVals.map(function(d) {
              return d.value;
            });
            var list = [];
            for (var k = 0; k < minorTickVals.length; k++) {
              var T = minorTickVals[k];
              var v = T.value;
              if (majorValues.indexOf(v) !== -1) {
                continue;
              }
              var found = false;
              for (var q = 0; !found && q < tickVals.length; q++) {
                if (
                  // add 10e6 to eliminate problematic digits
                  1e7 + tickVals[q].value === 1e7 + v
                ) {
                  found = true;
                }
              }
              if (!found) list.push(T);
            }
            minorTickVals = list;
          }
        }
        if (isPeriod) positionPeriodTicks(allTicklabelVals, ax, ax._definedDelta);
        var i;
        if (ax.rangebreaks) {
          var flip = ax._id.charAt(0) === "y";
          var fontSize = 1;
          if (ax.tickmode === "auto") {
            fontSize = ax.tickfont ? ax.tickfont.size : 12;
          }
          var prevL = NaN;
          for (i = tickVals.length - 1; i > -1; i--) {
            if (tickVals[i].drop) {
              tickVals.splice(i, 1);
              continue;
            }
            tickVals[i].value = moveOutsideBreak(tickVals[i].value, ax);
            var l = ax.c2p(tickVals[i].value);
            if (flip ? prevL > l - fontSize : prevL < l + fontSize) {
              tickVals.splice(axrev ? i + 1 : i, 1);
            } else {
              prevL = l;
            }
          }
        }
        if (isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {
          tickVals.pop();
        }
        ax._tmax = (tickVals[tickVals.length - 1] || {}).value;
        ax._prevDateHead = "";
        ax._inCalcTicks = true;
        var lastVisibleHead;
        var hideLabel = function(tick) {
          tick.text = "";
          ax._prevDateHead = lastVisibleHead;
        };
        tickVals = tickVals.concat(minorTickVals);
        function setTickLabel(ax2, tickVal) {
          var text = axes.tickText(
            ax2,
            tickVal.value,
            false,
            // hover
            tickVal.simpleLabel
            // noSuffixPrefix
          );
          var p = tickVal.periodX;
          if (p !== void 0) {
            text.periodX = p;
            if (p > maxRange || p < minRange) {
              if (p > maxRange) text.periodX = maxRange;
              if (p < minRange) text.periodX = minRange;
              hideLabel(text);
            }
          }
          return text;
        }
        var t;
        for (i = 0; i < tickVals.length; i++) {
          var _minor = tickVals[i].minor;
          var _value = tickVals[i].value;
          if (_minor) {
            if (ticklabelIndex && allTicklabelVals.indexOf(tickVals[i]) !== -1) {
              t = setTickLabel(ax, tickVals[i]);
            } else {
              t = { x: _value };
            }
            t.minor = true;
            minorTicks.push(t);
          } else {
            lastVisibleHead = ax._prevDateHead;
            t = setTickLabel(ax, tickVals[i]);
            if (tickVals[i].skipLabel || ticklabelIndex && allTicklabelVals.indexOf(tickVals[i]) === -1) {
              hideLabel(t);
            }
            ticksOut.push(t);
          }
        }
        ticksOut = ticksOut.concat(minorTicks);
        ax._inCalcTicks = false;
        if (isPeriod && ticksOut.length) {
          ticksOut[0].noTick = true;
        }
        return ticksOut;
      };
      function filterRangeBreaks(ax, ticksOut) {
        if (ax.rangebreaks) {
          ticksOut = ticksOut.filter(function(d) {
            return ax.maskBreaks(d.x) !== BADNUM;
          });
        }
        return ticksOut;
      }
      function syncTicks(ax) {
        var baseAxis = ax._mainAxis;
        var ticksOut = [];
        if (baseAxis._vals) {
          for (var i = 0; i < baseAxis._vals.length; i++) {
            if (baseAxis._vals[i].noTick) {
              continue;
            }
            var pos = baseAxis.l2p(baseAxis._vals[i].x);
            var vali = ax.p2l(pos);
            var obj = axes.tickText(ax, vali);
            if (baseAxis._vals[i].minor) {
              obj.minor = true;
              obj.text = "";
            }
            ticksOut.push(obj);
          }
        }
        ticksOut = filterRangeBreaks(ax, ticksOut);
        return ticksOut;
      }
      function arrayTicks(ax, majorOnly) {
        var rng = Lib.simpleMap(ax.range, ax.r2l);
        var exRng = expandRange(rng);
        var tickMin = Math.min(exRng[0], exRng[1]);
        var tickMax = Math.max(exRng[0], exRng[1]);
        var tickVal2l = ax.type === "category" ? ax.d2l_noadd : ax.d2l;
        if (ax.type === "log" && String(ax.dtick).charAt(0) !== "L") {
          ax.dtick = "L" + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);
        }
        var ticksOut = [];
        for (var isMinor = 0; isMinor <= 1; isMinor++) {
          if (majorOnly !== void 0 && (majorOnly && isMinor || majorOnly === false && !isMinor)) continue;
          if (isMinor && !ax.minor) continue;
          var vals = !isMinor ? ax.tickvals : ax.minor.tickvals;
          var text = !isMinor ? ax.ticktext : [];
          if (!vals) continue;
          if (!Lib.isArrayOrTypedArray(text)) text = [];
          for (var i = 0; i < vals.length; i++) {
            var vali = tickVal2l(vals[i]);
            if (vali > tickMin && vali < tickMax) {
              var obj = axes.tickText(ax, vali, false, String(text[i]));
              if (isMinor) {
                obj.minor = true;
                obj.text = "";
              }
              ticksOut.push(obj);
            }
          }
        }
        ticksOut = filterRangeBreaks(ax, ticksOut);
        return ticksOut;
      }
      var roundBase10 = [2, 5, 10];
      var roundBase24 = [1, 2, 3, 6, 12];
      var roundBase60 = [1, 2, 5, 10, 15, 30];
      var roundDays = [1, 2, 3, 7, 14];
      var roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];
      var roundLog2 = [-0.301, 0, 0.301, 0.699, 1];
      var roundAngles = [15, 30, 45, 90, 180];
      function roundDTick(roughDTick, base, roundingSet) {
        return base * Lib.roundUp(roughDTick / base, roundingSet);
      }
      axes.autoTicks = function(ax, roughDTick, isMinor) {
        var base;
        function getBase(v) {
          return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));
        }
        if (ax.type === "date") {
          ax.tick0 = Lib.dateTick0(ax.calendar, 0);
          var roughX2 = 2 * roughDTick;
          if (roughX2 > ONEAVGYEAR) {
            roughDTick /= ONEAVGYEAR;
            base = getBase(10);
            ax.dtick = "M" + 12 * roundDTick(roughDTick, base, roundBase10);
          } else if (roughX2 > ONEAVGMONTH) {
            roughDTick /= ONEAVGMONTH;
            ax.dtick = "M" + roundDTick(roughDTick, 1, roundBase24);
          } else if (roughX2 > ONEDAY) {
            ax.dtick = roundDTick(roughDTick, ONEDAY, ax._hasDayOfWeekBreaks ? [1, 2, 7, 14] : roundDays);
            if (!isMinor) {
              var tickformat = axes.getTickFormat(ax);
              var isPeriod = ax.ticklabelmode === "period";
              if (isPeriod) ax._rawTick0 = ax.tick0;
              if (/%[uVW]/.test(tickformat)) {
                ax.tick0 = Lib.dateTick0(ax.calendar, 2);
              } else {
                ax.tick0 = Lib.dateTick0(ax.calendar, 1);
              }
              if (isPeriod) ax._dowTick0 = ax.tick0;
            }
          } else if (roughX2 > ONEHOUR) {
            ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);
          } else if (roughX2 > ONEMIN) {
            ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);
          } else if (roughX2 > ONESEC) {
            ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);
          } else {
            base = getBase(10);
            ax.dtick = roundDTick(roughDTick, base, roundBase10);
          }
        } else if (ax.type === "log") {
          ax.tick0 = 0;
          var rng = Lib.simpleMap(ax.range, ax.r2l);
          if (ax._isMinor) {
            roughDTick *= 1.5;
          }
          if (roughDTick > 0.7) {
            ax.dtick = Math.ceil(roughDTick);
          } else if (Math.abs(rng[1] - rng[0]) < 1) {
            var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);
            roughDTick = Math.abs(Math.pow(10, rng[1]) - Math.pow(10, rng[0])) / nt;
            base = getBase(10);
            ax.dtick = "L" + roundDTick(roughDTick, base, roundBase10);
          } else {
            ax.dtick = roughDTick > 0.3 ? "D2" : "D1";
          }
        } else if (ax.type === "category" || ax.type === "multicategory") {
          ax.tick0 = 0;
          ax.dtick = Math.ceil(Math.max(roughDTick, 1));
        } else if (isAngular(ax)) {
          ax.tick0 = 0;
          base = 1;
          ax.dtick = roundDTick(roughDTick, base, roundAngles);
        } else {
          ax.tick0 = 0;
          base = getBase(10);
          ax.dtick = roundDTick(roughDTick, base, roundBase10);
        }
        if (ax.dtick === 0) ax.dtick = 1;
        if (!isNumeric(ax.dtick) && typeof ax.dtick !== "string") {
          var olddtick = ax.dtick;
          ax.dtick = 1;
          throw "ax.dtick error: " + String(olddtick);
        }
      };
      function autoTickRound(ax) {
        var dtick = ax.dtick;
        ax._tickexponent = 0;
        if (!isNumeric(dtick) && typeof dtick !== "string") {
          dtick = 1;
        }
        if (ax.type === "category" || ax.type === "multicategory") {
          ax._tickround = null;
        }
        if (ax.type === "date") {
          var tick0ms = ax.r2l(ax.tick0);
          var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, "");
          var tick0len = tick0str.length;
          if (String(dtick).charAt(0) === "M") {
            if (tick0len > 10 || tick0str.substr(5) !== "01-01") ax._tickround = "d";
            else ax._tickround = +dtick.substr(1) % 12 === 0 ? "y" : "m";
          } else if (dtick >= ONEDAY && tick0len <= 10 || dtick >= ONEDAY * 15) ax._tickround = "d";
          else if (dtick >= ONEMIN && tick0len <= 16 || dtick >= ONEHOUR) ax._tickround = "M";
          else if (dtick >= ONESEC && tick0len <= 19 || dtick >= ONEMIN) ax._tickround = "S";
          else {
            var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, "").length;
            ax._tickround = Math.max(tick0len, tick1len) - 20;
            if (ax._tickround < 0) ax._tickround = 4;
          }
        } else if (isNumeric(dtick) || dtick.charAt(0) === "L") {
          var rng = ax.range.map(ax.r2d || Number);
          if (!isNumeric(dtick)) dtick = Number(dtick.substr(1));
          ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);
          var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));
          var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);
          var minexponent = ax.minexponent === void 0 ? 3 : ax.minexponent;
          if (Math.abs(rangeexp) > minexponent) {
            if (isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {
              ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);
            } else ax._tickexponent = rangeexp;
          }
        } else {
          ax._tickround = null;
        }
      }
      axes.tickIncrement = function(x, dtick, axrev, calendar) {
        var axSign = axrev ? -1 : 1;
        if (isNumeric(dtick)) return Lib.increment(x, axSign * dtick);
        var tType = dtick.charAt(0);
        var dtSigned = axSign * Number(dtick.substr(1));
        if (tType === "M") return Lib.incrementMonth(x, dtSigned, calendar);
        if (tType === "L") return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;
        if (tType === "D") {
          var tickset = dtick === "D2" ? roundLog2 : roundLog1;
          var x2 = x + axSign * 0.01;
          var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);
          return Math.floor(x2) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
        }
        throw "unrecognized dtick " + String(dtick);
      };
      axes.tickFirst = function(ax, opts) {
        var r2l = ax.r2l || Number;
        var rng = Lib.simpleMap(ax.range, r2l, void 0, void 0, opts);
        var axrev = rng[1] < rng[0];
        var sRound = axrev ? Math.floor : Math.ceil;
        var r0 = expandRange(rng)[0];
        var dtick = ax.dtick;
        var tick0 = r2l(ax.tick0);
        if (isNumeric(dtick)) {
          var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;
          if (ax.type === "category" || ax.type === "multicategory") {
            tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);
          }
          return tmin;
        }
        var tType = dtick.charAt(0);
        var dtNum = Number(dtick.substr(1));
        if (tType === "M") {
          var cnt = 0;
          var t0 = tick0;
          var t1, mult, newDTick;
          while (cnt < 10) {
            t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);
            if ((t1 - r0) * (t0 - r0) <= 0) {
              if (axrev) return Math.min(t0, t1);
              return Math.max(t0, t1);
            }
            mult = (r0 - (t0 + t1) / 2) / (t1 - t0);
            newDTick = tType + (Math.abs(Math.round(mult)) || 1) * dtNum;
            t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);
            cnt++;
          }
          Lib.error("tickFirst did not converge", ax);
          return t0;
        } else if (tType === "L") {
          return Math.log(sRound(
            (Math.pow(10, r0) - tick0) / dtNum
          ) * dtNum + tick0) / Math.LN10;
        } else if (tType === "D") {
          var tickset = dtick === "D2" ? roundLog2 : roundLog1;
          var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);
          return Math.floor(r0) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
        } else throw "unrecognized dtick " + String(dtick);
      };
      axes.tickText = function(ax, x, hover, noSuffixPrefix) {
        var out = tickTextObj(ax, x);
        var arrayMode = ax.tickmode === "array";
        var extraPrecision = hover || arrayMode;
        var axType = ax.type;
        var tickVal2l = axType === "category" ? ax.d2l_noadd : ax.d2l;
        var i;
        var inbounds = function(v) {
          var p = ax.l2p(v);
          return p >= 0 && p <= ax._length ? v : null;
        };
        if (arrayMode && Lib.isArrayOrTypedArray(ax.ticktext)) {
          var rng = Lib.simpleMap(ax.range, ax.r2l);
          var minDiff = (Math.abs(rng[1] - rng[0]) - (ax._lBreaks || 0)) / 1e4;
          for (i = 0; i < ax.ticktext.length; i++) {
            if (Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;
          }
          if (i < ax.ticktext.length) {
            out.text = String(ax.ticktext[i]);
            out.xbnd = [
              inbounds(out.x - 0.5),
              inbounds(out.x + ax.dtick - 0.5)
            ];
            return out;
          }
        }
        function isHidden(showAttr) {
          if (showAttr === void 0) return true;
          if (hover) return showAttr === "none";
          var firstOrLast = {
            first: ax._tmin,
            last: ax._tmax
          }[showAttr];
          return showAttr !== "all" && x !== firstOrLast;
        }
        var hideexp = hover ? "never" : ax.exponentformat !== "none" && isHidden(ax.showexponent) ? "hide" : "";
        if (axType === "date") formatDate(ax, out, hover, extraPrecision);
        else if (axType === "log") formatLog(ax, out, hover, extraPrecision, hideexp);
        else if (axType === "category") formatCategory(ax, out);
        else if (axType === "multicategory") formatMultiCategory(ax, out, hover);
        else if (isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);
        else formatLinear(ax, out, hover, extraPrecision, hideexp);
        if (!noSuffixPrefix) {
          if (ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;
          if (ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;
        }
        if (ax.labelalias && ax.labelalias.hasOwnProperty(out.text)) {
          var t = ax.labelalias[out.text];
          if (typeof t === "string") out.text = t;
        }
        if (ax.tickson === "boundaries" || ax.showdividers) {
          out.xbnd = [
            inbounds(out.x - 0.5),
            inbounds(out.x + ax.dtick - 0.5)
          ];
        }
        return out;
      };
      axes.hoverLabelText = function(ax, values, hoverformat) {
        if (hoverformat) ax = Lib.extendFlat({}, ax, { hoverformat });
        var val = Lib.isArrayOrTypedArray(values) ? values[0] : values;
        var val2 = Lib.isArrayOrTypedArray(values) ? values[1] : void 0;
        if (val2 !== void 0 && val2 !== val) {
          return axes.hoverLabelText(ax, val, hoverformat) + " - " + axes.hoverLabelText(ax, val2, hoverformat);
        }
        var logOffScale = ax.type === "log" && val <= 0;
        var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), "hover").text;
        if (logOffScale) {
          return val === 0 ? "0" : MINUS_SIGN + tx;
        }
        return tx;
      };
      function tickTextObj(ax, x, text) {
        var tf = ax.tickfont || {};
        return {
          x,
          dx: 0,
          dy: 0,
          text: text || "",
          fontSize: tf.size,
          font: tf.family,
          fontWeight: tf.weight,
          fontStyle: tf.style,
          fontVariant: tf.variant,
          fontTextcase: tf.textcase,
          fontLineposition: tf.lineposition,
          fontShadow: tf.shadow,
          fontColor: tf.color
        };
      }
      function formatDate(ax, out, hover, extraPrecision) {
        var tr = ax._tickround;
        var fmt = hover && ax.hoverformat || axes.getTickFormat(ax);
        extraPrecision = !fmt && extraPrecision;
        if (extraPrecision) {
          if (isNumeric(tr)) tr = 4;
          else tr = { y: "m", m: "d", d: "M", M: "S", S: 4 }[tr];
        }
        var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);
        var headStr;
        var splitIndex = dateStr.indexOf("\n");
        if (splitIndex !== -1) {
          headStr = dateStr.substr(splitIndex + 1);
          dateStr = dateStr.substr(0, splitIndex);
        }
        if (extraPrecision) {
          if (headStr !== void 0 && (dateStr === "00:00:00" || dateStr === "00:00")) {
            dateStr = headStr;
            headStr = "";
          } else if (dateStr.length === 8) {
            dateStr = dateStr.replace(/:00$/, "");
          }
        }
        if (headStr) {
          if (hover) {
            if (tr === "d") dateStr += ", " + headStr;
            else dateStr = headStr + (dateStr ? ", " + dateStr : "");
          } else {
            if (!ax._inCalcTicks || ax._prevDateHead !== headStr) {
              ax._prevDateHead = headStr;
              dateStr += "<br>" + headStr;
            } else {
              var isInside = insideTicklabelposition(ax);
              var side = ax._trueSide || ax.side;
              if (!isInside && side === "top" || isInside && side === "bottom") {
                dateStr += "<br> ";
              }
            }
          }
        }
        out.text = dateStr;
      }
      function formatLog(ax, out, hover, extraPrecision, hideexp) {
        var dtick = ax.dtick;
        var x = out.x;
        var tickformat = ax.tickformat;
        var dtChar0 = typeof dtick === "string" && dtick.charAt(0);
        if (hideexp === "never") {
          hideexp = "";
        }
        if (extraPrecision && dtChar0 !== "L") {
          dtick = "L3";
          dtChar0 = "L";
        }
        if (tickformat || dtChar0 === "L") {
          out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);
        } else if (isNumeric(dtick) || dtChar0 === "D" && Lib.mod(x + 0.01, 1) < 0.1) {
          var p = Math.round(x);
          var absP = Math.abs(p);
          var exponentFormat = ax.exponentformat;
          if (exponentFormat === "power" || isSIFormat(exponentFormat) && beyondSI(p)) {
            if (p === 0) out.text = 1;
            else if (p === 1) out.text = "10";
            else out.text = "10<sup>" + (p > 1 ? "" : MINUS_SIGN) + absP + "</sup>";
            out.fontSize *= 1.25;
          } else if ((exponentFormat === "e" || exponentFormat === "E") && absP > 2) {
            out.text = "1" + exponentFormat + (p > 0 ? "+" : MINUS_SIGN) + absP;
          } else {
            out.text = numFormat(Math.pow(10, x), ax, "", "fakehover");
            if (dtick === "D1" && ax._id.charAt(0) === "y") {
              out.dy -= out.fontSize / 6;
            }
          }
        } else if (dtChar0 === "D") {
          out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));
          out.fontSize *= 0.75;
        } else throw "unrecognized dtick " + String(dtick);
        if (ax.dtick === "D1") {
          var firstChar = String(out.text).charAt(0);
          if (firstChar === "0" || firstChar === "1") {
            if (ax._id.charAt(0) === "y") {
              out.dx -= out.fontSize / 4;
            } else {
              out.dy += out.fontSize / 2;
              out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) * out.fontSize * (x < 0 ? 0.5 : 0.25);
            }
          }
        }
      }
      function formatCategory(ax, out) {
        var tt = ax._categories[Math.round(out.x)];
        if (tt === void 0) tt = "";
        out.text = String(tt);
      }
      function formatMultiCategory(ax, out, hover) {
        var v = Math.round(out.x);
        var cats = ax._categories[v] || [];
        var tt = cats[1] === void 0 ? "" : String(cats[1]);
        var tt2 = cats[0] === void 0 ? "" : String(cats[0]);
        if (hover) {
          out.text = tt2 + " - " + tt;
        } else {
          out.text = tt;
          out.text2 = tt2;
        }
      }
      function formatLinear(ax, out, hover, extraPrecision, hideexp) {
        if (hideexp === "never") {
          hideexp = "";
        } else if (ax.showexponent === "all" && Math.abs(out.x / ax.dtick) < 1e-6) {
          hideexp = "hide";
        }
        out.text = numFormat(out.x, ax, hideexp, extraPrecision);
      }
      function formatAngle(ax, out, hover, extraPrecision, hideexp) {
        if (ax.thetaunit === "radians" && !hover) {
          var num = out.x / 180;
          if (num === 0) {
            out.text = "0";
          } else {
            var frac = num2frac(num);
            if (frac[1] >= 100) {
              out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);
            } else {
              var isNeg = out.x < 0;
              if (frac[1] === 1) {
                if (frac[0] === 1) out.text = "\u03C0";
                else out.text = frac[0] + "\u03C0";
              } else {
                out.text = [
                  "<sup>",
                  frac[0],
                  "</sup>",
                  "\u2044",
                  "<sub>",
                  frac[1],
                  "</sub>",
                  "\u03C0"
                ].join("");
              }
              if (isNeg) out.text = MINUS_SIGN + out.text;
            }
          }
        } else {
          out.text = numFormat(out.x, ax, hideexp, extraPrecision);
        }
      }
      function num2frac(num) {
        function almostEq(a, b) {
          return Math.abs(a - b) <= 1e-6;
        }
        function findGCD(a, b) {
          return almostEq(b, 0) ? a : findGCD(b, a % b);
        }
        function findPrecision(n) {
          var e = 1;
          while (!almostEq(Math.round(n * e) / e, n)) {
            e *= 10;
          }
          return e;
        }
        var precision = findPrecision(num);
        var number = num * precision;
        var gcd = Math.abs(findGCD(number, precision));
        return [
          // numerator
          Math.round(number / gcd),
          // denominator
          Math.round(precision / gcd)
        ];
      }
      var SIPREFIXES = ["f", "p", "n", "\u03BC", "m", "", "k", "M", "G", "T"];
      function isSIFormat(exponentFormat) {
        return exponentFormat === "SI" || exponentFormat === "B";
      }
      function beyondSI(exponent) {
        return exponent > 14 || exponent < -15;
      }
      function numFormat(v, ax, fmtoverride, hover) {
        var isNeg = v < 0;
        var tickRound = ax._tickround;
        var exponentFormat = fmtoverride || ax.exponentformat || "B";
        var exponent = ax._tickexponent;
        var tickformat = axes.getTickFormat(ax);
        var separatethousands = ax.separatethousands;
        if (hover) {
          var ah = {
            exponentformat: exponentFormat,
            minexponent: ax.minexponent,
            dtick: ax.showexponent === "none" ? ax.dtick : isNumeric(v) ? Math.abs(v) || 1 : 1,
            // if not showing any exponents, don't change the exponent
            // from what we calculate
            range: ax.showexponent === "none" ? ax.range.map(ax.r2d) : [0, v || 1]
          };
          autoTickRound(ah);
          tickRound = (Number(ah._tickround) || 0) + 4;
          exponent = ah._tickexponent;
          if (ax.hoverformat) tickformat = ax.hoverformat;
        }
        if (tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);
        var e = Math.pow(10, -tickRound) / 2;
        if (exponentFormat === "none") exponent = 0;
        v = Math.abs(v);
        if (v < e) {
          v = "0";
          isNeg = false;
        } else {
          v += e;
          if (exponent) {
            v *= Math.pow(10, -exponent);
            tickRound += exponent;
          }
          if (tickRound === 0) v = String(Math.floor(v));
          else if (tickRound < 0) {
            v = String(Math.round(v));
            v = v.substr(0, v.length + tickRound);
            for (var i = tickRound; i < 0; i++) v += "0";
          } else {
            v = String(v);
            var dp = v.indexOf(".") + 1;
            if (dp) v = v.substr(0, dp + tickRound).replace(/\.?0+$/, "");
          }
          v = Lib.numSeparate(v, ax._separators, separatethousands);
        }
        if (exponent && exponentFormat !== "hide") {
          if (isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = "power";
          var signedExponent;
          if (exponent < 0) signedExponent = MINUS_SIGN + -exponent;
          else if (exponentFormat !== "power") signedExponent = "+" + exponent;
          else signedExponent = String(exponent);
          if (exponentFormat === "e" || exponentFormat === "E") {
            v += exponentFormat + signedExponent;
          } else if (exponentFormat === "power") {
            v += "\xD710<sup>" + signedExponent + "</sup>";
          } else if (exponentFormat === "B" && exponent === 9) {
            v += "B";
          } else if (isSIFormat(exponentFormat)) {
            v += SIPREFIXES[exponent / 3 + 5];
          }
        }
        if (isNeg) return MINUS_SIGN + v;
        return v;
      }
      axes.getTickFormat = function(ax) {
        var i;
        function convertToMs(dtick) {
          return typeof dtick !== "string" ? dtick : Number(dtick.replace("M", "")) * ONEAVGMONTH;
        }
        function compareLogTicks(left, right) {
          var priority = ["L", "D"];
          if (typeof left === typeof right) {
            if (typeof left === "number") {
              return left - right;
            } else {
              var leftPriority = priority.indexOf(left.charAt(0));
              var rightPriority = priority.indexOf(right.charAt(0));
              if (leftPriority === rightPriority) {
                return Number(left.replace(/(L|D)/g, "")) - Number(right.replace(/(L|D)/g, ""));
              } else {
                return leftPriority - rightPriority;
              }
            }
          } else {
            return typeof left === "number" ? 1 : -1;
          }
        }
        function isProperStop(dtick, range, convert) {
          var convertFn = convert || function(x) {
            return x;
          };
          var leftDtick = range[0];
          var rightDtick = range[1];
          return (!leftDtick && typeof leftDtick !== "number" || convertFn(leftDtick) <= convertFn(dtick)) && (!rightDtick && typeof rightDtick !== "number" || convertFn(rightDtick) >= convertFn(dtick));
        }
        function isProperLogStop(dtick, range) {
          var isLeftDtickNull = range[0] === null;
          var isRightDtickNull = range[1] === null;
          var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;
          var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;
          return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);
        }
        var tickstop, stopi;
        if (ax.tickformatstops && ax.tickformatstops.length > 0) {
          switch (ax.type) {
            case "date":
            case "linear": {
              for (i = 0; i < ax.tickformatstops.length; i++) {
                stopi = ax.tickformatstops[i];
                if (stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {
                  tickstop = stopi;
                  break;
                }
              }
              break;
            }
            case "log": {
              for (i = 0; i < ax.tickformatstops.length; i++) {
                stopi = ax.tickformatstops[i];
                if (stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {
                  tickstop = stopi;
                  break;
                }
              }
              break;
            }
            default:
          }
        }
        return tickstop ? tickstop.value : ax.tickformat;
      };
      axes.getSubplots = function(gd, ax) {
        var subplotObj = gd._fullLayout._subplots;
        var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);
        var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;
        out.sort(function(a, b) {
          var aParts = a.substr(1).split("y");
          var bParts = b.substr(1).split("y");
          if (aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];
          return +aParts[0] - +bParts[0];
        });
        return out;
      };
      axes.findSubplotsWithAxis = function(subplots, ax) {
        var axMatch = new RegExp(
          ax._id.charAt(0) === "x" ? "^" + ax._id + "y" : ax._id + "$"
        );
        var subplotsWithAx = [];
        for (var i = 0; i < subplots.length; i++) {
          var sp = subplots[i];
          if (axMatch.test(sp)) subplotsWithAx.push(sp);
        }
        return subplotsWithAx;
      };
      axes.makeClipPaths = function(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._hasOnlyLargeSploms) return;
        var fullWidth = { _offset: 0, _length: fullLayout.width, _id: "" };
        var fullHeight = { _offset: 0, _length: fullLayout.height, _id: "" };
        var xaList = axes.list(gd, "x", true);
        var yaList = axes.list(gd, "y", true);
        var clipList = [];
        var i, j;
        for (i = 0; i < xaList.length; i++) {
          clipList.push({ x: xaList[i], y: fullHeight });
          for (j = 0; j < yaList.length; j++) {
            if (i === 0) clipList.push({ x: fullWidth, y: yaList[j] });
            clipList.push({ x: xaList[i], y: yaList[j] });
          }
        }
        var axClips = fullLayout._clips.selectAll(".axesclip").data(clipList, function(d) {
          return d.x._id + d.y._id;
        });
        axClips.enter().append("clipPath").classed("axesclip", true).attr("id", function(d) {
          return "clip" + fullLayout._uid + d.x._id + d.y._id;
        }).append("rect");
        axClips.exit().remove();
        axClips.each(function(d) {
          d3.select(this).select("rect").attr({
            x: d.x._offset || 0,
            y: d.y._offset || 0,
            width: d.x._length || 1,
            height: d.y._length || 1
          });
        });
      };
      axes.draw = function(gd, arg, opts) {
        var fullLayout = gd._fullLayout;
        if (arg === "redraw") {
          fullLayout._paper.selectAll("g.subplot").each(function(d) {
            var id = d[0];
            var plotinfo = fullLayout._plots[id];
            if (plotinfo) {
              var xa = plotinfo.xaxis;
              var ya = plotinfo.yaxis;
              plotinfo.xaxislayer.selectAll("." + xa._id + "tick").remove();
              plotinfo.yaxislayer.selectAll("." + ya._id + "tick").remove();
              plotinfo.xaxislayer.selectAll("." + xa._id + "tick2").remove();
              plotinfo.yaxislayer.selectAll("." + ya._id + "tick2").remove();
              plotinfo.xaxislayer.selectAll("." + xa._id + "divider").remove();
              plotinfo.yaxislayer.selectAll("." + ya._id + "divider").remove();
              if (plotinfo.minorGridlayer) plotinfo.minorGridlayer.selectAll("path").remove();
              if (plotinfo.gridlayer) plotinfo.gridlayer.selectAll("path").remove();
              if (plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll("path").remove();
              fullLayout._infolayer.select(".g-" + xa._id + "title").remove();
              fullLayout._infolayer.select(".g-" + ya._id + "title").remove();
            }
          });
        }
        var axList = !arg || arg === "redraw" ? axes.listIds(gd) : arg;
        var fullAxList = axes.list(gd);
        var overlayingShiftedAx = fullAxList.filter(function(ax) {
          return ax.autoshift;
        }).map(function(ax) {
          return ax.overlaying;
        });
        axList.map(function(axId) {
          var ax = axes.getFromId(gd, axId);
          if (ax.tickmode === "sync" && ax.overlaying) {
            var overlayingIndex = axList.findIndex(function(axis) {
              return axis === ax.overlaying;
            });
            if (overlayingIndex >= 0) {
              axList.unshift(axList.splice(overlayingIndex, 1).shift());
            }
          }
        });
        var axShifts = { false: { left: 0, right: 0 } };
        return Lib.syncOrAsync(axList.map(function(axId) {
          return function() {
            if (!axId) return;
            var ax = axes.getFromId(gd, axId);
            if (!opts) opts = {};
            opts.axShifts = axShifts;
            opts.overlayingShiftedAx = overlayingShiftedAx;
            var axDone = axes.drawOne(gd, ax, opts);
            if (ax._shiftPusher) {
              incrementShift(ax, ax._fullDepth || 0, axShifts, true);
            }
            ax._r = ax.range.slice();
            ax._rl = Lib.simpleMap(ax._r, ax.r2l);
            return axDone;
          };
        }));
      };
      axes.drawOne = function(gd, ax, opts) {
        opts = opts || {};
        var axShifts = opts.axShifts || {};
        var overlayingShiftedAx = opts.overlayingShiftedAx || [];
        var i, sp, plotinfo;
        ax.setScale();
        var fullLayout = gd._fullLayout;
        var axId = ax._id;
        var axLetter = axId.charAt(0);
        var counterLetter = axes.counterLetter(axId);
        var mainPlotinfo = fullLayout._plots[ax._mainSubplot];
        if (!mainPlotinfo) return;
        ax._shiftPusher = ax.autoshift || overlayingShiftedAx.indexOf(ax._id) !== -1 || overlayingShiftedAx.indexOf(ax.overlaying) !== -1;
        if (ax._shiftPusher & ax.anchor === "free") {
          var selfPush = ax.linewidth / 2 || 0;
          if (ax.ticks === "inside") {
            selfPush += ax.ticklen;
          }
          incrementShift(ax, selfPush, axShifts, true);
          incrementShift(ax, ax.shift || 0, axShifts, false);
        }
        if (opts.skipTitle !== true || ax._shift === void 0) ax._shift = setShiftVal(ax, axShifts);
        var mainAxLayer = mainPlotinfo[axLetter + "axislayer"];
        var mainLinePosition = ax._mainLinePosition;
        var mainLinePositionShift = mainLinePosition += ax._shift;
        var mainMirrorPosition = ax._mainMirrorPosition;
        var vals = ax._vals = axes.calcTicks(ax);
        var axInfo = [ax.mirror, mainLinePositionShift, mainMirrorPosition].join("_");
        for (i = 0; i < vals.length; i++) {
          vals[i].axInfo = axInfo;
        }
        ax._selections = {};
        if (ax._tickAngles) ax._prevTickAngles = ax._tickAngles;
        ax._tickAngles = {};
        ax._depth = null;
        var llbboxes = {};
        function getLabelLevelBbox(suffix) {
          var cls = axId + (suffix || "tick");
          if (!llbboxes[cls]) llbboxes[cls] = calcLabelLevelBbox(ax, cls, mainLinePositionShift);
          return llbboxes[cls];
        }
        if (!ax.visible) return;
        var transTickFn = axes.makeTransTickFn(ax);
        var transTickLabelFn = axes.makeTransTickLabelFn(ax);
        var tickVals;
        var valsClipped;
        var insideTicks = ax.ticks === "inside";
        var outsideTicks = ax.ticks === "outside";
        if (ax.tickson === "boundaries") {
          var boundaryVals = getBoundaryVals(ax, vals);
          valsClipped = axes.clipEnds(ax, boundaryVals);
          tickVals = insideTicks ? valsClipped : boundaryVals;
        } else {
          valsClipped = axes.clipEnds(ax, vals);
          tickVals = insideTicks && ax.ticklabelmode !== "period" ? valsClipped : vals;
        }
        var gridVals = ax._gridVals = valsClipped;
        var dividerVals = getDividerVals(ax, vals);
        if (!fullLayout._hasOnlyLargeSploms) {
          var subplotsWithAx = ax._subplotsWith;
          var finishedGrids = {};
          for (i = 0; i < subplotsWithAx.length; i++) {
            sp = subplotsWithAx[i];
            plotinfo = fullLayout._plots[sp];
            var counterAxis = plotinfo[counterLetter + "axis"];
            var mainCounterID = counterAxis._mainAxis._id;
            if (finishedGrids[mainCounterID]) continue;
            finishedGrids[mainCounterID] = 1;
            var gridPath = axLetter === "x" ? "M0," + counterAxis._offset + "v" + counterAxis._length : "M" + counterAxis._offset + ",0h" + counterAxis._length;
            axes.drawGrid(gd, ax, {
              vals: gridVals,
              counterAxis,
              layer: plotinfo.gridlayer.select("." + axId),
              minorLayer: plotinfo.minorGridlayer.select("." + axId),
              path: gridPath,
              transFn: transTickFn
            });
            axes.drawZeroLine(gd, ax, {
              counterAxis,
              layer: plotinfo.zerolinelayer,
              path: gridPath,
              transFn: transTickFn
            });
          }
        }
        var tickPath;
        var majorTickSigns = axes.getTickSigns(ax);
        var minorTickSigns = axes.getTickSigns(ax, "minor");
        if (ax.ticks || ax.minor && ax.minor.ticks) {
          var majorTickPath = axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[2]);
          var minorTickPath = axes.makeTickPath(ax, mainLinePositionShift, minorTickSigns[2], { minor: true });
          var mirrorMajorTickPath;
          var mirrorMinorTickPath;
          var fullMajorTickPath;
          var fullMinorTickPath;
          if (ax._anchorAxis && ax.mirror && ax.mirror !== true) {
            mirrorMajorTickPath = axes.makeTickPath(ax, mainMirrorPosition, majorTickSigns[3]);
            mirrorMinorTickPath = axes.makeTickPath(ax, mainMirrorPosition, minorTickSigns[3], { minor: true });
            fullMajorTickPath = majorTickPath + mirrorMajorTickPath;
            fullMinorTickPath = minorTickPath + mirrorMinorTickPath;
          } else {
            mirrorMajorTickPath = "";
            mirrorMinorTickPath = "";
            fullMajorTickPath = majorTickPath;
            fullMinorTickPath = minorTickPath;
          }
          if (ax.showdividers && outsideTicks && ax.tickson === "boundaries") {
            var dividerLookup = {};
            for (i = 0; i < dividerVals.length; i++) {
              dividerLookup[dividerVals[i].x] = 1;
            }
            tickPath = function(d) {
              return dividerLookup[d.x] ? mirrorMajorTickPath : fullMajorTickPath;
            };
          } else {
            tickPath = function(d) {
              return d.minor ? fullMinorTickPath : fullMajorTickPath;
            };
          }
        }
        axes.drawTicks(gd, ax, {
          vals: tickVals,
          layer: mainAxLayer,
          path: tickPath,
          transFn: transTickFn
        });
        if (ax.mirror === "allticks") {
          var tickSubplots = Object.keys(ax._linepositions || {});
          for (i = 0; i < tickSubplots.length; i++) {
            sp = tickSubplots[i];
            plotinfo = fullLayout._plots[sp];
            var linepositions = ax._linepositions[sp] || [];
            var p0 = linepositions[0];
            var p1 = linepositions[1];
            var isMinor = linepositions[2];
            var spTickPath = axes.makeTickPath(
              ax,
              p0,
              isMinor ? majorTickSigns[0] : minorTickSigns[0],
              { minor: isMinor }
            ) + axes.makeTickPath(
              ax,
              p1,
              isMinor ? majorTickSigns[1] : minorTickSigns[1],
              { minor: isMinor }
            );
            axes.drawTicks(gd, ax, {
              vals: tickVals,
              layer: plotinfo[axLetter + "axislayer"],
              path: spTickPath,
              transFn: transTickFn
            });
          }
        }
        var seq = [];
        seq.push(function() {
          return axes.drawLabels(gd, ax, {
            vals,
            layer: mainAxLayer,
            plotinfo,
            transFn: transTickLabelFn,
            labelFns: axes.makeLabelFns(ax, mainLinePositionShift)
          });
        });
        if (ax.type === "multicategory") {
          var pad = { x: 2, y: 10 }[axLetter];
          seq.push(function() {
            var bboxKey = { x: "height", y: "width" }[axLetter];
            var standoff = getLabelLevelBbox()[bboxKey] + pad + (ax._tickAngles[axId + "tick"] ? ax.tickfont.size * LINE_SPACING : 0);
            return axes.drawLabels(gd, ax, {
              vals: getSecondaryLabelVals(ax, vals),
              layer: mainAxLayer,
              cls: axId + "tick2",
              repositionOnUpdate: true,
              secondary: true,
              transFn: transTickFn,
              labelFns: axes.makeLabelFns(ax, mainLinePositionShift + standoff * majorTickSigns[4])
            });
          });
          seq.push(function() {
            ax._depth = majorTickSigns[4] * (getLabelLevelBbox("tick2")[ax.side] - mainLinePositionShift);
            return drawDividers(gd, ax, {
              vals: dividerVals,
              layer: mainAxLayer,
              path: axes.makeTickPath(ax, mainLinePositionShift, majorTickSigns[4], { len: ax._depth }),
              transFn: transTickFn
            });
          });
        } else if (ax.title.hasOwnProperty("standoff")) {
          seq.push(function() {
            ax._depth = majorTickSigns[4] * (getLabelLevelBbox()[ax.side] - mainLinePositionShift);
          });
        }
        var hasRangeSlider = Registry.getComponentMethod("rangeslider", "isVisible")(ax);
        if (!opts.skipTitle && !(hasRangeSlider && ax.side === "bottom")) {
          seq.push(function() {
            return drawTitle(gd, ax);
          });
        }
        seq.push(function() {
          var s = ax.side.charAt(0);
          var sMirror = OPPOSITE_SIDE[ax.side].charAt(0);
          var pos = axes.getPxPosition(gd, ax);
          var outsideTickLen = outsideTicks ? ax.ticklen : 0;
          var llbbox;
          var push;
          var mirrorPush;
          var rangeSliderPush;
          if (ax.automargin || hasRangeSlider || ax._shiftPusher) {
            if (ax.type === "multicategory") {
              llbbox = getLabelLevelBbox("tick2");
            } else {
              llbbox = getLabelLevelBbox();
              if (axLetter === "x" && s === "b") {
                ax._depth = Math.max(llbbox.width > 0 ? llbbox.bottom - pos : 0, outsideTickLen);
              }
            }
          }
          var axDepth = 0;
          var titleDepth = 0;
          if (ax._shiftPusher) {
            axDepth = Math.max(
              outsideTickLen,
              llbbox.height > 0 ? s === "l" ? pos - llbbox.left : llbbox.right - pos : 0
            );
            if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
              titleDepth = (ax._titleStandoff || 0) + (ax._titleScoot || 0);
              if (s === "l") {
                titleDepth += approxTitleDepth(ax);
              }
            }
            ax._fullDepth = Math.max(axDepth, titleDepth);
          }
          if (ax.automargin) {
            push = { x: 0, y: 0, r: 0, l: 0, t: 0, b: 0 };
            var domainIndices = [0, 1];
            var shift = typeof ax._shift === "number" ? ax._shift : 0;
            if (axLetter === "x") {
              if (s === "b") {
                push[s] = ax._depth;
              } else {
                push[s] = ax._depth = Math.max(llbbox.width > 0 ? pos - llbbox.top : 0, outsideTickLen);
                domainIndices.reverse();
              }
              if (llbbox.width > 0) {
                var rExtra = llbbox.right - (ax._offset + ax._length);
                if (rExtra > 0) {
                  push.xr = 1;
                  push.r = rExtra;
                }
                var lExtra = ax._offset - llbbox.left;
                if (lExtra > 0) {
                  push.xl = 0;
                  push.l = lExtra;
                }
              }
            } else {
              if (s === "l") {
                ax._depth = Math.max(llbbox.height > 0 ? pos - llbbox.left : 0, outsideTickLen);
                push[s] = ax._depth - shift;
              } else {
                ax._depth = Math.max(llbbox.height > 0 ? llbbox.right - pos : 0, outsideTickLen);
                push[s] = ax._depth + shift;
                domainIndices.reverse();
              }
              if (llbbox.height > 0) {
                var bExtra = llbbox.bottom - (ax._offset + ax._length);
                if (bExtra > 0) {
                  push.yb = 0;
                  push.b = bExtra;
                }
                var tExtra = ax._offset - llbbox.top;
                if (tExtra > 0) {
                  push.yt = 1;
                  push.t = tExtra;
                }
              }
            }
            push[counterLetter] = ax.anchor === "free" ? ax.position : ax._anchorAxis.domain[domainIndices[0]];
            if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
              push[s] += approxTitleDepth(ax) + (ax.title.standoff || 0);
            }
            if (ax.mirror && ax.anchor !== "free") {
              mirrorPush = { x: 0, y: 0, r: 0, l: 0, t: 0, b: 0 };
              mirrorPush[sMirror] = ax.linewidth;
              if (ax.mirror && ax.mirror !== true) mirrorPush[sMirror] += outsideTickLen;
              if (ax.mirror === true || ax.mirror === "ticks") {
                mirrorPush[counterLetter] = ax._anchorAxis.domain[domainIndices[1]];
              } else if (ax.mirror === "all" || ax.mirror === "allticks") {
                mirrorPush[counterLetter] = [ax._counterDomainMin, ax._counterDomainMax][domainIndices[1]];
              }
            }
          }
          if (hasRangeSlider) {
            rangeSliderPush = Registry.getComponentMethod("rangeslider", "autoMarginOpts")(gd, ax);
          }
          if (typeof ax.automargin === "string") {
            filterPush(push, ax.automargin);
            filterPush(mirrorPush, ax.automargin);
          }
          Plots.autoMargin(gd, axAutoMarginID(ax), push);
          Plots.autoMargin(gd, axMirrorAutoMarginID(ax), mirrorPush);
          Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);
        });
        return Lib.syncOrAsync(seq);
      };
      function filterPush(push, automargin) {
        if (!push) return;
        var keepMargin = Object.keys(MARGIN_MAPPING).reduce(function(data, nextKey) {
          if (automargin.indexOf(nextKey) !== -1) {
            MARGIN_MAPPING[nextKey].forEach(function(key) {
              data[key] = 1;
            });
          }
          return data;
        }, {});
        Object.keys(push).forEach(function(key) {
          if (!keepMargin[key]) {
            if (key.length === 1) push[key] = 0;
            else delete push[key];
          }
        });
      }
      function getBoundaryVals(ax, vals) {
        var out = [];
        var i;
        var _push = function(d, bndIndex) {
          var xb = d.xbnd[bndIndex];
          if (xb !== null) {
            out.push(Lib.extendFlat({}, d, { x: xb }));
          }
        };
        if (vals.length) {
          for (i = 0; i < vals.length; i++) {
            _push(vals[i], 0);
          }
          _push(vals[i - 1], 1);
        }
        return out;
      }
      function getSecondaryLabelVals(ax, vals) {
        var out = [];
        var lookup = {};
        for (var i = 0; i < vals.length; i++) {
          var d = vals[i];
          if (lookup[d.text2]) {
            lookup[d.text2].push(d.x);
          } else {
            lookup[d.text2] = [d.x];
          }
        }
        for (var k in lookup) {
          out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));
        }
        return out;
      }
      function getDividerVals(ax, vals) {
        var out = [];
        var i, current;
        var reversed = vals.length && vals[vals.length - 1].x < vals[0].x;
        var _push = function(d2, bndIndex) {
          var xb = d2.xbnd[bndIndex];
          if (xb !== null) {
            out.push(Lib.extendFlat({}, d2, { x: xb }));
          }
        };
        if (ax.showdividers && vals.length) {
          for (i = 0; i < vals.length; i++) {
            var d = vals[i];
            if (d.text2 !== current) {
              _push(d, reversed ? 1 : 0);
            }
            current = d.text2;
          }
          _push(vals[i - 1], reversed ? 0 : 1);
        }
        return out;
      }
      function calcLabelLevelBbox(ax, cls, mainLinePositionShift) {
        var top, bottom;
        var left, right;
        if (ax._selections[cls].size()) {
          top = Infinity;
          bottom = -Infinity;
          left = Infinity;
          right = -Infinity;
          ax._selections[cls].each(function() {
            var thisLabel = selectTickLabel(this);
            var bb = Drawing.bBox(thisLabel.node().parentNode);
            top = Math.min(top, bb.top);
            bottom = Math.max(bottom, bb.bottom);
            left = Math.min(left, bb.left);
            right = Math.max(right, bb.right);
          });
        } else {
          var dummyCalc = axes.makeLabelFns(ax, mainLinePositionShift);
          top = bottom = dummyCalc.yFn({ dx: 0, dy: 0, fontSize: 0 });
          left = right = dummyCalc.xFn({ dx: 0, dy: 0, fontSize: 0 });
        }
        return {
          top,
          bottom,
          left,
          right,
          height: bottom - top,
          width: right - left
        };
      }
      axes.getTickSigns = function(ax, minor) {
        var axLetter = ax._id.charAt(0);
        var sideOpposite = { x: "top", y: "right" }[axLetter];
        var main = ax.side === sideOpposite ? 1 : -1;
        var out = [-1, 1, main, -main];
        var ticks = minor ? (ax.minor || {}).ticks : ax.ticks;
        if (ticks !== "inside" === (axLetter === "x")) {
          out = out.map(function(v) {
            return -v;
          });
        }
        if (ax.side) {
          out.push({ l: -1, t: -1, r: 1, b: 1 }[ax.side.charAt(0)]);
        }
        return out;
      };
      axes.makeTransTickFn = function(ax) {
        return ax._id.charAt(0) === "x" ? function(d) {
          return strTranslate(ax._offset + ax.l2p(d.x), 0);
        } : function(d) {
          return strTranslate(0, ax._offset + ax.l2p(d.x));
        };
      };
      axes.makeTransTickLabelFn = function(ax) {
        var uv = getTickLabelUV(ax);
        var shift = ax.ticklabelshift || 0;
        var standoff = ax.ticklabelstandoff || 0;
        var u = uv[0];
        var v = uv[1];
        var isReversed = ax.range[0] > ax.range[1];
        var labelsInside = ax.ticklabelposition && ax.ticklabelposition.indexOf("inside") !== -1;
        var labelsOutside = !labelsInside;
        if (shift) {
          var shiftSign = isReversed ? -1 : 1;
          shift = shift * shiftSign;
        }
        if (standoff) {
          var side = ax.side;
          var standoffSign = labelsInside && (side === "top" || side === "left") || labelsOutside && (side === "bottom" || side === "right") ? 1 : -1;
          standoff = standoff * standoffSign;
        }
        return ax._id.charAt(0) === "x" ? function(d) {
          return strTranslate(
            u + ax._offset + ax.l2p(getPosX(d)) + shift,
            v + standoff
          );
        } : function(d) {
          return strTranslate(
            v + standoff,
            u + ax._offset + ax.l2p(getPosX(d)) + shift
          );
        };
      };
      function getPosX(d) {
        return d.periodX !== void 0 ? d.periodX : d.x;
      }
      function getTickLabelUV(ax) {
        var ticklabelposition = ax.ticklabelposition || "";
        var has = function(str) {
          return ticklabelposition.indexOf(str) !== -1;
        };
        var isTop = has("top");
        var isLeft = has("left");
        var isRight = has("right");
        var isBottom = has("bottom");
        var isInside = has("inside");
        var isAligned = isBottom || isLeft || isTop || isRight;
        if (!isAligned && !isInside) return [0, 0];
        var side = ax.side;
        var u = isAligned ? (ax.tickwidth || 0) / 2 : 0;
        var v = TEXTPAD;
        var fontSize = ax.tickfont ? ax.tickfont.size : 12;
        if (isBottom || isTop) {
          u += fontSize * CAP_SHIFT;
          v += (ax.linewidth || 0) / 2;
        }
        if (isLeft || isRight) {
          u += (ax.linewidth || 0) / 2;
          v += TEXTPAD;
        }
        if (isInside && side === "top") {
          v -= fontSize * (1 - CAP_SHIFT);
        }
        if (isLeft || isTop) u = -u;
        if (side === "bottom" || side === "right") v = -v;
        return [
          isAligned ? u : 0,
          isInside ? v : 0
        ];
      }
      axes.makeTickPath = function(ax, shift, sgn, opts) {
        if (!opts) opts = {};
        var minor = opts.minor;
        if (minor && !ax.minor) return "";
        var len = opts.len !== void 0 ? opts.len : minor ? ax.minor.ticklen : ax.ticklen;
        var axLetter = ax._id.charAt(0);
        var pad = (ax.linewidth || 1) / 2;
        return axLetter === "x" ? "M0," + (shift + pad * sgn) + "v" + len * sgn : "M" + (shift + pad * sgn) + ",0h" + len * sgn;
      };
      axes.makeLabelFns = function(ax, shift, angle) {
        var ticklabelposition = ax.ticklabelposition || "";
        var has = function(str) {
          return ticklabelposition.indexOf(str) !== -1;
        };
        var isTop = has("top");
        var isLeft = has("left");
        var isRight = has("right");
        var isBottom = has("bottom");
        var isAligned = isBottom || isLeft || isTop || isRight;
        var insideTickLabels = has("inside");
        var labelsOverTicks = ticklabelposition === "inside" && ax.ticks === "inside" || !insideTickLabels && ax.ticks === "outside" && ax.tickson !== "boundaries";
        var labelStandoff = 0;
        var labelShift = 0;
        var tickLen = labelsOverTicks ? ax.ticklen : 0;
        if (insideTickLabels) {
          tickLen *= -1;
        } else if (isAligned) {
          tickLen = 0;
        }
        if (labelsOverTicks) {
          labelStandoff += tickLen;
          if (angle) {
            var rad = Lib.deg2rad(angle);
            labelStandoff = tickLen * Math.cos(rad) + 1;
            labelShift = tickLen * Math.sin(rad);
          }
        }
        if (ax.showticklabels && (labelsOverTicks || ax.showline)) {
          labelStandoff += 0.2 * ax.tickfont.size;
        }
        labelStandoff += (ax.linewidth || 1) / 2 * (insideTickLabels ? -1 : 1);
        var out = {
          labelStandoff,
          labelShift
        };
        var x0, y0, ff, flipIt;
        var xQ = 0;
        var side = ax.side;
        var axLetter = ax._id.charAt(0);
        var tickangle = ax.tickangle;
        var endSide;
        if (axLetter === "x") {
          endSide = !insideTickLabels && side === "bottom" || insideTickLabels && side === "top";
          flipIt = endSide ? 1 : -1;
          if (insideTickLabels) flipIt *= -1;
          x0 = labelShift * flipIt;
          y0 = shift + labelStandoff * flipIt;
          ff = endSide ? 1 : -0.2;
          if (Math.abs(tickangle) === 90) {
            if (insideTickLabels) {
              ff += MID_SHIFT;
            } else {
              if (tickangle === -90 && side === "bottom") {
                ff = CAP_SHIFT;
              } else if (tickangle === 90 && side === "top") {
                ff = MID_SHIFT;
              } else {
                ff = 0.5;
              }
            }
            xQ = MID_SHIFT / 2 * (tickangle / 90);
          }
          out.xFn = function(d) {
            return d.dx + x0 + xQ * d.fontSize;
          };
          out.yFn = function(d) {
            return d.dy + y0 + d.fontSize * ff;
          };
          out.anchorFn = function(d, a) {
            if (isAligned) {
              if (isLeft) return "end";
              if (isRight) return "start";
            }
            if (!isNumeric(a) || a === 0 || a === 180) {
              return "middle";
            }
            return a * flipIt < 0 !== insideTickLabels ? "end" : "start";
          };
          out.heightFn = function(d, a, h) {
            return a < -60 || a > 60 ? -0.5 * h : ax.side === "top" !== insideTickLabels ? -h : 0;
          };
        } else if (axLetter === "y") {
          endSide = !insideTickLabels && side === "left" || insideTickLabels && side === "right";
          flipIt = endSide ? 1 : -1;
          if (insideTickLabels) flipIt *= -1;
          x0 = labelStandoff;
          y0 = labelShift * flipIt;
          ff = 0;
          if (!insideTickLabels && Math.abs(tickangle) === 90) {
            if (tickangle === -90 && side === "left" || tickangle === 90 && side === "right") {
              ff = CAP_SHIFT;
            } else {
              ff = 0.5;
            }
          }
          if (insideTickLabels) {
            var ang = isNumeric(tickangle) ? +tickangle : 0;
            if (ang !== 0) {
              var rA = Lib.deg2rad(ang);
              xQ = Math.abs(Math.sin(rA)) * CAP_SHIFT * flipIt;
              ff = 0;
            }
          }
          out.xFn = function(d) {
            return d.dx + shift - (x0 + d.fontSize * ff) * flipIt + xQ * d.fontSize;
          };
          out.yFn = function(d) {
            return d.dy + y0 + d.fontSize * MID_SHIFT;
          };
          out.anchorFn = function(d, a) {
            if (isNumeric(a) && Math.abs(a) === 90) {
              return "middle";
            }
            return endSide ? "end" : "start";
          };
          out.heightFn = function(d, a, h) {
            if (ax.side === "right") a *= -1;
            return a < -30 ? -h : a < 30 ? -0.5 * h : 0;
          };
        }
        return out;
      };
      function tickDataFn(d) {
        return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join("_");
      }
      axes.drawTicks = function(gd, ax, opts) {
        opts = opts || {};
        var cls = ax._id + "tick";
        var vals = [].concat(
          ax.minor && ax.minor.ticks ? (
            // minor vals
            opts.vals.filter(function(d) {
              return d.minor && !d.noTick;
            })
          ) : []
        ).concat(
          ax.ticks ? (
            // major vals
            opts.vals.filter(function(d) {
              return !d.minor && !d.noTick;
            })
          ) : []
        );
        var ticks = opts.layer.selectAll("path." + cls).data(vals, tickDataFn);
        ticks.exit().remove();
        ticks.enter().append("path").classed(cls, 1).classed("ticks", 1).classed("crisp", opts.crisp !== false).each(function(d) {
          return Color.stroke(d3.select(this), d.minor ? ax.minor.tickcolor : ax.tickcolor);
        }).style("stroke-width", function(d) {
          return Drawing.crispRound(
            gd,
            d.minor ? ax.minor.tickwidth : ax.tickwidth,
            1
          ) + "px";
        }).attr("d", opts.path).style("display", null);
        hideCounterAxisInsideTickLabels(ax, [TICK_PATH]);
        ticks.attr("transform", opts.transFn);
      };
      axes.drawGrid = function(gd, ax, opts) {
        opts = opts || {};
        if (ax.tickmode === "sync") {
          return;
        }
        var cls = ax._id + "grid";
        var hasMinor = ax.minor && ax.minor.showgrid;
        var minorVals = hasMinor ? opts.vals.filter(function(d) {
          return d.minor;
        }) : [];
        var majorVals = ax.showgrid ? opts.vals.filter(function(d) {
          return !d.minor;
        }) : [];
        var counterAx = opts.counterAxis;
        if (counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {
          var isArrayMode = ax.tickmode === "array";
          for (var i = 0; i < majorVals.length; i++) {
            var xi = majorVals[i].x;
            if (isArrayMode ? !xi : Math.abs(xi) < ax.dtick / 100) {
              majorVals = majorVals.slice(0, i).concat(majorVals.slice(i + 1));
              if (isArrayMode) i--;
              else break;
            }
          }
        }
        ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);
        var wMinor = !hasMinor ? 0 : Drawing.crispRound(gd, ax.minor.gridwidth, 1);
        var majorLayer = opts.layer;
        var minorLayer = opts.minorLayer;
        for (var major = 1; major >= 0; major--) {
          var layer = major ? majorLayer : minorLayer;
          if (!layer) continue;
          var grid = layer.selectAll("path." + cls).data(major ? majorVals : minorVals, tickDataFn);
          grid.exit().remove();
          grid.enter().append("path").classed(cls, 1).classed("crisp", opts.crisp !== false);
          grid.attr("transform", opts.transFn).attr("d", opts.path).each(function(d) {
            return Color.stroke(
              d3.select(this),
              d.minor ? ax.minor.gridcolor : ax.gridcolor || "#ddd"
            );
          }).style("stroke-dasharray", function(d) {
            return Drawing.dashStyle(
              d.minor ? ax.minor.griddash : ax.griddash,
              d.minor ? ax.minor.gridwidth : ax.gridwidth
            );
          }).style("stroke-width", function(d) {
            return (d.minor ? wMinor : ax._gw) + "px";
          }).style("display", null);
          if (typeof opts.path === "function") grid.attr("d", opts.path);
        }
        hideCounterAxisInsideTickLabels(ax, [GRID_PATH, MINORGRID_PATH]);
      };
      axes.drawZeroLine = function(gd, ax, opts) {
        opts = opts || opts;
        var cls = ax._id + "zl";
        var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);
        var zl = opts.layer.selectAll("path." + cls).data(show ? [{ x: 0, id: ax._id }] : []);
        zl.exit().remove();
        zl.enter().append("path").classed(cls, 1).classed("zl", 1).classed("crisp", opts.crisp !== false).each(function() {
          opts.layer.selectAll("path").sort(function(da, db) {
            return idSort(da.id, db.id);
          });
        });
        zl.attr("transform", opts.transFn).attr("d", opts.path).call(Color.stroke, ax.zerolinecolor || Color.defaultLine).style("stroke-width", Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + "px").style("display", null);
        hideCounterAxisInsideTickLabels(ax, [ZERO_PATH]);
      };
      axes.drawLabels = function(gd, ax, opts) {
        opts = opts || {};
        var fullLayout = gd._fullLayout;
        var axId = ax._id;
        var cls = opts.cls || axId + "tick";
        var vals = opts.vals.filter(function(d) {
          return d.text;
        });
        var labelFns = opts.labelFns;
        var tickAngle = opts.secondary ? 0 : ax.tickangle;
        var prevAngle = (ax._prevTickAngles || {})[cls];
        var tickLabels = opts.layer.selectAll("g." + cls).data(ax.showticklabels ? vals : [], tickDataFn);
        var labelsReady = [];
        tickLabels.enter().append("g").classed(cls, 1).append("text").attr("text-anchor", "middle").each(function(d) {
          var thisLabel = d3.select(this);
          var newPromise = gd._promises.length;
          thisLabel.call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d)).call(Drawing.font, {
            family: d.font,
            size: d.fontSize,
            color: d.fontColor,
            weight: d.fontWeight,
            style: d.fontStyle,
            variant: d.fontVariant,
            textcase: d.fontTextcase,
            lineposition: d.fontLineposition,
            shadow: d.fontShadow
          }).text(d.text).call(svgTextUtils.convertToTspans, gd);
          if (gd._promises[newPromise]) {
            labelsReady.push(gd._promises.pop().then(function() {
              positionLabels(thisLabel, tickAngle);
            }));
          } else {
            positionLabels(thisLabel, tickAngle);
          }
        });
        hideCounterAxisInsideTickLabels(ax, [TICK_TEXT]);
        tickLabels.exit().remove();
        if (opts.repositionOnUpdate) {
          tickLabels.each(function(d) {
            d3.select(this).select("text").call(svgTextUtils.positionText, labelFns.xFn(d), labelFns.yFn(d));
          });
        }
        function positionLabels(s, angle) {
          s.each(function(d) {
            var thisLabel = d3.select(this);
            var mathjaxGroup = thisLabel.select(".text-math-group");
            var anchor = labelFns.anchorFn(d, angle);
            var transform = opts.transFn.call(thisLabel.node(), d) + (isNumeric(angle) && +angle !== 0 ? " rotate(" + angle + "," + labelFns.xFn(d) + "," + (labelFns.yFn(d) - d.fontSize / 2) + ")" : "");
            var nLines = svgTextUtils.lineCount(thisLabel);
            var lineHeight = LINE_SPACING * d.fontSize;
            var anchorHeight = labelFns.heightFn(d, isNumeric(angle) ? +angle : 0, (nLines - 1) * lineHeight);
            if (anchorHeight) {
              transform += strTranslate(0, anchorHeight);
            }
            if (mathjaxGroup.empty()) {
              var thisText = thisLabel.select("text");
              thisText.attr({
                transform,
                "text-anchor": anchor
              });
              thisText.style("opacity", 1);
              if (ax._adjustTickLabelsOverflow) {
                ax._adjustTickLabelsOverflow();
              }
            } else {
              var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;
              var mjShift = mjWidth * { end: -0.5, start: 0.5 }[anchor];
              mathjaxGroup.attr("transform", transform + strTranslate(mjShift, 0));
            }
          });
        }
        ax._adjustTickLabelsOverflow = function() {
          var ticklabeloverflow = ax.ticklabeloverflow;
          if (!ticklabeloverflow || ticklabeloverflow === "allow") return;
          var hideOverflow = ticklabeloverflow.indexOf("hide") !== -1;
          var isX = ax._id.charAt(0) === "x";
          var p02 = 0;
          var p12 = isX ? gd._fullLayout.width : gd._fullLayout.height;
          if (ticklabeloverflow.indexOf("domain") !== -1) {
            var rl = Lib.simpleMap(ax.range, ax.r2l);
            p02 = ax.l2p(rl[0]) + ax._offset;
            p12 = ax.l2p(rl[1]) + ax._offset;
          }
          var min = Math.min(p02, p12);
          var max = Math.max(p02, p12);
          var side = ax.side;
          var visibleLabelMin = Infinity;
          var visibleLabelMax = -Infinity;
          tickLabels.each(function(d) {
            var thisLabel = d3.select(this);
            var mathjaxGroup = thisLabel.select(".text-math-group");
            if (mathjaxGroup.empty()) {
              var bb = Drawing.bBox(thisLabel.node());
              var adjust = 0;
              if (isX) {
                if (bb.right > max) adjust = 1;
                else if (bb.left < min) adjust = 1;
              } else {
                if (bb.bottom > max) adjust = 1;
                else if (bb.top + (ax.tickangle ? 0 : d.fontSize / 4) < min) adjust = 1;
              }
              var t = thisLabel.select("text");
              if (adjust) {
                if (hideOverflow) t.style("opacity", 0);
              } else {
                t.style("opacity", 1);
                if (side === "bottom" || side === "right") {
                  visibleLabelMin = Math.min(visibleLabelMin, isX ? bb.top : bb.left);
                } else {
                  visibleLabelMin = -Infinity;
                }
                if (side === "top" || side === "left") {
                  visibleLabelMax = Math.max(visibleLabelMax, isX ? bb.bottom : bb.right);
                } else {
                  visibleLabelMax = Infinity;
                }
              }
            }
          });
          for (var subplot in fullLayout._plots) {
            var plotinfo = fullLayout._plots[subplot];
            if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
            var anchorAx2 = isX ? plotinfo.yaxis : plotinfo.xaxis;
            if (anchorAx2) {
              anchorAx2["_visibleLabelMin_" + ax._id] = visibleLabelMin;
              anchorAx2["_visibleLabelMax_" + ax._id] = visibleLabelMax;
            }
          }
        };
        ax._hideCounterAxisInsideTickLabels = function(partialOpts) {
          var isX = ax._id.charAt(0) === "x";
          var anchoredAxes = [];
          for (var subplot in fullLayout._plots) {
            var plotinfo = fullLayout._plots[subplot];
            if (ax._id !== plotinfo.xaxis._id && ax._id !== plotinfo.yaxis._id) continue;
            anchoredAxes.push(isX ? plotinfo.yaxis : plotinfo.xaxis);
          }
          anchoredAxes.forEach(function(anchorAx2, idx) {
            if (anchorAx2 && insideTicklabelposition(anchorAx2)) {
              (partialOpts || [
                ZERO_PATH,
                MINORGRID_PATH,
                GRID_PATH,
                TICK_PATH,
                TICK_TEXT
              ]).forEach(function(e) {
                var isPeriodLabel = e.K === "tick" && e.L === "text" && ax.ticklabelmode === "period";
                var mainPlotinfo = fullLayout._plots[ax._mainSubplot];
                var sel;
                if (e.K === ZERO_PATH.K) sel = mainPlotinfo.zerolinelayer.selectAll("." + ax._id + "zl");
                else if (e.K === MINORGRID_PATH.K) sel = mainPlotinfo.minorGridlayer.selectAll("." + ax._id);
                else if (e.K === GRID_PATH.K) sel = mainPlotinfo.gridlayer.selectAll("." + ax._id);
                else sel = mainPlotinfo[ax._id.charAt(0) + "axislayer"];
                sel.each(function() {
                  var w = d3.select(this);
                  if (e.L) w = w.selectAll(e.L);
                  w.each(function(d) {
                    var q = ax.l2p(
                      isPeriodLabel ? getPosX(d) : d.x
                    ) + ax._offset;
                    var t = d3.select(this);
                    if (q < ax["_visibleLabelMax_" + anchorAx2._id] && q > ax["_visibleLabelMin_" + anchorAx2._id]) {
                      t.style("display", "none");
                    } else if (e.K === "tick" && !idx) {
                      t.style("display", null);
                    }
                  });
                });
              });
            }
          });
        };
        positionLabels(tickLabels, prevAngle + 1 ? prevAngle : tickAngle);
        function allLabelsReady() {
          return labelsReady.length && Promise.all(labelsReady);
        }
        var autoangle = null;
        function fixLabelOverlaps() {
          positionLabels(tickLabels, tickAngle);
          if (vals.length && ax.autotickangles && (ax.type !== "log" || String(ax.dtick).charAt(0) !== "D")) {
            autoangle = ax.autotickangles[0];
            var maxFontSize = 0;
            var lbbArray = [];
            var i;
            var maxLines = 1;
            tickLabels.each(function(d) {
              maxFontSize = Math.max(maxFontSize, d.fontSize);
              var x = ax.l2p(d.x);
              var thisLabel = selectTickLabel(this);
              var bb = Drawing.bBox(thisLabel.node());
              maxLines = Math.max(maxLines, svgTextUtils.lineCount(thisLabel));
              lbbArray.push({
                // ignore about y, just deal with x overlaps
                top: 0,
                bottom: 10,
                height: 10,
                left: x - bb.width / 2,
                // impose a 2px gap
                right: x + bb.width / 2 + 2,
                width: bb.width + 2
              });
            });
            var preventOverlapWithTick = (ax.tickson === "boundaries" || ax.showdividers) && !opts.secondary;
            var vLen = vals.length;
            var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);
            var adjacent = preventOverlapWithTick ? tickSpacing / 2 : tickSpacing;
            var opposite = preventOverlapWithTick ? ax.ticklen : maxFontSize * 1.25 * maxLines;
            var hypotenuse = Math.sqrt(Math.pow(adjacent, 2) + Math.pow(opposite, 2));
            var maxCos = adjacent / hypotenuse;
            var autoTickAnglesRadians = ax.autotickangles.map(
              function(degrees) {
                return degrees * Math.PI / 180;
              }
            );
            var angleRadians = autoTickAnglesRadians.find(
              function(angle) {
                return Math.abs(Math.cos(angle)) <= maxCos;
              }
            );
            if (angleRadians === void 0) {
              angleRadians = autoTickAnglesRadians.reduce(
                function(currentMax, nextAngle) {
                  return Math.abs(Math.cos(currentMax)) < Math.abs(Math.cos(nextAngle)) ? currentMax : nextAngle;
                },
                autoTickAnglesRadians[0]
              );
            }
            var newAngle = angleRadians * (180 / Math.PI);
            if (preventOverlapWithTick) {
              var gap = 2;
              if (ax.ticks) gap += ax.tickwidth / 2;
              for (i = 0; i < lbbArray.length; i++) {
                var xbnd = vals[i].xbnd;
                var lbb = lbbArray[i];
                if (xbnd[0] !== null && lbb.left - ax.l2p(xbnd[0]) < gap || xbnd[1] !== null && ax.l2p(xbnd[1]) - lbb.right < gap) {
                  autoangle = newAngle;
                  break;
                }
              }
            } else {
              var ticklabelposition = ax.ticklabelposition || "";
              var has = function(str) {
                return ticklabelposition.indexOf(str) !== -1;
              };
              var isTop = has("top");
              var isLeft = has("left");
              var isRight = has("right");
              var isBottom = has("bottom");
              var isAligned = isBottom || isLeft || isTop || isRight;
              var pad = !isAligned ? 0 : (ax.tickwidth || 0) + 2 * TEXTPAD;
              for (i = 0; i < lbbArray.length - 1; i++) {
                if (Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1], pad)) {
                  autoangle = newAngle;
                  break;
                }
              }
            }
            if (autoangle) {
              positionLabels(tickLabels, autoangle);
            }
          }
        }
        if (ax._selections) {
          ax._selections[cls] = tickLabels;
        }
        var seq = [allLabelsReady];
        if (ax.automargin && fullLayout._redrawFromAutoMarginCount && prevAngle === 90) {
          autoangle = prevAngle;
          seq.push(function() {
            positionLabels(tickLabels, prevAngle);
          });
        } else {
          seq.push(fixLabelOverlaps);
        }
        if (ax._tickAngles) {
          seq.push(function() {
            ax._tickAngles[cls] = autoangle === null ? isNumeric(tickAngle) ? tickAngle : 0 : autoangle;
          });
        }
        var computeTickLabelBoundingBoxes = function() {
          var labelsMaxW = 0;
          var labelsMaxH = 0;
          tickLabels.each(function(d, i) {
            var thisLabel = selectTickLabel(this);
            var mathjaxGroup = thisLabel.select(".text-math-group");
            if (mathjaxGroup.empty()) {
              var bb;
              if (ax._vals[i]) {
                bb = ax._vals[i].bb || Drawing.bBox(thisLabel.node());
                ax._vals[i].bb = bb;
              }
              labelsMaxW = Math.max(labelsMaxW, bb.width);
              labelsMaxH = Math.max(labelsMaxH, bb.height);
            }
          });
          return {
            labelsMaxW,
            labelsMaxH
          };
        };
        var anchorAx = ax._anchorAxis;
        if (anchorAx && (anchorAx.autorange || anchorAx.insiderange) && insideTicklabelposition(ax) && !isLinked(fullLayout, ax._id)) {
          if (!fullLayout._insideTickLabelsUpdaterange) {
            fullLayout._insideTickLabelsUpdaterange = {};
          }
          if (anchorAx.autorange) {
            fullLayout._insideTickLabelsUpdaterange[anchorAx._name + ".autorange"] = anchorAx.autorange;
            seq.push(computeTickLabelBoundingBoxes);
          }
          if (anchorAx.insiderange) {
            var BBs = computeTickLabelBoundingBoxes();
            var move = ax._id.charAt(0) === "y" ? BBs.labelsMaxW : BBs.labelsMaxH;
            move += 2 * TEXTPAD;
            if (ax.ticklabelposition === "inside") {
              move += ax.ticklen || 0;
            }
            var sgn = ax.side === "right" || ax.side === "top" ? 1 : -1;
            var index = sgn === 1 ? 1 : 0;
            var otherIndex = sgn === 1 ? 0 : 1;
            var newRange = [];
            newRange[otherIndex] = anchorAx.range[otherIndex];
            var anchorAxRange = anchorAx.range;
            var p0 = anchorAx.r2p(anchorAxRange[index]);
            var p1 = anchorAx.r2p(anchorAxRange[otherIndex]);
            var _tempNewRange = fullLayout._insideTickLabelsUpdaterange[anchorAx._name + ".range"];
            if (_tempNewRange) {
              var q0 = anchorAx.r2p(_tempNewRange[index]);
              var q1 = anchorAx.r2p(_tempNewRange[otherIndex]);
              var dir = sgn * (ax._id.charAt(0) === "y" ? 1 : -1);
              if (dir * p0 < dir * q0) {
                p0 = q0;
                newRange[index] = anchorAxRange[index] = _tempNewRange[index];
              }
              if (dir * p1 > dir * q1) {
                p1 = q1;
                newRange[otherIndex] = anchorAxRange[otherIndex] = _tempNewRange[otherIndex];
              }
            }
            var dist = Math.abs(p1 - p0);
            if (dist - move > 0) {
              dist -= move;
              move *= 1 + move / dist;
            } else {
              move = 0;
            }
            if (ax._id.charAt(0) !== "y") move = -move;
            newRange[index] = anchorAx.p2r(
              anchorAx.r2p(anchorAxRange[index]) + sgn * move
            );
            if (anchorAx.autorange === "min" || anchorAx.autorange === "max reversed") {
              newRange[0] = null;
              anchorAx._rangeInitial0 = void 0;
              anchorAx._rangeInitial1 = void 0;
            } else if (anchorAx.autorange === "max" || anchorAx.autorange === "min reversed") {
              newRange[1] = null;
              anchorAx._rangeInitial0 = void 0;
              anchorAx._rangeInitial1 = void 0;
            }
            fullLayout._insideTickLabelsUpdaterange[anchorAx._name + ".range"] = newRange;
          }
        }
        var done = Lib.syncOrAsync(seq);
        if (done && done.then) gd._promises.push(done);
        return done;
      };
      function drawDividers(gd, ax, opts) {
        var cls = ax._id + "divider";
        var vals = opts.vals;
        var dividers = opts.layer.selectAll("path." + cls).data(vals, tickDataFn);
        dividers.exit().remove();
        dividers.enter().insert("path", ":first-child").classed(cls, 1).classed("crisp", 1).call(Color.stroke, ax.dividercolor).style("stroke-width", Drawing.crispRound(gd, ax.dividerwidth, 1) + "px");
        dividers.attr("transform", opts.transFn).attr("d", opts.path);
      }
      axes.getPxPosition = function(gd, ax) {
        var gs = gd._fullLayout._size;
        var axLetter = ax._id.charAt(0);
        var side = ax.side;
        var anchorAxis;
        if (ax.anchor !== "free") {
          anchorAxis = ax._anchorAxis;
        } else if (axLetter === "x") {
          anchorAxis = {
            _offset: gs.t + (1 - (ax.position || 0)) * gs.h,
            _length: 0
          };
        } else if (axLetter === "y") {
          anchorAxis = {
            _offset: gs.l + (ax.position || 0) * gs.w + ax._shift,
            _length: 0
          };
        }
        if (side === "top" || side === "left") {
          return anchorAxis._offset;
        } else if (side === "bottom" || side === "right") {
          return anchorAxis._offset + anchorAxis._length;
        }
      };
      function approxTitleDepth(ax) {
        var fontSize = ax.title.font.size;
        var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
        if (ax.title.hasOwnProperty("standoff")) {
          return fontSize * (CAP_SHIFT + extraLines * LINE_SPACING);
        } else {
          return extraLines ? fontSize * (extraLines + 1) * LINE_SPACING : fontSize;
        }
      }
      function drawTitle(gd, ax) {
        var fullLayout = gd._fullLayout;
        var axId = ax._id;
        var axLetter = axId.charAt(0);
        var fontSize = ax.title.font.size;
        var titleStandoff;
        var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
        if (ax.title.hasOwnProperty("standoff")) {
          if (ax.side === "bottom" || ax.side === "right") {
            titleStandoff = ax._depth + ax.title.standoff + fontSize * CAP_SHIFT;
          } else if (ax.side === "top" || ax.side === "left") {
            titleStandoff = ax._depth + ax.title.standoff + fontSize * (MID_SHIFT + extraLines * LINE_SPACING);
          }
        } else {
          var isInside = insideTicklabelposition(ax);
          if (ax.type === "multicategory") {
            titleStandoff = ax._depth;
          } else {
            var offsetBase = 1.5 * fontSize;
            if (isInside) {
              offsetBase = 0.5 * fontSize;
              if (ax.ticks === "outside") {
                offsetBase += ax.ticklen;
              }
            }
            titleStandoff = 10 + offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);
          }
          if (!isInside) {
            if (axLetter === "x") {
              titleStandoff += ax.side === "top" ? fontSize * (ax.showticklabels ? 1 : 0) : fontSize * (ax.showticklabels ? 1.5 : 0.5);
            } else {
              titleStandoff += ax.side === "right" ? fontSize * (ax.showticklabels ? 1 : 0.5) : fontSize * (ax.showticklabels ? 0.5 : 0);
            }
          }
        }
        var pos = axes.getPxPosition(gd, ax);
        var transform, x, y;
        if (axLetter === "x") {
          x = ax._offset + ax._length / 2;
          y = ax.side === "top" ? pos - titleStandoff : pos + titleStandoff;
        } else {
          y = ax._offset + ax._length / 2;
          x = ax.side === "right" ? pos + titleStandoff : pos - titleStandoff;
          transform = { rotate: "-90", offset: 0 };
        }
        var avoid;
        if (ax.type !== "multicategory") {
          var tickLabels = ax._selections[ax._id + "tick"];
          avoid = {
            selection: tickLabels,
            side: ax.side
          };
          if (tickLabels && tickLabels.node() && tickLabels.node().parentNode) {
            var translation = Drawing.getTranslate(tickLabels.node().parentNode);
            avoid.offsetLeft = translation.x;
            avoid.offsetTop = translation.y;
          }
          if (ax.title.hasOwnProperty("standoff")) {
            avoid.pad = 0;
          }
        }
        ax._titleStandoff = titleStandoff;
        return Titles.draw(gd, axId + "title", {
          propContainer: ax,
          propName: ax._name + ".title.text",
          placeholder: fullLayout._dfltTitle[axLetter],
          avoid,
          transform,
          attributes: { x, y, "text-anchor": "middle" }
        });
      }
      axes.shouldShowZeroLine = function(gd, ax, counterAxis) {
        var rng = Lib.simpleMap(ax.range, ax.r2l);
        return rng[0] * rng[1] <= 0 && ax.zeroline && (ax.type === "linear" || ax.type === "-") && !(ax.rangebreaks && ax.maskBreaks(0) === BADNUM) && (clipEnds(ax, 0) || !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) || hasBarsOrFill(gd, ax));
      };
      axes.clipEnds = function(ax, vals) {
        return vals.filter(function(d) {
          return clipEnds(ax, d.x);
        });
      };
      function clipEnds(ax, l) {
        var p = ax.l2p(l);
        return p > 1 && p < ax._length - 1;
      }
      function anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {
        var mainCounterAxis = counterAxis._mainAxis;
        if (!mainCounterAxis) return;
        var fullLayout = gd._fullLayout;
        var axLetter = ax._id.charAt(0);
        var counterLetter = axes.counterLetter(ax._id);
        var zeroPosition = ax._offset + (Math.abs(rng[0]) < Math.abs(rng[1]) === (axLetter === "x") ? 0 : ax._length);
        function lineNearZero(ax2) {
          if (!ax2.showline || !ax2.linewidth) return false;
          var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);
          function closeEnough(pos2) {
            return typeof pos2 === "number" && Math.abs(pos2 - zeroPosition) < tolerance;
          }
          if (closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {
            return true;
          }
          var linePositions = ax2._linepositions || {};
          for (var k in linePositions) {
            if (closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {
              return true;
            }
          }
        }
        var plotinfo = fullLayout._plots[counterAxis._mainSubplot];
        if (!(plotinfo.mainplotinfo || plotinfo).overlays.length) {
          return lineNearZero(counterAxis, zeroPosition);
        }
        var counterLetterAxes = axes.list(gd, counterLetter);
        for (var i = 0; i < counterLetterAxes.length; i++) {
          var counterAxis2 = counterLetterAxes[i];
          if (counterAxis2._mainAxis === mainCounterAxis && lineNearZero(counterAxis2, zeroPosition)) {
            return true;
          }
        }
      }
      function hasBarsOrFill(gd, ax) {
        var fullData = gd._fullData;
        var subplot = ax._mainSubplot;
        var axLetter = ax._id.charAt(0);
        for (var i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          if (trace.visible === true && trace.xaxis + trace.yaxis === subplot) {
            if (Registry.traceIs(trace, "bar-like") && trace.orientation === { x: "h", y: "v" }[axLetter]) return true;
            if (trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter) return true;
          }
        }
        return false;
      }
      function selectTickLabel(gTick) {
        var s = d3.select(gTick);
        var mj = s.select(".text-math-group");
        return mj.empty() ? s.select("text") : mj;
      }
      axes.allowAutoMargin = function(gd) {
        var axList = axes.list(gd, "", true);
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          if (ax.automargin) {
            Plots.allowAutoMargin(gd, axAutoMarginID(ax));
            if (ax.mirror) {
              Plots.allowAutoMargin(gd, axMirrorAutoMarginID(ax));
            }
          }
          if (Registry.getComponentMethod("rangeslider", "isVisible")(ax)) {
            Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));
          }
        }
      };
      function axAutoMarginID(ax) {
        return ax._id + ".automargin";
      }
      function axMirrorAutoMarginID(ax) {
        return axAutoMarginID(ax) + ".mirror";
      }
      function rangeSliderAutoMarginID(ax) {
        return ax._id + ".rangeslider";
      }
      axes.swap = function(gd, traces) {
        var axGroups = makeAxisGroups(gd, traces);
        for (var i = 0; i < axGroups.length; i++) {
          swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);
        }
      };
      function makeAxisGroups(gd, traces) {
        var groups = [];
        var i, j;
        for (i = 0; i < traces.length; i++) {
          var groupsi = [];
          var xi = gd._fullData[traces[i]].xaxis;
          var yi = gd._fullData[traces[i]].yaxis;
          if (!xi || !yi) continue;
          for (j = 0; j < groups.length; j++) {
            if (groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {
              groupsi.push(j);
            }
          }
          if (!groupsi.length) {
            groups.push({ x: [xi], y: [yi] });
            continue;
          }
          var group0 = groups[groupsi[0]];
          var groupj;
          if (groupsi.length > 1) {
            for (j = 1; j < groupsi.length; j++) {
              groupj = groups[groupsi[j]];
              mergeAxisGroups(group0.x, groupj.x);
              mergeAxisGroups(group0.y, groupj.y);
            }
          }
          mergeAxisGroups(group0.x, [xi]);
          mergeAxisGroups(group0.y, [yi]);
        }
        return groups;
      }
      function mergeAxisGroups(intoSet, fromSet) {
        for (var i = 0; i < fromSet.length; i++) {
          if (intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);
        }
      }
      function swapAxisGroup(gd, xIds, yIds) {
        var xFullAxes = [];
        var yFullAxes = [];
        var layout = gd.layout;
        var i, j;
        for (i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));
        for (i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));
        var allAxKeys = Object.keys(axAttrs);
        var noSwapAttrs = [
          "anchor",
          "domain",
          "overlaying",
          "position",
          "side",
          "tickangle",
          "editType"
        ];
        var numericTypes = ["linear", "log"];
        for (i = 0; i < allAxKeys.length; i++) {
          var keyi = allAxKeys[i];
          var xVal = xFullAxes[0][keyi];
          var yVal = yFullAxes[0][keyi];
          var allEqual = true;
          var coerceLinearX = false;
          var coerceLinearY = false;
          if (keyi.charAt(0) === "_" || typeof xVal === "function" || noSwapAttrs.indexOf(keyi) !== -1) {
            continue;
          }
          for (j = 1; j < xFullAxes.length && allEqual; j++) {
            var xVali = xFullAxes[j][keyi];
            if (keyi === "type" && numericTypes.indexOf(xVal) !== -1 && numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {
              coerceLinearX = true;
            } else if (xVali !== xVal) allEqual = false;
          }
          for (j = 1; j < yFullAxes.length && allEqual; j++) {
            var yVali = yFullAxes[j][keyi];
            if (keyi === "type" && numericTypes.indexOf(yVal) !== -1 && numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {
              coerceLinearY = true;
            } else if (yFullAxes[j][keyi] !== yVal) allEqual = false;
          }
          if (allEqual) {
            if (coerceLinearX) layout[xFullAxes[0]._name].type = "linear";
            if (coerceLinearY) layout[yFullAxes[0]._name].type = "linear";
            swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);
          }
        }
        for (i = 0; i < gd._fullLayout.annotations.length; i++) {
          var ann = gd._fullLayout.annotations[i];
          if (xIds.indexOf(ann.xref) !== -1 && yIds.indexOf(ann.yref) !== -1) {
            Lib.swapAttrs(layout.annotations[i], ["?"]);
          }
        }
      }
      function swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {
        var np = Lib.nestedProperty;
        var xVal = np(layout[xFullAxes[0]._name], key).get();
        var yVal = np(layout[yFullAxes[0]._name], key).get();
        var i;
        if (key === "title") {
          if (xVal && xVal.text === dfltTitle.x) {
            xVal.text = dfltTitle.y;
          }
          if (yVal && yVal.text === dfltTitle.y) {
            yVal.text = dfltTitle.x;
          }
        }
        for (i = 0; i < xFullAxes.length; i++) {
          np(layout, xFullAxes[i]._name + "." + key).set(yVal);
        }
        for (i = 0; i < yFullAxes.length; i++) {
          np(layout, yFullAxes[i]._name + "." + key).set(xVal);
        }
      }
      function isAngular(ax) {
        return ax._id === "angularaxis";
      }
      function moveOutsideBreak(v, ax) {
        var len = ax._rangebreaks.length;
        for (var k = 0; k < len; k++) {
          var brk = ax._rangebreaks[k];
          if (v >= brk.min && v < brk.max) {
            return brk.max;
          }
        }
        return v;
      }
      function insideTicklabelposition(ax) {
        return (ax.ticklabelposition || "").indexOf("inside") !== -1;
      }
      function hideCounterAxisInsideTickLabels(ax, opts) {
        if (insideTicklabelposition(ax._anchorAxis || {})) {
          if (ax._hideCounterAxisInsideTickLabels) {
            ax._hideCounterAxisInsideTickLabels(opts);
          }
        }
      }
      function incrementShift(ax, shiftVal, axShifts, normalize) {
        var overlay = ax.anchor !== "free" && (ax.overlaying === void 0 || ax.overlaying === false) ? ax._id : ax.overlaying;
        var shiftValAdj;
        if (normalize) {
          shiftValAdj = ax.side === "right" ? shiftVal : -shiftVal;
        } else {
          shiftValAdj = shiftVal;
        }
        if (!(overlay in axShifts)) {
          axShifts[overlay] = {};
        }
        if (!(ax.side in axShifts[overlay])) {
          axShifts[overlay][ax.side] = 0;
        }
        axShifts[overlay][ax.side] += shiftValAdj;
      }
      function setShiftVal(ax, axShifts) {
        return ax.autoshift ? axShifts[ax.overlaying][ax.side] : ax.shift || 0;
      }
      function periodCompatibleWithTickformat(period, tickformat) {
        return /%f/.test(tickformat) ? period >= ONEMICROSEC : /%L/.test(tickformat) ? period >= ONEMILLI : /%[SX]/.test(tickformat) ? period >= ONESEC : /%M/.test(tickformat) ? period >= ONEMIN : /%[HI]/.test(tickformat) ? period >= ONEHOUR : /%p/.test(tickformat) ? period >= HALFDAY : /%[Aadejuwx]/.test(tickformat) ? period >= ONEDAY : /%[UVW]/.test(tickformat) ? period >= ONEWEEK : /%[Bbm]/.test(tickformat) ? period >= ONEMINMONTH : /%[q]/.test(tickformat) ? period >= ONEMINQUARTER : /%[Yy]/.test(tickformat) ? period >= ONEMINYEAR : true;
      }
    }
  });

  // src/plots/cartesian/autorange_options_defaults.js
  var require_autorange_options_defaults = __commonJS({
    "src/plots/cartesian/autorange_options_defaults.js"(exports, module) {
      "use strict";
      module.exports = function handleAutorangeOptionsDefaults(coerce, autorange, range) {
        var minRange, maxRange;
        if (range) {
          var isReversed = autorange === "reversed" || autorange === "min reversed" || autorange === "max reversed";
          minRange = range[isReversed ? 1 : 0];
          maxRange = range[isReversed ? 0 : 1];
        }
        var minallowed = coerce("autorangeoptions.minallowed", maxRange === null ? minRange : void 0);
        var maxallowed = coerce("autorangeoptions.maxallowed", minRange === null ? maxRange : void 0);
        if (minallowed === void 0) coerce("autorangeoptions.clipmin");
        if (maxallowed === void 0) coerce("autorangeoptions.clipmax");
        coerce("autorangeoptions.include");
      };
    }
  });

  // src/plots/cartesian/range_defaults.js
  var require_range_defaults = __commonJS({
    "src/plots/cartesian/range_defaults.js"(exports, module) {
      "use strict";
      var handleAutorangeOptionsDefaults = require_autorange_options_defaults();
      module.exports = function handleRangeDefaults(containerIn, containerOut, coerce, options) {
        var axTemplate = containerOut._template || {};
        var axType = containerOut.type || axTemplate.type || "-";
        coerce("minallowed");
        coerce("maxallowed");
        var range = coerce("range");
        if (!range) {
          var insiderange;
          if (!options.noInsiderange && axType !== "log") {
            insiderange = coerce("insiderange");
            if (insiderange && (insiderange[0] === null || insiderange[1] === null)) {
              containerOut.insiderange = false;
              insiderange = void 0;
            }
            if (insiderange) range = coerce("range", insiderange);
          }
        }
        var autorangeDflt = containerOut.getAutorangeDflt(range, options);
        var autorange = coerce("autorange", autorangeDflt);
        var shouldAutorange;
        if (range && (range[0] === null && range[1] === null || (range[0] === null || range[1] === null) && (autorange === "reversed" || autorange === true) || range[0] !== null && (autorange === "min" || autorange === "max reversed") || range[1] !== null && (autorange === "max" || autorange === "min reversed"))) {
          range = void 0;
          delete containerOut.range;
          containerOut.autorange = true;
          shouldAutorange = true;
        }
        if (!shouldAutorange) {
          autorangeDflt = containerOut.getAutorangeDflt(range, options);
          autorange = coerce("autorange", autorangeDflt);
        }
        if (autorange) {
          handleAutorangeOptionsDefaults(coerce, autorange, range);
          if (axType === "linear" || axType === "-") coerce("rangemode");
        }
        containerOut.cleanRange();
      };
    }
  });

  // node_modules/mouse-event-offset/index.js
  var require_mouse_event_offset = __commonJS({
    "node_modules/mouse-event-offset/index.js"(exports, module) {
      var rootPosition = { left: 0, top: 0 };
      module.exports = mouseEventOffset;
      function mouseEventOffset(ev, target, out) {
        target = target || ev.currentTarget || ev.srcElement;
        if (!Array.isArray(out)) {
          out = [0, 0];
        }
        var cx = ev.clientX || 0;
        var cy = ev.clientY || 0;
        var rect = getBoundingClientOffset(target);
        out[0] = cx - rect.left;
        out[1] = cy - rect.top;
        return out;
      }
      function getBoundingClientOffset(element) {
        if (element === window || element === document || element === document.body) {
          return rootPosition;
        } else {
          return element.getBoundingClientRect();
        }
      }
    }
  });

  // node_modules/has-passive-events/index.js
  var require_has_passive_events = __commonJS({
    "node_modules/has-passive-events/index.js"(exports, module) {
      "use strict";
      var isBrowser = require_client();
      function detect() {
        var supported = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supported = true;
            }
          });
          window.addEventListener("test", null, opts);
          window.removeEventListener("test", null, opts);
        } catch (e) {
          supported = false;
        }
        return supported;
      }
      module.exports = isBrowser && detect();
    }
  });

  // src/components/dragelement/align.js
  var require_align = __commonJS({
    "src/components/dragelement/align.js"(exports, module) {
      "use strict";
      module.exports = function align(v, dv, v0, v1, anchor) {
        var vmin = (v - v0) / (v1 - v0);
        var vmax = vmin + dv / (v1 - v0);
        var vc = (vmin + vmax) / 2;
        if (anchor === "left" || anchor === "bottom") return vmin;
        if (anchor === "center" || anchor === "middle") return vc;
        if (anchor === "right" || anchor === "top") return vmax;
        if (vmin < 2 / 3 - vc) return vmin;
        if (vmax > 4 / 3 - vc) return vmax;
        return vc;
      };
    }
  });

  // src/components/dragelement/cursor.js
  var require_cursor = __commonJS({
    "src/components/dragelement/cursor.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var cursorset = [
        ["sw-resize", "s-resize", "se-resize"],
        ["w-resize", "move", "e-resize"],
        ["nw-resize", "n-resize", "ne-resize"]
      ];
      module.exports = function getCursor(x, y, xanchor, yanchor) {
        if (xanchor === "left") x = 0;
        else if (xanchor === "center") x = 1;
        else if (xanchor === "right") x = 2;
        else x = Lib.constrain(Math.floor(x * 3), 0, 2);
        if (yanchor === "bottom") y = 0;
        else if (yanchor === "middle") y = 1;
        else if (yanchor === "top") y = 2;
        else y = Lib.constrain(Math.floor(y * 3), 0, 2);
        return cursorset[y][x];
      };
    }
  });

  // src/components/dragelement/unhover.js
  var require_unhover = __commonJS({
    "src/components/dragelement/unhover.js"(exports, module) {
      "use strict";
      var Events = require_events2();
      var throttle = require_throttle();
      var getGraphDiv = require_dom().getGraphDiv;
      var hoverConstants = require_constants();
      var unhover = module.exports = {};
      unhover.wrapped = function(gd, evt, subplot) {
        gd = getGraphDiv(gd);
        if (gd._fullLayout) {
          throttle.clear(gd._fullLayout._uid + hoverConstants.HOVERID);
        }
        unhover.raw(gd, evt, subplot);
      };
      unhover.raw = function raw(gd, evt) {
        var fullLayout = gd._fullLayout;
        var oldhoverdata = gd._hoverdata;
        if (!evt) evt = {};
        if (evt.target && !gd._dragged && Events.triggerHandler(gd, "plotly_beforehover", evt) === false) {
          return;
        }
        fullLayout._hoverlayer.selectAll("g").remove();
        fullLayout._hoverlayer.selectAll("line").remove();
        fullLayout._hoverlayer.selectAll("circle").remove();
        gd._hoverdata = void 0;
        if (evt.target && oldhoverdata) {
          gd.emit("plotly_unhover", {
            event: evt,
            points: oldhoverdata
          });
        }
      };
    }
  });

  // src/components/dragelement/index.js
  var require_dragelement = __commonJS({
    "src/components/dragelement/index.js"(exports, module) {
      "use strict";
      var mouseOffset = require_mouse_event_offset();
      var hasHover = require_has_hover();
      var supportsPassive = require_has_passive_events();
      var removeElement = require_lib().removeElement;
      var constants = require_constants2();
      var dragElement = module.exports = {};
      dragElement.align = require_align();
      dragElement.getCursor = require_cursor();
      var unhover = require_unhover();
      dragElement.unhover = unhover.wrapped;
      dragElement.unhoverRaw = unhover.raw;
      dragElement.init = function init(options) {
        var gd = options.gd;
        var numClicks = 1;
        var doubleClickDelay = gd._context.doubleClickDelay;
        var element = options.element;
        var startX, startY, newMouseDownTime, cursor, dragCover, initialEvent, initialTarget, rightClick;
        if (!gd._mouseDownTime) gd._mouseDownTime = 0;
        element.style.pointerEvents = "all";
        element.onmousedown = onStart;
        if (!supportsPassive) {
          element.ontouchstart = onStart;
        } else {
          if (element._ontouchstart) {
            element.removeEventListener("touchstart", element._ontouchstart);
          }
          element._ontouchstart = onStart;
          element.addEventListener("touchstart", onStart, { passive: false });
        }
        function _clampFn(dx, dy, minDrag) {
          if (Math.abs(dx) < minDrag) dx = 0;
          if (Math.abs(dy) < minDrag) dy = 0;
          return [dx, dy];
        }
        var clampFn = options.clampFn || _clampFn;
        function onStart(e) {
          gd._dragged = false;
          gd._dragging = true;
          var offset = pointerOffset(e);
          startX = offset[0];
          startY = offset[1];
          initialTarget = e.target;
          initialEvent = e;
          rightClick = e.buttons === 2 || e.ctrlKey;
          if (typeof e.clientX === "undefined" && typeof e.clientY === "undefined") {
            e.clientX = startX;
            e.clientY = startY;
          }
          newMouseDownTime = (/* @__PURE__ */ new Date()).getTime();
          if (newMouseDownTime - gd._mouseDownTime < doubleClickDelay) {
            numClicks += 1;
          } else {
            numClicks = 1;
            gd._mouseDownTime = newMouseDownTime;
          }
          if (options.prepFn) options.prepFn(e, startX, startY);
          if (hasHover && !rightClick) {
            dragCover = coverSlip();
            dragCover.style.cursor = window.getComputedStyle(element).cursor;
          } else if (!hasHover) {
            dragCover = document;
            cursor = window.getComputedStyle(document.documentElement).cursor;
            document.documentElement.style.cursor = window.getComputedStyle(element).cursor;
          }
          document.addEventListener("mouseup", onDone);
          document.addEventListener("touchend", onDone);
          if (options.dragmode !== false) {
            e.preventDefault();
            document.addEventListener("mousemove", onMove);
            document.addEventListener("touchmove", onMove, { passive: false });
          }
          return;
        }
        function onMove(e) {
          e.preventDefault();
          var offset = pointerOffset(e);
          var minDrag = options.minDrag || constants.MINDRAG;
          var dxdy = clampFn(offset[0] - startX, offset[1] - startY, minDrag);
          var dx = dxdy[0];
          var dy = dxdy[1];
          if (dx || dy) {
            gd._dragged = true;
            dragElement.unhover(gd, e);
          }
          if (gd._dragged && options.moveFn && !rightClick) {
            gd._dragdata = {
              element,
              dx,
              dy
            };
            options.moveFn(dx, dy);
          }
          return;
        }
        function onDone(e) {
          delete gd._dragdata;
          if (options.dragmode !== false) {
            e.preventDefault();
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("touchmove", onMove);
          }
          document.removeEventListener("mouseup", onDone);
          document.removeEventListener("touchend", onDone);
          if (hasHover) {
            removeElement(dragCover);
          } else if (cursor) {
            dragCover.documentElement.style.cursor = cursor;
            cursor = null;
          }
          if (!gd._dragging) {
            gd._dragged = false;
            return;
          }
          gd._dragging = false;
          if ((/* @__PURE__ */ new Date()).getTime() - gd._mouseDownTime > doubleClickDelay) {
            numClicks = Math.max(numClicks - 1, 1);
          }
          if (gd._dragged) {
            if (options.doneFn) options.doneFn();
          } else {
            var clickEvent;
            if (initialEvent.target === initialTarget) {
              clickEvent = initialEvent;
            } else {
              clickEvent = {
                target: initialTarget,
                srcElement: initialTarget,
                toElement: initialTarget
              };
              Object.keys(initialEvent).concat(Object.keys(initialEvent.__proto__)).forEach((k) => {
                var v = initialEvent[k];
                if (!clickEvent[k] && typeof v !== "function") {
                  clickEvent[k] = v;
                }
              });
            }
            if (options.clickFn) options.clickFn(numClicks, clickEvent);
            if (!rightClick) {
              initialTarget.dispatchEvent(new MouseEvent("click", e));
            }
          }
          gd._dragging = false;
          gd._dragged = false;
          return;
        }
      };
      function coverSlip() {
        var cover = document.createElement("div");
        cover.className = "dragcover";
        var cStyle = cover.style;
        cStyle.position = "fixed";
        cStyle.left = 0;
        cStyle.right = 0;
        cStyle.top = 0;
        cStyle.bottom = 0;
        cStyle.zIndex = 999999999;
        cStyle.background = "none";
        document.body.appendChild(cover);
        return cover;
      }
      dragElement.coverSlip = coverSlip;
      function pointerOffset(e) {
        return mouseOffset(
          e.changedTouches ? e.changedTouches[0] : e,
          document.body
        );
      }
    }
  });

  // src/lib/setcursor.js
  var require_setcursor = __commonJS({
    "src/lib/setcursor.js"(exports, module) {
      "use strict";
      module.exports = function setCursor(el3, csr) {
        (el3.attr("class") || "").split(" ").forEach(function(cls) {
          if (cls.indexOf("cursor-") === 0) el3.classed(cls, false);
        });
        if (csr) el3.classed("cursor-" + csr, true);
      };
    }
  });

  // src/lib/override_cursor.js
  var require_override_cursor = __commonJS({
    "src/lib/override_cursor.js"(exports, module) {
      "use strict";
      var setCursor = require_setcursor();
      var STASHATTR = "data-savedcursor";
      var NO_CURSOR = "!!";
      module.exports = function overrideCursor(el3, csr) {
        var savedCursor = el3.attr(STASHATTR);
        if (csr) {
          if (!savedCursor) {
            var classes = (el3.attr("class") || "").split(" ");
            for (var i = 0; i < classes.length; i++) {
              var cls = classes[i];
              if (cls.indexOf("cursor-") === 0) {
                el3.attr(STASHATTR, cls.substr(7)).classed(cls, false);
              }
            }
            if (!el3.attr(STASHATTR)) {
              el3.attr(STASHATTR, NO_CURSOR);
            }
          }
          setCursor(el3, csr);
        } else if (savedCursor) {
          el3.attr(STASHATTR, null);
          if (savedCursor === NO_CURSOR) setCursor(el3);
          else setCursor(el3, savedCursor);
        }
      };
    }
  });

  // src/components/legend/attributes.js
  var require_attributes9 = __commonJS({
    "src/components/legend/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      module.exports = {
        // not really a 'subplot' attribute container,
        // but this is the flag we use to denote attributes that
        // support yaxis, yaxis2, yaxis3, ... counters
        _isSubplotObj: true,
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "legend"
        },
        bgcolor: {
          valType: "color",
          editType: "legend"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "legend"
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "legend"
        },
        font: fontAttrs({
          editType: "legend"
        }),
        grouptitlefont: fontAttrs({
          editType: "legend"
        }),
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          dflt: "v",
          editType: "legend"
        },
        traceorder: {
          valType: "flaglist",
          flags: ["reversed", "grouped"],
          extras: ["normal"],
          editType: "legend"
        },
        tracegroupgap: {
          valType: "number",
          min: 0,
          dflt: 10,
          editType: "legend"
        },
        entrywidth: {
          valType: "number",
          min: 0,
          editType: "legend"
        },
        entrywidthmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "pixels",
          editType: "legend"
        },
        indentation: {
          valType: "number",
          min: -15,
          dflt: 0,
          editType: "legend"
        },
        itemsizing: {
          valType: "enumerated",
          values: ["trace", "constant"],
          dflt: "trace",
          editType: "legend"
        },
        itemwidth: {
          valType: "number",
          min: 30,
          dflt: 30,
          editType: "legend"
        },
        itemclick: {
          valType: "enumerated",
          values: ["toggle", "toggleothers", false],
          dflt: "toggle",
          editType: "legend"
        },
        itemdoubleclick: {
          valType: "enumerated",
          values: ["toggle", "toggleothers", false],
          dflt: "toggleothers",
          editType: "legend"
        },
        groupclick: {
          valType: "enumerated",
          values: ["toggleitem", "togglegroup"],
          dflt: "togglegroup",
          editType: "legend"
        },
        x: {
          valType: "number",
          editType: "legend"
        },
        xref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "left",
          editType: "legend"
        },
        y: {
          valType: "number",
          editType: "legend"
        },
        yref: {
          valType: "enumerated",
          dflt: "paper",
          values: ["container", "paper"],
          editType: "layoutstyle"
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          editType: "legend"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        valign: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"],
          dflt: "middle",
          editType: "legend"
        },
        title: {
          text: {
            valType: "string",
            dflt: "",
            editType: "legend"
          },
          font: fontAttrs({
            editType: "legend"
          }),
          side: {
            valType: "enumerated",
            values: ["top", "left", "top left", "top center", "top right"],
            editType: "legend"
          },
          editType: "legend"
        },
        editType: "legend"
      };
    }
  });

  // src/components/legend/helpers.js
  var require_helpers3 = __commonJS({
    "src/components/legend/helpers.js"(exports) {
      "use strict";
      exports.isGrouped = function isGrouped(legendLayout) {
        return (legendLayout.traceorder || "").indexOf("grouped") !== -1;
      };
      exports.isVertical = function isVertical(legendLayout) {
        return legendLayout.orientation !== "h";
      };
      exports.isReversed = function isReversed(legendLayout) {
        return (legendLayout.traceorder || "").indexOf("reversed") !== -1;
      };
    }
  });

  // src/components/legend/defaults.js
  var require_defaults3 = __commonJS({
    "src/components/legend/defaults.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var Template = require_plot_template();
      var plotsAttrs = require_attributes2();
      var attributes = require_attributes9();
      var basePlotLayoutAttributes = require_layout_attributes2();
      var helpers = require_helpers3();
      function groupDefaults(legendId, layoutIn, layoutOut, fullData) {
        var containerIn = layoutIn[legendId] || {};
        var containerOut = Template.newContainer(layoutOut, legendId);
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        var itemFont = Lib.coerceFont(coerce, "font", layoutOut.font);
        coerce("bgcolor", layoutOut.paper_bgcolor);
        coerce("bordercolor");
        var visible = coerce("visible");
        if (!visible) return;
        var trace;
        var traceCoerce = function(attr, dflt) {
          var traceIn = trace._input;
          var traceOut = trace;
          return Lib.coerce(traceIn, traceOut, plotsAttrs, attr, dflt);
        };
        var globalFont = layoutOut.font || {};
        var grouptitlefont = Lib.coerceFont(coerce, "grouptitlefont", globalFont, { overrideDflt: {
          size: Math.round(globalFont.size * 1.1)
        } });
        var legendTraceCount = 0;
        var legendReallyHasATrace = false;
        var defaultOrder = "normal";
        var shapesWithLegend = (layoutOut.shapes || []).filter(function(d) {
          return d.showlegend;
        });
        var allLegendItems = fullData.concat(shapesWithLegend).filter(function(d) {
          return legendId === (d.legend || "legend");
        });
        for (var i = 0; i < allLegendItems.length; i++) {
          trace = allLegendItems[i];
          if (!trace.visible) continue;
          var isShape = trace._isShape;
          if (trace.showlegend || trace._dfltShowLegend && !(trace._module && trace._module.attributes && trace._module.attributes.showlegend && trace._module.attributes.showlegend.dflt === false)) {
            legendTraceCount++;
            if (trace.showlegend) {
              legendReallyHasATrace = true;
              if (!isShape && Registry.traceIs(trace, "pie-like") || trace._input.showlegend === true) {
                legendTraceCount++;
              }
            }
            Lib.coerceFont(traceCoerce, "legendgrouptitle.font", grouptitlefont);
          }
          if (!isShape && Registry.traceIs(trace, "bar") && layoutOut.barmode === "stack" || ["tonextx", "tonexty"].indexOf(trace.fill) !== -1) {
            defaultOrder = helpers.isGrouped({ traceorder: defaultOrder }) ? "grouped+reversed" : "reversed";
          }
          if (trace.legendgroup !== void 0 && trace.legendgroup !== "") {
            defaultOrder = helpers.isReversed({ traceorder: defaultOrder }) ? "reversed+grouped" : "grouped";
          }
        }
        var showLegend = Lib.coerce(
          layoutIn,
          layoutOut,
          basePlotLayoutAttributes,
          "showlegend",
          legendReallyHasATrace && legendTraceCount > (legendId === "legend" ? 1 : 0)
        );
        if (showLegend === false) layoutOut[legendId] = void 0;
        if (showLegend === false && !containerIn.uirevision) return;
        coerce("uirevision", layoutOut.uirevision);
        if (showLegend === false) return;
        coerce("borderwidth");
        var orientation = coerce("orientation");
        var yref = coerce("yref");
        var xref = coerce("xref");
        var isHorizontal = orientation === "h";
        var isPaperY = yref === "paper";
        var isPaperX = xref === "paper";
        var defaultX, defaultY, defaultYAnchor;
        var defaultXAnchor = "left";
        if (isHorizontal) {
          defaultX = 0;
          if (Registry.getComponentMethod("rangeslider", "isVisible")(layoutIn.xaxis)) {
            if (isPaperY) {
              defaultY = 1.1;
              defaultYAnchor = "bottom";
            } else {
              defaultY = 1;
              defaultYAnchor = "top";
            }
          } else {
            if (isPaperY) {
              defaultY = -0.1;
              defaultYAnchor = "top";
            } else {
              defaultY = 0;
              defaultYAnchor = "bottom";
            }
          }
        } else {
          defaultY = 1;
          defaultYAnchor = "auto";
          if (isPaperX) {
            defaultX = 1.02;
          } else {
            defaultX = 1;
            defaultXAnchor = "right";
          }
        }
        Lib.coerce(containerIn, containerOut, {
          x: {
            valType: "number",
            editType: "legend",
            min: isPaperX ? -2 : 0,
            max: isPaperX ? 3 : 1,
            dflt: defaultX
          }
        }, "x");
        Lib.coerce(containerIn, containerOut, {
          y: {
            valType: "number",
            editType: "legend",
            min: isPaperY ? -2 : 0,
            max: isPaperY ? 3 : 1,
            dflt: defaultY
          }
        }, "y");
        coerce("traceorder", defaultOrder);
        if (helpers.isGrouped(layoutOut[legendId])) coerce("tracegroupgap");
        coerce("entrywidth");
        coerce("entrywidthmode");
        coerce("indentation");
        coerce("itemsizing");
        coerce("itemwidth");
        coerce("itemclick");
        coerce("itemdoubleclick");
        coerce("groupclick");
        coerce("xanchor", defaultXAnchor);
        coerce("yanchor", defaultYAnchor);
        coerce("valign");
        Lib.noneOrAll(containerIn, containerOut, ["x", "y"]);
        var titleText = coerce("title.text");
        if (titleText) {
          coerce("title.side", isHorizontal ? "left" : "top");
          var dfltTitleFont = Lib.extendFlat({}, itemFont, {
            size: Lib.bigFont(itemFont.size)
          });
          Lib.coerceFont(coerce, "title.font", dfltTitleFont);
        }
      }
      module.exports = function legendDefaults(layoutIn, layoutOut, fullData) {
        var i;
        var allLegendsData = fullData.slice();
        var shapes = layoutOut.shapes;
        if (shapes) {
          for (i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            if (!shape.showlegend) continue;
            var mockTrace = {
              _input: shape._input,
              visible: shape.visible,
              showlegend: shape.showlegend,
              legend: shape.legend
            };
            allLegendsData.push(mockTrace);
          }
        }
        var legends = ["legend"];
        for (i = 0; i < allLegendsData.length; i++) {
          Lib.pushUnique(legends, allLegendsData[i].legend);
        }
        layoutOut._legends = [];
        for (i = 0; i < legends.length; i++) {
          var legendId = legends[i];
          groupDefaults(legendId, layoutIn, layoutOut, allLegendsData);
          if (layoutOut[legendId] && layoutOut[legendId].visible) {
            layoutOut[legendId]._id = legendId;
          }
          layoutOut._legends.push(legendId);
        }
      };
    }
  });

  // src/components/legend/handle_click.js
  var require_handle_click = __commonJS({
    "src/components/legend/handle_click.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var pushUnique = Lib.pushUnique;
      var SHOWISOLATETIP = true;
      module.exports = function handleClick(g, gd, numClicks) {
        var fullLayout = gd._fullLayout;
        if (gd._dragged || gd._editing) return;
        var itemClick = fullLayout.legend.itemclick;
        var itemDoubleClick = fullLayout.legend.itemdoubleclick;
        var groupClick = fullLayout.legend.groupclick;
        if (numClicks === 1 && itemClick === "toggle" && itemDoubleClick === "toggleothers" && SHOWISOLATETIP && gd.data && gd._context.showTips) {
          Lib.notifier(Lib._(gd, "Double-click on legend to isolate one trace"), "long");
          SHOWISOLATETIP = false;
        } else {
          SHOWISOLATETIP = false;
        }
        var mode;
        if (numClicks === 1) mode = itemClick;
        else if (numClicks === 2) mode = itemDoubleClick;
        if (!mode) return;
        var toggleGroup = groupClick === "togglegroup";
        var hiddenSlices = fullLayout.hiddenlabels ? fullLayout.hiddenlabels.slice() : [];
        var legendItem = g.data()[0][0];
        if (legendItem.groupTitle && legendItem.noClick) return;
        var fullData = gd._fullData;
        var shapesWithLegend = (fullLayout.shapes || []).filter(function(d2) {
          return d2.showlegend;
        });
        var allLegendItems = fullData.concat(shapesWithLegend);
        var fullTrace = legendItem.trace;
        if (fullTrace._isShape) {
          fullTrace = fullTrace._fullInput;
        }
        var legendgroup = fullTrace.legendgroup;
        var i, j, kcont, key, keys, val;
        var dataUpdate = {};
        var dataIndices = [];
        var carrs = [];
        var carrIdx = [];
        function insertDataUpdate(traceIndex, value) {
          var attrIndex = dataIndices.indexOf(traceIndex);
          var valueArray = dataUpdate.visible;
          if (!valueArray) {
            valueArray = dataUpdate.visible = [];
          }
          if (dataIndices.indexOf(traceIndex) === -1) {
            dataIndices.push(traceIndex);
            attrIndex = dataIndices.length - 1;
          }
          valueArray[attrIndex] = value;
          return attrIndex;
        }
        var updatedShapes = (fullLayout.shapes || []).map(function(d2) {
          return d2._input;
        });
        var shapesUpdated = false;
        function insertShapesUpdate(shapeIndex, value) {
          updatedShapes[shapeIndex].visible = value;
          shapesUpdated = true;
        }
        function setVisibility(fullTrace2, visibility) {
          if (legendItem.groupTitle && !toggleGroup) return;
          var fullInput2 = fullTrace2._fullInput || fullTrace2;
          var isShape2 = fullInput2._isShape;
          var index = fullInput2.index;
          if (index === void 0) index = fullInput2._index;
          var nextVisibility2 = fullInput2.visible === false ? false : visibility;
          if (isShape2) {
            insertShapesUpdate(index, nextVisibility2);
          } else {
            insertDataUpdate(index, nextVisibility2);
          }
        }
        var thisLegend = fullTrace.legend;
        var fullInput = fullTrace._fullInput;
        var isShape = fullInput && fullInput._isShape;
        if (!isShape && Registry.traceIs(fullTrace, "pie-like")) {
          var thisLabel = legendItem.label;
          var thisLabelIndex = hiddenSlices.indexOf(thisLabel);
          if (mode === "toggle") {
            if (thisLabelIndex === -1) hiddenSlices.push(thisLabel);
            else hiddenSlices.splice(thisLabelIndex, 1);
          } else if (mode === "toggleothers") {
            var changed = thisLabelIndex !== -1;
            var unhideList = [];
            for (i = 0; i < gd.calcdata.length; i++) {
              var cdi = gd.calcdata[i];
              for (j = 0; j < cdi.length; j++) {
                var d = cdi[j];
                var dLabel = d.label;
                if (thisLegend === cdi[0].trace.legend) {
                  if (thisLabel !== dLabel) {
                    if (hiddenSlices.indexOf(dLabel) === -1) changed = true;
                    pushUnique(hiddenSlices, dLabel);
                    unhideList.push(dLabel);
                  }
                }
              }
            }
            if (!changed) {
              for (var q = 0; q < unhideList.length; q++) {
                var pos = hiddenSlices.indexOf(unhideList[q]);
                if (pos !== -1) {
                  hiddenSlices.splice(pos, 1);
                }
              }
            }
          }
          Registry.call("_guiRelayout", gd, "hiddenlabels", hiddenSlices);
        } else {
          var hasLegendgroup = legendgroup && legendgroup.length;
          var traceIndicesInGroup = [];
          var tracei;
          if (hasLegendgroup) {
            for (i = 0; i < allLegendItems.length; i++) {
              tracei = allLegendItems[i];
              if (!tracei.visible) continue;
              if (tracei.legendgroup === legendgroup) {
                traceIndicesInGroup.push(i);
              }
            }
          }
          if (mode === "toggle") {
            var nextVisibility;
            switch (fullTrace.visible) {
              case true:
                nextVisibility = "legendonly";
                break;
              case false:
                nextVisibility = false;
                break;
              case "legendonly":
                nextVisibility = true;
                break;
            }
            if (hasLegendgroup) {
              if (toggleGroup) {
                for (i = 0; i < allLegendItems.length; i++) {
                  var item = allLegendItems[i];
                  if (item.visible !== false && item.legendgroup === legendgroup) {
                    setVisibility(item, nextVisibility);
                  }
                }
              } else {
                setVisibility(fullTrace, nextVisibility);
              }
            } else {
              setVisibility(fullTrace, nextVisibility);
            }
          } else if (mode === "toggleothers") {
            var isClicked, isInGroup, notInLegend, otherState, _item;
            var isIsolated = true;
            for (i = 0; i < allLegendItems.length; i++) {
              _item = allLegendItems[i];
              isClicked = _item === fullTrace;
              notInLegend = _item.showlegend !== true;
              if (isClicked || notInLegend) continue;
              isInGroup = hasLegendgroup && _item.legendgroup === legendgroup;
              if (!isInGroup && _item.legend === thisLegend && _item.visible === true && !Registry.traceIs(_item, "notLegendIsolatable")) {
                isIsolated = false;
                break;
              }
            }
            for (i = 0; i < allLegendItems.length; i++) {
              _item = allLegendItems[i];
              if (_item.visible === false || _item.legend !== thisLegend) continue;
              if (Registry.traceIs(_item, "notLegendIsolatable")) {
                continue;
              }
              switch (fullTrace.visible) {
                case "legendonly":
                  setVisibility(_item, true);
                  break;
                case true:
                  otherState = isIsolated ? true : "legendonly";
                  isClicked = _item === fullTrace;
                  notInLegend = _item.showlegend !== true && !_item.legendgroup;
                  isInGroup = isClicked || hasLegendgroup && _item.legendgroup === legendgroup;
                  setVisibility(_item, isInGroup || notInLegend ? true : otherState);
                  break;
              }
            }
          }
          for (i = 0; i < carrs.length; i++) {
            kcont = carrs[i];
            if (!kcont) continue;
            var update = kcont.constructUpdate();
            var updateKeys = Object.keys(update);
            for (j = 0; j < updateKeys.length; j++) {
              key = updateKeys[j];
              val = dataUpdate[key] = dataUpdate[key] || [];
              val[carrIdx[i]] = update[key];
            }
          }
          keys = Object.keys(dataUpdate);
          for (i = 0; i < keys.length; i++) {
            key = keys[i];
            for (j = 0; j < dataIndices.length; j++) {
              if (!dataUpdate[key].hasOwnProperty(j)) {
                dataUpdate[key][j] = void 0;
              }
            }
          }
          if (shapesUpdated) {
            Registry.call("_guiUpdate", gd, dataUpdate, { shapes: updatedShapes }, dataIndices);
          } else {
            Registry.call("_guiRestyle", gd, dataUpdate, dataIndices);
          }
        }
      };
    }
  });

  // src/components/legend/constants.js
  var require_constants3 = __commonJS({
    "src/components/legend/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        scrollBarWidth: 6,
        scrollBarMinHeight: 20,
        scrollBarColor: "#808BA4",
        scrollBarMargin: 4,
        scrollBarEnterAttrs: { rx: 20, ry: 3, width: 0, height: 0 },
        // number of px between legend title and (left) side of legend (always in x direction and from inner border)
        titlePad: 2,
        // number of px between each legend item (x and/or y direction)
        itemGap: 5
      };
    }
  });

  // src/components/legend/get_legend_data.js
  var require_get_legend_data = __commonJS({
    "src/components/legend/get_legend_data.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var helpers = require_helpers3();
      module.exports = function getLegendData(calcdata, opts, hasMultipleLegends) {
        var inHover = opts._inHover;
        var grouped = helpers.isGrouped(opts);
        var reversed = helpers.isReversed(opts);
        var lgroupToTraces = {};
        var lgroups = [];
        var hasOneNonBlankGroup = false;
        var slicesShown = {};
        var lgroupi = 0;
        var maxNameLength = 0;
        var i, j;
        function addOneItem(legendId, legendGroup, legendItem) {
          if (opts.visible === false) return;
          if (hasMultipleLegends && legendId !== opts._id) return;
          if (legendGroup === "" || !helpers.isGrouped(opts)) {
            var uniqueGroup = "~~i" + lgroupi;
            lgroups.push(uniqueGroup);
            lgroupToTraces[uniqueGroup] = [legendItem];
            lgroupi++;
          } else if (lgroups.indexOf(legendGroup) === -1) {
            lgroups.push(legendGroup);
            hasOneNonBlankGroup = true;
            lgroupToTraces[legendGroup] = [legendItem];
          } else {
            lgroupToTraces[legendGroup].push(legendItem);
          }
        }
        for (i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var cd0 = cd[0];
          var trace = cd0.trace;
          var lid = trace.legend;
          var lgroup = trace.legendgroup;
          if (!inHover && (!trace.visible || !trace.showlegend)) continue;
          if (Registry.traceIs(trace, "pie-like")) {
            if (!slicesShown[lgroup]) slicesShown[lgroup] = {};
            for (j = 0; j < cd.length; j++) {
              var labelj = cd[j].label;
              if (!slicesShown[lgroup][labelj]) {
                addOneItem(lid, lgroup, {
                  label: labelj,
                  color: cd[j].color,
                  i: cd[j].i,
                  trace,
                  pts: cd[j].pts
                });
                slicesShown[lgroup][labelj] = true;
                maxNameLength = Math.max(maxNameLength, (labelj || "").length);
              }
            }
          } else {
            addOneItem(lid, lgroup, cd0);
            maxNameLength = Math.max(maxNameLength, (trace.name || "").length);
          }
        }
        if (!lgroups.length) return [];
        var shouldCollapse = !hasOneNonBlankGroup || !grouped;
        var legendData = [];
        for (i = 0; i < lgroups.length; i++) {
          var t = lgroupToTraces[lgroups[i]];
          if (shouldCollapse) {
            legendData.push(t[0]);
          } else {
            legendData.push(t);
          }
        }
        if (shouldCollapse) legendData = [legendData];
        for (i = 0; i < legendData.length; i++) {
          var groupMinRank = Infinity;
          for (j = 0; j < legendData[i].length; j++) {
            var rank = legendData[i][j].trace.legendrank;
            if (groupMinRank > rank) groupMinRank = rank;
          }
          legendData[i][0]._groupMinRank = groupMinRank;
          legendData[i][0]._preGroupSort = i;
        }
        var orderFn1 = function(a, b) {
          return a[0]._groupMinRank - b[0]._groupMinRank || a[0]._preGroupSort - b[0]._preGroupSort;
        };
        var orderFn2 = function(a, b) {
          return a.trace.legendrank - b.trace.legendrank || a._preSort - b._preSort;
        };
        legendData.forEach(function(a, k) {
          a[0]._preGroupSort = k;
        });
        legendData.sort(orderFn1);
        for (i = 0; i < legendData.length; i++) {
          legendData[i].forEach(function(a, k) {
            a._preSort = k;
          });
          legendData[i].sort(orderFn2);
          var firstItemTrace = legendData[i][0].trace;
          var groupTitle = null;
          for (j = 0; j < legendData[i].length; j++) {
            var gt = legendData[i][j].trace.legendgrouptitle;
            if (gt && gt.text) {
              groupTitle = gt;
              if (inHover) gt.font = opts._groupTitleFont;
              break;
            }
          }
          if (reversed) legendData[i].reverse();
          if (groupTitle) {
            var hasPieLike = false;
            for (j = 0; j < legendData[i].length; j++) {
              if (Registry.traceIs(legendData[i][j].trace, "pie-like")) {
                hasPieLike = true;
                break;
              }
            }
            legendData[i].unshift({
              i: -1,
              groupTitle,
              noClick: hasPieLike,
              trace: {
                showlegend: firstItemTrace.showlegend,
                legendgroup: firstItemTrace.legendgroup,
                visible: opts.groupclick === "toggleitem" ? true : firstItemTrace.visible
              }
            });
          }
          for (j = 0; j < legendData[i].length; j++) {
            legendData[i][j] = [
              legendData[i][j]
            ];
          }
        }
        opts._lgroupsLength = legendData.length;
        opts._maxNameLength = maxNameLength;
        return legendData;
      };
    }
  });

  // src/traces/pie/helpers.js
  var require_helpers4 = __commonJS({
    "src/traces/pie/helpers.js"(exports) {
      "use strict";
      var Lib = require_lib();
      function format(vRounded) {
        return vRounded.indexOf("e") !== -1 ? vRounded.replace(/[.]?0+e/, "e") : vRounded.indexOf(".") !== -1 ? vRounded.replace(/[.]?0+$/, "") : vRounded;
      }
      exports.formatPiePercent = function formatPiePercent(v, separators) {
        var vRounded = format((v * 100).toPrecision(3));
        return Lib.numSeparate(vRounded, separators) + "%";
      };
      exports.formatPieValue = function formatPieValue(v, separators) {
        var vRounded = format(v.toPrecision(10));
        return Lib.numSeparate(vRounded, separators);
      };
      exports.getFirstFilled = function getFirstFilled(array, indices) {
        if (!Lib.isArrayOrTypedArray(array)) return;
        for (var i = 0; i < indices.length; i++) {
          var v = array[indices[i]];
          if (v || v === 0 || v === "") return v;
        }
      };
      exports.castOption = function castOption(item, indices) {
        if (Lib.isArrayOrTypedArray(item)) return exports.getFirstFilled(item, indices);
        else if (item) return item;
      };
      exports.getRotationAngle = function(rotation) {
        return (rotation === "auto" ? 0 : rotation) * Math.PI / 180;
      };
    }
  });

  // src/traces/pie/fill_one.js
  var require_fill_one = __commonJS({
    "src/traces/pie/fill_one.js"(exports, module) {
      "use strict";
      var Drawing = require_drawing();
      var Color = require_color();
      module.exports = function fillOne(s, pt, trace, gd) {
        var pattern = trace.marker.pattern;
        if (pattern && pattern.shape) {
          Drawing.pointStyle(s, trace, gd, pt);
        } else {
          Color.fill(s, pt.color);
        }
      };
    }
  });

  // src/traces/pie/style_one.js
  var require_style_one = __commonJS({
    "src/traces/pie/style_one.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var castOption = require_helpers4().castOption;
      var fillOne = require_fill_one();
      module.exports = function styleOne(s, pt, trace, gd) {
        var line = trace.marker.line;
        var lineColor = castOption(line.color, pt.pts) || Color.defaultLine;
        var lineWidth = castOption(line.width, pt.pts) || 0;
        s.call(fillOne, pt, trace, gd).style("stroke-width", lineWidth).call(Color.stroke, lineColor);
      };
    }
  });

  // src/components/legend/style.js
  var require_style = __commonJS({
    "src/components/legend/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Drawing = require_drawing();
      var Color = require_color();
      var extractOpts = require_helpers().extractOpts;
      var subTypes = require_subtypes();
      var stylePie = require_style_one();
      var pieCastOption = require_helpers4().castOption;
      var constants = require_constants3();
      var CST_MARKER_SIZE = 12;
      var CST_LINE_WIDTH = 5;
      var CST_MARKER_LINE_WIDTH = 2;
      var MAX_LINE_WIDTH = 10;
      var MAX_MARKER_LINE_WIDTH = 5;
      module.exports = function style(s, gd, legend) {
        var fullLayout = gd._fullLayout;
        if (!legend) legend = fullLayout.legend;
        var constantItemSizing = legend.itemsizing === "constant";
        var itemWidth = legend.itemwidth;
        var centerPos = (itemWidth + constants.itemGap * 2) / 2;
        var centerTransform = strTranslate(centerPos, 0);
        var boundLineWidth = function(mlw, cont, max, cst) {
          var v;
          if (mlw + 1) {
            v = mlw;
          } else if (cont && cont.width > 0) {
            v = cont.width;
          } else {
            return 0;
          }
          return constantItemSizing ? cst : Math.min(v, max);
        };
        s.each(function(d) {
          var traceGroup = d3.select(this);
          var layers = Lib.ensureSingle(traceGroup, "g", "layers");
          layers.style("opacity", d[0].trace.opacity);
          var indentation = legend.indentation;
          var valign = legend.valign;
          var lineHeight = d[0].lineHeight;
          var height = d[0].height;
          if (valign === "middle" && indentation === 0 || !lineHeight || !height) {
            layers.attr("transform", null);
          } else {
            var factor = { top: 1, bottom: -1 }[valign];
            var markerOffsetY = factor * (0.5 * (lineHeight - height + 3)) || 0;
            var markerOffsetX = legend.indentation;
            layers.attr("transform", strTranslate(markerOffsetX, markerOffsetY));
          }
          var fill = layers.selectAll("g.legendfill").data([d]);
          fill.enter().append("g").classed("legendfill", true);
          var line = layers.selectAll("g.legendlines").data([d]);
          line.enter().append("g").classed("legendlines", true);
          var symbol = layers.selectAll("g.legendsymbols").data([d]);
          symbol.enter().append("g").classed("legendsymbols", true);
          symbol.selectAll("g.legendpoints").data([d]).enter().append("g").classed("legendpoints", true);
        }).each(styleSpatial).each(styleWaterfalls).each(styleFunnels).each(styleBars).each(styleBoxes).each(styleFunnelareas).each(stylePies).each(styleLines).each(stylePoints).each(styleCandles).each(styleOHLC);
        function styleLines(d) {
          var styleGuide = getStyleGuide(d);
          var showFill = styleGuide.showFill;
          var showLine = styleGuide.showLine;
          var showGradientLine = styleGuide.showGradientLine;
          var showGradientFill = styleGuide.showGradientFill;
          var anyFill = styleGuide.anyFill;
          var anyLine = styleGuide.anyLine;
          var d0 = d[0];
          var trace = d0.trace;
          var dMod, tMod;
          var cOpts = extractOpts(trace);
          var colorscale = cOpts.colorscale;
          var reversescale = cOpts.reversescale;
          var fillStyle = function(s2) {
            if (s2.size()) {
              if (showFill) {
                Drawing.fillGroupStyle(s2, gd, true);
              } else {
                var gradientID = "legendfill-" + trace.uid;
                Drawing.gradient(
                  s2,
                  gd,
                  gradientID,
                  getGradientDirection(reversescale),
                  colorscale,
                  "fill"
                );
              }
            }
          };
          var lineGradient = function(s2) {
            if (s2.size()) {
              var gradientID = "legendline-" + trace.uid;
              Drawing.lineGroupStyle(s2);
              Drawing.gradient(
                s2,
                gd,
                gradientID,
                getGradientDirection(reversescale),
                colorscale,
                "stroke"
              );
            }
          };
          var pathStart = subTypes.hasMarkers(trace) || !anyFill ? "M5,0" : (
            // with a line leave it slightly below center, to leave room for the
            // line thickness and because the line is usually more prominent
            anyLine ? "M5,-2" : "M5,-3"
          );
          var this3 = d3.select(this);
          var fill = this3.select(".legendfill").selectAll("path").data(showFill || showGradientFill ? [d] : []);
          fill.enter().append("path").classed("js-fill", true);
          fill.exit().remove();
          fill.attr("d", pathStart + "h" + itemWidth + "v6h-" + itemWidth + "z").call(fillStyle);
          if (showLine || showGradientLine) {
            var lw = boundLineWidth(void 0, trace.line, MAX_LINE_WIDTH, CST_LINE_WIDTH);
            tMod = Lib.minExtend(trace, { line: { width: lw } });
            dMod = [Lib.minExtend(d0, { trace: tMod })];
          }
          var line = this3.select(".legendlines").selectAll("path").data(showLine || showGradientLine ? [dMod] : []);
          line.enter().append("path").classed("js-line", true);
          line.exit().remove();
          line.attr("d", pathStart + (showGradientLine ? "l" + itemWidth + ",0.0001" : "h" + itemWidth)).call(showLine ? Drawing.lineGroupStyle : lineGradient);
        }
        function stylePoints(d) {
          var styleGuide = getStyleGuide(d);
          var anyFill = styleGuide.anyFill;
          var anyLine = styleGuide.anyLine;
          var showLine = styleGuide.showLine;
          var showMarker = styleGuide.showMarker;
          var d0 = d[0];
          var trace = d0.trace;
          var showText = !showMarker && !anyLine && !anyFill && subTypes.hasText(trace);
          var dMod, tMod;
          function boundVal(attrIn, arrayToValFn, bounds, cst) {
            var valIn = Lib.nestedProperty(trace, attrIn).get();
            var valToBound = Lib.isArrayOrTypedArray(valIn) && arrayToValFn ? arrayToValFn(valIn) : valIn;
            if (constantItemSizing && valToBound && cst !== void 0) {
              valToBound = cst;
            }
            if (bounds) {
              if (valToBound < bounds[0]) return bounds[0];
              else if (valToBound > bounds[1]) return bounds[1];
            }
            return valToBound;
          }
          function pickFirst(array) {
            if (d0._distinct && d0.index && array[d0.index]) return array[d0.index];
            return array[0];
          }
          if (showMarker || showText || showLine) {
            var dEdit = {};
            var tEdit = {};
            if (showMarker) {
              dEdit.mc = boundVal("marker.color", pickFirst);
              dEdit.mx = boundVal("marker.symbol", pickFirst);
              dEdit.mo = boundVal("marker.opacity", Lib.mean, [0.2, 1]);
              dEdit.mlc = boundVal("marker.line.color", pickFirst);
              dEdit.mlw = boundVal("marker.line.width", Lib.mean, [0, 5], CST_MARKER_LINE_WIDTH);
              tEdit.marker = {
                sizeref: 1,
                sizemin: 1,
                sizemode: "diameter"
              };
              var ms = boundVal("marker.size", Lib.mean, [2, 16], CST_MARKER_SIZE);
              dEdit.ms = ms;
              tEdit.marker.size = ms;
            }
            if (showLine) {
              tEdit.line = {
                width: boundVal("line.width", pickFirst, [0, 10], CST_LINE_WIDTH)
              };
            }
            if (showText) {
              dEdit.tx = "Aa";
              dEdit.tp = boundVal("textposition", pickFirst);
              dEdit.ts = 10;
              dEdit.tc = boundVal("textfont.color", pickFirst);
              dEdit.tf = boundVal("textfont.family", pickFirst);
              dEdit.tw = boundVal("textfont.weight", pickFirst);
              dEdit.ty = boundVal("textfont.style", pickFirst);
              dEdit.tv = boundVal("textfont.variant", pickFirst);
              dEdit.tC = boundVal("textfont.textcase", pickFirst);
              dEdit.tE = boundVal("textfont.lineposition", pickFirst);
              dEdit.tS = boundVal("textfont.shadow", pickFirst);
            }
            dMod = [Lib.minExtend(d0, dEdit)];
            tMod = Lib.minExtend(trace, tEdit);
            tMod.selectedpoints = null;
            tMod.texttemplate = null;
          }
          var ptgroup = d3.select(this).select("g.legendpoints");
          var pts = ptgroup.selectAll("path.scatterpts").data(showMarker ? dMod : []);
          pts.enter().insert("path", ":first-child").classed("scatterpts", true).attr("transform", centerTransform);
          pts.exit().remove();
          pts.call(Drawing.pointStyle, tMod, gd);
          if (showMarker) dMod[0].mrc = 3;
          var txt = ptgroup.selectAll("g.pointtext").data(showText ? dMod : []);
          txt.enter().append("g").classed("pointtext", true).append("text").attr("transform", centerTransform);
          txt.exit().remove();
          txt.selectAll("text").call(Drawing.textPointStyle, tMod, gd);
        }
        function styleWaterfalls(d) {
          var trace = d[0].trace;
          var isWaterfall = trace.type === "waterfall";
          if (d[0]._distinct && isWaterfall) {
            var cont = d[0].trace[d[0].dir].marker;
            d[0].mc = cont.color;
            d[0].mlw = cont.line.width;
            d[0].mlc = cont.line.color;
            return styleBarLike(d, this, "waterfall");
          }
          var ptsData = [];
          if (trace.visible && isWaterfall) {
            ptsData = d[0].hasTotals ? [["increasing", "M-6,-6V6H0Z"], ["totals", "M6,6H0L-6,-6H-0Z"], ["decreasing", "M6,6V-6H0Z"]] : [["increasing", "M-6,-6V6H6Z"], ["decreasing", "M6,6V-6H-6Z"]];
          }
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendwaterfall").data(ptsData);
          pts.enter().append("path").classed("legendwaterfall", true).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(dd) {
            var pt = d3.select(this);
            var cont2 = trace[dd[0]].marker;
            var lw = boundLineWidth(void 0, cont2.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            pt.attr("d", dd[1]).style("stroke-width", lw + "px").call(Color.fill, cont2.color);
            if (lw) {
              pt.call(Color.stroke, cont2.line.color);
            }
          });
        }
        function styleBars(d) {
          styleBarLike(d, this);
        }
        function styleFunnels(d) {
          styleBarLike(d, this, "funnel");
        }
        function styleBarLike(d, lThis, desiredType) {
          var trace = d[0].trace;
          var marker = trace.marker || {};
          var markerLine = marker.line || {};
          var pathStr = marker.cornerradius ? "M6,3a3,3,0,0,1-3,3H-3a3,3,0,0,1-3-3V-3a3,3,0,0,1,3-3H3a3,3,0,0,1,3,3Z" : (
            // Square with rounded corners
            "M6,6H-6V-6H6Z"
          );
          var isVisible = !desiredType ? Registry.traceIs(trace, "bar") : trace.visible && trace.type === desiredType;
          var barpath = d3.select(lThis).select("g.legendpoints").selectAll("path.legend" + desiredType).data(isVisible ? [d] : []);
          barpath.enter().append("path").classed("legend" + desiredType, true).attr("d", pathStr).attr("transform", centerTransform);
          barpath.exit().remove();
          barpath.each(function(d2) {
            var p = d3.select(this);
            var d0 = d2[0];
            var w = boundLineWidth(d0.mlw, marker.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            p.style("stroke-width", w + "px");
            var mcc = d0.mcc;
            if (!legend._inHover && "mc" in d0) {
              var cOpts = extractOpts(marker);
              var mid = cOpts.mid;
              if (mid === void 0) mid = (cOpts.max + cOpts.min) / 2;
              mcc = Drawing.tryColorscale(marker, "")(mid);
            }
            var fillColor = mcc || d0.mc || marker.color;
            var markerPattern = marker.pattern;
            var patternShape = markerPattern && Drawing.getPatternAttr(markerPattern.shape, 0, "");
            if (patternShape) {
              var patternBGColor = Drawing.getPatternAttr(markerPattern.bgcolor, 0, null);
              var patternFGColor = Drawing.getPatternAttr(markerPattern.fgcolor, 0, null);
              var patternFGOpacity = markerPattern.fgopacity;
              var patternSize = dimAttr(markerPattern.size, 8, 10);
              var patternSolidity = dimAttr(markerPattern.solidity, 0.5, 1);
              var patternID = "legend-" + trace.uid;
              p.call(
                Drawing.pattern,
                "legend",
                gd,
                patternID,
                patternShape,
                patternSize,
                patternSolidity,
                mcc,
                markerPattern.fillmode,
                patternBGColor,
                patternFGColor,
                patternFGOpacity
              );
            } else {
              p.call(Color.fill, fillColor);
            }
            if (w) Color.stroke(p, d0.mlc || markerLine.color);
          });
        }
        function styleBoxes(d) {
          var trace = d[0].trace;
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendbox").data(trace.visible && Registry.traceIs(trace, "box-violin") ? [d] : []);
          pts.enter().append("path").classed("legendbox", true).attr("d", "M6,6H-6V-6H6Z").attr("transform", centerTransform);
          pts.exit().remove();
          pts.each(function() {
            var p = d3.select(this);
            if ((trace.boxpoints === "all" || trace.points === "all") && Color.opacity(trace.fillcolor) === 0 && Color.opacity((trace.line || {}).color) === 0) {
              var tMod = Lib.minExtend(trace, {
                marker: {
                  size: constantItemSizing ? CST_MARKER_SIZE : Lib.constrain(trace.marker.size, 2, 16),
                  sizeref: 1,
                  sizemin: 1,
                  sizemode: "diameter"
                }
              });
              pts.call(Drawing.pointStyle, tMod, gd);
            } else {
              var w = boundLineWidth(void 0, trace.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
              p.style("stroke-width", w + "px").call(Color.fill, trace.fillcolor);
              if (w) Color.stroke(p, trace.line.color);
            }
          });
        }
        function styleCandles(d) {
          var trace = d[0].trace;
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendcandle").data(trace.visible && trace.type === "candlestick" ? [d, d] : []);
          pts.enter().append("path").classed("legendcandle", true).attr("d", function(_, i) {
            if (i) return "M-15,0H-8M-8,6V-6H8Z";
            return "M15,0H8M8,-6V6H-8Z";
          }).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(_, i) {
            var p = d3.select(this);
            var cont = trace[i ? "increasing" : "decreasing"];
            var w = boundLineWidth(void 0, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            p.style("stroke-width", w + "px").call(Color.fill, cont.fillcolor);
            if (w) Color.stroke(p, cont.line.color);
          });
        }
        function styleOHLC(d) {
          var trace = d[0].trace;
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legendohlc").data(trace.visible && trace.type === "ohlc" ? [d, d] : []);
          pts.enter().append("path").classed("legendohlc", true).attr("d", function(_, i) {
            if (i) return "M-15,0H0M-8,-6V0";
            return "M15,0H0M8,6V0";
          }).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(_, i) {
            var p = d3.select(this);
            var cont = trace[i ? "increasing" : "decreasing"];
            var w = boundLineWidth(void 0, cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            p.style("fill", "none").call(Drawing.dashLine, cont.line.dash, w);
            if (w) Color.stroke(p, cont.line.color);
          });
        }
        function stylePies(d) {
          stylePieLike(d, this, "pie");
        }
        function styleFunnelareas(d) {
          stylePieLike(d, this, "funnelarea");
        }
        function stylePieLike(d, lThis, desiredType) {
          var d0 = d[0];
          var trace = d0.trace;
          var isVisible = !desiredType ? Registry.traceIs(trace, desiredType) : trace.visible && trace.type === desiredType;
          var pts = d3.select(lThis).select("g.legendpoints").selectAll("path.legend" + desiredType).data(isVisible ? [d] : []);
          pts.enter().append("path").classed("legend" + desiredType, true).attr("d", "M6,6H-6V-6H6Z").attr("transform", centerTransform);
          pts.exit().remove();
          if (pts.size()) {
            var cont = trace.marker || {};
            var lw = boundLineWidth(pieCastOption(cont.line.width, d0.pts), cont.line, MAX_MARKER_LINE_WIDTH, CST_MARKER_LINE_WIDTH);
            var opt = "pieLike";
            var tMod = Lib.minExtend(trace, { marker: { line: { width: lw } } }, opt);
            var d0Mod = Lib.minExtend(d0, { trace: tMod }, opt);
            stylePie(pts, d0Mod, tMod, gd);
          }
        }
        function styleSpatial(d) {
          var trace = d[0].trace;
          var useGradient;
          var ptsData = [];
          if (trace.visible) {
            switch (trace.type) {
              case "histogram2d":
              case "heatmap":
                ptsData = [
                  ["M-15,-2V4H15V-2Z"]
                  // similar to contour
                ];
                useGradient = true;
                break;
              case "choropleth":
              case "choroplethmapbox":
              case "choroplethmap":
                ptsData = [
                  ["M-6,-6V6H6V-6Z"]
                ];
                useGradient = true;
                break;
              case "densitymapbox":
              case "densitymap":
                ptsData = [
                  ["M-6,0 a6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0"]
                ];
                useGradient = "radial";
                break;
              case "cone":
                ptsData = [
                  ["M-6,2 A2,2 0 0,0 -6,6 V6L6,4Z"],
                  ["M-6,-6 A2,2 0 0,0 -6,-2 L6,-4Z"],
                  ["M-6,-2 A2,2 0 0,0 -6,2 L6,0Z"]
                ];
                useGradient = false;
                break;
              case "streamtube":
                ptsData = [
                  ["M-6,2 A2,2 0 0,0 -6,6 H6 A2,2 0 0,1 6,2 Z"],
                  ["M-6,-6 A2,2 0 0,0 -6,-2 H6 A2,2 0 0,1 6,-6 Z"],
                  ["M-6,-2 A2,2 0 0,0 -6,2 H6 A2,2 0 0,1 6,-2 Z"]
                ];
                useGradient = false;
                break;
              case "surface":
                ptsData = [
                  ["M-6,-6 A2,3 0 0,0 -6,0 H6 A2,3 0 0,1 6,-6 Z"],
                  ["M-6,1 A2,3 0 0,1 -6,6 H6 A2,3 0 0,0 6,0 Z"]
                ];
                useGradient = true;
                break;
              case "mesh3d":
                ptsData = [
                  ["M-6,6H0L-6,-6Z"],
                  ["M6,6H0L6,-6Z"],
                  ["M-6,-6H6L0,6Z"]
                ];
                useGradient = false;
                break;
              case "volume":
                ptsData = [
                  ["M-6,6H0L-6,-6Z"],
                  ["M6,6H0L6,-6Z"],
                  ["M-6,-6H6L0,6Z"]
                ];
                useGradient = true;
                break;
              case "isosurface":
                ptsData = [
                  ["M-6,6H0L-6,-6Z"],
                  ["M6,6H0L6,-6Z"],
                  ["M-6,-6 A12,24 0 0,0 6,-6 L0,6Z"]
                ];
                useGradient = false;
                break;
            }
          }
          var pts = d3.select(this).select("g.legendpoints").selectAll("path.legend3dandfriends").data(ptsData);
          pts.enter().append("path").classed("legend3dandfriends", true).attr("transform", centerTransform).style("stroke-miterlimit", 1);
          pts.exit().remove();
          pts.each(function(dd, i) {
            var pt = d3.select(this);
            var cOpts = extractOpts(trace);
            var colorscale = cOpts.colorscale;
            var reversescale = cOpts.reversescale;
            var fillGradient = function(s2) {
              if (s2.size()) {
                var gradientID = "legendfill-" + trace.uid;
                Drawing.gradient(
                  s2,
                  gd,
                  gradientID,
                  getGradientDirection(reversescale, useGradient === "radial"),
                  colorscale,
                  "fill"
                );
              }
            };
            var fillColor;
            if (!colorscale) {
              var color = trace.vertexcolor || trace.facecolor || trace.color;
              fillColor = Lib.isArrayOrTypedArray(color) ? color[i] || color[0] : color;
            } else {
              if (!useGradient) {
                var len = colorscale.length;
                fillColor = i === 0 ? colorscale[reversescale ? len - 1 : 0][1] : (
                  // minimum
                  i === 1 ? colorscale[reversescale ? 0 : len - 1][1] : (
                    // maximum
                    colorscale[Math.floor((len - 1) / 2)][1]
                  )
                );
              }
            }
            pt.attr("d", dd[0]);
            if (fillColor) {
              pt.call(Color.fill, fillColor);
            } else {
              pt.call(fillGradient);
            }
          });
        }
      };
      function getGradientDirection(reversescale, isRadial) {
        var str = isRadial ? "radial" : "horizontal";
        return str + (reversescale ? "" : "reversed");
      }
      function getStyleGuide(d) {
        var trace = d[0].trace;
        var contours = trace.contours;
        var showLine = subTypes.hasLines(trace);
        var showMarker = subTypes.hasMarkers(trace);
        var showFill = trace.visible && trace.fill && trace.fill !== "none";
        var showGradientLine = false;
        var showGradientFill = false;
        if (contours) {
          var coloring = contours.coloring;
          if (coloring === "lines") {
            showGradientLine = true;
          } else {
            showLine = coloring === "none" || coloring === "heatmap" || contours.showlines;
          }
          if (contours.type === "constraint") {
            showFill = contours._operation !== "=";
          } else if (coloring === "fill" || coloring === "heatmap") {
            showGradientFill = true;
          }
        }
        return {
          showMarker,
          showLine,
          showFill,
          showGradientLine,
          showGradientFill,
          anyLine: showLine || showGradientLine,
          anyFill: showFill || showGradientFill
        };
      }
      function dimAttr(v, dflt, max) {
        if (v && Lib.isArrayOrTypedArray(v)) return dflt;
        if (v > max) return max;
        return v;
      }
    }
  });

  // src/components/legend/draw.js
  var require_draw = __commonJS({
    "src/components/legend/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var Plots = require_plots();
      var Registry = require_registry();
      var Events = require_events2();
      var dragElement = require_dragelement();
      var Drawing = require_drawing();
      var Color = require_color();
      var svgTextUtils = require_svg_text_utils();
      var handleClick = require_handle_click();
      var constants = require_constants3();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      var getLegendData = require_get_legend_data();
      var style = require_style();
      var helpers = require_helpers3();
      var MAIN_TITLE = 1;
      var LEGEND_PATTERN = /^legend[0-9]*$/;
      module.exports = function draw(gd, opts) {
        if (opts) {
          drawOne(gd, opts);
        } else {
          var fullLayout = gd._fullLayout;
          var newLegends = fullLayout._legends;
          var oldLegends = fullLayout._infolayer.selectAll('[class^="legend"]');
          oldLegends.each(function() {
            var el = d3.select(this);
            var classes = el.attr("class");
            var cls = classes.split(" ")[0];
            if (cls.match(LEGEND_PATTERN) && newLegends.indexOf(cls) === -1) {
              el.remove();
            }
          });
          for (var i = 0; i < newLegends.length; i++) {
            var legendId = newLegends[i];
            var legendObj = gd._fullLayout[legendId];
            drawOne(gd, legendObj);
          }
        }
      };
      function horizontalAlignTitle(titleEl, legendObj, bw) {
        if (legendObj.title.side !== "top center" && legendObj.title.side !== "top right") return;
        var font = legendObj.title.font;
        var lineHeight = font.size * LINE_SPACING;
        var titleOffset = 0;
        var textNode = titleEl.node();
        var width = Drawing.bBox(textNode).width;
        if (legendObj.title.side === "top center") {
          titleOffset = 0.5 * (legendObj._width - 2 * bw - 2 * constants.titlePad - width);
        } else if (legendObj.title.side === "top right") {
          titleOffset = legendObj._width - 2 * bw - 2 * constants.titlePad - width;
        }
        svgTextUtils.positionText(
          titleEl,
          bw + constants.titlePad + titleOffset,
          bw + lineHeight
        );
      }
      function drawOne(gd, opts) {
        var legendObj = opts || {};
        var fullLayout = gd._fullLayout;
        var legendId = getId(legendObj);
        var clipId, layer;
        var inHover = legendObj._inHover;
        if (inHover) {
          layer = legendObj.layer;
          clipId = "hover";
        } else {
          layer = fullLayout._infolayer;
          clipId = legendId;
        }
        if (!layer) return;
        clipId += fullLayout._uid;
        if (!gd._legendMouseDownTime) gd._legendMouseDownTime = 0;
        var legendData;
        if (!inHover) {
          var calcdata = (gd.calcdata || []).slice();
          var shapes = fullLayout.shapes;
          for (var i = 0; i < shapes.length; i++) {
            var shape = shapes[i];
            if (!shape.showlegend) continue;
            var shapeLegend = {
              _isShape: true,
              _fullInput: shape,
              index: shape._index,
              name: shape.name || shape.label.text || "shape " + shape._index,
              legend: shape.legend,
              legendgroup: shape.legendgroup,
              legendgrouptitle: shape.legendgrouptitle,
              legendrank: shape.legendrank,
              legendwidth: shape.legendwidth,
              showlegend: shape.showlegend,
              visible: shape.visible,
              opacity: shape.opacity,
              mode: shape.type === "line" ? "lines" : "markers",
              line: shape.line,
              marker: {
                line: shape.line,
                color: shape.fillcolor,
                size: 12,
                symbol: shape.type === "rect" ? "square" : shape.type === "circle" ? "circle" : (
                  // case of path
                  "hexagon2"
                )
              }
            };
            calcdata.push([{ trace: shapeLegend }]);
          }
          legendData = fullLayout.showlegend && getLegendData(calcdata, legendObj, fullLayout._legends.length > 1);
        } else {
          if (!legendObj.entries) return;
          legendData = getLegendData(legendObj.entries, legendObj);
        }
        var hiddenSlices = fullLayout.hiddenlabels || [];
        if (!inHover && (!fullLayout.showlegend || !legendData.length)) {
          layer.selectAll("." + legendId).remove();
          fullLayout._topdefs.select("#" + clipId).remove();
          return Plots.autoMargin(gd, legendId);
        }
        var legend = Lib.ensureSingle(layer, "g", legendId, function(s) {
          if (!inHover) s.attr("pointer-events", "all");
        });
        var clipPath = Lib.ensureSingleById(fullLayout._topdefs, "clipPath", clipId, function(s) {
          s.append("rect");
        });
        var bg = Lib.ensureSingle(legend, "rect", "bg", function(s) {
          s.attr("shape-rendering", "crispEdges");
        });
        bg.call(Color.stroke, legendObj.bordercolor).call(Color.fill, legendObj.bgcolor).style("stroke-width", legendObj.borderwidth + "px");
        var scrollBox = Lib.ensureSingle(legend, "g", "scrollbox");
        var title = legendObj.title;
        legendObj._titleWidth = 0;
        legendObj._titleHeight = 0;
        var titleEl;
        if (title.text) {
          titleEl = Lib.ensureSingle(scrollBox, "text", legendId + "titletext");
          titleEl.attr("text-anchor", "start").call(Drawing.font, title.font).text(title.text);
          textLayout(titleEl, scrollBox, gd, legendObj, MAIN_TITLE);
        } else {
          scrollBox.selectAll("." + legendId + "titletext").remove();
        }
        var scrollBar = Lib.ensureSingle(legend, "rect", "scrollbar", function(s) {
          s.attr(constants.scrollBarEnterAttrs).call(Color.fill, constants.scrollBarColor);
        });
        var groups = scrollBox.selectAll("g.groups").data(legendData);
        groups.enter().append("g").attr("class", "groups");
        groups.exit().remove();
        var traces = groups.selectAll("g.traces").data(Lib.identity);
        traces.enter().append("g").attr("class", "traces");
        traces.exit().remove();
        traces.style("opacity", function(d) {
          var trace = d[0].trace;
          if (Registry.traceIs(trace, "pie-like")) {
            return hiddenSlices.indexOf(d[0].label) !== -1 ? 0.5 : 1;
          } else {
            return trace.visible === "legendonly" ? 0.5 : 1;
          }
        }).each(function() {
          d3.select(this).call(drawTexts, gd, legendObj);
        }).call(style, gd, legendObj).each(function() {
          if (!inHover) d3.select(this).call(setupTraceToggle, gd, legendId);
        });
        Lib.syncOrAsync([
          Plots.previousPromises,
          function() {
            return computeLegendDimensions(gd, groups, traces, legendObj);
          },
          function() {
            var gs = fullLayout._size;
            var bw = legendObj.borderwidth;
            var isPaperX = legendObj.xref === "paper";
            var isPaperY = legendObj.yref === "paper";
            if (title.text) {
              horizontalAlignTitle(titleEl, legendObj, bw);
            }
            if (!inHover) {
              var lx, ly;
              if (isPaperX) {
                lx = gs.l + gs.w * legendObj.x - FROM_TL[getXanchor(legendObj)] * legendObj._width;
              } else {
                lx = fullLayout.width * legendObj.x - FROM_TL[getXanchor(legendObj)] * legendObj._width;
              }
              if (isPaperY) {
                ly = gs.t + gs.h * (1 - legendObj.y) - FROM_TL[getYanchor(legendObj)] * legendObj._effHeight;
              } else {
                ly = fullLayout.height * (1 - legendObj.y) - FROM_TL[getYanchor(legendObj)] * legendObj._effHeight;
              }
              var expMargin = expandMargin(gd, legendId, lx, ly);
              if (expMargin) return;
              if (fullLayout.margin.autoexpand) {
                var lx0 = lx;
                var ly0 = ly;
                lx = isPaperX ? Lib.constrain(lx, 0, fullLayout.width - legendObj._width) : lx0;
                ly = isPaperY ? Lib.constrain(ly, 0, fullLayout.height - legendObj._effHeight) : ly0;
                if (lx !== lx0) {
                  Lib.log("Constrain " + legendId + ".x to make legend fit inside graph");
                }
                if (ly !== ly0) {
                  Lib.log("Constrain " + legendId + ".y to make legend fit inside graph");
                }
              }
              Drawing.setTranslate(legend, lx, ly);
            }
            scrollBar.on(".drag", null);
            legend.on("wheel", null);
            if (inHover || legendObj._height <= legendObj._maxHeight || gd._context.staticPlot) {
              var height = legendObj._effHeight;
              if (inHover) height = legendObj._height;
              bg.attr({
                width: legendObj._width - bw,
                height: height - bw,
                x: bw / 2,
                y: bw / 2
              });
              Drawing.setTranslate(scrollBox, 0, 0);
              clipPath.select("rect").attr({
                width: legendObj._width - 2 * bw,
                height: height - 2 * bw,
                x: bw,
                y: bw
              });
              Drawing.setClipUrl(scrollBox, clipId, gd);
              Drawing.setRect(scrollBar, 0, 0, 0, 0);
              delete legendObj._scrollY;
            } else {
              var scrollBarHeight = Math.max(
                constants.scrollBarMinHeight,
                legendObj._effHeight * legendObj._effHeight / legendObj._height
              );
              var scrollBarYMax = legendObj._effHeight - scrollBarHeight - 2 * constants.scrollBarMargin;
              var scrollBoxYMax = legendObj._height - legendObj._effHeight;
              var scrollRatio = scrollBarYMax / scrollBoxYMax;
              var scrollBoxY = Math.min(legendObj._scrollY || 0, scrollBoxYMax);
              bg.attr({
                width: legendObj._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,
                height: legendObj._effHeight - bw,
                x: bw / 2,
                y: bw / 2
              });
              clipPath.select("rect").attr({
                width: legendObj._width - 2 * bw + constants.scrollBarWidth + constants.scrollBarMargin,
                height: legendObj._effHeight - 2 * bw,
                x: bw,
                y: bw + scrollBoxY
              });
              Drawing.setClipUrl(scrollBox, clipId, gd);
              scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
              legend.on("wheel", function() {
                scrollBoxY = Lib.constrain(
                  legendObj._scrollY + d3.event.deltaY / scrollBarYMax * scrollBoxYMax,
                  0,
                  scrollBoxYMax
                );
                scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
                if (scrollBoxY !== 0 && scrollBoxY !== scrollBoxYMax) {
                  d3.event.preventDefault();
                }
              });
              var eventY0, eventY1, scrollBoxY0;
              var getScrollBarDragY = function(scrollBoxY02, eventY02, eventY12) {
                var y = (eventY12 - eventY02) / scrollRatio + scrollBoxY02;
                return Lib.constrain(y, 0, scrollBoxYMax);
              };
              var getNaturalDragY = function(scrollBoxY02, eventY02, eventY12) {
                var y = (eventY02 - eventY12) / scrollRatio + scrollBoxY02;
                return Lib.constrain(y, 0, scrollBoxYMax);
              };
              var scrollBarDrag = d3.behavior.drag().on("dragstart", function() {
                var e = d3.event.sourceEvent;
                if (e.type === "touchstart") {
                  eventY0 = e.changedTouches[0].clientY;
                } else {
                  eventY0 = e.clientY;
                }
                scrollBoxY0 = scrollBoxY;
              }).on("drag", function() {
                var e = d3.event.sourceEvent;
                if (e.buttons === 2 || e.ctrlKey) return;
                if (e.type === "touchmove") {
                  eventY1 = e.changedTouches[0].clientY;
                } else {
                  eventY1 = e.clientY;
                }
                scrollBoxY = getScrollBarDragY(scrollBoxY0, eventY0, eventY1);
                scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
              });
              scrollBar.call(scrollBarDrag);
              var scrollBoxTouchDrag = d3.behavior.drag().on("dragstart", function() {
                var e = d3.event.sourceEvent;
                if (e.type === "touchstart") {
                  eventY0 = e.changedTouches[0].clientY;
                  scrollBoxY0 = scrollBoxY;
                }
              }).on("drag", function() {
                var e = d3.event.sourceEvent;
                if (e.type === "touchmove") {
                  eventY1 = e.changedTouches[0].clientY;
                  scrollBoxY = getNaturalDragY(scrollBoxY0, eventY0, eventY1);
                  scrollHandler(scrollBoxY, scrollBarHeight, scrollRatio);
                }
              });
              scrollBox.call(scrollBoxTouchDrag);
            }
            function scrollHandler(scrollBoxY2, scrollBarHeight2, scrollRatio2) {
              legendObj._scrollY = gd._fullLayout[legendId]._scrollY = scrollBoxY2;
              Drawing.setTranslate(scrollBox, 0, -scrollBoxY2);
              Drawing.setRect(
                scrollBar,
                legendObj._width,
                constants.scrollBarMargin + scrollBoxY2 * scrollRatio2,
                constants.scrollBarWidth,
                scrollBarHeight2
              );
              clipPath.select("rect").attr("y", bw + scrollBoxY2);
            }
            if (gd._context.edits.legendPosition) {
              var xf, yf, x0, y0;
              legend.classed("cursor-move", true);
              dragElement.init({
                element: legend.node(),
                gd,
                prepFn: function(e) {
                  if (e.target === scrollBar.node()) {
                    return;
                  }
                  var transform = Drawing.getTranslate(legend);
                  x0 = transform.x;
                  y0 = transform.y;
                },
                moveFn: function(dx, dy) {
                  if (x0 !== void 0 && y0 !== void 0) {
                    var newX = x0 + dx;
                    var newY = y0 + dy;
                    Drawing.setTranslate(legend, newX, newY);
                    xf = dragElement.align(newX, legendObj._width, gs.l, gs.l + gs.w, legendObj.xanchor);
                    yf = dragElement.align(newY + legendObj._height, -legendObj._height, gs.t + gs.h, gs.t, legendObj.yanchor);
                  }
                },
                doneFn: function() {
                  if (xf !== void 0 && yf !== void 0) {
                    var obj = {};
                    obj[legendId + ".x"] = xf;
                    obj[legendId + ".y"] = yf;
                    Registry.call("_guiRelayout", gd, obj);
                  }
                },
                clickFn: function(numClicks, e) {
                  var clickedTrace = layer.selectAll("g.traces").filter(function() {
                    var bbox = this.getBoundingClientRect();
                    return e.clientX >= bbox.left && e.clientX <= bbox.right && e.clientY >= bbox.top && e.clientY <= bbox.bottom;
                  });
                  if (clickedTrace.size() > 0) {
                    clickOrDoubleClick(gd, legend, clickedTrace, numClicks, e);
                  }
                }
              });
            }
          }
        ], gd);
      }
      function getTraceWidth(d, legendObj, textGap) {
        var legendItem = d[0];
        var legendWidth = legendItem.width;
        var mode = legendObj.entrywidthmode;
        var traceLegendWidth = legendItem.trace.legendwidth || legendObj.entrywidth;
        if (mode === "fraction") return legendObj._maxWidth * traceLegendWidth;
        return textGap + (traceLegendWidth || legendWidth);
      }
      function clickOrDoubleClick(gd, legend, legendItem, numClicks, evt) {
        var trace = legendItem.data()[0][0].trace;
        var evtData = {
          event: evt,
          node: legendItem.node(),
          curveNumber: trace.index,
          expandedIndex: trace.index,
          data: gd.data,
          layout: gd.layout,
          frames: gd._transitionData._frames,
          config: gd._context,
          fullData: gd._fullData,
          fullLayout: gd._fullLayout
        };
        if (trace._group) {
          evtData.group = trace._group;
        }
        if (Registry.traceIs(trace, "pie-like")) {
          evtData.label = legendItem.datum()[0].label;
        }
        var clickVal = Events.triggerHandler(gd, "plotly_legendclick", evtData);
        if (numClicks === 1) {
          if (clickVal === false) return;
          legend._clickTimeout = setTimeout(function() {
            if (!gd._fullLayout) return;
            handleClick(legendItem, gd, numClicks);
          }, gd._context.doubleClickDelay);
        } else if (numClicks === 2) {
          if (legend._clickTimeout) clearTimeout(legend._clickTimeout);
          gd._legendMouseDownTime = 0;
          var dblClickVal = Events.triggerHandler(gd, "plotly_legenddoubleclick", evtData);
          if (dblClickVal !== false && clickVal !== false) handleClick(legendItem, gd, numClicks);
        }
      }
      function drawTexts(g, gd, legendObj) {
        var legendId = getId(legendObj);
        var legendItem = g.data()[0][0];
        var trace = legendItem.trace;
        var isPieLike = Registry.traceIs(trace, "pie-like");
        var isEditable = !legendObj._inHover && gd._context.edits.legendText && !isPieLike;
        var maxNameLength = legendObj._maxNameLength;
        var name, font;
        if (legendItem.groupTitle) {
          name = legendItem.groupTitle.text;
          font = legendItem.groupTitle.font;
        } else {
          font = legendObj.font;
          if (!legendObj.entries) {
            name = isPieLike ? legendItem.label : trace.name;
            if (trace._meta) {
              name = Lib.templateString(name, trace._meta);
            }
          } else {
            name = legendItem.text;
          }
        }
        var textEl = Lib.ensureSingle(g, "text", legendId + "text");
        textEl.attr("text-anchor", "start").call(Drawing.font, font).text(isEditable ? ensureLength(name, maxNameLength) : name);
        var textGap = legendObj.indentation + legendObj.itemwidth + constants.itemGap * 2;
        svgTextUtils.positionText(textEl, textGap, 0);
        if (isEditable) {
          textEl.call(svgTextUtils.makeEditable, { gd, text: name }).call(textLayout, g, gd, legendObj).on("edit", function(newName) {
            this.text(ensureLength(newName, maxNameLength)).call(textLayout, g, gd, legendObj);
            var fullInput = legendItem.trace._fullInput || {};
            var update = {};
            update.name = newName;
            if (fullInput._isShape) {
              return Registry.call("_guiRelayout", gd, "shapes[" + trace.index + "].name", update.name);
            } else {
              return Registry.call("_guiRestyle", gd, update, trace.index);
            }
          });
        } else {
          textLayout(textEl, g, gd, legendObj);
        }
      }
      function ensureLength(str, maxLength) {
        var targetLength = Math.max(4, maxLength);
        if (str && str.trim().length >= targetLength / 2) return str;
        str = str || "";
        for (var i = targetLength - str.length; i > 0; i--) str += " ";
        return str;
      }
      function setupTraceToggle(g, gd, legendId) {
        var doubleClickDelay = gd._context.doubleClickDelay;
        var newMouseDownTime;
        var numClicks = 1;
        var traceToggle = Lib.ensureSingle(g, "rect", legendId + "toggle", function(s) {
          if (!gd._context.staticPlot) {
            s.style("cursor", "pointer").attr("pointer-events", "all");
          }
          s.call(Color.fill, "rgba(0,0,0,0)");
        });
        if (gd._context.staticPlot) return;
        traceToggle.on("mousedown", function() {
          newMouseDownTime = (/* @__PURE__ */ new Date()).getTime();
          if (newMouseDownTime - gd._legendMouseDownTime < doubleClickDelay) {
            numClicks += 1;
          } else {
            numClicks = 1;
            gd._legendMouseDownTime = newMouseDownTime;
          }
        });
        traceToggle.on("mouseup", function() {
          if (gd._dragged || gd._editing) return;
          var legend = gd._fullLayout[legendId];
          if ((/* @__PURE__ */ new Date()).getTime() - gd._legendMouseDownTime > doubleClickDelay) {
            numClicks = Math.max(numClicks - 1, 1);
          }
          clickOrDoubleClick(gd, legend, g, numClicks, d3.event);
        });
      }
      function textLayout(s, g, gd, legendObj, aTitle) {
        if (legendObj._inHover) s.attr("data-notex", true);
        svgTextUtils.convertToTspans(s, gd, function() {
          computeTextDimensions(g, gd, legendObj, aTitle);
        });
      }
      function computeTextDimensions(g, gd, legendObj, aTitle) {
        var legendItem = g.data()[0][0];
        if (!legendObj._inHover && legendItem && !legendItem.trace.showlegend) {
          g.remove();
          return;
        }
        var mathjaxGroup = g.select("g[class*=math-group]");
        var mathjaxNode = mathjaxGroup.node();
        var legendId = getId(legendObj);
        if (!legendObj) {
          legendObj = gd._fullLayout[legendId];
        }
        var bw = legendObj.borderwidth;
        var font;
        if (aTitle === MAIN_TITLE) {
          font = legendObj.title.font;
        } else if (legendItem.groupTitle) {
          font = legendItem.groupTitle.font;
        } else {
          font = legendObj.font;
        }
        var lineHeight = font.size * LINE_SPACING;
        var height, width;
        if (mathjaxNode) {
          var mathjaxBB = Drawing.bBox(mathjaxNode);
          height = mathjaxBB.height;
          width = mathjaxBB.width;
          if (aTitle === MAIN_TITLE) {
            Drawing.setTranslate(mathjaxGroup, bw, bw + height * 0.75);
          } else {
            Drawing.setTranslate(mathjaxGroup, 0, height * 0.25);
          }
        } else {
          var cls = "." + legendId + (aTitle === MAIN_TITLE ? "title" : "") + "text";
          var textEl = g.select(cls);
          var textLines = svgTextUtils.lineCount(textEl);
          var textNode = textEl.node();
          height = lineHeight * textLines;
          width = textNode ? Drawing.bBox(textNode).width : 0;
          if (aTitle === MAIN_TITLE) {
            if (legendObj.title.side === "left") {
              width += constants.itemGap * 2;
            }
            svgTextUtils.positionText(
              textEl,
              bw + constants.titlePad,
              bw + lineHeight
            );
          } else {
            var x = constants.itemGap * 2 + legendObj.indentation + legendObj.itemwidth;
            if (legendItem.groupTitle) {
              x = constants.itemGap;
              width -= legendObj.indentation + legendObj.itemwidth;
            }
            svgTextUtils.positionText(
              textEl,
              x,
              -lineHeight * ((textLines - 1) / 2 - 0.3)
            );
          }
        }
        if (aTitle === MAIN_TITLE) {
          legendObj._titleWidth = width;
          legendObj._titleHeight = height;
        } else {
          legendItem.lineHeight = lineHeight;
          legendItem.height = Math.max(height, 16) + 3;
          legendItem.width = width;
        }
      }
      function getTitleSize(legendObj) {
        var w = 0;
        var h = 0;
        var side = legendObj.title.side;
        if (side) {
          if (side.indexOf("left") !== -1) {
            w = legendObj._titleWidth;
          }
          if (side.indexOf("top") !== -1) {
            h = legendObj._titleHeight;
          }
        }
        return [w, h];
      }
      function computeLegendDimensions(gd, groups, traces, legendObj) {
        var fullLayout = gd._fullLayout;
        var legendId = getId(legendObj);
        if (!legendObj) {
          legendObj = fullLayout[legendId];
        }
        var gs = fullLayout._size;
        var isVertical = helpers.isVertical(legendObj);
        var isGrouped = helpers.isGrouped(legendObj);
        var isFraction = legendObj.entrywidthmode === "fraction";
        var bw = legendObj.borderwidth;
        var bw2 = 2 * bw;
        var itemGap = constants.itemGap;
        var textGap = legendObj.indentation + legendObj.itemwidth + itemGap * 2;
        var endPad = 2 * (bw + itemGap);
        var yanchor = getYanchor(legendObj);
        var isBelowPlotArea = legendObj.y < 0 || legendObj.y === 0 && yanchor === "top";
        var isAbovePlotArea = legendObj.y > 1 || legendObj.y === 1 && yanchor === "bottom";
        var traceGroupGap = legendObj.tracegroupgap;
        var legendGroupWidths = {};
        legendObj._maxHeight = Math.max(
          isBelowPlotArea || isAbovePlotArea ? fullLayout.height / 2 : gs.h,
          30
        );
        var toggleRectWidth = 0;
        legendObj._width = 0;
        legendObj._height = 0;
        var titleSize = getTitleSize(legendObj);
        if (isVertical) {
          traces.each(function(d) {
            var h = d[0].height;
            Drawing.setTranslate(
              this,
              bw + titleSize[0],
              bw + titleSize[1] + legendObj._height + h / 2 + itemGap
            );
            legendObj._height += h;
            legendObj._width = Math.max(legendObj._width, d[0].width);
          });
          toggleRectWidth = textGap + legendObj._width;
          legendObj._width += itemGap + textGap + bw2;
          legendObj._height += endPad;
          if (isGrouped) {
            groups.each(function(d, i) {
              Drawing.setTranslate(this, 0, i * legendObj.tracegroupgap);
            });
            legendObj._height += (legendObj._lgroupsLength - 1) * legendObj.tracegroupgap;
          }
        } else {
          var xanchor = getXanchor(legendObj);
          var isLeftOfPlotArea = legendObj.x < 0 || legendObj.x === 0 && xanchor === "right";
          var isRightOfPlotArea = legendObj.x > 1 || legendObj.x === 1 && xanchor === "left";
          var isBeyondPlotAreaY = isAbovePlotArea || isBelowPlotArea;
          var hw = fullLayout.width / 2;
          legendObj._maxWidth = Math.max(
            isLeftOfPlotArea ? isBeyondPlotAreaY && xanchor === "left" ? gs.l + gs.w : hw : isRightOfPlotArea ? isBeyondPlotAreaY && xanchor === "right" ? gs.r + gs.w : hw : gs.w,
            2 * textGap
          );
          var maxItemWidth = 0;
          var combinedItemWidth = 0;
          traces.each(function(d) {
            var w = getTraceWidth(d, legendObj, textGap);
            maxItemWidth = Math.max(maxItemWidth, w);
            combinedItemWidth += w;
          });
          toggleRectWidth = null;
          var maxRowWidth = 0;
          if (isGrouped) {
            var maxGroupHeightInRow = 0;
            var groupOffsetX = 0;
            var groupOffsetY = 0;
            groups.each(function() {
              var maxWidthInGroup = 0;
              var offsetY2 = 0;
              d3.select(this).selectAll("g.traces").each(function(d) {
                var w = getTraceWidth(d, legendObj, textGap);
                var h = d[0].height;
                Drawing.setTranslate(
                  this,
                  titleSize[0],
                  titleSize[1] + bw + itemGap + h / 2 + offsetY2
                );
                offsetY2 += h;
                maxWidthInGroup = Math.max(maxWidthInGroup, w);
                legendGroupWidths[d[0].trace.legendgroup] = maxWidthInGroup;
              });
              var next = maxWidthInGroup + itemGap;
              if (
                // not on the first column already
                groupOffsetX > 0 && // goes beyound limit
                next + bw + groupOffsetX > legendObj._maxWidth
              ) {
                maxRowWidth = Math.max(maxRowWidth, groupOffsetX);
                groupOffsetX = 0;
                groupOffsetY += maxGroupHeightInRow + traceGroupGap;
                maxGroupHeightInRow = offsetY2;
              } else {
                maxGroupHeightInRow = Math.max(maxGroupHeightInRow, offsetY2);
              }
              Drawing.setTranslate(this, groupOffsetX, groupOffsetY);
              groupOffsetX += next;
            });
            legendObj._width = Math.max(maxRowWidth, groupOffsetX) + bw;
            legendObj._height = groupOffsetY + maxGroupHeightInRow + endPad;
          } else {
            var nTraces = traces.size();
            var oneRowLegend = combinedItemWidth + bw2 + (nTraces - 1) * itemGap < legendObj._maxWidth;
            var maxItemHeightInRow = 0;
            var offsetX = 0;
            var offsetY = 0;
            var rowWidth = 0;
            traces.each(function(d) {
              var h = d[0].height;
              var w = getTraceWidth(d, legendObj, textGap, isGrouped);
              var next = oneRowLegend ? w : maxItemWidth;
              if (!isFraction) {
                next += itemGap;
              }
              if (next + bw + offsetX - itemGap >= legendObj._maxWidth) {
                maxRowWidth = Math.max(maxRowWidth, rowWidth);
                offsetX = 0;
                offsetY += maxItemHeightInRow;
                legendObj._height += maxItemHeightInRow;
                maxItemHeightInRow = 0;
              }
              Drawing.setTranslate(
                this,
                titleSize[0] + bw + offsetX,
                titleSize[1] + bw + offsetY + h / 2 + itemGap
              );
              rowWidth = offsetX + w + itemGap;
              offsetX += next;
              maxItemHeightInRow = Math.max(maxItemHeightInRow, h);
            });
            if (oneRowLegend) {
              legendObj._width = offsetX + bw2;
              legendObj._height = maxItemHeightInRow + endPad;
            } else {
              legendObj._width = Math.max(maxRowWidth, rowWidth) + bw2;
              legendObj._height += maxItemHeightInRow + endPad;
            }
          }
        }
        legendObj._width = Math.ceil(
          Math.max(
            legendObj._width + titleSize[0],
            legendObj._titleWidth + 2 * (bw + constants.titlePad)
          )
        );
        legendObj._height = Math.ceil(
          Math.max(
            legendObj._height + titleSize[1],
            legendObj._titleHeight + 2 * (bw + constants.itemGap)
          )
        );
        legendObj._effHeight = Math.min(legendObj._height, legendObj._maxHeight);
        var edits = gd._context.edits;
        var isEditable = edits.legendText || edits.legendPosition;
        traces.each(function(d) {
          var traceToggle = d3.select(this).select("." + legendId + "toggle");
          var h = d[0].height;
          var legendgroup = d[0].trace.legendgroup;
          var traceWidth = getTraceWidth(d, legendObj, textGap);
          if (isGrouped && legendgroup !== "") {
            traceWidth = legendGroupWidths[legendgroup];
          }
          var w = isEditable ? textGap : toggleRectWidth || traceWidth;
          if (!isVertical && !isFraction) {
            w += itemGap / 2;
          }
          Drawing.setRect(traceToggle, 0, -h / 2, w, h);
        });
      }
      function expandMargin(gd, legendId, lx, ly) {
        var fullLayout = gd._fullLayout;
        var legendObj = fullLayout[legendId];
        var xanchor = getXanchor(legendObj);
        var yanchor = getYanchor(legendObj);
        var isPaperX = legendObj.xref === "paper";
        var isPaperY = legendObj.yref === "paper";
        gd._fullLayout._reservedMargin[legendId] = {};
        var sideY = legendObj.y < 0.5 ? "b" : "t";
        var sideX = legendObj.x < 0.5 ? "l" : "r";
        var possibleReservedMargins = {
          r: fullLayout.width - lx,
          l: lx + legendObj._width,
          b: fullLayout.height - ly,
          t: ly + legendObj._effHeight
        };
        if (isPaperX && isPaperY) {
          return Plots.autoMargin(gd, legendId, {
            x: legendObj.x,
            y: legendObj.y,
            l: legendObj._width * FROM_TL[xanchor],
            r: legendObj._width * FROM_BR[xanchor],
            b: legendObj._effHeight * FROM_BR[yanchor],
            t: legendObj._effHeight * FROM_TL[yanchor]
          });
        } else if (isPaperX) {
          gd._fullLayout._reservedMargin[legendId][sideY] = possibleReservedMargins[sideY];
        } else if (isPaperY) {
          gd._fullLayout._reservedMargin[legendId][sideX] = possibleReservedMargins[sideX];
        } else {
          if (legendObj.orientation === "v") {
            gd._fullLayout._reservedMargin[legendId][sideX] = possibleReservedMargins[sideX];
          } else {
            gd._fullLayout._reservedMargin[legendId][sideY] = possibleReservedMargins[sideY];
          }
        }
      }
      function getXanchor(legendObj) {
        return Lib.isRightAnchor(legendObj) ? "right" : Lib.isCenterAnchor(legendObj) ? "center" : "left";
      }
      function getYanchor(legendObj) {
        return Lib.isBottomAnchor(legendObj) ? "bottom" : Lib.isMiddleAnchor(legendObj) ? "middle" : "top";
      }
      function getId(legendObj) {
        return legendObj._id || "legend";
      }
    }
  });

  // src/components/fx/hover.js
  var require_hover = __commonJS({
    "src/components/fx/hover.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var Lib = require_lib();
      var pushUnique = Lib.pushUnique;
      var strTranslate = Lib.strTranslate;
      var strRotate = Lib.strRotate;
      var Events = require_events2();
      var svgTextUtils = require_svg_text_utils();
      var overrideCursor = require_override_cursor();
      var Drawing = require_drawing();
      var Color = require_color();
      var dragElement = require_dragelement();
      var Axes = require_axes();
      var zindexSeparator = require_constants2().zindexSeparator;
      var Registry = require_registry();
      var helpers = require_helpers2();
      var constants = require_constants();
      var legendSupplyDefaults = require_defaults3();
      var legendDraw = require_draw();
      var YANGLE = constants.YANGLE;
      var YA_RADIANS = Math.PI * YANGLE / 180;
      var YFACTOR = 1 / Math.sin(YA_RADIANS);
      var YSHIFTX = Math.cos(YA_RADIANS);
      var YSHIFTY = Math.sin(YA_RADIANS);
      var HOVERARROWSIZE = constants.HOVERARROWSIZE;
      var HOVERTEXTPAD = constants.HOVERTEXTPAD;
      var multipleHoverPoints = {
        box: true,
        ohlc: true,
        violin: true,
        candlestick: true
      };
      var cartesianScatterPoints = {
        scatter: true,
        scattergl: true,
        splom: true
      };
      function distanceSort(a, b) {
        return a.distance - b.distance;
      }
      exports.hover = function hover(gd, evt, subplot, noHoverEvent) {
        gd = Lib.getGraphDiv(gd);
        var eventTarget = evt.target;
        Lib.throttle(
          gd._fullLayout._uid + constants.HOVERID,
          constants.HOVERMINTIME,
          function() {
            _hover(gd, evt, subplot, noHoverEvent, eventTarget);
          }
        );
      };
      exports.loneHover = function loneHover(hoverItems, opts) {
        var multiHover = true;
        if (!Array.isArray(hoverItems)) {
          multiHover = false;
          hoverItems = [hoverItems];
        }
        var gd = opts.gd;
        var gTop = getTopOffset(gd);
        var gLeft = getLeftOffset(gd);
        var pointsData = hoverItems.map(function(hoverItem) {
          var _x0 = hoverItem._x0 || hoverItem.x0 || hoverItem.x || 0;
          var _x1 = hoverItem._x1 || hoverItem.x1 || hoverItem.x || 0;
          var _y0 = hoverItem._y0 || hoverItem.y0 || hoverItem.y || 0;
          var _y1 = hoverItem._y1 || hoverItem.y1 || hoverItem.y || 0;
          var eventData = hoverItem.eventData;
          if (eventData) {
            var x0 = Math.min(_x0, _x1);
            var x1 = Math.max(_x0, _x1);
            var y0 = Math.min(_y0, _y1);
            var y1 = Math.max(_y0, _y1);
            var trace = hoverItem.trace;
            if (Registry.traceIs(trace, "gl3d")) {
              var container = gd._fullLayout[trace.scene]._scene.container;
              var dx = container.offsetLeft;
              var dy = container.offsetTop;
              x0 += dx;
              x1 += dx;
              y0 += dy;
              y1 += dy;
            }
            eventData.bbox = {
              x0: x0 + gLeft,
              x1: x1 + gLeft,
              y0: y0 + gTop,
              y1: y1 + gTop
            };
            if (opts.inOut_bbox) {
              opts.inOut_bbox.push(eventData.bbox);
            }
          } else {
            eventData = false;
          }
          return {
            color: hoverItem.color || Color.defaultLine,
            x0: hoverItem.x0 || hoverItem.x || 0,
            x1: hoverItem.x1 || hoverItem.x || 0,
            y0: hoverItem.y0 || hoverItem.y || 0,
            y1: hoverItem.y1 || hoverItem.y || 0,
            xLabel: hoverItem.xLabel,
            yLabel: hoverItem.yLabel,
            zLabel: hoverItem.zLabel,
            text: hoverItem.text,
            name: hoverItem.name,
            idealAlign: hoverItem.idealAlign,
            // optional extra bits of styling
            borderColor: hoverItem.borderColor,
            fontFamily: hoverItem.fontFamily,
            fontSize: hoverItem.fontSize,
            fontColor: hoverItem.fontColor,
            fontWeight: hoverItem.fontWeight,
            fontStyle: hoverItem.fontStyle,
            fontVariant: hoverItem.fontVariant,
            nameLength: hoverItem.nameLength,
            textAlign: hoverItem.textAlign,
            // filler to make createHoverText happy
            trace: hoverItem.trace || {
              index: 0,
              hoverinfo: ""
            },
            xa: { _offset: 0 },
            ya: { _offset: 0 },
            index: 0,
            hovertemplate: hoverItem.hovertemplate || false,
            hovertemplateLabels: hoverItem.hovertemplateLabels || false,
            eventData
          };
        });
        var rotateLabels = false;
        var hoverText = createHoverText(pointsData, {
          gd,
          hovermode: "closest",
          rotateLabels,
          bgColor: opts.bgColor || Color.background,
          container: d3.select(opts.container),
          outerContainer: opts.outerContainer || opts.container
        });
        var hoverLabel = hoverText.hoverLabels;
        var tooltipSpacing = 5;
        var lastBottomY = 0;
        var anchor = 0;
        hoverLabel.sort(function(a, b) {
          return a.y0 - b.y0;
        }).each(function(d, i) {
          var topY = d.y0 - d.by / 2;
          if (topY - tooltipSpacing < lastBottomY) {
            d.offset = lastBottomY - topY + tooltipSpacing;
          } else {
            d.offset = 0;
          }
          lastBottomY = topY + d.by + d.offset;
          if (i === opts.anchorIndex || 0) anchor = d.offset;
        }).each(function(d) {
          d.offset -= anchor;
        });
        var scaleX = gd._fullLayout._invScaleX;
        var scaleY = gd._fullLayout._invScaleY;
        alignHoverText(hoverLabel, rotateLabels, scaleX, scaleY);
        return multiHover ? hoverLabel : hoverLabel.node();
      };
      function _hover(gd, evt, subplot, noHoverEvent, eventTarget) {
        if (!subplot) subplot = "xy";
        if (typeof subplot === "string") {
          subplot = subplot.split(zindexSeparator)[0];
        }
        var subplots = Array.isArray(subplot) ? subplot : [subplot];
        var spId;
        var fullLayout = gd._fullLayout;
        var hoversubplots = fullLayout.hoversubplots;
        var plots = fullLayout._plots || [];
        var plotinfo = plots[subplot];
        var hasCartesian = fullLayout._has("cartesian");
        var hovermode = evt.hovermode || fullLayout.hovermode;
        var hovermodeHasX = (hovermode || "").charAt(0) === "x";
        var hovermodeHasY = (hovermode || "").charAt(0) === "y";
        var firstXaxis;
        var firstYaxis;
        if (hasCartesian && (hovermodeHasX || hovermodeHasY) && hoversubplots === "axis") {
          var subplotsLength = subplots.length;
          for (var p = 0; p < subplotsLength; p++) {
            spId = subplots[p];
            if (plots[spId]) {
              firstXaxis = Axes.getFromId(gd, spId, "x");
              firstYaxis = Axes.getFromId(gd, spId, "y");
              var subplotsWith = (hovermodeHasX ? firstXaxis : firstYaxis)._subplotsWith;
              if (subplotsWith && subplotsWith.length) {
                for (var q = 0; q < subplotsWith.length; q++) {
                  pushUnique(subplots, subplotsWith[q]);
                }
              }
            }
          }
        }
        if (plotinfo && hoversubplots !== "single") {
          var overlayedSubplots = plotinfo.overlays.map(function(pi) {
            return pi.id;
          });
          subplots = subplots.concat(overlayedSubplots);
        }
        var len = subplots.length;
        var xaArray = new Array(len);
        var yaArray = new Array(len);
        var supportsCompare = false;
        for (var i = 0; i < len; i++) {
          spId = subplots[i];
          if (plots[spId]) {
            supportsCompare = true;
            xaArray[i] = plots[spId].xaxis;
            yaArray[i] = plots[spId].yaxis;
          } else if (fullLayout[spId] && fullLayout[spId]._subplot) {
            var _subplot = fullLayout[spId]._subplot;
            xaArray[i] = _subplot.xaxis;
            yaArray[i] = _subplot.yaxis;
          } else {
            Lib.warn("Unrecognized subplot: " + spId);
            return;
          }
        }
        if (hovermode && !supportsCompare) hovermode = "closest";
        if (["x", "y", "closest", "x unified", "y unified"].indexOf(hovermode) === -1 || !gd.calcdata || gd.querySelector(".zoombox") || gd._dragging) {
          return dragElement.unhoverRaw(gd, evt);
        }
        var hoverdistance = fullLayout.hoverdistance;
        if (hoverdistance === -1) hoverdistance = Infinity;
        var spikedistance = fullLayout.spikedistance;
        if (spikedistance === -1) spikedistance = Infinity;
        var hoverData = [];
        var searchData = [];
        var xvalArray, yvalArray;
        var itemnum, curvenum, cd, trace, subplotId, subploti, _mode, xval, yval, pointData, closedataPreviousLength;
        var spikePoints = {
          hLinePoint: null,
          vLinePoint: null
        };
        var hasOneHorizontalTrace = false;
        if (Array.isArray(evt)) {
          hovermode = "array";
          for (itemnum = 0; itemnum < evt.length; itemnum++) {
            cd = gd.calcdata[evt[itemnum].curveNumber || 0];
            if (cd) {
              trace = cd[0].trace;
              if (cd[0].trace.hoverinfo !== "skip") {
                searchData.push(cd);
                if (trace.orientation === "h") {
                  hasOneHorizontalTrace = true;
                }
              }
            }
          }
        } else {
          var zorderedCalcdata = gd.calcdata.slice();
          zorderedCalcdata.sort(function(a, b) {
            var aZorder = a[0].trace.zorder || 0;
            var bZorder = b[0].trace.zorder || 0;
            return aZorder - bZorder;
          });
          for (curvenum = 0; curvenum < zorderedCalcdata.length; curvenum++) {
            cd = zorderedCalcdata[curvenum];
            trace = cd[0].trace;
            if (trace.hoverinfo !== "skip" && helpers.isTraceInSubplots(trace, subplots)) {
              searchData.push(cd);
              if (trace.orientation === "h") {
                hasOneHorizontalTrace = true;
              }
            }
          }
          var hasUserCalledHover = !eventTarget;
          var xpx, ypx;
          if (hasUserCalledHover) {
            if ("xpx" in evt) xpx = evt.xpx;
            else xpx = xaArray[0]._length / 2;
            if ("ypx" in evt) ypx = evt.ypx;
            else ypx = yaArray[0]._length / 2;
          } else {
            if (Events.triggerHandler(gd, "plotly_beforehover", evt) === false) {
              return;
            }
            var dbb = eventTarget.getBoundingClientRect();
            xpx = evt.clientX - dbb.left;
            ypx = evt.clientY - dbb.top;
            fullLayout._calcInverseTransform(gd);
            var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(xpx, ypx);
            xpx = transformedCoords[0];
            ypx = transformedCoords[1];
            if (xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {
              return dragElement.unhoverRaw(gd, evt);
            }
          }
          evt.pointerX = xpx + xaArray[0]._offset;
          evt.pointerY = ypx + yaArray[0]._offset;
          if ("xval" in evt) xvalArray = helpers.flat(subplots, evt.xval);
          else xvalArray = helpers.p2c(xaArray, xpx);
          if ("yval" in evt) yvalArray = helpers.flat(subplots, evt.yval);
          else yvalArray = helpers.p2c(yaArray, ypx);
          if (!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {
            Lib.warn("Fx.hover failed", evt, gd);
            return dragElement.unhoverRaw(gd, evt);
          }
        }
        var distance = Infinity;
        function findHoverPoints(customXVal, customYVal) {
          for (curvenum = 0; curvenum < searchData.length; curvenum++) {
            cd = searchData[curvenum];
            if (!cd || !cd[0] || !cd[0].trace) continue;
            trace = cd[0].trace;
            if (trace.visible !== true || trace._length === 0) continue;
            if (["carpet", "contourcarpet"].indexOf(trace._module.name) !== -1) continue;
            _mode = hovermode;
            if (helpers.isUnifiedHover(_mode)) {
              _mode = _mode.charAt(0);
            }
            if (trace.type === "splom") {
              subploti = 0;
              subplotId = subplots[subploti];
            } else {
              subplotId = helpers.getSubplot(trace);
              subploti = subplots.indexOf(subplotId);
            }
            pointData = {
              // trace properties
              cd,
              trace,
              xa: xaArray[subploti],
              ya: yaArray[subploti],
              // max distances for hover and spikes - for points that want to show but do not
              // want to override other points, set distance/spikeDistance equal to max*Distance
              // and it will not get filtered out but it will be guaranteed to have a greater
              // distance than any point that calculated a real distance.
              maxHoverDistance: hoverdistance,
              maxSpikeDistance: spikedistance,
              // point properties - override all of these
              index: false,
              // point index in trace - only used by plotly.js hoverdata consumers
              distance: Math.min(distance, hoverdistance),
              // pixel distance or pseudo-distance
              // distance/pseudo-distance for spikes. This distance should always be calculated
              // as if in "closest" mode, and should only be set if this point should
              // generate a spike.
              spikeDistance: Infinity,
              // in some cases the spikes have different positioning from the hover label
              // they don't need x0/x1, just one position
              xSpike: void 0,
              ySpike: void 0,
              // where and how to display the hover label
              color: Color.defaultLine,
              // trace color
              name: trace.name,
              x0: void 0,
              x1: void 0,
              y0: void 0,
              y1: void 0,
              xLabelVal: void 0,
              yLabelVal: void 0,
              zLabelVal: void 0,
              text: void 0
            };
            if (fullLayout[subplotId]) {
              pointData.subplot = fullLayout[subplotId]._subplot;
            }
            if (fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {
              pointData.scene = fullLayout._splomScenes[trace.uid];
            }
            if (_mode === "array") {
              var selection = evt[curvenum];
              if ("pointNumber" in selection) {
                pointData.index = selection.pointNumber;
                _mode = "closest";
              } else {
                _mode = "";
                if ("xval" in selection) {
                  xval = selection.xval;
                  _mode = "x";
                }
                if ("yval" in selection) {
                  yval = selection.yval;
                  _mode = _mode ? "closest" : "y";
                }
              }
            } else if (customXVal !== void 0 && customYVal !== void 0) {
              xval = customXVal;
              yval = customYVal;
            } else {
              xval = xvalArray[subploti];
              yval = yvalArray[subploti];
            }
            closedataPreviousLength = hoverData.length;
            if (hoverdistance !== 0) {
              if (trace._module && trace._module.hoverPoints) {
                var newPoints = trace._module.hoverPoints(pointData, xval, yval, _mode, {
                  finiteRange: true,
                  hoverLayer: fullLayout._hoverlayer,
                  // options for splom when hovering on same axis
                  hoversubplots,
                  gd
                });
                if (newPoints) {
                  var newPoint;
                  for (var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {
                    newPoint = newPoints[newPointNum];
                    if (isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {
                      hoverData.push(cleanPoint(newPoint, hovermode));
                    }
                  }
                }
              } else {
                Lib.log("Unrecognized trace type in hover:", trace);
              }
            }
            if (hovermode === "closest" && hoverData.length > closedataPreviousLength) {
              hoverData.splice(0, closedataPreviousLength);
              distance = hoverData[0].distance;
            }
            if (hasCartesian && spikedistance !== 0) {
              if (hoverData.length === 0) {
                pointData.distance = spikedistance;
                pointData.index = false;
                var closestPoints = trace._module.hoverPoints(pointData, xval, yval, "closest", {
                  hoverLayer: fullLayout._hoverlayer
                });
                if (closestPoints) {
                  closestPoints = closestPoints.filter(function(point) {
                    return point.spikeDistance <= spikedistance;
                  });
                }
                if (closestPoints && closestPoints.length) {
                  var tmpPoint;
                  var closestVPoints = closestPoints.filter(function(point) {
                    return point.xa.showspikes && point.xa.spikesnap !== "hovered data";
                  });
                  if (closestVPoints.length) {
                    var closestVPt = closestVPoints[0];
                    if (isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {
                      tmpPoint = fillSpikePoint(closestVPt);
                      if (!spikePoints.vLinePoint || spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance) {
                        spikePoints.vLinePoint = tmpPoint;
                      }
                    }
                  }
                  var closestHPoints = closestPoints.filter(function(point) {
                    return point.ya.showspikes && point.ya.spikesnap !== "hovered data";
                  });
                  if (closestHPoints.length) {
                    var closestHPt = closestHPoints[0];
                    if (isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {
                      tmpPoint = fillSpikePoint(closestHPt);
                      if (!spikePoints.hLinePoint || spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance) {
                        spikePoints.hLinePoint = tmpPoint;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        findHoverPoints();
        function selectClosestPoint(pointsData, spikedistance2, spikeOnWinning2) {
          var resultPoint = null;
          var minDistance = Infinity;
          var thisSpikeDistance;
          for (var i2 = 0; i2 < pointsData.length; i2++) {
            if (firstXaxis && firstXaxis._id !== pointsData[i2].xa._id) continue;
            if (firstYaxis && firstYaxis._id !== pointsData[i2].ya._id) continue;
            thisSpikeDistance = pointsData[i2].spikeDistance;
            if (spikeOnWinning2 && i2 === 0) thisSpikeDistance = -Infinity;
            if (thisSpikeDistance <= minDistance && thisSpikeDistance <= spikedistance2) {
              resultPoint = pointsData[i2];
              minDistance = thisSpikeDistance;
            }
          }
          return resultPoint;
        }
        function fillSpikePoint(point) {
          if (!point) return null;
          return {
            xa: point.xa,
            ya: point.ya,
            x: point.xSpike !== void 0 ? point.xSpike : (point.x0 + point.x1) / 2,
            y: point.ySpike !== void 0 ? point.ySpike : (point.y0 + point.y1) / 2,
            distance: point.distance,
            spikeDistance: point.spikeDistance,
            curveNumber: point.trace.index,
            color: point.color,
            pointNumber: point.index
          };
        }
        var spikelineOpts = {
          fullLayout,
          container: fullLayout._hoverlayer,
          event: evt
        };
        var oldspikepoints = gd._spikepoints;
        var newspikepoints = {
          vLinePoint: spikePoints.vLinePoint,
          hLinePoint: spikePoints.hLinePoint
        };
        gd._spikepoints = newspikepoints;
        var sortHoverData = function() {
          var hoverDataInSubplot = hoverData.filter(function(a) {
            return firstXaxis && firstXaxis._id === a.xa._id && (firstYaxis && firstYaxis._id === a.ya._id);
          });
          var hoverDataOutSubplot = hoverData.filter(function(a) {
            return !(firstXaxis && firstXaxis._id === a.xa._id && (firstYaxis && firstYaxis._id === a.ya._id));
          });
          hoverDataInSubplot.sort(distanceSort);
          hoverDataOutSubplot.sort(distanceSort);
          hoverData = hoverDataInSubplot.concat(hoverDataOutSubplot);
          hoverData = orderRangePoints(hoverData, hovermode);
        };
        sortHoverData();
        var axLetter = hovermode.charAt(0);
        var spikeOnWinning = (axLetter === "x" || axLetter === "y") && hoverData[0] && cartesianScatterPoints[hoverData[0].trace.type];
        if (hasCartesian && spikedistance !== 0) {
          if (hoverData.length !== 0) {
            var tmpHPointData = hoverData.filter(function(point) {
              return point.ya.showspikes;
            });
            var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance, spikeOnWinning);
            spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);
            var tmpVPointData = hoverData.filter(function(point) {
              return point.xa.showspikes;
            });
            var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance, spikeOnWinning);
            spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);
          }
        }
        if (hoverData.length === 0) {
          var result = dragElement.unhoverRaw(gd, evt);
          if (hasCartesian && (spikePoints.hLinePoint !== null || spikePoints.vLinePoint !== null)) {
            if (spikesChanged(oldspikepoints)) {
              createSpikelines(gd, spikePoints, spikelineOpts);
            }
          }
          return result;
        }
        if (hasCartesian) {
          if (spikesChanged(oldspikepoints)) {
            createSpikelines(gd, spikePoints, spikelineOpts);
          }
        }
        if (helpers.isXYhover(_mode) && hoverData[0].length !== 0 && hoverData[0].trace.type !== "splom") {
          var winningPoint = hoverData[0];
          if (multipleHoverPoints[winningPoint.trace.type]) {
            hoverData = hoverData.filter(function(d) {
              return d.trace.index === winningPoint.trace.index;
            });
          } else {
            hoverData = [winningPoint];
          }
          var initLen = hoverData.length;
          var winX = getCoord("x", winningPoint, fullLayout);
          var winY = getCoord("y", winningPoint, fullLayout);
          findHoverPoints(winX, winY);
          var finalPoints = [];
          var seen = {};
          var id = 0;
          var insert = function(newHd) {
            var key = multipleHoverPoints[newHd.trace.type] ? hoverDataKey(newHd) : newHd.trace.index;
            if (!seen[key]) {
              id++;
              seen[key] = id;
              finalPoints.push(newHd);
            } else {
              var oldId = seen[key] - 1;
              var oldHd = finalPoints[oldId];
              if (oldId > 0 && Math.abs(newHd.distance) < Math.abs(oldHd.distance)) {
                finalPoints[oldId] = newHd;
              }
            }
          };
          var k;
          for (k = 0; k < initLen; k++) {
            insert(hoverData[k]);
          }
          for (k = hoverData.length - 1; k > initLen - 1; k--) {
            insert(hoverData[k]);
          }
          hoverData = finalPoints;
          sortHoverData();
        }
        var oldhoverdata = gd._hoverdata;
        var newhoverdata = [];
        var gTop = getTopOffset(gd);
        var gLeft = getLeftOffset(gd);
        for (itemnum = 0; itemnum < hoverData.length; itemnum++) {
          var pt = hoverData[itemnum];
          var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);
          if (pt.hovertemplate !== false) {
            var ht = false;
            if (pt.cd[pt.index] && pt.cd[pt.index].ht) {
              ht = pt.cd[pt.index].ht;
            }
            pt.hovertemplate = ht || pt.trace.hovertemplate || false;
          }
          if (pt.xa && pt.ya) {
            var _x0 = pt.x0 + pt.xa._offset;
            var _x1 = pt.x1 + pt.xa._offset;
            var _y0 = pt.y0 + pt.ya._offset;
            var _y1 = pt.y1 + pt.ya._offset;
            var x0 = Math.min(_x0, _x1);
            var x1 = Math.max(_x0, _x1);
            var y0 = Math.min(_y0, _y1);
            var y1 = Math.max(_y0, _y1);
            eventData.bbox = {
              x0: x0 + gLeft,
              x1: x1 + gLeft,
              y0: y0 + gTop,
              y1: y1 + gTop
            };
          }
          pt.eventData = [eventData];
          newhoverdata.push(eventData);
        }
        gd._hoverdata = newhoverdata;
        var rotateLabels = hovermode === "y" && (searchData.length > 1 || hoverData.length > 1) || hovermode === "closest" && hasOneHorizontalTrace && hoverData.length > 1;
        var bgColor = Color.combine(
          fullLayout.plot_bgcolor || Color.background,
          fullLayout.paper_bgcolor
        );
        var hoverText = createHoverText(hoverData, {
          gd,
          hovermode,
          rotateLabels,
          bgColor,
          container: fullLayout._hoverlayer,
          outerContainer: fullLayout._paper.node(),
          commonLabelOpts: fullLayout.hoverlabel,
          hoverdistance: fullLayout.hoverdistance
        });
        var hoverLabels = hoverText.hoverLabels;
        if (!helpers.isUnifiedHover(hovermode)) {
          hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, hoverText.commonLabelBoundingBox);
          alignHoverText(hoverLabels, rotateLabels, fullLayout._invScaleX, fullLayout._invScaleY);
        }
        if (eventTarget && eventTarget.tagName) {
          var hasClickToShow = Registry.getComponentMethod("annotations", "hasClickToShow")(gd, newhoverdata);
          overrideCursor(d3.select(eventTarget), hasClickToShow ? "pointer" : "");
        }
        if (!eventTarget || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;
        if (oldhoverdata) {
          gd.emit("plotly_unhover", {
            event: evt,
            points: oldhoverdata
          });
        }
        gd.emit("plotly_hover", {
          event: evt,
          points: gd._hoverdata,
          xaxes: xaArray,
          yaxes: yaArray,
          xvals: xvalArray,
          yvals: yvalArray
        });
      }
      function hoverDataKey(d) {
        return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa ? d.xa._id : "", d.ya ? d.ya._id : ""].join(",");
      }
      var EXTRA_STRING_REGEX = /<extra>([\s\S]*)<\/extra>/;
      function createHoverText(hoverData, opts) {
        var gd = opts.gd;
        var fullLayout = gd._fullLayout;
        var hovermode = opts.hovermode;
        var rotateLabels = opts.rotateLabels;
        var bgColor = opts.bgColor;
        var container = opts.container;
        var outerContainer = opts.outerContainer;
        var commonLabelOpts = opts.commonLabelOpts || {};
        if (hoverData.length === 0) return [[]];
        var fontFamily = opts.fontFamily || constants.HOVERFONT;
        var fontSize = opts.fontSize || constants.HOVERFONTSIZE;
        var fontWeight = opts.fontWeight || fullLayout.font.weight;
        var fontStyle = opts.fontStyle || fullLayout.font.style;
        var fontVariant = opts.fontVariant || fullLayout.font.variant;
        var fontTextcase = opts.fontTextcase || fullLayout.font.textcase;
        var fontLineposition = opts.fontLineposition || fullLayout.font.lineposition;
        var fontShadow = opts.fontShadow || fullLayout.font.shadow;
        var c0 = hoverData[0];
        var xa = c0.xa;
        var ya = c0.ya;
        var axLetter = hovermode.charAt(0);
        var axLabel = axLetter + "Label";
        var t0 = c0[axLabel];
        if (t0 === void 0 && xa.type === "multicategory") {
          for (var q = 0; q < hoverData.length; q++) {
            t0 = hoverData[q][axLabel];
            if (t0 !== void 0) break;
          }
        }
        var outerContainerBB = getBoundingClientRect(gd, outerContainer);
        var outerTop = outerContainerBB.top;
        var outerWidth = outerContainerBB.width;
        var outerHeight = outerContainerBB.height;
        var showCommonLabel = t0 !== void 0 && c0.distance <= opts.hoverdistance && (hovermode === "x" || hovermode === "y");
        if (showCommonLabel) {
          var allHaveZ = true;
          var i, traceHoverinfo;
          for (i = 0; i < hoverData.length; i++) {
            if (allHaveZ && hoverData[i].zLabel === void 0) allHaveZ = false;
            traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;
            if (traceHoverinfo) {
              var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split("+");
              if (parts.indexOf("all") === -1 && parts.indexOf(hovermode) === -1) {
                showCommonLabel = false;
                break;
              }
            }
          }
          if (allHaveZ) showCommonLabel = false;
        }
        var commonLabel = container.selectAll("g.axistext").data(showCommonLabel ? [0] : []);
        commonLabel.enter().append("g").classed("axistext", true);
        commonLabel.exit().remove();
        var commonLabelRect = {
          minX: 0,
          maxX: 0,
          minY: 0,
          maxY: 0
        };
        commonLabel.each(function() {
          var label = d3.select(this);
          var lpath = Lib.ensureSingle(label, "path", "", function(s) {
            s.style({ "stroke-width": "1px" });
          });
          var ltext = Lib.ensureSingle(label, "text", "", function(s) {
            s.attr("data-notex", 1);
          });
          var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;
          var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);
          var contrastColor = Color.contrast(commonBgColor);
          var commonLabelOptsFont = commonLabelOpts.font;
          var commonLabelFont = {
            weight: commonLabelOptsFont.weight || fontWeight,
            style: commonLabelOptsFont.style || fontStyle,
            variant: commonLabelOptsFont.variant || fontVariant,
            textcase: commonLabelOptsFont.textcase || fontTextcase,
            lineposition: commonLabelOptsFont.lineposition || fontLineposition,
            shadow: commonLabelOptsFont.shadow || fontShadow,
            family: commonLabelOptsFont.family || fontFamily,
            size: commonLabelOptsFont.size || fontSize,
            color: commonLabelOptsFont.color || contrastColor
          };
          lpath.style({
            fill: commonBgColor,
            stroke: commonStroke
          });
          ltext.text(t0).call(Drawing.font, commonLabelFont).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
          label.attr("transform", "");
          var tbb2 = getBoundingClientRect(gd, ltext.node());
          var lx2, ly2;
          if (hovermode === "x") {
            var topsign = xa.side === "top" ? "-" : "";
            ltext.attr("text-anchor", "middle").call(svgTextUtils.positionText, 0, xa.side === "top" ? outerTop - tbb2.bottom - HOVERARROWSIZE - HOVERTEXTPAD : outerTop - tbb2.top + HOVERARROWSIZE + HOVERTEXTPAD);
            lx2 = xa._offset + (c0.x0 + c0.x1) / 2;
            ly2 = ya._offset + (xa.side === "top" ? 0 : ya._length);
            var halfWidth = tbb2.width / 2 + HOVERTEXTPAD;
            var tooltipMidX = lx2;
            if (lx2 < halfWidth) {
              tooltipMidX = halfWidth;
            } else if (lx2 > fullLayout.width - halfWidth) {
              tooltipMidX = fullLayout.width - halfWidth;
            }
            lpath.attr("d", "M" + (lx2 - tooltipMidX) + ",0L" + (lx2 - tooltipMidX + HOVERARROWSIZE) + "," + topsign + HOVERARROWSIZE + "H" + halfWidth + "v" + topsign + (HOVERTEXTPAD * 2 + tbb2.height) + "H" + -halfWidth + "V" + topsign + HOVERARROWSIZE + "H" + (lx2 - tooltipMidX - HOVERARROWSIZE) + "Z");
            lx2 = tooltipMidX;
            commonLabelRect.minX = lx2 - halfWidth;
            commonLabelRect.maxX = lx2 + halfWidth;
            if (xa.side === "top") {
              commonLabelRect.minY = ly2 - (HOVERTEXTPAD * 2 + tbb2.height);
              commonLabelRect.maxY = ly2 - HOVERTEXTPAD;
            } else {
              commonLabelRect.minY = ly2 + HOVERTEXTPAD;
              commonLabelRect.maxY = ly2 + (HOVERTEXTPAD * 2 + tbb2.height);
            }
          } else {
            var anchor;
            var sgn;
            var leftsign;
            if (ya.side === "right") {
              anchor = "start";
              sgn = 1;
              leftsign = "";
              lx2 = xa._offset + xa._length;
            } else {
              anchor = "end";
              sgn = -1;
              leftsign = "-";
              lx2 = xa._offset;
            }
            ly2 = ya._offset + (c0.y0 + c0.y1) / 2;
            ltext.attr("text-anchor", anchor);
            lpath.attr("d", "M0,0L" + leftsign + HOVERARROWSIZE + "," + HOVERARROWSIZE + "V" + (HOVERTEXTPAD + tbb2.height / 2) + "h" + leftsign + (HOVERTEXTPAD * 2 + tbb2.width) + "V-" + (HOVERTEXTPAD + tbb2.height / 2) + "H" + leftsign + HOVERARROWSIZE + "V-" + HOVERARROWSIZE + "Z");
            commonLabelRect.minY = ly2 - (HOVERTEXTPAD + tbb2.height / 2);
            commonLabelRect.maxY = ly2 + (HOVERTEXTPAD + tbb2.height / 2);
            if (ya.side === "right") {
              commonLabelRect.minX = lx2 + HOVERARROWSIZE;
              commonLabelRect.maxX = lx2 + HOVERARROWSIZE + (HOVERTEXTPAD * 2 + tbb2.width);
            } else {
              commonLabelRect.minX = lx2 - HOVERARROWSIZE - (HOVERTEXTPAD * 2 + tbb2.width);
              commonLabelRect.maxX = lx2 - HOVERARROWSIZE;
            }
            var halfHeight = tbb2.height / 2;
            var lty = outerTop - tbb2.top - halfHeight;
            var clipId = "clip" + fullLayout._uid + "commonlabel" + ya._id;
            var clipPath;
            if (lx2 < tbb2.width + 2 * HOVERTEXTPAD + HOVERARROWSIZE) {
              clipPath = "M-" + (HOVERARROWSIZE + HOVERTEXTPAD) + "-" + halfHeight + "h-" + (tbb2.width - HOVERTEXTPAD) + "V" + halfHeight + "h" + (tbb2.width - HOVERTEXTPAD) + "Z";
              var ltx = tbb2.width - lx2 + HOVERTEXTPAD;
              svgTextUtils.positionText(ltext, ltx, lty);
              if (anchor === "end") {
                ltext.selectAll("tspan").each(function() {
                  var s = d3.select(this);
                  var dummy = Drawing.tester.append("text").text(s.text()).call(Drawing.font, commonLabelFont);
                  var dummyBB = getBoundingClientRect(gd, dummy.node());
                  if (Math.round(dummyBB.width) < Math.round(tbb2.width)) {
                    s.attr("x", ltx - dummyBB.width);
                  }
                  dummy.remove();
                });
              }
            } else {
              svgTextUtils.positionText(ltext, sgn * (HOVERTEXTPAD + HOVERARROWSIZE), lty);
              clipPath = null;
            }
            var textClip = fullLayout._topclips.selectAll("#" + clipId).data(clipPath ? [0] : []);
            textClip.enter().append("clipPath").attr("id", clipId).append("path");
            textClip.exit().remove();
            textClip.select("path").attr("d", clipPath);
            Drawing.setClipUrl(ltext, clipPath ? clipId : null, gd);
          }
          label.attr("transform", strTranslate(lx2, ly2));
        });
        if (helpers.isUnifiedHover(hovermode)) {
          container.selectAll("g.hovertext").remove();
          var groupedHoverData = hoverData.filter(function(data) {
            return data.hoverinfo !== "none";
          });
          if (groupedHoverData.length === 0) return [];
          var hoverlabel = fullLayout.hoverlabel;
          var font = hoverlabel.font;
          var mockLayoutIn = {
            showlegend: true,
            legend: {
              title: { text: t0, font },
              font,
              bgcolor: hoverlabel.bgcolor,
              bordercolor: hoverlabel.bordercolor,
              borderwidth: 1,
              tracegroupgap: 7,
              traceorder: fullLayout.legend ? fullLayout.legend.traceorder : void 0,
              orientation: "v"
            }
          };
          var mockLayoutOut = {
            font
          };
          legendSupplyDefaults(mockLayoutIn, mockLayoutOut, gd._fullData);
          var mockLegend = mockLayoutOut.legend;
          mockLegend.entries = [];
          for (var j = 0; j < groupedHoverData.length; j++) {
            var pt = groupedHoverData[j];
            if (pt.hoverinfo === "none") continue;
            var texts = getHoverLabelText(pt, true, hovermode, fullLayout, t0);
            var text = texts[0];
            var name = texts[1];
            pt.name = name;
            if (name !== "") {
              pt.text = name + " : " + text;
            } else {
              pt.text = text;
            }
            var cd = pt.cd[pt.index];
            if (cd) {
              if (cd.mc) pt.mc = cd.mc;
              if (cd.mcc) pt.mc = cd.mcc;
              if (cd.mlc) pt.mlc = cd.mlc;
              if (cd.mlcc) pt.mlc = cd.mlcc;
              if (cd.mlw) pt.mlw = cd.mlw;
              if (cd.mrc) pt.mrc = cd.mrc;
              if (cd.dir) pt.dir = cd.dir;
            }
            pt._distinct = true;
            mockLegend.entries.push([pt]);
          }
          mockLegend.entries.sort(function(a, b) {
            return a[0].trace.index - b[0].trace.index;
          });
          mockLegend.layer = container;
          mockLegend._inHover = true;
          mockLegend._groupTitleFont = hoverlabel.grouptitlefont;
          legendDraw(gd, mockLegend);
          var legendContainer = container.select("g.legend");
          var tbb = getBoundingClientRect(gd, legendContainer.node());
          var tWidth = tbb.width + 2 * HOVERTEXTPAD;
          var tHeight = tbb.height + 2 * HOVERTEXTPAD;
          var winningPoint = groupedHoverData[0];
          var avgX = (winningPoint.x0 + winningPoint.x1) / 2;
          var avgY = (winningPoint.y0 + winningPoint.y1) / 2;
          var pointWon = !(Registry.traceIs(winningPoint.trace, "bar-like") || Registry.traceIs(winningPoint.trace, "box-violin"));
          var lyBottom, lyTop;
          if (axLetter === "y") {
            if (pointWon) {
              lyTop = avgY - HOVERTEXTPAD;
              lyBottom = avgY + HOVERTEXTPAD;
            } else {
              lyTop = Math.min.apply(null, groupedHoverData.map(function(c) {
                return Math.min(c.y0, c.y1);
              }));
              lyBottom = Math.max.apply(null, groupedHoverData.map(function(c) {
                return Math.max(c.y0, c.y1);
              }));
            }
          } else {
            lyTop = lyBottom = Lib.mean(groupedHoverData.map(function(c) {
              return (c.y0 + c.y1) / 2;
            })) - tHeight / 2;
          }
          var lxRight, lxLeft;
          if (axLetter === "x") {
            if (pointWon) {
              lxRight = avgX + HOVERTEXTPAD;
              lxLeft = avgX - HOVERTEXTPAD;
            } else {
              lxRight = Math.max.apply(null, groupedHoverData.map(function(c) {
                return Math.max(c.x0, c.x1);
              }));
              lxLeft = Math.min.apply(null, groupedHoverData.map(function(c) {
                return Math.min(c.x0, c.x1);
              }));
            }
          } else {
            lxRight = lxLeft = Lib.mean(groupedHoverData.map(function(c) {
              return (c.x0 + c.x1) / 2;
            })) - tWidth / 2;
          }
          var xOffset = xa._offset;
          var yOffset = ya._offset;
          lyBottom += yOffset;
          lxRight += xOffset;
          lxLeft += xOffset - tWidth;
          lyTop += yOffset - tHeight;
          var lx, ly;
          if (lxRight + tWidth < outerWidth && lxRight >= 0) {
            lx = lxRight;
          } else if (lxLeft + tWidth < outerWidth && lxLeft >= 0) {
            lx = lxLeft;
          } else if (xOffset + tWidth < outerWidth) {
            lx = xOffset;
          } else {
            if (lxRight - avgX < avgX - lxLeft + tWidth) {
              lx = outerWidth - tWidth;
            } else {
              lx = 0;
            }
          }
          lx += HOVERTEXTPAD;
          if (lyBottom + tHeight < outerHeight && lyBottom >= 0) {
            ly = lyBottom;
          } else if (lyTop + tHeight < outerHeight && lyTop >= 0) {
            ly = lyTop;
          } else if (yOffset + tHeight < outerHeight) {
            ly = yOffset;
          } else {
            if (lyBottom - avgY < avgY - lyTop + tHeight) {
              ly = outerHeight - tHeight;
            } else {
              ly = 0;
            }
          }
          ly += HOVERTEXTPAD;
          legendContainer.attr("transform", strTranslate(lx - 1, ly - 1));
          return legendContainer;
        }
        var hoverLabels = container.selectAll("g.hovertext").data(hoverData, function(d) {
          return hoverDataKey(d);
        });
        hoverLabels.enter().append("g").classed("hovertext", true).each(function() {
          var g = d3.select(this);
          g.append("rect").call(Color.fill, Color.addOpacity(bgColor, 0.8));
          g.append("text").classed("name", true);
          g.append("path").style("stroke-width", "1px");
          g.append("text").classed("nums", true).call(Drawing.font, {
            weight: fontWeight,
            style: fontStyle,
            variant: fontVariant,
            textcase: fontTextcase,
            lineposition: fontLineposition,
            shadow: fontShadow,
            family: fontFamily,
            size: fontSize
          });
        });
        hoverLabels.exit().remove();
        hoverLabels.each(function(d) {
          var g = d3.select(this).attr("transform", "");
          var dColor = d.color;
          if (Array.isArray(dColor)) {
            dColor = dColor[d.eventData[0].pointNumber];
          }
          var color0 = d.bgcolor || dColor;
          var numsColor = Color.combine(
            Color.opacity(color0) ? color0 : Color.defaultLine,
            bgColor
          );
          var nameColor = Color.combine(
            Color.opacity(dColor) ? dColor : Color.defaultLine,
            bgColor
          );
          var contrastColor = d.borderColor || Color.contrast(numsColor);
          var texts2 = getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g);
          var text2 = texts2[0];
          var name2 = texts2[1];
          var tx = g.select("text.nums").call(Drawing.font, {
            family: d.fontFamily || fontFamily,
            size: d.fontSize || fontSize,
            color: d.fontColor || contrastColor,
            weight: d.fontWeight || fontWeight,
            style: d.fontStyle || fontStyle,
            variant: d.fontVariant || fontVariant,
            textcase: d.fontTextcase || fontTextcase,
            lineposition: d.fontLineposition || fontLineposition,
            shadow: d.fontShadow || fontShadow
          }).text(text2).attr("data-notex", 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
          var tx2 = g.select("text.name");
          var tx2width = 0;
          var tx2height = 0;
          if (name2 && name2 !== text2) {
            tx2.call(Drawing.font, {
              family: d.fontFamily || fontFamily,
              size: d.fontSize || fontSize,
              color: nameColor,
              weight: d.fontWeight || fontWeight,
              style: d.fontStyle || fontStyle,
              variant: d.fontVariant || fontVariant,
              textcase: d.fontTextcase || fontTextcase,
              lineposition: d.fontLineposition || fontLineposition,
              shadow: d.fontShadow || fontShadow
            }).text(name2).attr("data-notex", 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);
            var t2bb = getBoundingClientRect(gd, tx2.node());
            tx2width = t2bb.width + 2 * HOVERTEXTPAD;
            tx2height = t2bb.height + 2 * HOVERTEXTPAD;
          } else {
            tx2.remove();
            g.select("rect").remove();
          }
          g.select("path").style({
            fill: numsColor,
            stroke: contrastColor
          });
          var htx = d.xa._offset + (d.x0 + d.x1) / 2;
          var hty = d.ya._offset + (d.y0 + d.y1) / 2;
          var dx = Math.abs(d.x1 - d.x0);
          var dy = Math.abs(d.y1 - d.y0);
          var tbb2 = getBoundingClientRect(gd, tx.node());
          var tbbWidth = tbb2.width / fullLayout._invScaleX;
          var tbbHeight = tbb2.height / fullLayout._invScaleY;
          d.ty0 = (outerTop - tbb2.top) / fullLayout._invScaleY;
          d.bx = tbbWidth + 2 * HOVERTEXTPAD;
          d.by = Math.max(tbbHeight + 2 * HOVERTEXTPAD, tx2height);
          d.anchor = "start";
          d.txwidth = tbbWidth;
          d.tx2width = tx2width;
          d.offset = 0;
          var txTotalWidth = (tbbWidth + HOVERARROWSIZE + HOVERTEXTPAD + tx2width) * fullLayout._invScaleX;
          var anchorStartOK, anchorEndOK;
          if (rotateLabels) {
            d.pos = htx;
            anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;
            anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;
            if ((d.idealAlign === "top" || !anchorStartOK) && anchorEndOK) {
              hty -= dy / 2;
              d.anchor = "end";
            } else if (anchorStartOK) {
              hty += dy / 2;
              d.anchor = "start";
            } else {
              d.anchor = "middle";
            }
            d.crossPos = hty;
          } else {
            d.pos = hty;
            anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;
            anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;
            if ((d.idealAlign === "left" || !anchorStartOK) && anchorEndOK) {
              htx -= dx / 2;
              d.anchor = "end";
            } else if (anchorStartOK) {
              htx += dx / 2;
              d.anchor = "start";
            } else {
              d.anchor = "middle";
              var txHalfWidth = txTotalWidth / 2;
              var overflowR = htx + txHalfWidth - outerWidth;
              var overflowL = htx - txHalfWidth;
              if (overflowR > 0) htx -= overflowR;
              if (overflowL < 0) htx += -overflowL;
            }
            d.crossPos = htx;
          }
          tx.attr("text-anchor", d.anchor);
          if (tx2width) tx2.attr("text-anchor", d.anchor);
          g.attr("transform", strTranslate(htx, hty) + (rotateLabels ? strRotate(YANGLE) : ""));
        });
        return {
          hoverLabels,
          commonLabelBoundingBox: commonLabelRect
        };
      }
      function getHoverLabelText(d, showCommonLabel, hovermode, fullLayout, t0, g) {
        var name = "";
        var text = "";
        if (d.nameOverride !== void 0) d.name = d.nameOverride;
        if (d.name) {
          if (d.trace._meta) {
            d.name = Lib.templateString(d.name, d.trace._meta);
          }
          name = plainText(d.name, d.nameLength);
        }
        var h0 = hovermode.charAt(0);
        var h1 = h0 === "x" ? "y" : "x";
        if (d.zLabel !== void 0) {
          if (d.xLabel !== void 0) text += "x: " + d.xLabel + "<br>";
          if (d.yLabel !== void 0) text += "y: " + d.yLabel + "<br>";
          if (d.trace.type !== "choropleth" && d.trace.type !== "choroplethmapbox" && d.trace.type !== "choroplethmap") {
            text += (text ? "z: " : "") + d.zLabel;
          }
        } else if (showCommonLabel && d[h0 + "Label"] === t0) {
          text = d[h1 + "Label"] || "";
        } else if (d.xLabel === void 0) {
          if (d.yLabel !== void 0 && d.trace.type !== "scattercarpet") {
            text = d.yLabel;
          }
        } else if (d.yLabel === void 0) text = d.xLabel;
        else text = "(" + d.xLabel + ", " + d.yLabel + ")";
        if ((d.text || d.text === 0) && !Array.isArray(d.text)) {
          text += (text ? "<br>" : "") + d.text;
        }
        if (d.extraText !== void 0) text += (text ? "<br>" : "") + d.extraText;
        if (g && text === "" && !d.hovertemplate) {
          if (name === "") g.remove();
          text = name;
        }
        var hovertemplate = d.hovertemplate || false;
        if (hovertemplate) {
          var labels = d.hovertemplateLabels || d;
          if (d[h0 + "Label"] !== t0) {
            labels[h0 + "other"] = labels[h0 + "Val"];
            labels[h0 + "otherLabel"] = labels[h0 + "Label"];
          }
          text = Lib.hovertemplateString(
            hovertemplate,
            labels,
            fullLayout._d3locale,
            d.eventData[0] || {},
            d.trace._meta
          );
          text = text.replace(EXTRA_STRING_REGEX, function(match, extra) {
            name = plainText(extra, d.nameLength);
            return "";
          });
        }
        return [text, name];
      }
      function hoverAvoidOverlaps(hoverLabels, rotateLabels, fullLayout, commonLabelBoundingBox) {
        var axKey = rotateLabels ? "xa" : "ya";
        var crossAxKey = rotateLabels ? "ya" : "xa";
        var nummoves = 0;
        var axSign = 1;
        var nLabels = hoverLabels.size();
        var pointgroups = new Array(nLabels);
        var k = 0;
        var axisLabelMinX = commonLabelBoundingBox.minX;
        var axisLabelMaxX = commonLabelBoundingBox.maxX;
        var axisLabelMinY = commonLabelBoundingBox.minY;
        var axisLabelMaxY = commonLabelBoundingBox.maxY;
        var pX = function(x) {
          return x * fullLayout._invScaleX;
        };
        var pY = function(y) {
          return y * fullLayout._invScaleY;
        };
        hoverLabels.each(function(d) {
          var ax = d[axKey];
          var crossAx = d[crossAxKey];
          var axIsX = ax._id.charAt(0) === "x";
          var rng = ax.range;
          if (k === 0 && rng && rng[0] > rng[1] !== axIsX) {
            axSign = -1;
          }
          var pmin = 0;
          var pmax = axIsX ? fullLayout.width : fullLayout.height;
          if (fullLayout.hovermode === "x" || fullLayout.hovermode === "y") {
            var offsets = getHoverLabelOffsets(d, rotateLabels);
            var anchor = d.anchor;
            var horzSign = anchor === "end" ? -1 : 1;
            var labelMin;
            var labelMax;
            if (anchor === "middle") {
              labelMin = d.crossPos + (axIsX ? pY(offsets.y - d.by / 2) : pX(d.bx / 2 + d.tx2width / 2));
              labelMax = labelMin + (axIsX ? pY(d.by) : pX(d.bx));
            } else {
              if (axIsX) {
                labelMin = d.crossPos + pY(HOVERARROWSIZE + offsets.y) - pY(d.by / 2 - HOVERARROWSIZE);
                labelMax = labelMin + pY(d.by);
              } else {
                var startX = pX(horzSign * HOVERARROWSIZE + offsets.x);
                var endX = startX + pX(horzSign * d.bx);
                labelMin = d.crossPos + Math.min(startX, endX);
                labelMax = d.crossPos + Math.max(startX, endX);
              }
            }
            if (axIsX) {
              if (axisLabelMinY !== void 0 && axisLabelMaxY !== void 0 && Math.min(labelMax, axisLabelMaxY) - Math.max(labelMin, axisLabelMinY) > 1) {
                if (crossAx.side === "left") {
                  pmin = crossAx._mainLinePosition;
                  pmax = fullLayout.width;
                } else {
                  pmax = crossAx._mainLinePosition;
                }
              }
            } else {
              if (axisLabelMinX !== void 0 && axisLabelMaxX !== void 0 && Math.min(labelMax, axisLabelMaxX) - Math.max(labelMin, axisLabelMinX) > 1) {
                if (crossAx.side === "top") {
                  pmin = crossAx._mainLinePosition;
                  pmax = fullLayout.height;
                } else {
                  pmax = crossAx._mainLinePosition;
                }
              }
            }
          }
          pointgroups[k++] = [{
            datum: d,
            traceIndex: d.trace.index,
            dp: 0,
            pos: d.pos,
            posref: d.posref,
            size: d.by * (axIsX ? YFACTOR : 1) / 2,
            pmin,
            pmax
          }];
        });
        pointgroups.sort(function(a, b) {
          return a[0].posref - b[0].posref || // for equal positions, sort trace indices increasing or decreasing
          // depending on whether the axis is reversed or not... so stacked
          // traces will generally keep their order even if one trace adds
          // nothing to the stack.
          axSign * (b[0].traceIndex - a[0].traceIndex);
        });
        var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;
        function constrainGroup(grp2) {
          var minPt = grp2[0];
          var maxPt = grp2[grp2.length - 1];
          topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;
          bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;
          if (topOverlap > 0.01) {
            for (j = grp2.length - 1; j >= 0; j--) grp2[j].dp += topOverlap;
            donepositioning = false;
          }
          if (bottomOverlap < 0.01) return;
          if (topOverlap < -0.01) {
            for (j = grp2.length - 1; j >= 0; j--) grp2[j].dp -= bottomOverlap;
            donepositioning = false;
          }
          if (!donepositioning) return;
          var deleteCount = 0;
          for (i = 0; i < grp2.length; i++) {
            pti = grp2[i];
            if (pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;
          }
          for (i = grp2.length - 1; i >= 0; i--) {
            if (deleteCount <= 0) break;
            pti = grp2[i];
            if (pti.pos > minPt.pmax - 1) {
              pti.del = true;
              deleteCount--;
            }
          }
          for (i = 0; i < grp2.length; i++) {
            if (deleteCount <= 0) break;
            pti = grp2[i];
            if (pti.pos < minPt.pmin + 1) {
              pti.del = true;
              deleteCount--;
              bottomOverlap = pti.size * 2;
              for (j = grp2.length - 1; j >= 0; j--) grp2[j].dp -= bottomOverlap;
            }
          }
          for (i = grp2.length - 1; i >= 0; i--) {
            if (deleteCount <= 0) break;
            pti = grp2[i];
            if (pti.pos + pti.dp + pti.size > minPt.pmax) {
              pti.del = true;
              deleteCount--;
            }
          }
        }
        while (!donepositioning && nummoves <= nLabels) {
          nummoves++;
          donepositioning = true;
          i = 0;
          while (i < pointgroups.length - 1) {
            var g0 = pointgroups[i];
            var g1 = pointgroups[i + 1];
            var p0 = g0[g0.length - 1];
            var p1 = g1[0];
            topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;
            if (topOverlap > 0.01) {
              for (j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap;
              g0.push.apply(g0, g1);
              pointgroups.splice(i + 1, 1);
              sumdp = 0;
              for (j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;
              bottomOverlap = sumdp / g0.length;
              for (j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;
              donepositioning = false;
            } else i++;
          }
          pointgroups.forEach(constrainGroup);
        }
        for (i = pointgroups.length - 1; i >= 0; i--) {
          var grp = pointgroups[i];
          for (j = grp.length - 1; j >= 0; j--) {
            var pt = grp[j];
            var hoverPt = pt.datum;
            hoverPt.offset = pt.dp;
            hoverPt.del = pt.del;
          }
        }
      }
      function getHoverLabelOffsets(hoverLabel, rotateLabels) {
        var offsetX = 0;
        var offsetY = hoverLabel.offset;
        if (rotateLabels) {
          offsetY *= -YSHIFTY;
          offsetX = hoverLabel.offset * YSHIFTX;
        }
        return {
          x: offsetX,
          y: offsetY
        };
      }
      function getTextShiftX(hoverLabel) {
        var alignShift = { start: 1, end: -1, middle: 0 }[hoverLabel.anchor];
        var textShiftX = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);
        var text2ShiftX = textShiftX + alignShift * (hoverLabel.txwidth + HOVERTEXTPAD);
        var isMiddle = hoverLabel.anchor === "middle";
        if (isMiddle) {
          textShiftX -= hoverLabel.tx2width / 2;
          text2ShiftX += hoverLabel.txwidth / 2 + HOVERTEXTPAD;
        }
        return {
          alignShift,
          textShiftX,
          text2ShiftX
        };
      }
      function alignHoverText(hoverLabels, rotateLabels, scaleX, scaleY) {
        var pX = function(x) {
          return x * scaleX;
        };
        var pY = function(y) {
          return y * scaleY;
        };
        hoverLabels.each(function(d) {
          var g = d3.select(this);
          if (d.del) return g.remove();
          var tx = g.select("text.nums");
          var anchor = d.anchor;
          var horzSign = anchor === "end" ? -1 : 1;
          var shiftX = getTextShiftX(d);
          var offsets = getHoverLabelOffsets(d, rotateLabels);
          var offsetX = offsets.x;
          var offsetY = offsets.y;
          var isMiddle = anchor === "middle";
          g.select("path").attr("d", isMiddle ? (
            // middle aligned: rect centered on data
            "M-" + pX(d.bx / 2 + d.tx2width / 2) + "," + pY(offsetY - d.by / 2) + "h" + pX(d.bx) + "v" + pY(d.by) + "h-" + pX(d.bx) + "Z"
          ) : (
            // left or right aligned: side rect with arrow to data
            "M0,0L" + pX(horzSign * HOVERARROWSIZE + offsetX) + "," + pY(HOVERARROWSIZE + offsetY) + "v" + pY(d.by / 2 - HOVERARROWSIZE) + "h" + pX(horzSign * d.bx) + "v-" + pY(d.by) + "H" + pX(horzSign * HOVERARROWSIZE + offsetX) + "V" + pY(offsetY - HOVERARROWSIZE) + "Z"
          ));
          var posX = offsetX + shiftX.textShiftX;
          var posY = offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD;
          var textAlign = d.textAlign || "auto";
          if (textAlign !== "auto") {
            if (textAlign === "left" && anchor !== "start") {
              tx.attr("text-anchor", "start");
              posX = isMiddle ? -d.bx / 2 - d.tx2width / 2 + HOVERTEXTPAD : -d.bx - HOVERTEXTPAD;
            } else if (textAlign === "right" && anchor !== "end") {
              tx.attr("text-anchor", "end");
              posX = isMiddle ? d.bx / 2 - d.tx2width / 2 - HOVERTEXTPAD : d.bx + HOVERTEXTPAD;
            }
          }
          tx.call(svgTextUtils.positionText, pX(posX), pY(posY));
          if (d.tx2width) {
            g.select("text.name").call(
              svgTextUtils.positionText,
              pX(shiftX.text2ShiftX + shiftX.alignShift * HOVERTEXTPAD + offsetX),
              pY(offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD)
            );
            g.select("rect").call(
              Drawing.setRect,
              pX(shiftX.text2ShiftX + (shiftX.alignShift - 1) * d.tx2width / 2 + offsetX),
              pY(offsetY - d.by / 2 - 1),
              pX(d.tx2width),
              pY(d.by + 2)
            );
          }
        });
      }
      function cleanPoint(d, hovermode) {
        var index = d.index;
        var trace = d.trace || {};
        var cd0 = d.cd[0];
        var cd = d.cd[index] || {};
        function pass(v) {
          return v || isNumeric(v) && v === 0;
        }
        var getVal = Array.isArray(index) ? function(calcKey, traceKey) {
          var v = Lib.castOption(cd0, index, calcKey);
          return pass(v) ? v : Lib.extractOption({}, trace, "", traceKey);
        } : function(calcKey, traceKey) {
          return Lib.extractOption(cd, trace, calcKey, traceKey);
        };
        function fill(key, calcKey, traceKey) {
          var val = getVal(calcKey, traceKey);
          if (pass(val)) d[key] = val;
        }
        fill("hoverinfo", "hi", "hoverinfo");
        fill("bgcolor", "hbg", "hoverlabel.bgcolor");
        fill("borderColor", "hbc", "hoverlabel.bordercolor");
        fill("fontFamily", "htf", "hoverlabel.font.family");
        fill("fontSize", "hts", "hoverlabel.font.size");
        fill("fontColor", "htc", "hoverlabel.font.color");
        fill("fontWeight", "htw", "hoverlabel.font.weight");
        fill("fontStyle", "hty", "hoverlabel.font.style");
        fill("fontVariant", "htv", "hoverlabel.font.variant");
        fill("nameLength", "hnl", "hoverlabel.namelength");
        fill("textAlign", "hta", "hoverlabel.align");
        d.posref = hovermode === "y" || hovermode === "closest" && trace.orientation === "h" ? d.xa._offset + (d.x0 + d.x1) / 2 : d.ya._offset + (d.y0 + d.y1) / 2;
        d.x0 = Lib.constrain(d.x0, 0, d.xa._length);
        d.x1 = Lib.constrain(d.x1, 0, d.xa._length);
        d.y0 = Lib.constrain(d.y0, 0, d.ya._length);
        d.y1 = Lib.constrain(d.y1, 0, d.ya._length);
        if (d.xLabelVal !== void 0) {
          d.xLabel = "xLabel" in d ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal, trace.xhoverformat);
          d.xVal = d.xa.c2d(d.xLabelVal);
        }
        if (d.yLabelVal !== void 0) {
          d.yLabel = "yLabel" in d ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal, trace.yhoverformat);
          d.yVal = d.ya.c2d(d.yLabelVal);
        }
        if (d.zLabelVal !== void 0 && d.zLabel === void 0) {
          d.zLabel = String(d.zLabelVal);
        }
        if (!isNaN(d.xerr) && !(d.xa.type === "log" && d.xerr <= 0)) {
          var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), "hover").text;
          if (d.xerrneg !== void 0) {
            d.xLabel += " +" + xeText + " / -" + Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), "hover").text;
          } else d.xLabel += " \xB1 " + xeText;
          if (hovermode === "x") d.distance += 1;
        }
        if (!isNaN(d.yerr) && !(d.ya.type === "log" && d.yerr <= 0)) {
          var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), "hover").text;
          if (d.yerrneg !== void 0) {
            d.yLabel += " +" + yeText + " / -" + Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), "hover").text;
          } else d.yLabel += " \xB1 " + yeText;
          if (hovermode === "y") d.distance += 1;
        }
        var infomode = d.hoverinfo || d.trace.hoverinfo;
        if (infomode && infomode !== "all") {
          infomode = Array.isArray(infomode) ? infomode : infomode.split("+");
          if (infomode.indexOf("x") === -1) d.xLabel = void 0;
          if (infomode.indexOf("y") === -1) d.yLabel = void 0;
          if (infomode.indexOf("z") === -1) d.zLabel = void 0;
          if (infomode.indexOf("text") === -1) d.text = void 0;
          if (infomode.indexOf("name") === -1) d.name = void 0;
        }
        return d;
      }
      function createSpikelines(gd, closestPoints, opts) {
        var container = opts.container;
        var fullLayout = opts.fullLayout;
        var gs = fullLayout._size;
        var evt = opts.event;
        var showY = !!closestPoints.hLinePoint;
        var showX = !!closestPoints.vLinePoint;
        var xa, ya;
        container.selectAll(".spikeline").remove();
        if (!(showX || showY)) return;
        var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);
        if (showY) {
          var hLinePoint = closestPoints.hLinePoint;
          var hLinePointX, hLinePointY;
          xa = hLinePoint && hLinePoint.xa;
          ya = hLinePoint && hLinePoint.ya;
          var ySnap = ya.spikesnap;
          if (ySnap === "cursor") {
            hLinePointX = evt.pointerX;
            hLinePointY = evt.pointerY;
          } else {
            hLinePointX = xa._offset + hLinePoint.x;
            hLinePointY = ya._offset + hLinePoint.y;
          }
          var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : hLinePoint.color;
          var yMode = ya.spikemode;
          var yThickness = ya.spikethickness;
          var yColor = ya.spikecolor || dfltHLineColor;
          var xEdge = Axes.getPxPosition(gd, ya);
          var xBase, xEndSpike;
          if (yMode.indexOf("toaxis") !== -1 || yMode.indexOf("across") !== -1) {
            if (yMode.indexOf("toaxis") !== -1) {
              xBase = xEdge;
              xEndSpike = hLinePointX;
            }
            if (yMode.indexOf("across") !== -1) {
              var xAcross0 = ya._counterDomainMin;
              var xAcross1 = ya._counterDomainMax;
              if (ya.anchor === "free") {
                xAcross0 = Math.min(xAcross0, ya.position);
                xAcross1 = Math.max(xAcross1, ya.position);
              }
              xBase = gs.l + xAcross0 * gs.w;
              xEndSpike = gs.l + xAcross1 * gs.w;
            }
            container.insert("line", ":first-child").attr({
              x1: xBase,
              x2: xEndSpike,
              y1: hLinePointY,
              y2: hLinePointY,
              "stroke-width": yThickness,
              stroke: yColor,
              "stroke-dasharray": Drawing.dashStyle(ya.spikedash, yThickness)
            }).classed("spikeline", true).classed("crisp", true);
            container.insert("line", ":first-child").attr({
              x1: xBase,
              x2: xEndSpike,
              y1: hLinePointY,
              y2: hLinePointY,
              "stroke-width": yThickness + 2,
              stroke: contrastColor
            }).classed("spikeline", true).classed("crisp", true);
          }
          if (yMode.indexOf("marker") !== -1) {
            container.insert("circle", ":first-child").attr({
              cx: xEdge + (ya.side !== "right" ? yThickness : -yThickness),
              cy: hLinePointY,
              r: yThickness,
              fill: yColor
            }).classed("spikeline", true);
          }
        }
        if (showX) {
          var vLinePoint = closestPoints.vLinePoint;
          var vLinePointX, vLinePointY;
          xa = vLinePoint && vLinePoint.xa;
          ya = vLinePoint && vLinePoint.ya;
          var xSnap = xa.spikesnap;
          if (xSnap === "cursor") {
            vLinePointX = evt.pointerX;
            vLinePointY = evt.pointerY;
          } else {
            vLinePointX = xa._offset + vLinePoint.x;
            vLinePointY = ya._offset + vLinePoint.y;
          }
          var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : vLinePoint.color;
          var xMode = xa.spikemode;
          var xThickness = xa.spikethickness;
          var xColor = xa.spikecolor || dfltVLineColor;
          var yEdge = Axes.getPxPosition(gd, xa);
          var yBase, yEndSpike;
          if (xMode.indexOf("toaxis") !== -1 || xMode.indexOf("across") !== -1) {
            if (xMode.indexOf("toaxis") !== -1) {
              yBase = yEdge;
              yEndSpike = vLinePointY;
            }
            if (xMode.indexOf("across") !== -1) {
              var yAcross0 = xa._counterDomainMin;
              var yAcross1 = xa._counterDomainMax;
              if (xa.anchor === "free") {
                yAcross0 = Math.min(yAcross0, xa.position);
                yAcross1 = Math.max(yAcross1, xa.position);
              }
              yBase = gs.t + (1 - yAcross1) * gs.h;
              yEndSpike = gs.t + (1 - yAcross0) * gs.h;
            }
            container.insert("line", ":first-child").attr({
              x1: vLinePointX,
              x2: vLinePointX,
              y1: yBase,
              y2: yEndSpike,
              "stroke-width": xThickness,
              stroke: xColor,
              "stroke-dasharray": Drawing.dashStyle(xa.spikedash, xThickness)
            }).classed("spikeline", true).classed("crisp", true);
            container.insert("line", ":first-child").attr({
              x1: vLinePointX,
              x2: vLinePointX,
              y1: yBase,
              y2: yEndSpike,
              "stroke-width": xThickness + 2,
              stroke: contrastColor
            }).classed("spikeline", true).classed("crisp", true);
          }
          if (xMode.indexOf("marker") !== -1) {
            container.insert("circle", ":first-child").attr({
              cx: vLinePointX,
              cy: yEdge - (xa.side !== "top" ? xThickness : -xThickness),
              r: xThickness,
              fill: xColor
            }).classed("spikeline", true);
          }
        }
      }
      function hoverChanged(gd, evt, oldhoverdata) {
        if (!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;
        for (var i = oldhoverdata.length - 1; i >= 0; i--) {
          var oldPt = oldhoverdata[i];
          var newPt = gd._hoverdata[i];
          if (oldPt.curveNumber !== newPt.curveNumber || String(oldPt.pointNumber) !== String(newPt.pointNumber) || String(oldPt.pointNumbers) !== String(newPt.pointNumbers)) {
            return true;
          }
        }
        return false;
      }
      function spikesChanged(gd, oldspikepoints) {
        if (!oldspikepoints) return true;
        if (oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint || oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint) return true;
        return false;
      }
      function plainText(s, len) {
        return svgTextUtils.plainText(s || "", {
          len,
          allowedTags: ["br", "sub", "sup", "b", "i", "em", "s", "u"]
        });
      }
      function orderRangePoints(hoverData, hovermode) {
        var axLetter = hovermode.charAt(0);
        var first = [];
        var second = [];
        var last = [];
        for (var i = 0; i < hoverData.length; i++) {
          var d = hoverData[i];
          if (Registry.traceIs(d.trace, "bar-like") || Registry.traceIs(d.trace, "box-violin")) {
            last.push(d);
          } else if (d.trace[axLetter + "period"]) {
            second.push(d);
          } else {
            first.push(d);
          }
        }
        return first.concat(second).concat(last);
      }
      function getCoord(axLetter, winningPoint, fullLayout) {
        var ax = winningPoint[axLetter + "a"];
        var val = winningPoint[axLetter + "Val"];
        var cd0 = winningPoint.cd[0];
        if (ax.type === "category" || ax.type === "multicategory") val = ax._categoriesMap[val];
        else if (ax.type === "date") {
          var periodalignment = winningPoint.trace[axLetter + "periodalignment"];
          if (periodalignment) {
            var d = winningPoint.cd[winningPoint.index];
            var start = d[axLetter + "Start"];
            if (start === void 0) start = d[axLetter];
            var end = d[axLetter + "End"];
            if (end === void 0) end = d[axLetter];
            var diff = end - start;
            if (periodalignment === "end") {
              val += diff;
            } else if (periodalignment === "middle") {
              val += diff / 2;
            }
          }
          val = ax.d2c(val);
        }
        if (cd0 && cd0.t && cd0.t.posLetter === ax._id) {
          if (fullLayout.boxmode === "group" || fullLayout.violinmode === "group") {
            val += cd0.t.dPos;
          }
        }
        return val;
      }
      function getTopOffset(gd) {
        return gd.offsetTop + gd.clientTop;
      }
      function getLeftOffset(gd) {
        return gd.offsetLeft + gd.clientLeft;
      }
      function getBoundingClientRect(gd, node) {
        var fullLayout = gd._fullLayout;
        var rect = node.getBoundingClientRect();
        var x0 = rect.left;
        var y0 = rect.top;
        var x1 = x0 + rect.width;
        var y1 = y0 + rect.height;
        var A = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);
        var B = Lib.apply3DTransform(fullLayout._invTransform)(x1, y1);
        var Ax = A[0];
        var Ay = A[1];
        var Bx = B[0];
        var By = B[1];
        return {
          x: Ax,
          y: Ay,
          width: Bx - Ax,
          height: By - Ay,
          top: Math.min(Ay, By),
          left: Math.min(Ax, Bx),
          right: Math.max(Ax, Bx),
          bottom: Math.max(Ay, By)
        };
      }
    }
  });

  // src/components/fx/hoverlabel_defaults.js
  var require_hoverlabel_defaults = __commonJS({
    "src/components/fx/hoverlabel_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var isUnifiedHover = require_helpers2().isUnifiedHover;
      module.exports = function handleHoverLabelDefaults(contIn, contOut, coerce, opts) {
        opts = opts || {};
        var hasLegend = contOut.legend;
        function inheritFontAttr(attr) {
          if (!opts.font[attr]) {
            opts.font[attr] = hasLegend ? contOut.legend.font[attr] : contOut.font[attr];
          }
        }
        if (contOut && isUnifiedHover(contOut.hovermode)) {
          if (!opts.font) opts.font = {};
          inheritFontAttr("size");
          inheritFontAttr("family");
          inheritFontAttr("color");
          inheritFontAttr("weight");
          inheritFontAttr("style");
          inheritFontAttr("variant");
          if (hasLegend) {
            if (!opts.bgcolor) opts.bgcolor = Color.combine(contOut.legend.bgcolor, contOut.paper_bgcolor);
            if (!opts.bordercolor) opts.bordercolor = contOut.legend.bordercolor;
          } else {
            if (!opts.bgcolor) opts.bgcolor = contOut.paper_bgcolor;
          }
        }
        coerce("hoverlabel.bgcolor", opts.bgcolor);
        coerce("hoverlabel.bordercolor", opts.bordercolor);
        coerce("hoverlabel.namelength", opts.namelength);
        Lib.coerceFont(coerce, "hoverlabel.font", opts.font);
        coerce("hoverlabel.align", opts.align);
      };
    }
  });

  // src/components/fx/layout_global_defaults.js
  var require_layout_global_defaults = __commonJS({
    "src/components/fx/layout_global_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleHoverLabelDefaults = require_hoverlabel_defaults();
      var layoutAttributes = require_layout_attributes();
      module.exports = function supplyLayoutGlobalDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        handleHoverLabelDefaults(layoutIn, layoutOut, coerce);
      };
    }
  });

  // src/components/fx/defaults.js
  var require_defaults4 = __commonJS({
    "src/components/fx/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var attributes = require_attributes();
      var handleHoverLabelDefaults = require_hoverlabel_defaults();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var opts = Lib.extendFlat({}, layout.hoverlabel);
        if (traceOut.hovertemplate) opts.namelength = -1;
        handleHoverLabelDefaults(traceIn, traceOut, coerce, opts);
      };
    }
  });

  // src/components/fx/hovermode_defaults.js
  var require_hovermode_defaults = __commonJS({
    "src/components/fx/hovermode_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes();
      module.exports = function handleHoverModeDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          if (layoutOut[attr] !== void 0) return layoutOut[attr];
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        coerce("clickmode");
        coerce("hoversubplots");
        return coerce("hovermode");
      };
    }
  });

  // src/components/fx/layout_defaults.js
  var require_layout_defaults2 = __commonJS({
    "src/components/fx/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes();
      var handleHoverModeDefaults = require_hovermode_defaults();
      var handleHoverLabelDefaults = require_hoverlabel_defaults();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        var hoverMode = handleHoverModeDefaults(layoutIn, layoutOut);
        if (hoverMode) {
          coerce("hoverdistance");
          coerce("spikedistance");
        }
        var dragMode = coerce("dragmode");
        if (dragMode === "select") coerce("selectdirection");
        var hasMapbox = layoutOut._has("mapbox");
        var hasMap = layoutOut._has("map");
        var hasGeo = layoutOut._has("geo");
        var len = layoutOut._basePlotModules.length;
        if (layoutOut.dragmode === "zoom" && ((hasMapbox || hasMap || hasGeo) && len === 1 || (hasMapbox || hasMap) && hasGeo && len === 2)) {
          layoutOut.dragmode = "pan";
        }
        handleHoverLabelDefaults(layoutIn, layoutOut, coerce);
        Lib.coerceFont(coerce, "hoverlabel.grouptitlefont", layoutOut.hoverlabel.font);
      };
    }
  });

  // src/components/fx/calc.js
  var require_calc2 = __commonJS({
    "src/components/fx/calc.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      module.exports = function calc(gd) {
        var calcdata = gd.calcdata;
        var fullLayout = gd._fullLayout;
        function makeCoerceHoverInfo(trace2) {
          return function(val) {
            return Lib.coerceHoverinfo({ hoverinfo: val }, { _module: trace2._module }, fullLayout);
          };
        }
        for (var i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var trace = cd[0].trace;
          if (Registry.traceIs(trace, "pie-like")) continue;
          var fillFn = Registry.traceIs(trace, "2dMap") ? paste : Lib.fillArray;
          fillFn(trace.hoverinfo, cd, "hi", makeCoerceHoverInfo(trace));
          if (trace.hovertemplate) fillFn(trace.hovertemplate, cd, "ht");
          if (!trace.hoverlabel) continue;
          fillFn(trace.hoverlabel.bgcolor, cd, "hbg");
          fillFn(trace.hoverlabel.bordercolor, cd, "hbc");
          fillFn(trace.hoverlabel.font.size, cd, "hts");
          fillFn(trace.hoverlabel.font.color, cd, "htc");
          fillFn(trace.hoverlabel.font.family, cd, "htf");
          fillFn(trace.hoverlabel.font.weight, cd, "htw");
          fillFn(trace.hoverlabel.font.style, cd, "hty");
          fillFn(trace.hoverlabel.font.variant, cd, "htv");
          fillFn(trace.hoverlabel.namelength, cd, "hnl");
          fillFn(trace.hoverlabel.align, cd, "hta");
        }
      };
      function paste(traceAttr, cd, cdAttr, fn) {
        fn = fn || Lib.identity;
        if (Array.isArray(traceAttr)) {
          cd[0][cdAttr] = fn(traceAttr);
        }
      }
    }
  });

  // src/components/fx/click.js
  var require_click = __commonJS({
    "src/components/fx/click.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var hover = require_hover().hover;
      module.exports = function click(gd, evt, subplot) {
        var annotationsDone = Registry.getComponentMethod("annotations", "onClick")(gd, gd._hoverdata);
        if (subplot !== void 0) {
          hover(gd, evt, subplot, true);
        }
        function emitClick() {
          gd.emit("plotly_click", { points: gd._hoverdata, event: evt });
        }
        if (gd._hoverdata && evt && evt.target) {
          if (annotationsDone && annotationsDone.then) {
            annotationsDone.then(emitClick);
          } else emitClick();
          if (evt.stopImmediatePropagation) evt.stopImmediatePropagation();
        }
      };
    }
  });

  // src/components/fx/index.js
  var require_fx = __commonJS({
    "src/components/fx/index.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var dragElement = require_dragelement();
      var helpers = require_helpers2();
      var layoutAttributes = require_layout_attributes();
      var hoverModule = require_hover();
      module.exports = {
        moduleType: "component",
        name: "fx",
        constants: require_constants(),
        schema: {
          layout: layoutAttributes
        },
        attributes: require_attributes(),
        layoutAttributes,
        supplyLayoutGlobalDefaults: require_layout_global_defaults(),
        supplyDefaults: require_defaults4(),
        supplyLayoutDefaults: require_layout_defaults2(),
        calc: require_calc2(),
        getDistanceFunction: helpers.getDistanceFunction,
        getClosest: helpers.getClosest,
        inbox: helpers.inbox,
        quadrature: helpers.quadrature,
        appendArrayPointValue: helpers.appendArrayPointValue,
        castHoverOption,
        castHoverinfo,
        hover: hoverModule.hover,
        unhover: dragElement.unhover,
        loneHover: hoverModule.loneHover,
        loneUnhover,
        click: require_click()
      };
      function loneUnhover(containerOrSelection) {
        var selection = Lib.isD3Selection(containerOrSelection) ? containerOrSelection : d3.select(containerOrSelection);
        selection.selectAll("g.hovertext").remove();
        selection.selectAll(".spikeline").remove();
      }
      function castHoverOption(trace, ptNumber, attr) {
        return Lib.castOption(trace, ptNumber, "hoverlabel." + attr);
      }
      function castHoverinfo(trace, fullLayout, ptNumber) {
        function _coerce(val) {
          return Lib.coerceHoverinfo({ hoverinfo: val }, { _module: trace._module }, fullLayout);
        }
        return Lib.castOption(trace, ptNumber, "hoverinfo", _coerce);
      }
    }
  });

  // src/components/dragelement/helpers.js
  var require_helpers5 = __commonJS({
    "src/components/dragelement/helpers.js"(exports) {
      "use strict";
      exports.selectMode = function(dragmode) {
        return dragmode === "lasso" || dragmode === "select";
      };
      exports.drawMode = function(dragmode) {
        return dragmode === "drawclosedpath" || dragmode === "drawopenpath" || dragmode === "drawline" || dragmode === "drawrect" || dragmode === "drawcircle";
      };
      exports.openMode = function(dragmode) {
        return dragmode === "drawline" || dragmode === "drawopenpath";
      };
      exports.rectMode = function(dragmode) {
        return dragmode === "select" || dragmode === "drawline" || dragmode === "drawrect" || dragmode === "drawcircle";
      };
      exports.freeMode = function(dragmode) {
        return dragmode === "lasso" || dragmode === "drawclosedpath" || dragmode === "drawopenpath";
      };
      exports.selectingOrDrawing = function(dragmode) {
        return exports.freeMode(dragmode) || exports.rectMode(dragmode);
      };
    }
  });

  // src/lib/clear_gl_canvases.js
  var require_clear_gl_canvases = __commonJS({
    "src/lib/clear_gl_canvases.js"(exports, module) {
      "use strict";
      module.exports = function clearGlCanvases(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._glcanvas && fullLayout._glcanvas.size()) {
          fullLayout._glcanvas.each(function(d) {
            if (d.regl) d.regl.clear({ color: true, depth: true });
          });
        }
      };
    }
  });

  // src/fonts/ploticon.js
  var require_ploticon = __commonJS({
    "src/fonts/ploticon.js"(exports, module) {
      "use strict";
      module.exports = {
        undo: {
          width: 857.1,
          height: 1e3,
          path: "m857 350q0-87-34-166t-91-137-137-92-166-34q-96 0-183 41t-147 114q-4 6-4 13t5 11l76 77q6 5 14 5 9-1 13-7 41-53 100-82t126-29q58 0 110 23t92 61 61 91 22 111-22 111-61 91-92 61-110 23q-55 0-105-20t-90-57l77-77q17-16 8-38-10-23-33-23h-250q-15 0-25 11t-11 25v250q0 24 22 33 22 10 39-8l72-72q60 57 137 88t159 31q87 0 166-34t137-92 91-137 34-166z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        home: {
          width: 928.6,
          height: 1e3,
          path: "m786 296v-267q0-15-11-26t-25-10h-214v214h-143v-214h-214q-15 0-25 10t-11 26v267q0 1 0 2t0 2l321 264 321-264q1-1 1-4z m124 39l-34-41q-5-5-12-6h-2q-7 0-12 3l-386 322-386-322q-7-4-13-4-7 2-12 7l-35 41q-4 5-3 13t6 12l401 334q18 15 42 15t43-15l136-114v109q0 8 5 13t13 5h107q8 0 13-5t5-13v-227l122-102q5-5 6-12t-4-13z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        "camera-retro": {
          width: 1e3,
          height: 1e3,
          path: "m518 386q0 8-5 13t-13 5q-37 0-63-27t-26-63q0-8 5-13t13-5 12 5 5 13q0 23 16 38t38 16q8 0 13 5t5 13z m125-73q0-59-42-101t-101-42-101 42-42 101 42 101 101 42 101-42 42-101z m-572-320h858v71h-858v-71z m643 320q0 89-62 152t-152 62-151-62-63-152 63-151 151-63 152 63 62 151z m-571 358h214v72h-214v-72z m-72-107h858v143h-462l-36-71h-360v-72z m929 143v-714q0-30-21-51t-50-21h-858q-29 0-50 21t-21 51v714q0 30 21 51t50 21h858q29 0 50-21t21-51z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        zoombox: {
          width: 1e3,
          height: 1e3,
          path: "m1000-25l-250 251c40 63 63 138 63 218 0 224-182 406-407 406-224 0-406-182-406-406s183-406 407-406c80 0 155 22 218 62l250-250 125 125z m-812 250l0 438 437 0 0-438-437 0z m62 375l313 0 0-312-313 0 0 312z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        pan: {
          width: 1e3,
          height: 1e3,
          path: "m1000 350l-187 188 0-125-250 0 0 250 125 0-188 187-187-187 125 0 0-250-250 0 0 125-188-188 186-187 0 125 252 0 0-250-125 0 187-188 188 188-125 0 0 250 250 0 0-126 187 188z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        zoom_plus: {
          width: 875,
          height: 1e3,
          path: "m1 787l0-875 875 0 0 875-875 0z m687-500l-187 0 0-187-125 0 0 187-188 0 0 125 188 0 0 187 125 0 0-187 187 0 0-125z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        zoom_minus: {
          width: 875,
          height: 1e3,
          path: "m0 788l0-876 875 0 0 876-875 0z m688-500l-500 0 0 125 500 0 0-125z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        autoscale: {
          width: 1e3,
          height: 1e3,
          path: "m250 850l-187 0-63 0 0-62 0-188 63 0 0 188 187 0 0 62z m688 0l-188 0 0-62 188 0 0-188 62 0 0 188 0 62-62 0z m-875-938l0 188-63 0 0-188 0-62 63 0 187 0 0 62-187 0z m875 188l0-188-188 0 0-62 188 0 62 0 0 62 0 188-62 0z m-125 188l-1 0-93-94-156 156 156 156 92-93 2 0 0 250-250 0 0-2 93-92-156-156-156 156 94 92 0 2-250 0 0-250 0 0 93 93 157-156-157-156-93 94 0 0 0-250 250 0 0 0-94 93 156 157 156-157-93-93 0 0 250 0 0 250z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        tooltip_basic: {
          width: 1500,
          height: 1e3,
          path: "m375 725l0 0-375-375 375-374 0-1 1125 0 0 750-1125 0z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        tooltip_compare: {
          width: 1125,
          height: 1e3,
          path: "m187 786l0 2-187-188 188-187 0 0 937 0 0 373-938 0z m0-499l0 1-187-188 188-188 0 0 937 0 0 376-938-1z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        plotlylogo: {
          width: 1542,
          height: 1e3,
          path: "m0-10h182v-140h-182v140z m228 146h183v-286h-183v286z m225 714h182v-1000h-182v1000z m225-285h182v-715h-182v715z m225 142h183v-857h-183v857z m231-428h182v-429h-182v429z m225-291h183v-138h-183v138z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        "z-axis": {
          width: 1e3,
          height: 1e3,
          path: "m833 5l-17 108v41l-130-65 130-66c0 0 0 38 0 39 0-1 36-14 39-25 4-15-6-22-16-30-15-12-39-16-56-20-90-22-187-23-279-23-261 0-341 34-353 59 3 60 228 110 228 110-140-8-351-35-351-116 0-120 293-142 474-142 155 0 477 22 477 142 0 50-74 79-163 96z m-374 94c-58-5-99-21-99-40 0-24 65-43 144-43 79 0 143 19 143 43 0 19-42 34-98 40v216h87l-132 135-133-135h88v-216z m167 515h-136v1c16 16 31 34 46 52l84 109v54h-230v-71h124v-1c-16-17-28-32-44-51l-89-114v-51h245v72z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        "3d_rotate": {
          width: 1e3,
          height: 1e3,
          path: "m922 660c-5 4-9 7-14 11-359 263-580-31-580-31l-102 28 58-400c0 1 1 1 2 2 118 108 351 249 351 249s-62 27-100 42c88 83 222 183 347 122 16-8 30-17 44-27-2 1-4 2-6 4z m36-329c0 0 64 229-88 296-62 27-124 14-175-11 157-78 225-208 249-266 8-19 11-31 11-31 2 5 6 15 11 32-5-13-8-20-8-20z m-775-239c70-31 117-50 198-32-121 80-199 346-199 346l-96-15-58-12c0 0 55-226 155-287z m603 133l-317-139c0 0 4-4 19-14 7-5 24-15 24-15s-177-147-389 4c235-287 536-112 536-112l31-22 100 299-4-1z m-298-153c6-4 14-9 24-15 0 0-17 10-24 15z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        camera: {
          width: 1e3,
          height: 1e3,
          path: "m500 450c-83 0-150-67-150-150 0-83 67-150 150-150 83 0 150 67 150 150 0 83-67 150-150 150z m400 150h-120c-16 0-34 13-39 29l-31 93c-6 15-23 28-40 28h-340c-16 0-34-13-39-28l-31-94c-6-15-23-28-40-28h-120c-55 0-100-45-100-100v-450c0-55 45-100 100-100h800c55 0 100 45 100 100v450c0 55-45 100-100 100z m-400-550c-138 0-250 112-250 250 0 138 112 250 250 250 138 0 250-112 250-250 0-138-112-250-250-250z m365 380c-19 0-35 16-35 35 0 19 16 35 35 35 19 0 35-16 35-35 0-19-16-35-35-35z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        movie: {
          width: 1e3,
          height: 1e3,
          path: "m938 413l-188-125c0 37-17 71-44 94 64 38 107 107 107 187 0 121-98 219-219 219-121 0-219-98-219-219 0-61 25-117 66-156h-115c30 33 49 76 49 125 0 103-84 187-187 187s-188-84-188-187c0-57 26-107 65-141-38-22-65-62-65-109v-250c0-70 56-126 125-126h500c69 0 125 56 125 126l188-126c34 0 62 28 62 63v375c0 35-28 63-62 63z m-750 0c-69 0-125 56-125 125s56 125 125 125 125-56 125-125-56-125-125-125z m406-1c-87 0-157 70-157 157 0 86 70 156 157 156s156-70 156-156-70-157-156-157z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        question: {
          width: 857.1,
          height: 1e3,
          path: "m500 82v107q0 8-5 13t-13 5h-107q-8 0-13-5t-5-13v-107q0-8 5-13t13-5h107q8 0 13 5t5 13z m143 375q0 49-31 91t-77 65-95 23q-136 0-207-119-9-14 4-24l74-55q4-4 10-4 9 0 14 7 30 38 48 51 19 14 48 14 27 0 48-15t21-33q0-21-11-34t-38-25q-35-16-65-48t-29-70v-20q0-8 5-13t13-5h107q8 0 13 5t5 13q0 10 12 27t30 28q18 10 28 16t25 19 25 27 16 34 7 45z m214-107q0-117-57-215t-156-156-215-58-216 58-155 156-58 215 58 215 155 156 216 58 215-58 156-156 57-215z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        disk: {
          width: 857.1,
          height: 1e3,
          path: "m214-7h429v214h-429v-214z m500 0h72v500q0 8-6 21t-11 20l-157 156q-5 6-19 12t-22 5v-232q0-22-15-38t-38-16h-322q-22 0-37 16t-16 38v232h-72v-714h72v232q0 22 16 38t37 16h465q22 0 38-16t15-38v-232z m-214 518v178q0 8-5 13t-13 5h-107q-7 0-13-5t-5-13v-178q0-8 5-13t13-5h107q7 0 13 5t5 13z m357-18v-518q0-22-15-38t-38-16h-750q-23 0-38 16t-16 38v750q0 22 16 38t38 16h517q23 0 50-12t42-26l156-157q16-15 27-42t11-49z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        drawopenpath: {
          width: 70,
          height: 70,
          path: "M33.21,85.65a7.31,7.31,0,0,1-2.59-.48c-8.16-3.11-9.27-19.8-9.88-41.3-.1-3.58-.19-6.68-.35-9-.15-2.1-.67-3.48-1.43-3.79-2.13-.88-7.91,2.32-12,5.86L3,32.38c1.87-1.64,11.55-9.66,18.27-6.9,2.13.87,4.75,3.14,5.17,9,.17,2.43.26,5.59.36,9.25a224.17,224.17,0,0,0,1.5,23.4c1.54,10.76,4,12.22,4.48,12.4.84.32,2.79-.46,5.76-3.59L43,80.07C41.53,81.57,37.68,85.64,33.21,85.65ZM74.81,69a11.34,11.34,0,0,0,6.09-6.72L87.26,44.5,74.72,32,56.9,38.35c-2.37.86-5.57,3.42-6.61,6L38.65,72.14l8.42,8.43ZM55,46.27a7.91,7.91,0,0,1,3.64-3.17l14.8-5.3,8,8L76.11,60.6l-.06.19a6.37,6.37,0,0,1-3,3.43L48.25,74.59,44.62,71Zm16.57,7.82A6.9,6.9,0,1,0,64.64,61,6.91,6.91,0,0,0,71.54,54.09Zm-4.05,0a2.85,2.85,0,1,1-2.85-2.85A2.86,2.86,0,0,1,67.49,54.09Zm-4.13,5.22L60.5,56.45,44.26,72.7l2.86,2.86ZM97.83,35.67,84.14,22l-8.57,8.57L89.26,44.24Zm-13.69-8,8,8-2.85,2.85-8-8Z",
          transform: "matrix(1 0 0 1 -15 -15)"
        },
        drawclosedpath: {
          width: 90,
          height: 90,
          path: "M88.41,21.12a26.56,26.56,0,0,0-36.18,0l-2.07,2-2.07-2a26.57,26.57,0,0,0-36.18,0,23.74,23.74,0,0,0,0,34.8L48,90.12a3.22,3.22,0,0,0,4.42,0l36-34.21a23.73,23.73,0,0,0,0-34.79ZM84,51.24,50.16,83.35,16.35,51.25a17.28,17.28,0,0,1,0-25.47,20,20,0,0,1,27.3,0l4.29,4.07a3.23,3.23,0,0,0,4.44,0l4.29-4.07a20,20,0,0,1,27.3,0,17.27,17.27,0,0,1,0,25.46ZM66.76,47.68h-33v6.91h33ZM53.35,35H46.44V68h6.91Z",
          transform: "matrix(1 0 0 1 -5 -5)"
        },
        lasso: {
          width: 1031,
          height: 1e3,
          path: "m1018 538c-36 207-290 336-568 286-277-48-473-256-436-463 10-57 36-108 76-151-13-66 11-137 68-183 34-28 75-41 114-42l-55-70 0 0c-2-1-3-2-4-3-10-14-8-34 5-45 14-11 34-8 45 4 1 1 2 3 2 5l0 0 113 140c16 11 31 24 45 40 4 3 6 7 8 11 48-3 100 0 151 9 278 48 473 255 436 462z m-624-379c-80 14-149 48-197 96 42 42 109 47 156 9 33-26 47-66 41-105z m-187-74c-19 16-33 37-39 60 50-32 109-55 174-68-42-25-95-24-135 8z m360 75c-34-7-69-9-102-8 8 62-16 128-68 170-73 59-175 54-244-5-9 20-16 40-20 61-28 159 121 317 333 354s407-60 434-217c28-159-121-318-333-355z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        selectbox: {
          width: 1e3,
          height: 1e3,
          path: "m0 850l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-285l0-143 143 0 0 143-143 0z m857 0l0-143 143 0 0 143-143 0z m-857-286l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z m285 0l0-143 143 0 0 143-143 0z m286 0l0-143 143 0 0 143-143 0z",
          transform: "matrix(1 0 0 -1 0 850)"
        },
        drawline: {
          width: 70,
          height: 70,
          path: "M60.64,62.3a11.29,11.29,0,0,0,6.09-6.72l6.35-17.72L60.54,25.31l-17.82,6.4c-2.36.86-5.57,3.41-6.6,6L24.48,65.5l8.42,8.42ZM40.79,39.63a7.89,7.89,0,0,1,3.65-3.17l14.79-5.31,8,8L61.94,54l-.06.19a6.44,6.44,0,0,1-3,3.43L34.07,68l-3.62-3.63Zm16.57,7.81a6.9,6.9,0,1,0-6.89,6.9A6.9,6.9,0,0,0,57.36,47.44Zm-4,0a2.86,2.86,0,1,1-2.85-2.85A2.86,2.86,0,0,1,53.32,47.44Zm-4.13,5.22L46.33,49.8,30.08,66.05l2.86,2.86ZM83.65,29,70,15.34,61.4,23.9,75.09,37.59ZM70,21.06l8,8-2.84,2.85-8-8ZM87,80.49H10.67V87H87Z",
          transform: "matrix(1 0 0 1 -15 -15)"
        },
        drawrect: {
          width: 80,
          height: 80,
          path: "M78,22V79H21V22H78m9-9H12V88H87V13ZM68,46.22H31V54H68ZM53,32H45.22V69H53Z",
          transform: "matrix(1 0 0 1 -10 -10)"
        },
        drawcircle: {
          width: 80,
          height: 80,
          path: "M50,84.72C26.84,84.72,8,69.28,8,50.3S26.84,15.87,50,15.87,92,31.31,92,50.3,73.16,84.72,50,84.72Zm0-60.59c-18.6,0-33.74,11.74-33.74,26.17S31.4,76.46,50,76.46,83.74,64.72,83.74,50.3,68.6,24.13,50,24.13Zm17.15,22h-34v7.11h34Zm-13.8-13H46.24v34h7.11Z",
          transform: "matrix(1 0 0 1 -10 -10)"
        },
        eraseshape: {
          width: 80,
          height: 80,
          path: "M82.77,78H31.85L6,49.57,31.85,21.14H82.77a8.72,8.72,0,0,1,8.65,8.77V69.24A8.72,8.72,0,0,1,82.77,78ZM35.46,69.84H82.77a.57.57,0,0,0,.49-.6V29.91a.57.57,0,0,0-.49-.61H35.46L17,49.57Zm32.68-34.7-24,24,5,5,24-24Zm-19,.53-5,5,24,24,5-5Z",
          transform: "matrix(1 0 0 1 -10 -10)"
        },
        spikeline: {
          width: 1e3,
          height: 1e3,
          path: "M512 409c0-57-46-104-103-104-57 0-104 47-104 104 0 57 47 103 104 103 57 0 103-46 103-103z m-327-39l92 0 0 92-92 0z m-185 0l92 0 0 92-92 0z m370-186l92 0 0 93-92 0z m0-184l92 0 0 92-92 0z",
          transform: "matrix(1.5 0 0 -1.5 0 850)"
        },
        pencil: {
          width: 1792,
          height: 1792,
          path: "M491 1536l91-91-235-235-91 91v107h128v128h107zm523-928q0-22-22-22-10 0-17 7l-542 542q-7 7-7 17 0 22 22 22 10 0 17-7l542-542q7-7 7-17zm-54-192l416 416-832 832h-416v-416zm683 96q0 53-37 90l-166 166-416-416 166-165q36-38 90-38 53 0 91 38l235 234q37 39 37 91z",
          transform: "matrix(1 0 0 1 0 1)"
        },
        newplotlylogo: {
          name: "newplotlylogo",
          svg: [
            "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 132 132'>",
            " <title>plotly-logomark</title>",
            " <g id='symbol'>",
            "  <rect fill='#000' x='0' y='0' width='132' height='132' rx='18' ry='18'/>",
            "  <circle fill='#9EF' cx='102' cy='30' r='6'/>",
            "  <circle fill='#BAC' cx='78' cy='30' r='6'/>",
            "  <circle fill='#BAC' cx='78' cy='54' r='6'/>",
            "  <circle fill='#D69' cx='54' cy='30' r='6'/>",
            "  <circle fill='#F26' cx='30' cy='30' r='6'/>",
            "  <circle fill='#F26' cx='30' cy='54' r='6'/>",
            "  <path fill='#FFF' d='M30,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,30,72Z'/>",
            "  <path fill='#FFF' d='M78,72a6,6,0,0,0-6,6v24a6,6,0,0,0,12,0V78A6,6,0,0,0,78,72Z'/>",
            "  <path fill='#FFF' d='M54,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,54,48Z'/>",
            "  <path fill='#FFF' d='M102,48a6,6,0,0,0-6,6v48a6,6,0,0,0,12,0V54A6,6,0,0,0,102,48Z'/>",
            " </g>",
            "</svg>"
          ].join("")
        }
      };
    }
  });

  // src/components/shapes/draw_newshape/constants.js
  var require_constants4 = __commonJS({
    "src/components/shapes/draw_newshape/constants.js"(exports, module) {
      "use strict";
      var CIRCLE_SIDES = 32;
      module.exports = {
        CIRCLE_SIDES,
        i000: 0,
        i090: CIRCLE_SIDES / 4,
        i180: CIRCLE_SIDES / 2,
        i270: CIRCLE_SIDES / 4 * 3,
        cos45: Math.cos(Math.PI / 4),
        sin45: Math.sin(Math.PI / 4),
        SQRT2: Math.sqrt(2)
      };
    }
  });

  // src/components/selections/helpers.js
  var require_helpers6 = __commonJS({
    "src/components/selections/helpers.js"(exports, module) {
      "use strict";
      var strTranslate = require_lib().strTranslate;
      function p2r(ax, v) {
        switch (ax.type) {
          case "log":
            return ax.p2d(v);
          case "date":
            return ax.p2r(v, 0, ax.calendar);
          default:
            return ax.p2r(v);
        }
      }
      function r2p(ax, v) {
        switch (ax.type) {
          case "log":
            return ax.d2p(v);
          case "date":
            return ax.r2p(v, 0, ax.calendar);
          default:
            return ax.r2p(v);
        }
      }
      function axValue(ax) {
        var index = ax._id.charAt(0) === "y" ? 1 : 0;
        return function(v) {
          return p2r(ax, v[index]);
        };
      }
      function getTransform(plotinfo) {
        return strTranslate(
          plotinfo.xaxis._offset,
          plotinfo.yaxis._offset
        );
      }
      module.exports = {
        p2r,
        r2p,
        axValue,
        getTransform
      };
    }
  });

  // src/components/shapes/draw_newshape/helpers.js
  var require_helpers7 = __commonJS({
    "src/components/shapes/draw_newshape/helpers.js"(exports) {
      "use strict";
      var parseSvgPath = require_parse_svg_path();
      var constants = require_constants4();
      var CIRCLE_SIDES = constants.CIRCLE_SIDES;
      var SQRT2 = constants.SQRT2;
      var cartesianHelpers = require_helpers6();
      var p2r = cartesianHelpers.p2r;
      var r2p = cartesianHelpers.r2p;
      var iC = [0, 3, 4, 5, 6, 1, 2];
      var iQS = [0, 3, 4, 1, 2];
      exports.writePaths = function(polygons) {
        var nI = polygons.length;
        if (!nI) return "M0,0Z";
        var str = "";
        for (var i = 0; i < nI; i++) {
          var nJ = polygons[i].length;
          for (var j = 0; j < nJ; j++) {
            var w = polygons[i][j][0];
            if (w === "Z") {
              str += "Z";
            } else {
              var nK = polygons[i][j].length;
              for (var k = 0; k < nK; k++) {
                var realK = k;
                if (w === "Q" || w === "S") {
                  realK = iQS[k];
                } else if (w === "C") {
                  realK = iC[k];
                }
                str += polygons[i][j][realK];
                if (k > 0 && k < nK - 1) {
                  str += ",";
                }
              }
            }
          }
        }
        return str;
      };
      exports.readPaths = function(str, gd, plotinfo, isActiveShape) {
        var cmd = parseSvgPath(str);
        var polys = [];
        var n = -1;
        var newPoly = function() {
          n++;
          polys[n] = [];
        };
        var k;
        var x = 0;
        var y = 0;
        var initX;
        var initY;
        var recStart = function() {
          initX = x;
          initY = y;
        };
        recStart();
        for (var i = 0; i < cmd.length; i++) {
          var newPos = [];
          var x1, x2, y1, y2;
          var c = cmd[i][0];
          var w = c;
          switch (c) {
            case "M":
              newPoly();
              x = +cmd[i][1];
              y = +cmd[i][2];
              newPos.push([w, x, y]);
              recStart();
              break;
            case "Q":
            case "S":
              x1 = +cmd[i][1];
              y1 = +cmd[i][2];
              x = +cmd[i][3];
              y = +cmd[i][4];
              newPos.push([w, x, y, x1, y1]);
              break;
            case "C":
              x1 = +cmd[i][1];
              y1 = +cmd[i][2];
              x2 = +cmd[i][3];
              y2 = +cmd[i][4];
              x = +cmd[i][5];
              y = +cmd[i][6];
              newPos.push([w, x, y, x1, y1, x2, y2]);
              break;
            case "T":
            case "L":
              x = +cmd[i][1];
              y = +cmd[i][2];
              newPos.push([w, x, y]);
              break;
            case "H":
              w = "L";
              x = +cmd[i][1];
              newPos.push([w, x, y]);
              break;
            case "V":
              w = "L";
              y = +cmd[i][1];
              newPos.push([w, x, y]);
              break;
            case "A":
              w = "L";
              var rx = +cmd[i][1];
              var ry = +cmd[i][2];
              if (!+cmd[i][4]) {
                rx = -rx;
                ry = -ry;
              }
              var cenX = x - rx;
              var cenY = y;
              for (k = 1; k <= CIRCLE_SIDES / 2; k++) {
                var t = 2 * Math.PI * k / CIRCLE_SIDES;
                newPos.push([
                  w,
                  cenX + rx * Math.cos(t),
                  cenY + ry * Math.sin(t)
                ]);
              }
              break;
            case "Z":
              if (x !== initX || y !== initY) {
                x = initX;
                y = initY;
                newPos.push([w, x, y]);
              }
              break;
          }
          var domain = (plotinfo || {}).domain;
          var size = gd._fullLayout._size;
          var xPixelSized = plotinfo && plotinfo.xsizemode === "pixel";
          var yPixelSized = plotinfo && plotinfo.ysizemode === "pixel";
          var noOffset = isActiveShape === false;
          for (var j = 0; j < newPos.length; j++) {
            for (k = 0; k + 2 < 7; k += 2) {
              var _x = newPos[j][k + 1];
              var _y = newPos[j][k + 2];
              if (_x === void 0 || _y === void 0) continue;
              x = _x;
              y = _y;
              if (plotinfo) {
                if (plotinfo.xaxis && plotinfo.xaxis.p2r) {
                  if (noOffset) _x -= plotinfo.xaxis._offset;
                  if (xPixelSized) {
                    _x = r2p(plotinfo.xaxis, plotinfo.xanchor) + _x;
                  } else {
                    _x = p2r(plotinfo.xaxis, _x);
                  }
                } else {
                  if (noOffset) _x -= size.l;
                  if (domain) _x = domain.x[0] + _x / size.w;
                  else _x = _x / size.w;
                }
                if (plotinfo.yaxis && plotinfo.yaxis.p2r) {
                  if (noOffset) _y -= plotinfo.yaxis._offset;
                  if (yPixelSized) {
                    _y = r2p(plotinfo.yaxis, plotinfo.yanchor) - _y;
                  } else {
                    _y = p2r(plotinfo.yaxis, _y);
                  }
                } else {
                  if (noOffset) _y -= size.t;
                  if (domain) _y = domain.y[1] - _y / size.h;
                  else _y = 1 - _y / size.h;
                }
              }
              newPos[j][k + 1] = _x;
              newPos[j][k + 2] = _y;
            }
            polys[n].push(
              newPos[j].slice()
            );
          }
        }
        return polys;
      };
      function almostEq(a, b) {
        return Math.abs(a - b) <= 1e-6;
      }
      function dist(a, b) {
        var dx = b[1] - a[1];
        var dy = b[2] - a[2];
        return Math.sqrt(
          dx * dx + dy * dy
        );
      }
      exports.pointsOnRectangle = function(cell) {
        var len = cell.length;
        if (len !== 5) return false;
        for (var j = 1; j < 3; j++) {
          var e01 = cell[0][j] - cell[1][j];
          var e32 = cell[3][j] - cell[2][j];
          if (!almostEq(e01, e32)) return false;
          var e03 = cell[0][j] - cell[3][j];
          var e12 = cell[1][j] - cell[2][j];
          if (!almostEq(e03, e12)) return false;
        }
        if (!almostEq(cell[0][1], cell[1][1]) && !almostEq(cell[0][1], cell[3][1])) return false;
        return !!(dist(cell[0], cell[1]) * dist(cell[0], cell[3]));
      };
      exports.pointsOnEllipse = function(cell) {
        var len = cell.length;
        if (len !== CIRCLE_SIDES + 1) return false;
        len = CIRCLE_SIDES;
        for (var i = 0; i < len; i++) {
          var k = (len * 2 - i) % len;
          var k2 = (len / 2 + k) % len;
          var i2 = (len / 2 + i) % len;
          if (!almostEq(
            dist(cell[i], cell[i2]),
            dist(cell[k], cell[k2])
          )) return false;
        }
        return true;
      };
      exports.handleEllipse = function(isEllipse, start, end) {
        if (!isEllipse) return [start, end];
        var pos = exports.ellipseOver({
          x0: start[0],
          y0: start[1],
          x1: end[0],
          y1: end[1]
        });
        var cx = (pos.x1 + pos.x0) / 2;
        var cy = (pos.y1 + pos.y0) / 2;
        var rx = (pos.x1 - pos.x0) / 2;
        var ry = (pos.y1 - pos.y0) / 2;
        if (!rx) rx = ry = ry / SQRT2;
        if (!ry) ry = rx = rx / SQRT2;
        var cell = [];
        for (var i = 0; i < CIRCLE_SIDES; i++) {
          var t = i * 2 * Math.PI / CIRCLE_SIDES;
          cell.push([
            cx + rx * Math.cos(t),
            cy + ry * Math.sin(t)
          ]);
        }
        return cell;
      };
      exports.ellipseOver = function(pos) {
        var x0 = pos.x0;
        var y0 = pos.y0;
        var x1 = pos.x1;
        var y1 = pos.y1;
        var dx = x1 - x0;
        var dy = y1 - y0;
        x0 -= dx;
        y0 -= dy;
        var cx = (x0 + x1) / 2;
        var cy = (y0 + y1) / 2;
        var scale = SQRT2;
        dx *= scale;
        dy *= scale;
        return {
          x0: cx - dx,
          y0: cy - dy,
          x1: cx + dx,
          y1: cy + dy
        };
      };
      exports.fixDatesForPaths = function(polygons, xaxis, yaxis) {
        var xIsDate = xaxis.type === "date";
        var yIsDate = yaxis.type === "date";
        if (!xIsDate && !yIsDate) return polygons;
        for (var i = 0; i < polygons.length; i++) {
          for (var j = 0; j < polygons[i].length; j++) {
            for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {
              if (xIsDate) polygons[i][j][k + 1] = polygons[i][j][k + 1].replace(" ", "_");
              if (yIsDate) polygons[i][j][k + 2] = polygons[i][j][k + 2].replace(" ", "_");
            }
          }
        }
        return polygons;
      };
    }
  });

  // src/components/shapes/draw_newshape/newshapes.js
  var require_newshapes = __commonJS({
    "src/components/shapes/draw_newshape/newshapes.js"(exports, module) {
      "use strict";
      var dragHelpers = require_helpers5();
      var drawMode = dragHelpers.drawMode;
      var openMode = dragHelpers.openMode;
      var constants = require_constants4();
      var i000 = constants.i000;
      var i090 = constants.i090;
      var i180 = constants.i180;
      var i270 = constants.i270;
      var cos45 = constants.cos45;
      var sin45 = constants.sin45;
      var cartesianHelpers = require_helpers6();
      var p2r = cartesianHelpers.p2r;
      var r2p = cartesianHelpers.r2p;
      var handleOutline = require_handle_outline();
      var clearOutline = handleOutline.clearOutline;
      var helpers = require_helpers7();
      var readPaths = helpers.readPaths;
      var writePaths = helpers.writePaths;
      var ellipseOver = helpers.ellipseOver;
      var fixDatesForPaths = helpers.fixDatesForPaths;
      function newShapes(outlines, dragOptions) {
        if (!outlines.length) return;
        var e = outlines[0][0];
        if (!e) return;
        var gd = dragOptions.gd;
        var isActiveShape = dragOptions.isActiveShape;
        var dragmode = dragOptions.dragmode;
        var shapes = (gd.layout || {}).shapes || [];
        if (!drawMode(dragmode) && isActiveShape !== void 0) {
          var id = gd._fullLayout._activeShapeIndex;
          if (id < shapes.length) {
            switch (gd._fullLayout.shapes[id].type) {
              case "rect":
                dragmode = "drawrect";
                break;
              case "circle":
                dragmode = "drawcircle";
                break;
              case "line":
                dragmode = "drawline";
                break;
              case "path":
                var path = shapes[id].path || "";
                if (path[path.length - 1] === "Z") {
                  dragmode = "drawclosedpath";
                } else {
                  dragmode = "drawopenpath";
                }
                break;
            }
          }
        }
        var newShape = createShapeObj(outlines, dragOptions, dragmode);
        clearOutline(gd);
        var editHelpers = dragOptions.editHelpers;
        var modifyItem = (editHelpers || {}).modifyItem;
        var allShapes = [];
        for (var q = 0; q < shapes.length; q++) {
          var beforeEdit = gd._fullLayout.shapes[q];
          allShapes[q] = beforeEdit._input;
          if (isActiveShape !== void 0 && q === gd._fullLayout._activeShapeIndex) {
            var afterEdit = newShape;
            switch (beforeEdit.type) {
              case "line":
              case "rect":
              case "circle":
                modifyItem("x0", afterEdit.x0 - (beforeEdit.x0shift || 0));
                modifyItem("x1", afterEdit.x1 - (beforeEdit.x1shift || 0));
                modifyItem("y0", afterEdit.y0 - (beforeEdit.y0shift || 0));
                modifyItem("y1", afterEdit.y1 - (beforeEdit.y1shift || 0));
                break;
              case "path":
                modifyItem("path", afterEdit.path);
                break;
            }
          }
        }
        if (isActiveShape === void 0) {
          allShapes.push(newShape);
          return allShapes;
        }
        return editHelpers ? editHelpers.getUpdateObj() : {};
      }
      function createShapeObj(outlines, dragOptions, dragmode) {
        var e = outlines[0][0];
        var gd = dragOptions.gd;
        var d = e.getAttribute("d");
        var newStyle = gd._fullLayout.newshape;
        var plotinfo = dragOptions.plotinfo;
        var isActiveShape = dragOptions.isActiveShape;
        var xaxis = plotinfo.xaxis;
        var yaxis = plotinfo.yaxis;
        var xPaper = !!plotinfo.domain || !plotinfo.xaxis;
        var yPaper = !!plotinfo.domain || !plotinfo.yaxis;
        var isOpenMode = openMode(dragmode);
        var polygons = readPaths(d, gd, plotinfo, isActiveShape);
        var newShape = {
          editable: true,
          visible: newStyle.visible,
          name: newStyle.name,
          showlegend: newStyle.showlegend,
          legend: newStyle.legend,
          legendwidth: newStyle.legendwidth,
          legendgroup: newStyle.legendgroup,
          legendgrouptitle: {
            text: newStyle.legendgrouptitle.text,
            font: newStyle.legendgrouptitle.font
          },
          legendrank: newStyle.legendrank,
          label: newStyle.label,
          xref: xPaper ? "paper" : xaxis._id,
          yref: yPaper ? "paper" : yaxis._id,
          layer: newStyle.layer,
          opacity: newStyle.opacity,
          line: {
            color: newStyle.line.color,
            width: newStyle.line.width,
            dash: newStyle.line.dash
          }
        };
        if (!isOpenMode) {
          newShape.fillcolor = newStyle.fillcolor;
          newShape.fillrule = newStyle.fillrule;
        }
        var cell;
        if (polygons.length === 1) cell = polygons[0];
        if (cell && cell.length === 5 && // ensure we only have 4 corners for a rect
        dragmode === "drawrect") {
          newShape.type = "rect";
          newShape.x0 = cell[0][1];
          newShape.y0 = cell[0][2];
          newShape.x1 = cell[2][1];
          newShape.y1 = cell[2][2];
        } else if (cell && dragmode === "drawline") {
          newShape.type = "line";
          newShape.x0 = cell[0][1];
          newShape.y0 = cell[0][2];
          newShape.x1 = cell[1][1];
          newShape.y1 = cell[1][2];
        } else if (cell && dragmode === "drawcircle") {
          newShape.type = "circle";
          var xA = cell[i000][1];
          var xB = cell[i090][1];
          var xC = cell[i180][1];
          var xD = cell[i270][1];
          var yA = cell[i000][2];
          var yB = cell[i090][2];
          var yC = cell[i180][2];
          var yD = cell[i270][2];
          var xDateOrLog = plotinfo.xaxis && (plotinfo.xaxis.type === "date" || plotinfo.xaxis.type === "log");
          var yDateOrLog = plotinfo.yaxis && (plotinfo.yaxis.type === "date" || plotinfo.yaxis.type === "log");
          if (xDateOrLog) {
            xA = r2p(plotinfo.xaxis, xA);
            xB = r2p(plotinfo.xaxis, xB);
            xC = r2p(plotinfo.xaxis, xC);
            xD = r2p(plotinfo.xaxis, xD);
          }
          if (yDateOrLog) {
            yA = r2p(plotinfo.yaxis, yA);
            yB = r2p(plotinfo.yaxis, yB);
            yC = r2p(plotinfo.yaxis, yC);
            yD = r2p(plotinfo.yaxis, yD);
          }
          var x0 = (xB + xD) / 2;
          var y0 = (yA + yC) / 2;
          var rx = (xD - xB + xC - xA) / 2;
          var ry = (yD - yB + yC - yA) / 2;
          var pos = ellipseOver({
            x0,
            y0,
            x1: x0 + rx * cos45,
            y1: y0 + ry * sin45
          });
          if (xDateOrLog) {
            pos.x0 = p2r(plotinfo.xaxis, pos.x0);
            pos.x1 = p2r(plotinfo.xaxis, pos.x1);
          }
          if (yDateOrLog) {
            pos.y0 = p2r(plotinfo.yaxis, pos.y0);
            pos.y1 = p2r(plotinfo.yaxis, pos.y1);
          }
          newShape.x0 = pos.x0;
          newShape.y0 = pos.y0;
          newShape.x1 = pos.x1;
          newShape.y1 = pos.y1;
        } else {
          newShape.type = "path";
          if (xaxis && yaxis) fixDatesForPaths(polygons, xaxis, yaxis);
          newShape.path = writePaths(polygons);
          cell = null;
        }
        return newShape;
      }
      module.exports = {
        newShapes,
        createShapeObj
      };
    }
  });

  // src/components/selections/draw_newselection/newselections.js
  var require_newselections = __commonJS({
    "src/components/selections/draw_newselection/newselections.js"(exports, module) {
      "use strict";
      var dragHelpers = require_helpers5();
      var selectMode = dragHelpers.selectMode;
      var handleOutline = require_handle_outline();
      var clearOutline = handleOutline.clearOutline;
      var helpers = require_helpers7();
      var readPaths = helpers.readPaths;
      var writePaths = helpers.writePaths;
      var fixDatesForPaths = helpers.fixDatesForPaths;
      module.exports = function newSelections(outlines, dragOptions) {
        if (!outlines.length) return;
        var e = outlines[0][0];
        if (!e) return;
        var d = e.getAttribute("d");
        var gd = dragOptions.gd;
        var newStyle = gd._fullLayout.newselection;
        var plotinfo = dragOptions.plotinfo;
        var xaxis = plotinfo.xaxis;
        var yaxis = plotinfo.yaxis;
        var isActiveSelection = dragOptions.isActiveSelection;
        var dragmode = dragOptions.dragmode;
        var selections = (gd.layout || {}).selections || [];
        if (!selectMode(dragmode) && isActiveSelection !== void 0) {
          var id = gd._fullLayout._activeSelectionIndex;
          if (id < selections.length) {
            switch (gd._fullLayout.selections[id].type) {
              case "rect":
                dragmode = "select";
                break;
              case "path":
                dragmode = "lasso";
                break;
            }
          }
        }
        var polygons = readPaths(d, gd, plotinfo, isActiveSelection);
        var newSelection = {
          xref: xaxis._id,
          yref: yaxis._id,
          opacity: newStyle.opacity,
          line: {
            color: newStyle.line.color,
            width: newStyle.line.width,
            dash: newStyle.line.dash
          }
        };
        var cell;
        if (polygons.length === 1) cell = polygons[0];
        if (cell && cell.length === 5 && // ensure we only have 4 corners for a rect
        dragmode === "select") {
          newSelection.type = "rect";
          newSelection.x0 = cell[0][1];
          newSelection.y0 = cell[0][2];
          newSelection.x1 = cell[2][1];
          newSelection.y1 = cell[2][2];
        } else {
          newSelection.type = "path";
          if (xaxis && yaxis) fixDatesForPaths(polygons, xaxis, yaxis);
          newSelection.path = writePaths(polygons);
          cell = null;
        }
        clearOutline(gd);
        var editHelpers = dragOptions.editHelpers;
        var modifyItem = (editHelpers || {}).modifyItem;
        var allSelections = [];
        for (var q = 0; q < selections.length; q++) {
          var beforeEdit = gd._fullLayout.selections[q];
          if (!beforeEdit) {
            allSelections[q] = beforeEdit;
            continue;
          }
          allSelections[q] = beforeEdit._input;
          if (isActiveSelection !== void 0 && q === gd._fullLayout._activeSelectionIndex) {
            var afterEdit = newSelection;
            switch (beforeEdit.type) {
              case "rect":
                modifyItem("x0", afterEdit.x0);
                modifyItem("x1", afterEdit.x1);
                modifyItem("y0", afterEdit.y0);
                modifyItem("y1", afterEdit.y1);
                break;
              case "path":
                modifyItem("path", afterEdit.path);
                break;
            }
          }
        }
        if (isActiveSelection === void 0) {
          allSelections.push(newSelection);
          return allSelections;
        }
        return editHelpers ? editHelpers.getUpdateObj() : {};
      };
    }
  });

  // src/components/shapes/constants.js
  var require_constants5 = __commonJS({
    "src/components/shapes/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        segmentRE: /[MLHVQCTSZ][^MLHVQCTSZ]*/g,
        paramRE: /[^\s,]+/g,
        // which numbers in each path segment are x (or y) values
        // drawn is which param is a drawn point, as opposed to a
        // control point (which doesn't count toward autorange.
        // TODO: this means curved paths could extend beyond the
        // autorange bounds. This is a bit tricky to get right
        // unless we revert to bounding boxes, but perhaps there's
        // a calculation we could do...)
        paramIsX: {
          M: { 0: true, drawn: 0 },
          L: { 0: true, drawn: 0 },
          H: { 0: true, drawn: 0 },
          V: {},
          Q: { 0: true, 2: true, drawn: 2 },
          C: { 0: true, 2: true, 4: true, drawn: 4 },
          T: { 0: true, drawn: 0 },
          S: { 0: true, 2: true, drawn: 2 },
          // A: {0: true, 5: true},
          Z: {}
        },
        paramIsY: {
          M: { 1: true, drawn: 1 },
          L: { 1: true, drawn: 1 },
          H: {},
          V: { 0: true, drawn: 0 },
          Q: { 1: true, 3: true, drawn: 3 },
          C: { 1: true, 3: true, 5: true, drawn: 5 },
          T: { 1: true, drawn: 1 },
          S: { 1: true, 3: true, drawn: 5 },
          // A: {1: true, 6: true},
          Z: {}
        },
        numParams: {
          M: 2,
          L: 2,
          H: 1,
          V: 1,
          Q: 4,
          C: 6,
          T: 2,
          S: 4,
          // A: 7,
          Z: 0
        }
      };
    }
  });

  // src/components/shapes/helpers.js
  var require_helpers8 = __commonJS({
    "src/components/shapes/helpers.js"(exports) {
      "use strict";
      var constants = require_constants5();
      var Lib = require_lib();
      var Axes = require_axes();
      exports.rangeToShapePosition = function(ax) {
        return ax.type === "log" ? ax.r2d : function(v) {
          return v;
        };
      };
      exports.shapePositionToRange = function(ax) {
        return ax.type === "log" ? ax.d2r : function(v) {
          return v;
        };
      };
      exports.decodeDate = function(convertToPx) {
        return function(v) {
          if (v.replace) v = v.replace("_", " ");
          return convertToPx(v);
        };
      };
      exports.encodeDate = function(convertToDate) {
        return function(v) {
          return convertToDate(v).replace(" ", "_");
        };
      };
      exports.extractPathCoords = function(path, paramsToUse, isRaw) {
        var extractedCoordinates = [];
        var segments = path.match(constants.segmentRE);
        segments.forEach(function(segment) {
          var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;
          if (relevantParamIdx === void 0) return;
          var params = segment.substr(1).match(constants.paramRE);
          if (!params || params.length < relevantParamIdx) return;
          var str = params[relevantParamIdx];
          var pos = isRaw ? str : Lib.cleanNumber(str);
          extractedCoordinates.push(pos);
        });
        return extractedCoordinates;
      };
      exports.getDataToPixel = function(gd, axis, shift, isVertical, refType) {
        var gs = gd._fullLayout._size;
        var dataToPixel;
        if (axis) {
          if (refType === "domain") {
            dataToPixel = function(v) {
              return axis._length * (isVertical ? 1 - v : v) + axis._offset;
            };
          } else {
            var d2r = exports.shapePositionToRange(axis);
            dataToPixel = function(v) {
              var shiftPixels = getPixelShift(axis, shift);
              return axis._offset + axis.r2p(d2r(v, true)) + shiftPixels;
            };
            if (axis.type === "date") dataToPixel = exports.decodeDate(dataToPixel);
          }
        } else if (isVertical) {
          dataToPixel = function(v) {
            return gs.t + gs.h * (1 - v);
          };
        } else {
          dataToPixel = function(v) {
            return gs.l + gs.w * v;
          };
        }
        return dataToPixel;
      };
      exports.getPixelToData = function(gd, axis, isVertical, opt) {
        var gs = gd._fullLayout._size;
        var pixelToData;
        if (axis) {
          if (opt === "domain") {
            pixelToData = function(p) {
              var q = (p - axis._offset) / axis._length;
              return isVertical ? 1 - q : q;
            };
          } else {
            var r2d = exports.rangeToShapePosition(axis);
            pixelToData = function(p) {
              return r2d(axis.p2r(p - axis._offset));
            };
          }
        } else if (isVertical) {
          pixelToData = function(p) {
            return 1 - (p - gs.t) / gs.h;
          };
        } else {
          pixelToData = function(p) {
            return (p - gs.l) / gs.w;
          };
        }
        return pixelToData;
      };
      exports.roundPositionForSharpStrokeRendering = function(pos, strokeWidth) {
        var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;
        var posValAsInt = Math.round(pos);
        return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;
      };
      exports.makeShapesOptionsAndPlotinfo = function(gd, index) {
        var options = gd._fullLayout.shapes[index] || {};
        var plotinfo = gd._fullLayout._plots[options.xref + options.yref];
        var hasPlotinfo = !!plotinfo;
        if (hasPlotinfo) {
          plotinfo._hadPlotinfo = true;
        } else {
          plotinfo = {};
          if (options.xref && options.xref !== "paper") plotinfo.xaxis = gd._fullLayout[options.xref + "axis"];
          if (options.yref && options.yref !== "paper") plotinfo.yaxis = gd._fullLayout[options.yref + "axis"];
        }
        plotinfo.xsizemode = options.xsizemode;
        plotinfo.ysizemode = options.ysizemode;
        plotinfo.xanchor = options.xanchor;
        plotinfo.yanchor = options.yanchor;
        return {
          options,
          plotinfo
        };
      };
      exports.makeSelectionsOptionsAndPlotinfo = function(gd, index) {
        var options = gd._fullLayout.selections[index] || {};
        var plotinfo = gd._fullLayout._plots[options.xref + options.yref];
        var hasPlotinfo = !!plotinfo;
        if (hasPlotinfo) {
          plotinfo._hadPlotinfo = true;
        } else {
          plotinfo = {};
          if (options.xref) plotinfo.xaxis = gd._fullLayout[options.xref + "axis"];
          if (options.yref) plotinfo.yaxis = gd._fullLayout[options.yref + "axis"];
        }
        return {
          options,
          plotinfo
        };
      };
      exports.getPathString = function(gd, options) {
        var type = options.type;
        var xRefType = Axes.getRefType(options.xref);
        var yRefType = Axes.getRefType(options.yref);
        var xa = Axes.getFromId(gd, options.xref);
        var ya = Axes.getFromId(gd, options.yref);
        var gs = gd._fullLayout._size;
        var x2r, x2p, y2r, y2p;
        var xShiftStart = getPixelShift(xa, options.x0shift);
        var xShiftEnd = getPixelShift(xa, options.x1shift);
        var yShiftStart = getPixelShift(ya, options.y0shift);
        var yShiftEnd = getPixelShift(ya, options.y1shift);
        var x0, x1, y0, y1;
        if (xa) {
          if (xRefType === "domain") {
            x2p = function(v) {
              return xa._offset + xa._length * v;
            };
          } else {
            x2r = exports.shapePositionToRange(xa);
            x2p = function(v) {
              return xa._offset + xa.r2p(x2r(v, true));
            };
          }
        } else {
          x2p = function(v) {
            return gs.l + gs.w * v;
          };
        }
        if (ya) {
          if (yRefType === "domain") {
            y2p = function(v) {
              return ya._offset + ya._length * (1 - v);
            };
          } else {
            y2r = exports.shapePositionToRange(ya);
            y2p = function(v) {
              return ya._offset + ya.r2p(y2r(v, true));
            };
          }
        } else {
          y2p = function(v) {
            return gs.t + gs.h * (1 - v);
          };
        }
        if (type === "path") {
          if (xa && xa.type === "date") x2p = exports.decodeDate(x2p);
          if (ya && ya.type === "date") y2p = exports.decodeDate(y2p);
          return convertPath(options, x2p, y2p);
        }
        if (options.xsizemode === "pixel") {
          var xAnchorPos = x2p(options.xanchor);
          x0 = xAnchorPos + options.x0 + xShiftStart;
          x1 = xAnchorPos + options.x1 + xShiftEnd;
        } else {
          x0 = x2p(options.x0) + xShiftStart;
          x1 = x2p(options.x1) + xShiftEnd;
        }
        if (options.ysizemode === "pixel") {
          var yAnchorPos = y2p(options.yanchor);
          y0 = yAnchorPos - options.y0 + yShiftStart;
          y1 = yAnchorPos - options.y1 + yShiftEnd;
        } else {
          y0 = y2p(options.y0) + yShiftStart;
          y1 = y2p(options.y1) + yShiftEnd;
        }
        if (type === "line") return "M" + x0 + "," + y0 + "L" + x1 + "," + y1;
        if (type === "rect") return "M" + x0 + "," + y0 + "H" + x1 + "V" + y1 + "H" + x0 + "Z";
        var cx = (x0 + x1) / 2;
        var cy = (y0 + y1) / 2;
        var rx = Math.abs(cx - x0);
        var ry = Math.abs(cy - y0);
        var rArc = "A" + rx + "," + ry;
        var rightPt = cx + rx + "," + cy;
        var topPt = cx + "," + (cy - ry);
        return "M" + rightPt + rArc + " 0 1,1 " + topPt + rArc + " 0 0,1 " + rightPt + "Z";
      };
      function convertPath(options, x2p, y2p) {
        var pathIn = options.path;
        var xSizemode = options.xsizemode;
        var ySizemode = options.ysizemode;
        var xAnchor = options.xanchor;
        var yAnchor = options.yanchor;
        return pathIn.replace(constants.segmentRE, function(segment) {
          var paramNumber = 0;
          var segmentType = segment.charAt(0);
          var xParams = constants.paramIsX[segmentType];
          var yParams = constants.paramIsY[segmentType];
          var nParams = constants.numParams[segmentType];
          var paramString = segment.substr(1).replace(constants.paramRE, function(param) {
            if (xParams[paramNumber]) {
              if (xSizemode === "pixel") param = x2p(xAnchor) + Number(param);
              else param = x2p(param);
            } else if (yParams[paramNumber]) {
              if (ySizemode === "pixel") param = y2p(yAnchor) - Number(param);
              else param = y2p(param);
            }
            paramNumber++;
            if (paramNumber > nParams) param = "X";
            return param;
          });
          if (paramNumber > nParams) {
            paramString = paramString.replace(/[\s,]*X.*/, "");
            Lib.log("Ignoring extra params in segment " + segment);
          }
          return segmentType + paramString;
        });
      }
      function getPixelShift(axis, shift) {
        shift = shift || 0;
        var shiftPixels = 0;
        if (shift && axis && (axis.type === "category" || axis.type === "multicategory")) {
          shiftPixels = (axis.r2p(1) - axis.r2p(0)) * shift;
        }
        return shiftPixels;
      }
    }
  });

  // src/components/shapes/display_labels.js
  var require_display_labels = __commonJS({
    "src/components/shapes/display_labels.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var svgTextUtils = require_svg_text_utils();
      var Drawing = require_drawing();
      var readPaths = require_helpers7().readPaths;
      var helpers = require_helpers8();
      var getPathString = helpers.getPathString;
      var shapeLabelTexttemplateVars = require_label_texttemplate();
      var FROM_TL = require_alignment().FROM_TL;
      module.exports = function drawLabel(gd, index, options, shapeGroup) {
        shapeGroup.selectAll(".shape-label").remove();
        if (!(options.label.text || options.label.texttemplate)) return;
        var text;
        if (options.label.texttemplate) {
          var templateValues = {};
          if (options.type !== "path") {
            var _xa = Axes.getFromId(gd, options.xref);
            var _ya = Axes.getFromId(gd, options.yref);
            for (var key in shapeLabelTexttemplateVars) {
              var val = shapeLabelTexttemplateVars[key](options, _xa, _ya);
              if (val !== void 0) templateValues[key] = val;
            }
          }
          text = Lib.texttemplateStringForShapes(
            options.label.texttemplate,
            {},
            gd._fullLayout._d3locale,
            templateValues
          );
        } else {
          text = options.label.text;
        }
        var labelGroupAttrs = {
          "data-index": index
        };
        var font = options.label.font;
        var labelTextAttrs = {
          "data-notex": 1
        };
        var labelGroup = shapeGroup.append("g").attr(labelGroupAttrs).classed("shape-label", true);
        var labelText = labelGroup.append("text").attr(labelTextAttrs).classed("shape-label-text", true).text(text);
        var shapex0, shapex1, shapey0, shapey1;
        if (options.path) {
          var d = getPathString(gd, options);
          var polygons = readPaths(d, gd);
          shapex0 = Infinity;
          shapey0 = Infinity;
          shapex1 = -Infinity;
          shapey1 = -Infinity;
          for (var i = 0; i < polygons.length; i++) {
            for (var j = 0; j < polygons[i].length; j++) {
              var p = polygons[i][j];
              for (var k = 1; k < p.length; k += 2) {
                var _x = p[k];
                var _y = p[k + 1];
                shapex0 = Math.min(shapex0, _x);
                shapex1 = Math.max(shapex1, _x);
                shapey0 = Math.min(shapey0, _y);
                shapey1 = Math.max(shapey1, _y);
              }
            }
          }
        } else {
          var xa = Axes.getFromId(gd, options.xref);
          var xShiftStart = options.x0shift;
          var xShiftEnd = options.x1shift;
          var xRefType = Axes.getRefType(options.xref);
          var ya = Axes.getFromId(gd, options.yref);
          var yShiftStart = options.y0shift;
          var yShiftEnd = options.y1shift;
          var yRefType = Axes.getRefType(options.yref);
          var x2p = function(v, shift) {
            var dataToPixel = helpers.getDataToPixel(gd, xa, shift, false, xRefType);
            return dataToPixel(v);
          };
          var y2p = function(v, shift) {
            var dataToPixel = helpers.getDataToPixel(gd, ya, shift, true, yRefType);
            return dataToPixel(v);
          };
          shapex0 = x2p(options.x0, xShiftStart);
          shapex1 = x2p(options.x1, xShiftEnd);
          shapey0 = y2p(options.y0, yShiftStart);
          shapey1 = y2p(options.y1, yShiftEnd);
        }
        var textangle = options.label.textangle;
        if (textangle === "auto") {
          if (options.type === "line") {
            textangle = calcTextAngle(shapex0, shapey0, shapex1, shapey1);
          } else {
            textangle = 0;
          }
        }
        labelText.call(function(s) {
          s.call(Drawing.font, font).attr({});
          svgTextUtils.convertToTspans(s, gd);
          return s;
        });
        var textBB = Drawing.bBox(labelText.node());
        var textPos = calcTextPosition(shapex0, shapey0, shapex1, shapey1, options, textangle, textBB);
        var textx = textPos.textx;
        var texty = textPos.texty;
        var xanchor = textPos.xanchor;
        labelText.attr({
          "text-anchor": {
            left: "start",
            center: "middle",
            right: "end"
          }[xanchor],
          y: texty,
          x: textx,
          transform: "rotate(" + textangle + "," + textx + "," + texty + ")"
        }).call(svgTextUtils.positionText, textx, texty);
      };
      function calcTextAngle(shapex0, shapey0, shapex1, shapey1) {
        var dy, dx;
        dx = Math.abs(shapex1 - shapex0);
        if (shapex1 >= shapex0) {
          dy = shapey0 - shapey1;
        } else {
          dy = shapey1 - shapey0;
        }
        return -180 / Math.PI * Math.atan2(dy, dx);
      }
      function calcTextPosition(shapex0, shapey0, shapex1, shapey1, shapeOptions, actualTextAngle, textBB) {
        var textPosition = shapeOptions.label.textposition;
        var textAngle = shapeOptions.label.textangle;
        var textPadding = shapeOptions.label.padding;
        var shapeType = shapeOptions.type;
        var textAngleRad = Math.PI / 180 * actualTextAngle;
        var sinA = Math.sin(textAngleRad);
        var cosA = Math.cos(textAngleRad);
        var xanchor = shapeOptions.label.xanchor;
        var yanchor = shapeOptions.label.yanchor;
        var textx, texty, paddingX, paddingY;
        if (shapeType === "line") {
          if (textPosition === "start") {
            textx = shapex0;
            texty = shapey0;
          } else if (textPosition === "end") {
            textx = shapex1;
            texty = shapey1;
          } else {
            textx = (shapex0 + shapex1) / 2;
            texty = (shapey0 + shapey1) / 2;
          }
          if (xanchor === "auto") {
            if (textPosition === "start") {
              if (textAngle === "auto") {
                if (shapex1 > shapex0) xanchor = "left";
                else if (shapex1 < shapex0) xanchor = "right";
                else xanchor = "center";
              } else {
                if (shapex1 > shapex0) xanchor = "right";
                else if (shapex1 < shapex0) xanchor = "left";
                else xanchor = "center";
              }
            } else if (textPosition === "end") {
              if (textAngle === "auto") {
                if (shapex1 > shapex0) xanchor = "right";
                else if (shapex1 < shapex0) xanchor = "left";
                else xanchor = "center";
              } else {
                if (shapex1 > shapex0) xanchor = "left";
                else if (shapex1 < shapex0) xanchor = "right";
                else xanchor = "center";
              }
            } else {
              xanchor = "center";
            }
          }
          var paddingConstantsX = { left: 1, center: 0, right: -1 };
          var paddingConstantsY = { bottom: -1, middle: 0, top: 1 };
          if (textAngle === "auto") {
            var paddingDirection = paddingConstantsY[yanchor];
            paddingX = -textPadding * sinA * paddingDirection;
            paddingY = textPadding * cosA * paddingDirection;
          } else {
            var paddingDirectionX = paddingConstantsX[xanchor];
            var paddingDirectionY = paddingConstantsY[yanchor];
            paddingX = textPadding * paddingDirectionX;
            paddingY = textPadding * paddingDirectionY;
          }
          textx = textx + paddingX;
          texty = texty + paddingY;
        } else {
          paddingX = textPadding + 3;
          if (textPosition.indexOf("right") !== -1) {
            textx = Math.max(shapex0, shapex1) - paddingX;
            if (xanchor === "auto") xanchor = "right";
          } else if (textPosition.indexOf("left") !== -1) {
            textx = Math.min(shapex0, shapex1) + paddingX;
            if (xanchor === "auto") xanchor = "left";
          } else {
            textx = (shapex0 + shapex1) / 2;
            if (xanchor === "auto") xanchor = "center";
          }
          if (textPosition.indexOf("top") !== -1) {
            texty = Math.min(shapey0, shapey1);
          } else if (textPosition.indexOf("bottom") !== -1) {
            texty = Math.max(shapey0, shapey1);
          } else {
            texty = (shapey0 + shapey1) / 2;
          }
          paddingY = textPadding;
          if (yanchor === "bottom") {
            texty = texty - paddingY;
          } else if (yanchor === "top") {
            texty = texty + paddingY;
          }
        }
        var shiftFraction = FROM_TL[yanchor];
        var baselineAdjust = shapeOptions.label.font.size;
        var textHeight = textBB.height;
        var xshift = (textHeight * shiftFraction - baselineAdjust) * sinA;
        var yshift = -(textHeight * shiftFraction - baselineAdjust) * cosA;
        return { textx: textx + xshift, texty: texty + yshift, xanchor };
      }
    }
  });

  // src/components/shapes/display_outlines.js
  var require_display_outlines = __commonJS({
    "src/components/shapes/display_outlines.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var dragElement = require_dragelement();
      var dragHelpers = require_helpers5();
      var drawMode = dragHelpers.drawMode;
      var selectMode = dragHelpers.selectMode;
      var Registry = require_registry();
      var Color = require_color();
      var constants = require_constants4();
      var i000 = constants.i000;
      var i090 = constants.i090;
      var i180 = constants.i180;
      var i270 = constants.i270;
      var handleOutline = require_handle_outline();
      var clearOutlineControllers = handleOutline.clearOutlineControllers;
      var helpers = require_helpers7();
      var pointsOnRectangle = helpers.pointsOnRectangle;
      var pointsOnEllipse = helpers.pointsOnEllipse;
      var writePaths = helpers.writePaths;
      var newShapes = require_newshapes().newShapes;
      var createShapeObj = require_newshapes().createShapeObj;
      var newSelections = require_newselections();
      var drawLabel = require_display_labels();
      module.exports = function displayOutlines(polygons, outlines, dragOptions, nCalls) {
        if (!nCalls) nCalls = 0;
        var gd = dragOptions.gd;
        function redraw() {
          displayOutlines(polygons, outlines, dragOptions, nCalls++);
          if (pointsOnEllipse(polygons[0]) || dragOptions.hasText) {
            update({ redrawing: true });
          }
        }
        function update(opts) {
          var updateObject = {};
          if (dragOptions.isActiveShape !== void 0) {
            dragOptions.isActiveShape = false;
            updateObject = newShapes(outlines, dragOptions);
          }
          if (dragOptions.isActiveSelection !== void 0) {
            dragOptions.isActiveSelection = false;
            updateObject = newSelections(outlines, dragOptions);
            gd._fullLayout._reselect = true;
          }
          if (Object.keys(updateObject).length) {
            Registry.call((opts || {}).redrawing ? "relayout" : "_guiRelayout", gd, updateObject);
          }
        }
        var fullLayout = gd._fullLayout;
        var zoomLayer = fullLayout._zoomlayer;
        var dragmode = dragOptions.dragmode;
        var isDrawMode = drawMode(dragmode);
        var isSelectMode = selectMode(dragmode);
        if (isDrawMode || isSelectMode) {
          gd._fullLayout._outlining = true;
        }
        clearOutlineControllers(gd);
        outlines.attr("d", writePaths(polygons));
        var vertexDragOptions;
        var groupDragOptions;
        var indexI;
        var indexJ;
        var copyPolygons;
        if (!nCalls && (dragOptions.isActiveShape || dragOptions.isActiveSelection)) {
          copyPolygons = recordPositions([], polygons);
          var g = zoomLayer.append("g").attr("class", "outline-controllers");
          addVertexControllers(g);
          addGroupControllers();
        }
        if (isDrawMode && dragOptions.hasText) {
          var shapeGroup = zoomLayer.select(".label-temp");
          var shapeOptions = createShapeObj(outlines, dragOptions, dragOptions.dragmode);
          drawLabel(gd, "label-temp", shapeOptions, shapeGroup);
        }
        function startDragVertex(evt) {
          indexI = +evt.srcElement.getAttribute("data-i");
          indexJ = +evt.srcElement.getAttribute("data-j");
          vertexDragOptions[indexI][indexJ].moveFn = moveVertexController;
        }
        function moveVertexController(dx, dy) {
          if (!polygons.length) return;
          var x0 = copyPolygons[indexI][indexJ][1];
          var y0 = copyPolygons[indexI][indexJ][2];
          var cell = polygons[indexI];
          var len = cell.length;
          if (pointsOnRectangle(cell)) {
            var _dx = dx;
            var _dy = dy;
            if (dragOptions.isActiveSelection) {
              var nextPoint = getNextPoint(cell, indexJ);
              if (nextPoint[1] === cell[indexJ][1]) {
                _dy = 0;
              } else {
                _dx = 0;
              }
            }
            for (var q = 0; q < len; q++) {
              if (q === indexJ) continue;
              var pos = cell[q];
              if (pos[1] === cell[indexJ][1]) {
                pos[1] = x0 + _dx;
              }
              if (pos[2] === cell[indexJ][2]) {
                pos[2] = y0 + _dy;
              }
            }
            cell[indexJ][1] = x0 + _dx;
            cell[indexJ][2] = y0 + _dy;
            if (!pointsOnRectangle(cell)) {
              for (var j = 0; j < len; j++) {
                for (var k = 0; k < cell[j].length; k++) {
                  cell[j][k] = copyPolygons[indexI][j][k];
                }
              }
            }
          } else {
            cell[indexJ][1] = x0 + dx;
            cell[indexJ][2] = y0 + dy;
          }
          redraw();
        }
        function endDragVertexController() {
          update();
        }
        function removeVertex() {
          if (!polygons.length) return;
          if (!polygons[indexI]) return;
          if (!polygons[indexI].length) return;
          var newPolygon = [];
          for (var j = 0; j < polygons[indexI].length; j++) {
            if (j !== indexJ) {
              newPolygon.push(
                polygons[indexI][j]
              );
            }
          }
          if (newPolygon.length > 1 && !(newPolygon.length === 2 && newPolygon[1][0] === "Z")) {
            if (indexJ === 0) {
              newPolygon[0][0] = "M";
            }
            polygons[indexI] = newPolygon;
            redraw();
            update();
          }
        }
        function clickVertexController(numClicks, evt) {
          if (numClicks === 2) {
            indexI = +evt.srcElement.getAttribute("data-i");
            indexJ = +evt.srcElement.getAttribute("data-j");
            var cell = polygons[indexI];
            if (!pointsOnRectangle(cell) && !pointsOnEllipse(cell)) {
              removeVertex();
            }
          }
        }
        function addVertexControllers(g2) {
          vertexDragOptions = [];
          for (var i = 0; i < polygons.length; i++) {
            var cell = polygons[i];
            var onRect = pointsOnRectangle(cell);
            var onEllipse = !onRect && pointsOnEllipse(cell);
            vertexDragOptions[i] = [];
            var len = cell.length;
            for (var j = 0; j < len; j++) {
              if (cell[j][0] === "Z") continue;
              if (onEllipse && j !== i000 && j !== i090 && j !== i180 && j !== i270) {
                continue;
              }
              var rectSelection = onRect && dragOptions.isActiveSelection;
              var nextPoint;
              if (rectSelection) nextPoint = getNextPoint(cell, j);
              var x = cell[j][1];
              var y = cell[j][2];
              var vertex = g2.append(rectSelection ? "rect" : "circle").attr("data-i", i).attr("data-j", j).style({
                fill: Color.background,
                stroke: Color.defaultLine,
                "stroke-width": 1,
                "shape-rendering": "crispEdges"
              });
              if (rectSelection) {
                var dx = nextPoint[1] - x;
                var dy = nextPoint[2] - y;
                var width = dy ? 5 : Math.max(Math.min(25, Math.abs(dx) - 5), 5);
                var height = dx ? 5 : Math.max(Math.min(25, Math.abs(dy) - 5), 5);
                vertex.classed(dy ? "cursor-ew-resize" : "cursor-ns-resize", true).attr("width", width).attr("height", height).attr("x", x - width / 2).attr("y", y - height / 2).attr("transform", strTranslate(dx / 2, dy / 2));
              } else {
                vertex.classed("cursor-grab", true).attr("r", 5).attr("cx", x).attr("cy", y);
              }
              vertexDragOptions[i][j] = {
                element: vertex.node(),
                gd,
                prepFn: startDragVertex,
                doneFn: endDragVertexController,
                clickFn: clickVertexController
              };
              dragElement.init(vertexDragOptions[i][j]);
            }
          }
        }
        function moveGroup(dx, dy) {
          if (!polygons.length) return;
          for (var i = 0; i < polygons.length; i++) {
            for (var j = 0; j < polygons[i].length; j++) {
              for (var k = 0; k + 2 < polygons[i][j].length; k += 2) {
                polygons[i][j][k + 1] = copyPolygons[i][j][k + 1] + dx;
                polygons[i][j][k + 2] = copyPolygons[i][j][k + 2] + dy;
              }
            }
          }
        }
        function moveGroupController(dx, dy) {
          moveGroup(dx, dy);
          redraw();
        }
        function startDragGroupController(evt) {
          indexI = +evt.srcElement.getAttribute("data-i");
          if (!indexI) indexI = 0;
          groupDragOptions[indexI].moveFn = moveGroupController;
        }
        function endDragGroupController() {
          update();
        }
        function clickGroupController(numClicks) {
          if (numClicks === 2) {
            eraseActiveSelection(gd);
          }
        }
        function addGroupControllers() {
          groupDragOptions = [];
          if (!polygons.length) return;
          var i = 0;
          groupDragOptions[i] = {
            element: outlines[0][0],
            gd,
            prepFn: startDragGroupController,
            doneFn: endDragGroupController,
            clickFn: clickGroupController
          };
          dragElement.init(groupDragOptions[i]);
        }
      };
      function recordPositions(polygonsOut, polygonsIn) {
        for (var i = 0; i < polygonsIn.length; i++) {
          var cell = polygonsIn[i];
          polygonsOut[i] = [];
          for (var j = 0; j < cell.length; j++) {
            polygonsOut[i][j] = [];
            for (var k = 0; k < cell[j].length; k++) {
              polygonsOut[i][j][k] = cell[j][k];
            }
          }
        }
        return polygonsOut;
      }
      function getNextPoint(cell, j) {
        var x = cell[j][1];
        var y = cell[j][2];
        var len = cell.length;
        var nextJ, nextX, nextY;
        nextJ = (j + 1) % len;
        nextX = cell[nextJ][1];
        nextY = cell[nextJ][2];
        if (nextX === x && nextY === y) {
          nextJ = (j + 2) % len;
          nextX = cell[nextJ][1];
          nextY = cell[nextJ][2];
        }
        return [nextJ, nextX, nextY];
      }
      function eraseActiveSelection(gd) {
        if (!selectMode(gd._fullLayout.dragmode)) return;
        clearOutlineControllers(gd);
        var id = gd._fullLayout._activeSelectionIndex;
        var selections = (gd.layout || {}).selections || [];
        if (id < selections.length) {
          var list = [];
          for (var q = 0; q < selections.length; q++) {
            if (q !== id) {
              list.push(selections[q]);
            }
          }
          delete gd._fullLayout._activeSelectionIndex;
          var erasedSelection = gd._fullLayout.selections[id];
          gd._fullLayout._deselect = {
            xref: erasedSelection.xref,
            yref: erasedSelection.yref
          };
          Registry.call("_guiRelayout", gd, {
            selections: list
          });
        }
      }
    }
  });

  // src/components/shapes/draw.js
  var require_draw2 = __commonJS({
    "src/components/shapes/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var Axes = require_axes();
      var readPaths = require_helpers7().readPaths;
      var displayOutlines = require_display_outlines();
      var drawLabel = require_display_labels();
      var clearOutlineControllers = require_handle_outline().clearOutlineControllers;
      var Color = require_color();
      var Drawing = require_drawing();
      var arrayEditor = require_plot_template().arrayEditor;
      var dragElement = require_dragelement();
      var setCursor = require_setcursor();
      var constants = require_constants5();
      var helpers = require_helpers8();
      var getPathString = helpers.getPathString;
      module.exports = {
        draw,
        drawOne,
        eraseActiveShape,
        drawLabel
      };
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        fullLayout._shapeUpperLayer.selectAll("path").remove();
        fullLayout._shapeLowerLayer.selectAll("path").remove();
        fullLayout._shapeUpperLayer.selectAll("text").remove();
        fullLayout._shapeLowerLayer.selectAll("text").remove();
        for (var k in fullLayout._plots) {
          var shapelayer = fullLayout._plots[k].shapelayer;
          if (shapelayer) {
            shapelayer.selectAll("path").remove();
            shapelayer.selectAll("text").remove();
          }
        }
        for (var i = 0; i < fullLayout.shapes.length; i++) {
          if (fullLayout.shapes[i].visible === true) {
            drawOne(gd, i);
          }
        }
      }
      function shouldSkipEdits(gd) {
        return !!gd._fullLayout._outlining;
      }
      function couldHaveActiveShape(gd) {
        return !gd._context.edits.shapePosition;
      }
      function drawOne(gd, index) {
        gd._fullLayout._paperdiv.selectAll('.shapelayer [data-index="' + index + '"]').remove();
        var o = helpers.makeShapesOptionsAndPlotinfo(gd, index);
        var options = o.options;
        var plotinfo = o.plotinfo;
        if (!options._input || options.visible !== true) return;
        if (options.layer === "above") {
          drawShape(gd._fullLayout._shapeUpperLayer);
        } else if (options.xref === "paper" || options.yref === "paper") {
          drawShape(gd._fullLayout._shapeLowerLayer);
        } else if (options.layer === "between") {
          drawShape(plotinfo.shapelayerBetween);
        } else {
          if (plotinfo._hadPlotinfo) {
            var mainPlot = plotinfo.mainplotinfo || plotinfo;
            drawShape(mainPlot.shapelayer);
          } else {
            drawShape(gd._fullLayout._shapeLowerLayer);
          }
        }
        function drawShape(shapeLayer) {
          var d = getPathString(gd, options);
          var attrs = {
            "data-index": index,
            "fill-rule": options.fillrule,
            d
          };
          var opacity = options.opacity;
          var fillColor = options.fillcolor;
          var lineColor = options.line.width ? options.line.color : "rgba(0,0,0,0)";
          var lineWidth = options.line.width;
          var lineDash = options.line.dash;
          if (!lineWidth && options.editable === true) {
            lineWidth = 5;
            lineDash = "solid";
          }
          var isOpen = d[d.length - 1] !== "Z";
          var isActiveShape = couldHaveActiveShape(gd) && options.editable && gd._fullLayout._activeShapeIndex === index;
          if (isActiveShape) {
            fillColor = isOpen ? "rgba(0,0,0,0)" : gd._fullLayout.activeshape.fillcolor;
            opacity = gd._fullLayout.activeshape.opacity;
          }
          var shapeGroup = shapeLayer.append("g").classed("shape-group", true).attr({ "data-index": index });
          var path = shapeGroup.append("path").attr(attrs).style("opacity", opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor).call(Drawing.dashLine, lineDash, lineWidth);
          setClipPath(shapeGroup, gd, options);
          drawLabel(gd, index, options, shapeGroup);
          var editHelpers;
          if (isActiveShape || gd._context.edits.shapePosition) editHelpers = arrayEditor(gd.layout, "shapes", options);
          if (isActiveShape) {
            path.style({
              cursor: "move"
            });
            var dragOptions = {
              element: path.node(),
              plotinfo,
              gd,
              editHelpers,
              hasText: options.label.text || options.label.texttemplate,
              isActiveShape: true
              // i.e. to enable controllers
            };
            var polygons = readPaths(d, gd);
            displayOutlines(polygons, path, dragOptions);
          } else {
            if (gd._context.edits.shapePosition) {
              setupDragElement(gd, path, options, index, shapeLayer, editHelpers);
            } else if (options.editable === true) {
              path.style(
                "pointer-events",
                isOpen || Color.opacity(fillColor) * opacity <= 0.5 ? "stroke" : "all"
              );
            }
          }
          path.node().addEventListener("click", function() {
            return activateShape(gd, path);
          });
        }
      }
      function setClipPath(shapePath, gd, shapeOptions) {
        var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, "").replace(/[xyz][1-9]* *domain/g, "");
        Drawing.setClipUrl(
          shapePath,
          clipAxes ? "clip" + gd._fullLayout._uid + clipAxes : null,
          gd
        );
      }
      function setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer, editHelpers) {
        var MINWIDTH = 10;
        var MINHEIGHT = 10;
        var xPixelSized = shapeOptions.xsizemode === "pixel";
        var yPixelSized = shapeOptions.ysizemode === "pixel";
        var isLine = shapeOptions.type === "line";
        var isPath = shapeOptions.type === "path";
        var modifyItem = editHelpers.modifyItem;
        var x0, y0, x1, y1, xAnchor, yAnchor;
        var n0, s0, w0, e0, optN, optS, optW, optE;
        var pathIn;
        var shapeGroup = d3.select(shapePath.node().parentNode);
        var xa = Axes.getFromId(gd, shapeOptions.xref);
        var xRefType = Axes.getRefType(shapeOptions.xref);
        var ya = Axes.getFromId(gd, shapeOptions.yref);
        var yRefType = Axes.getRefType(shapeOptions.yref);
        var shiftXStart = shapeOptions.x0shift;
        var shiftXEnd = shapeOptions.x1shift;
        var shiftYStart = shapeOptions.y0shift;
        var shiftYEnd = shapeOptions.y1shift;
        var x2p = function(v, shift) {
          var dataToPixel = helpers.getDataToPixel(gd, xa, shift, false, xRefType);
          return dataToPixel(v);
        };
        var y2p = function(v, shift) {
          var dataToPixel = helpers.getDataToPixel(gd, ya, shift, true, yRefType);
          return dataToPixel(v);
        };
        var p2x = helpers.getPixelToData(gd, xa, false, xRefType);
        var p2y = helpers.getPixelToData(gd, ya, true, yRefType);
        var sensoryElement = obtainSensoryElement();
        var dragOptions = {
          element: sensoryElement.node(),
          gd,
          prepFn: startDrag,
          doneFn: endDrag,
          clickFn: abortDrag
        };
        var dragMode;
        dragElement.init(dragOptions);
        sensoryElement.node().onmousemove = updateDragMode;
        function obtainSensoryElement() {
          return isLine ? createLineDragHandles() : shapePath;
        }
        function createLineDragHandles() {
          var minSensoryWidth = 10;
          var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);
          var g = shapeLayer.append("g").attr("data-index", index).attr("drag-helper", true);
          g.append("path").attr("d", shapePath.attr("d")).style({
            cursor: "move",
            "stroke-width": sensoryWidth,
            "stroke-opacity": "0"
            // ensure not visible
          });
          var circleStyle = {
            "fill-opacity": "0"
            // ensure not visible
          };
          var circleRadius = Math.max(sensoryWidth / 2, minSensoryWidth);
          g.append("circle").attr({
            "data-line-point": "start-point",
            cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0, shiftXStart),
            cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0, shiftYStart),
            r: circleRadius
          }).style(circleStyle).classed("cursor-grab", true);
          g.append("circle").attr({
            "data-line-point": "end-point",
            cx: xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1, shiftXEnd),
            cy: yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1, shiftYEnd),
            r: circleRadius
          }).style(circleStyle).classed("cursor-grab", true);
          return g;
        }
        function updateDragMode(evt) {
          if (shouldSkipEdits(gd)) {
            dragMode = null;
            return;
          }
          if (isLine) {
            if (evt.target.tagName === "path") {
              dragMode = "move";
            } else {
              dragMode = evt.target.attributes["data-line-point"].value === "start-point" ? "resize-over-start-point" : "resize-over-end-point";
            }
          } else {
            var dragBBox = dragOptions.element.getBoundingClientRect();
            var w = dragBBox.right - dragBBox.left;
            var h = dragBBox.bottom - dragBBox.top;
            var x = evt.clientX - dragBBox.left;
            var y = evt.clientY - dragBBox.top;
            var cursor = !isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey ? dragElement.getCursor(x / w, 1 - y / h) : "move";
            setCursor(shapePath, cursor);
            dragMode = cursor.split("-")[0];
          }
        }
        function startDrag(evt) {
          if (shouldSkipEdits(gd)) return;
          if (xPixelSized) {
            xAnchor = x2p(shapeOptions.xanchor);
          }
          if (yPixelSized) {
            yAnchor = y2p(shapeOptions.yanchor);
          }
          if (shapeOptions.type === "path") {
            pathIn = shapeOptions.path;
          } else {
            x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);
            y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);
            x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);
            y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);
          }
          if (x0 < x1) {
            w0 = x0;
            optW = "x0";
            e0 = x1;
            optE = "x1";
          } else {
            w0 = x1;
            optW = "x1";
            e0 = x0;
            optE = "x0";
          }
          if (!yPixelSized && y0 < y1 || yPixelSized && y0 > y1) {
            n0 = y0;
            optN = "y0";
            s0 = y1;
            optS = "y1";
          } else {
            n0 = y1;
            optN = "y1";
            s0 = y0;
            optS = "y0";
          }
          updateDragMode(evt);
          renderVisualCues(shapeLayer, shapeOptions);
          deactivateClipPathTemporarily(shapePath, shapeOptions, gd);
          dragOptions.moveFn = dragMode === "move" ? moveShape : resizeShape;
          dragOptions.altKey = evt.altKey;
        }
        function endDrag() {
          if (shouldSkipEdits(gd)) return;
          setCursor(shapePath);
          removeVisualCues(shapeLayer);
          setClipPath(shapePath, gd, shapeOptions);
          Registry.call("_guiRelayout", gd, editHelpers.getUpdateObj());
        }
        function abortDrag() {
          if (shouldSkipEdits(gd)) return;
          removeVisualCues(shapeLayer);
        }
        function moveShape(dx, dy) {
          if (shapeOptions.type === "path") {
            var noOp = function(coord) {
              return coord;
            };
            var moveX = noOp;
            var moveY = noOp;
            if (xPixelSized) {
              modifyItem("xanchor", shapeOptions.xanchor = p2x(xAnchor + dx));
            } else {
              moveX = function moveX2(x) {
                return p2x(x2p(x) + dx);
              };
              if (xa && xa.type === "date") moveX = helpers.encodeDate(moveX);
            }
            if (yPixelSized) {
              modifyItem("yanchor", shapeOptions.yanchor = p2y(yAnchor + dy));
            } else {
              moveY = function moveY2(y) {
                return p2y(y2p(y) + dy);
              };
              if (ya && ya.type === "date") moveY = helpers.encodeDate(moveY);
            }
            modifyItem("path", shapeOptions.path = movePath(pathIn, moveX, moveY));
          } else {
            if (xPixelSized) {
              modifyItem("xanchor", shapeOptions.xanchor = p2x(xAnchor + dx));
            } else {
              modifyItem("x0", shapeOptions.x0 = p2x(x0 + dx));
              modifyItem("x1", shapeOptions.x1 = p2x(x1 + dx));
            }
            if (yPixelSized) {
              modifyItem("yanchor", shapeOptions.yanchor = p2y(yAnchor + dy));
            } else {
              modifyItem("y0", shapeOptions.y0 = p2y(y0 + dy));
              modifyItem("y1", shapeOptions.y1 = p2y(y1 + dy));
            }
          }
          shapePath.attr("d", getPathString(gd, shapeOptions));
          renderVisualCues(shapeLayer, shapeOptions);
          drawLabel(gd, index, shapeOptions, shapeGroup);
        }
        function resizeShape(dx, dy) {
          if (isPath) {
            var noOp = function(coord) {
              return coord;
            };
            var moveX = noOp;
            var moveY = noOp;
            if (xPixelSized) {
              modifyItem("xanchor", shapeOptions.xanchor = p2x(xAnchor + dx));
            } else {
              moveX = function moveX2(x) {
                return p2x(x2p(x) + dx);
              };
              if (xa && xa.type === "date") moveX = helpers.encodeDate(moveX);
            }
            if (yPixelSized) {
              modifyItem("yanchor", shapeOptions.yanchor = p2y(yAnchor + dy));
            } else {
              moveY = function moveY2(y) {
                return p2y(y2p(y) + dy);
              };
              if (ya && ya.type === "date") moveY = helpers.encodeDate(moveY);
            }
            modifyItem("path", shapeOptions.path = movePath(pathIn, moveX, moveY));
          } else if (isLine) {
            if (dragMode === "resize-over-start-point") {
              var newX0 = x0 + dx;
              var newY0 = yPixelSized ? y0 - dy : y0 + dy;
              modifyItem("x0", shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));
              modifyItem("y0", shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));
            } else if (dragMode === "resize-over-end-point") {
              var newX1 = x1 + dx;
              var newY1 = yPixelSized ? y1 - dy : y1 + dy;
              modifyItem("x1", shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));
              modifyItem("y1", shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));
            }
          } else {
            var has = function(str) {
              return dragMode.indexOf(str) !== -1;
            };
            var hasN = has("n");
            var hasS = has("s");
            var hasW = has("w");
            var hasE = has("e");
            var newN = hasN ? n0 + dy : n0;
            var newS = hasS ? s0 + dy : s0;
            var newW = hasW ? w0 + dx : w0;
            var newE = hasE ? e0 + dx : e0;
            if (yPixelSized) {
              if (hasN) newN = n0 - dy;
              if (hasS) newS = s0 - dy;
            }
            if (!yPixelSized && newS - newN > MINHEIGHT || yPixelSized && newN - newS > MINHEIGHT) {
              modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));
              modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));
            }
            if (newE - newW > MINWIDTH) {
              modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));
              modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));
            }
          }
          shapePath.attr("d", getPathString(gd, shapeOptions));
          renderVisualCues(shapeLayer, shapeOptions);
          drawLabel(gd, index, shapeOptions, shapeGroup);
        }
        function renderVisualCues(shapeLayer2, shapeOptions2) {
          if (xPixelSized || yPixelSized) {
            renderAnchor();
          }
          function renderAnchor() {
            var isNotPath = shapeOptions2.type !== "path";
            var visualCues = shapeLayer2.selectAll(".visual-cue").data([0]);
            var strokeWidth = 1;
            visualCues.enter().append("path").attr({
              fill: "#fff",
              "fill-rule": "evenodd",
              stroke: "#000",
              "stroke-width": strokeWidth
            }).classed("visual-cue", true);
            var posX = x2p(
              xPixelSized ? shapeOptions2.xanchor : Lib.midRange(
                isNotPath ? [shapeOptions2.x0, shapeOptions2.x1] : helpers.extractPathCoords(shapeOptions2.path, constants.paramIsX)
              )
            );
            var posY = y2p(
              yPixelSized ? shapeOptions2.yanchor : Lib.midRange(
                isNotPath ? [shapeOptions2.y0, shapeOptions2.y1] : helpers.extractPathCoords(shapeOptions2.path, constants.paramIsY)
              )
            );
            posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);
            posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);
            if (xPixelSized && yPixelSized) {
              var crossPath = "M" + (posX - 1 - strokeWidth) + "," + (posY - 1 - strokeWidth) + "h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z";
              visualCues.attr("d", crossPath);
            } else if (xPixelSized) {
              var vBarPath = "M" + (posX - 1 - strokeWidth) + "," + (posY - 9 - strokeWidth) + "v18 h2 v-18 Z";
              visualCues.attr("d", vBarPath);
            } else {
              var hBarPath = "M" + (posX - 9 - strokeWidth) + "," + (posY - 1 - strokeWidth) + "h18 v2 h-18 Z";
              visualCues.attr("d", hBarPath);
            }
          }
        }
        function removeVisualCues(shapeLayer2) {
          shapeLayer2.selectAll(".visual-cue").remove();
        }
        function deactivateClipPathTemporarily(shapePath2, shapeOptions2, gd2) {
          var xref = shapeOptions2.xref;
          var yref = shapeOptions2.yref;
          var xa2 = Axes.getFromId(gd2, xref);
          var ya2 = Axes.getFromId(gd2, yref);
          var clipAxes = "";
          if (xref !== "paper" && !xa2.autorange) clipAxes += xref;
          if (yref !== "paper" && !ya2.autorange) clipAxes += yref;
          Drawing.setClipUrl(
            shapePath2,
            clipAxes ? "clip" + gd2._fullLayout._uid + clipAxes : null,
            gd2
          );
        }
      }
      function movePath(pathIn, moveX, moveY) {
        return pathIn.replace(constants.segmentRE, function(segment) {
          var paramNumber = 0;
          var segmentType = segment.charAt(0);
          var xParams = constants.paramIsX[segmentType];
          var yParams = constants.paramIsY[segmentType];
          var nParams = constants.numParams[segmentType];
          var paramString = segment.substr(1).replace(constants.paramRE, function(param) {
            if (paramNumber >= nParams) return param;
            if (xParams[paramNumber]) param = moveX(param);
            else if (yParams[paramNumber]) param = moveY(param);
            paramNumber++;
            return param;
          });
          return segmentType + paramString;
        });
      }
      function activateShape(gd, path) {
        if (!couldHaveActiveShape(gd)) return;
        var element = path.node();
        var id = +element.getAttribute("data-index");
        if (id >= 0) {
          if (id === gd._fullLayout._activeShapeIndex) {
            deactivateShape(gd);
            return;
          }
          gd._fullLayout._activeShapeIndex = id;
          gd._fullLayout._deactivateShape = deactivateShape;
          draw(gd);
        }
      }
      function deactivateShape(gd) {
        if (!couldHaveActiveShape(gd)) return;
        var id = gd._fullLayout._activeShapeIndex;
        if (id >= 0) {
          clearOutlineControllers(gd);
          delete gd._fullLayout._activeShapeIndex;
          draw(gd);
        }
      }
      function eraseActiveShape(gd) {
        if (!couldHaveActiveShape(gd)) return;
        clearOutlineControllers(gd);
        var id = gd._fullLayout._activeShapeIndex;
        var shapes = (gd.layout || {}).shapes || [];
        if (id < shapes.length) {
          var list = [];
          for (var q = 0; q < shapes.length; q++) {
            if (q !== id) {
              list.push(shapes[q]);
            }
          }
          delete gd._fullLayout._activeShapeIndex;
          return Registry.call("_guiRelayout", gd, {
            shapes: list
          });
        }
      }
    }
  });

  // src/components/modebar/buttons.js
  var require_buttons = __commonJS({
    "src/components/modebar/buttons.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Plots = require_plots();
      var axisIds = require_axis_ids();
      var Icons = require_ploticon();
      var eraseActiveShape = require_draw2().eraseActiveShape;
      var Lib = require_lib();
      var _ = Lib._;
      var modeBarButtons = module.exports = {};
      modeBarButtons.toImage = {
        name: "toImage",
        title: function(gd) {
          var opts = gd._context.toImageButtonOptions || {};
          var format = opts.format || "png";
          return format === "png" ? _(gd, "Download plot as a png") : (
            // legacy text
            _(gd, "Download plot")
          );
        },
        icon: Icons.camera,
        click: function(gd) {
          var toImageButtonOptions = gd._context.toImageButtonOptions;
          var opts = { format: toImageButtonOptions.format || "png" };
          Lib.notifier(_(gd, "Taking snapshot - this may take a few seconds"), "long");
          ["filename", "width", "height", "scale"].forEach(function(key) {
            if (key in toImageButtonOptions) {
              opts[key] = toImageButtonOptions[key];
            }
          });
          Registry.call("downloadImage", gd, opts).then(function(filename) {
            Lib.notifier(_(gd, "Snapshot succeeded") + " - " + filename, "long");
          }).catch(function() {
            Lib.notifier(_(gd, "Sorry, there was a problem downloading your snapshot!"), "long");
          });
        }
      };
      modeBarButtons.sendDataToCloud = {
        name: "sendDataToCloud",
        title: function(gd) {
          return _(gd, "Edit in Chart Studio");
        },
        icon: Icons.disk,
        click: function(gd) {
          Plots.sendDataToCloud(gd);
        }
      };
      modeBarButtons.editInChartStudio = {
        name: "editInChartStudio",
        title: function(gd) {
          return _(gd, "Edit in Chart Studio");
        },
        icon: Icons.pencil,
        click: function(gd) {
          Plots.sendDataToCloud(gd);
        }
      };
      modeBarButtons.zoom2d = {
        name: "zoom2d",
        _cat: "zoom",
        title: function(gd) {
          return _(gd, "Zoom");
        },
        attr: "dragmode",
        val: "zoom",
        icon: Icons.zoombox,
        click: handleCartesian
      };
      modeBarButtons.pan2d = {
        name: "pan2d",
        _cat: "pan",
        title: function(gd) {
          return _(gd, "Pan");
        },
        attr: "dragmode",
        val: "pan",
        icon: Icons.pan,
        click: handleCartesian
      };
      modeBarButtons.select2d = {
        name: "select2d",
        _cat: "select",
        title: function(gd) {
          return _(gd, "Box Select");
        },
        attr: "dragmode",
        val: "select",
        icon: Icons.selectbox,
        click: handleCartesian
      };
      modeBarButtons.lasso2d = {
        name: "lasso2d",
        _cat: "lasso",
        title: function(gd) {
          return _(gd, "Lasso Select");
        },
        attr: "dragmode",
        val: "lasso",
        icon: Icons.lasso,
        click: handleCartesian
      };
      modeBarButtons.drawclosedpath = {
        name: "drawclosedpath",
        title: function(gd) {
          return _(gd, "Draw closed freeform");
        },
        attr: "dragmode",
        val: "drawclosedpath",
        icon: Icons.drawclosedpath,
        click: handleCartesian
      };
      modeBarButtons.drawopenpath = {
        name: "drawopenpath",
        title: function(gd) {
          return _(gd, "Draw open freeform");
        },
        attr: "dragmode",
        val: "drawopenpath",
        icon: Icons.drawopenpath,
        click: handleCartesian
      };
      modeBarButtons.drawline = {
        name: "drawline",
        title: function(gd) {
          return _(gd, "Draw line");
        },
        attr: "dragmode",
        val: "drawline",
        icon: Icons.drawline,
        click: handleCartesian
      };
      modeBarButtons.drawrect = {
        name: "drawrect",
        title: function(gd) {
          return _(gd, "Draw rectangle");
        },
        attr: "dragmode",
        val: "drawrect",
        icon: Icons.drawrect,
        click: handleCartesian
      };
      modeBarButtons.drawcircle = {
        name: "drawcircle",
        title: function(gd) {
          return _(gd, "Draw circle");
        },
        attr: "dragmode",
        val: "drawcircle",
        icon: Icons.drawcircle,
        click: handleCartesian
      };
      modeBarButtons.eraseshape = {
        name: "eraseshape",
        title: function(gd) {
          return _(gd, "Erase active shape");
        },
        icon: Icons.eraseshape,
        click: eraseActiveShape
      };
      modeBarButtons.zoomIn2d = {
        name: "zoomIn2d",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleCartesian
      };
      modeBarButtons.zoomOut2d = {
        name: "zoomOut2d",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleCartesian
      };
      modeBarButtons.autoScale2d = {
        name: "autoScale2d",
        _cat: "autoscale",
        title: function(gd) {
          return _(gd, "Autoscale");
        },
        attr: "zoom",
        val: "auto",
        icon: Icons.autoscale,
        click: handleCartesian
      };
      modeBarButtons.resetScale2d = {
        name: "resetScale2d",
        _cat: "resetscale",
        title: function(gd) {
          return _(gd, "Reset axes");
        },
        attr: "zoom",
        val: "reset",
        icon: Icons.home,
        click: handleCartesian
      };
      modeBarButtons.hoverClosestCartesian = {
        name: "hoverClosestCartesian",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Show closest data on hover");
        },
        attr: "hovermode",
        val: "closest",
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: handleCartesian
      };
      modeBarButtons.hoverCompareCartesian = {
        name: "hoverCompareCartesian",
        _cat: "hoverCompare",
        title: function(gd) {
          return _(gd, "Compare data on hover");
        },
        attr: "hovermode",
        val: function(gd) {
          return gd._fullLayout._isHoriz ? "y" : "x";
        },
        icon: Icons.tooltip_compare,
        gravity: "ne",
        click: handleCartesian
      };
      function handleCartesian(gd, ev) {
        var button = ev.currentTarget;
        var astr = button.getAttribute("data-attr");
        var val = button.getAttribute("data-val") || true;
        var fullLayout = gd._fullLayout;
        var aobj = {};
        var axList = axisIds.list(gd, null, true);
        var allSpikesEnabled = fullLayout._cartesianSpikesEnabled;
        var ax, i;
        if (astr === "zoom") {
          var mag = val === "in" ? 0.5 : 2;
          var r0 = (1 + mag) / 2;
          var r1 = (1 - mag) / 2;
          var axName;
          for (i = 0; i < axList.length; i++) {
            ax = axList[i];
            if (!ax.fixedrange) {
              axName = ax._name;
              if (val === "auto") {
                aobj[axName + ".autorange"] = true;
              } else if (val === "reset") {
                if (ax._rangeInitial0 === void 0 && ax._rangeInitial1 === void 0) {
                  aobj[axName + ".autorange"] = true;
                } else if (ax._rangeInitial0 === void 0) {
                  aobj[axName + ".autorange"] = ax._autorangeInitial;
                  aobj[axName + ".range"] = [null, ax._rangeInitial1];
                } else if (ax._rangeInitial1 === void 0) {
                  aobj[axName + ".range"] = [ax._rangeInitial0, null];
                  aobj[axName + ".autorange"] = ax._autorangeInitial;
                } else {
                  aobj[axName + ".range"] = [ax._rangeInitial0, ax._rangeInitial1];
                }
                if (ax._showSpikeInitial !== void 0) {
                  aobj[axName + ".showspikes"] = ax._showSpikeInitial;
                  if (allSpikesEnabled === "on" && !ax._showSpikeInitial) {
                    allSpikesEnabled = "off";
                  }
                }
              } else {
                var rangeNow = [
                  ax.r2l(ax.range[0]),
                  ax.r2l(ax.range[1])
                ];
                var rangeNew = [
                  r0 * rangeNow[0] + r1 * rangeNow[1],
                  r0 * rangeNow[1] + r1 * rangeNow[0]
                ];
                aobj[axName + ".range[0]"] = ax.l2r(rangeNew[0]);
                aobj[axName + ".range[1]"] = ax.l2r(rangeNew[1]);
              }
            }
          }
        } else {
          if (astr === "hovermode" && (val === "x" || val === "y")) {
            val = fullLayout._isHoriz ? "y" : "x";
            button.setAttribute("data-val", val);
          }
          aobj[astr] = val;
        }
        fullLayout._cartesianSpikesEnabled = allSpikesEnabled;
        Registry.call("_guiRelayout", gd, aobj);
      }
      modeBarButtons.zoom3d = {
        name: "zoom3d",
        _cat: "zoom",
        title: function(gd) {
          return _(gd, "Zoom");
        },
        attr: "scene.dragmode",
        val: "zoom",
        icon: Icons.zoombox,
        click: handleDrag3d
      };
      modeBarButtons.pan3d = {
        name: "pan3d",
        _cat: "pan",
        title: function(gd) {
          return _(gd, "Pan");
        },
        attr: "scene.dragmode",
        val: "pan",
        icon: Icons.pan,
        click: handleDrag3d
      };
      modeBarButtons.orbitRotation = {
        name: "orbitRotation",
        title: function(gd) {
          return _(gd, "Orbital rotation");
        },
        attr: "scene.dragmode",
        val: "orbit",
        icon: Icons["3d_rotate"],
        click: handleDrag3d
      };
      modeBarButtons.tableRotation = {
        name: "tableRotation",
        title: function(gd) {
          return _(gd, "Turntable rotation");
        },
        attr: "scene.dragmode",
        val: "turntable",
        icon: Icons["z-axis"],
        click: handleDrag3d
      };
      function handleDrag3d(gd, ev) {
        var button = ev.currentTarget;
        var attr = button.getAttribute("data-attr");
        var val = button.getAttribute("data-val") || true;
        var sceneIds = gd._fullLayout._subplots.gl3d || [];
        var layoutUpdate = {};
        var parts = attr.split(".");
        for (var i = 0; i < sceneIds.length; i++) {
          layoutUpdate[sceneIds[i] + "." + parts[1]] = val;
        }
        var val2d = val === "pan" ? val : "zoom";
        layoutUpdate.dragmode = val2d;
        Registry.call("_guiRelayout", gd, layoutUpdate);
      }
      modeBarButtons.resetCameraDefault3d = {
        name: "resetCameraDefault3d",
        _cat: "resetCameraDefault",
        title: function(gd) {
          return _(gd, "Reset camera to default");
        },
        attr: "resetDefault",
        icon: Icons.home,
        click: handleCamera3d
      };
      modeBarButtons.resetCameraLastSave3d = {
        name: "resetCameraLastSave3d",
        _cat: "resetCameraLastSave",
        title: function(gd) {
          return _(gd, "Reset camera to last save");
        },
        attr: "resetLastSave",
        icon: Icons.movie,
        click: handleCamera3d
      };
      function handleCamera3d(gd, ev) {
        var button = ev.currentTarget;
        var attr = button.getAttribute("data-attr");
        var resetLastSave = attr === "resetLastSave";
        var resetDefault = attr === "resetDefault";
        var fullLayout = gd._fullLayout;
        var sceneIds = fullLayout._subplots.gl3d || [];
        var aobj = {};
        for (var i = 0; i < sceneIds.length; i++) {
          var sceneId = sceneIds[i];
          var camera = sceneId + ".camera";
          var aspectratio = sceneId + ".aspectratio";
          var aspectmode = sceneId + ".aspectmode";
          var scene = fullLayout[sceneId]._scene;
          var didUpdate;
          if (resetLastSave) {
            aobj[camera + ".up"] = scene.viewInitial.up;
            aobj[camera + ".eye"] = scene.viewInitial.eye;
            aobj[camera + ".center"] = scene.viewInitial.center;
            didUpdate = true;
          } else if (resetDefault) {
            aobj[camera + ".up"] = null;
            aobj[camera + ".eye"] = null;
            aobj[camera + ".center"] = null;
            didUpdate = true;
          }
          if (didUpdate) {
            aobj[aspectratio + ".x"] = scene.viewInitial.aspectratio.x;
            aobj[aspectratio + ".y"] = scene.viewInitial.aspectratio.y;
            aobj[aspectratio + ".z"] = scene.viewInitial.aspectratio.z;
            aobj[aspectmode] = scene.viewInitial.aspectmode;
          }
        }
        Registry.call("_guiRelayout", gd, aobj);
      }
      modeBarButtons.hoverClosest3d = {
        name: "hoverClosest3d",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: null,
        toggle: true,
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: handleHover3d
      };
      function getNextHover3d(gd, ev) {
        var button = ev.currentTarget;
        var val = button._previousVal;
        var fullLayout = gd._fullLayout;
        var sceneIds = fullLayout._subplots.gl3d || [];
        var axes = ["xaxis", "yaxis", "zaxis"];
        var currentSpikes = {};
        var layoutUpdate = {};
        if (val) {
          layoutUpdate = val;
          button._previousVal = null;
        } else {
          for (var i = 0; i < sceneIds.length; i++) {
            var sceneId = sceneIds[i];
            var sceneLayout = fullLayout[sceneId];
            var hovermodeAStr = sceneId + ".hovermode";
            currentSpikes[hovermodeAStr] = sceneLayout.hovermode;
            layoutUpdate[hovermodeAStr] = false;
            for (var j = 0; j < 3; j++) {
              var axis = axes[j];
              var spikeAStr = sceneId + "." + axis + ".showspikes";
              layoutUpdate[spikeAStr] = false;
              currentSpikes[spikeAStr] = sceneLayout[axis].showspikes;
            }
          }
          button._previousVal = currentSpikes;
        }
        return layoutUpdate;
      }
      function handleHover3d(gd, ev) {
        var layoutUpdate = getNextHover3d(gd, ev);
        Registry.call("_guiRelayout", gd, layoutUpdate);
      }
      modeBarButtons.zoomInGeo = {
        name: "zoomInGeo",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleGeo
      };
      modeBarButtons.zoomOutGeo = {
        name: "zoomOutGeo",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleGeo
      };
      modeBarButtons.resetGeo = {
        name: "resetGeo",
        _cat: "reset",
        title: function(gd) {
          return _(gd, "Reset");
        },
        attr: "reset",
        val: null,
        icon: Icons.autoscale,
        click: handleGeo
      };
      modeBarButtons.hoverClosestGeo = {
        name: "hoverClosestGeo",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: null,
        toggle: true,
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: toggleHover
      };
      function handleGeo(gd, ev) {
        var button = ev.currentTarget;
        var attr = button.getAttribute("data-attr");
        var val = button.getAttribute("data-val") || true;
        var fullLayout = gd._fullLayout;
        var geoIds = fullLayout._subplots.geo || [];
        for (var i = 0; i < geoIds.length; i++) {
          var id = geoIds[i];
          var geoLayout = fullLayout[id];
          if (attr === "zoom") {
            var scale = geoLayout.projection.scale;
            var newScale = val === "in" ? 2 * scale : 0.5 * scale;
            Registry.call("_guiRelayout", gd, id + ".projection.scale", newScale);
          }
        }
        if (attr === "reset") {
          resetView(gd, "geo");
        }
      }
      modeBarButtons.hoverClosestPie = {
        name: "hoverClosestPie",
        _cat: "hoverclosest",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: "closest",
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: toggleHover
      };
      function getNextHover(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout.hovermode) return false;
        if (fullLayout._has("cartesian")) {
          return fullLayout._isHoriz ? "y" : "x";
        }
        return "closest";
      }
      function toggleHover(gd) {
        var newHover = getNextHover(gd);
        Registry.call("_guiRelayout", gd, "hovermode", newHover);
      }
      modeBarButtons.resetViewSankey = {
        name: "resetSankeyGroup",
        title: function(gd) {
          return _(gd, "Reset view");
        },
        icon: Icons.home,
        click: function(gd) {
          var aObj = {
            "node.groups": [],
            "node.x": [],
            "node.y": []
          };
          for (var i = 0; i < gd._fullData.length; i++) {
            var viewInitial = gd._fullData[i]._viewInitial;
            aObj["node.groups"].push(viewInitial.node.groups.slice());
            aObj["node.x"].push(viewInitial.node.x.slice());
            aObj["node.y"].push(viewInitial.node.y.slice());
          }
          Registry.call("restyle", gd, aObj);
        }
      };
      modeBarButtons.toggleHover = {
        name: "toggleHover",
        title: function(gd) {
          return _(gd, "Toggle show closest data on hover");
        },
        attr: "hovermode",
        val: null,
        toggle: true,
        icon: Icons.tooltip_basic,
        gravity: "ne",
        click: function(gd, ev) {
          var layoutUpdate = getNextHover3d(gd, ev);
          layoutUpdate.hovermode = getNextHover(gd);
          Registry.call("_guiRelayout", gd, layoutUpdate);
        }
      };
      modeBarButtons.resetViews = {
        name: "resetViews",
        title: function(gd) {
          return _(gd, "Reset views");
        },
        icon: Icons.home,
        click: function(gd, ev) {
          var button = ev.currentTarget;
          button.setAttribute("data-attr", "zoom");
          button.setAttribute("data-val", "reset");
          handleCartesian(gd, ev);
          button.setAttribute("data-attr", "resetLastSave");
          handleCamera3d(gd, ev);
          resetView(gd, "geo");
          resetView(gd, "mapbox");
          resetView(gd, "map");
        }
      };
      modeBarButtons.toggleSpikelines = {
        name: "toggleSpikelines",
        title: function(gd) {
          return _(gd, "Toggle Spike Lines");
        },
        icon: Icons.spikeline,
        attr: "_cartesianSpikesEnabled",
        val: "on",
        click: function(gd) {
          var fullLayout = gd._fullLayout;
          var allSpikesEnabled = fullLayout._cartesianSpikesEnabled;
          fullLayout._cartesianSpikesEnabled = allSpikesEnabled === "on" ? "off" : "on";
          Registry.call("_guiRelayout", gd, setSpikelineVisibility(gd));
        }
      };
      function setSpikelineVisibility(gd) {
        var fullLayout = gd._fullLayout;
        var areSpikesOn = fullLayout._cartesianSpikesEnabled === "on";
        var axList = axisIds.list(gd, null, true);
        var aobj = {};
        for (var i = 0; i < axList.length; i++) {
          var ax = axList[i];
          aobj[ax._name + ".showspikes"] = areSpikesOn ? true : ax._showSpikeInitial;
        }
        return aobj;
      }
      modeBarButtons.resetViewMapbox = {
        name: "resetViewMapbox",
        _cat: "resetView",
        title: function(gd) {
          return _(gd, "Reset view");
        },
        attr: "reset",
        icon: Icons.home,
        click: function(gd) {
          resetView(gd, "mapbox");
        }
      };
      modeBarButtons.resetViewMap = {
        name: "resetViewMap",
        _cat: "resetView",
        title: function(gd) {
          return _(gd, "Reset view");
        },
        attr: "reset",
        icon: Icons.home,
        click: function(gd) {
          resetView(gd, "map");
        }
      };
      modeBarButtons.zoomInMapbox = {
        name: "zoomInMapbox",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleMapboxZoom
      };
      modeBarButtons.zoomInMap = {
        name: "zoomInMap",
        _cat: "zoomin",
        title: function(gd) {
          return _(gd, "Zoom in");
        },
        attr: "zoom",
        val: "in",
        icon: Icons.zoom_plus,
        click: handleMapZoom
      };
      modeBarButtons.zoomOutMapbox = {
        name: "zoomOutMapbox",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleMapboxZoom
      };
      modeBarButtons.zoomOutMap = {
        name: "zoomOutMap",
        _cat: "zoomout",
        title: function(gd) {
          return _(gd, "Zoom out");
        },
        attr: "zoom",
        val: "out",
        icon: Icons.zoom_minus,
        click: handleMapZoom
      };
      function handleMapboxZoom(gd, ev) {
        _handleMapZoom(gd, ev, "mapbox");
      }
      function handleMapZoom(gd, ev) {
        _handleMapZoom(gd, ev, "map");
      }
      function _handleMapZoom(gd, ev, mapType) {
        var button = ev.currentTarget;
        var val = button.getAttribute("data-val");
        var fullLayout = gd._fullLayout;
        var subplotIds = fullLayout._subplots[mapType] || [];
        var scalar = 1.05;
        var aObj = {};
        for (var i = 0; i < subplotIds.length; i++) {
          var id = subplotIds[i];
          var current = fullLayout[id].zoom;
          var next = val === "in" ? scalar * current : current / scalar;
          aObj[id + ".zoom"] = next;
        }
        Registry.call("_guiRelayout", gd, aObj);
      }
      function resetView(gd, subplotType) {
        var fullLayout = gd._fullLayout;
        var subplotIds = fullLayout._subplots[subplotType] || [];
        var aObj = {};
        for (var i = 0; i < subplotIds.length; i++) {
          var id = subplotIds[i];
          var subplotObj = fullLayout[id]._subplot;
          var viewInitial = subplotObj.viewInitial;
          var viewKeys = Object.keys(viewInitial);
          for (var j = 0; j < viewKeys.length; j++) {
            var key = viewKeys[j];
            aObj[id + "." + key] = viewInitial[key];
          }
        }
        Registry.call("_guiRelayout", gd, aObj);
      }
    }
  });

  // src/components/modebar/constants.js
  var require_constants6 = __commonJS({
    "src/components/modebar/constants.js"(exports, module) {
      "use strict";
      var modeBarButtons = require_buttons();
      var buttonList = Object.keys(modeBarButtons);
      var DRAW_MODES = [
        "drawline",
        "drawopenpath",
        "drawclosedpath",
        "drawcircle",
        "drawrect",
        "eraseshape"
      ];
      var backButtons = [
        "v1hovermode",
        "hoverclosest",
        "hovercompare",
        "togglehover",
        "togglespikelines"
      ].concat(DRAW_MODES);
      var foreButtons = [];
      var addToForeButtons = function(b) {
        if (backButtons.indexOf(b._cat || b.name) !== -1) return;
        var name = b.name;
        var _cat = (b._cat || b.name).toLowerCase();
        if (foreButtons.indexOf(name) === -1) foreButtons.push(name);
        if (foreButtons.indexOf(_cat) === -1) foreButtons.push(_cat);
      };
      buttonList.forEach(function(k) {
        addToForeButtons(modeBarButtons[k]);
      });
      foreButtons.sort();
      module.exports = {
        DRAW_MODES,
        backButtons,
        foreButtons
      };
    }
  });

  // src/components/modebar/attributes.js
  var require_attributes10 = __commonJS({
    "src/components/modebar/attributes.js"(exports, module) {
      "use strict";
      var constants = require_constants6();
      module.exports = {
        editType: "modebar",
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          dflt: "h",
          editType: "modebar"
        },
        bgcolor: {
          valType: "color",
          editType: "modebar"
        },
        color: {
          valType: "color",
          editType: "modebar"
        },
        activecolor: {
          valType: "color",
          editType: "modebar"
        },
        uirevision: {
          valType: "any",
          editType: "none"
        },
        add: {
          valType: "string",
          arrayOk: true,
          dflt: "",
          editType: "modebar"
        },
        remove: {
          valType: "string",
          arrayOk: true,
          dflt: "",
          editType: "modebar"
        }
      };
    }
  });

  // src/components/modebar/defaults.js
  var require_defaults5 = __commonJS({
    "src/components/modebar/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var Template = require_plot_template();
      var attributes = require_attributes10();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        var containerIn = layoutIn.modebar || {};
        var containerOut = Template.newContainer(layoutOut, "modebar");
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        coerce("orientation");
        coerce("bgcolor", Color.addOpacity(layoutOut.paper_bgcolor, 0.5));
        var defaultColor = Color.contrast(Color.rgb(layoutOut.modebar.bgcolor));
        coerce("color", Color.addOpacity(defaultColor, 0.3));
        coerce("activecolor", Color.addOpacity(defaultColor, 0.7));
        coerce("uirevision", layoutOut.uirevision);
        coerce("add");
        coerce("remove");
      };
    }
  });

  // src/components/modebar/modebar.js
  var require_modebar = __commonJS({
    "src/components/modebar/modebar.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Icons = require_ploticon();
      var version = require_version().version;
      var Parser = new DOMParser();
      function ModeBar(opts) {
        this.container = opts.container;
        this.element = document.createElement("div");
        this.update(opts.graphInfo, opts.buttons);
        this.container.appendChild(this.element);
      }
      var proto = ModeBar.prototype;
      proto.update = function(graphInfo, buttons) {
        this.graphInfo = graphInfo;
        var context = this.graphInfo._context;
        var fullLayout = this.graphInfo._fullLayout;
        var modeBarId = "modebar-" + fullLayout._uid;
        this.element.setAttribute("id", modeBarId);
        this._uid = modeBarId;
        this.element.className = "modebar";
        if (context.displayModeBar === "hover") this.element.className += " modebar--hover ease-bg";
        if (fullLayout.modebar.orientation === "v") {
          this.element.className += " vertical";
          buttons = buttons.reverse();
        }
        var style = fullLayout.modebar;
        var groupSelector = "#" + modeBarId + " .modebar-group";
        document.querySelectorAll(groupSelector).forEach(function(group) {
          group.style.backgroundColor = style.bgcolor;
        });
        var needsNewButtons = !this.hasButtons(buttons);
        var needsNewLogo = this.hasLogo !== context.displaylogo;
        var needsNewLocale = this.locale !== context.locale;
        this.locale = context.locale;
        if (needsNewButtons || needsNewLogo || needsNewLocale) {
          this.removeAllButtons();
          this.updateButtons(buttons);
          if (context.watermark || context.displaylogo) {
            var logoGroup = this.getLogo();
            if (context.watermark) {
              logoGroup.className = logoGroup.className + " watermark";
            }
            if (fullLayout.modebar.orientation === "v") {
              this.element.insertBefore(logoGroup, this.element.childNodes[0]);
            } else {
              this.element.appendChild(logoGroup);
            }
            this.hasLogo = true;
          }
        }
        this.updateActiveButton();
        Lib.setStyleOnHover("#" + modeBarId + " .modebar-btn", ".active", ".icon path", "fill: " + style.activecolor, "fill: " + style.color, this.element);
      };
      proto.updateButtons = function(buttons) {
        var _this = this;
        this.buttons = buttons;
        this.buttonElements = [];
        this.buttonsNames = [];
        this.buttons.forEach(function(buttonGroup) {
          var group = _this.createGroup();
          buttonGroup.forEach(function(buttonConfig) {
            var buttonName = buttonConfig.name;
            if (!buttonName) {
              throw new Error("must provide button 'name' in button config");
            }
            if (_this.buttonsNames.indexOf(buttonName) !== -1) {
              throw new Error("button name '" + buttonName + "' is taken");
            }
            _this.buttonsNames.push(buttonName);
            var button = _this.createButton(buttonConfig);
            _this.buttonElements.push(button);
            group.appendChild(button);
          });
          _this.element.appendChild(group);
        });
      };
      proto.createGroup = function() {
        var group = document.createElement("div");
        group.className = "modebar-group";
        var style = this.graphInfo._fullLayout.modebar;
        group.style.backgroundColor = style.bgcolor;
        return group;
      };
      proto.createButton = function(config) {
        var _this = this;
        var button = document.createElement("a");
        button.setAttribute("rel", "tooltip");
        button.className = "modebar-btn";
        var title = config.title;
        if (title === void 0) title = config.name;
        else if (typeof title === "function") title = title(this.graphInfo);
        if (title || title === 0) button.setAttribute("data-title", title);
        if (config.attr !== void 0) button.setAttribute("data-attr", config.attr);
        var val = config.val;
        if (val !== void 0) {
          if (typeof val === "function") val = val(this.graphInfo);
          button.setAttribute("data-val", val);
        }
        var click = config.click;
        if (typeof click !== "function") {
          throw new Error("must provide button 'click' function in button config");
        } else {
          button.addEventListener("click", function(ev) {
            config.click(_this.graphInfo, ev);
            _this.updateActiveButton(ev.currentTarget);
          });
        }
        button.setAttribute("data-toggle", config.toggle || false);
        if (config.toggle) d3.select(button).classed("active", true);
        var icon = config.icon;
        if (typeof icon === "function") {
          button.appendChild(icon());
        } else {
          button.appendChild(this.createIcon(icon || Icons.question));
        }
        button.setAttribute("data-gravity", config.gravity || "n");
        return button;
      };
      proto.createIcon = function(thisIcon) {
        var iconHeight = isNumeric(thisIcon.height) ? Number(thisIcon.height) : thisIcon.ascent - thisIcon.descent;
        var svgNS = "http://www.w3.org/2000/svg";
        var icon;
        if (thisIcon.path) {
          icon = document.createElementNS(svgNS, "svg");
          icon.setAttribute("viewBox", [0, 0, thisIcon.width, iconHeight].join(" "));
          icon.setAttribute("class", "icon");
          var path = document.createElementNS(svgNS, "path");
          path.setAttribute("d", thisIcon.path);
          if (thisIcon.transform) {
            path.setAttribute("transform", thisIcon.transform);
          } else if (thisIcon.ascent !== void 0) {
            path.setAttribute("transform", "matrix(1 0 0 -1 0 " + thisIcon.ascent + ")");
          }
          icon.appendChild(path);
        }
        if (thisIcon.svg) {
          var svgDoc = Parser.parseFromString(thisIcon.svg, "application/xml");
          icon = svgDoc.childNodes[0];
        }
        icon.setAttribute("height", "1em");
        icon.setAttribute("width", "1em");
        return icon;
      };
      proto.updateActiveButton = function(buttonClicked) {
        var fullLayout = this.graphInfo._fullLayout;
        var dataAttrClicked = buttonClicked !== void 0 ? buttonClicked.getAttribute("data-attr") : null;
        this.buttonElements.forEach(function(button) {
          var thisval = button.getAttribute("data-val") || true;
          var dataAttr = button.getAttribute("data-attr");
          var isToggleButton = button.getAttribute("data-toggle") === "true";
          var button3 = d3.select(button);
          var updateButtonStyle = function(button2, isActive2) {
            var style = fullLayout.modebar;
            var childEl = button2.querySelector(".icon path");
            if (childEl) {
              if (isActive2 || button2.matches(":hover")) {
                childEl.style.fill = style.activecolor;
              } else {
                childEl.style.fill = style.color;
              }
            }
          };
          if (isToggleButton) {
            if (dataAttr === dataAttrClicked) {
              var isActive = !button3.classed("active");
              button3.classed("active", isActive);
              updateButtonStyle(button, isActive);
            }
          } else {
            var val = dataAttr === null ? dataAttr : Lib.nestedProperty(fullLayout, dataAttr).get();
            button3.classed("active", val === thisval);
            updateButtonStyle(button, val === thisval);
          }
        });
      };
      proto.hasButtons = function(buttons) {
        var currentButtons = this.buttons;
        if (!currentButtons) return false;
        if (buttons.length !== currentButtons.length) return false;
        for (var i = 0; i < buttons.length; ++i) {
          if (buttons[i].length !== currentButtons[i].length) return false;
          for (var j = 0; j < buttons[i].length; j++) {
            if (buttons[i][j].name !== currentButtons[i][j].name) return false;
          }
        }
        return true;
      };
      function jsVersion(str) {
        return str + " (v" + version + ")";
      }
      proto.getLogo = function() {
        var group = this.createGroup();
        var a = document.createElement("a");
        a.href = "https://plotly.com/";
        a.target = "_blank";
        a.setAttribute("data-title", jsVersion(Lib._(this.graphInfo, "Produced with Plotly.js")));
        a.className = "modebar-btn plotlyjsicon modebar-btn--logo";
        a.appendChild(this.createIcon(Icons.newplotlylogo));
        group.appendChild(a);
        return group;
      };
      proto.removeAllButtons = function() {
        while (this.element.firstChild) {
          this.element.removeChild(this.element.firstChild);
        }
        this.hasLogo = false;
      };
      proto.destroy = function() {
        Lib.removeElement(this.container.querySelector(".modebar"));
      };
      function createModeBar(gd, buttons) {
        var fullLayout = gd._fullLayout;
        var modeBar = new ModeBar({
          graphInfo: gd,
          container: fullLayout._modebardiv.node(),
          buttons
        });
        if (fullLayout._privateplot) {
          d3.select(modeBar.element).append("span").classed("badge-private float--left", true).text("PRIVATE");
        }
        return modeBar;
      }
      module.exports = createModeBar;
    }
  });

  // src/components/modebar/manage.js
  var require_manage = __commonJS({
    "src/components/modebar/manage.js"(exports, module) {
      "use strict";
      var axisIds = require_axis_ids();
      var scatterSubTypes = require_subtypes();
      var Registry = require_registry();
      var isUnifiedHover = require_helpers2().isUnifiedHover;
      var createModeBar = require_modebar();
      var modeBarButtons = require_buttons();
      var DRAW_MODES = require_constants6().DRAW_MODES;
      var extendDeep = require_lib().extendDeep;
      module.exports = function manageModeBar(gd) {
        var fullLayout = gd._fullLayout;
        var context = gd._context;
        var modeBar = fullLayout._modeBar;
        if (!context.displayModeBar && !context.watermark) {
          if (modeBar) {
            modeBar.destroy();
            delete fullLayout._modeBar;
          }
          return;
        }
        if (!Array.isArray(context.modeBarButtonsToRemove)) {
          throw new Error([
            "*modeBarButtonsToRemove* configuration options",
            "must be an array."
          ].join(" "));
        }
        if (!Array.isArray(context.modeBarButtonsToAdd)) {
          throw new Error([
            "*modeBarButtonsToAdd* configuration options",
            "must be an array."
          ].join(" "));
        }
        var customButtons = context.modeBarButtons;
        var buttonGroups;
        if (Array.isArray(customButtons) && customButtons.length) {
          buttonGroups = fillCustomButton(customButtons);
        } else if (!context.displayModeBar && context.watermark) {
          buttonGroups = [];
        } else {
          buttonGroups = getButtonGroups(gd);
        }
        if (modeBar) modeBar.update(gd, buttonGroups);
        else fullLayout._modeBar = createModeBar(gd, buttonGroups);
      };
      function getButtonGroups(gd) {
        var fullLayout = gd._fullLayout;
        var fullData = gd._fullData;
        var context = gd._context;
        function match(name, B) {
          if (typeof B === "string") {
            if (B.toLowerCase() === name.toLowerCase()) return true;
          } else {
            var v0 = B.name;
            var v1 = B._cat || B.name;
            if (v0 === name || v1 === name.toLowerCase()) return true;
          }
          return false;
        }
        var layoutAdd = fullLayout.modebar.add;
        if (typeof layoutAdd === "string") layoutAdd = [layoutAdd];
        var layoutRemove = fullLayout.modebar.remove;
        if (typeof layoutRemove === "string") layoutRemove = [layoutRemove];
        var buttonsToAdd = context.modeBarButtonsToAdd.concat(
          layoutAdd.filter(function(e) {
            for (var i2 = 0; i2 < context.modeBarButtonsToRemove.length; i2++) {
              if (match(e, context.modeBarButtonsToRemove[i2])) return false;
            }
            return true;
          })
        );
        var buttonsToRemove = context.modeBarButtonsToRemove.concat(
          layoutRemove.filter(function(e) {
            for (var i2 = 0; i2 < context.modeBarButtonsToAdd.length; i2++) {
              if (match(e, context.modeBarButtonsToAdd[i2])) return false;
            }
            return true;
          })
        );
        var hasCartesian = fullLayout._has("cartesian");
        var hasGL3D = fullLayout._has("gl3d");
        var hasGeo = fullLayout._has("geo");
        var hasPie = fullLayout._has("pie");
        var hasFunnelarea = fullLayout._has("funnelarea");
        var hasTernary = fullLayout._has("ternary");
        var hasMapbox = fullLayout._has("mapbox");
        var hasMap = fullLayout._has("map");
        var hasPolar = fullLayout._has("polar");
        var hasSmith = fullLayout._has("smith");
        var hasSankey = fullLayout._has("sankey");
        var allAxesFixed = areAllAxesFixed(fullLayout);
        var hasUnifiedHoverLabel = isUnifiedHover(fullLayout.hovermode);
        var groups = [];
        function addGroup(newGroup) {
          if (!newGroup.length) return;
          var out = [];
          for (var i2 = 0; i2 < newGroup.length; i2++) {
            var name = newGroup[i2];
            var B = modeBarButtons[name];
            var v0 = B.name.toLowerCase();
            var v1 = (B._cat || B.name).toLowerCase();
            var found = false;
            for (var q = 0; q < buttonsToRemove.length; q++) {
              var t = buttonsToRemove[q].toLowerCase();
              if (t === v0 || t === v1) {
                found = true;
                break;
              }
            }
            if (found) continue;
            out.push(modeBarButtons[name]);
          }
          groups.push(out);
        }
        var commonGroup = ["toImage"];
        if (context.showEditInChartStudio) commonGroup.push("editInChartStudio");
        else if (context.showSendToCloud) commonGroup.push("sendDataToCloud");
        addGroup(commonGroup);
        var zoomGroup = [];
        var hoverGroup = [];
        var resetGroup = [];
        var dragModeGroup = [];
        if ((hasCartesian || hasPie || hasFunnelarea || hasTernary) + hasGeo + hasGL3D + hasMapbox + hasMap + hasPolar + hasSmith > 1) {
          hoverGroup = ["toggleHover"];
          resetGroup = ["resetViews"];
        } else if (hasGeo) {
          zoomGroup = ["zoomInGeo", "zoomOutGeo"];
          hoverGroup = ["hoverClosestGeo"];
          resetGroup = ["resetGeo"];
        } else if (hasGL3D) {
          hoverGroup = ["hoverClosest3d"];
          resetGroup = ["resetCameraDefault3d", "resetCameraLastSave3d"];
        } else if (hasMapbox) {
          zoomGroup = ["zoomInMapbox", "zoomOutMapbox"];
          hoverGroup = ["toggleHover"];
          resetGroup = ["resetViewMapbox"];
        } else if (hasMap) {
          zoomGroup = ["zoomInMap", "zoomOutMap"];
          hoverGroup = ["toggleHover"];
          resetGroup = ["resetViewMap"];
        } else if (hasPie) {
          hoverGroup = ["hoverClosestPie"];
        } else if (hasSankey) {
          hoverGroup = ["hoverClosestCartesian", "hoverCompareCartesian"];
          resetGroup = ["resetViewSankey"];
        } else {
          hoverGroup = ["toggleHover"];
        }
        if (hasCartesian) {
          hoverGroup.push("toggleSpikelines", "hoverClosestCartesian", "hoverCompareCartesian");
        }
        if (hasNoHover(fullData) || hasUnifiedHoverLabel) {
          hoverGroup = [];
        }
        if (hasCartesian && !allAxesFixed) {
          zoomGroup = ["zoomIn2d", "zoomOut2d", "autoScale2d"];
          if (resetGroup[0] !== "resetViews") resetGroup = ["resetScale2d"];
        }
        if (hasGL3D) {
          dragModeGroup = ["zoom3d", "pan3d", "orbitRotation", "tableRotation"];
        } else if (hasCartesian && !allAxesFixed || hasTernary) {
          dragModeGroup = ["zoom2d", "pan2d"];
        } else if (hasMapbox || hasMap || hasGeo) {
          dragModeGroup = ["pan2d"];
        } else if (hasPolar) {
          dragModeGroup = ["zoom2d"];
        }
        if (isSelectable(fullData)) {
          dragModeGroup.push("select2d", "lasso2d");
        }
        var enabledHoverGroup = [];
        var enableHover = function(a) {
          if (enabledHoverGroup.indexOf(a) !== -1) return;
          if (hoverGroup.indexOf(a) !== -1) {
            enabledHoverGroup.push(a);
          }
        };
        if (Array.isArray(buttonsToAdd)) {
          var newList = [];
          for (var i = 0; i < buttonsToAdd.length; i++) {
            var b = buttonsToAdd[i];
            if (typeof b === "string") {
              b = b.toLowerCase();
              if (DRAW_MODES.indexOf(b) !== -1) {
                if (fullLayout._has("mapbox") || fullLayout._has("map") || // draw shapes in paper coordinate (could be improved in future to support data coordinate, when there is no pitch)
                fullLayout._has("cartesian")) {
                  dragModeGroup.push(b);
                }
              } else if (b === "togglespikelines") {
                enableHover("toggleSpikelines");
              } else if (b === "togglehover") {
                enableHover("toggleHover");
              } else if (b === "hovercompare") {
                enableHover("hoverCompareCartesian");
              } else if (b === "hoverclosest") {
                enableHover("hoverClosestCartesian");
                enableHover("hoverClosestGeo");
                enableHover("hoverClosest3d");
                enableHover("hoverClosestPie");
              } else if (b === "v1hovermode") {
                enableHover("hoverClosestCartesian");
                enableHover("hoverCompareCartesian");
                enableHover("hoverClosestGeo");
                enableHover("hoverClosest3d");
                enableHover("hoverClosestPie");
              }
            } else newList.push(b);
          }
          buttonsToAdd = newList;
        }
        addGroup(dragModeGroup);
        addGroup(zoomGroup.concat(resetGroup));
        addGroup(enabledHoverGroup);
        return appendButtonsToGroups(groups, buttonsToAdd);
      }
      function areAllAxesFixed(fullLayout) {
        var axList = axisIds.list({ _fullLayout: fullLayout }, null, true);
        for (var i = 0; i < axList.length; i++) {
          if (!axList[i].fixedrange) {
            return false;
          }
        }
        return true;
      }
      function isSelectable(fullData) {
        var selectable = false;
        for (var i = 0; i < fullData.length; i++) {
          if (selectable) break;
          var trace = fullData[i];
          if (!trace._module || !trace._module.selectPoints) continue;
          if (Registry.traceIs(trace, "scatter-like")) {
            if (scatterSubTypes.hasMarkers(trace) || scatterSubTypes.hasText(trace)) {
              selectable = true;
            }
          } else if (Registry.traceIs(trace, "box-violin")) {
            if (trace.boxpoints === "all" || trace.points === "all") {
              selectable = true;
            }
          } else {
            selectable = true;
          }
        }
        return selectable;
      }
      function hasNoHover(fullData) {
        for (var i = 0; i < fullData.length; i++) {
          if (!Registry.traceIs(fullData[i], "noHover")) return false;
        }
        return true;
      }
      function appendButtonsToGroups(groups, buttons) {
        if (buttons.length) {
          if (Array.isArray(buttons[0])) {
            for (var i = 0; i < buttons.length; i++) {
              groups.push(buttons[i]);
            }
          } else groups.push(buttons);
        }
        return groups;
      }
      function fillCustomButton(originalModeBarButtons) {
        var customButtons = extendDeep([], originalModeBarButtons);
        for (var i = 0; i < customButtons.length; i++) {
          var buttonGroup = customButtons[i];
          for (var j = 0; j < buttonGroup.length; j++) {
            var button = buttonGroup[j];
            if (typeof button === "string") {
              if (modeBarButtons[button] !== void 0) {
                customButtons[i][j] = modeBarButtons[button];
              } else {
                throw new Error([
                  "*modeBarButtons* configuration options",
                  "invalid button name"
                ].join(" "));
              }
            }
          }
        }
        return customButtons;
      }
    }
  });

  // src/components/modebar/index.js
  var require_modebar2 = __commonJS({
    "src/components/modebar/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "modebar",
        layoutAttributes: require_attributes10(),
        supplyLayoutDefaults: require_defaults5(),
        manage: require_manage()
      };
    }
  });

  // src/plots/cartesian/scale_zoom.js
  var require_scale_zoom = __commonJS({
    "src/plots/cartesian/scale_zoom.js"(exports, module) {
      "use strict";
      var FROM_BL = require_alignment().FROM_BL;
      module.exports = function scaleZoom(ax, factor, centerFraction) {
        if (centerFraction === void 0) {
          centerFraction = FROM_BL[ax.constraintoward || "center"];
        }
        var rangeLinear = [ax.r2l(ax.range[0]), ax.r2l(ax.range[1])];
        var center = rangeLinear[0] + (rangeLinear[1] - rangeLinear[0]) * centerFraction;
        ax.range = ax._input.range = [
          ax.l2r(center + (rangeLinear[0] - center) * factor),
          ax.l2r(center + (rangeLinear[1] - center) * factor)
        ];
        ax.setScale();
      };
    }
  });

  // src/plots/cartesian/constraints.js
  var require_constraints = __commonJS({
    "src/plots/cartesian/constraints.js"(exports) {
      "use strict";
      var Lib = require_lib();
      var autorange = require_autorange();
      var id2name = require_axis_ids().id2name;
      var layoutAttributes = require_layout_attributes4();
      var scaleZoom = require_scale_zoom();
      var setConvert = require_set_convert();
      var ALMOST_EQUAL = require_numerical().ALMOST_EQUAL;
      var FROM_BL = require_alignment().FROM_BL;
      exports.handleDefaults = function(layoutIn, layoutOut, opts) {
        var axIds = opts.axIds;
        var axHasImage = opts.axHasImage;
        var constraintGroups = layoutOut._axisConstraintGroups = [];
        var matchGroups = layoutOut._axisMatchGroups = [];
        var i, group, axId, axName, axIn, axOut, attr, val;
        for (i = 0; i < axIds.length; i++) {
          axName = id2name(axIds[i]);
          axIn = layoutIn[axName];
          axOut = layoutOut[axName];
          handleOneAxDefaults(axIn, axOut, {
            axIds,
            layoutOut,
            hasImage: axHasImage[axName]
          });
        }
        function stash(groups, stashAttr) {
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            for (axId in group) {
              layoutOut[id2name(axId)][stashAttr] = group;
            }
          }
        }
        stash(matchGroups, "_matchGroup");
        for (i = 0; i < constraintGroups.length; i++) {
          group = constraintGroups[i];
          for (axId in group) {
            axOut = layoutOut[id2name(axId)];
            if (axOut.fixedrange) {
              for (var axId2 in group) {
                var axName2 = id2name(axId2);
                if ((layoutIn[axName2] || {}).fixedrange === false) {
                  Lib.warn(
                    "fixedrange was specified as false for axis " + axName2 + " but was overridden because another axis in its constraint group has fixedrange true"
                  );
                }
                layoutOut[axName2].fixedrange = true;
              }
              break;
            }
          }
        }
        i = 0;
        while (i < constraintGroups.length) {
          group = constraintGroups[i];
          for (axId in group) {
            axOut = layoutOut[id2name(axId)];
            if (axOut._matchGroup && Object.keys(axOut._matchGroup).length === Object.keys(group).length) {
              constraintGroups.splice(i, 1);
              i--;
            }
            break;
          }
          i++;
        }
        stash(constraintGroups, "_constraintGroup");
        var matchAttrs = [
          "constrain",
          "range",
          "autorange",
          "rangemode",
          "rangebreaks",
          "categoryorder",
          "categoryarray"
        ];
        var hasRange = false;
        var hasDayOfWeekBreaks = false;
        function setAttrVal() {
          val = axOut[attr];
          if (attr === "rangebreaks") {
            hasDayOfWeekBreaks = axOut._hasDayOfWeekBreaks;
          }
        }
        for (i = 0; i < matchGroups.length; i++) {
          group = matchGroups[i];
          for (var j = 0; j < matchAttrs.length; j++) {
            attr = matchAttrs[j];
            val = null;
            var baseAx;
            for (axId in group) {
              axName = id2name(axId);
              axIn = layoutIn[axName];
              axOut = layoutOut[axName];
              if (!(attr in axOut)) {
                continue;
              }
              if (!axOut.matches) {
                baseAx = axOut;
                if (attr in axIn) {
                  setAttrVal();
                  break;
                }
              }
              if (val === null && attr in axIn) {
                setAttrVal();
              }
            }
            if (attr === "range" && val && axIn.range && axIn.range.length === 2 && axIn.range[0] !== null && axIn.range[1] !== null) {
              hasRange = true;
            }
            if (attr === "autorange" && val === null && hasRange) {
              val = false;
            }
            if (val === null && attr in baseAx) {
              val = baseAx[attr];
            }
            if (val !== null) {
              for (axId in group) {
                axOut = layoutOut[id2name(axId)];
                axOut[attr] = attr === "range" ? val.slice() : val;
                if (attr === "rangebreaks") {
                  axOut._hasDayOfWeekBreaks = hasDayOfWeekBreaks;
                  setConvert(axOut, layoutOut);
                }
              }
            }
          }
        }
      };
      function handleOneAxDefaults(axIn, axOut, opts) {
        var axIds = opts.axIds;
        var layoutOut = opts.layoutOut;
        var hasImage = opts.hasImage;
        var constraintGroups = layoutOut._axisConstraintGroups;
        var matchGroups = layoutOut._axisMatchGroups;
        var axId = axOut._id;
        var axLetter = axId.charAt(0);
        var splomStash = ((layoutOut._splomAxes || {})[axLetter] || {})[axId] || {};
        var thisID = axOut._id;
        var isX = thisID.charAt(0) === "x";
        axOut._matchGroup = null;
        axOut._constraintGroup = null;
        function coerce(attr, dflt) {
          return Lib.coerce(axIn, axOut, layoutAttributes, attr, dflt);
        }
        coerce("constrain", hasImage ? "domain" : "range");
        Lib.coerce(axIn, axOut, {
          constraintoward: {
            valType: "enumerated",
            values: isX ? ["left", "center", "right"] : ["bottom", "middle", "top"],
            dflt: isX ? "center" : "middle"
          }
        }, "constraintoward");
        var thisType = axOut.type;
        var i, idi;
        var linkableAxes = [];
        for (i = 0; i < axIds.length; i++) {
          idi = axIds[i];
          if (idi === thisID) continue;
          var axi = layoutOut[id2name(idi)];
          if (axi.type === thisType) {
            linkableAxes.push(idi);
          }
        }
        var thisGroup = getConstraintGroup(constraintGroups, thisID);
        if (thisGroup) {
          var linkableAxesNoLoops = [];
          for (i = 0; i < linkableAxes.length; i++) {
            idi = linkableAxes[i];
            if (!thisGroup[idi]) linkableAxesNoLoops.push(idi);
          }
          linkableAxes = linkableAxesNoLoops;
        }
        var canLink = linkableAxes.length;
        var matches, scaleanchor;
        if (canLink && (axIn.matches || splomStash.matches)) {
          matches = Lib.coerce(axIn, axOut, {
            matches: {
              valType: "enumerated",
              values: linkableAxes,
              dflt: linkableAxes.indexOf(splomStash.matches) !== -1 ? splomStash.matches : void 0
            }
          }, "matches");
        }
        var scaleanchorDflt = hasImage && !isX ? axOut.anchor : void 0;
        if (canLink && !matches && (axIn.scaleanchor || scaleanchorDflt)) {
          scaleanchor = Lib.coerce(axIn, axOut, {
            scaleanchor: {
              valType: "enumerated",
              values: linkableAxes.concat([false])
            }
          }, "scaleanchor", scaleanchorDflt);
        }
        if (matches) {
          axOut._matchGroup = updateConstraintGroups(matchGroups, thisID, matches, 1);
          var matchedAx = layoutOut[id2name(matches)];
          var matchRatio = extent(layoutOut, axOut) / extent(layoutOut, matchedAx);
          if (isX !== (matches.charAt(0) === "x")) {
            matchRatio = (isX ? "x" : "y") + matchRatio;
          }
          updateConstraintGroups(constraintGroups, thisID, matches, matchRatio);
        } else if (axIn.matches && axIds.indexOf(axIn.matches) !== -1) {
          Lib.warn("ignored " + axOut._name + '.matches: "' + axIn.matches + '" to avoid an infinite loop');
        }
        if (scaleanchor) {
          var scaleratio = coerce("scaleratio");
          if (!scaleratio) scaleratio = axOut.scaleratio = 1;
          updateConstraintGroups(constraintGroups, thisID, scaleanchor, scaleratio);
        } else if (axIn.scaleanchor && axIds.indexOf(axIn.scaleanchor) !== -1) {
          Lib.warn("ignored " + axOut._name + '.scaleanchor: "' + axIn.scaleanchor + '" to avoid either an infinite loop and possibly inconsistent scaleratios, or because this axis declares a *matches* constraint.');
        }
      }
      function extent(layoutOut, ax) {
        var domain = ax.domain;
        if (!domain) {
          domain = layoutOut[id2name(ax.overlaying)].domain;
        }
        return domain[1] - domain[0];
      }
      function getConstraintGroup(groups, thisID) {
        for (var i = 0; i < groups.length; i++) {
          if (groups[i][thisID]) {
            return groups[i];
          }
        }
        return null;
      }
      function updateConstraintGroups(constraintGroups, thisID, thatID, scaleratio) {
        var i, j, groupi, keyj, thisGroupIndex;
        var thisGroup = getConstraintGroup(constraintGroups, thisID);
        if (thisGroup === null) {
          thisGroup = {};
          thisGroup[thisID] = 1;
          thisGroupIndex = constraintGroups.length;
          constraintGroups.push(thisGroup);
        } else {
          thisGroupIndex = constraintGroups.indexOf(thisGroup);
        }
        var thisGroupKeys = Object.keys(thisGroup);
        for (i = 0; i < constraintGroups.length; i++) {
          groupi = constraintGroups[i];
          if (i !== thisGroupIndex && groupi[thatID]) {
            var baseScale = groupi[thatID];
            for (j = 0; j < thisGroupKeys.length; j++) {
              keyj = thisGroupKeys[j];
              groupi[keyj] = multiplyScales(baseScale, multiplyScales(scaleratio, thisGroup[keyj]));
            }
            constraintGroups.splice(thisGroupIndex, 1);
            return;
          }
        }
        if (scaleratio !== 1) {
          for (j = 0; j < thisGroupKeys.length; j++) {
            var key = thisGroupKeys[j];
            thisGroup[key] = multiplyScales(scaleratio, thisGroup[key]);
          }
        }
        thisGroup[thatID] = 1;
      }
      function multiplyScales(a, b) {
        var aPrefix = "";
        var bPrefix = "";
        var aLen, bLen;
        if (typeof a === "string") {
          aPrefix = a.match(/^[xy]*/)[0];
          aLen = aPrefix.length;
          a = +a.substr(aLen);
        }
        if (typeof b === "string") {
          bPrefix = b.match(/^[xy]*/)[0];
          bLen = bPrefix.length;
          b = +b.substr(bLen);
        }
        var c = a * b;
        if (!aLen && !bLen) {
          return c;
        }
        if (!aLen || !bLen || aPrefix.charAt(0) === bPrefix.charAt(0)) {
          return aPrefix + bPrefix + a * b;
        }
        if (aLen === bLen) {
          return c;
        }
        return (aLen > bLen ? aPrefix.substr(bLen) : bPrefix.substr(aLen)) + c;
      }
      function finalRatios(group, fullLayout) {
        var size = fullLayout._size;
        var yRatio = size.h / size.w;
        var out = {};
        var keys = Object.keys(group);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var val = group[key];
          if (typeof val === "string") {
            var prefix = val.match(/^[xy]*/)[0];
            var pLen = prefix.length;
            val = +val.substr(pLen);
            var mult = prefix.charAt(0) === "y" ? yRatio : 1 / yRatio;
            for (var j = 0; j < pLen; j++) {
              val *= mult;
            }
          }
          out[key] = val;
        }
        return out;
      }
      exports.enforce = function enforce(gd) {
        var fullLayout = gd._fullLayout;
        var constraintGroups = fullLayout._axisConstraintGroups || [];
        var i, j, group, axisID, ax, normScale, mode, factor;
        for (i = 0; i < constraintGroups.length; i++) {
          group = finalRatios(constraintGroups[i], fullLayout);
          var axisIDs = Object.keys(group);
          var minScale = Infinity;
          var maxScale = 0;
          var matchScale = Infinity;
          var normScales = {};
          var axes = {};
          var hasAnyDomainConstraint = false;
          for (j = 0; j < axisIDs.length; j++) {
            axisID = axisIDs[j];
            axes[axisID] = ax = fullLayout[id2name(axisID)];
            if (ax._inputDomain) ax.domain = ax._inputDomain.slice();
            else ax._inputDomain = ax.domain.slice();
            if (!ax._inputRange) ax._inputRange = ax.range.slice();
            ax.setScale();
            normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];
            minScale = Math.min(minScale, normScale);
            if (ax.constrain === "domain" || !ax._constraintShrinkable) {
              matchScale = Math.min(matchScale, normScale);
            }
            delete ax._constraintShrinkable;
            maxScale = Math.max(maxScale, normScale);
            if (ax.constrain === "domain") hasAnyDomainConstraint = true;
          }
          if (minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue;
          for (j = 0; j < axisIDs.length; j++) {
            axisID = axisIDs[j];
            normScale = normScales[axisID];
            ax = axes[axisID];
            mode = ax.constrain;
            if (normScale !== matchScale || mode === "domain") {
              factor = normScale / matchScale;
              if (mode === "range") {
                scaleZoom(ax, factor);
              } else {
                var inputDomain = ax._inputDomain;
                var domainShrunk = (ax.domain[1] - ax.domain[0]) / (inputDomain[1] - inputDomain[0]);
                var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) / (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));
                factor /= domainShrunk;
                if (factor * rangeShrunk < 1) {
                  ax.domain = ax._input.domain = inputDomain.slice();
                  scaleZoom(ax, factor);
                  continue;
                }
                if (rangeShrunk < 1) {
                  ax.range = ax._input.range = ax._inputRange.slice();
                  factor *= rangeShrunk;
                }
                if (ax.autorange) {
                  var rl0 = ax.r2l(ax.range[0]);
                  var rl1 = ax.r2l(ax.range[1]);
                  var rangeCenter = (rl0 + rl1) / 2;
                  var rangeMin = rangeCenter;
                  var rangeMax = rangeCenter;
                  var halfRange = Math.abs(rl1 - rangeCenter);
                  var outerMin = rangeCenter - halfRange * factor * 1.0001;
                  var outerMax = rangeCenter + halfRange * factor * 1.0001;
                  var getPadMin = autorange.makePadFn(fullLayout, ax, 0);
                  var getPadMax = autorange.makePadFn(fullLayout, ax, 1);
                  updateDomain(ax, factor);
                  var m = Math.abs(ax._m);
                  var extremes = autorange.concatExtremes(gd, ax);
                  var minArray = extremes.min;
                  var maxArray = extremes.max;
                  var newVal;
                  var k;
                  for (k = 0; k < minArray.length; k++) {
                    newVal = minArray[k].val - getPadMin(minArray[k]) / m;
                    if (newVal > outerMin && newVal < rangeMin) {
                      rangeMin = newVal;
                    }
                  }
                  for (k = 0; k < maxArray.length; k++) {
                    newVal = maxArray[k].val + getPadMax(maxArray[k]) / m;
                    if (newVal < outerMax && newVal > rangeMax) {
                      rangeMax = newVal;
                    }
                  }
                  var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);
                  factor /= domainExpand;
                  rangeMin = ax.l2r(rangeMin);
                  rangeMax = ax.l2r(rangeMax);
                  ax.range = ax._input.range = rl0 < rl1 ? [rangeMin, rangeMax] : [rangeMax, rangeMin];
                }
                updateDomain(ax, factor);
              }
            }
          }
        }
      };
      exports.getAxisGroup = function getAxisGroup(fullLayout, axId) {
        var matchGroups = fullLayout._axisMatchGroups;
        for (var i = 0; i < matchGroups.length; i++) {
          var group = matchGroups[i];
          if (group[axId]) return "g" + i;
        }
        return axId;
      };
      exports.clean = function clean(gd, ax) {
        if (ax._inputDomain) {
          var isConstrained = false;
          var axId = ax._id;
          var constraintGroups = gd._fullLayout._axisConstraintGroups;
          for (var j = 0; j < constraintGroups.length; j++) {
            if (constraintGroups[j][axId]) {
              isConstrained = true;
              break;
            }
          }
          if (!isConstrained || ax.constrain !== "domain") {
            ax._input.domain = ax.domain = ax._inputDomain;
            delete ax._inputDomain;
          }
        }
      };
      function updateDomain(ax, factor) {
        var inputDomain = ax._inputDomain;
        var centerFraction = FROM_BL[ax.constraintoward];
        var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;
        ax.domain = ax._input.domain = [
          center + (inputDomain[0] - center) / factor,
          center + (inputDomain[1] - center) / factor
        ];
        ax.setScale();
      }
    }
  });

  // src/plot_api/subroutines.js
  var require_subroutines = __commonJS({
    "src/plot_api/subroutines.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Lib = require_lib();
      var svgTextUtils = require_svg_text_utils();
      var clearGlCanvases = require_clear_gl_canvases();
      var Color = require_color();
      var Drawing = require_drawing();
      var Titles = require_titles();
      var ModeBar = require_modebar2();
      var Axes = require_axes();
      var alignmentConstants = require_alignment();
      var axisConstraints = require_constraints();
      var enforceAxisConstraints = axisConstraints.enforce;
      var cleanAxisConstraints = axisConstraints.clean;
      var doAutoRange = require_autorange().doAutoRange;
      var SVG_TEXT_ANCHOR_START = "start";
      var SVG_TEXT_ANCHOR_MIDDLE = "middle";
      var SVG_TEXT_ANCHOR_END = "end";
      var zindexSeparator = require_constants2().zindexSeparator;
      exports.layoutStyles = function(gd) {
        return Lib.syncOrAsync([Plots.doAutoMargin, lsInner], gd);
      };
      function overlappingDomain(xDomain, yDomain, domains) {
        for (var i = 0; i < domains.length; i++) {
          var existingX = domains[i][0];
          var existingY = domains[i][1];
          if (existingX[0] >= xDomain[1] || existingX[1] <= xDomain[0]) {
            continue;
          }
          if (existingY[0] < yDomain[1] && existingY[1] > yDomain[0]) {
            return true;
          }
        }
        return false;
      }
      function lsInner(gd) {
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var pad = gs.p;
        var axList = Axes.list(gd, "", true);
        var i, subplot, plotinfo, ax, xa, ya;
        fullLayout._paperdiv.style({
          width: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroWidth && !gd.layout.width ? "100%" : fullLayout.width + "px",
          height: gd._context.responsive && fullLayout.autosize && !gd._context._hasZeroHeight && !gd.layout.height ? "100%" : fullLayout.height + "px"
        }).selectAll(".main-svg").call(Drawing.setSize, fullLayout.width, fullLayout.height);
        gd._context.setBackground(gd, fullLayout.paper_bgcolor);
        exports.drawMainTitle(gd);
        ModeBar.manage(gd);
        if (!fullLayout._has("cartesian")) {
          return Plots.previousPromises(gd);
        }
        function getLinePosition(ax2, counterAx2, side) {
          var lwHalf = ax2._lw / 2;
          if (ax2._id.charAt(0) === "x") {
            if (!counterAx2) return gs.t + gs.h * (1 - (ax2.position || 0)) + lwHalf % 1;
            else if (side === "top") return counterAx2._offset - pad - lwHalf;
            return counterAx2._offset + counterAx2._length + pad + lwHalf;
          }
          if (!counterAx2) return gs.l + gs.w * (ax2.position || 0) + lwHalf % 1;
          else if (side === "right") return counterAx2._offset + counterAx2._length + pad + lwHalf;
          return counterAx2._offset - pad - lwHalf;
        }
        for (i = 0; i < axList.length; i++) {
          ax = axList[i];
          var counterAx = ax._anchorAxis;
          ax._linepositions = {};
          ax._lw = Drawing.crispRound(gd, ax.linewidth, 1);
          ax._mainLinePosition = getLinePosition(ax, counterAx, ax.side);
          ax._mainMirrorPosition = ax.mirror && counterAx ? getLinePosition(
            ax,
            counterAx,
            alignmentConstants.OPPOSITE_SIDE[ax.side]
          ) : null;
        }
        var lowerBackgroundIDs = [];
        var backgroundIds = [];
        var lowerDomains = [];
        var noNeedForBg = Color.opacity(fullLayout.paper_bgcolor) === 1 && Color.opacity(fullLayout.plot_bgcolor) === 1 && fullLayout.paper_bgcolor === fullLayout.plot_bgcolor;
        for (subplot in fullLayout._plots) {
          plotinfo = fullLayout._plots[subplot];
          if (plotinfo.mainplot) {
            if (plotinfo.bg) {
              plotinfo.bg.remove();
            }
            plotinfo.bg = void 0;
          } else {
            var xDomain = plotinfo.xaxis.domain;
            var yDomain = plotinfo.yaxis.domain;
            var plotgroup = plotinfo.plotgroup;
            if (overlappingDomain(xDomain, yDomain, lowerDomains) && subplot.indexOf(zindexSeparator) === -1) {
              var pgNode = plotgroup.node();
              var plotgroupBg = plotinfo.bg = Lib.ensureSingle(plotgroup, "rect", "bg");
              pgNode.insertBefore(plotgroupBg.node(), pgNode.childNodes[0]);
              backgroundIds.push(subplot);
            } else {
              plotgroup.select("rect.bg").remove();
              lowerDomains.push([xDomain, yDomain]);
              if (!noNeedForBg) {
                lowerBackgroundIDs.push(subplot);
                backgroundIds.push(subplot);
              }
            }
          }
        }
        var lowerBackgrounds = fullLayout._bgLayer.selectAll(".bg").data(lowerBackgroundIDs);
        lowerBackgrounds.enter().append("rect").classed("bg", true);
        lowerBackgrounds.exit().remove();
        lowerBackgrounds.each(function(subplot2) {
          fullLayout._plots[subplot2].bg = d3.select(this);
        });
        for (i = 0; i < backgroundIds.length; i++) {
          plotinfo = fullLayout._plots[backgroundIds[i]];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          if (plotinfo.bg && xa._offset !== void 0 && ya._offset !== void 0) {
            plotinfo.bg.call(
              Drawing.setRect,
              xa._offset - pad,
              ya._offset - pad,
              xa._length + 2 * pad,
              ya._length + 2 * pad
            ).call(Color.fill, fullLayout.plot_bgcolor).style("stroke-width", 0);
          }
        }
        if (!fullLayout._hasOnlyLargeSploms) {
          for (subplot in fullLayout._plots) {
            plotinfo = fullLayout._plots[subplot];
            xa = plotinfo.xaxis;
            ya = plotinfo.yaxis;
            var clipId = plotinfo.clipId = "clip" + fullLayout._uid + subplot + "plot";
            var plotClip = Lib.ensureSingleById(fullLayout._clips, "clipPath", clipId, function(s) {
              s.classed("plotclip", true).append("rect");
            });
            plotinfo.clipRect = plotClip.select("rect").attr({
              width: xa._length,
              height: ya._length
            });
            Drawing.setTranslate(plotinfo.plot, xa._offset, ya._offset);
            var plotClipId;
            var layerClipId;
            if (plotinfo._hasClipOnAxisFalse) {
              plotClipId = null;
              layerClipId = clipId;
            } else {
              plotClipId = clipId;
              layerClipId = null;
            }
            Drawing.setClipUrl(plotinfo.plot, plotClipId, gd);
            plotinfo.layerClipId = layerClipId;
          }
        }
        var xLinesXLeft, xLinesXRight, xLinesYBottom, xLinesYTop, leftYLineWidth, rightYLineWidth;
        var yLinesYBottom, yLinesYTop, yLinesXLeft, yLinesXRight, connectYBottom, connectYTop;
        var extraSubplot;
        function xLinePath(y) {
          return "M" + xLinesXLeft + "," + y + "H" + xLinesXRight;
        }
        function xLinePathFree(y) {
          return "M" + xa._offset + "," + y + "h" + xa._length;
        }
        function yLinePath(x) {
          return "M" + x + "," + yLinesYTop + "V" + yLinesYBottom;
        }
        function yLinePathFree(x) {
          if (ya._shift !== void 0) {
            x += ya._shift;
          }
          return "M" + x + "," + ya._offset + "v" + ya._length;
        }
        function mainPath(ax2, pathFn, pathFnFree) {
          if (!ax2.showline || subplot !== ax2._mainSubplot) return "";
          if (!ax2._anchorAxis) return pathFnFree(ax2._mainLinePosition);
          var out = pathFn(ax2._mainLinePosition);
          if (ax2.mirror) out += pathFn(ax2._mainMirrorPosition);
          return out;
        }
        for (subplot in fullLayout._plots) {
          plotinfo = fullLayout._plots[subplot];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          var xPath = "M0,0";
          if (shouldShowLinesOrTicks(xa, subplot)) {
            leftYLineWidth = findCounterAxisLineWidth(xa, "left", ya, axList);
            xLinesXLeft = xa._offset - (leftYLineWidth ? pad + leftYLineWidth : 0);
            rightYLineWidth = findCounterAxisLineWidth(xa, "right", ya, axList);
            xLinesXRight = xa._offset + xa._length + (rightYLineWidth ? pad + rightYLineWidth : 0);
            xLinesYBottom = getLinePosition(xa, ya, "bottom");
            xLinesYTop = getLinePosition(xa, ya, "top");
            extraSubplot = !xa._anchorAxis || subplot !== xa._mainSubplot;
            if (extraSubplot && (xa.mirror === "allticks" || xa.mirror === "all")) {
              xa._linepositions[subplot] = [xLinesYBottom, xLinesYTop];
            }
            xPath = mainPath(xa, xLinePath, xLinePathFree);
            if (extraSubplot && xa.showline && (xa.mirror === "all" || xa.mirror === "allticks")) {
              xPath += xLinePath(xLinesYBottom) + xLinePath(xLinesYTop);
            }
            plotinfo.xlines.style("stroke-width", xa._lw + "px").call(Color.stroke, xa.showline ? xa.linecolor : "rgba(0,0,0,0)");
          }
          plotinfo.xlines.attr("d", xPath);
          var yPath = "M0,0";
          if (shouldShowLinesOrTicks(ya, subplot)) {
            connectYBottom = findCounterAxisLineWidth(ya, "bottom", xa, axList);
            yLinesYBottom = ya._offset + ya._length + (connectYBottom ? pad : 0);
            connectYTop = findCounterAxisLineWidth(ya, "top", xa, axList);
            yLinesYTop = ya._offset - (connectYTop ? pad : 0);
            yLinesXLeft = getLinePosition(ya, xa, "left");
            yLinesXRight = getLinePosition(ya, xa, "right");
            extraSubplot = !ya._anchorAxis || subplot !== ya._mainSubplot;
            if (extraSubplot && (ya.mirror === "allticks" || ya.mirror === "all")) {
              ya._linepositions[subplot] = [yLinesXLeft, yLinesXRight];
            }
            yPath = mainPath(ya, yLinePath, yLinePathFree);
            if (extraSubplot && ya.showline && (ya.mirror === "all" || ya.mirror === "allticks")) {
              yPath += yLinePath(yLinesXLeft) + yLinePath(yLinesXRight);
            }
            plotinfo.ylines.style("stroke-width", ya._lw + "px").call(Color.stroke, ya.showline ? ya.linecolor : "rgba(0,0,0,0)");
          }
          plotinfo.ylines.attr("d", yPath);
        }
        Axes.makeClipPaths(gd);
        return Plots.previousPromises(gd);
      }
      function shouldShowLinesOrTicks(ax, subplot) {
        return (ax.ticks || ax.showline) && (subplot === ax._mainSubplot || ax.mirror === "all" || ax.mirror === "allticks");
      }
      function shouldShowLineThisSide(ax, side, counterAx) {
        if (!counterAx.showline || !counterAx._lw) return false;
        if (counterAx.mirror === "all" || counterAx.mirror === "allticks") return true;
        var anchorAx = counterAx._anchorAxis;
        if (!anchorAx) return false;
        var sideIndex = alignmentConstants.FROM_BL[side];
        if (counterAx.side === side) {
          return anchorAx.domain[sideIndex] === ax.domain[sideIndex];
        }
        return counterAx.mirror && anchorAx.domain[1 - sideIndex] === ax.domain[1 - sideIndex];
      }
      function findCounterAxisLineWidth(ax, side, counterAx, axList) {
        if (shouldShowLineThisSide(ax, side, counterAx)) {
          return counterAx._lw;
        }
        for (var i = 0; i < axList.length; i++) {
          var axi = axList[i];
          if (axi._mainAxis === counterAx._mainAxis && shouldShowLineThisSide(ax, side, axi)) {
            return axi._lw;
          }
        }
        return 0;
      }
      exports.drawMainTitle = function(gd) {
        var title = gd._fullLayout.title;
        var fullLayout = gd._fullLayout;
        var textAnchor = getMainTitleTextAnchor(fullLayout);
        var dy = getMainTitleDy(fullLayout);
        var y = getMainTitleY(fullLayout, dy);
        var x = getMainTitleX(fullLayout, textAnchor);
        Titles.draw(gd, "gtitle", {
          propContainer: fullLayout,
          propName: "title.text",
          subtitlePropName: "title.subtitle.text",
          placeholder: fullLayout._dfltTitle.plot,
          subtitlePlaceholder: fullLayout._dfltTitle.subtitle,
          attributes: {
            x,
            y,
            "text-anchor": textAnchor,
            dy
          }
        });
        if (title.text && title.automargin) {
          var titleObj = d3.selectAll(".gtitle");
          var titleHeight = Drawing.bBox(d3.selectAll(".g-gtitle").node()).height;
          var pushMargin = needsMarginPush(gd, title, titleHeight);
          if (pushMargin > 0) {
            applyTitleAutoMargin(gd, y, pushMargin, titleHeight);
            titleObj.attr({
              x,
              y,
              "text-anchor": textAnchor,
              dy: getMainTitleDyAdj(title.yanchor)
            }).call(svgTextUtils.positionText, x, y);
            var extraLines = (title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
            if (extraLines) {
              var delta = alignmentConstants.LINE_SPACING * extraLines + alignmentConstants.MID_SHIFT;
              if (title.y === 0) {
                delta = -delta;
              }
              titleObj.selectAll(".line").each(function() {
                var newDy = +this.getAttribute("dy").slice(0, -2) - delta + "em";
                this.setAttribute("dy", newDy);
              });
            }
            var subtitleObj = d3.selectAll(".gtitle-subtitle");
            if (subtitleObj.node()) {
              var titleBB = titleObj.node().getBBox();
              var titleBottom = titleBB.y + titleBB.height;
              var subtitleY = titleBottom + Titles.SUBTITLE_PADDING_EM * title.subtitle.font.size;
              subtitleObj.attr({
                x,
                y: subtitleY,
                "text-anchor": textAnchor,
                dy: getMainTitleDyAdj(title.yanchor)
              }).call(svgTextUtils.positionText, x, subtitleY);
            }
          }
        }
      };
      function isOutsideContainer(gd, title, position, y, titleHeight) {
        var plotHeight = title.yref === "paper" ? gd._fullLayout._size.h : gd._fullLayout.height;
        var yPosTop = Lib.isTopAnchor(title) ? y : y - titleHeight;
        var yPosRel = position === "b" ? plotHeight - yPosTop : yPosTop;
        if (Lib.isTopAnchor(title) && position === "t" || Lib.isBottomAnchor(title) && position === "b") {
          return false;
        } else {
          return yPosRel < titleHeight;
        }
      }
      function containerPushVal(position, titleY, titleYanchor, height, titleDepth) {
        var push = 0;
        if (titleYanchor === "middle") {
          push += titleDepth / 2;
        }
        if (position === "t") {
          if (titleYanchor === "top") {
            push += titleDepth;
          }
          push += height - titleY * height;
        } else {
          if (titleYanchor === "bottom") {
            push += titleDepth;
          }
          push += titleY * height;
        }
        return push;
      }
      function needsMarginPush(gd, title, titleHeight) {
        var titleY = title.y;
        var titleYanchor = title.yanchor;
        var position = titleY > 0.5 ? "t" : "b";
        var curMargin = gd._fullLayout.margin[position];
        var pushMargin = 0;
        if (title.yref === "paper") {
          pushMargin = titleHeight + title.pad.t + title.pad.b;
        } else if (title.yref === "container") {
          pushMargin = containerPushVal(position, titleY, titleYanchor, gd._fullLayout.height, titleHeight) + title.pad.t + title.pad.b;
        }
        if (pushMargin > curMargin) {
          return pushMargin;
        }
        return 0;
      }
      function applyTitleAutoMargin(gd, y, pushMargin, titleHeight) {
        var titleID = "title.automargin";
        var title = gd._fullLayout.title;
        var position = title.y > 0.5 ? "t" : "b";
        var push = {
          x: title.x,
          y: title.y,
          t: 0,
          b: 0
        };
        var reservedPush = {};
        if (title.yref === "paper" && isOutsideContainer(gd, title, position, y, titleHeight)) {
          push[position] = pushMargin;
        } else if (title.yref === "container") {
          reservedPush[position] = pushMargin;
          gd._fullLayout._reservedMargin[titleID] = reservedPush;
        }
        Plots.allowAutoMargin(gd, titleID);
        Plots.autoMargin(gd, titleID, push);
      }
      function getMainTitleX(fullLayout, textAnchor) {
        var title = fullLayout.title;
        var gs = fullLayout._size;
        var hPadShift = 0;
        if (textAnchor === SVG_TEXT_ANCHOR_START) {
          hPadShift = title.pad.l;
        } else if (textAnchor === SVG_TEXT_ANCHOR_END) {
          hPadShift = -title.pad.r;
        }
        switch (title.xref) {
          case "paper":
            return gs.l + gs.w * title.x + hPadShift;
          case "container":
          default:
            return fullLayout.width * title.x + hPadShift;
        }
      }
      function getMainTitleY(fullLayout, dy) {
        var title = fullLayout.title;
        var gs = fullLayout._size;
        var vPadShift = 0;
        if (dy === "0em" || !dy) {
          vPadShift = -title.pad.b;
        } else if (dy === alignmentConstants.CAP_SHIFT + "em") {
          vPadShift = title.pad.t;
        }
        if (title.y === "auto") {
          return gs.t / 2;
        } else {
          switch (title.yref) {
            case "paper":
              return gs.t + gs.h - gs.h * title.y + vPadShift;
            case "container":
            default:
              return fullLayout.height - fullLayout.height * title.y + vPadShift;
          }
        }
      }
      function getMainTitleDyAdj(yanchor) {
        if (yanchor === "top") {
          return alignmentConstants.CAP_SHIFT + 0.3 + "em";
        } else if (yanchor === "bottom") {
          return "-0.3em";
        } else {
          return alignmentConstants.MID_SHIFT + "em";
        }
      }
      function getMainTitleTextAnchor(fullLayout) {
        var title = fullLayout.title;
        var textAnchor = SVG_TEXT_ANCHOR_MIDDLE;
        if (Lib.isRightAnchor(title)) {
          textAnchor = SVG_TEXT_ANCHOR_END;
        } else if (Lib.isLeftAnchor(title)) {
          textAnchor = SVG_TEXT_ANCHOR_START;
        }
        return textAnchor;
      }
      function getMainTitleDy(fullLayout) {
        var title = fullLayout.title;
        var dy = "0em";
        if (Lib.isTopAnchor(title)) {
          dy = alignmentConstants.CAP_SHIFT + "em";
        } else if (Lib.isMiddleAnchor(title)) {
          dy = alignmentConstants.MID_SHIFT + "em";
        }
        return dy;
      }
      exports.doTraceStyle = function(gd) {
        var calcdata = gd.calcdata;
        var editStyleCalls = [];
        var i;
        for (i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          var cd0 = cd[0] || {};
          var trace = cd0.trace || {};
          var _module = trace._module || {};
          var arraysToCalcdata = _module.arraysToCalcdata;
          if (arraysToCalcdata) arraysToCalcdata(cd, trace);
          var editStyle = _module.editStyle;
          if (editStyle) editStyleCalls.push({ fn: editStyle, cd0 });
        }
        if (editStyleCalls.length) {
          for (i = 0; i < editStyleCalls.length; i++) {
            var edit = editStyleCalls[i];
            edit.fn(gd, edit.cd0);
          }
          clearGlCanvases(gd);
          exports.redrawReglTraces(gd);
        }
        Plots.style(gd);
        Registry.getComponentMethod("legend", "draw")(gd);
        return Plots.previousPromises(gd);
      };
      exports.doColorBars = function(gd) {
        Registry.getComponentMethod("colorbar", "draw")(gd);
        return Plots.previousPromises(gd);
      };
      exports.layoutReplot = function(gd) {
        var layout = gd.layout;
        gd.layout = void 0;
        return Registry.call("_doPlot", gd, "", layout);
      };
      exports.doLegend = function(gd) {
        Registry.getComponentMethod("legend", "draw")(gd);
        return Plots.previousPromises(gd);
      };
      exports.doTicksRelayout = function(gd) {
        Axes.draw(gd, "redraw");
        if (gd._fullLayout._hasOnlyLargeSploms) {
          Registry.subplotsRegistry.splom.updateGrid(gd);
          clearGlCanvases(gd);
          exports.redrawReglTraces(gd);
        }
        exports.drawMainTitle(gd);
        return Plots.previousPromises(gd);
      };
      exports.doModeBar = function(gd) {
        var fullLayout = gd._fullLayout;
        ModeBar.manage(gd);
        for (var i = 0; i < fullLayout._basePlotModules.length; i++) {
          var updateFx = fullLayout._basePlotModules[i].updateFx;
          if (updateFx) updateFx(gd);
        }
        return Plots.previousPromises(gd);
      };
      exports.doCamera = function(gd) {
        var fullLayout = gd._fullLayout;
        var sceneIds = fullLayout._subplots.gl3d;
        for (var i = 0; i < sceneIds.length; i++) {
          var sceneLayout = fullLayout[sceneIds[i]];
          var scene = sceneLayout._scene;
          scene.setViewport(sceneLayout);
        }
      };
      exports.drawData = function(gd) {
        var fullLayout = gd._fullLayout;
        clearGlCanvases(gd);
        var basePlotModules = fullLayout._basePlotModules;
        for (var i = 0; i < basePlotModules.length; i++) {
          basePlotModules[i].plot(gd);
        }
        exports.redrawReglTraces(gd);
        Plots.style(gd);
        Registry.getComponentMethod("selections", "draw")(gd);
        Registry.getComponentMethod("shapes", "draw")(gd);
        Registry.getComponentMethod("annotations", "draw")(gd);
        Registry.getComponentMethod("images", "draw")(gd);
        fullLayout._replotting = false;
        return Plots.previousPromises(gd);
      };
      exports.redrawReglTraces = function(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._has("regl")) {
          var fullData = gd._fullData;
          var cartesianIds = [];
          var polarIds = [];
          var i, sp;
          if (fullLayout._hasOnlyLargeSploms) {
            fullLayout._splomGrid.draw();
          }
          for (i = 0; i < fullData.length; i++) {
            var trace = fullData[i];
            if (trace.visible === true && trace._length !== 0) {
              if (trace.type === "splom") {
                fullLayout._splomScenes[trace.uid].draw();
              } else if (trace.type === "scattergl") {
                Lib.pushUnique(cartesianIds, trace.xaxis + trace.yaxis);
              } else if (trace.type === "scatterpolargl") {
                Lib.pushUnique(polarIds, trace.subplot);
              }
            }
          }
          for (i = 0; i < cartesianIds.length; i++) {
            sp = fullLayout._plots[cartesianIds[i]];
            if (sp._scene) sp._scene.draw();
          }
          for (i = 0; i < polarIds.length; i++) {
            sp = fullLayout[polarIds[i]]._subplot;
            if (sp._scene) sp._scene.draw();
          }
        }
      };
      exports.doAutoRangeAndConstraints = function(gd) {
        var axList = Axes.list(gd, "", true);
        var ax;
        var autoRangeDone = {};
        for (var i = 0; i < axList.length; i++) {
          ax = axList[i];
          if (!autoRangeDone[ax._id]) {
            autoRangeDone[ax._id] = 1;
            cleanAxisConstraints(gd, ax);
            doAutoRange(gd, ax);
            var matchGroup = ax._matchGroup;
            if (matchGroup) {
              for (var id2 in matchGroup) {
                var ax2 = Axes.getFromId(gd, id2);
                doAutoRange(gd, ax2, ax.range);
                autoRangeDone[id2] = 1;
              }
            }
          }
        }
        enforceAxisConstraints(gd);
      };
      exports.finalDraw = function(gd) {
        Registry.getComponentMethod("rangeslider", "draw")(gd);
        Registry.getComponentMethod("rangeselector", "draw")(gd);
      };
      exports.drawMarginPushers = function(gd) {
        Registry.getComponentMethod("legend", "draw")(gd);
        Registry.getComponentMethod("rangeselector", "draw")(gd);
        Registry.getComponentMethod("sliders", "draw")(gd);
        Registry.getComponentMethod("updatemenus", "draw")(gd);
        Registry.getComponentMethod("colorbar", "draw")(gd);
      };
    }
  });

  // src/components/selections/draw.js
  var require_draw3 = __commonJS({
    "src/components/selections/draw.js"(exports, module) {
      "use strict";
      var readPaths = require_helpers7().readPaths;
      var displayOutlines = require_display_outlines();
      var clearOutlineControllers = require_handle_outline().clearOutlineControllers;
      var Color = require_color();
      var Drawing = require_drawing();
      var arrayEditor = require_plot_template().arrayEditor;
      var helpers = require_helpers8();
      var getPathString = helpers.getPathString;
      module.exports = {
        draw,
        drawOne,
        activateLastSelection
      };
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        clearOutlineControllers(gd);
        fullLayout._selectionLayer.selectAll("path").remove();
        for (var k in fullLayout._plots) {
          var selectionLayer = fullLayout._plots[k].selectionLayer;
          if (selectionLayer) selectionLayer.selectAll("path").remove();
        }
        for (var i = 0; i < fullLayout.selections.length; i++) {
          drawOne(gd, i);
        }
      }
      function couldHaveActiveSelection(gd) {
        return gd._context.editSelection;
      }
      function drawOne(gd, index) {
        gd._fullLayout._paperdiv.selectAll('.selectionlayer [data-index="' + index + '"]').remove();
        var o = helpers.makeSelectionsOptionsAndPlotinfo(gd, index);
        var options = o.options;
        var plotinfo = o.plotinfo;
        if (!options._input) return;
        drawSelection(gd._fullLayout._selectionLayer);
        function drawSelection(selectionLayer) {
          var d = getPathString(gd, options);
          var attrs = {
            "data-index": index,
            "fill-rule": "evenodd",
            d
          };
          var opacity = options.opacity;
          var fillColor = "rgba(0,0,0,0)";
          var lineColor = options.line.color || Color.contrast(gd._fullLayout.plot_bgcolor);
          var lineWidth = options.line.width;
          var lineDash = options.line.dash;
          if (!lineWidth) {
            lineWidth = 5;
            lineDash = "solid";
          }
          var isActiveSelection = couldHaveActiveSelection(gd) && gd._fullLayout._activeSelectionIndex === index;
          if (isActiveSelection) {
            fillColor = gd._fullLayout.activeselection.fillcolor;
            opacity = gd._fullLayout.activeselection.opacity;
          }
          var allPaths = [];
          for (var sensory = 1; sensory >= 0; sensory--) {
            var path = selectionLayer.append("path").attr(attrs).style("opacity", sensory ? 0.1 : opacity).call(Color.stroke, lineColor).call(Color.fill, fillColor).call(
              Drawing.dashLine,
              sensory ? "solid" : lineDash,
              sensory ? 4 + lineWidth : lineWidth
            );
            setClipPath(path, gd, options);
            if (isActiveSelection) {
              var editHelpers = arrayEditor(gd.layout, "selections", options);
              path.style({
                cursor: "move"
              });
              var dragOptions = {
                element: path.node(),
                plotinfo,
                gd,
                editHelpers,
                isActiveSelection: true
                // i.e. to enable controllers
              };
              var polygons = readPaths(d, gd);
              displayOutlines(polygons, path, dragOptions);
            } else {
              path.style("pointer-events", sensory ? "all" : "none");
            }
            allPaths[sensory] = path;
          }
          var forePath = allPaths[0];
          var backPath = allPaths[1];
          backPath.node().addEventListener("click", function() {
            return activateSelection(gd, forePath);
          });
        }
      }
      function setClipPath(selectionPath, gd, selectionOptions) {
        var clipAxes = selectionOptions.xref + selectionOptions.yref;
        Drawing.setClipUrl(
          selectionPath,
          "clip" + gd._fullLayout._uid + clipAxes,
          gd
        );
      }
      function activateSelection(gd, path) {
        if (!couldHaveActiveSelection(gd)) return;
        var element = path.node();
        var id = +element.getAttribute("data-index");
        if (id >= 0) {
          if (id === gd._fullLayout._activeSelectionIndex) {
            deactivateSelection(gd);
            return;
          }
          gd._fullLayout._activeSelectionIndex = id;
          gd._fullLayout._deactivateSelection = deactivateSelection;
          draw(gd);
        }
      }
      function activateLastSelection(gd) {
        if (!couldHaveActiveSelection(gd)) return;
        var id = gd._fullLayout.selections.length - 1;
        gd._fullLayout._activeSelectionIndex = id;
        gd._fullLayout._deactivateSelection = deactivateSelection;
        draw(gd);
      }
      function deactivateSelection(gd) {
        if (!couldHaveActiveSelection(gd)) return;
        var id = gd._fullLayout._activeSelectionIndex;
        if (id >= 0) {
          clearOutlineControllers(gd);
          delete gd._fullLayout._activeSelectionIndex;
          draw(gd);
        }
      }
    }
  });

  // node_modules/polybooljs/lib/build-log.js
  var require_build_log = __commonJS({
    "node_modules/polybooljs/lib/build-log.js"(exports, module) {
      function BuildLog() {
        var my;
        var nextSegmentId = 0;
        var curVert = false;
        function push(type, data) {
          my.list.push({
            type,
            data: data ? JSON.parse(JSON.stringify(data)) : void 0
          });
          return my;
        }
        my = {
          list: [],
          segmentId: function() {
            return nextSegmentId++;
          },
          checkIntersection: function(seg1, seg2) {
            return push("check", { seg1, seg2 });
          },
          segmentChop: function(seg, end) {
            push("div_seg", { seg, pt: end });
            return push("chop", { seg, pt: end });
          },
          statusRemove: function(seg) {
            return push("pop_seg", { seg });
          },
          segmentUpdate: function(seg) {
            return push("seg_update", { seg });
          },
          segmentNew: function(seg, primary) {
            return push("new_seg", { seg, primary });
          },
          segmentRemove: function(seg) {
            return push("rem_seg", { seg });
          },
          tempStatus: function(seg, above, below) {
            return push("temp_status", { seg, above, below });
          },
          rewind: function(seg) {
            return push("rewind", { seg });
          },
          status: function(seg, above, below) {
            return push("status", { seg, above, below });
          },
          vert: function(x) {
            if (x === curVert)
              return my;
            curVert = x;
            return push("vert", { x });
          },
          log: function(data) {
            if (typeof data !== "string")
              data = JSON.stringify(data, false, "  ");
            return push("log", { txt: data });
          },
          reset: function() {
            return push("reset");
          },
          selected: function(segs) {
            return push("selected", { segs });
          },
          chainStart: function(seg) {
            return push("chain_start", { seg });
          },
          chainRemoveHead: function(index, pt) {
            return push("chain_rem_head", { index, pt });
          },
          chainRemoveTail: function(index, pt) {
            return push("chain_rem_tail", { index, pt });
          },
          chainNew: function(pt1, pt2) {
            return push("chain_new", { pt1, pt2 });
          },
          chainMatch: function(index) {
            return push("chain_match", { index });
          },
          chainClose: function(index) {
            return push("chain_close", { index });
          },
          chainAddHead: function(index, pt) {
            return push("chain_add_head", { index, pt });
          },
          chainAddTail: function(index, pt) {
            return push("chain_add_tail", { index, pt });
          },
          chainConnect: function(index1, index2) {
            return push("chain_con", { index1, index2 });
          },
          chainReverse: function(index) {
            return push("chain_rev", { index });
          },
          chainJoin: function(index1, index2) {
            return push("chain_join", { index1, index2 });
          },
          done: function() {
            return push("done");
          }
        };
        return my;
      }
      module.exports = BuildLog;
    }
  });

  // node_modules/polybooljs/lib/epsilon.js
  var require_epsilon = __commonJS({
    "node_modules/polybooljs/lib/epsilon.js"(exports, module) {
      function Epsilon(eps) {
        if (typeof eps !== "number")
          eps = 1e-10;
        var my = {
          epsilon: function(v) {
            if (typeof v === "number")
              eps = v;
            return eps;
          },
          pointAboveOrOnLine: function(pt, left, right) {
            var Ax = left[0];
            var Ay = left[1];
            var Bx = right[0];
            var By = right[1];
            var Cx = pt[0];
            var Cy = pt[1];
            return (Bx - Ax) * (Cy - Ay) - (By - Ay) * (Cx - Ax) >= -eps;
          },
          pointBetween: function(p, left, right) {
            var d_py_ly = p[1] - left[1];
            var d_rx_lx = right[0] - left[0];
            var d_px_lx = p[0] - left[0];
            var d_ry_ly = right[1] - left[1];
            var dot = d_px_lx * d_rx_lx + d_py_ly * d_ry_ly;
            if (dot < eps)
              return false;
            var sqlen = d_rx_lx * d_rx_lx + d_ry_ly * d_ry_ly;
            if (dot - sqlen > -eps)
              return false;
            return true;
          },
          pointsSameX: function(p1, p2) {
            return Math.abs(p1[0] - p2[0]) < eps;
          },
          pointsSameY: function(p1, p2) {
            return Math.abs(p1[1] - p2[1]) < eps;
          },
          pointsSame: function(p1, p2) {
            return my.pointsSameX(p1, p2) && my.pointsSameY(p1, p2);
          },
          pointsCompare: function(p1, p2) {
            if (my.pointsSameX(p1, p2))
              return my.pointsSameY(p1, p2) ? 0 : p1[1] < p2[1] ? -1 : 1;
            return p1[0] < p2[0] ? -1 : 1;
          },
          pointsCollinear: function(pt1, pt2, pt3) {
            var dx1 = pt1[0] - pt2[0];
            var dy1 = pt1[1] - pt2[1];
            var dx2 = pt2[0] - pt3[0];
            var dy2 = pt2[1] - pt3[1];
            return Math.abs(dx1 * dy2 - dx2 * dy1) < eps;
          },
          linesIntersect: function(a0, a1, b0, b1) {
            var adx = a1[0] - a0[0];
            var ady = a1[1] - a0[1];
            var bdx = b1[0] - b0[0];
            var bdy = b1[1] - b0[1];
            var axb = adx * bdy - ady * bdx;
            if (Math.abs(axb) < eps)
              return false;
            var dx = a0[0] - b0[0];
            var dy = a0[1] - b0[1];
            var A = (bdx * dy - bdy * dx) / axb;
            var B = (adx * dy - ady * dx) / axb;
            var ret = {
              alongA: 0,
              alongB: 0,
              pt: [
                a0[0] + A * adx,
                a0[1] + A * ady
              ]
            };
            if (A <= -eps)
              ret.alongA = -2;
            else if (A < eps)
              ret.alongA = -1;
            else if (A - 1 <= -eps)
              ret.alongA = 0;
            else if (A - 1 < eps)
              ret.alongA = 1;
            else
              ret.alongA = 2;
            if (B <= -eps)
              ret.alongB = -2;
            else if (B < eps)
              ret.alongB = -1;
            else if (B - 1 <= -eps)
              ret.alongB = 0;
            else if (B - 1 < eps)
              ret.alongB = 1;
            else
              ret.alongB = 2;
            return ret;
          },
          pointInsideRegion: function(pt, region) {
            var x = pt[0];
            var y = pt[1];
            var last_x = region[region.length - 1][0];
            var last_y = region[region.length - 1][1];
            var inside = false;
            for (var i = 0; i < region.length; i++) {
              var curr_x = region[i][0];
              var curr_y = region[i][1];
              if (curr_y - y > eps != last_y - y > eps && (last_x - curr_x) * (y - curr_y) / (last_y - curr_y) + curr_x - x > eps)
                inside = !inside;
              last_x = curr_x;
              last_y = curr_y;
            }
            return inside;
          }
        };
        return my;
      }
      module.exports = Epsilon;
    }
  });

  // node_modules/polybooljs/lib/linked-list.js
  var require_linked_list = __commonJS({
    "node_modules/polybooljs/lib/linked-list.js"(exports, module) {
      var LinkedList = {
        create: function() {
          var my = {
            root: { root: true, next: null },
            exists: function(node) {
              if (node === null || node === my.root)
                return false;
              return true;
            },
            isEmpty: function() {
              return my.root.next === null;
            },
            getHead: function() {
              return my.root.next;
            },
            insertBefore: function(node, check) {
              var last = my.root;
              var here = my.root.next;
              while (here !== null) {
                if (check(here)) {
                  node.prev = here.prev;
                  node.next = here;
                  here.prev.next = node;
                  here.prev = node;
                  return;
                }
                last = here;
                here = here.next;
              }
              last.next = node;
              node.prev = last;
              node.next = null;
            },
            findTransition: function(check) {
              var prev = my.root;
              var here = my.root.next;
              while (here !== null) {
                if (check(here))
                  break;
                prev = here;
                here = here.next;
              }
              return {
                before: prev === my.root ? null : prev,
                after: here,
                insert: function(node) {
                  node.prev = prev;
                  node.next = here;
                  prev.next = node;
                  if (here !== null)
                    here.prev = node;
                  return node;
                }
              };
            }
          };
          return my;
        },
        node: function(data) {
          data.prev = null;
          data.next = null;
          data.remove = function() {
            data.prev.next = data.next;
            if (data.next)
              data.next.prev = data.prev;
            data.prev = null;
            data.next = null;
          };
          return data;
        }
      };
      module.exports = LinkedList;
    }
  });

  // node_modules/polybooljs/lib/intersecter.js
  var require_intersecter = __commonJS({
    "node_modules/polybooljs/lib/intersecter.js"(exports, module) {
      var LinkedList = require_linked_list();
      function Intersecter(selfIntersection, eps, buildLog) {
        function segmentNew(start, end) {
          return {
            id: buildLog ? buildLog.segmentId() : -1,
            start,
            end,
            myFill: {
              above: null,
              // is there fill above us?
              below: null
              // is there fill below us?
            },
            otherFill: null
          };
        }
        function segmentCopy(start, end, seg) {
          return {
            id: buildLog ? buildLog.segmentId() : -1,
            start,
            end,
            myFill: {
              above: seg.myFill.above,
              below: seg.myFill.below
            },
            otherFill: null
          };
        }
        var event_root = LinkedList.create();
        function eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2) {
          var comp = eps.pointsCompare(p1_1, p2_1);
          if (comp !== 0)
            return comp;
          if (eps.pointsSame(p1_2, p2_2))
            return 0;
          if (p1_isStart !== p2_isStart)
            return p1_isStart ? 1 : -1;
          return eps.pointAboveOrOnLine(
            p1_2,
            p2_isStart ? p2_1 : p2_2,
            // order matters
            p2_isStart ? p2_2 : p2_1
          ) ? 1 : -1;
        }
        function eventAdd(ev, other_pt) {
          event_root.insertBefore(ev, function(here) {
            var comp = eventCompare(
              ev.isStart,
              ev.pt,
              other_pt,
              here.isStart,
              here.pt,
              here.other.pt
            );
            return comp < 0;
          });
        }
        function eventAddSegmentStart(seg, primary) {
          var ev_start = LinkedList.node({
            isStart: true,
            pt: seg.start,
            seg,
            primary,
            other: null,
            status: null
          });
          eventAdd(ev_start, seg.end);
          return ev_start;
        }
        function eventAddSegmentEnd(ev_start, seg, primary) {
          var ev_end = LinkedList.node({
            isStart: false,
            pt: seg.end,
            seg,
            primary,
            other: ev_start,
            status: null
          });
          ev_start.other = ev_end;
          eventAdd(ev_end, ev_start.pt);
        }
        function eventAddSegment(seg, primary) {
          var ev_start = eventAddSegmentStart(seg, primary);
          eventAddSegmentEnd(ev_start, seg, primary);
          return ev_start;
        }
        function eventUpdateEnd(ev, end) {
          if (buildLog)
            buildLog.segmentChop(ev.seg, end);
          ev.other.remove();
          ev.seg.end = end;
          ev.other.pt = end;
          eventAdd(ev.other, ev.pt);
        }
        function eventDivide(ev, pt) {
          var ns = segmentCopy(pt, ev.seg.end, ev.seg);
          eventUpdateEnd(ev, pt);
          return eventAddSegment(ns, ev.primary);
        }
        function calculate(primaryPolyInverted, secondaryPolyInverted) {
          var status_root = LinkedList.create();
          function statusCompare(ev1, ev2) {
            var a1 = ev1.seg.start;
            var a2 = ev1.seg.end;
            var b1 = ev2.seg.start;
            var b2 = ev2.seg.end;
            if (eps.pointsCollinear(a1, b1, b2)) {
              if (eps.pointsCollinear(a2, b1, b2))
                return 1;
              return eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;
            }
            return eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;
          }
          function statusFindSurrounding(ev2) {
            return status_root.findTransition(function(here) {
              var comp = statusCompare(ev2, here.ev);
              return comp > 0;
            });
          }
          function checkIntersection(ev1, ev2) {
            var seg1 = ev1.seg;
            var seg2 = ev2.seg;
            var a1 = seg1.start;
            var a2 = seg1.end;
            var b1 = seg2.start;
            var b2 = seg2.end;
            if (buildLog)
              buildLog.checkIntersection(seg1, seg2);
            var i = eps.linesIntersect(a1, a2, b1, b2);
            if (i === false) {
              if (!eps.pointsCollinear(a1, a2, b1))
                return false;
              if (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))
                return false;
              var a1_equ_b1 = eps.pointsSame(a1, b1);
              var a2_equ_b2 = eps.pointsSame(a2, b2);
              if (a1_equ_b1 && a2_equ_b2)
                return ev2;
              var a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);
              var a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);
              if (a1_equ_b1) {
                if (a2_between) {
                  eventDivide(ev2, a2);
                } else {
                  eventDivide(ev1, b2);
                }
                return ev2;
              } else if (a1_between) {
                if (!a2_equ_b2) {
                  if (a2_between) {
                    eventDivide(ev2, a2);
                  } else {
                    eventDivide(ev1, b2);
                  }
                }
                eventDivide(ev2, a1);
              }
            } else {
              if (i.alongA === 0) {
                if (i.alongB === -1)
                  eventDivide(ev1, b1);
                else if (i.alongB === 0)
                  eventDivide(ev1, i.pt);
                else if (i.alongB === 1)
                  eventDivide(ev1, b2);
              }
              if (i.alongB === 0) {
                if (i.alongA === -1)
                  eventDivide(ev2, a1);
                else if (i.alongA === 0)
                  eventDivide(ev2, i.pt);
                else if (i.alongA === 1)
                  eventDivide(ev2, a2);
              }
            }
            return false;
          }
          var segments = [];
          while (!event_root.isEmpty()) {
            var ev = event_root.getHead();
            if (buildLog)
              buildLog.vert(ev.pt[0]);
            if (ev.isStart) {
              let checkBothIntersections2 = function() {
                if (above) {
                  var eve2 = checkIntersection(ev, above);
                  if (eve2)
                    return eve2;
                }
                if (below)
                  return checkIntersection(ev, below);
                return false;
              };
              var checkBothIntersections = checkBothIntersections2;
              if (buildLog)
                buildLog.segmentNew(ev.seg, ev.primary);
              var surrounding = statusFindSurrounding(ev);
              var above = surrounding.before ? surrounding.before.ev : null;
              var below = surrounding.after ? surrounding.after.ev : null;
              if (buildLog) {
                buildLog.tempStatus(
                  ev.seg,
                  above ? above.seg : false,
                  below ? below.seg : false
                );
              }
              var eve = checkBothIntersections2();
              if (eve) {
                if (selfIntersection) {
                  var toggle;
                  if (ev.seg.myFill.below === null)
                    toggle = true;
                  else
                    toggle = ev.seg.myFill.above !== ev.seg.myFill.below;
                  if (toggle)
                    eve.seg.myFill.above = !eve.seg.myFill.above;
                } else {
                  eve.seg.otherFill = ev.seg.myFill;
                }
                if (buildLog)
                  buildLog.segmentUpdate(eve.seg);
                ev.other.remove();
                ev.remove();
              }
              if (event_root.getHead() !== ev) {
                if (buildLog)
                  buildLog.rewind(ev.seg);
                continue;
              }
              if (selfIntersection) {
                var toggle;
                if (ev.seg.myFill.below === null)
                  toggle = true;
                else
                  toggle = ev.seg.myFill.above !== ev.seg.myFill.below;
                if (!below) {
                  ev.seg.myFill.below = primaryPolyInverted;
                } else {
                  ev.seg.myFill.below = below.seg.myFill.above;
                }
                if (toggle)
                  ev.seg.myFill.above = !ev.seg.myFill.below;
                else
                  ev.seg.myFill.above = ev.seg.myFill.below;
              } else {
                if (ev.seg.otherFill === null) {
                  var inside;
                  if (!below) {
                    inside = ev.primary ? secondaryPolyInverted : primaryPolyInverted;
                  } else {
                    if (ev.primary === below.primary)
                      inside = below.seg.otherFill.above;
                    else
                      inside = below.seg.myFill.above;
                  }
                  ev.seg.otherFill = {
                    above: inside,
                    below: inside
                  };
                }
              }
              if (buildLog) {
                buildLog.status(
                  ev.seg,
                  above ? above.seg : false,
                  below ? below.seg : false
                );
              }
              ev.other.status = surrounding.insert(LinkedList.node({ ev }));
            } else {
              var st = ev.status;
              if (st === null) {
                throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");
              }
              if (status_root.exists(st.prev) && status_root.exists(st.next))
                checkIntersection(st.prev.ev, st.next.ev);
              if (buildLog)
                buildLog.statusRemove(st.ev.seg);
              st.remove();
              if (!ev.primary) {
                var s = ev.seg.myFill;
                ev.seg.myFill = ev.seg.otherFill;
                ev.seg.otherFill = s;
              }
              segments.push(ev.seg);
            }
            event_root.getHead().remove();
          }
          if (buildLog)
            buildLog.done();
          return segments;
        }
        if (!selfIntersection) {
          return {
            calculate: function(segments1, inverted1, segments2, inverted2) {
              segments1.forEach(function(seg) {
                eventAddSegment(segmentCopy(seg.start, seg.end, seg), true);
              });
              segments2.forEach(function(seg) {
                eventAddSegment(segmentCopy(seg.start, seg.end, seg), false);
              });
              return calculate(inverted1, inverted2);
            }
          };
        }
        return {
          addRegion: function(region) {
            var pt1;
            var pt2 = region[region.length - 1];
            for (var i = 0; i < region.length; i++) {
              pt1 = pt2;
              pt2 = region[i];
              var forward = eps.pointsCompare(pt1, pt2);
              if (forward === 0)
                continue;
              eventAddSegment(
                segmentNew(
                  forward < 0 ? pt1 : pt2,
                  forward < 0 ? pt2 : pt1
                ),
                true
              );
            }
          },
          calculate: function(inverted) {
            return calculate(inverted, false);
          }
        };
      }
      module.exports = Intersecter;
    }
  });

  // node_modules/polybooljs/lib/segment-chainer.js
  var require_segment_chainer = __commonJS({
    "node_modules/polybooljs/lib/segment-chainer.js"(exports, module) {
      function SegmentChainer(segments, eps, buildLog) {
        var chains = [];
        var regions = [];
        segments.forEach(function(seg) {
          var pt1 = seg.start;
          var pt2 = seg.end;
          if (eps.pointsSame(pt1, pt2)) {
            console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");
            return;
          }
          if (buildLog)
            buildLog.chainStart(seg);
          var first_match = {
            index: 0,
            matches_head: false,
            matches_pt1: false
          };
          var second_match = {
            index: 0,
            matches_head: false,
            matches_pt1: false
          };
          var next_match = first_match;
          function setMatch(index2, matches_head, matches_pt1) {
            next_match.index = index2;
            next_match.matches_head = matches_head;
            next_match.matches_pt1 = matches_pt1;
            if (next_match === first_match) {
              next_match = second_match;
              return false;
            }
            next_match = null;
            return true;
          }
          for (var i = 0; i < chains.length; i++) {
            var chain = chains[i];
            var head = chain[0];
            var head2 = chain[1];
            var tail = chain[chain.length - 1];
            var tail2 = chain[chain.length - 2];
            if (eps.pointsSame(head, pt1)) {
              if (setMatch(i, true, true))
                break;
            } else if (eps.pointsSame(head, pt2)) {
              if (setMatch(i, true, false))
                break;
            } else if (eps.pointsSame(tail, pt1)) {
              if (setMatch(i, false, true))
                break;
            } else if (eps.pointsSame(tail, pt2)) {
              if (setMatch(i, false, false))
                break;
            }
          }
          if (next_match === first_match) {
            chains.push([pt1, pt2]);
            if (buildLog)
              buildLog.chainNew(pt1, pt2);
            return;
          }
          if (next_match === second_match) {
            if (buildLog)
              buildLog.chainMatch(first_match.index);
            var index = first_match.index;
            var pt = first_match.matches_pt1 ? pt2 : pt1;
            var addToHead = first_match.matches_head;
            var chain = chains[index];
            var grow = addToHead ? chain[0] : chain[chain.length - 1];
            var grow2 = addToHead ? chain[1] : chain[chain.length - 2];
            var oppo = addToHead ? chain[chain.length - 1] : chain[0];
            var oppo2 = addToHead ? chain[chain.length - 2] : chain[1];
            if (eps.pointsCollinear(grow2, grow, pt)) {
              if (addToHead) {
                if (buildLog)
                  buildLog.chainRemoveHead(first_match.index, pt);
                chain.shift();
              } else {
                if (buildLog)
                  buildLog.chainRemoveTail(first_match.index, pt);
                chain.pop();
              }
              grow = grow2;
            }
            if (eps.pointsSame(oppo, pt)) {
              chains.splice(index, 1);
              if (eps.pointsCollinear(oppo2, oppo, grow)) {
                if (addToHead) {
                  if (buildLog)
                    buildLog.chainRemoveTail(first_match.index, grow);
                  chain.pop();
                } else {
                  if (buildLog)
                    buildLog.chainRemoveHead(first_match.index, grow);
                  chain.shift();
                }
              }
              if (buildLog)
                buildLog.chainClose(first_match.index);
              regions.push(chain);
              return;
            }
            if (addToHead) {
              if (buildLog)
                buildLog.chainAddHead(first_match.index, pt);
              chain.unshift(pt);
            } else {
              if (buildLog)
                buildLog.chainAddTail(first_match.index, pt);
              chain.push(pt);
            }
            return;
          }
          function reverseChain(index2) {
            if (buildLog)
              buildLog.chainReverse(index2);
            chains[index2].reverse();
          }
          function appendChain(index1, index2) {
            var chain1 = chains[index1];
            var chain2 = chains[index2];
            var tail3 = chain1[chain1.length - 1];
            var tail22 = chain1[chain1.length - 2];
            var head3 = chain2[0];
            var head22 = chain2[1];
            if (eps.pointsCollinear(tail22, tail3, head3)) {
              if (buildLog)
                buildLog.chainRemoveTail(index1, tail3);
              chain1.pop();
              tail3 = tail22;
            }
            if (eps.pointsCollinear(tail3, head3, head22)) {
              if (buildLog)
                buildLog.chainRemoveHead(index2, head3);
              chain2.shift();
            }
            if (buildLog)
              buildLog.chainJoin(index1, index2);
            chains[index1] = chain1.concat(chain2);
            chains.splice(index2, 1);
          }
          var F = first_match.index;
          var S = second_match.index;
          if (buildLog)
            buildLog.chainConnect(F, S);
          var reverseF = chains[F].length < chains[S].length;
          if (first_match.matches_head) {
            if (second_match.matches_head) {
              if (reverseF) {
                reverseChain(F);
                appendChain(F, S);
              } else {
                reverseChain(S);
                appendChain(S, F);
              }
            } else {
              appendChain(S, F);
            }
          } else {
            if (second_match.matches_head) {
              appendChain(F, S);
            } else {
              if (reverseF) {
                reverseChain(F);
                appendChain(S, F);
              } else {
                reverseChain(S);
                appendChain(F, S);
              }
            }
          }
        });
        return regions;
      }
      module.exports = SegmentChainer;
    }
  });

  // node_modules/polybooljs/lib/segment-selector.js
  var require_segment_selector = __commonJS({
    "node_modules/polybooljs/lib/segment-selector.js"(exports, module) {
      function select(segments, selection, buildLog) {
        var result = [];
        segments.forEach(function(seg) {
          var index = (seg.myFill.above ? 8 : 0) + (seg.myFill.below ? 4 : 0) + (seg.otherFill && seg.otherFill.above ? 2 : 0) + (seg.otherFill && seg.otherFill.below ? 1 : 0);
          if (selection[index] !== 0) {
            result.push({
              id: buildLog ? buildLog.segmentId() : -1,
              start: seg.start,
              end: seg.end,
              myFill: {
                above: selection[index] === 1,
                // 1 if filled above
                below: selection[index] === 2
                // 2 if filled below
              },
              otherFill: null
            });
          }
        });
        if (buildLog)
          buildLog.selected(result);
        return result;
      }
      var SegmentSelector = {
        union: function(segments, buildLog) {
          return select(segments, [
            0,
            2,
            1,
            0,
            2,
            2,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
          ], buildLog);
        },
        intersect: function(segments, buildLog) {
          return select(segments, [
            0,
            0,
            0,
            0,
            0,
            2,
            0,
            2,
            0,
            0,
            1,
            1,
            0,
            2,
            1,
            0
          ], buildLog);
        },
        difference: function(segments, buildLog) {
          return select(segments, [
            0,
            0,
            0,
            0,
            2,
            0,
            2,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            2,
            0
          ], buildLog);
        },
        differenceRev: function(segments, buildLog) {
          return select(segments, [
            0,
            2,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            2,
            0,
            2,
            0,
            0,
            0,
            0
          ], buildLog);
        },
        xor: function(segments, buildLog) {
          return select(segments, [
            0,
            2,
            1,
            0,
            2,
            0,
            0,
            1,
            1,
            0,
            0,
            2,
            0,
            1,
            2,
            0
          ], buildLog);
        }
      };
      module.exports = SegmentSelector;
    }
  });

  // node_modules/polybooljs/lib/geojson.js
  var require_geojson = __commonJS({
    "node_modules/polybooljs/lib/geojson.js"(exports, module) {
      var GeoJSON = {
        // convert a GeoJSON object to a PolyBool polygon
        toPolygon: function(PolyBool, geojson) {
          function GeoPoly(coords) {
            if (coords.length <= 0)
              return PolyBool.segments({ inverted: false, regions: [] });
            function LineString(ls) {
              var reg = ls.slice(0, ls.length - 1);
              return PolyBool.segments({ inverted: false, regions: [reg] });
            }
            var out2 = LineString(coords[0]);
            for (var i2 = 1; i2 < coords.length; i2++)
              out2 = PolyBool.selectDifference(PolyBool.combine(out2, LineString(coords[i2])));
            return out2;
          }
          if (geojson.type === "Polygon") {
            return PolyBool.polygon(GeoPoly(geojson.coordinates));
          } else if (geojson.type === "MultiPolygon") {
            var out = PolyBool.segments({ inverted: false, regions: [] });
            for (var i = 0; i < geojson.coordinates.length; i++)
              out = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));
            return PolyBool.polygon(out);
          }
          throw new Error("PolyBool: Cannot convert GeoJSON object to PolyBool polygon");
        },
        // convert a PolyBool polygon to a GeoJSON object
        fromPolygon: function(PolyBool, eps, poly) {
          poly = PolyBool.polygon(PolyBool.segments(poly));
          function regionInsideRegion(r1, r2) {
            return eps.pointInsideRegion([
              (r1[0][0] + r1[1][0]) * 0.5,
              (r1[0][1] + r1[1][1]) * 0.5
            ], r2);
          }
          function newNode(region2) {
            return {
              region: region2,
              children: []
            };
          }
          var roots = newNode(null);
          function addChild(root, region2) {
            for (var i2 = 0; i2 < root.children.length; i2++) {
              var child = root.children[i2];
              if (regionInsideRegion(region2, child.region)) {
                addChild(child, region2);
                return;
              }
            }
            var node = newNode(region2);
            for (var i2 = 0; i2 < root.children.length; i2++) {
              var child = root.children[i2];
              if (regionInsideRegion(child.region, region2)) {
                node.children.push(child);
                root.children.splice(i2, 1);
                i2--;
              }
            }
            root.children.push(node);
          }
          for (var i = 0; i < poly.regions.length; i++) {
            var region = poly.regions[i];
            if (region.length < 3)
              continue;
            addChild(roots, region);
          }
          function forceWinding(region2, clockwise) {
            var winding = 0;
            var last_x = region2[region2.length - 1][0];
            var last_y = region2[region2.length - 1][1];
            var copy = [];
            for (var i2 = 0; i2 < region2.length; i2++) {
              var curr_x = region2[i2][0];
              var curr_y = region2[i2][1];
              copy.push([curr_x, curr_y]);
              winding += curr_y * last_x - curr_x * last_y;
              last_x = curr_x;
              last_y = curr_y;
            }
            var isclockwise = winding < 0;
            if (isclockwise !== clockwise)
              copy.reverse();
            copy.push([copy[0][0], copy[0][1]]);
            return copy;
          }
          var geopolys = [];
          function addExterior(node) {
            var poly2 = [forceWinding(node.region, false)];
            geopolys.push(poly2);
            for (var i2 = 0; i2 < node.children.length; i2++)
              poly2.push(getInterior(node.children[i2]));
          }
          function getInterior(node) {
            for (var i2 = 0; i2 < node.children.length; i2++)
              addExterior(node.children[i2]);
            return forceWinding(node.region, true);
          }
          for (var i = 0; i < roots.children.length; i++)
            addExterior(roots.children[i]);
          if (geopolys.length <= 0)
            return { type: "Polygon", coordinates: [] };
          if (geopolys.length == 1)
            return { type: "Polygon", coordinates: geopolys[0] };
          return {
            // otherwise, use a GeoJSON MultiPolygon
            type: "MultiPolygon",
            coordinates: geopolys
          };
        }
      };
      module.exports = GeoJSON;
    }
  });

  // node_modules/polybooljs/index.js
  var require_polybooljs = __commonJS({
    "node_modules/polybooljs/index.js"(exports, module) {
      var BuildLog = require_build_log();
      var Epsilon = require_epsilon();
      var Intersecter = require_intersecter();
      var SegmentChainer = require_segment_chainer();
      var SegmentSelector = require_segment_selector();
      var GeoJSON = require_geojson();
      var buildLog = false;
      var epsilon = Epsilon();
      var PolyBool;
      PolyBool = {
        // getter/setter for buildLog
        buildLog: function(bl) {
          if (bl === true)
            buildLog = BuildLog();
          else if (bl === false)
            buildLog = false;
          return buildLog === false ? false : buildLog.list;
        },
        // getter/setter for epsilon
        epsilon: function(v) {
          return epsilon.epsilon(v);
        },
        // core API
        segments: function(poly) {
          var i = Intersecter(true, epsilon, buildLog);
          poly.regions.forEach(i.addRegion);
          return {
            segments: i.calculate(poly.inverted),
            inverted: poly.inverted
          };
        },
        combine: function(segments1, segments2) {
          var i3 = Intersecter(false, epsilon, buildLog);
          return {
            combined: i3.calculate(
              segments1.segments,
              segments1.inverted,
              segments2.segments,
              segments2.inverted
            ),
            inverted1: segments1.inverted,
            inverted2: segments2.inverted
          };
        },
        selectUnion: function(combined) {
          return {
            segments: SegmentSelector.union(combined.combined, buildLog),
            inverted: combined.inverted1 || combined.inverted2
          };
        },
        selectIntersect: function(combined) {
          return {
            segments: SegmentSelector.intersect(combined.combined, buildLog),
            inverted: combined.inverted1 && combined.inverted2
          };
        },
        selectDifference: function(combined) {
          return {
            segments: SegmentSelector.difference(combined.combined, buildLog),
            inverted: combined.inverted1 && !combined.inverted2
          };
        },
        selectDifferenceRev: function(combined) {
          return {
            segments: SegmentSelector.differenceRev(combined.combined, buildLog),
            inverted: !combined.inverted1 && combined.inverted2
          };
        },
        selectXor: function(combined) {
          return {
            segments: SegmentSelector.xor(combined.combined, buildLog),
            inverted: combined.inverted1 !== combined.inverted2
          };
        },
        polygon: function(segments) {
          return {
            regions: SegmentChainer(segments.segments, epsilon, buildLog),
            inverted: segments.inverted
          };
        },
        // GeoJSON converters
        polygonFromGeoJSON: function(geojson) {
          return GeoJSON.toPolygon(PolyBool, geojson);
        },
        polygonToGeoJSON: function(poly) {
          return GeoJSON.fromPolygon(PolyBool, epsilon, poly);
        },
        // helper functions for common operations
        union: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectUnion);
        },
        intersect: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectIntersect);
        },
        difference: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectDifference);
        },
        differenceRev: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectDifferenceRev);
        },
        xor: function(poly1, poly2) {
          return operate(poly1, poly2, PolyBool.selectXor);
        }
      };
      function operate(poly1, poly2, selector) {
        var seg1 = PolyBool.segments(poly1);
        var seg2 = PolyBool.segments(poly2);
        var comb = PolyBool.combine(seg1, seg2);
        var seg3 = selector(comb);
        return PolyBool.polygon(seg3);
      }
      if (typeof window === "object")
        window.PolyBool = PolyBool;
      module.exports = PolyBool;
    }
  });

  // node_modules/point-in-polygon/nested.js
  var require_nested = __commonJS({
    "node_modules/point-in-polygon/nested.js"(exports, module) {
      module.exports = function pointInPolygonNested(point, vs, start, end) {
        var x = point[0], y = point[1];
        var inside = false;
        if (start === void 0) start = 0;
        if (end === void 0) end = vs.length;
        var len = end - start;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[i + start][0], yi = vs[i + start][1];
          var xj = vs[j + start][0], yj = vs[j + start][1];
          var intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      };
    }
  });

  // src/lib/polygon.js
  var require_polygon = __commonJS({
    "src/lib/polygon.js"(exports, module) {
      "use strict";
      var dot = require_matrix().dot;
      var BADNUM = require_numerical().BADNUM;
      var polygon = module.exports = {};
      polygon.tester = function tester(ptsIn) {
        var pts = ptsIn.slice();
        var xmin = pts[0][0];
        var xmax = xmin;
        var ymin = pts[0][1];
        var ymax = ymin;
        var i;
        if (pts[pts.length - 1][0] !== pts[0][0] || pts[pts.length - 1][1] !== pts[0][1]) {
          pts.push(pts[0]);
        }
        for (i = 1; i < pts.length; i++) {
          xmin = Math.min(xmin, pts[i][0]);
          xmax = Math.max(xmax, pts[i][0]);
          ymin = Math.min(ymin, pts[i][1]);
          ymax = Math.max(ymax, pts[i][1]);
        }
        var isRect = false;
        var rectFirstEdgeTest;
        if (pts.length === 5) {
          if (pts[0][0] === pts[1][0]) {
            if (pts[2][0] === pts[3][0] && pts[0][1] === pts[3][1] && pts[1][1] === pts[2][1]) {
              isRect = true;
              rectFirstEdgeTest = function(pt) {
                return pt[0] === pts[0][0];
              };
            }
          } else if (pts[0][1] === pts[1][1]) {
            if (pts[2][1] === pts[3][1] && pts[0][0] === pts[3][0] && pts[1][0] === pts[2][0]) {
              isRect = true;
              rectFirstEdgeTest = function(pt) {
                return pt[1] === pts[0][1];
              };
            }
          }
        }
        function rectContains(pt, omitFirstEdge) {
          var x = pt[0];
          var y = pt[1];
          if (x === BADNUM || x < xmin || x > xmax || y === BADNUM || y < ymin || y > ymax) {
            return false;
          }
          if (omitFirstEdge && rectFirstEdgeTest(pt)) return false;
          return true;
        }
        function contains(pt, omitFirstEdge) {
          var x = pt[0];
          var y = pt[1];
          if (x === BADNUM || x < xmin || x > xmax || y === BADNUM || y < ymin || y > ymax) {
            return false;
          }
          var imax = pts.length;
          var x1 = pts[0][0];
          var y1 = pts[0][1];
          var crossings = 0;
          var i2;
          var x0;
          var y0;
          var xmini;
          var ycross;
          for (i2 = 1; i2 < imax; i2++) {
            x0 = x1;
            y0 = y1;
            x1 = pts[i2][0];
            y1 = pts[i2][1];
            xmini = Math.min(x0, x1);
            if (x < xmini || x > Math.max(x0, x1) || y > Math.max(y0, y1)) {
              continue;
            } else if (y < Math.min(y0, y1)) {
              if (x !== xmini) crossings++;
            } else {
              if (x1 === x0) ycross = y;
              else ycross = y0 + (x - x0) * (y1 - y0) / (x1 - x0);
              if (y === ycross) {
                if (i2 === 1 && omitFirstEdge) return false;
                return true;
              }
              if (y <= ycross && x !== xmini) crossings++;
            }
          }
          return crossings % 2 === 1;
        }
        var degenerate = true;
        var lastPt = pts[0];
        for (i = 1; i < pts.length; i++) {
          if (lastPt[0] !== pts[i][0] || lastPt[1] !== pts[i][1]) {
            degenerate = false;
            break;
          }
        }
        return {
          xmin,
          xmax,
          ymin,
          ymax,
          pts,
          contains: isRect ? rectContains : contains,
          isRect,
          degenerate
        };
      };
      polygon.isSegmentBent = function isSegmentBent(pts, start, end, tolerance) {
        var startPt = pts[start];
        var segment = [pts[end][0] - startPt[0], pts[end][1] - startPt[1]];
        var segmentSquared = dot(segment, segment);
        var segmentLen = Math.sqrt(segmentSquared);
        var unitPerp = [-segment[1] / segmentLen, segment[0] / segmentLen];
        var i;
        var part;
        var partParallel;
        for (i = start + 1; i < end; i++) {
          part = [pts[i][0] - startPt[0], pts[i][1] - startPt[1]];
          partParallel = dot(part, segment);
          if (partParallel < 0 || partParallel > segmentSquared || Math.abs(dot(part, unitPerp)) > tolerance) return true;
        }
        return false;
      };
      polygon.filter = function filter(pts, tolerance) {
        var ptsFiltered = [pts[0]];
        var doneRawIndex = 0;
        var doneFilteredIndex = 0;
        function addPt(pt) {
          pts.push(pt);
          var prevFilterLen = ptsFiltered.length;
          var iLast = doneRawIndex;
          ptsFiltered.splice(doneFilteredIndex + 1);
          for (var i = iLast + 1; i < pts.length; i++) {
            if (i === pts.length - 1 || polygon.isSegmentBent(pts, iLast, i + 1, tolerance)) {
              ptsFiltered.push(pts[i]);
              if (ptsFiltered.length < prevFilterLen - 2) {
                doneRawIndex = i;
                doneFilteredIndex = ptsFiltered.length - 1;
              }
              iLast = i;
            }
          }
        }
        if (pts.length > 1) {
          var lastPt = pts.pop();
          addPt(lastPt);
        }
        return {
          addPt,
          raw: pts,
          filtered: ptsFiltered
        };
      };
    }
  });

  // src/components/selections/constants.js
  var require_constants7 = __commonJS({
    "src/components/selections/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // max pixels off straight before a lasso select line counts as bent
        BENDPX: 1.5,
        // smallest dimension allowed for a select box
        MINSELECT: 12,
        // throttling limit (ms) for selectPoints calls
        SELECTDELAY: 100,
        // cache ID suffix for throttle
        SELECTID: "-select"
      };
    }
  });

  // src/components/selections/select.js
  var require_select = __commonJS({
    "src/components/selections/select.js"(exports, module) {
      "use strict";
      var polybool = require_polybooljs();
      var pointInPolygon = require_nested();
      var Registry = require_registry();
      var dashStyle = require_drawing().dashStyle;
      var Color = require_color();
      var Fx = require_fx();
      var makeEventData = require_helpers2().makeEventData;
      var dragHelpers = require_helpers5();
      var freeMode = dragHelpers.freeMode;
      var rectMode = dragHelpers.rectMode;
      var drawMode = dragHelpers.drawMode;
      var openMode = dragHelpers.openMode;
      var selectMode = dragHelpers.selectMode;
      var shapeHelpers = require_helpers8();
      var shapeConstants = require_constants5();
      var displayOutlines = require_display_outlines();
      var clearOutline = require_handle_outline().clearOutline;
      var newShapeHelpers = require_helpers7();
      var handleEllipse = newShapeHelpers.handleEllipse;
      var readPaths = newShapeHelpers.readPaths;
      var newShapes = require_newshapes().newShapes;
      var newSelections = require_newselections();
      var activateLastSelection = require_draw3().activateLastSelection;
      var Lib = require_lib();
      var ascending = Lib.sorterAsc;
      var libPolygon = require_polygon();
      var throttle = require_throttle();
      var getFromId = require_axis_ids().getFromId;
      var clearGlCanvases = require_clear_gl_canvases();
      var redrawReglTraces = require_subroutines().redrawReglTraces;
      var constants = require_constants7();
      var MINSELECT = constants.MINSELECT;
      var filteredPolygon = libPolygon.filter;
      var polygonTester = libPolygon.tester;
      var helpers = require_helpers6();
      var p2r = helpers.p2r;
      var axValue = helpers.axValue;
      var getTransform = helpers.getTransform;
      function hasSubplot(dragOptions) {
        return dragOptions.subplot !== void 0;
      }
      function prepSelect(evt, startX, startY, dragOptions, mode) {
        var isCartesian = !hasSubplot(dragOptions);
        var isFreeMode = freeMode(mode);
        var isRectMode = rectMode(mode);
        var isOpenMode = openMode(mode);
        var isDrawMode = drawMode(mode);
        var isSelectMode = selectMode(mode);
        var isLine = mode === "drawline";
        var isEllipse = mode === "drawcircle";
        var isLineOrEllipse = isLine || isEllipse;
        var gd = dragOptions.gd;
        var fullLayout = gd._fullLayout;
        var immediateSelect = isSelectMode && fullLayout.newselection.mode === "immediate" && isCartesian;
        var zoomLayer = fullLayout._zoomlayer;
        var dragBBox = dragOptions.element.getBoundingClientRect();
        var plotinfo = dragOptions.plotinfo;
        var transform = getTransform(plotinfo);
        var x0 = startX - dragBBox.left;
        var y0 = startY - dragBBox.top;
        fullLayout._calcInverseTransform(gd);
        var transformedCoords = Lib.apply3DTransform(fullLayout._invTransform)(x0, y0);
        x0 = transformedCoords[0];
        y0 = transformedCoords[1];
        var scaleX = fullLayout._invScaleX;
        var scaleY = fullLayout._invScaleY;
        var x1 = x0;
        var y1 = y0;
        var path0 = "M" + x0 + "," + y0;
        var xAxis = dragOptions.xaxes[0];
        var yAxis = dragOptions.yaxes[0];
        var pw = xAxis._length;
        var ph = yAxis._length;
        var subtract = evt.altKey && !(drawMode(mode) && isOpenMode);
        var filterPoly, selectionTesters, mergedPolygons, currentPolygon;
        var i, searchInfo, eventData;
        coerceSelectionsCache(evt, gd, dragOptions);
        if (isFreeMode) {
          filterPoly = filteredPolygon([[x0, y0]], constants.BENDPX);
        }
        var outlines = zoomLayer.selectAll("path.select-outline-" + plotinfo.id).data([1]);
        var newStyle = isDrawMode ? fullLayout.newshape : fullLayout.newselection;
        if (isDrawMode) {
          dragOptions.hasText = newStyle.label.text || newStyle.label.texttemplate;
        }
        var fillC = isDrawMode && !isOpenMode ? newStyle.fillcolor : "rgba(0,0,0,0)";
        var strokeC = newStyle.line.color || (isCartesian ? Color.contrast(gd._fullLayout.plot_bgcolor) : "#7f7f7f");
        outlines.enter().append("path").attr("class", "select-outline select-outline-" + plotinfo.id).style({
          opacity: isDrawMode ? newStyle.opacity / 2 : 1,
          "stroke-dasharray": dashStyle(newStyle.line.dash, newStyle.line.width),
          "stroke-width": newStyle.line.width + "px",
          "shape-rendering": "crispEdges"
        }).call(Color.stroke, strokeC).call(Color.fill, fillC).attr("fill-rule", "evenodd").classed("cursor-move", isDrawMode ? true : false).attr("transform", transform).attr("d", path0 + "Z");
        var corners = zoomLayer.append("path").attr("class", "zoombox-corners").style({
          fill: Color.background,
          stroke: Color.defaultLine,
          "stroke-width": 1
        }).attr("transform", transform).attr("d", "M0,0Z");
        if (isDrawMode && dragOptions.hasText) {
          var shapeGroup = zoomLayer.select(".label-temp");
          if (shapeGroup.empty()) {
            shapeGroup = zoomLayer.append("g").classed("label-temp", true).classed("select-outline", true).style({ opacity: 0.8 });
          }
        }
        var throttleID = fullLayout._uid + constants.SELECTID;
        var selection = [];
        var searchTraces = determineSearchTraces(
          gd,
          dragOptions.xaxes,
          dragOptions.yaxes,
          dragOptions.subplot
        );
        if (immediateSelect && !evt.shiftKey) {
          dragOptions._clearSubplotSelections = function() {
            if (!isCartesian) return;
            var xRef = xAxis._id;
            var yRef = yAxis._id;
            deselectSubplot(gd, xRef, yRef, searchTraces);
            var selections = (gd.layout || {}).selections || [];
            var list = [];
            var selectionErased = false;
            for (var q = 0; q < selections.length; q++) {
              var s = fullLayout.selections[q];
              if (!s || s.xref !== xRef || s.yref !== yRef) {
                list.push(selections[q]);
              } else {
                selectionErased = true;
              }
            }
            if (selectionErased) {
              gd._fullLayout._noEmitSelectedAtStart = true;
              Registry.call("_guiRelayout", gd, {
                selections: list
              });
            }
          };
        }
        var fillRangeItems = getFillRangeItems(dragOptions);
        dragOptions.moveFn = function(dx0, dy0) {
          if (dragOptions._clearSubplotSelections) {
            dragOptions._clearSubplotSelections();
            dragOptions._clearSubplotSelections = void 0;
          }
          x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));
          y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));
          var dx = Math.abs(x1 - x0);
          var dy = Math.abs(y1 - y0);
          if (isRectMode) {
            var direction;
            var start, end;
            if (isSelectMode) {
              var q = fullLayout.selectdirection;
              if (q === "any") {
                if (dy < Math.min(dx * 0.6, MINSELECT)) {
                  direction = "h";
                } else if (dx < Math.min(dy * 0.6, MINSELECT)) {
                  direction = "v";
                } else {
                  direction = "d";
                }
              } else {
                direction = q;
              }
              switch (direction) {
                case "h":
                  start = isEllipse ? ph / 2 : 0;
                  end = ph;
                  break;
                case "v":
                  start = isEllipse ? pw / 2 : 0;
                  end = pw;
                  break;
              }
            }
            if (isDrawMode) {
              switch (fullLayout.newshape.drawdirection) {
                case "vertical":
                  direction = "h";
                  start = isEllipse ? ph / 2 : 0;
                  end = ph;
                  break;
                case "horizontal":
                  direction = "v";
                  start = isEllipse ? pw / 2 : 0;
                  end = pw;
                  break;
                case "ortho":
                  if (dx < dy) {
                    direction = "h";
                    start = y0;
                    end = y1;
                  } else {
                    direction = "v";
                    start = x0;
                    end = x1;
                  }
                  break;
                default:
                  direction = "d";
              }
            }
            if (direction === "h") {
              currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x1, start], [x1, end]) : (
                // using x1 instead of x0 allows adjusting the line while drawing
                [[x0, start], [x0, end], [x1, end], [x1, start]]
              );
              currentPolygon.xmin = isLineOrEllipse ? x1 : Math.min(x0, x1);
              currentPolygon.xmax = isLineOrEllipse ? x1 : Math.max(x0, x1);
              currentPolygon.ymin = Math.min(start, end);
              currentPolygon.ymax = Math.max(start, end);
              corners.attr("d", "M" + currentPolygon.xmin + "," + (y0 - MINSELECT) + "h-4v" + 2 * MINSELECT + "h4ZM" + (currentPolygon.xmax - 1) + "," + (y0 - MINSELECT) + "h4v" + 2 * MINSELECT + "h-4Z");
            } else if (direction === "v") {
              currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [start, y1], [end, y1]) : (
                // using y1 instead of y0 allows adjusting the line while drawing
                [[start, y0], [start, y1], [end, y1], [end, y0]]
              );
              currentPolygon.xmin = Math.min(start, end);
              currentPolygon.xmax = Math.max(start, end);
              currentPolygon.ymin = isLineOrEllipse ? y1 : Math.min(y0, y1);
              currentPolygon.ymax = isLineOrEllipse ? y1 : Math.max(y0, y1);
              corners.attr("d", "M" + (x0 - MINSELECT) + "," + currentPolygon.ymin + "v-4h" + 2 * MINSELECT + "v4ZM" + (x0 - MINSELECT) + "," + (currentPolygon.ymax - 1) + "v4h" + 2 * MINSELECT + "v-4Z");
            } else if (direction === "d") {
              currentPolygon = isLineOrEllipse ? handleEllipse(isEllipse, [x0, y0], [x1, y1]) : [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];
              currentPolygon.xmin = Math.min(x0, x1);
              currentPolygon.xmax = Math.max(x0, x1);
              currentPolygon.ymin = Math.min(y0, y1);
              currentPolygon.ymax = Math.max(y0, y1);
              corners.attr("d", "M0,0Z");
            }
          } else if (isFreeMode) {
            filterPoly.addPt([x1, y1]);
            currentPolygon = filterPoly.filtered;
          }
          if (dragOptions.selectionDefs && dragOptions.selectionDefs.length) {
            mergedPolygons = mergePolygons(dragOptions.mergedPolygons, currentPolygon, subtract);
            currentPolygon.subtract = subtract;
            selectionTesters = multiTester(dragOptions.selectionDefs.concat([currentPolygon]));
          } else {
            mergedPolygons = [currentPolygon];
            selectionTesters = polygonTester(currentPolygon);
          }
          displayOutlines(convertPoly(mergedPolygons, isOpenMode), outlines, dragOptions);
          if (isSelectMode) {
            var _res = reselect(gd, false);
            var extraPoints = _res.eventData ? _res.eventData.points.slice() : [];
            _res = reselect(gd, false, selectionTesters, searchTraces, dragOptions);
            selectionTesters = _res.selectionTesters;
            eventData = _res.eventData;
            var poly;
            if (filterPoly) {
              poly = filterPoly.filtered;
            } else {
              poly = castMultiPolygon(mergedPolygons);
            }
            throttle.throttle(
              throttleID,
              constants.SELECTDELAY,
              function() {
                selection = _doSelect(selectionTesters, searchTraces);
                var newPoints = selection.slice();
                for (var w = 0; w < extraPoints.length; w++) {
                  var p = extraPoints[w];
                  var found = false;
                  for (var u = 0; u < newPoints.length; u++) {
                    if (newPoints[u].curveNumber === p.curveNumber && newPoints[u].pointNumber === p.pointNumber) {
                      found = true;
                      break;
                    }
                  }
                  if (!found) newPoints.push(p);
                }
                if (newPoints.length) {
                  if (!eventData) eventData = {};
                  eventData.points = newPoints;
                }
                fillRangeItems(eventData, poly);
                emitSelecting(gd, eventData);
              }
            );
          }
        };
        dragOptions.clickFn = function(numClicks, evt2) {
          corners.remove();
          if (gd._fullLayout._activeShapeIndex >= 0) {
            gd._fullLayout._deactivateShape(gd);
            return;
          }
          if (isDrawMode) return;
          var clickmode = fullLayout.clickmode;
          throttle.done(throttleID).then(function() {
            throttle.clear(throttleID);
            if (numClicks === 2) {
              outlines.remove();
              for (i = 0; i < searchTraces.length; i++) {
                searchInfo = searchTraces[i];
                searchInfo._module.selectPoints(searchInfo, false);
              }
              updateSelectedState(gd, searchTraces);
              clearSelectionsCache(dragOptions);
              emitDeselect(gd);
              if (searchTraces.length) {
                var clickedXaxis = searchTraces[0].xaxis;
                var clickedYaxis = searchTraces[0].yaxis;
                if (clickedXaxis && clickedYaxis) {
                  var subSelections = [];
                  var allSelections = gd._fullLayout.selections;
                  for (var k = 0; k < allSelections.length; k++) {
                    var s = allSelections[k];
                    if (!s) continue;
                    if (s.xref !== clickedXaxis._id || s.yref !== clickedYaxis._id) {
                      subSelections.push(s);
                    }
                  }
                  if (subSelections.length < allSelections.length) {
                    gd._fullLayout._noEmitSelectedAtStart = true;
                    Registry.call("_guiRelayout", gd, {
                      selections: subSelections
                    });
                  }
                }
              }
            } else {
              if (clickmode.indexOf("select") > -1) {
                selectOnClick(
                  evt2,
                  gd,
                  dragOptions.xaxes,
                  dragOptions.yaxes,
                  dragOptions.subplot,
                  dragOptions,
                  outlines
                );
              }
              if (clickmode === "event") {
                emitSelected(gd, void 0);
              }
            }
            Fx.click(gd, evt2, plotinfo.id);
          }).catch(Lib.error);
        };
        dragOptions.doneFn = function() {
          corners.remove();
          throttle.done(throttleID).then(function() {
            throttle.clear(throttleID);
            if (!immediateSelect && currentPolygon && dragOptions.selectionDefs) {
              currentPolygon.subtract = subtract;
              dragOptions.selectionDefs.push(currentPolygon);
              dragOptions.mergedPolygons.length = 0;
              [].push.apply(dragOptions.mergedPolygons, mergedPolygons);
            }
            if (immediateSelect || isDrawMode) {
              clearSelectionsCache(dragOptions, immediateSelect);
            }
            if (dragOptions.doneFnCompleted) {
              dragOptions.doneFnCompleted(selection);
            }
            if (isSelectMode) {
              emitSelected(gd, eventData);
            }
          }).catch(Lib.error);
        };
      }
      function selectOnClick(evt, gd, xAxes, yAxes, subplot, dragOptions, polygonOutlines) {
        var hoverData = gd._hoverdata;
        var fullLayout = gd._fullLayout;
        var clickmode = fullLayout.clickmode;
        var sendEvents = clickmode.indexOf("event") > -1;
        var selection = [];
        var searchTraces, searchInfo, currentSelectionDef, selectionTesters, traceSelection;
        var thisTracesSelection, pointOrBinSelected, subtract, eventData, i;
        if (isHoverDataSet(hoverData)) {
          coerceSelectionsCache(evt, gd, dragOptions);
          searchTraces = determineSearchTraces(gd, xAxes, yAxes, subplot);
          var clickedPtInfo = extractClickedPtInfo(hoverData, searchTraces);
          var isBinnedTrace = clickedPtInfo.pointNumbers.length > 0;
          if (isBinnedTrace ? isOnlyThisBinSelected(searchTraces, clickedPtInfo) : isOnlyOnePointSelected(searchTraces) && (pointOrBinSelected = isPointOrBinSelected(clickedPtInfo))) {
            if (polygonOutlines) polygonOutlines.remove();
            for (i = 0; i < searchTraces.length; i++) {
              searchInfo = searchTraces[i];
              searchInfo._module.selectPoints(searchInfo, false);
            }
            updateSelectedState(gd, searchTraces);
            clearSelectionsCache(dragOptions);
            if (sendEvents) {
              emitDeselect(gd);
            }
          } else {
            subtract = evt.shiftKey && (pointOrBinSelected !== void 0 ? pointOrBinSelected : isPointOrBinSelected(clickedPtInfo));
            currentSelectionDef = newPointSelectionDef(clickedPtInfo.pointNumber, clickedPtInfo.searchInfo, subtract);
            var allSelectionDefs = dragOptions.selectionDefs.concat([currentSelectionDef]);
            selectionTesters = multiTester(allSelectionDefs, selectionTesters);
            for (i = 0; i < searchTraces.length; i++) {
              traceSelection = searchTraces[i]._module.selectPoints(searchTraces[i], selectionTesters);
              thisTracesSelection = fillSelectionItem(traceSelection, searchTraces[i]);
              if (selection.length) {
                for (var j = 0; j < thisTracesSelection.length; j++) {
                  selection.push(thisTracesSelection[j]);
                }
              } else selection = thisTracesSelection;
            }
            eventData = { points: selection };
            updateSelectedState(gd, searchTraces, eventData);
            if (currentSelectionDef && dragOptions) {
              dragOptions.selectionDefs.push(currentSelectionDef);
            }
            if (polygonOutlines) {
              var polygons = dragOptions.mergedPolygons;
              var isOpenMode = openMode(dragOptions.dragmode);
              displayOutlines(convertPoly(polygons, isOpenMode), polygonOutlines, dragOptions);
            }
            if (sendEvents) {
              emitSelected(gd, eventData);
            }
          }
        }
      }
      function newPointSelectionDef(pointNumber, searchInfo, subtract) {
        return {
          pointNumber,
          searchInfo,
          subtract: !!subtract
        };
      }
      function isPointSelectionDef(o) {
        return "pointNumber" in o && "searchInfo" in o;
      }
      function newPointNumTester(pointSelectionDef) {
        return {
          xmin: 0,
          xmax: 0,
          ymin: 0,
          ymax: 0,
          pts: [],
          contains: function(pt, omitFirstEdge, pointNumber, searchInfo) {
            var idxWantedTrace = pointSelectionDef.searchInfo.cd[0].trace.index;
            var idxActualTrace = searchInfo.cd[0].trace.index;
            return idxActualTrace === idxWantedTrace && pointNumber === pointSelectionDef.pointNumber;
          },
          isRect: false,
          degenerate: false,
          subtract: !!pointSelectionDef.subtract
        };
      }
      function multiTester(list) {
        if (!list.length) return;
        var testers = [];
        var xmin = isPointSelectionDef(list[0]) ? 0 : list[0][0][0];
        var xmax = xmin;
        var ymin = isPointSelectionDef(list[0]) ? 0 : list[0][0][1];
        var ymax = ymin;
        for (var i = 0; i < list.length; i++) {
          if (isPointSelectionDef(list[i])) {
            testers.push(newPointNumTester(list[i]));
          } else {
            var tester = polygonTester(list[i]);
            tester.subtract = !!list[i].subtract;
            testers.push(tester);
            xmin = Math.min(xmin, tester.xmin);
            xmax = Math.max(xmax, tester.xmax);
            ymin = Math.min(ymin, tester.ymin);
            ymax = Math.max(ymax, tester.ymax);
          }
        }
        function contains(pt, arg, pointNumber, searchInfo) {
          var contained = false;
          for (var i2 = 0; i2 < testers.length; i2++) {
            if (testers[i2].contains(pt, arg, pointNumber, searchInfo)) {
              contained = !testers[i2].subtract;
            }
          }
          return contained;
        }
        return {
          xmin,
          xmax,
          ymin,
          ymax,
          pts: [],
          contains,
          isRect: false,
          degenerate: false
        };
      }
      function coerceSelectionsCache(evt, gd, dragOptions) {
        var fullLayout = gd._fullLayout;
        var plotinfo = dragOptions.plotinfo;
        var dragmode = dragOptions.dragmode;
        var selectingOnSameSubplot = fullLayout._lastSelectedSubplot && fullLayout._lastSelectedSubplot === plotinfo.id;
        var hasModifierKey = (evt.shiftKey || evt.altKey) && !(drawMode(dragmode) && openMode(dragmode));
        if (selectingOnSameSubplot && hasModifierKey && plotinfo.selection && plotinfo.selection.selectionDefs && !dragOptions.selectionDefs) {
          dragOptions.selectionDefs = plotinfo.selection.selectionDefs;
          dragOptions.mergedPolygons = plotinfo.selection.mergedPolygons;
        } else if (!hasModifierKey || !plotinfo.selection) {
          clearSelectionsCache(dragOptions);
        }
        if (!selectingOnSameSubplot) {
          clearOutline(gd);
          fullLayout._lastSelectedSubplot = plotinfo.id;
        }
      }
      function hasActiveShape(gd) {
        return gd._fullLayout._activeShapeIndex >= 0;
      }
      function hasActiveSelection(gd) {
        return gd._fullLayout._activeSelectionIndex >= 0;
      }
      function clearSelectionsCache(dragOptions, immediateSelect) {
        var dragmode = dragOptions.dragmode;
        var plotinfo = dragOptions.plotinfo;
        var gd = dragOptions.gd;
        if (hasActiveShape(gd)) {
          gd._fullLayout._deactivateShape(gd);
        }
        if (hasActiveSelection(gd)) {
          gd._fullLayout._deactivateSelection(gd);
        }
        var fullLayout = gd._fullLayout;
        var zoomLayer = fullLayout._zoomlayer;
        var isDrawMode = drawMode(dragmode);
        var isSelectMode = selectMode(dragmode);
        if (isDrawMode || isSelectMode) {
          var outlines = zoomLayer.selectAll(".select-outline-" + plotinfo.id);
          if (outlines && gd._fullLayout._outlining) {
            var shapes;
            if (isDrawMode) {
              shapes = newShapes(outlines, dragOptions);
            }
            if (shapes) {
              Registry.call("_guiRelayout", gd, {
                shapes
              });
            }
            var selections;
            if (isSelectMode && !hasSubplot(dragOptions)) {
              selections = newSelections(outlines, dragOptions);
            }
            if (selections) {
              gd._fullLayout._noEmitSelectedAtStart = true;
              Registry.call("_guiRelayout", gd, {
                selections
              }).then(function() {
                if (immediateSelect) {
                  activateLastSelection(gd);
                }
              });
            }
            gd._fullLayout._outlining = false;
          }
        }
        plotinfo.selection = {};
        plotinfo.selection.selectionDefs = dragOptions.selectionDefs = [];
        plotinfo.selection.mergedPolygons = dragOptions.mergedPolygons = [];
      }
      function getAxId(ax) {
        return ax._id;
      }
      function determineSearchTraces(gd, xAxes, yAxes, subplot) {
        if (!gd.calcdata) return [];
        var searchTraces = [];
        var xAxisIds = xAxes.map(getAxId);
        var yAxisIds = yAxes.map(getAxId);
        var cd, trace, i;
        for (i = 0; i < gd.calcdata.length; i++) {
          cd = gd.calcdata[i];
          trace = cd[0].trace;
          if (trace.visible !== true || !trace._module || !trace._module.selectPoints) continue;
          if (hasSubplot({ subplot }) && (trace.subplot === subplot || trace.geo === subplot)) {
            searchTraces.push(createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]));
          } else if (trace.type === "splom") {
            if (trace._xaxes[xAxisIds[0]] && trace._yaxes[yAxisIds[0]]) {
              var info = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);
              info.scene = gd._fullLayout._splomScenes[trace.uid];
              searchTraces.push(info);
            }
          } else if (trace.type === "sankey") {
            var sankeyInfo = createSearchInfo(trace._module, cd, xAxes[0], yAxes[0]);
            searchTraces.push(sankeyInfo);
          } else {
            if (xAxisIds.indexOf(trace.xaxis) === -1 && (!trace._xA || !trace._xA.overlaying)) continue;
            if (yAxisIds.indexOf(trace.yaxis) === -1 && (!trace._yA || !trace._yA.overlaying)) continue;
            searchTraces.push(createSearchInfo(
              trace._module,
              cd,
              getFromId(gd, trace.xaxis),
              getFromId(gd, trace.yaxis)
            ));
          }
        }
        return searchTraces;
      }
      function createSearchInfo(module2, calcData, xaxis, yaxis) {
        return {
          _module: module2,
          cd: calcData,
          xaxis,
          yaxis
        };
      }
      function isHoverDataSet(hoverData) {
        return hoverData && Array.isArray(hoverData) && hoverData[0].hoverOnBox !== true;
      }
      function extractClickedPtInfo(hoverData, searchTraces) {
        var hoverDatum = hoverData[0];
        var pointNumber = -1;
        var pointNumbers = [];
        var searchInfo, i;
        for (i = 0; i < searchTraces.length; i++) {
          searchInfo = searchTraces[i];
          if (hoverDatum.fullData.index === searchInfo.cd[0].trace.index) {
            if (hoverDatum.hoverOnBox === true) {
              break;
            }
            if (hoverDatum.pointNumber !== void 0) {
              pointNumber = hoverDatum.pointNumber;
            } else if (hoverDatum.binNumber !== void 0) {
              pointNumber = hoverDatum.binNumber;
              pointNumbers = hoverDatum.pointNumbers;
            }
            break;
          }
        }
        return {
          pointNumber,
          pointNumbers,
          searchInfo
        };
      }
      function isPointOrBinSelected(clickedPtInfo) {
        var trace = clickedPtInfo.searchInfo.cd[0].trace;
        var ptNum = clickedPtInfo.pointNumber;
        var ptNums = clickedPtInfo.pointNumbers;
        var ptNumsSet = ptNums.length > 0;
        var ptNumToTest = ptNumsSet ? ptNums[0] : ptNum;
        return trace.selectedpoints ? trace.selectedpoints.indexOf(ptNumToTest) > -1 : false;
      }
      function isOnlyThisBinSelected(searchTraces, clickedPtInfo) {
        var tracesWithSelectedPts = [];
        var searchInfo, trace, isSameTrace, i;
        for (i = 0; i < searchTraces.length; i++) {
          searchInfo = searchTraces[i];
          if (searchInfo.cd[0].trace.selectedpoints && searchInfo.cd[0].trace.selectedpoints.length > 0) {
            tracesWithSelectedPts.push(searchInfo);
          }
        }
        if (tracesWithSelectedPts.length === 1) {
          isSameTrace = tracesWithSelectedPts[0] === clickedPtInfo.searchInfo;
          if (isSameTrace) {
            trace = clickedPtInfo.searchInfo.cd[0].trace;
            if (trace.selectedpoints.length === clickedPtInfo.pointNumbers.length) {
              for (i = 0; i < clickedPtInfo.pointNumbers.length; i++) {
                if (trace.selectedpoints.indexOf(clickedPtInfo.pointNumbers[i]) < 0) {
                  return false;
                }
              }
              return true;
            }
          }
        }
        return false;
      }
      function isOnlyOnePointSelected(searchTraces) {
        var len = 0;
        var searchInfo, trace, i;
        for (i = 0; i < searchTraces.length; i++) {
          searchInfo = searchTraces[i];
          trace = searchInfo.cd[0].trace;
          if (trace.selectedpoints) {
            if (trace.selectedpoints.length > 1) return false;
            len += trace.selectedpoints.length;
            if (len > 1) return false;
          }
        }
        return len === 1;
      }
      function updateSelectedState(gd, searchTraces, eventData) {
        var i;
        for (i = 0; i < searchTraces.length; i++) {
          var fullInputTrace = searchTraces[i].cd[0].trace._fullInput;
          var tracePreGUI = gd._fullLayout._tracePreGUI[fullInputTrace.uid] || {};
          if (tracePreGUI.selectedpoints === void 0) {
            tracePreGUI.selectedpoints = fullInputTrace._input.selectedpoints || null;
          }
        }
        var trace;
        if (eventData) {
          var pts = eventData.points || [];
          for (i = 0; i < searchTraces.length; i++) {
            trace = searchTraces[i].cd[0].trace;
            trace._input.selectedpoints = trace._fullInput.selectedpoints = [];
            if (trace._fullInput !== trace) trace.selectedpoints = [];
          }
          for (var k = 0; k < pts.length; k++) {
            var pt = pts[k];
            var data = pt.data;
            var fullData = pt.fullData;
            var pointIndex = pt.pointIndex;
            var pointIndices = pt.pointIndices;
            if (pointIndices) {
              [].push.apply(data.selectedpoints, pointIndices);
              if (trace._fullInput !== trace) {
                [].push.apply(fullData.selectedpoints, pointIndices);
              }
            } else {
              data.selectedpoints.push(pointIndex);
              if (trace._fullInput !== trace) {
                fullData.selectedpoints.push(pointIndex);
              }
            }
          }
        } else {
          for (i = 0; i < searchTraces.length; i++) {
            trace = searchTraces[i].cd[0].trace;
            delete trace.selectedpoints;
            delete trace._input.selectedpoints;
            if (trace._fullInput !== trace) {
              delete trace._fullInput.selectedpoints;
            }
          }
        }
        updateReglSelectedState(gd, searchTraces);
      }
      function updateReglSelectedState(gd, searchTraces) {
        var hasRegl = false;
        for (var i = 0; i < searchTraces.length; i++) {
          var searchInfo = searchTraces[i];
          var cd = searchInfo.cd;
          if (Registry.traceIs(cd[0].trace, "regl")) {
            hasRegl = true;
          }
          var _module = searchInfo._module;
          var fn = _module.styleOnSelect || _module.style;
          if (fn) {
            fn(gd, cd, cd[0].node3);
            if (cd[0].nodeRangePlot3) fn(gd, cd, cd[0].nodeRangePlot3);
          }
        }
        if (hasRegl) {
          clearGlCanvases(gd);
          redrawReglTraces(gd);
        }
      }
      function mergePolygons(list, poly, subtract) {
        var fn = subtract ? polybool.difference : polybool.union;
        var res = fn({
          regions: list
        }, {
          regions: [poly]
        });
        var allPolygons = res.regions.reverse();
        for (var i = 0; i < allPolygons.length; i++) {
          var polygon = allPolygons[i];
          polygon.subtract = getSubtract(polygon, allPolygons.slice(0, i));
        }
        return allPolygons;
      }
      function fillSelectionItem(selection, searchInfo) {
        if (Array.isArray(selection)) {
          var cd = searchInfo.cd;
          var trace = searchInfo.cd[0].trace;
          for (var i = 0; i < selection.length; i++) {
            selection[i] = makeEventData(selection[i], trace, cd);
          }
        }
        return selection;
      }
      function convertPoly(polygonsIn, isOpenMode) {
        var polygonsOut = [];
        for (var i = 0; i < polygonsIn.length; i++) {
          polygonsOut[i] = [];
          for (var j = 0; j < polygonsIn[i].length; j++) {
            polygonsOut[i][j] = [];
            polygonsOut[i][j][0] = j ? "L" : "M";
            for (var k = 0; k < polygonsIn[i][j].length; k++) {
              polygonsOut[i][j].push(
                polygonsIn[i][j][k]
              );
            }
          }
          if (!isOpenMode) {
            polygonsOut[i].push([
              "Z",
              polygonsOut[i][0][1],
              // initial x
              polygonsOut[i][0][2]
              // initial y
            ]);
          }
        }
        return polygonsOut;
      }
      function _doSelect(selectionTesters, searchTraces) {
        var allSelections = [];
        var thisSelection;
        var traceSelections = [];
        var traceSelection;
        for (var i = 0; i < searchTraces.length; i++) {
          var searchInfo = searchTraces[i];
          traceSelection = searchInfo._module.selectPoints(searchInfo, selectionTesters);
          traceSelections.push(traceSelection);
          thisSelection = fillSelectionItem(traceSelection, searchInfo);
          allSelections = allSelections.concat(thisSelection);
        }
        return allSelections;
      }
      function reselect(gd, mayEmitSelected, selectionTesters, searchTraces, dragOptions) {
        var hadSearchTraces = !!searchTraces;
        var plotinfo, xRef, yRef;
        if (dragOptions) {
          plotinfo = dragOptions.plotinfo;
          xRef = dragOptions.xaxes[0]._id;
          yRef = dragOptions.yaxes[0]._id;
        }
        var allSelections = [];
        var allSearchTraces = [];
        var layoutPolygons = getLayoutPolygons(gd);
        var fullLayout = gd._fullLayout;
        if (plotinfo) {
          var zoomLayer = fullLayout._zoomlayer;
          var mode = fullLayout.dragmode;
          var isDrawMode = drawMode(mode);
          var isSelectMode = selectMode(mode);
          if (isDrawMode || isSelectMode) {
            var xaxis = getFromId(gd, xRef, "x");
            var yaxis = getFromId(gd, yRef, "y");
            if (xaxis && yaxis) {
              var outlines = zoomLayer.selectAll(".select-outline-" + plotinfo.id);
              if (outlines && gd._fullLayout._outlining) {
                if (outlines.length) {
                  var e = outlines[0][0];
                  var d = e.getAttribute("d");
                  var outlinePolys = readPaths(d, gd, plotinfo);
                  var draftPolygons = [];
                  for (var u = 0; u < outlinePolys.length; u++) {
                    var p = outlinePolys[u];
                    var polygon = [];
                    for (var t = 0; t < p.length; t++) {
                      polygon.push([
                        convert(xaxis, p[t][1]),
                        convert(yaxis, p[t][2])
                      ]);
                    }
                    polygon.xref = xRef;
                    polygon.yref = yRef;
                    polygon.subtract = getSubtract(polygon, draftPolygons);
                    draftPolygons.push(polygon);
                  }
                  layoutPolygons = layoutPolygons.concat(draftPolygons);
                }
              }
            }
          }
        }
        var subplots = xRef && yRef ? [xRef + yRef] : fullLayout._subplots.cartesian;
        epmtySplomSelectionBatch(gd);
        var seenSplom = {};
        for (var i = 0; i < subplots.length; i++) {
          var subplot = subplots[i];
          var yAt = subplot.indexOf("y");
          var _xRef = subplot.slice(0, yAt);
          var _yRef = subplot.slice(yAt);
          var _selectionTesters = xRef && yRef ? selectionTesters : void 0;
          _selectionTesters = addTester(layoutPolygons, _xRef, _yRef, _selectionTesters);
          if (_selectionTesters) {
            var _searchTraces = searchTraces;
            if (!hadSearchTraces) {
              var _xA = getFromId(gd, _xRef, "x");
              var _yA = getFromId(gd, _yRef, "y");
              _searchTraces = determineSearchTraces(
                gd,
                [_xA],
                [_yA],
                subplot
              );
              for (var w = 0; w < _searchTraces.length; w++) {
                var s = _searchTraces[w];
                var cd0 = s.cd[0];
                var trace = cd0.trace;
                if (s._module.name === "scattergl" && !cd0.t.xpx) {
                  var x = trace.x;
                  var y = trace.y;
                  var len = trace._length;
                  cd0.t.xpx = [];
                  cd0.t.ypx = [];
                  for (var j = 0; j < len; j++) {
                    cd0.t.xpx[j] = _xA.c2p(x[j]);
                    cd0.t.ypx[j] = _yA.c2p(y[j]);
                  }
                }
                if (s._module.name === "splom") {
                  if (!seenSplom[trace.uid]) {
                    seenSplom[trace.uid] = true;
                  }
                }
              }
            }
            var selection = _doSelect(_selectionTesters, _searchTraces);
            allSelections = allSelections.concat(selection);
            allSearchTraces = allSearchTraces.concat(_searchTraces);
          }
        }
        var eventData = { points: allSelections };
        updateSelectedState(gd, allSearchTraces, eventData);
        var clickmode = fullLayout.clickmode;
        var sendEvents = clickmode.indexOf("event") > -1 && mayEmitSelected;
        if (!plotinfo && // get called from plot_api & plots
        mayEmitSelected) {
          var activePolygons = getLayoutPolygons(gd, true);
          if (activePolygons.length) {
            var xref = activePolygons[0].xref;
            var yref = activePolygons[0].yref;
            if (xref && yref) {
              var poly = castMultiPolygon(activePolygons);
              var fillRangeItems = makeFillRangeItems([
                getFromId(gd, xref, "x"),
                getFromId(gd, yref, "y")
              ]);
              fillRangeItems(eventData, poly);
            }
          }
          if (gd._fullLayout._noEmitSelectedAtStart) {
            gd._fullLayout._noEmitSelectedAtStart = false;
          } else {
            if (sendEvents) emitSelected(gd, eventData);
          }
          fullLayout._reselect = false;
        }
        if (!plotinfo && // get called from plot_api & plots
        fullLayout._deselect) {
          var deselect = fullLayout._deselect;
          xRef = deselect.xref;
          yRef = deselect.yref;
          if (!subplotSelected(xRef, yRef, allSearchTraces)) {
            deselectSubplot(gd, xRef, yRef, searchTraces);
          }
          if (sendEvents) {
            if (eventData.points.length) {
              emitSelected(gd, eventData);
            } else {
              emitDeselect(gd);
            }
          }
          fullLayout._deselect = false;
        }
        return {
          eventData,
          selectionTesters
        };
      }
      function epmtySplomSelectionBatch(gd) {
        var cd = gd.calcdata;
        if (!cd) return;
        for (var i = 0; i < cd.length; i++) {
          var cd0 = cd[i][0];
          var trace = cd0.trace;
          var splomScenes = gd._fullLayout._splomScenes;
          if (splomScenes) {
            var scene = splomScenes[trace.uid];
            if (scene) {
              scene.selectBatch = [];
            }
          }
        }
      }
      function subplotSelected(xRef, yRef, searchTraces) {
        for (var i = 0; i < searchTraces.length; i++) {
          var s = searchTraces[i];
          if (s.xaxis && s.xaxis._id === xRef && (s.yaxis && s.yaxis._id === yRef)) {
            return true;
          }
        }
        return false;
      }
      function deselectSubplot(gd, xRef, yRef, searchTraces) {
        searchTraces = determineSearchTraces(
          gd,
          [getFromId(gd, xRef, "x")],
          [getFromId(gd, yRef, "y")],
          xRef + yRef
        );
        for (var k = 0; k < searchTraces.length; k++) {
          var searchInfo = searchTraces[k];
          searchInfo._module.selectPoints(searchInfo, false);
        }
        updateSelectedState(gd, searchTraces);
      }
      function addTester(layoutPolygons, xRef, yRef, selectionTesters) {
        var mergedPolygons;
        for (var i = 0; i < layoutPolygons.length; i++) {
          var currentPolygon = layoutPolygons[i];
          if (xRef !== currentPolygon.xref || yRef !== currentPolygon.yref) continue;
          if (mergedPolygons) {
            var subtract = !!currentPolygon.subtract;
            mergedPolygons = mergePolygons(mergedPolygons, currentPolygon, subtract);
            selectionTesters = multiTester(mergedPolygons);
          } else {
            mergedPolygons = [currentPolygon];
            selectionTesters = polygonTester(currentPolygon);
          }
        }
        return selectionTesters;
      }
      function getLayoutPolygons(gd, onlyActiveOnes) {
        var allPolygons = [];
        var fullLayout = gd._fullLayout;
        var allSelections = fullLayout.selections;
        var len = allSelections.length;
        for (var i = 0; i < len; i++) {
          if (onlyActiveOnes && i !== fullLayout._activeSelectionIndex) continue;
          var selection = allSelections[i];
          if (!selection) continue;
          var xref = selection.xref;
          var yref = selection.yref;
          var xaxis = getFromId(gd, xref, "x");
          var yaxis = getFromId(gd, yref, "y");
          var xmin, xmax, ymin, ymax;
          var polygon;
          if (selection.type === "rect") {
            polygon = [];
            var x0 = convert(xaxis, selection.x0);
            var x1 = convert(xaxis, selection.x1);
            var y0 = convert(yaxis, selection.y0);
            var y1 = convert(yaxis, selection.y1);
            polygon = [[x0, y0], [x0, y1], [x1, y1], [x1, y0]];
            xmin = Math.min(x0, x1);
            xmax = Math.max(x0, x1);
            ymin = Math.min(y0, y1);
            ymax = Math.max(y0, y1);
            polygon.xmin = xmin;
            polygon.xmax = xmax;
            polygon.ymin = ymin;
            polygon.ymax = ymax;
            polygon.xref = xref;
            polygon.yref = yref;
            polygon.subtract = false;
            polygon.isRect = true;
            allPolygons.push(polygon);
          } else if (selection.type === "path") {
            var segments = selection.path.split("Z");
            var multiPolygons = [];
            for (var j = 0; j < segments.length; j++) {
              var path = segments[j];
              if (!path) continue;
              path += "Z";
              var allX = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsX, "raw");
              var allY = shapeHelpers.extractPathCoords(path, shapeConstants.paramIsY, "raw");
              xmin = Infinity;
              xmax = -Infinity;
              ymin = Infinity;
              ymax = -Infinity;
              polygon = [];
              for (var k = 0; k < allX.length; k++) {
                var x = convert(xaxis, allX[k]);
                var y = convert(yaxis, allY[k]);
                polygon.push([x, y]);
                xmin = Math.min(x, xmin);
                xmax = Math.max(x, xmax);
                ymin = Math.min(y, ymin);
                ymax = Math.max(y, ymax);
              }
              polygon.xmin = xmin;
              polygon.xmax = xmax;
              polygon.ymin = ymin;
              polygon.ymax = ymax;
              polygon.xref = xref;
              polygon.yref = yref;
              polygon.subtract = getSubtract(polygon, multiPolygons);
              multiPolygons.push(polygon);
              allPolygons.push(polygon);
            }
          }
        }
        return allPolygons;
      }
      function getSubtract(polygon, previousPolygons) {
        var subtract = false;
        for (var i = 0; i < previousPolygons.length; i++) {
          var previousPolygon = previousPolygons[i];
          for (var k = 0; k < polygon.length; k++) {
            if (pointInPolygon(polygon[k], previousPolygon)) {
              subtract = !subtract;
              break;
            }
          }
        }
        return subtract;
      }
      function convert(ax, d) {
        if (ax.type === "date") d = d.replace("_", " ");
        return ax.type === "log" ? ax.c2p(d) : ax.r2p(d, null, ax.calendar);
      }
      function castMultiPolygon(allPolygons) {
        var len = allPolygons.length;
        var p = [];
        for (var i = 0; i < len; i++) {
          var polygon = allPolygons[i];
          p = p.concat(polygon);
          p = p.concat([polygon[0]]);
        }
        return computeRectAndRanges(p);
      }
      function computeRectAndRanges(poly) {
        poly.isRect = poly.length === 5 && poly[0][0] === poly[4][0] && poly[0][1] === poly[4][1] && (poly[0][0] === poly[1][0] && poly[2][0] === poly[3][0] && poly[0][1] === poly[3][1] && poly[1][1] === poly[2][1]) || poly[0][1] === poly[1][1] && poly[2][1] === poly[3][1] && poly[0][0] === poly[3][0] && poly[1][0] === poly[2][0];
        if (poly.isRect) {
          poly.xmin = Math.min(poly[0][0], poly[2][0]);
          poly.xmax = Math.max(poly[0][0], poly[2][0]);
          poly.ymin = Math.min(poly[0][1], poly[2][1]);
          poly.ymax = Math.max(poly[0][1], poly[2][1]);
        }
        return poly;
      }
      function makeFillRangeItems(allAxes) {
        return function(eventData, poly) {
          var range;
          var lassoPoints;
          for (var i = 0; i < allAxes.length; i++) {
            var ax = allAxes[i];
            var id = ax._id;
            var axLetter = id.charAt(0);
            if (poly.isRect) {
              if (!range) range = {};
              var min = poly[axLetter + "min"];
              var max = poly[axLetter + "max"];
              if (min !== void 0 && max !== void 0) {
                range[id] = [
                  p2r(ax, min),
                  p2r(ax, max)
                ].sort(ascending);
              }
            } else {
              if (!lassoPoints) lassoPoints = {};
              lassoPoints[id] = poly.map(axValue(ax));
            }
          }
          if (range) {
            eventData.range = range;
          }
          if (lassoPoints) {
            eventData.lassoPoints = lassoPoints;
          }
        };
      }
      function getFillRangeItems(dragOptions) {
        var plotinfo = dragOptions.plotinfo;
        return plotinfo.fillRangeItems || // allow subplots (i.e. geo, mapbox, map, sankey) to override fillRangeItems routine
        makeFillRangeItems(dragOptions.xaxes.concat(dragOptions.yaxes));
      }
      function emitSelecting(gd, eventData) {
        gd.emit("plotly_selecting", eventData);
      }
      function emitSelected(gd, eventData) {
        if (eventData) {
          eventData.selections = (gd.layout || {}).selections || [];
        }
        gd.emit("plotly_selected", eventData);
      }
      function emitDeselect(gd) {
        gd.emit("plotly_deselect", null);
      }
      module.exports = {
        reselect,
        prepSelect,
        clearOutline,
        clearSelectionsCache,
        selectOnClick
      };
    }
  });

  // src/components/annotations/arrow_paths.js
  var require_arrow_paths = __commonJS({
    "src/components/annotations/arrow_paths.js"(exports, module) {
      "use strict";
      module.exports = [
        // no arrow
        {
          path: "",
          backoff: 0
        },
        // wide with flat back
        {
          path: "M-2.4,-3V3L0.6,0Z",
          backoff: 0.6
        },
        // narrower with flat back
        {
          path: "M-3.7,-2.5V2.5L1.3,0Z",
          backoff: 1.3
        },
        // barbed
        {
          path: "M-4.45,-3L-1.65,-0.2V0.2L-4.45,3L1.55,0Z",
          backoff: 1.55
        },
        // wide line-drawn
        {
          path: "M-2.2,-2.2L-0.2,-0.2V0.2L-2.2,2.2L-1.4,3L1.6,0L-1.4,-3Z",
          backoff: 1.6
        },
        // narrower line-drawn
        {
          path: "M-4.4,-2.1L-0.6,-0.2V0.2L-4.4,2.1L-4,3L2,0L-4,-3Z",
          backoff: 2
        },
        // circle
        {
          path: "M2,0A2,2 0 1,1 0,-2A2,2 0 0,1 2,0Z",
          backoff: 0,
          noRotate: true
        },
        // square
        {
          path: "M2,2V-2H-2V2Z",
          backoff: 0,
          noRotate: true
        }
      ];
    }
  });

  // src/constants/axis_placeable_objects.js
  var require_axis_placeable_objects = __commonJS({
    "src/constants/axis_placeable_objects.js"(exports, module) {
      "use strict";
      module.exports = {
        axisRefDescription: function(axisname, lower, upper) {
          return [
            "If set to a",
            axisname,
            "axis id (e.g. *" + axisname + "* or",
            "*" + axisname + "2*), the `" + axisname + "` position refers to a",
            axisname,
            "coordinate. If set to *paper*, the `" + axisname + "`",
            "position refers to the distance from the",
            lower,
            "of the plotting",
            "area in normalized coordinates where *0* (*1*) corresponds to the",
            lower,
            "(" + upper + "). If set to a",
            axisname,
            "axis ID followed by",
            "*domain* (separated by a space), the position behaves like for",
            "*paper*, but refers to the distance in fractions of the domain",
            "length from the",
            lower,
            "of the domain of that axis: e.g.,",
            "*" + axisname + "2 domain* refers to the domain of the second",
            axisname,
            " axis and a",
            axisname,
            "position of 0.5 refers to the",
            "point between the",
            lower,
            "and the",
            upper,
            "of the domain of the",
            "second",
            axisname,
            "axis."
          ].join(" ");
        }
      };
    }
  });

  // src/components/annotations/attributes.js
  var require_attributes11 = __commonJS({
    "src/components/annotations/attributes.js"(exports, module) {
      "use strict";
      var ARROWPATHS = require_arrow_paths();
      var fontAttrs = require_font_attributes();
      var cartesianConstants = require_constants2();
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      module.exports = templatedArray("annotation", {
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "calc+arraydraw"
        },
        text: {
          valType: "string",
          editType: "calc+arraydraw"
        },
        textangle: {
          valType: "angle",
          dflt: 0,
          editType: "calc+arraydraw"
        },
        font: fontAttrs({
          editType: "calc+arraydraw",
          colorEditType: "arraydraw"
        }),
        width: {
          valType: "number",
          min: 1,
          dflt: null,
          editType: "calc+arraydraw"
        },
        height: {
          valType: "number",
          min: 1,
          dflt: null,
          editType: "calc+arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "arraydraw"
        },
        align: {
          valType: "enumerated",
          values: ["left", "center", "right"],
          dflt: "center",
          editType: "arraydraw"
        },
        valign: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"],
          dflt: "middle",
          editType: "arraydraw"
        },
        bgcolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)",
          editType: "arraydraw"
        },
        bordercolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)",
          editType: "arraydraw"
        },
        borderpad: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        // arrow
        showarrow: {
          valType: "boolean",
          dflt: true,
          editType: "calc+arraydraw"
        },
        arrowcolor: {
          valType: "color",
          editType: "arraydraw"
        },
        arrowhead: {
          valType: "integer",
          min: 0,
          max: ARROWPATHS.length,
          dflt: 1,
          editType: "arraydraw"
        },
        startarrowhead: {
          valType: "integer",
          min: 0,
          max: ARROWPATHS.length,
          dflt: 1,
          editType: "arraydraw"
        },
        arrowside: {
          valType: "flaglist",
          flags: ["end", "start"],
          extras: ["none"],
          dflt: "end",
          editType: "arraydraw"
        },
        arrowsize: {
          valType: "number",
          min: 0.3,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        startarrowsize: {
          valType: "number",
          min: 0.3,
          dflt: 1,
          editType: "calc+arraydraw"
        },
        arrowwidth: {
          valType: "number",
          min: 0.1,
          editType: "calc+arraydraw"
        },
        standoff: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "calc+arraydraw"
        },
        startstandoff: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "calc+arraydraw"
        },
        ax: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        ay: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        axref: {
          valType: "enumerated",
          dflt: "pixel",
          values: [
            "pixel",
            cartesianConstants.idRegex.x.toString()
          ],
          editType: "calc"
        },
        ayref: {
          valType: "enumerated",
          dflt: "pixel",
          values: [
            "pixel",
            cartesianConstants.idRegex.y.toString()
          ],
          editType: "calc"
        },
        // positioning
        xref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.x.toString()
          ],
          editType: "calc"
        },
        x: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "auto",
          editType: "calc+arraydraw"
        },
        xshift: {
          valType: "number",
          dflt: 0,
          editType: "calc+arraydraw"
        },
        yref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.y.toString()
          ],
          editType: "calc"
        },
        y: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "auto",
          editType: "calc+arraydraw"
        },
        yshift: {
          valType: "number",
          dflt: 0,
          editType: "calc+arraydraw"
        },
        clicktoshow: {
          valType: "enumerated",
          values: [false, "onoff", "onout"],
          dflt: false,
          editType: "arraydraw"
        },
        xclick: {
          valType: "any",
          editType: "arraydraw"
        },
        yclick: {
          valType: "any",
          editType: "arraydraw"
        },
        hovertext: {
          valType: "string",
          editType: "arraydraw"
        },
        hoverlabel: {
          bgcolor: {
            valType: "color",
            editType: "arraydraw"
          },
          bordercolor: {
            valType: "color",
            editType: "arraydraw"
          },
          font: fontAttrs({
            editType: "arraydraw"
          }),
          editType: "arraydraw"
        },
        captureevents: {
          valType: "boolean",
          editType: "arraydraw"
        },
        editType: "calc"
      });
    }
  });

  // src/traces/scatter/constants.js
  var require_constants8 = __commonJS({
    "src/traces/scatter/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        PTS_LINESONLY: 20,
        // fixed parameters of clustering and clipping algorithms
        // fraction of clustering tolerance "so close we don't even consider it a new point"
        minTolerance: 0.2,
        // how fast does clustering tolerance increase as you get away from the visible region
        toleranceGrowth: 10,
        // number of viewport sizes away from the visible region
        // at which we clip all lines to the perimeter
        maxScreensAway: 20,
        eventDataKeys: []
      };
    }
  });

  // src/traces/scatter/fillcolor_attribute.js
  var require_fillcolor_attribute = __commonJS({
    "src/traces/scatter/fillcolor_attribute.js"(exports, module) {
      "use strict";
      module.exports = function makeFillcolorAttr(hasFillgradient) {
        return {
          valType: "color",
          editType: "style",
          anim: true
        };
      };
    }
  });

  // src/traces/scatter/attributes.js
  var require_attributes12 = __commonJS({
    "src/traces/scatter/attributes.js"(exports, module) {
      "use strict";
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var texttemplateAttrs = require_template_attributes().texttemplateAttrs;
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var colorScaleAttrs = require_attributes8();
      var fontAttrs = require_font_attributes();
      var dash = require_attributes4().dash;
      var pattern = require_attributes4().pattern;
      var Drawing = require_drawing();
      var constants = require_constants8();
      var extendFlat = require_extend().extendFlat;
      var makeFillcolorAttr = require_fillcolor_attribute();
      function axisPeriod(axis) {
        return {
          valType: "any",
          dflt: 0,
          editType: "calc"
        };
      }
      function axisPeriod0(axis) {
        return {
          valType: "any",
          editType: "calc"
        };
      }
      function axisPeriodAlignment(axis) {
        return {
          valType: "enumerated",
          values: [
            "start",
            "middle",
            "end"
          ],
          dflt: "middle",
          editType: "calc"
        };
      }
      module.exports = {
        x: {
          valType: "data_array",
          editType: "calc+clearAxisTypes",
          anim: true
        },
        x0: {
          valType: "any",
          dflt: 0,
          editType: "calc+clearAxisTypes",
          anim: true
        },
        dx: {
          valType: "number",
          dflt: 1,
          editType: "calc",
          anim: true
        },
        y: {
          valType: "data_array",
          editType: "calc+clearAxisTypes",
          anim: true
        },
        y0: {
          valType: "any",
          dflt: 0,
          editType: "calc+clearAxisTypes",
          anim: true
        },
        dy: {
          valType: "number",
          dflt: 1,
          editType: "calc",
          anim: true
        },
        xperiod: axisPeriod("x"),
        yperiod: axisPeriod("y"),
        xperiod0: axisPeriod0("x0"),
        yperiod0: axisPeriod0("y0"),
        xperiodalignment: axisPeriodAlignment("x"),
        yperiodalignment: axisPeriodAlignment("y"),
        xhoverformat: axisHoverFormat("x"),
        yhoverformat: axisHoverFormat("y"),
        offsetgroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        alignmentgroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        stackgroup: {
          valType: "string",
          dflt: "",
          editType: "calc"
        },
        orientation: {
          valType: "enumerated",
          values: ["v", "h"],
          editType: "calc"
        },
        groupnorm: {
          valType: "enumerated",
          values: ["", "fraction", "percent"],
          dflt: "",
          editType: "calc"
        },
        stackgaps: {
          valType: "enumerated",
          values: ["infer zero", "interpolate"],
          dflt: "infer zero",
          editType: "calc"
        },
        text: {
          valType: "string",
          dflt: "",
          arrayOk: true,
          editType: "calc"
        },
        texttemplate: texttemplateAttrs({}, {}),
        hovertext: {
          valType: "string",
          dflt: "",
          arrayOk: true,
          editType: "style"
        },
        mode: {
          valType: "flaglist",
          flags: ["lines", "markers", "text"],
          extras: ["none"],
          editType: "calc"
        },
        hoveron: {
          valType: "flaglist",
          flags: ["points", "fills"],
          editType: "style"
        },
        hovertemplate: hovertemplateAttrs({}, {
          keys: constants.eventDataKeys
        }),
        line: {
          color: {
            valType: "color",
            editType: "style",
            anim: true
          },
          width: {
            valType: "number",
            min: 0,
            dflt: 2,
            editType: "style",
            anim: true
          },
          shape: {
            valType: "enumerated",
            values: ["linear", "spline", "hv", "vh", "hvh", "vhv"],
            dflt: "linear",
            editType: "plot"
          },
          smoothing: {
            valType: "number",
            min: 0,
            max: 1.3,
            dflt: 1,
            editType: "plot"
          },
          dash: extendFlat({}, dash, { editType: "style" }),
          backoff: {
            // we want to have a similar option for the start of the line
            valType: "number",
            min: 0,
            dflt: "auto",
            arrayOk: true,
            editType: "plot"
          },
          simplify: {
            valType: "boolean",
            dflt: true,
            editType: "plot"
          },
          editType: "plot"
        },
        connectgaps: {
          valType: "boolean",
          dflt: false,
          editType: "calc"
        },
        cliponaxis: {
          valType: "boolean",
          dflt: true,
          editType: "plot"
        },
        fill: {
          valType: "enumerated",
          values: ["none", "tozeroy", "tozerox", "tonexty", "tonextx", "toself", "tonext"],
          editType: "calc"
        },
        fillcolor: makeFillcolorAttr(true),
        fillgradient: extendFlat({
          type: {
            valType: "enumerated",
            values: ["radial", "horizontal", "vertical", "none"],
            dflt: "none",
            editType: "calc"
          },
          start: {
            valType: "number",
            editType: "calc"
          },
          stop: {
            valType: "number",
            editType: "calc"
          },
          colorscale: {
            valType: "colorscale",
            editType: "style"
          },
          editType: "calc"
        }),
        fillpattern: pattern,
        marker: extendFlat(
          {
            symbol: {
              valType: "enumerated",
              values: Drawing.symbolList,
              dflt: "circle",
              arrayOk: true,
              editType: "style"
            },
            opacity: {
              valType: "number",
              min: 0,
              max: 1,
              arrayOk: true,
              editType: "style",
              anim: true
            },
            angle: {
              valType: "angle",
              dflt: 0,
              arrayOk: true,
              editType: "plot",
              anim: false
              // TODO: possibly set to true in future
            },
            angleref: {
              valType: "enumerated",
              values: ["previous", "up"],
              dflt: "up",
              editType: "plot",
              anim: false
            },
            standoff: {
              valType: "number",
              min: 0,
              dflt: 0,
              arrayOk: true,
              editType: "plot",
              anim: true
            },
            size: {
              valType: "number",
              min: 0,
              dflt: 6,
              arrayOk: true,
              editType: "calc",
              anim: true
            },
            maxdisplayed: {
              valType: "number",
              min: 0,
              dflt: 0,
              editType: "plot"
            },
            sizeref: {
              valType: "number",
              dflt: 1,
              editType: "calc"
            },
            sizemin: {
              valType: "number",
              min: 0,
              dflt: 0,
              editType: "calc"
            },
            sizemode: {
              valType: "enumerated",
              values: ["diameter", "area"],
              dflt: "diameter",
              editType: "calc"
            },
            line: extendFlat(
              {
                width: {
                  valType: "number",
                  min: 0,
                  arrayOk: true,
                  editType: "style",
                  anim: true
                },
                editType: "calc"
              },
              colorScaleAttrs("marker.line", { anim: true })
            ),
            gradient: {
              type: {
                valType: "enumerated",
                values: ["radial", "horizontal", "vertical", "none"],
                arrayOk: true,
                dflt: "none",
                editType: "calc"
              },
              color: {
                valType: "color",
                arrayOk: true,
                editType: "calc"
              },
              editType: "calc"
            },
            editType: "calc"
          },
          colorScaleAttrs("marker", { anim: true })
        ),
        selected: {
          marker: {
            opacity: {
              valType: "number",
              min: 0,
              max: 1,
              editType: "style"
            },
            color: {
              valType: "color",
              editType: "style"
            },
            size: {
              valType: "number",
              min: 0,
              editType: "style"
            },
            editType: "style"
          },
          textfont: {
            color: {
              valType: "color",
              editType: "style"
            },
            editType: "style"
          },
          editType: "style"
        },
        unselected: {
          marker: {
            opacity: {
              valType: "number",
              min: 0,
              max: 1,
              editType: "style"
            },
            color: {
              valType: "color",
              editType: "style"
            },
            size: {
              valType: "number",
              min: 0,
              editType: "style"
            },
            editType: "style"
          },
          textfont: {
            color: {
              valType: "color",
              editType: "style"
            },
            editType: "style"
          },
          editType: "style"
        },
        textposition: {
          valType: "enumerated",
          values: [
            "top left",
            "top center",
            "top right",
            "middle left",
            "middle center",
            "middle right",
            "bottom left",
            "bottom center",
            "bottom right"
          ],
          dflt: "middle center",
          arrayOk: true,
          editType: "calc"
        },
        textfont: fontAttrs({
          editType: "calc",
          colorEditType: "style",
          arrayOk: true
        }),
        zorder: {
          valType: "integer",
          dflt: 0,
          editType: "plot"
        }
      };
    }
  });

  // src/components/selections/attributes.js
  var require_attributes13 = __commonJS({
    "src/components/selections/attributes.js"(exports, module) {
      "use strict";
      var annAttrs = require_attributes11();
      var scatterLineAttrs = require_attributes12().line;
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      module.exports = overrideAll(templatedArray("selection", {
        type: {
          valType: "enumerated",
          values: ["rect", "path"]
        },
        xref: extendFlat({}, annAttrs.xref, {}),
        yref: extendFlat({}, annAttrs.yref, {}),
        x0: {
          valType: "any"
        },
        x1: {
          valType: "any"
        },
        y0: {
          valType: "any"
        },
        y1: {
          valType: "any"
        },
        path: {
          valType: "string",
          editType: "arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 0.7,
          editType: "arraydraw"
        },
        line: {
          color: scatterLineAttrs.color,
          width: extendFlat({}, scatterLineAttrs.width, {
            min: 1,
            dflt: 1
          }),
          dash: extendFlat({}, dash, {
            dflt: "dot"
          })
        }
      }), "arraydraw", "from-root");
    }
  });

  // src/components/selections/defaults.js
  var require_defaults6 = __commonJS({
    "src/components/selections/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes13();
      var helpers = require_helpers8();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name: "selections",
          handleItemDefaults: handleSelectionDefaults
        });
        var selections = layoutOut.selections;
        for (var i = 0; i < selections.length; i++) {
          var selection = selections[i];
          if (!selection) continue;
          if (selection.path === void 0) {
            if (selection.x0 === void 0 || selection.x1 === void 0 || selection.y0 === void 0 || selection.y1 === void 0) {
              layoutOut.selections[i] = null;
            }
          }
        }
      };
      function handleSelectionDefaults(selectionIn, selectionOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(selectionIn, selectionOut, attributes, attr, dflt);
        }
        var path = coerce("path");
        var dfltType = path ? "path" : "rect";
        var selectionType = coerce("type", dfltType);
        var noPath = selectionType !== "path";
        if (noPath) delete selectionOut.path;
        coerce("opacity");
        coerce("line.color");
        coerce("line.width");
        coerce("line.dash");
        var axLetters = ["x", "y"];
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var gdMock = { _fullLayout: fullLayout };
          var ax;
          var pos2r;
          var r2pos;
          var axRef = Axes.coerceRef(selectionIn, selectionOut, gdMock, axLetter);
          ax = Axes.getFromId(gdMock, axRef);
          ax._selectionIndices.push(selectionOut._index);
          r2pos = helpers.rangeToShapePosition(ax);
          pos2r = helpers.shapePositionToRange(ax);
          if (noPath) {
            var attr0 = axLetter + "0";
            var attr1 = axLetter + "1";
            var in0 = selectionIn[attr0];
            var in1 = selectionIn[attr1];
            selectionIn[attr0] = pos2r(selectionIn[attr0], true);
            selectionIn[attr1] = pos2r(selectionIn[attr1], true);
            Axes.coercePosition(selectionOut, gdMock, coerce, axRef, attr0);
            Axes.coercePosition(selectionOut, gdMock, coerce, axRef, attr1);
            var p0 = selectionOut[attr0];
            var p1 = selectionOut[attr1];
            if (p0 !== void 0 && p1 !== void 0) {
              selectionOut[attr0] = r2pos(p0);
              selectionOut[attr1] = r2pos(p1);
              selectionIn[attr0] = in0;
              selectionIn[attr1] = in1;
            }
          }
        }
        if (noPath) {
          Lib.noneOrAll(selectionIn, selectionOut, ["x0", "x1", "y0", "y1"]);
        }
      }
    }
  });

  // src/components/selections/draw_newselection/defaults.js
  var require_defaults7 = __commonJS({
    "src/components/selections/draw_newselection/defaults.js"(exports, module) {
      "use strict";
      module.exports = function supplyDrawNewSelectionDefaults(layoutIn, layoutOut, coerce) {
        coerce("newselection.mode");
        var newselectionLineWidth = coerce("newselection.line.width");
        if (newselectionLineWidth) {
          coerce("newselection.line.color");
          coerce("newselection.line.dash");
        }
        coerce("activeselection.fillcolor");
        coerce("activeselection.opacity");
      };
    }
  });

  // src/plots/cartesian/include_components.js
  var require_include_components = __commonJS({
    "src/plots/cartesian/include_components.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var axisIds = require_axis_ids();
      module.exports = function makeIncludeComponents(containerArrayName) {
        return function includeComponents(layoutIn, layoutOut) {
          var array = layoutIn[containerArrayName];
          if (!Array.isArray(array)) return;
          var Cartesian = Registry.subplotsRegistry.cartesian;
          var idRegex = Cartesian.idRegex;
          var subplots = layoutOut._subplots;
          var xaList = subplots.xaxis;
          var yaList = subplots.yaxis;
          var cartesianList = subplots.cartesian;
          var hasCartesian = layoutOut._has("cartesian");
          for (var i = 0; i < array.length; i++) {
            var itemi = array[i];
            if (!Lib.isPlainObject(itemi)) continue;
            var xref = axisIds.cleanId(itemi.xref, "x", false);
            var yref = axisIds.cleanId(itemi.yref, "y", false);
            var hasXref = idRegex.x.test(xref);
            var hasYref = idRegex.y.test(yref);
            if (hasXref || hasYref) {
              if (!hasCartesian) Lib.pushUnique(layoutOut._basePlotModules, Cartesian);
              var newAxis = false;
              if (hasXref && xaList.indexOf(xref) === -1) {
                xaList.push(xref);
                newAxis = true;
              }
              if (hasYref && yaList.indexOf(yref) === -1) {
                yaList.push(yref);
                newAxis = true;
              }
              if (newAxis && hasXref && hasYref) {
                cartesianList.push(xref + yref);
              }
            }
          }
        };
      };
    }
  });

  // src/components/selections/index.js
  var require_selections = __commonJS({
    "src/components/selections/index.js"(exports, module) {
      "use strict";
      var drawModule = require_draw3();
      var select = require_select();
      module.exports = {
        moduleType: "component",
        name: "selections",
        layoutAttributes: require_attributes13(),
        supplyLayoutDefaults: require_defaults6(),
        supplyDrawNewSelectionDefaults: require_defaults7(),
        includeBasePlot: require_include_components()("selections"),
        draw: drawModule.draw,
        drawOne: drawModule.drawOne,
        reselect: select.reselect,
        prepSelect: select.prepSelect,
        clearOutline: select.clearOutline,
        clearSelectionsCache: select.clearSelectionsCache,
        selectOnClick: select.selectOnClick
      };
    }
  });

  // src/plots/cartesian/dragbox.js
  var require_dragbox = __commonJS({
    "src/plots/cartesian/dragbox.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var numberFormat = Lib.numberFormat;
      var tinycolor = require_tinycolor();
      var supportsPassive = require_has_passive_events();
      var Registry = require_registry();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var Color = require_color();
      var Drawing = require_drawing();
      var Fx = require_fx();
      var Axes = require_axes();
      var setCursor = require_setcursor();
      var dragElement = require_dragelement();
      var helpers = require_helpers5();
      var selectingOrDrawing = helpers.selectingOrDrawing;
      var freeMode = helpers.freeMode;
      var FROM_TL = require_alignment().FROM_TL;
      var clearGlCanvases = require_clear_gl_canvases();
      var redrawReglTraces = require_subroutines().redrawReglTraces;
      var Plots = require_plots();
      var getFromId = require_axis_ids().getFromId;
      var prepSelect = require_selections().prepSelect;
      var clearOutline = require_selections().clearOutline;
      var selectOnClick = require_selections().selectOnClick;
      var scaleZoom = require_scale_zoom();
      var constants = require_constants2();
      var MINDRAG = constants.MINDRAG;
      var MINZOOM = constants.MINZOOM;
      var SHOWZOOMOUTTIP = true;
      function makeDragBox(gd, plotinfo, x, y, w, h, ns, ew) {
        var zoomlayer = gd._fullLayout._zoomlayer;
        var isMainDrag = ns + ew === "nsew";
        var singleEnd = (ns + ew).length === 1;
        var xa0, ya0;
        var xaHash, yaHash;
        var xaxes, yaxes;
        var xs, ys;
        var pw, ph;
        var links;
        var matches;
        var xActive, yActive;
        var allFixedRanges;
        var editX, editY;
        var hasScatterGl, hasSplom, hasSVG;
        var updates;
        var scaleX;
        var scaleY;
        x += plotinfo.yaxis._shift;
        function recomputeAxisLists() {
          xa0 = plotinfo.xaxis;
          ya0 = plotinfo.yaxis;
          pw = xa0._length;
          ph = ya0._length;
          xs = xa0._offset;
          ys = ya0._offset;
          xaHash = {};
          xaHash[xa0._id] = xa0;
          yaHash = {};
          yaHash[ya0._id] = ya0;
          if (ns && ew) {
            var overlays = plotinfo.overlays;
            for (var i = 0; i < overlays.length; i++) {
              var xa = overlays[i].xaxis;
              xaHash[xa._id] = xa;
              var ya = overlays[i].yaxis;
              yaHash[ya._id] = ya;
            }
          }
          xaxes = hashValues(xaHash);
          yaxes = hashValues(yaHash);
          xActive = isDirectionActive(xaxes, ew);
          yActive = isDirectionActive(yaxes, ns);
          allFixedRanges = !yActive && !xActive;
          matches = calcLinks(gd, gd._fullLayout._axisMatchGroups, xaHash, yaHash);
          links = calcLinks(gd, gd._fullLayout._axisConstraintGroups, xaHash, yaHash, matches);
          var spConstrained = links.isSubplotConstrained || matches.isSubplotConstrained;
          editX = ew || spConstrained;
          editY = ns || spConstrained;
          var fullLayout = gd._fullLayout;
          hasScatterGl = fullLayout._has("scattergl");
          hasSplom = fullLayout._has("splom");
          hasSVG = fullLayout._has("svg");
        }
        recomputeAxisLists();
        var cursor = getDragCursor(yActive + xActive, gd._fullLayout.dragmode, isMainDrag);
        var dragger = makeRectDragger(plotinfo, ns + ew + "drag", cursor, x, y, w, h);
        if (allFixedRanges && !isMainDrag) {
          dragger.onmousedown = null;
          dragger.style.pointerEvents = "none";
          return dragger;
        }
        var dragOptions = {
          element: dragger,
          gd,
          plotinfo
        };
        dragOptions.prepFn = function(e, startX, startY) {
          var dragModePrev = dragOptions.dragmode;
          var dragModeNow = gd._fullLayout.dragmode;
          if (dragModeNow !== dragModePrev) {
            dragOptions.dragmode = dragModeNow;
          }
          recomputeAxisLists();
          scaleX = gd._fullLayout._invScaleX;
          scaleY = gd._fullLayout._invScaleY;
          if (!allFixedRanges) {
            if (isMainDrag) {
              if (e.shiftKey) {
                if (dragModeNow === "pan") dragModeNow = "zoom";
                else if (!selectingOrDrawing(dragModeNow)) dragModeNow = "pan";
              } else if (e.ctrlKey) {
                dragModeNow = "pan";
              }
            } else {
              dragModeNow = "pan";
            }
          }
          if (freeMode(dragModeNow)) dragOptions.minDrag = 1;
          else dragOptions.minDrag = void 0;
          if (selectingOrDrawing(dragModeNow)) {
            dragOptions.xaxes = xaxes;
            dragOptions.yaxes = yaxes;
            prepSelect(e, startX, startY, dragOptions, dragModeNow);
          } else {
            dragOptions.clickFn = clickFn;
            if (selectingOrDrawing(dragModePrev)) {
              clearAndResetSelect();
            }
            if (!allFixedRanges) {
              if (dragModeNow === "zoom") {
                dragOptions.moveFn = zoomMove;
                dragOptions.doneFn = zoomDone;
                dragOptions.minDrag = 1;
                zoomPrep(e, startX, startY);
              } else if (dragModeNow === "pan") {
                dragOptions.moveFn = plotDrag;
                dragOptions.doneFn = dragTail;
              }
            }
          }
          gd._fullLayout._redrag = function() {
            var dragDataNow = gd._dragdata;
            if (dragDataNow && dragDataNow.element === dragger) {
              var dragModeNow2 = gd._fullLayout.dragmode;
              if (!selectingOrDrawing(dragModeNow2)) {
                recomputeAxisLists();
                updateSubplots([0, 0, pw, ph]);
                dragOptions.moveFn(dragDataNow.dx, dragDataNow.dy);
              }
            }
          };
        };
        function clearAndResetSelect() {
          dragOptions.plotinfo.selection = false;
          clearOutline(gd);
        }
        function clickFn(numClicks, evt) {
          var gd2 = dragOptions.gd;
          if (gd2._fullLayout._activeShapeIndex >= 0) {
            gd2._fullLayout._deactivateShape(gd2);
            return;
          }
          var clickmode = gd2._fullLayout.clickmode;
          removeZoombox(gd2);
          if (numClicks === 2 && !singleEnd) doubleClick();
          if (isMainDrag) {
            if (clickmode.indexOf("select") > -1) {
              selectOnClick(evt, gd2, xaxes, yaxes, plotinfo.id, dragOptions);
            }
            if (clickmode.indexOf("event") > -1) {
              Fx.click(gd2, evt, plotinfo.id);
            }
          } else if (numClicks === 1 && singleEnd) {
            var ax = ns ? ya0 : xa0;
            var end = ns === "s" || ew === "w" ? 0 : 1;
            var attrStr = ax._name + ".range[" + end + "]";
            var initialText = getEndText(ax, end);
            var hAlign = "left";
            var vAlign = "middle";
            if (ax.fixedrange) return;
            if (ns) {
              vAlign = ns === "n" ? "top" : "bottom";
              if (ax.side === "right") hAlign = "right";
            } else if (ew === "e") hAlign = "right";
            if (gd2._context.showAxisRangeEntryBoxes) {
              d3.select(dragger).call(svgTextUtils.makeEditable, {
                gd: gd2,
                immediate: true,
                background: gd2._fullLayout.paper_bgcolor,
                text: String(initialText),
                fill: ax.tickfont ? ax.tickfont.color : "#444",
                horizontalAlign: hAlign,
                verticalAlign: vAlign
              }).on("edit", function(text) {
                var v = ax.d2r(text);
                if (v !== void 0) {
                  Registry.call("_guiRelayout", gd2, attrStr, v);
                }
              });
            }
          }
        }
        dragElement.init(dragOptions);
        var x0, y0;
        var box;
        var lum;
        var path0;
        var dimmed;
        var zoomMode;
        var zb;
        var corners;
        var zoomDragged;
        function zoomPrep(e, startX, startY) {
          var dragBBox = dragger.getBoundingClientRect();
          x0 = startX - dragBBox.left;
          y0 = startY - dragBBox.top;
          gd._fullLayout._calcInverseTransform(gd);
          var transformedCoords = Lib.apply3DTransform(gd._fullLayout._invTransform)(x0, y0);
          x0 = transformedCoords[0];
          y0 = transformedCoords[1];
          box = { l: x0, r: x0, w: 0, t: y0, b: y0, h: 0 };
          lum = gd._hmpixcount ? gd._hmlumcount / gd._hmpixcount : tinycolor(gd._fullLayout.plot_bgcolor).getLuminance();
          path0 = "M0,0H" + pw + "V" + ph + "H0V0";
          dimmed = false;
          zoomMode = "xy";
          zoomDragged = false;
          zb = makeZoombox(zoomlayer, lum, xs, ys, path0);
          corners = makeCorners(zoomlayer, xs, ys);
        }
        function zoomMove(dx0, dy0) {
          if (gd._transitioningWithDuration) {
            return false;
          }
          var x1 = Math.max(0, Math.min(pw, scaleX * dx0 + x0));
          var y1 = Math.max(0, Math.min(ph, scaleY * dy0 + y0));
          var dx = Math.abs(x1 - x0);
          var dy = Math.abs(y1 - y0);
          box.l = Math.min(x0, x1);
          box.r = Math.max(x0, x1);
          box.t = Math.min(y0, y1);
          box.b = Math.max(y0, y1);
          function noZoom() {
            zoomMode = "";
            box.r = box.l;
            box.t = box.b;
            corners.attr("d", "M0,0Z");
          }
          if (links.isSubplotConstrained) {
            if (dx > MINZOOM || dy > MINZOOM) {
              zoomMode = "xy";
              if (dx / pw > dy / ph) {
                dy = dx * ph / pw;
                if (y0 > y1) box.t = y0 - dy;
                else box.b = y0 + dy;
              } else {
                dx = dy * pw / ph;
                if (x0 > x1) box.l = x0 - dx;
                else box.r = x0 + dx;
              }
              corners.attr("d", xyCorners(box));
            } else {
              noZoom();
            }
          } else if (matches.isSubplotConstrained) {
            if (dx > MINZOOM || dy > MINZOOM) {
              zoomMode = "xy";
              var r0 = Math.min(box.l / pw, (ph - box.b) / ph);
              var r1 = Math.max(box.r / pw, (ph - box.t) / ph);
              box.l = r0 * pw;
              box.r = r1 * pw;
              box.b = (1 - r0) * ph;
              box.t = (1 - r1) * ph;
              corners.attr("d", xyCorners(box));
            } else {
              noZoom();
            }
          } else if (!yActive || dy < Math.min(Math.max(dx * 0.6, MINDRAG), MINZOOM)) {
            if (dx < MINDRAG || !xActive) {
              noZoom();
            } else {
              box.t = 0;
              box.b = ph;
              zoomMode = "x";
              corners.attr("d", xCorners(box, y0));
            }
          } else if (!xActive || dx < Math.min(dy * 0.6, MINZOOM)) {
            box.l = 0;
            box.r = pw;
            zoomMode = "y";
            corners.attr("d", yCorners(box, x0));
          } else {
            zoomMode = "xy";
            corners.attr("d", xyCorners(box));
          }
          box.w = box.r - box.l;
          box.h = box.b - box.t;
          if (zoomMode) zoomDragged = true;
          gd._dragged = zoomDragged;
          updateZoombox(zb, corners, box, path0, dimmed, lum);
          computeZoomUpdates();
          gd.emit("plotly_relayouting", updates);
          dimmed = true;
        }
        function computeZoomUpdates() {
          updates = {};
          if (zoomMode === "xy" || zoomMode === "x") {
            zoomAxRanges(xaxes, box.l / pw, box.r / pw, updates, links.xaxes);
            updateMatchedAxRange("x", updates);
          }
          if (zoomMode === "xy" || zoomMode === "y") {
            zoomAxRanges(yaxes, (ph - box.b) / ph, (ph - box.t) / ph, updates, links.yaxes);
            updateMatchedAxRange("y", updates);
          }
        }
        function zoomDone() {
          computeZoomUpdates();
          removeZoombox(gd);
          dragTail();
          showDoubleClickNotifier(gd);
        }
        var scrollViewBox = [0, 0, pw, ph];
        var redrawTimer = null;
        var REDRAWDELAY = constants.REDRAWDELAY;
        var mainplot = plotinfo.mainplot ? gd._fullLayout._plots[plotinfo.mainplot] : plotinfo;
        function zoomWheel(e) {
          if (!gd._context._scrollZoom.cartesian && !gd._fullLayout._enablescrollzoom) {
            return;
          }
          clearAndResetSelect();
          if (gd._transitioningWithDuration) {
            e.preventDefault();
            e.stopPropagation();
            return;
          }
          recomputeAxisLists();
          clearTimeout(redrawTimer);
          var wheelDelta = -e.deltaY;
          if (!isFinite(wheelDelta)) wheelDelta = e.wheelDelta / 10;
          if (!isFinite(wheelDelta)) {
            Lib.log("Did not find wheel motion attributes: ", e);
            return;
          }
          var zoom = Math.exp(-Math.min(Math.max(wheelDelta, -20), 20) / 200);
          var gbb = mainplot.draglayer.select(".nsewdrag").node().getBoundingClientRect();
          var xfrac = (e.clientX - gbb.left) / gbb.width;
          var yfrac = (gbb.bottom - e.clientY) / gbb.height;
          var i;
          function zoomWheelOneAxis(ax, centerFraction, zoom2) {
            if (ax.fixedrange) return;
            var axRange = Lib.simpleMap(ax.range, ax.r2l);
            var v0 = axRange[0] + (axRange[1] - axRange[0]) * centerFraction;
            function doZoom(v) {
              return ax.l2r(v0 + (v - v0) * zoom2);
            }
            ax.range = axRange.map(doZoom);
          }
          if (editX) {
            if (!ew) xfrac = 0.5;
            for (i = 0; i < xaxes.length; i++) {
              zoomWheelOneAxis(xaxes[i], xfrac, zoom);
            }
            updateMatchedAxRange("x");
            scrollViewBox[2] *= zoom;
            scrollViewBox[0] += scrollViewBox[2] * xfrac * (1 / zoom - 1);
          }
          if (editY) {
            if (!ns) yfrac = 0.5;
            for (i = 0; i < yaxes.length; i++) {
              zoomWheelOneAxis(yaxes[i], yfrac, zoom);
            }
            updateMatchedAxRange("y");
            scrollViewBox[3] *= zoom;
            scrollViewBox[1] += scrollViewBox[3] * (1 - yfrac) * (1 / zoom - 1);
          }
          updateSubplots(scrollViewBox);
          ticksAndAnnotations();
          gd.emit("plotly_relayouting", updates);
          redrawTimer = setTimeout(function() {
            if (!gd._fullLayout) return;
            scrollViewBox = [0, 0, pw, ph];
            dragTail();
          }, REDRAWDELAY);
          e.preventDefault();
          return;
        }
        if (ns.length * ew.length !== 1) {
          attachWheelEventHandler(dragger, zoomWheel);
        }
        function plotDrag(dx, dy) {
          dx = dx * scaleX;
          dy = dy * scaleY;
          if (gd._transitioningWithDuration) {
            return;
          }
          gd._fullLayout._replotting = true;
          if (xActive === "ew" || yActive === "ns") {
            var spDx = xActive ? -dx : 0;
            var spDy = yActive ? -dy : 0;
            if (matches.isSubplotConstrained) {
              if (xActive && yActive) {
                var frac = (dx / pw - dy / ph) / 2;
                dx = frac * pw;
                dy = -frac * ph;
                spDx = -dx;
                spDy = -dy;
              }
              if (yActive) {
                spDx = -spDy * pw / ph;
              } else {
                spDy = -spDx * ph / pw;
              }
            }
            if (xActive) {
              dragAxList(xaxes, dx);
              updateMatchedAxRange("x");
            }
            if (yActive) {
              dragAxList(yaxes, dy);
              updateMatchedAxRange("y");
            }
            updateSubplots([spDx, spDy, pw, ph]);
            ticksAndAnnotations();
            gd.emit("plotly_relayouting", updates);
            return;
          }
          function dz(axArray, end, d) {
            var otherEnd = 1 - end;
            var movedAx;
            var newLinearizedEnd;
            for (var i2 = 0; i2 < axArray.length; i2++) {
              var axi = axArray[i2];
              if (axi.fixedrange) continue;
              movedAx = axi;
              newLinearizedEnd = axi._rl[otherEnd] + (axi._rl[end] - axi._rl[otherEnd]) / dZoom(d / axi._length);
              var newEnd = axi.l2r(newLinearizedEnd);
              if (newEnd !== false && newEnd !== void 0) axi.range[end] = newEnd;
            }
            return movedAx._length * (movedAx._rl[end] - newLinearizedEnd) / (movedAx._rl[end] - movedAx._rl[otherEnd]);
          }
          var dxySign = xActive === "w" === (yActive === "n") ? 1 : -1;
          if (xActive && yActive && (links.isSubplotConstrained || matches.isSubplotConstrained)) {
            var dxyFraction = (dx / pw + dxySign * dy / ph) / 2;
            dx = dxyFraction * pw;
            dy = dxySign * dxyFraction * ph;
          }
          var xStart, yStart;
          if (xActive === "w") dx = dz(xaxes, 0, dx);
          else if (xActive === "e") dx = dz(xaxes, 1, -dx);
          else if (!xActive) dx = 0;
          if (yActive === "n") dy = dz(yaxes, 1, dy);
          else if (yActive === "s") dy = dz(yaxes, 0, -dy);
          else if (!yActive) dy = 0;
          xStart = xActive === "w" ? dx : 0;
          yStart = yActive === "n" ? dy : 0;
          if (links.isSubplotConstrained && !matches.isSubplotConstrained || // NW or SE on matching axes - create a symmetric zoom
          matches.isSubplotConstrained && xActive && yActive && dxySign > 0) {
            var i;
            if (matches.isSubplotConstrained || !xActive && yActive.length === 1) {
              for (i = 0; i < xaxes.length; i++) {
                xaxes[i].range = xaxes[i]._r.slice();
                scaleZoom(xaxes[i], 1 - dy / ph);
              }
              dx = dy * pw / ph;
              xStart = dx / 2;
            }
            if (matches.isSubplotConstrained || !yActive && xActive.length === 1) {
              for (i = 0; i < yaxes.length; i++) {
                yaxes[i].range = yaxes[i]._r.slice();
                scaleZoom(yaxes[i], 1 - dx / pw);
              }
              dy = dx * ph / pw;
              yStart = dy / 2;
            }
          }
          if (!matches.isSubplotConstrained || !yActive) {
            updateMatchedAxRange("x");
          }
          if (!matches.isSubplotConstrained || !xActive) {
            updateMatchedAxRange("y");
          }
          var xSize = pw - dx;
          var ySize = ph - dy;
          if (matches.isSubplotConstrained && !(xActive && yActive)) {
            if (xActive) {
              yStart = xStart ? 0 : dx * ph / pw;
              ySize = xSize * ph / pw;
            } else {
              xStart = yStart ? 0 : dy * pw / ph;
              xSize = ySize * pw / ph;
            }
          }
          updateSubplots([xStart, yStart, xSize, ySize]);
          ticksAndAnnotations();
          gd.emit("plotly_relayouting", updates);
        }
        function updateMatchedAxRange(axLetter, out) {
          var matchedAxes = matches.isSubplotConstrained ? { x: yaxes, y: xaxes }[axLetter] : matches[axLetter + "axes"];
          var constrainedAxes = matches.isSubplotConstrained ? { x: xaxes, y: yaxes }[axLetter] : [];
          for (var i = 0; i < matchedAxes.length; i++) {
            var ax = matchedAxes[i];
            var axId = ax._id;
            var axId2 = matches.xLinks[axId] || matches.yLinks[axId];
            var ax2 = constrainedAxes[0] || xaHash[axId2] || yaHash[axId2];
            if (ax2) {
              if (out) {
                out[ax._name + ".range[0]"] = out[ax2._name + ".range[0]"];
                out[ax._name + ".range[1]"] = out[ax2._name + ".range[1]"];
              } else {
                ax.range = ax2.range.slice();
              }
            }
          }
        }
        function ticksAndAnnotations() {
          var activeAxIds = [];
          var i;
          function pushActiveAxIds(axList) {
            for (i = 0; i < axList.length; i++) {
              if (!axList[i].fixedrange) activeAxIds.push(axList[i]._id);
            }
          }
          function pushActiveAxIdsSynced(axList, axisType) {
            for (i = 0; i < axList.length; i++) {
              var axListI = axList[i];
              var axListIType = axListI[axisType];
              if (!axListI.fixedrange && axListIType.tickmode === "sync") activeAxIds.push(axListIType._id);
            }
          }
          if (editX) {
            pushActiveAxIds(xaxes);
            pushActiveAxIds(links.xaxes);
            pushActiveAxIds(matches.xaxes);
            pushActiveAxIdsSynced(plotinfo.overlays, "xaxis");
          }
          if (editY) {
            pushActiveAxIds(yaxes);
            pushActiveAxIds(links.yaxes);
            pushActiveAxIds(matches.yaxes);
            pushActiveAxIdsSynced(plotinfo.overlays, "yaxis");
          }
          updates = {};
          for (i = 0; i < activeAxIds.length; i++) {
            var axId = activeAxIds[i];
            var ax = getFromId(gd, axId);
            Axes.drawOne(gd, ax, { skipTitle: true });
            updates[ax._name + ".range[0]"] = ax.range[0];
            updates[ax._name + ".range[1]"] = ax.range[1];
          }
          Axes.redrawComponents(gd, activeAxIds);
        }
        function doubleClick() {
          if (gd._transitioningWithDuration) return;
          var doubleClickConfig = gd._context.doubleClick;
          var axList = [];
          if (xActive) axList = axList.concat(xaxes);
          if (yActive) axList = axList.concat(yaxes);
          if (matches.xaxes) axList = axList.concat(matches.xaxes);
          if (matches.yaxes) axList = axList.concat(matches.yaxes);
          var attrs = {};
          var ax, i;
          if (doubleClickConfig === "reset+autosize") {
            doubleClickConfig = "autosize";
            for (i = 0; i < axList.length; i++) {
              ax = axList[i];
              var r0 = ax._rangeInitial0;
              var r1 = ax._rangeInitial1;
              var hasRangeInitial = r0 !== void 0 || r1 !== void 0;
              if (hasRangeInitial && (r0 !== void 0 && r0 !== ax.range[0] || r1 !== void 0 && r1 !== ax.range[1]) || !hasRangeInitial && ax.autorange !== true) {
                doubleClickConfig = "reset";
                break;
              }
            }
          }
          if (doubleClickConfig === "autosize") {
            for (i = 0; i < axList.length; i++) {
              ax = axList[i];
              if (!ax.fixedrange) attrs[ax._name + ".autorange"] = true;
            }
          } else if (doubleClickConfig === "reset") {
            if (xActive || links.isSubplotConstrained) axList = axList.concat(links.xaxes);
            if (yActive && !links.isSubplotConstrained) axList = axList.concat(links.yaxes);
            if (links.isSubplotConstrained) {
              if (!xActive) axList = axList.concat(xaxes);
              else if (!yActive) axList = axList.concat(yaxes);
            }
            for (i = 0; i < axList.length; i++) {
              ax = axList[i];
              if (!ax.fixedrange) {
                var axName = ax._name;
                var autorangeInitial = ax._autorangeInitial;
                if (ax._rangeInitial0 === void 0 && ax._rangeInitial1 === void 0) {
                  attrs[axName + ".autorange"] = true;
                } else if (ax._rangeInitial0 === void 0) {
                  attrs[axName + ".autorange"] = autorangeInitial;
                  attrs[axName + ".range"] = [null, ax._rangeInitial1];
                } else if (ax._rangeInitial1 === void 0) {
                  attrs[axName + ".range"] = [ax._rangeInitial0, null];
                  attrs[axName + ".autorange"] = autorangeInitial;
                } else {
                  attrs[axName + ".range"] = [ax._rangeInitial0, ax._rangeInitial1];
                }
              }
            }
          }
          gd.emit("plotly_doubleclick", null);
          Registry.call("_guiRelayout", gd, attrs);
        }
        function dragTail() {
          updateSubplots([0, 0, pw, ph]);
          Lib.syncOrAsync([
            Plots.previousPromises,
            function() {
              gd._fullLayout._replotting = false;
              Registry.call("_guiRelayout", gd, updates);
            }
          ], gd);
        }
        function updateSubplots(viewBox) {
          var fullLayout = gd._fullLayout;
          var plotinfos = fullLayout._plots;
          var subplots = fullLayout._subplots.cartesian;
          var i, sp, xa, ya;
          if (hasSplom) {
            Registry.subplotsRegistry.splom.drag(gd);
          }
          if (hasScatterGl) {
            for (i = 0; i < subplots.length; i++) {
              sp = plotinfos[subplots[i]];
              xa = sp.xaxis;
              ya = sp.yaxis;
              if (sp._scene) {
                if (xa.limitRange) xa.limitRange();
                if (ya.limitRange) ya.limitRange();
                var xrng = Lib.simpleMap(xa.range, xa.r2l);
                var yrng = Lib.simpleMap(ya.range, ya.r2l);
                sp._scene.update({ range: [xrng[0], yrng[0], xrng[1], yrng[1]] });
              }
            }
          }
          if (hasSplom || hasScatterGl) {
            clearGlCanvases(gd);
            redrawReglTraces(gd);
          }
          if (hasSVG) {
            var xScaleFactor = viewBox[2] / xa0._length;
            var yScaleFactor = viewBox[3] / ya0._length;
            for (i = 0; i < subplots.length; i++) {
              sp = plotinfos[subplots[i]];
              xa = sp.xaxis;
              ya = sp.yaxis;
              var editX2 = (editX || matches.isSubplotConstrained) && !xa.fixedrange && xaHash[xa._id];
              var editY2 = (editY || matches.isSubplotConstrained) && !ya.fixedrange && yaHash[ya._id];
              var xScaleFactor2, yScaleFactor2;
              var clipDx, clipDy;
              if (editX2) {
                xScaleFactor2 = xScaleFactor;
                clipDx = ew || matches.isSubplotConstrained ? viewBox[0] : getShift(xa, xScaleFactor2);
              } else if (matches.xaHash[xa._id]) {
                xScaleFactor2 = xScaleFactor;
                clipDx = viewBox[0] * xa._length / xa0._length;
              } else if (matches.yaHash[xa._id]) {
                xScaleFactor2 = yScaleFactor;
                clipDx = yActive === "ns" ? -viewBox[1] * xa._length / ya0._length : getShift(xa, xScaleFactor2, { n: "top", s: "bottom" }[yActive]);
              } else {
                xScaleFactor2 = getLinkedScaleFactor(xa, xScaleFactor, yScaleFactor);
                clipDx = scaleAndGetShift(xa, xScaleFactor2);
              }
              if (xScaleFactor2 > 1 && (xa.maxallowed !== void 0 && editX === (xa.range[0] < xa.range[1] ? "e" : "w") || xa.minallowed !== void 0 && editX === (xa.range[0] < xa.range[1] ? "w" : "e"))) {
                xScaleFactor2 = 1;
                clipDx = 0;
              }
              if (editY2) {
                yScaleFactor2 = yScaleFactor;
                clipDy = ns || matches.isSubplotConstrained ? viewBox[1] : getShift(ya, yScaleFactor2);
              } else if (matches.yaHash[ya._id]) {
                yScaleFactor2 = yScaleFactor;
                clipDy = viewBox[1] * ya._length / ya0._length;
              } else if (matches.xaHash[ya._id]) {
                yScaleFactor2 = xScaleFactor;
                clipDy = xActive === "ew" ? -viewBox[0] * ya._length / xa0._length : getShift(ya, yScaleFactor2, { e: "right", w: "left" }[xActive]);
              } else {
                yScaleFactor2 = getLinkedScaleFactor(ya, xScaleFactor, yScaleFactor);
                clipDy = scaleAndGetShift(ya, yScaleFactor2);
              }
              if (yScaleFactor2 > 1 && (ya.maxallowed !== void 0 && editY === (ya.range[0] < ya.range[1] ? "n" : "s") || ya.minallowed !== void 0 && editY === (ya.range[0] < ya.range[1] ? "s" : "n"))) {
                yScaleFactor2 = 1;
                clipDy = 0;
              }
              if (!xScaleFactor2 && !yScaleFactor2) {
                continue;
              }
              if (!xScaleFactor2) xScaleFactor2 = 1;
              if (!yScaleFactor2) yScaleFactor2 = 1;
              var plotDx = xa._offset - clipDx / xScaleFactor2;
              var plotDy = ya._offset - clipDy / yScaleFactor2;
              sp.clipRect.call(Drawing.setTranslate, clipDx, clipDy).call(Drawing.setScale, xScaleFactor2, yScaleFactor2);
              sp.plot.call(Drawing.setTranslate, plotDx, plotDy).call(Drawing.setScale, 1 / xScaleFactor2, 1 / yScaleFactor2);
              if (xScaleFactor2 !== sp.xScaleFactor || yScaleFactor2 !== sp.yScaleFactor) {
                Drawing.setPointGroupScale(sp.zoomScalePts, xScaleFactor2, yScaleFactor2);
                Drawing.setTextPointsScale(sp.zoomScaleTxt, xScaleFactor2, yScaleFactor2);
              }
              Drawing.hideOutsideRangePoints(sp.clipOnAxisFalseTraces, sp);
              sp.xScaleFactor = xScaleFactor2;
              sp.yScaleFactor = yScaleFactor2;
            }
          }
        }
        function getLinkedScaleFactor(ax, xScaleFactor, yScaleFactor) {
          if (ax.fixedrange) return 0;
          if (editX && links.xaHash[ax._id]) {
            return xScaleFactor;
          }
          if (editY && (links.isSubplotConstrained ? links.xaHash : links.yaHash)[ax._id]) {
            return yScaleFactor;
          }
          return 0;
        }
        function scaleAndGetShift(ax, scaleFactor) {
          if (scaleFactor) {
            ax.range = ax._r.slice();
            scaleZoom(ax, scaleFactor);
            return getShift(ax, scaleFactor);
          }
          return 0;
        }
        function getShift(ax, scaleFactor, from) {
          return ax._length * (1 - scaleFactor) * FROM_TL[from || ax.constraintoward || "middle"];
        }
        return dragger;
      }
      function makeDragger(plotinfo, nodeName, dragClass, cursor) {
        var dragger3 = Lib.ensureSingle(plotinfo.draglayer, nodeName, dragClass, function(s) {
          s.classed("drag", true).style({ fill: "transparent", "stroke-width": 0 }).attr("data-subplot", plotinfo.id);
        });
        dragger3.call(setCursor, cursor);
        return dragger3.node();
      }
      function makeRectDragger(plotinfo, dragClass, cursor, x, y, w, h) {
        var dragger = makeDragger(plotinfo, "rect", dragClass, cursor);
        d3.select(dragger).call(Drawing.setRect, x, y, w, h);
        return dragger;
      }
      function isDirectionActive(axList, activeVal) {
        for (var i = 0; i < axList.length; i++) {
          if (!axList[i].fixedrange) return activeVal;
        }
        return "";
      }
      function getEndText(ax, end) {
        var initialVal = ax.range[end];
        var diff = Math.abs(initialVal - ax.range[1 - end]);
        var dig;
        if (ax.type === "date") {
          return initialVal;
        } else if (ax.type === "log") {
          dig = Math.ceil(Math.max(0, -Math.log(diff) / Math.LN10)) + 3;
          return numberFormat("." + dig + "g")(Math.pow(10, initialVal));
        } else {
          dig = Math.floor(Math.log(Math.abs(initialVal)) / Math.LN10) - Math.floor(Math.log(diff) / Math.LN10) + 4;
          return numberFormat("." + String(dig) + "g")(initialVal);
        }
      }
      function zoomAxRanges(axList, r0Fraction, r1Fraction, updates, linkedAxes) {
        for (var i = 0; i < axList.length; i++) {
          var axi = axList[i];
          if (axi.fixedrange) continue;
          if (axi.rangebreaks) {
            var isY = axi._id.charAt(0) === "y";
            var r0F = isY ? 1 - r0Fraction : r0Fraction;
            var r1F = isY ? 1 - r1Fraction : r1Fraction;
            updates[axi._name + ".range[0]"] = axi.l2r(axi.p2l(r0F * axi._length));
            updates[axi._name + ".range[1]"] = axi.l2r(axi.p2l(r1F * axi._length));
          } else {
            var axRangeLinear0 = axi._rl[0];
            var axRangeLinearSpan = axi._rl[1] - axRangeLinear0;
            updates[axi._name + ".range[0]"] = axi.l2r(axRangeLinear0 + axRangeLinearSpan * r0Fraction);
            updates[axi._name + ".range[1]"] = axi.l2r(axRangeLinear0 + axRangeLinearSpan * r1Fraction);
          }
        }
        if (linkedAxes && linkedAxes.length) {
          var linkedR0Fraction = (r0Fraction + (1 - r1Fraction)) / 2;
          zoomAxRanges(linkedAxes, linkedR0Fraction, 1 - linkedR0Fraction, updates, []);
        }
      }
      function dragAxList(axList, pix) {
        for (var i = 0; i < axList.length; i++) {
          var axi = axList[i];
          if (!axi.fixedrange) {
            if (axi.rangebreaks) {
              var p0 = 0;
              var p1 = axi._length;
              var d0 = axi.p2l(p0 + pix) - axi.p2l(p0);
              var d1 = axi.p2l(p1 + pix) - axi.p2l(p1);
              var delta = (d0 + d1) / 2;
              axi.range = [
                axi.l2r(axi._rl[0] - delta),
                axi.l2r(axi._rl[1] - delta)
              ];
            } else {
              axi.range = [
                axi.l2r(axi._rl[0] - pix / axi._m),
                axi.l2r(axi._rl[1] - pix / axi._m)
              ];
            }
            if (axi.limitRange) axi.limitRange();
          }
        }
      }
      function dZoom(d) {
        return 1 - (d >= 0 ? Math.min(d, 0.9) : 1 / (1 / Math.max(d, -0.3) + 3.222));
      }
      function getDragCursor(nsew, dragmode, isMainDrag) {
        if (!nsew) return "pointer";
        if (nsew === "nsew") {
          if (isMainDrag) return "";
          if (dragmode === "pan") return "move";
          return "crosshair";
        }
        return nsew.toLowerCase() + "-resize";
      }
      function makeZoombox(zoomlayer, lum, xs, ys, path0) {
        return zoomlayer.append("path").attr("class", "zoombox").style({
          fill: lum > 0.2 ? "rgba(0,0,0,0)" : "rgba(255,255,255,0)",
          "stroke-width": 0
        }).attr("transform", strTranslate(xs, ys)).attr("d", path0 + "Z");
      }
      function makeCorners(zoomlayer, xs, ys) {
        return zoomlayer.append("path").attr("class", "zoombox-corners").style({
          fill: Color.background,
          stroke: Color.defaultLine,
          "stroke-width": 1,
          opacity: 0
        }).attr("transform", strTranslate(xs, ys)).attr("d", "M0,0Z");
      }
      function updateZoombox(zb, corners, box, path0, dimmed, lum) {
        zb.attr(
          "d",
          path0 + "M" + box.l + "," + box.t + "v" + box.h + "h" + box.w + "v-" + box.h + "h-" + box.w + "Z"
        );
        transitionZoombox(zb, corners, dimmed, lum);
      }
      function transitionZoombox(zb, corners, dimmed, lum) {
        if (!dimmed) {
          zb.transition().style("fill", lum > 0.2 ? "rgba(0,0,0,0.4)" : "rgba(255,255,255,0.3)").duration(200);
          corners.transition().style("opacity", 1).duration(200);
        }
      }
      function removeZoombox(gd) {
        d3.select(gd).selectAll(".zoombox,.js-zoombox-backdrop,.js-zoombox-menu,.zoombox-corners").remove();
      }
      function showDoubleClickNotifier(gd) {
        if (SHOWZOOMOUTTIP && gd.data && gd._context.showTips) {
          Lib.notifier(Lib._(gd, "Double-click to zoom back out"), "long");
          SHOWZOOMOUTTIP = false;
        }
      }
      function xCorners(box, y0) {
        return "M" + (box.l - 0.5) + "," + (y0 - MINZOOM - 0.5) + "h-3v" + (2 * MINZOOM + 1) + "h3ZM" + (box.r + 0.5) + "," + (y0 - MINZOOM - 0.5) + "h3v" + (2 * MINZOOM + 1) + "h-3Z";
      }
      function yCorners(box, x0) {
        return "M" + (x0 - MINZOOM - 0.5) + "," + (box.t - 0.5) + "v-3h" + (2 * MINZOOM + 1) + "v3ZM" + (x0 - MINZOOM - 0.5) + "," + (box.b + 0.5) + "v3h" + (2 * MINZOOM + 1) + "v-3Z";
      }
      function xyCorners(box) {
        var clen = Math.floor(Math.min(box.b - box.t, box.r - box.l, MINZOOM) / 2);
        return "M" + (box.l - 3.5) + "," + (box.t - 0.5 + clen) + "h3v" + -clen + "h" + clen + "v-3h-" + (clen + 3) + "ZM" + (box.r + 3.5) + "," + (box.t - 0.5 + clen) + "h-3v" + -clen + "h" + -clen + "v-3h" + (clen + 3) + "ZM" + (box.r + 3.5) + "," + (box.b + 0.5 - clen) + "h-3v" + clen + "h" + -clen + "v3h" + (clen + 3) + "ZM" + (box.l - 3.5) + "," + (box.b + 0.5 - clen) + "h3v" + clen + "h" + clen + "v3h-" + (clen + 3) + "Z";
      }
      function calcLinks(gd, groups, xaHash, yaHash, exclude) {
        var isSubplotConstrained = false;
        var xLinks = {};
        var yLinks = {};
        var xID, yID, xLinkID, yLinkID;
        var xExclude = (exclude || {}).xaHash;
        var yExclude = (exclude || {}).yaHash;
        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          for (xID in xaHash) {
            if (group[xID]) {
              for (xLinkID in group) {
                if (!(exclude && (xExclude[xLinkID] || yExclude[xLinkID])) && !(xLinkID.charAt(0) === "x" ? xaHash : yaHash)[xLinkID]) {
                  xLinks[xLinkID] = xID;
                }
              }
              for (yID in yaHash) {
                if (!(exclude && (xExclude[yID] || yExclude[yID])) && group[yID]) {
                  isSubplotConstrained = true;
                }
              }
            }
          }
          for (yID in yaHash) {
            if (group[yID]) {
              for (yLinkID in group) {
                if (!(exclude && (xExclude[yLinkID] || yExclude[yLinkID])) && !(yLinkID.charAt(0) === "x" ? xaHash : yaHash)[yLinkID]) {
                  yLinks[yLinkID] = yID;
                }
              }
            }
          }
        }
        if (isSubplotConstrained) {
          Lib.extendFlat(xLinks, yLinks);
          yLinks = {};
        }
        var xaHashLinked = {};
        var xaxesLinked = [];
        for (xLinkID in xLinks) {
          var xa = getFromId(gd, xLinkID);
          xaxesLinked.push(xa);
          xaHashLinked[xa._id] = xa;
        }
        var yaHashLinked = {};
        var yaxesLinked = [];
        for (yLinkID in yLinks) {
          var ya = getFromId(gd, yLinkID);
          yaxesLinked.push(ya);
          yaHashLinked[ya._id] = ya;
        }
        return {
          xaHash: xaHashLinked,
          yaHash: yaHashLinked,
          xaxes: xaxesLinked,
          yaxes: yaxesLinked,
          xLinks,
          yLinks,
          isSubplotConstrained
        };
      }
      function attachWheelEventHandler(element, handler) {
        if (!supportsPassive) {
          if (element.onwheel !== void 0) element.onwheel = handler;
          else if (element.onmousewheel !== void 0) element.onmousewheel = handler;
          else if (!element.isAddedWheelEvent) {
            element.isAddedWheelEvent = true;
            element.addEventListener("wheel", handler, { passive: false });
          }
        } else {
          var wheelEventName = element.onwheel !== void 0 ? "wheel" : "mousewheel";
          if (element._onwheel) {
            element.removeEventListener(wheelEventName, element._onwheel);
          }
          element._onwheel = handler;
          element.addEventListener(wheelEventName, handler, { passive: false });
        }
      }
      function hashValues(hash) {
        var out = [];
        for (var k in hash) out.push(hash[k]);
        return out;
      }
      module.exports = {
        makeDragBox,
        makeDragger,
        makeRectDragger,
        makeZoombox,
        makeCorners,
        updateZoombox,
        xyCorners,
        transitionZoombox,
        removeZoombox,
        showDoubleClickNotifier,
        attachWheelEventHandler
      };
    }
  });

  // src/plots/cartesian/graph_interact.js
  var require_graph_interact = __commonJS({
    "src/plots/cartesian/graph_interact.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Fx = require_fx();
      var dragElement = require_dragelement();
      var setCursor = require_setcursor();
      var makeDragBox = require_dragbox().makeDragBox;
      var DRAGGERSIZE = require_constants2().DRAGGERSIZE;
      exports.initInteractions = function initInteractions(gd) {
        var fullLayout = gd._fullLayout;
        if (gd._context.staticPlot) {
          d3.select(gd).selectAll(".drag").remove();
          return;
        }
        if (!fullLayout._has("cartesian") && !fullLayout._has("splom")) return;
        var subplots = Object.keys(fullLayout._plots || {}).sort(function(a, b) {
          if ((fullLayout._plots[a].mainplot && true) === (fullLayout._plots[b].mainplot && true)) {
            var aParts = a.split("y");
            var bParts = b.split("y");
            return aParts[0] === bParts[0] ? Number(aParts[1] || 1) - Number(bParts[1] || 1) : Number(aParts[0] || 1) - Number(bParts[0] || 1);
          }
          return fullLayout._plots[a].mainplot ? 1 : -1;
        });
        subplots.forEach(function(subplot) {
          var plotinfo = fullLayout._plots[subplot];
          var xa = plotinfo.xaxis;
          var ya = plotinfo.yaxis;
          if (!plotinfo.mainplot) {
            var maindrag = makeDragBox(
              gd,
              plotinfo,
              xa._offset,
              ya._offset,
              xa._length,
              ya._length,
              "ns",
              "ew"
            );
            maindrag.onmousemove = function(evt) {
              gd._fullLayout._rehover = function() {
                if (gd._fullLayout._hoversubplot === subplot && gd._fullLayout._plots[subplot]) {
                  Fx.hover(gd, evt, subplot);
                }
              };
              Fx.hover(gd, evt, subplot);
              gd._fullLayout._lasthover = maindrag;
              gd._fullLayout._hoversubplot = subplot;
            };
            maindrag.onmouseout = function(evt) {
              if (gd._dragging) return;
              gd._fullLayout._hoversubplot = null;
              dragElement.unhover(gd, evt);
            };
            if (gd._context.showAxisDragHandles) {
              makeDragBox(
                gd,
                plotinfo,
                xa._offset - DRAGGERSIZE,
                ya._offset - DRAGGERSIZE,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "n",
                "w"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length,
                ya._offset - DRAGGERSIZE,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "n",
                "e"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset - DRAGGERSIZE,
                ya._offset + ya._length,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "s",
                "w"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length,
                ya._offset + ya._length,
                DRAGGERSIZE,
                DRAGGERSIZE,
                "s",
                "e"
              );
            }
          }
          if (gd._context.showAxisDragHandles) {
            if (subplot === xa._mainSubplot) {
              var y0 = xa._mainLinePosition;
              if (xa.side === "top") y0 -= DRAGGERSIZE;
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length * 0.1,
                y0,
                xa._length * 0.8,
                DRAGGERSIZE,
                "",
                "ew"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset,
                y0,
                xa._length * 0.1,
                DRAGGERSIZE,
                "",
                "w"
              );
              makeDragBox(
                gd,
                plotinfo,
                xa._offset + xa._length * 0.9,
                y0,
                xa._length * 0.1,
                DRAGGERSIZE,
                "",
                "e"
              );
            }
            if (subplot === ya._mainSubplot) {
              var x0 = ya._mainLinePosition;
              if (ya.side !== "right") x0 -= DRAGGERSIZE;
              makeDragBox(
                gd,
                plotinfo,
                x0,
                ya._offset + ya._length * 0.1,
                DRAGGERSIZE,
                ya._length * 0.8,
                "ns",
                ""
              );
              makeDragBox(
                gd,
                plotinfo,
                x0,
                ya._offset + ya._length * 0.9,
                DRAGGERSIZE,
                ya._length * 0.1,
                "s",
                ""
              );
              makeDragBox(
                gd,
                plotinfo,
                x0,
                ya._offset,
                DRAGGERSIZE,
                ya._length * 0.1,
                "n",
                ""
              );
            }
          }
        });
        var hoverLayer = fullLayout._hoverlayer.node();
        hoverLayer.onmousemove = function(evt) {
          evt.target = gd._fullLayout._lasthover;
          Fx.hover(gd, evt, fullLayout._hoversubplot);
        };
        hoverLayer.onclick = function(evt) {
          evt.target = gd._fullLayout._lasthover;
          Fx.click(gd, evt);
        };
        hoverLayer.onmousedown = function(evt) {
          gd._fullLayout._lasthover.onmousedown(evt);
        };
        exports.updateFx(gd);
      };
      exports.updateFx = function(gd) {
        var fullLayout = gd._fullLayout;
        var cursor = fullLayout.dragmode === "pan" ? "move" : "crosshair";
        setCursor(fullLayout._draggers, cursor);
      };
    }
  });

  // src/plot_api/container_array_match.js
  var require_container_array_match = __commonJS({
    "src/plot_api/container_array_match.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      module.exports = function containerArrayMatch(astr) {
        var rootContainers = Registry.layoutArrayContainers;
        var regexpContainers = Registry.layoutArrayRegexes;
        var rootPart = astr.split("[")[0];
        var arrayStr;
        var match;
        for (var i = 0; i < regexpContainers.length; i++) {
          match = astr.match(regexpContainers[i]);
          if (match && match.index === 0) {
            arrayStr = match[0];
            break;
          }
        }
        if (!arrayStr) arrayStr = rootContainers[rootContainers.indexOf(rootPart)];
        if (!arrayStr) return false;
        var tail = astr.substr(arrayStr.length);
        if (!tail) return { array: arrayStr, index: "", property: "" };
        match = tail.match(/^\[(0|[1-9][0-9]*)\](\.(.+))?$/);
        if (!match) return false;
        return { array: arrayStr, index: Number(match[1]), property: match[3] || "" };
      };
    }
  });

  // src/plot_api/manage_arrays.js
  var require_manage_arrays = __commonJS({
    "src/plot_api/manage_arrays.js"(exports) {
      "use strict";
      var isPlainObject = require_is_plain_object();
      var noop = require_noop();
      var Loggers = require_loggers();
      var sorterAsc = require_search().sorterAsc;
      var Registry = require_registry();
      exports.containerArrayMatch = require_container_array_match();
      var isAddVal = exports.isAddVal = function isAddVal2(val) {
        return val === "add" || isPlainObject(val);
      };
      var isRemoveVal = exports.isRemoveVal = function isRemoveVal2(val) {
        return val === null || val === "remove";
      };
      exports.applyContainerArrayChanges = function applyContainerArrayChanges(gd, np, edits, flags, _nestedProperty) {
        var componentType = np.astr;
        var supplyComponentDefaults = Registry.getComponentMethod(componentType, "supplyLayoutDefaults");
        var draw = Registry.getComponentMethod(componentType, "draw");
        var drawOne = Registry.getComponentMethod(componentType, "drawOne");
        var replotLater = flags.replot || flags.recalc || supplyComponentDefaults === noop || draw === noop;
        var layout = gd.layout;
        var fullLayout = gd._fullLayout;
        if (edits[""]) {
          if (Object.keys(edits).length > 1) {
            Loggers.warn(
              "Full array edits are incompatible with other edits",
              componentType
            );
          }
          var fullVal = edits[""][""];
          if (isRemoveVal(fullVal)) np.set(null);
          else if (Array.isArray(fullVal)) np.set(fullVal);
          else {
            Loggers.warn("Unrecognized full array edit value", componentType, fullVal);
            return true;
          }
          if (replotLater) return false;
          supplyComponentDefaults(layout, fullLayout);
          draw(gd);
          return true;
        }
        var componentNums = Object.keys(edits).map(Number).sort(sorterAsc);
        var componentArrayIn = np.get();
        var componentArray = componentArrayIn || [];
        var componentArrayFull = _nestedProperty(fullLayout, componentType).get();
        var deletes = [];
        var firstIndexChange = -1;
        var maxIndex = componentArray.length;
        var i;
        var j;
        var componentNum;
        var objEdits;
        var objKeys;
        var objVal;
        var adding, prefix;
        for (i = 0; i < componentNums.length; i++) {
          componentNum = componentNums[i];
          objEdits = edits[componentNum];
          objKeys = Object.keys(objEdits);
          objVal = objEdits[""], adding = isAddVal(objVal);
          if (componentNum < 0 || componentNum > componentArray.length - (adding ? 0 : 1)) {
            Loggers.warn("index out of range", componentType, componentNum);
            continue;
          }
          if (objVal !== void 0) {
            if (objKeys.length > 1) {
              Loggers.warn(
                "Insertion & removal are incompatible with edits to the same index.",
                componentType,
                componentNum
              );
            }
            if (isRemoveVal(objVal)) {
              deletes.push(componentNum);
            } else if (adding) {
              if (objVal === "add") objVal = {};
              componentArray.splice(componentNum, 0, objVal);
              if (componentArrayFull) componentArrayFull.splice(componentNum, 0, {});
            } else {
              Loggers.warn(
                "Unrecognized full object edit value",
                componentType,
                componentNum,
                objVal
              );
            }
            if (firstIndexChange === -1) firstIndexChange = componentNum;
          } else {
            for (j = 0; j < objKeys.length; j++) {
              prefix = componentType + "[" + componentNum + "].";
              _nestedProperty(componentArray[componentNum], objKeys[j], prefix).set(objEdits[objKeys[j]]);
            }
          }
        }
        for (i = deletes.length - 1; i >= 0; i--) {
          componentArray.splice(deletes[i], 1);
          if (componentArrayFull) componentArrayFull.splice(deletes[i], 1);
        }
        if (!componentArray.length) np.set(null);
        else if (!componentArrayIn) np.set(componentArray);
        if (replotLater) return false;
        supplyComponentDefaults(layout, fullLayout);
        if (drawOne !== noop) {
          var indicesToDraw;
          if (firstIndexChange === -1) {
            indicesToDraw = componentNums;
          } else {
            maxIndex = Math.max(componentArray.length, maxIndex);
            indicesToDraw = [];
            for (i = 0; i < componentNums.length; i++) {
              componentNum = componentNums[i];
              if (componentNum >= firstIndexChange) break;
              indicesToDraw.push(componentNum);
            }
            for (i = firstIndexChange; i < maxIndex; i++) {
              indicesToDraw.push(i);
            }
          }
          for (i = 0; i < indicesToDraw.length; i++) {
            drawOne(gd, indicesToDraw[i]);
          }
        } else draw(gd);
        return true;
      };
    }
  });

  // src/plot_api/helpers.js
  var require_helpers9 = __commonJS({
    "src/plot_api/helpers.js"(exports) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var m4FromQuat = require_fromQuat();
      var Registry = require_registry();
      var Lib = require_lib();
      var Plots = require_plots();
      var AxisIds = require_axis_ids();
      var Color = require_color();
      var cleanId = AxisIds.cleanId;
      var getFromTrace = AxisIds.getFromTrace;
      var traceIs = Registry.traceIs;
      exports.clearPromiseQueue = function(gd) {
        if (Array.isArray(gd._promises) && gd._promises.length > 0) {
          Lib.log("Clearing previous rejected promises from queue.");
        }
        gd._promises = [];
      };
      exports.cleanLayout = function(layout) {
        var i, j;
        if (!layout) layout = {};
        if (layout.xaxis1) {
          if (!layout.xaxis) layout.xaxis = layout.xaxis1;
          delete layout.xaxis1;
        }
        if (layout.yaxis1) {
          if (!layout.yaxis) layout.yaxis = layout.yaxis1;
          delete layout.yaxis1;
        }
        if (layout.scene1) {
          if (!layout.scene) layout.scene = layout.scene1;
          delete layout.scene1;
        }
        var axisAttrRegex = (Plots.subplotsRegistry.cartesian || {}).attrRegex;
        var polarAttrRegex = (Plots.subplotsRegistry.polar || {}).attrRegex;
        var ternaryAttrRegex = (Plots.subplotsRegistry.ternary || {}).attrRegex;
        var sceneAttrRegex = (Plots.subplotsRegistry.gl3d || {}).attrRegex;
        var keys = Object.keys(layout);
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (axisAttrRegex && axisAttrRegex.test(key)) {
            var ax = layout[key];
            if (ax.anchor && ax.anchor !== "free") {
              ax.anchor = cleanId(ax.anchor);
            }
            if (ax.overlaying) ax.overlaying = cleanId(ax.overlaying);
            if (!ax.type) {
              if (ax.isdate) ax.type = "date";
              else if (ax.islog) ax.type = "log";
              else if (ax.isdate === false && ax.islog === false) ax.type = "linear";
            }
            if (ax.autorange === "withzero" || ax.autorange === "tozero") {
              ax.autorange = true;
              ax.rangemode = "tozero";
            }
            if (ax.insiderange) delete ax.range;
            delete ax.islog;
            delete ax.isdate;
            delete ax.categories;
            if (emptyContainer(ax, "domain")) delete ax.domain;
          }
        }
        var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;
        for (i = 0; i < annotationsLen; i++) {
          var ann = layout.annotations[i];
          if (!Lib.isPlainObject(ann)) continue;
          cleanAxRef(ann, "xref");
          cleanAxRef(ann, "yref");
        }
        var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;
        for (i = 0; i < shapesLen; i++) {
          var shape = layout.shapes[i];
          if (!Lib.isPlainObject(shape)) continue;
          cleanAxRef(shape, "xref");
          cleanAxRef(shape, "yref");
        }
        var imagesLen = Array.isArray(layout.images) ? layout.images.length : 0;
        for (i = 0; i < imagesLen; i++) {
          var image = layout.images[i];
          if (!Lib.isPlainObject(image)) continue;
          cleanAxRef(image, "xref");
          cleanAxRef(image, "yref");
        }
        var legend = layout.legend;
        if (legend) {
          if (legend.x > 3) {
            legend.x = 1.02;
            legend.xanchor = "left";
          } else if (legend.x < -2) {
            legend.x = -0.02;
            legend.xanchor = "right";
          }
          if (legend.y > 3) {
            legend.y = 1.02;
            legend.yanchor = "bottom";
          } else if (legend.y < -2) {
            legend.y = -0.02;
            legend.yanchor = "top";
          }
        }
        if (layout.dragmode === "rotate") layout.dragmode = "orbit";
        Color.clean(layout);
        if (layout.template && layout.template.layout) {
          exports.cleanLayout(layout.template.layout);
        }
        return layout;
      };
      function cleanAxRef(container, attr) {
        var valIn = container[attr];
        var axLetter = attr.charAt(0);
        if (valIn && valIn !== "paper") {
          container[attr] = cleanId(valIn, axLetter, true);
        }
      }
      exports.cleanData = function(data) {
        for (var tracei = 0; tracei < data.length; tracei++) {
          var trace = data[tracei];
          var i;
          if (trace.type === "histogramy" && "xbins" in trace && !("ybins" in trace)) {
            trace.ybins = trace.xbins;
            delete trace.xbins;
          }
          if (trace.type === "histogramy") exports.swapXYData(trace);
          if (trace.type === "histogramx" || trace.type === "histogramy") {
            trace.type = "histogram";
          }
          if ("scl" in trace && !("colorscale" in trace)) {
            trace.colorscale = trace.scl;
            delete trace.scl;
          }
          if ("reversescl" in trace && !("reversescale" in trace)) {
            trace.reversescale = trace.reversescl;
            delete trace.reversescl;
          }
          if (trace.xaxis) trace.xaxis = cleanId(trace.xaxis, "x");
          if (trace.yaxis) trace.yaxis = cleanId(trace.yaxis, "y");
          if (traceIs(trace, "gl3d") && trace.scene) {
            trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);
          }
          if (!traceIs(trace, "pie-like") && !traceIs(trace, "bar-like")) {
            if (Array.isArray(trace.textposition)) {
              for (i = 0; i < trace.textposition.length; i++) {
                trace.textposition[i] = cleanTextPosition(trace.textposition[i]);
              }
            } else if (trace.textposition) {
              trace.textposition = cleanTextPosition(trace.textposition);
            }
          }
          var _module = Registry.getModule(trace);
          if (_module && _module.colorbar) {
            var containerName = _module.colorbar.container;
            var container = containerName ? trace[containerName] : trace;
            if (container && container.colorscale) {
              if (container.colorscale === "YIGnBu") container.colorscale = "YlGnBu";
              if (container.colorscale === "YIOrRd") container.colorscale = "YlOrRd";
            }
          }
          if (trace.type === "surface" && Lib.isPlainObject(trace.contours)) {
            var dims = ["x", "y", "z"];
            for (i = 0; i < dims.length; i++) {
              var opts = trace.contours[dims[i]];
              if (!Lib.isPlainObject(opts)) continue;
              if (opts.highlightColor) {
                opts.highlightcolor = opts.highlightColor;
                delete opts.highlightColor;
              }
              if (opts.highlightWidth) {
                opts.highlightwidth = opts.highlightWidth;
                delete opts.highlightWidth;
              }
            }
          }
          if (trace.type === "candlestick" || trace.type === "ohlc") {
            var increasingShowlegend = (trace.increasing || {}).showlegend !== false;
            var decreasingShowlegend = (trace.decreasing || {}).showlegend !== false;
            var increasingName = cleanFinanceDir(trace.increasing);
            var decreasingName = cleanFinanceDir(trace.decreasing);
            if (increasingName !== false && decreasingName !== false) {
              var newName = commonPrefix(
                increasingName,
                decreasingName,
                increasingShowlegend,
                decreasingShowlegend
              );
              if (newName) trace.name = newName;
            } else if ((increasingName || decreasingName) && !trace.name) {
              trace.name = increasingName || decreasingName;
            }
          }
          if (emptyContainer(trace, "line")) delete trace.line;
          if ("marker" in trace) {
            if (emptyContainer(trace.marker, "line")) delete trace.marker.line;
            if (emptyContainer(trace, "marker")) delete trace.marker;
          }
          Color.clean(trace);
          if (trace.autobinx) {
            delete trace.autobinx;
            delete trace.xbins;
          }
          if (trace.autobiny) {
            delete trace.autobiny;
            delete trace.ybins;
          }
        }
      };
      function cleanFinanceDir(dirContainer) {
        if (!Lib.isPlainObject(dirContainer)) return false;
        var dirName = dirContainer.name;
        delete dirContainer.name;
        delete dirContainer.showlegend;
        return (typeof dirName === "string" || typeof dirName === "number") && String(dirName);
      }
      function commonPrefix(name1, name2, show1, show2) {
        if (show1 && !show2) return name1;
        if (show2 && !show1) return name2;
        if (!name1.trim()) return name2;
        if (!name2.trim()) return name1;
        var minLen = Math.min(name1.length, name2.length);
        var i;
        for (i = 0; i < minLen; i++) {
          if (name1.charAt(i) !== name2.charAt(i)) break;
        }
        var out = name1.substr(0, i);
        return out.trim();
      }
      function cleanTextPosition(textposition) {
        var posY = "middle";
        var posX = "center";
        if (typeof textposition === "string") {
          if (textposition.indexOf("top") !== -1) posY = "top";
          else if (textposition.indexOf("bottom") !== -1) posY = "bottom";
          if (textposition.indexOf("left") !== -1) posX = "left";
          else if (textposition.indexOf("right") !== -1) posX = "right";
        }
        return posY + " " + posX;
      }
      function emptyContainer(outer, innerStr) {
        return innerStr in outer && typeof outer[innerStr] === "object" && Object.keys(outer[innerStr]).length === 0;
      }
      exports.swapXYData = function(trace) {
        var i;
        Lib.swapAttrs(trace, ["?", "?0", "d?", "?bins", "nbins?", "autobin?", "?src", "error_?"]);
        if (Array.isArray(trace.z) && Array.isArray(trace.z[0])) {
          if (trace.transpose) delete trace.transpose;
          else trace.transpose = true;
        }
        if (trace.error_x && trace.error_y) {
          var errorY = trace.error_y;
          var copyYstyle = "copy_ystyle" in errorY ? errorY.copy_ystyle : !(errorY.color || errorY.thickness || errorY.width);
          Lib.swapAttrs(trace, ["error_?.copy_ystyle"]);
          if (copyYstyle) {
            Lib.swapAttrs(trace, ["error_?.color", "error_?.thickness", "error_?.width"]);
          }
        }
        if (typeof trace.hoverinfo === "string") {
          var hoverInfoParts = trace.hoverinfo.split("+");
          for (i = 0; i < hoverInfoParts.length; i++) {
            if (hoverInfoParts[i] === "x") hoverInfoParts[i] = "y";
            else if (hoverInfoParts[i] === "y") hoverInfoParts[i] = "x";
          }
          trace.hoverinfo = hoverInfoParts.join("+");
        }
      };
      exports.coerceTraceIndices = function(gd, traceIndices) {
        if (isNumeric(traceIndices)) {
          return [traceIndices];
        } else if (!Array.isArray(traceIndices) || !traceIndices.length) {
          return gd.data.map(function(_, i2) {
            return i2;
          });
        } else if (Array.isArray(traceIndices)) {
          var traceIndicesOut = [];
          for (var i = 0; i < traceIndices.length; i++) {
            if (Lib.isIndex(traceIndices[i], gd.data.length)) {
              traceIndicesOut.push(traceIndices[i]);
            } else {
              Lib.warn("trace index (", traceIndices[i], ") is not a number or is out of bounds");
            }
          }
          return traceIndicesOut;
        }
        return traceIndices;
      };
      exports.manageArrayContainers = function(np, newVal, undoit) {
        var obj = np.obj;
        var parts = np.parts;
        var pLength = parts.length;
        var pLast = parts[pLength - 1];
        var pLastIsNumber = isNumeric(pLast);
        if (pLastIsNumber && newVal === null) {
          var contPath = parts.slice(0, pLength - 1).join(".");
          var cont = Lib.nestedProperty(obj, contPath).get();
          cont.splice(pLast, 1);
        } else if (pLastIsNumber && np.get() === void 0) {
          if (np.get() === void 0) undoit[np.astr] = null;
          np.set(newVal);
        } else {
          np.set(newVal);
        }
      };
      var ATTR_TAIL_RE = /(\.[^\[\]\.]+|\[[^\[\]\.]+\])$/;
      function getParent(attr) {
        var tail = attr.search(ATTR_TAIL_RE);
        if (tail > 0) return attr.substr(0, tail);
      }
      exports.hasParent = function(aobj, attr) {
        var attrParent = getParent(attr);
        while (attrParent) {
          if (attrParent in aobj) return true;
          attrParent = getParent(attrParent);
        }
        return false;
      };
      var axLetters = ["x", "y", "z"];
      exports.clearAxisTypes = function(gd, traces, layoutUpdate) {
        for (var i = 0; i < traces.length; i++) {
          var trace = gd._fullData[i];
          for (var j = 0; j < 3; j++) {
            var ax = getFromTrace(gd, trace, axLetters[j]);
            if (ax && ax.type !== "log") {
              var axAttr = ax._name;
              var sceneName = ax._id.substr(1);
              if (sceneName.substr(0, 5) === "scene") {
                if (layoutUpdate[sceneName] !== void 0) continue;
                axAttr = sceneName + "." + axAttr;
              }
              var typeAttr = axAttr + ".type";
              if (layoutUpdate[axAttr] === void 0 && layoutUpdate[typeAttr] === void 0) {
                Lib.nestedProperty(gd.layout, typeAttr).set(null);
              }
            }
          }
        }
      };
    }
  });

  // src/plot_api/plot_api.js
  var require_plot_api = __commonJS({
    "src/plot_api/plot_api.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var hasHover = require_has_hover();
      var Lib = require_lib();
      var nestedProperty = Lib.nestedProperty;
      var Events = require_events2();
      var Queue = require_queue();
      var Registry = require_registry();
      var PlotSchema = require_plot_schema();
      var Plots = require_plots();
      var Axes = require_axes();
      var handleRangeDefaults = require_range_defaults();
      var cartesianLayoutAttributes = require_layout_attributes4();
      var Drawing = require_drawing();
      var Color = require_color();
      var initInteractions = require_graph_interact().initInteractions;
      var xmlnsNamespaces = require_xmlns_namespaces();
      var clearOutline = require_selections().clearOutline;
      var dfltConfig = require_plot_config().dfltConfig;
      var manageArrays = require_manage_arrays();
      var helpers = require_helpers9();
      var subroutines = require_subroutines();
      var editTypes = require_edit_types();
      var AX_NAME_PATTERN = require_constants2().AX_NAME_PATTERN;
      var numericNameWarningCount = 0;
      var numericNameWarningCountLimit = 5;
      function _doPlot(gd, data, layout, config) {
        var frames;
        gd = Lib.getGraphDiv(gd);
        Events.init(gd);
        if (Lib.isPlainObject(data)) {
          var obj = data;
          data = obj.data;
          layout = obj.layout;
          config = obj.config;
          frames = obj.frames;
        }
        var okToPlot = Events.triggerHandler(gd, "plotly_beforeplot", [data, layout, config]);
        if (okToPlot === false) return Promise.reject();
        if (!data && !layout && !Lib.isPlotDiv(gd)) {
          Lib.warn("Calling _doPlot as if redrawing but this container doesn't yet have a plot.", gd);
        }
        function addFrames2() {
          if (frames) {
            return exports.addFrames(gd, frames);
          }
        }
        setPlotContext(gd, config);
        if (!layout) layout = {};
        d3.select(gd).classed("js-plotly-plot", true);
        Drawing.makeTester();
        if (!Array.isArray(gd._promises)) gd._promises = [];
        var graphWasEmpty = (gd.data || []).length === 0 && Array.isArray(data);
        if (Array.isArray(data)) {
          helpers.cleanData(data);
          if (graphWasEmpty) gd.data = data;
          else gd.data.push.apply(gd.data, data);
          gd.empty = false;
        }
        if (!gd.layout || graphWasEmpty) {
          gd.layout = helpers.cleanLayout(layout);
        }
        Plots.supplyDefaults(gd);
        var fullLayout = gd._fullLayout;
        var hasCartesian = fullLayout._has("cartesian");
        fullLayout._replotting = true;
        if (graphWasEmpty || fullLayout._shouldCreateBgLayer) {
          makePlotFramework(gd);
          if (fullLayout._shouldCreateBgLayer) {
            delete fullLayout._shouldCreateBgLayer;
          }
        }
        Drawing.initGradients(gd);
        Drawing.initPatterns(gd);
        if (graphWasEmpty) Axes.saveShowSpikeInitial(gd);
        var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;
        if (recalc) Plots.doCalcdata(gd);
        for (var i = 0; i < gd.calcdata.length; i++) {
          gd.calcdata[i][0].trace = gd._fullData[i];
        }
        if (gd._context.responsive) {
          if (!gd._responsiveChartHandler) {
            gd._responsiveChartHandler = function() {
              if (!Lib.isHidden(gd)) Plots.resize(gd);
            };
            window.addEventListener("resize", gd._responsiveChartHandler);
          }
        } else {
          Lib.clearResponsive(gd);
        }
        var oldMargins = Lib.extendFlat({}, fullLayout._size);
        var drawFrameworkCalls = 0;
        function drawFramework() {
          var basePlotModules = fullLayout._basePlotModules;
          for (var i2 = 0; i2 < basePlotModules.length; i2++) {
            if (basePlotModules[i2].drawFramework) {
              basePlotModules[i2].drawFramework(gd);
            }
          }
          if (!fullLayout._glcanvas && fullLayout._has("gl")) {
            fullLayout._glcanvas = fullLayout._glcontainer.selectAll(".gl-canvas").data([{
              key: "contextLayer",
              context: true,
              pick: false
            }, {
              key: "focusLayer",
              context: false,
              pick: false
            }, {
              key: "pickLayer",
              context: false,
              pick: true
            }], function(d) {
              return d.key;
            });
            fullLayout._glcanvas.enter().append("canvas").attr("class", function(d) {
              return "gl-canvas gl-canvas-" + d.key.replace("Layer", "");
            }).style({
              position: "absolute",
              top: 0,
              left: 0,
              overflow: "visible",
              "pointer-events": "none"
            });
          }
          var plotGlPixelRatio = gd._context.plotGlPixelRatio;
          if (fullLayout._glcanvas) {
            fullLayout._glcanvas.attr("width", fullLayout.width * plotGlPixelRatio).attr("height", fullLayout.height * plotGlPixelRatio).style("width", fullLayout.width + "px").style("height", fullLayout.height + "px");
            var regl = fullLayout._glcanvas.data()[0].regl;
            if (regl) {
              if (Math.floor(fullLayout.width * plotGlPixelRatio) !== regl._gl.drawingBufferWidth || Math.floor(fullLayout.height * plotGlPixelRatio) !== regl._gl.drawingBufferHeight) {
                var msg = "WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.";
                if (drawFrameworkCalls) {
                  Lib.error(msg);
                } else {
                  Lib.log(msg + " Clearing graph and plotting again.");
                  Plots.cleanPlot([], {}, gd._fullData, fullLayout);
                  Plots.supplyDefaults(gd);
                  fullLayout = gd._fullLayout;
                  Plots.doCalcdata(gd);
                  drawFrameworkCalls++;
                  return drawFramework();
                }
              }
            }
          }
          if (fullLayout.modebar.orientation === "h") {
            fullLayout._modebardiv.style("height", null).style("width", "100%");
          } else {
            fullLayout._modebardiv.style("width", null).style("height", fullLayout.height + "px");
          }
          return Plots.previousPromises(gd);
        }
        function marginPushers() {
          Plots.clearAutoMarginIds(gd);
          subroutines.drawMarginPushers(gd);
          Axes.allowAutoMargin(gd);
          if (gd._fullLayout.title.text && gd._fullLayout.title.automargin) Plots.allowAutoMargin(gd, "title.automargin");
          if (fullLayout._has("pie")) {
            var fullData = gd._fullData;
            for (var i2 = 0; i2 < fullData.length; i2++) {
              var trace = fullData[i2];
              if (trace.type === "pie" && trace.automargin) {
                Plots.allowAutoMargin(gd, "pie." + trace.uid + ".automargin");
              }
            }
          }
          Plots.doAutoMargin(gd);
          return Plots.previousPromises(gd);
        }
        function marginPushersAgain() {
          if (!Plots.didMarginChange(oldMargins, fullLayout._size)) return;
          return Lib.syncOrAsync([
            marginPushers,
            subroutines.layoutStyles
          ], gd);
        }
        function positionAndAutorange() {
          if (!recalc) {
            doAutoRangeAndConstraints();
            return;
          }
          return Lib.syncOrAsync([
            Registry.getComponentMethod("shapes", "calcAutorange"),
            Registry.getComponentMethod("annotations", "calcAutorange"),
            doAutoRangeAndConstraints
          ], gd);
        }
        function doAutoRangeAndConstraints() {
          if (gd._transitioning) return;
          subroutines.doAutoRangeAndConstraints(gd);
          if (graphWasEmpty) Axes.saveRangeInitial(gd);
          Registry.getComponentMethod("rangeslider", "calcAutorange")(gd);
        }
        function drawAxes() {
          return Axes.draw(gd, graphWasEmpty ? "" : "redraw");
        }
        var seq = [
          Plots.previousPromises,
          addFrames2,
          drawFramework,
          marginPushers,
          marginPushersAgain
        ];
        if (hasCartesian) seq.push(positionAndAutorange);
        seq.push(subroutines.layoutStyles);
        if (hasCartesian) {
          seq.push(
            drawAxes,
            function insideTickLabelsAutorange(gd2) {
              var insideTickLabelsUpdaterange = gd2._fullLayout._insideTickLabelsUpdaterange;
              if (insideTickLabelsUpdaterange) {
                gd2._fullLayout._insideTickLabelsUpdaterange = void 0;
                return relayout(gd2, insideTickLabelsUpdaterange).then(function() {
                  Axes.saveRangeInitial(gd2, true);
                });
              }
            }
          );
        }
        seq.push(
          subroutines.drawData,
          subroutines.finalDraw,
          initInteractions,
          Plots.addLinks,
          Plots.rehover,
          Plots.redrag,
          Plots.reselect,
          // TODO: doAutoMargin is only needed here for axis automargin, which
          // happens outside of marginPushers where all the other automargins are
          // calculated. Would be much better to separate margin calculations from
          // component drawing - see https://github.com/plotly/plotly.js/issues/2704
          Plots.doAutoMargin,
          Plots.previousPromises
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve();
        return plotDone.then(function() {
          emitAfterPlot(gd);
          return gd;
        });
      }
      function emitAfterPlot(gd) {
        var fullLayout = gd._fullLayout;
        if (fullLayout._redrawFromAutoMarginCount) {
          fullLayout._redrawFromAutoMarginCount--;
        } else {
          gd.emit("plotly_afterplot");
        }
      }
      function setPlotConfig(obj) {
        return Lib.extendFlat(dfltConfig, obj);
      }
      function setBackground(gd, bgColor) {
        try {
          gd._fullLayout._paper.style("background", bgColor);
        } catch (e) {
          Lib.error(e);
        }
      }
      function opaqueSetBackground(gd, bgColor) {
        var blend = Color.combine(bgColor, "white");
        setBackground(gd, blend);
      }
      function setPlotContext(gd, config) {
        if (!gd._context) {
          gd._context = Lib.extendDeep({}, dfltConfig);
          var base = d3.select("base");
          gd._context._baseUrl = base.size() && base.attr("href") ? window.location.href.split("#")[0] : "";
        }
        var context = gd._context;
        var i, keys, key;
        if (config) {
          keys = Object.keys(config);
          for (i = 0; i < keys.length; i++) {
            key = keys[i];
            if (key === "editable" || key === "edits") continue;
            if (key in context) {
              if (key === "setBackground" && config[key] === "opaque") {
                context[key] = opaqueSetBackground;
              } else {
                context[key] = config[key];
              }
            }
          }
          var editable = config.editable;
          if (editable !== void 0) {
            context.editable = editable;
            keys = Object.keys(context.edits);
            for (i = 0; i < keys.length; i++) {
              context.edits[keys[i]] = editable;
            }
          }
          if (config.edits) {
            keys = Object.keys(config.edits);
            for (i = 0; i < keys.length; i++) {
              key = keys[i];
              if (key in context.edits) {
                context.edits[key] = config.edits[key];
              }
            }
          }
          context._exportedPlot = config._exportedPlot;
        }
        if (context.staticPlot) {
          context.editable = false;
          context.edits = {};
          context.autosizable = false;
          context.scrollZoom = false;
          context.doubleClick = false;
          context.showTips = false;
          context.showLink = false;
          context.displayModeBar = false;
        }
        if (context.displayModeBar === "hover" && !hasHover) {
          context.displayModeBar = true;
        }
        if (context.setBackground === "transparent" || typeof context.setBackground !== "function") {
          context.setBackground = setBackground;
        }
        context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;
        context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;
        var szIn = context.scrollZoom;
        var szOut = context._scrollZoom = {};
        if (szIn === true) {
          szOut.cartesian = 1;
          szOut.gl3d = 1;
          szOut.geo = 1;
          szOut.mapbox = 1;
          szOut.map = 1;
        } else if (typeof szIn === "string") {
          var parts = szIn.split("+");
          for (i = 0; i < parts.length; i++) {
            szOut[parts[i]] = 1;
          }
        } else if (szIn !== false) {
          szOut.gl3d = 1;
          szOut.geo = 1;
          szOut.mapbox = 1;
          szOut.map = 1;
        }
      }
      function redraw(gd) {
        gd = Lib.getGraphDiv(gd);
        if (!Lib.isPlotDiv(gd)) {
          throw new Error("This element is not a Plotly plot: " + gd);
        }
        helpers.cleanData(gd.data);
        helpers.cleanLayout(gd.layout);
        gd.calcdata = void 0;
        return exports._doPlot(gd).then(function() {
          gd.emit("plotly_redraw");
          return gd;
        });
      }
      function newPlot(gd, data, layout, config) {
        gd = Lib.getGraphDiv(gd);
        Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});
        Plots.purge(gd);
        return exports._doPlot(gd, data, layout, config);
      }
      function positivifyIndices(indices, maxIndex) {
        var parentLength = maxIndex + 1;
        var positiveIndices = [];
        var i;
        var index;
        for (i = 0; i < indices.length; i++) {
          index = indices[i];
          if (index < 0) {
            positiveIndices.push(parentLength + index);
          } else {
            positiveIndices.push(index);
          }
        }
        return positiveIndices;
      }
      function assertIndexArray(gd, indices, arrayName) {
        var i, index;
        for (i = 0; i < indices.length; i++) {
          index = indices[i];
          if (index !== parseInt(index, 10)) {
            throw new Error("all values in " + arrayName + " must be integers");
          }
          if (index >= gd.data.length || index < -gd.data.length) {
            throw new Error(arrayName + " must be valid indices for gd.data.");
          }
          if (indices.indexOf(index, i + 1) > -1 || index >= 0 && indices.indexOf(-gd.data.length + index) > -1 || index < 0 && indices.indexOf(gd.data.length + index) > -1) {
            throw new Error("each index in " + arrayName + " must be unique.");
          }
        }
      }
      function checkMoveTracesArgs(gd, currentIndices, newIndices) {
        if (!Array.isArray(gd.data)) {
          throw new Error("gd.data must be an array.");
        }
        if (typeof currentIndices === "undefined") {
          throw new Error("currentIndices is a required argument.");
        } else if (!Array.isArray(currentIndices)) {
          currentIndices = [currentIndices];
        }
        assertIndexArray(gd, currentIndices, "currentIndices");
        if (typeof newIndices !== "undefined" && !Array.isArray(newIndices)) {
          newIndices = [newIndices];
        }
        if (typeof newIndices !== "undefined") {
          assertIndexArray(gd, newIndices, "newIndices");
        }
        if (typeof newIndices !== "undefined" && currentIndices.length !== newIndices.length) {
          throw new Error("current and new indices must be of equal length.");
        }
      }
      function checkAddTracesArgs(gd, traces, newIndices) {
        var i, value;
        if (!Array.isArray(gd.data)) {
          throw new Error("gd.data must be an array.");
        }
        if (typeof traces === "undefined") {
          throw new Error("traces must be defined.");
        }
        if (!Array.isArray(traces)) {
          traces = [traces];
        }
        for (i = 0; i < traces.length; i++) {
          value = traces[i];
          if (typeof value !== "object" || (Array.isArray(value) || value === null)) {
            throw new Error("all values in traces array must be non-array objects");
          }
        }
        if (typeof newIndices !== "undefined" && !Array.isArray(newIndices)) {
          newIndices = [newIndices];
        }
        if (typeof newIndices !== "undefined" && newIndices.length !== traces.length) {
          throw new Error(
            "if indices is specified, traces.length must equal indices.length"
          );
        }
      }
      function assertExtendTracesArgs(gd, update2, indices, maxPoints) {
        var maxPointsIsObject = Lib.isPlainObject(maxPoints);
        if (!Array.isArray(gd.data)) {
          throw new Error("gd.data must be an array");
        }
        if (!Lib.isPlainObject(update2)) {
          throw new Error("update must be a key:value object");
        }
        if (typeof indices === "undefined") {
          throw new Error("indices must be an integer or array of integers");
        }
        assertIndexArray(gd, indices, "indices");
        for (var key in update2) {
          if (!Array.isArray(update2[key]) || update2[key].length !== indices.length) {
            throw new Error("attribute " + key + " must be an array of length equal to indices array length");
          }
          if (maxPointsIsObject && (!(key in maxPoints) || !Array.isArray(maxPoints[key]) || maxPoints[key].length !== update2[key].length)) {
            throw new Error("when maxPoints is set as a key:value object it must contain a 1:1 corrispondence with the keys and number of traces in the update object");
          }
        }
      }
      function getExtendProperties(gd, update2, indices, maxPoints) {
        var maxPointsIsObject = Lib.isPlainObject(maxPoints);
        var updateProps = [];
        var trace, target, prop, insert, maxp;
        if (!Array.isArray(indices)) indices = [indices];
        indices = positivifyIndices(indices, gd.data.length - 1);
        for (var key in update2) {
          for (var j = 0; j < indices.length; j++) {
            trace = gd.data[indices[j]];
            prop = nestedProperty(trace, key);
            target = prop.get();
            insert = update2[key][j];
            if (!Lib.isArrayOrTypedArray(insert)) {
              throw new Error("attribute: " + key + " index: " + j + " must be an array");
            }
            if (!Lib.isArrayOrTypedArray(target)) {
              throw new Error("cannot extend missing or non-array attribute: " + key);
            }
            if (target.constructor !== insert.constructor) {
              throw new Error("cannot extend array with an array of a different type: " + key);
            }
            maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;
            if (!isNumeric(maxp)) maxp = -1;
            updateProps.push({
              prop,
              target,
              insert,
              maxp: Math.floor(maxp)
            });
          }
        }
        return updateProps;
      }
      function spliceTraces(gd, update2, indices, maxPoints, updateArray) {
        assertExtendTracesArgs(gd, update2, indices, maxPoints);
        var updateProps = getExtendProperties(gd, update2, indices, maxPoints);
        var undoUpdate = {};
        var undoPoints = {};
        for (var i = 0; i < updateProps.length; i++) {
          var prop = updateProps[i].prop;
          var maxp = updateProps[i].maxp;
          var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);
          prop.set(out[0]);
          if (!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];
          undoUpdate[prop.astr].push(out[1]);
          if (!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];
          undoPoints[prop.astr].push(updateProps[i].target.length);
        }
        return { update: undoUpdate, maxPoints: undoPoints };
      }
      function concatTypedArray(arr0, arr1) {
        var arr2 = new arr0.constructor(arr0.length + arr1.length);
        arr2.set(arr0);
        arr2.set(arr1, arr0.length);
        return arr2;
      }
      function extendTraces(gd, update2, indices, maxPoints) {
        gd = Lib.getGraphDiv(gd);
        function updateArray(target, insert, maxp) {
          var newArray, remainder;
          if (Lib.isTypedArray(target)) {
            if (maxp < 0) {
              var none = new target.constructor(0);
              var both = concatTypedArray(target, insert);
              if (maxp < 0) {
                newArray = both;
                remainder = none;
              } else {
                newArray = none;
                remainder = both;
              }
            } else {
              newArray = new target.constructor(maxp);
              remainder = new target.constructor(target.length + insert.length - maxp);
              if (maxp === insert.length) {
                newArray.set(insert);
                remainder.set(target);
              } else if (maxp < insert.length) {
                var numberOfItemsFromInsert = insert.length - maxp;
                newArray.set(insert.subarray(numberOfItemsFromInsert));
                remainder.set(target);
                remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);
              } else {
                var numberOfItemsFromTarget = maxp - insert.length;
                var targetBegin = target.length - numberOfItemsFromTarget;
                newArray.set(target.subarray(targetBegin));
                newArray.set(insert, numberOfItemsFromTarget);
                remainder.set(target.subarray(0, targetBegin));
              }
            }
          } else {
            newArray = target.concat(insert);
            remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(0, newArray.length - maxp) : [];
          }
          return [newArray, remainder];
        }
        var undo = spliceTraces(gd, update2, indices, maxPoints, updateArray);
        var promise = exports.redraw(gd);
        var undoArgs = [gd, undo.update, indices, undo.maxPoints];
        Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);
        return promise;
      }
      function prependTraces(gd, update2, indices, maxPoints) {
        gd = Lib.getGraphDiv(gd);
        function updateArray(target, insert, maxp) {
          var newArray, remainder;
          if (Lib.isTypedArray(target)) {
            if (maxp <= 0) {
              var none = new target.constructor(0);
              var both = concatTypedArray(insert, target);
              if (maxp < 0) {
                newArray = both;
                remainder = none;
              } else {
                newArray = none;
                remainder = both;
              }
            } else {
              newArray = new target.constructor(maxp);
              remainder = new target.constructor(target.length + insert.length - maxp);
              if (maxp === insert.length) {
                newArray.set(insert);
                remainder.set(target);
              } else if (maxp < insert.length) {
                var numberOfItemsFromInsert = insert.length - maxp;
                newArray.set(insert.subarray(0, numberOfItemsFromInsert));
                remainder.set(insert.subarray(numberOfItemsFromInsert));
                remainder.set(target, numberOfItemsFromInsert);
              } else {
                var numberOfItemsFromTarget = maxp - insert.length;
                newArray.set(insert);
                newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);
                remainder.set(target.subarray(numberOfItemsFromTarget));
              }
            }
          } else {
            newArray = insert.concat(target);
            remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(maxp, newArray.length) : [];
          }
          return [newArray, remainder];
        }
        var undo = spliceTraces(gd, update2, indices, maxPoints, updateArray);
        var promise = exports.redraw(gd);
        var undoArgs = [gd, undo.update, indices, undo.maxPoints];
        Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);
        return promise;
      }
      function addTraces(gd, traces, newIndices) {
        gd = Lib.getGraphDiv(gd);
        var currentIndices = [];
        var undoFunc = exports.deleteTraces;
        var redoFunc = addTraces;
        var undoArgs = [gd, currentIndices];
        var redoArgs = [gd, traces];
        var i;
        var promise;
        checkAddTracesArgs(gd, traces, newIndices);
        if (!Array.isArray(traces)) {
          traces = [traces];
        }
        traces = traces.map(function(trace) {
          return Lib.extendFlat({}, trace);
        });
        helpers.cleanData(traces);
        for (i = 0; i < traces.length; i++) {
          gd.data.push(traces[i]);
        }
        for (i = 0; i < traces.length; i++) {
          currentIndices.push(-traces.length + i);
        }
        if (typeof newIndices === "undefined") {
          promise = exports.redraw(gd);
          Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
          return promise;
        }
        if (!Array.isArray(newIndices)) {
          newIndices = [newIndices];
        }
        try {
          checkMoveTracesArgs(gd, currentIndices, newIndices);
        } catch (error) {
          gd.data.splice(gd.data.length - traces.length, traces.length);
          throw error;
        }
        Queue.startSequence(gd);
        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        promise = exports.moveTraces(gd, currentIndices, newIndices);
        Queue.stopSequence(gd);
        return promise;
      }
      function deleteTraces(gd, indices) {
        gd = Lib.getGraphDiv(gd);
        var traces = [];
        var undoFunc = exports.addTraces;
        var redoFunc = deleteTraces;
        var undoArgs = [gd, traces, indices];
        var redoArgs = [gd, indices];
        var i;
        var deletedTrace;
        if (typeof indices === "undefined") {
          throw new Error("indices must be an integer or array of integers.");
        } else if (!Array.isArray(indices)) {
          indices = [indices];
        }
        assertIndexArray(gd, indices, "indices");
        indices = positivifyIndices(indices, gd.data.length - 1);
        indices.sort(Lib.sorterDes);
        for (i = 0; i < indices.length; i += 1) {
          deletedTrace = gd.data.splice(indices[i], 1)[0];
          traces.push(deletedTrace);
        }
        var promise = exports.redraw(gd);
        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return promise;
      }
      function moveTraces(gd, currentIndices, newIndices) {
        gd = Lib.getGraphDiv(gd);
        var newData = [];
        var movingTraceMap = [];
        var undoFunc = moveTraces;
        var redoFunc = moveTraces;
        var undoArgs = [gd, newIndices, currentIndices];
        var redoArgs = [gd, currentIndices, newIndices];
        var i;
        checkMoveTracesArgs(gd, currentIndices, newIndices);
        currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];
        if (typeof newIndices === "undefined") {
          newIndices = [];
          for (i = 0; i < currentIndices.length; i++) {
            newIndices.push(-currentIndices.length + i);
          }
        }
        newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];
        currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);
        newIndices = positivifyIndices(newIndices, gd.data.length - 1);
        for (i = 0; i < gd.data.length; i++) {
          if (currentIndices.indexOf(i) === -1) {
            newData.push(gd.data[i]);
          }
        }
        for (i = 0; i < currentIndices.length; i++) {
          movingTraceMap.push({ newIndex: newIndices[i], trace: gd.data[currentIndices[i]] });
        }
        movingTraceMap.sort(function(a, b) {
          return a.newIndex - b.newIndex;
        });
        for (i = 0; i < movingTraceMap.length; i += 1) {
          newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);
        }
        gd.data = newData;
        var promise = exports.redraw(gd);
        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return promise;
      }
      function restyle(gd, astr, val, _traces) {
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        var aobj = {};
        if (typeof astr === "string") aobj[astr] = val;
        else if (Lib.isPlainObject(astr)) {
          aobj = Lib.extendFlat({}, astr);
          if (_traces === void 0) _traces = val;
        } else {
          Lib.warn("Restyle fail.", astr, val, _traces);
          return Promise.reject();
        }
        if (Object.keys(aobj).length) gd.changed = true;
        var traces = helpers.coerceTraceIndices(gd, _traces);
        var specs = _restyle(gd, aobj, traces);
        var flags = specs.flags;
        if (flags.calc) gd.calcdata = void 0;
        if (flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});
        var seq = [];
        if (flags.fullReplot) {
          seq.push(exports._doPlot);
        } else {
          seq.push(Plots.previousPromises);
          Plots.supplyDefaults(gd);
          if (flags.markerSize) {
            Plots.doCalcdata(gd);
            addAxRangeSequence(seq);
          }
          if (flags.style) seq.push(subroutines.doTraceStyle);
          if (flags.colorbars) seq.push(subroutines.doColorBars);
          seq.push(emitAfterPlot);
        }
        seq.push(
          Plots.rehover,
          Plots.redrag,
          Plots.reselect
        );
        Queue.add(
          gd,
          restyle,
          [gd, specs.undoit, specs.traces],
          restyle,
          [gd, specs.redoit, specs.traces]
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve();
        return plotDone.then(function() {
          gd.emit("plotly_restyle", specs.eventData);
          return gd;
        });
      }
      function undefinedToNull(val) {
        if (val === void 0) return null;
        return val;
      }
      function makeNP(preGUI, guiEditFlag) {
        if (!guiEditFlag) return nestedProperty;
        return function(container, attr, prefix) {
          var np = nestedProperty(container, attr);
          var npSet = np.set;
          np.set = function(val) {
            var fullAttr = (prefix || "") + attr;
            storeCurrent(fullAttr, np.get(), val, preGUI);
            npSet(val);
          };
          return np;
        };
      }
      function storeCurrent(attr, val, newVal, preGUI) {
        if (Array.isArray(val) || Array.isArray(newVal)) {
          var arrayVal = Array.isArray(val) ? val : [];
          var arrayNew = Array.isArray(newVal) ? newVal : [];
          var maxLen = Math.max(arrayVal.length, arrayNew.length);
          for (var i = 0; i < maxLen; i++) {
            storeCurrent(attr + "[" + i + "]", arrayVal[i], arrayNew[i], preGUI);
          }
        } else if (Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {
          var objVal = Lib.isPlainObject(val) ? val : {};
          var objNew = Lib.isPlainObject(newVal) ? newVal : {};
          var objBoth = Lib.extendFlat({}, objVal, objNew);
          for (var key in objBoth) {
            storeCurrent(attr + "." + key, objVal[key], objNew[key], preGUI);
          }
        } else if (preGUI[attr] === void 0) {
          preGUI[attr] = undefinedToNull(val);
        }
      }
      function _storeDirectGUIEdit(container, preGUI, edits) {
        for (var attr in edits) {
          var np = nestedProperty(container, attr);
          storeCurrent(attr, np.get(), edits[attr], preGUI);
        }
      }
      function _restyle(gd, aobj, traces) {
        var fullLayout = gd._fullLayout;
        var fullData = gd._fullData;
        var data = gd.data;
        var guiEditFlag = fullLayout._guiEditing;
        var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);
        var eventData = Lib.extendDeepAll({}, aobj);
        var i;
        var flags = editTypes.traceFlags();
        var redoit = {};
        var undoit = {};
        var axlist;
        function a0() {
          return traces.map(function() {
            return void 0;
          });
        }
        function addToAxlist(axid) {
          var axName = Axes.id2name(axid);
          if (axlist.indexOf(axName) === -1) axlist.push(axName);
        }
        function autorangeAttr(axName) {
          return "LAYOUT" + axName + ".autorange";
        }
        function rangeAttr(axName) {
          return "LAYOUT" + axName + ".range";
        }
        function getFullTrace(traceIndex) {
          for (var j = traceIndex; j < fullData.length; j++) {
            if (fullData[j]._input === data[traceIndex]) return fullData[j];
          }
        }
        function doextra(attr, val, i2) {
          if (Array.isArray(attr)) {
            attr.forEach(function(a) {
              doextra(a, val, i2);
            });
            return;
          }
          if (attr in aobj || helpers.hasParent(aobj, attr)) return;
          var extraparam;
          if (attr.substr(0, 6) === "LAYOUT") {
            extraparam = layoutNP(gd.layout, attr.replace("LAYOUT", ""));
          } else {
            var tracei = traces[i2];
            var preGUI2 = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];
            extraparam = makeNP(preGUI2, guiEditFlag)(data[tracei], attr);
          }
          if (!(attr in undoit)) {
            undoit[attr] = a0();
          }
          if (undoit[attr][i2] === void 0) {
            undoit[attr][i2] = undefinedToNull(extraparam.get());
          }
          if (val !== void 0) {
            extraparam.set(val);
          }
        }
        function allBins(binAttr) {
          return function(j) {
            return fullData[j][binAttr];
          };
        }
        function arrayBins(binAttr) {
          return function(vij, j) {
            return vij === false ? fullData[traces[j]][binAttr] : null;
          };
        }
        for (var ai in aobj) {
          if (helpers.hasParent(aobj, ai)) {
            throw new Error("cannot set " + ai + " and a parent attribute simultaneously");
          }
          var vi = aobj[ai];
          var cont;
          var contFull;
          var param;
          var oldVal;
          var newVal;
          var valObject;
          if (ai === "autobinx" || ai === "autobiny") {
            ai = ai.charAt(ai.length - 1) + "bins";
            if (Array.isArray(vi)) vi = vi.map(arrayBins(ai));
            else if (vi === false) vi = traces.map(allBins(ai));
            else vi = null;
          }
          redoit[ai] = vi;
          if (ai.substr(0, 6) === "LAYOUT") {
            param = layoutNP(gd.layout, ai.replace("LAYOUT", ""));
            undoit[ai] = [undefinedToNull(param.get())];
            param.set(Array.isArray(vi) ? vi[0] : vi);
            flags.calc = true;
            continue;
          }
          undoit[ai] = a0();
          for (i = 0; i < traces.length; i++) {
            cont = data[traces[i]];
            contFull = getFullTrace(traces[i]);
            var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];
            param = makeNP(preGUI, guiEditFlag)(cont, ai);
            oldVal = param.get();
            newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;
            if (newVal === void 0) continue;
            var finalPart = param.parts[param.parts.length - 1];
            var prefix = ai.substr(0, ai.length - finalPart.length - 1);
            var prefixDot = prefix ? prefix + "." : "";
            var innerContFull = prefix ? nestedProperty(contFull, prefix).get() : contFull;
            valObject = PlotSchema.getTraceValObject(contFull, param.parts);
            if (valObject && valObject.impliedEdits && newVal !== null) {
              for (var impliedKey in valObject.impliedEdits) {
                doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);
              }
            } else if ((finalPart === "thicknessmode" || finalPart === "lenmode") && oldVal !== newVal && (newVal === "fraction" || newVal === "pixels") && innerContFull) {
              var gs = fullLayout._size;
              var orient = innerContFull.orient;
              var topOrBottom = orient === "top" || orient === "bottom";
              if (finalPart === "thicknessmode") {
                var thicknorm = topOrBottom ? gs.h : gs.w;
                doextra(prefixDot + "thickness", innerContFull.thickness * (newVal === "fraction" ? 1 / thicknorm : thicknorm), i);
              } else {
                var lennorm = topOrBottom ? gs.w : gs.h;
                doextra(prefixDot + "len", innerContFull.len * (newVal === "fraction" ? 1 / lennorm : lennorm), i);
              }
            } else if (ai === "type" && (newVal === "pie" !== (oldVal === "pie") || newVal === "funnelarea" !== (oldVal === "funnelarea"))) {
              var labelsTo = "x";
              var valuesTo = "y";
              if ((newVal === "bar" || oldVal === "bar") && cont.orientation === "h") {
                labelsTo = "y";
                valuesTo = "x";
              }
              Lib.swapAttrs(cont, ["?", "?src"], "labels", labelsTo);
              Lib.swapAttrs(cont, ["d?", "?0"], "label", labelsTo);
              Lib.swapAttrs(cont, ["?", "?src"], "values", valuesTo);
              if (oldVal === "pie" || oldVal === "funnelarea") {
                nestedProperty(cont, "marker.color").set(nestedProperty(cont, "marker.colors").get());
                fullLayout._pielayer.selectAll("g.trace").remove();
              } else if (Registry.traceIs(cont, "cartesian")) {
                nestedProperty(cont, "marker.colors").set(nestedProperty(cont, "marker.color").get());
              }
            }
            undoit[ai][i] = undefinedToNull(oldVal);
            var swapAttrs = [
              "swapxy",
              "swapxyaxes",
              "orientation",
              "orientationaxes"
            ];
            if (swapAttrs.indexOf(ai) !== -1) {
              if (ai === "orientation") {
                param.set(newVal);
                var defaultOrientation = cont.x && !cont.y ? "h" : "v";
                if ((param.get() || defaultOrientation) === contFull.orientation) {
                  continue;
                }
              } else if (ai === "orientationaxes") {
                cont.orientation = { v: "h", h: "v" }[contFull.orientation];
              }
              helpers.swapXYData(cont);
              flags.calc = flags.clearAxisTypes = true;
            } else if (Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {
              helpers.manageArrayContainers(param, newVal, undoit);
              flags.calc = true;
            } else {
              if (valObject) {
                if (valObject.arrayOk && !Registry.traceIs(contFull, "regl") && (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))) {
                  flags.calc = true;
                } else editTypes.update(flags, valObject);
              } else {
                flags.calc = true;
              }
              param.set(newVal);
            }
          }
          if (["swapxyaxes", "orientationaxes"].indexOf(ai) !== -1) {
            Axes.swap(gd, traces);
          }
          if (ai === "orientationaxes") {
            var hovermode = nestedProperty(gd.layout, "hovermode");
            var h = hovermode.get();
            if (h === "x") {
              hovermode.set("y");
            } else if (h === "y") {
              hovermode.set("x");
            } else if (h === "x unified") {
              hovermode.set("y unified");
            } else if (h === "y unified") {
              hovermode.set("x unified");
            }
          }
          if (["orientation", "type"].indexOf(ai) !== -1) {
            axlist = [];
            for (i = 0; i < traces.length; i++) {
              var trace = data[traces[i]];
              if (Registry.traceIs(trace, "cartesian")) {
                addToAxlist(trace.xaxis || "x");
                addToAxlist(trace.yaxis || "y");
              }
            }
            doextra(axlist.map(autorangeAttr), true, 0);
            doextra(axlist.map(rangeAttr), [0, 1], 0);
          }
        }
        if (flags.calc || flags.plot) {
          flags.fullReplot = true;
        }
        return {
          flags,
          undoit,
          redoit,
          traces,
          eventData: Lib.extendDeepNoArrays([], [eventData, traces])
        };
      }
      function relayout(gd, astr, val) {
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        var aobj = {};
        if (typeof astr === "string") {
          aobj[astr] = val;
        } else if (Lib.isPlainObject(astr)) {
          aobj = Lib.extendFlat({}, astr);
        } else {
          Lib.warn("Relayout fail.", astr, val);
          return Promise.reject();
        }
        if (Object.keys(aobj).length) gd.changed = true;
        var specs = _relayout(gd, aobj);
        var flags = specs.flags;
        if (flags.calc) gd.calcdata = void 0;
        var seq = [Plots.previousPromises];
        if (flags.layoutReplot) {
          seq.push(subroutines.layoutReplot);
        } else if (Object.keys(aobj).length) {
          axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);
          if (flags.legend) seq.push(subroutines.doLegend);
          if (flags.layoutstyle) seq.push(subroutines.layoutStyles);
          if (flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);
          if (flags.ticks) seq.push(subroutines.doTicksRelayout);
          if (flags.modebar) seq.push(subroutines.doModeBar);
          if (flags.camera) seq.push(subroutines.doCamera);
          if (flags.colorbars) seq.push(subroutines.doColorBars);
          seq.push(emitAfterPlot);
        }
        seq.push(
          Plots.rehover,
          Plots.redrag,
          Plots.reselect
        );
        Queue.add(
          gd,
          relayout,
          [gd, specs.undoit],
          relayout,
          [gd, specs.redoit]
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
        return plotDone.then(function() {
          gd.emit("plotly_relayout", specs.eventData);
          return gd;
        });
      }
      function axRangeSupplyDefaultsByPass(gd, flags, specs) {
        var fullLayout = gd._fullLayout;
        if (!flags.axrange) return false;
        for (var k in flags) {
          if (k !== "axrange" && flags[k]) return false;
        }
        var axIn, axOut;
        var coerce = function(attr, dflt) {
          return Lib.coerce(axIn, axOut, cartesianLayoutAttributes, attr, dflt);
        };
        var options = {};
        for (var axId in specs.rangesAltered) {
          var axName = Axes.id2name(axId);
          axIn = gd.layout[axName];
          axOut = fullLayout[axName];
          handleRangeDefaults(axIn, axOut, coerce, options);
          if (axOut._matchGroup) {
            for (var axId2 in axOut._matchGroup) {
              if (axId2 !== axId) {
                var ax2 = fullLayout[Axes.id2name(axId2)];
                ax2.autorange = axOut.autorange;
                ax2.range = axOut.range.slice();
                ax2._input.range = axOut.range.slice();
              }
            }
          }
        }
        return true;
      }
      function addAxRangeSequence(seq, rangesAltered) {
        var drawAxes = rangesAltered ? function(gd) {
          var axIds = [];
          var skipTitle = true;
          for (var id in rangesAltered) {
            var ax = Axes.getFromId(gd, id);
            axIds.push(id);
            if ((ax.ticklabelposition || "").indexOf("inside") !== -1) {
              if (ax._anchorAxis) {
                axIds.push(ax._anchorAxis._id);
              }
            }
            if (ax._matchGroup) {
              for (var id2 in ax._matchGroup) {
                if (!rangesAltered[id2]) {
                  axIds.push(id2);
                }
              }
            }
          }
          return Axes.draw(gd, axIds, { skipTitle });
        } : function(gd) {
          return Axes.draw(gd, "redraw");
        };
        seq.push(
          clearOutline,
          subroutines.doAutoRangeAndConstraints,
          drawAxes,
          subroutines.drawData,
          subroutines.finalDraw
        );
      }
      var AX_RANGE_RE = /^[xyz]axis[0-9]*\.range(\[[0|1]\])?$/;
      var AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\.autorange$/;
      var AX_DOMAIN_RE = /^[xyz]axis[0-9]*\.domain(\[[0|1]\])?$/;
      function _relayout(gd, aobj) {
        var layout = gd.layout;
        var fullLayout = gd._fullLayout;
        var guiEditFlag = fullLayout._guiEditing;
        var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);
        var keys = Object.keys(aobj);
        var axes = Axes.list(gd);
        var eventData = Lib.extendDeepAll({}, aobj);
        var arrayEdits = {};
        var arrayStr, i, j;
        keys = Object.keys(aobj);
        for (i = 0; i < keys.length; i++) {
          if (keys[i].indexOf("allaxes") === 0) {
            for (j = 0; j < axes.length; j++) {
              var scene = axes[j]._id.substr(1);
              var axisAttr = scene.indexOf("scene") !== -1 ? scene + "." : "";
              var newkey = keys[i].replace("allaxes", axisAttr + axes[j]._name);
              if (!aobj[newkey]) aobj[newkey] = aobj[keys[i]];
            }
            delete aobj[keys[i]];
          }
        }
        var flags = editTypes.layoutFlags();
        var redoit = {};
        var undoit = {};
        function doextra(attr, val) {
          if (Array.isArray(attr)) {
            attr.forEach(function(a) {
              doextra(a, val);
            });
            return;
          }
          if (attr in aobj || helpers.hasParent(aobj, attr)) return;
          var p2 = layoutNP(layout, attr);
          if (!(attr in undoit)) {
            undoit[attr] = undefinedToNull(p2.get());
          }
          if (val !== void 0) p2.set(val);
        }
        var rangesAltered = {};
        var ax;
        function recordAlteredAxis(pleafPlus2) {
          var axId2 = Axes.name2id(pleafPlus2.split(".")[0]);
          rangesAltered[axId2] = 1;
          return axId2;
        }
        for (var ai in aobj) {
          if (helpers.hasParent(aobj, ai)) {
            throw new Error("cannot set " + ai + " and a parent attribute simultaneously");
          }
          var p = layoutNP(layout, ai);
          var vi = aobj[ai];
          var plen = p.parts.length;
          var pend = plen - 1;
          while (pend > 0 && typeof p.parts[pend] !== "string") pend--;
          var pleaf = p.parts[pend];
          var pleafPlus = p.parts[pend - 1] + "." + pleaf;
          var ptrunk = p.parts.slice(0, pend).join(".");
          var parentIn = nestedProperty(gd.layout, ptrunk).get();
          var parentFull = nestedProperty(fullLayout, ptrunk).get();
          var vOld = p.get();
          if (vi === void 0) continue;
          redoit[ai] = vi;
          undoit[ai] = pleaf === "reverse" ? vi : undefinedToNull(vOld);
          var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);
          if (valObject && valObject.impliedEdits && vi !== null) {
            for (var impliedKey in valObject.impliedEdits) {
              doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);
            }
          }
          if (["width", "height"].indexOf(ai) !== -1) {
            if (vi) {
              doextra("autosize", null);
              var oppositeAttr = ai === "height" ? "width" : "height";
              doextra(oppositeAttr, fullLayout[oppositeAttr]);
            } else {
              fullLayout[ai] = gd._initialAutoSize[ai];
            }
          } else if (ai === "autosize") {
            doextra("width", vi ? null : fullLayout.width);
            doextra("height", vi ? null : fullLayout.height);
          } else if (pleafPlus.match(AX_RANGE_RE)) {
            recordAlteredAxis(pleafPlus);
            nestedProperty(fullLayout, ptrunk + "._inputRange").set(null);
          } else if (pleafPlus.match(AX_AUTORANGE_RE)) {
            recordAlteredAxis(pleafPlus);
            nestedProperty(fullLayout, ptrunk + "._inputRange").set(null);
            var axFull = nestedProperty(fullLayout, ptrunk).get();
            if (axFull._inputDomain) {
              axFull._input.domain = axFull._inputDomain.slice();
            }
          } else if (pleafPlus.match(AX_DOMAIN_RE)) {
            nestedProperty(fullLayout, ptrunk + "._inputDomain").set(null);
          }
          if (pleaf === "type") {
            ax = parentIn;
            var toLog = parentFull.type === "linear" && vi === "log";
            var fromLog = parentFull.type === "log" && vi === "linear";
            if (toLog || fromLog) {
              if (!ax || !ax.range) {
                doextra(ptrunk + ".autorange", true);
              } else if (!parentFull.autorange) {
                var r0 = ax.range[0];
                var r1 = ax.range[1];
                if (toLog) {
                  if (r0 <= 0 && r1 <= 0) {
                    doextra(ptrunk + ".autorange", true);
                  }
                  if (r0 <= 0) r0 = r1 / 1e6;
                  else if (r1 <= 0) r1 = r0 / 1e6;
                  doextra(ptrunk + ".range[0]", Math.log(r0) / Math.LN10);
                  doextra(ptrunk + ".range[1]", Math.log(r1) / Math.LN10);
                } else {
                  doextra(ptrunk + ".range[0]", Math.pow(10, r0));
                  doextra(ptrunk + ".range[1]", Math.pow(10, r1));
                }
              } else if (toLog) {
                ax.range = ax.range[1] > ax.range[0] ? [1, 2] : [2, 1];
              }
              if (Array.isArray(fullLayout._subplots.polar) && fullLayout._subplots.polar.length && fullLayout[p.parts[0]] && p.parts[1] === "radialaxis") {
                delete fullLayout[p.parts[0]]._subplot.viewInitial["radialaxis.range"];
              }
              Registry.getComponentMethod("annotations", "convertCoords")(gd, parentFull, vi, doextra);
              Registry.getComponentMethod("images", "convertCoords")(gd, parentFull, vi, doextra);
            } else {
              doextra(ptrunk + ".autorange", true);
              doextra(ptrunk + ".range", null);
            }
            nestedProperty(fullLayout, ptrunk + "._inputRange").set(null);
          } else if (pleaf.match(AX_NAME_PATTERN)) {
            var fullProp = nestedProperty(fullLayout, ai).get();
            var newType = (vi || {}).type;
            if (!newType || newType === "-") newType = "linear";
            Registry.getComponentMethod("annotations", "convertCoords")(gd, fullProp, newType, doextra);
            Registry.getComponentMethod("images", "convertCoords")(gd, fullProp, newType, doextra);
          }
          var containerArrayMatch = manageArrays.containerArrayMatch(ai);
          if (containerArrayMatch) {
            arrayStr = containerArrayMatch.array;
            i = containerArrayMatch.index;
            var propStr = containerArrayMatch.property;
            var updateValObject = valObject || { editType: "calc" };
            if (i !== "" && propStr === "") {
              if (manageArrays.isAddVal(vi)) {
                undoit[ai] = null;
              } else if (manageArrays.isRemoveVal(vi)) {
                undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];
              } else {
                Lib.warn("unrecognized full object value", aobj);
              }
            }
            editTypes.update(flags, updateValObject);
            if (!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};
            var objEdits = arrayEdits[arrayStr][i];
            if (!objEdits) objEdits = arrayEdits[arrayStr][i] = {};
            objEdits[propStr] = vi;
            delete aobj[ai];
          } else if (pleaf === "reverse") {
            if (parentIn.range) parentIn.range.reverse();
            else {
              doextra(ptrunk + ".autorange", true);
              parentIn.range = [1, 0];
            }
            if (parentFull.autorange) flags.calc = true;
            else flags.plot = true;
          } else {
            if (ai === "dragmode" && (vi === false && vOld !== false || vi !== false && vOld === false)) {
              flags.plot = true;
            } else if (fullLayout._has("scatter-like") && fullLayout._has("regl") && (ai === "dragmode" && (vi === "lasso" || vi === "select") && !(vOld === "lasso" || vOld === "select"))) {
              flags.plot = true;
            } else if (valObject) editTypes.update(flags, valObject);
            else flags.calc = true;
            p.set(vi);
          }
        }
        for (arrayStr in arrayEdits) {
          var finished = manageArrays.applyContainerArrayChanges(
            gd,
            layoutNP(layout, arrayStr),
            arrayEdits[arrayStr],
            flags,
            layoutNP
          );
          if (!finished) flags.plot = true;
        }
        for (var axId in rangesAltered) {
          ax = Axes.getFromId(gd, axId);
          var group = ax && ax._constraintGroup;
          if (group) {
            flags.calc = true;
            for (var groupAxId in group) {
              if (!rangesAltered[groupAxId]) {
                Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;
              }
            }
          }
        }
        if (updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;
        var shapes = fullLayout.shapes;
        for (i = 0; i < shapes.length; i++) {
          if (shapes[i].showlegend) {
            flags.calc = true;
            break;
          }
        }
        if (flags.plot || flags.calc) {
          flags.layoutReplot = true;
        }
        return {
          flags,
          rangesAltered,
          undoit,
          redoit,
          eventData
        };
      }
      function updateAutosize(gd) {
        var fullLayout = gd._fullLayout;
        var oldWidth = fullLayout.width;
        var oldHeight = fullLayout.height;
        if (gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);
        return fullLayout.width !== oldWidth || fullLayout.height !== oldHeight;
      }
      function update(gd, traceUpdate, layoutUpdate, _traces) {
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        if (!Lib.isPlainObject(traceUpdate)) traceUpdate = {};
        if (!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};
        if (Object.keys(traceUpdate).length) gd.changed = true;
        if (Object.keys(layoutUpdate).length) gd.changed = true;
        var traces = helpers.coerceTraceIndices(gd, _traces);
        var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);
        var restyleFlags = restyleSpecs.flags;
        var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));
        var relayoutFlags = relayoutSpecs.flags;
        if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = void 0;
        if (restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);
        var seq = [];
        if (relayoutFlags.layoutReplot) {
          seq.push(subroutines.layoutReplot);
        } else if (restyleFlags.fullReplot) {
          seq.push(exports._doPlot);
        } else {
          seq.push(Plots.previousPromises);
          axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);
          if (restyleFlags.style) seq.push(subroutines.doTraceStyle);
          if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);
          if (relayoutFlags.legend) seq.push(subroutines.doLegend);
          if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);
          if (relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);
          if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
          if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);
          if (relayoutFlags.camera) seq.push(subroutines.doCamera);
          seq.push(emitAfterPlot);
        }
        seq.push(
          Plots.rehover,
          Plots.redrag,
          Plots.reselect
        );
        Queue.add(
          gd,
          update,
          [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces],
          update,
          [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]
        );
        var plotDone = Lib.syncOrAsync(seq, gd);
        if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
        return plotDone.then(function() {
          gd.emit("plotly_update", {
            data: restyleSpecs.eventData,
            layout: relayoutSpecs.eventData
          });
          return gd;
        });
      }
      function guiEdit(func) {
        return function wrappedEdit(gd) {
          gd._fullLayout._guiEditing = true;
          var p = func.apply(null, arguments);
          gd._fullLayout._guiEditing = false;
          return p;
        };
      }
      var layoutUIControlPatterns = [
        { pattern: /^hiddenlabels/, attr: "legend.uirevision" },
        { pattern: /^((x|y)axis\d*)\.((auto)?range|title\.text)/ },
        // showspikes and modes include those nested inside scenes
        { pattern: /axis\d*\.showspikes$/, attr: "modebar.uirevision" },
        { pattern: /(hover|drag)mode$/, attr: "modebar.uirevision" },
        { pattern: /^(scene\d*)\.camera/ },
        { pattern: /^(geo\d*)\.(projection|center|fitbounds)/ },
        { pattern: /^(ternary\d*\.[abc]axis)\.(min|title\.text)$/ },
        { pattern: /^(polar\d*\.radialaxis)\.((auto)?range|angle|title\.text)/ },
        { pattern: /^(polar\d*\.angularaxis)\.rotation/ },
        { pattern: /^(mapbox\d*)\.(center|zoom|bearing|pitch)/ },
        { pattern: /^(map\d*)\.(center|zoom|bearing|pitch)/ },
        { pattern: /^legend\.(x|y)$/, attr: "editrevision" },
        { pattern: /^(shapes|annotations)/, attr: "editrevision" },
        { pattern: /^title\.text$/, attr: "editrevision" }
      ];
      var traceUIControlPatterns = [
        { pattern: /^selectedpoints$/, attr: "selectionrevision" },
        // "visible" includes trace.transforms[i].styles[j].value.visible
        { pattern: /(^|value\.)visible$/, attr: "legend.uirevision" },
        { pattern: /^dimensions\[\d+\]\.constraintrange/ },
        { pattern: /^node\.(x|y|groups)/ },
        // for Sankey nodes
        { pattern: /^level$/ },
        // for Sunburst, Treemap and Icicle traces
        // below this you must be in editable: true mode
        // TODO: I still put name and title with `trace.uirevision`
        // reasonable or should these be `editrevision`?
        // Also applies to axis titles up in the layout section
        // "name" also includes transform.styles
        { pattern: /(^|value\.)name$/ },
        // including nested colorbar attributes (ie marker.colorbar)
        { pattern: /colorbar\.title\.text$/ },
        { pattern: /colorbar\.(x|y)$/, attr: "editrevision" }
      ];
      function findUIPattern(key, patternSpecs) {
        for (var i = 0; i < patternSpecs.length; i++) {
          var spec = patternSpecs[i];
          var match = key.match(spec.pattern);
          if (match) {
            var head = match[1] || "";
            return { head, tail: key.substr(head.length + 1), attr: spec.attr };
          }
        }
      }
      function getNewRev(revAttr, container) {
        var newRev = nestedProperty(container, revAttr).get();
        if (newRev !== void 0) return newRev;
        var parts = revAttr.split(".");
        parts.pop();
        while (parts.length > 1) {
          parts.pop();
          newRev = nestedProperty(container, parts.join(".") + ".uirevision").get();
          if (newRev !== void 0) return newRev;
        }
        return container.uirevision;
      }
      function getFullTraceIndexFromUid(uid, fullData) {
        for (var i = 0; i < fullData.length; i++) {
          if (fullData[i]._fullInput.uid === uid) return i;
        }
        return -1;
      }
      function getTraceIndexFromUid(uid, data, tracei) {
        for (var i = 0; i < data.length; i++) {
          if (data[i].uid === uid) return i;
        }
        return !data[tracei] || data[tracei].uid ? -1 : tracei;
      }
      function valsMatch(v1, v2) {
        var v1IsObj = Lib.isPlainObject(v1);
        var v1IsArray = Array.isArray(v1);
        if (v1IsObj || v1IsArray) {
          return (v1IsObj && Lib.isPlainObject(v2) || v1IsArray && Array.isArray(v2)) && JSON.stringify(v1) === JSON.stringify(v2);
        }
        return v1 === v2;
      }
      function applyUIRevisions(data, layout, oldFullData, oldFullLayout) {
        var layoutPreGUI = oldFullLayout._preGUI;
        var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal, head, tail;
        var bothInheritAutorange = [];
        var newAutorangeIn = {};
        var newRangeAccepted = {};
        for (key in layoutPreGUI) {
          match = findUIPattern(key, layoutUIControlPatterns);
          if (match) {
            head = match.head;
            tail = match.tail;
            revAttr = match.attr || head + ".uirevision";
            oldRev = nestedProperty(oldFullLayout, revAttr).get();
            newRev = oldRev && getNewRev(revAttr, layout);
            if (newRev && newRev === oldRev) {
              preGUIVal = layoutPreGUI[key];
              if (preGUIVal === null) preGUIVal = void 0;
              newNP = nestedProperty(layout, key);
              newVal = newNP.get();
              if (valsMatch(newVal, preGUIVal)) {
                if (newVal === void 0 && tail === "autorange") {
                  bothInheritAutorange.push(head);
                }
                newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));
                continue;
              } else if (tail === "autorange" || tail.substr(0, 6) === "range[") {
                var pre0 = layoutPreGUI[head + ".range[0]"];
                var pre1 = layoutPreGUI[head + ".range[1]"];
                var preAuto = layoutPreGUI[head + ".autorange"];
                if (preAuto || preAuto === null && pre0 === null && pre1 === null) {
                  if (!(head in newAutorangeIn)) {
                    var newContainer = nestedProperty(layout, head).get();
                    newAutorangeIn[head] = newContainer && (newContainer.autorange || newContainer.autorange !== false && (!newContainer.range || newContainer.range.length !== 2));
                  }
                  if (newAutorangeIn[head]) {
                    newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));
                    continue;
                  }
                }
              }
            }
          } else {
            Lib.warn("unrecognized GUI edit: " + key);
          }
          delete layoutPreGUI[key];
          if (match && match.tail.substr(0, 6) === "range[") {
            newRangeAccepted[match.head] = 1;
          }
        }
        for (var i = 0; i < bothInheritAutorange.length; i++) {
          var axAttr = bothInheritAutorange[i];
          if (newRangeAccepted[axAttr]) {
            var newAx = nestedProperty(layout, axAttr).get();
            if (newAx) delete newAx.autorange;
          }
        }
        var allTracePreGUI = oldFullLayout._tracePreGUI;
        for (var uid in allTracePreGUI) {
          var tracePreGUI = allTracePreGUI[uid];
          var newTrace = null;
          var fullInput;
          for (key in tracePreGUI) {
            if (!newTrace) {
              var fulli = getFullTraceIndexFromUid(uid, oldFullData);
              if (fulli < 0) {
                delete allTracePreGUI[uid];
                break;
              }
              var fullTrace = oldFullData[fulli];
              fullInput = fullTrace._fullInput;
              var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);
              if (newTracei < 0) {
                delete allTracePreGUI[uid];
                break;
              }
              newTrace = data[newTracei];
            }
            match = findUIPattern(key, traceUIControlPatterns);
            if (match) {
              if (match.attr) {
                oldRev = nestedProperty(oldFullLayout, match.attr).get();
                newRev = oldRev && getNewRev(match.attr, layout);
              } else {
                oldRev = fullInput.uirevision;
                newRev = newTrace.uirevision;
                if (newRev === void 0) newRev = layout.uirevision;
              }
              if (newRev && newRev === oldRev) {
                preGUIVal = tracePreGUI[key];
                if (preGUIVal === null) preGUIVal = void 0;
                newNP = nestedProperty(newTrace, key);
                newVal = newNP.get();
                if (valsMatch(newVal, preGUIVal)) {
                  newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));
                  continue;
                }
              }
            } else {
              Lib.warn("unrecognized GUI edit: " + key + " in trace uid " + uid);
            }
            delete tracePreGUI[key];
          }
        }
      }
      function react(gd, data, layout, config) {
        var frames, plotDone;
        function addFrames2() {
          return exports.addFrames(gd, frames);
        }
        gd = Lib.getGraphDiv(gd);
        helpers.clearPromiseQueue(gd);
        var oldFullData = gd._fullData;
        var oldFullLayout = gd._fullLayout;
        if (!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {
          plotDone = exports.newPlot(gd, data, layout, config);
        } else {
          if (Lib.isPlainObject(data)) {
            var obj = data;
            data = obj.data;
            layout = obj.layout;
            config = obj.config;
            frames = obj.frames;
          }
          var configChanged = false;
          if (config) {
            var oldConfig = Lib.extendDeep({}, gd._context);
            gd._context = void 0;
            setPlotContext(gd, config);
            configChanged = diffConfig(oldConfig, gd._context);
          }
          gd.data = data || [];
          helpers.cleanData(gd.data);
          gd.layout = layout || {};
          helpers.cleanLayout(gd.layout);
          applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);
          Plots.supplyDefaults(gd, { skipUpdateCalc: true });
          var newFullData = gd._fullData;
          var newFullLayout = gd._fullLayout;
          var immutable = newFullLayout.datarevision === void 0;
          var transition = newFullLayout.transition;
          var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);
          var newDataRevision = relayoutFlags.newDataRevision;
          var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);
          if (updateAutosize(gd)) relayoutFlags.layoutReplot = true;
          if (restyleFlags.calc || relayoutFlags.calc) {
            gd.calcdata = void 0;
            var allNames = Object.getOwnPropertyNames(newFullLayout);
            for (var q = 0; q < allNames.length; q++) {
              var name = allNames[q];
              var start = name.substring(0, 5);
              if (start === "xaxis" || start === "yaxis") {
                var emptyCategories = newFullLayout[name]._emptyCategories;
                if (emptyCategories) emptyCategories();
              }
            }
          } else {
            Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);
          }
          var seq = [];
          if (frames) {
            gd._transitionData = {};
            Plots.createTransitionData(gd);
            seq.push(addFrames2);
          }
          if (newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {
            if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
            Plots.doCalcdata(gd);
            subroutines.doAutoRangeAndConstraints(gd);
            seq.push(function() {
              return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);
            });
          } else if (restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {
            gd._fullLayout._skipDefaults = true;
            seq.push(exports._doPlot);
          } else {
            for (var componentType in relayoutFlags.arrays) {
              var indices = relayoutFlags.arrays[componentType];
              if (indices.length) {
                var drawOne = Registry.getComponentMethod(componentType, "drawOne");
                if (drawOne !== Lib.noop) {
                  for (var i = 0; i < indices.length; i++) {
                    drawOne(gd, indices[i]);
                  }
                } else {
                  var draw = Registry.getComponentMethod(componentType, "draw");
                  if (draw === Lib.noop) {
                    throw new Error("cannot draw components: " + componentType);
                  }
                  draw(gd);
                }
              }
            }
            seq.push(Plots.previousPromises);
            if (restyleFlags.style) seq.push(subroutines.doTraceStyle);
            if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);
            if (relayoutFlags.legend) seq.push(subroutines.doLegend);
            if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);
            if (relayoutFlags.axrange) addAxRangeSequence(seq);
            if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);
            if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);
            if (relayoutFlags.camera) seq.push(subroutines.doCamera);
            seq.push(emitAfterPlot);
          }
          seq.push(
            Plots.rehover,
            Plots.redrag,
            Plots.reselect
          );
          plotDone = Lib.syncOrAsync(seq, gd);
          if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);
        }
        return plotDone.then(function() {
          gd.emit("plotly_react", {
            data,
            layout
          });
          return gd;
        });
      }
      function diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {
        var sameTraceLength = oldFullData.length === newFullData.length;
        if (!transition && !sameTraceLength) {
          return {
            fullReplot: true,
            calc: true
          };
        }
        var flags = editTypes.traceFlags();
        flags.arrays = {};
        flags.nChanges = 0;
        flags.nChangesAnim = 0;
        var i, trace;
        function getTraceValObject(parts) {
          var out = PlotSchema.getTraceValObject(trace, parts);
          if (!trace._module.animatable && out.anim) {
            out.anim = false;
          }
          return out;
        }
        var diffOpts = {
          getValObject: getTraceValObject,
          flags,
          immutable,
          transition,
          newDataRevision,
          gd
        };
        var seenUIDs = {};
        for (i = 0; i < oldFullData.length; i++) {
          if (newFullData[i]) {
            trace = newFullData[i]._fullInput;
            if (seenUIDs[trace.uid]) continue;
            seenUIDs[trace.uid] = 1;
            getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);
          }
        }
        if (flags.calc || flags.plot) {
          flags.fullReplot = true;
        }
        if (transition && flags.nChanges && flags.nChangesAnim) {
          flags.anim = flags.nChanges === flags.nChangesAnim && sameTraceLength ? "all" : "some";
        }
        return flags;
      }
      function diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {
        var flags = editTypes.layoutFlags();
        flags.arrays = {};
        flags.rangesAltered = {};
        flags.nChanges = 0;
        flags.nChangesAnim = 0;
        function getLayoutValObject(parts) {
          return PlotSchema.getLayoutValObject(newFullLayout, parts);
        }
        for (var key in newFullLayout) {
          if (!key.startsWith("xaxis") && !key.startsWith("yaxis")) {
            continue;
          }
          if (!oldFullLayout[key]) {
            continue;
          }
          var newDomain = newFullLayout[key].domain;
          var oldDomain = oldFullLayout[key].domain;
          var oldInputDomain = oldFullLayout[key]._inputDomain;
          if (oldFullLayout[key]._inputDomain) {
            if (newDomain[0] === oldInputDomain[0] && newDomain[1] === oldInputDomain[1]) {
              newFullLayout[key].domain = oldFullLayout[key].domain;
            } else if (newDomain[0] !== oldDomain[0] || newDomain[1] !== oldDomain[1]) {
              newFullLayout[key]._inputDomain = null;
            }
          }
        }
        var diffOpts = {
          getValObject: getLayoutValObject,
          flags,
          immutable,
          transition,
          gd
        };
        getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);
        if (flags.plot || flags.calc) {
          flags.layoutReplot = true;
        }
        if (transition && flags.nChanges && flags.nChangesAnim) {
          flags.anim = flags.nChanges === flags.nChangesAnim ? "all" : "some";
        }
        return flags;
      }
      function getDiffFlags(oldContainer, newContainer, outerparts, opts) {
        var valObject, key, astr;
        var getValObject = opts.getValObject;
        var flags = opts.flags;
        var immutable = opts.immutable;
        var inArray = opts.inArray;
        var arrayIndex = opts.arrayIndex;
        function changed() {
          var editType = valObject.editType;
          if (inArray && editType.indexOf("arraydraw") !== -1) {
            Lib.pushUnique(flags.arrays[inArray], arrayIndex);
            return;
          }
          editTypes.update(flags, valObject);
          if (editType !== "none") {
            flags.nChanges++;
          }
          if (opts.transition && valObject.anim) {
            flags.nChangesAnim++;
          }
          if (AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {
            flags.rangesAltered[outerparts[0]] = 1;
          }
          if (key === "datarevision") {
            flags.newDataRevision = 1;
          }
        }
        function valObjectCanBeDataArray(valObject2) {
          return valObject2.valType === "data_array" || valObject2.arrayOk;
        }
        for (key in oldContainer) {
          if (flags.calc && !opts.transition) return;
          var oldVal = oldContainer[key];
          var newVal = newContainer[key];
          var parts = outerparts.concat(key);
          astr = parts.join(".");
          if (key.charAt(0) === "_" || typeof oldVal === "function" || oldVal === newVal) continue;
          if ((key === "tick0" || key === "dtick") && outerparts[0] !== "geo") {
            var tickMode = newContainer.tickmode;
            if (tickMode === "auto" || tickMode === "array" || !tickMode) continue;
          }
          if (key === "range" && newContainer.autorange) continue;
          if ((key === "zmin" || key === "zmax") && newContainer.type === "contourcarpet") continue;
          valObject = getValObject(parts);
          if (!valObject) continue;
          if (valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;
          var valType = valObject.valType;
          var i;
          var canBeDataArray = valObjectCanBeDataArray(valObject);
          var wasArray = Array.isArray(oldVal);
          var nowArray = Array.isArray(newVal);
          if (wasArray && nowArray) {
            var inputKey = "_input_" + key;
            var oldValIn = oldContainer[inputKey];
            var newValIn = newContainer[inputKey];
            if (Array.isArray(oldValIn) && oldValIn === newValIn) continue;
          }
          if (newVal === void 0) {
            if (canBeDataArray && wasArray) flags.calc = true;
            else changed();
          } else if (valObject._isLinkedToArray) {
            var arrayEditIndices = [];
            var extraIndices = false;
            if (!inArray) flags.arrays[key] = arrayEditIndices;
            var minLen = Math.min(oldVal.length, newVal.length);
            var maxLen = Math.max(oldVal.length, newVal.length);
            if (minLen !== maxLen) {
              if (valObject.editType === "arraydraw") {
                extraIndices = true;
              } else {
                changed();
                continue;
              }
            }
            for (i = 0; i < minLen; i++) {
              getDiffFlags(
                oldVal[i],
                newVal[i],
                parts.concat(i),
                // add array indices, but not if we're already in an array
                Lib.extendFlat({ inArray: key, arrayIndex: i }, opts)
              );
            }
            if (extraIndices) {
              for (i = minLen; i < maxLen; i++) {
                arrayEditIndices.push(i);
              }
            }
          } else if (!valType && Lib.isPlainObject(oldVal)) {
            getDiffFlags(oldVal, newVal, parts, opts);
          } else if (canBeDataArray) {
            if (wasArray && nowArray) {
              if (immutable) {
                flags.calc = true;
              }
              if (immutable || opts.newDataRevision) {
                changed();
              }
            } else if (wasArray !== nowArray) {
              flags.calc = true;
            } else changed();
          } else if (wasArray && nowArray) {
            if (oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {
              changed();
            }
          } else {
            changed();
          }
        }
        for (key in newContainer) {
          if (!(key in oldContainer || key.charAt(0) === "_" || typeof newContainer[key] === "function")) {
            valObject = getValObject(outerparts.concat(key));
            if (valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {
              flags.calc = true;
              return;
            } else changed();
          }
        }
      }
      function diffConfig(oldConfig, newConfig) {
        var key;
        for (key in oldConfig) {
          if (key.charAt(0) === "_") continue;
          var oldVal = oldConfig[key];
          var newVal = newConfig[key];
          if (oldVal !== newVal) {
            if (Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {
              if (diffConfig(oldVal, newVal)) {
                return true;
              }
            } else if (Array.isArray(oldVal) && Array.isArray(newVal)) {
              if (oldVal.length !== newVal.length) {
                return true;
              }
              for (var i = 0; i < oldVal.length; i++) {
                if (oldVal[i] !== newVal[i]) {
                  if (Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {
                    if (diffConfig(oldVal[i], newVal[i])) {
                      return true;
                    }
                  } else {
                    return true;
                  }
                }
              }
            } else {
              return true;
            }
          }
        }
      }
      function animate(gd, frameOrGroupNameOrFrameList, animationOpts) {
        gd = Lib.getGraphDiv(gd);
        if (!Lib.isPlotDiv(gd)) {
          throw new Error(
            "This element is not a Plotly plot: " + gd + ". It's likely that you've failed to create a plot before animating it. For more details, see https://plotly.com/javascript/animations/"
          );
        }
        var trans = gd._transitionData;
        if (!trans._frameQueue) {
          trans._frameQueue = [];
        }
        animationOpts = Plots.supplyAnimationDefaults(animationOpts);
        var transitionOpts = animationOpts.transition;
        var frameOpts = animationOpts.frame;
        if (trans._frameWaitingCnt === void 0) {
          trans._frameWaitingCnt = 0;
        }
        function getTransitionOpts(i) {
          if (Array.isArray(transitionOpts)) {
            if (i >= transitionOpts.length) {
              return transitionOpts[0];
            } else {
              return transitionOpts[i];
            }
          } else {
            return transitionOpts;
          }
        }
        function getFrameOpts(i) {
          if (Array.isArray(frameOpts)) {
            if (i >= frameOpts.length) {
              return frameOpts[0];
            } else {
              return frameOpts[i];
            }
          } else {
            return frameOpts;
          }
        }
        function callbackOnNthTime(cb, n) {
          var cnt = 0;
          return function() {
            if (cb && ++cnt === n) {
              return cb();
            }
          };
        }
        return new Promise(function(resolve, reject) {
          function discardExistingFrames() {
            if (trans._frameQueue.length === 0) {
              return;
            }
            while (trans._frameQueue.length) {
              var next = trans._frameQueue.pop();
              if (next.onInterrupt) {
                next.onInterrupt();
              }
            }
            gd.emit("plotly_animationinterrupted", []);
          }
          function queueFrames(frameList2) {
            if (frameList2.length === 0) return;
            for (var i2 = 0; i2 < frameList2.length; i2++) {
              var computedFrame;
              if (frameList2[i2].type === "byname") {
                computedFrame = Plots.computeFrame(gd, frameList2[i2].name);
              } else {
                computedFrame = frameList2[i2].data;
              }
              var frameOpts2 = getFrameOpts(i2);
              var transitionOpts2 = getTransitionOpts(i2);
              transitionOpts2.duration = Math.min(transitionOpts2.duration, frameOpts2.duration);
              var nextFrame2 = {
                frame: computedFrame,
                name: frameList2[i2].name,
                frameOpts: frameOpts2,
                transitionOpts: transitionOpts2
              };
              if (i2 === frameList2.length - 1) {
                nextFrame2.onComplete = callbackOnNthTime(resolve, 2);
                nextFrame2.onInterrupt = reject;
              }
              trans._frameQueue.push(nextFrame2);
            }
            if (animationOpts.mode === "immediate") {
              trans._lastFrameAt = -Infinity;
            }
            if (!trans._animationRaf) {
              beginAnimationLoop();
            }
          }
          function stopAnimationLoop() {
            gd.emit("plotly_animated");
            window.cancelAnimationFrame(trans._animationRaf);
            trans._animationRaf = null;
          }
          function nextFrame() {
            if (trans._currentFrame && trans._currentFrame.onComplete) {
              trans._currentFrame.onComplete();
            }
            var newFrame = trans._currentFrame = trans._frameQueue.shift();
            if (newFrame) {
              var stringName = newFrame.name ? newFrame.name.toString() : null;
              gd._fullLayout._currentFrame = stringName;
              trans._lastFrameAt = Date.now();
              trans._timeToNext = newFrame.frameOpts.duration;
              Plots.transition(
                gd,
                newFrame.frame.data,
                newFrame.frame.layout,
                helpers.coerceTraceIndices(gd, newFrame.frame.traces),
                newFrame.frameOpts,
                newFrame.transitionOpts
              ).then(function() {
                if (newFrame.onComplete) {
                  newFrame.onComplete();
                }
              });
              gd.emit("plotly_animatingframe", {
                name: stringName,
                frame: newFrame.frame,
                animation: {
                  frame: newFrame.frameOpts,
                  transition: newFrame.transitionOpts
                }
              });
            } else {
              stopAnimationLoop();
            }
          }
          function beginAnimationLoop() {
            gd.emit("plotly_animating");
            trans._lastFrameAt = -Infinity;
            trans._timeToNext = 0;
            trans._runningTransitions = 0;
            trans._currentFrame = null;
            var doFrame = function() {
              trans._animationRaf = window.requestAnimationFrame(doFrame);
              if (Date.now() - trans._lastFrameAt > trans._timeToNext) {
                nextFrame();
              }
            };
            doFrame();
          }
          var configCounter = 0;
          function setTransitionConfig(frame2) {
            if (Array.isArray(transitionOpts)) {
              if (configCounter >= transitionOpts.length) {
                frame2.transitionOpts = transitionOpts[configCounter];
              } else {
                frame2.transitionOpts = transitionOpts[0];
              }
            } else {
              frame2.transitionOpts = transitionOpts;
            }
            configCounter++;
            return frame2;
          }
          var i, frame;
          var frameList = [];
          var allFrames = frameOrGroupNameOrFrameList === void 0 || frameOrGroupNameOrFrameList === null;
          var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);
          var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);
          if (isSingleFrame) {
            frameList.push({
              type: "object",
              data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))
            });
          } else if (allFrames || ["string", "number"].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {
            for (i = 0; i < trans._frames.length; i++) {
              frame = trans._frames[i];
              if (!frame) continue;
              if (allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {
                frameList.push({
                  type: "byname",
                  name: String(frame.name),
                  data: setTransitionConfig({ name: frame.name })
                });
              }
            }
          } else if (isFrameArray) {
            for (i = 0; i < frameOrGroupNameOrFrameList.length; i++) {
              var frameOrName = frameOrGroupNameOrFrameList[i];
              if (["number", "string"].indexOf(typeof frameOrName) !== -1) {
                frameOrName = String(frameOrName);
                frameList.push({
                  type: "byname",
                  name: frameOrName,
                  data: setTransitionConfig({ name: frameOrName })
                });
              } else if (Lib.isPlainObject(frameOrName)) {
                frameList.push({
                  type: "object",
                  data: setTransitionConfig(Lib.extendFlat({}, frameOrName))
                });
              }
            }
          }
          for (i = 0; i < frameList.length; i++) {
            frame = frameList[i];
            if (frame.type === "byname" && !trans._frameHash[frame.data.name]) {
              Lib.warn('animate failure: frame not found: "' + frame.data.name + '"');
              reject();
              return;
            }
          }
          if (["next", "immediate"].indexOf(animationOpts.mode) !== -1) {
            discardExistingFrames();
          }
          if (animationOpts.direction === "reverse") {
            frameList.reverse();
          }
          var currentFrame = gd._fullLayout._currentFrame;
          if (currentFrame && animationOpts.fromcurrent) {
            var idx = -1;
            for (i = 0; i < frameList.length; i++) {
              frame = frameList[i];
              if (frame.type === "byname" && frame.name === currentFrame) {
                idx = i;
                break;
              }
            }
            if (idx > 0 && idx < frameList.length - 1) {
              var filteredFrameList = [];
              for (i = 0; i < frameList.length; i++) {
                frame = frameList[i];
                if (frameList[i].type !== "byname" || i > idx) {
                  filteredFrameList.push(frame);
                }
              }
              frameList = filteredFrameList;
            }
          }
          if (frameList.length > 0) {
            queueFrames(frameList);
          } else {
            gd.emit("plotly_animated");
            resolve();
          }
        });
      }
      function addFrames(gd, frameList, indices) {
        gd = Lib.getGraphDiv(gd);
        if (frameList === null || frameList === void 0) {
          return Promise.resolve();
        }
        if (!Lib.isPlotDiv(gd)) {
          throw new Error(
            "This element is not a Plotly plot: " + gd + ". It's likely that you've failed to create a plot before adding frames. For more details, see https://plotly.com/javascript/animations/"
          );
        }
        var i, frame, j, idx;
        var _frames = gd._transitionData._frames;
        var _frameHash = gd._transitionData._frameHash;
        if (!Array.isArray(frameList)) {
          throw new Error("addFrames failure: frameList must be an Array of frame definitions" + frameList);
        }
        var bigIndex = _frames.length + frameList.length * 2;
        var insertions = [];
        var _frameHashLocal = {};
        for (i = frameList.length - 1; i >= 0; i--) {
          if (!Lib.isPlainObject(frameList[i])) continue;
          var lookupName = frameList[i].name;
          var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;
          var newName = frameList[i].name;
          var collisionPresent = _frameHash[name] || _frameHashLocal[name];
          if (name && newName && typeof newName === "number" && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {
            numericNameWarningCount++;
            Lib.warn('addFrames: overwriting frame "' + (_frameHash[name] || _frameHashLocal[name]).name + '" with a frame whose name of type "number" also equates to "' + name + '". This is valid but may potentially lead to unexpected behavior since all plotly.js frame names are stored internally as strings.');
            if (numericNameWarningCount === numericNameWarningCountLimit) {
              Lib.warn("addFrames: This API call has yielded too many of these warnings. For the rest of this call, further warnings about numeric frame names will be suppressed.");
            }
          }
          _frameHashLocal[lookupName] = { name: lookupName };
          insertions.push({
            frame: Plots.supplyFrameDefaults(frameList[i]),
            index: indices && indices[i] !== void 0 && indices[i] !== null ? indices[i] : bigIndex + i
          });
        }
        insertions.sort(function(a, b) {
          if (a.index > b.index) return -1;
          if (a.index < b.index) return 1;
          return 0;
        });
        var ops = [];
        var revops = [];
        var frameCount = _frames.length;
        for (i = insertions.length - 1; i >= 0; i--) {
          frame = insertions[i].frame;
          if (typeof frame.name === "number") {
            Lib.warn("Warning: addFrames accepts frames with numeric names, but the numbers areimplicitly cast to strings");
          }
          if (!frame.name) {
            while (_frameHash[frame.name = "frame " + gd._transitionData._counter++]) ;
          }
          if (_frameHash[frame.name]) {
            for (j = 0; j < _frames.length; j++) {
              if ((_frames[j] || {}).name === frame.name) break;
            }
            ops.push({ type: "replace", index: j, value: frame });
            revops.unshift({ type: "replace", index: j, value: _frames[j] });
          } else {
            idx = Math.max(0, Math.min(insertions[i].index, frameCount));
            ops.push({ type: "insert", index: idx, value: frame });
            revops.unshift({ type: "delete", index: idx });
            frameCount++;
          }
        }
        var undoFunc = Plots.modifyFrames;
        var redoFunc = Plots.modifyFrames;
        var undoArgs = [gd, revops];
        var redoArgs = [gd, ops];
        if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return Plots.modifyFrames(gd, ops);
      }
      function deleteFrames(gd, frameList) {
        gd = Lib.getGraphDiv(gd);
        if (!Lib.isPlotDiv(gd)) {
          throw new Error("This element is not a Plotly plot: " + gd);
        }
        var i, idx;
        var _frames = gd._transitionData._frames;
        var ops = [];
        var revops = [];
        if (!frameList) {
          frameList = [];
          for (i = 0; i < _frames.length; i++) {
            frameList.push(i);
          }
        }
        frameList = frameList.slice();
        frameList.sort();
        for (i = frameList.length - 1; i >= 0; i--) {
          idx = frameList[i];
          ops.push({ type: "delete", index: idx });
          revops.unshift({ type: "insert", index: idx, value: _frames[idx] });
        }
        var undoFunc = Plots.modifyFrames;
        var redoFunc = Plots.modifyFrames;
        var undoArgs = [gd, revops];
        var redoArgs = [gd, ops];
        if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return Plots.modifyFrames(gd, ops);
      }
      function purge(gd) {
        gd = Lib.getGraphDiv(gd);
        var fullLayout = gd._fullLayout || {};
        var fullData = gd._fullData || [];
        Plots.cleanPlot([], {}, fullData, fullLayout);
        Plots.purge(gd);
        Events.purge(gd);
        if (fullLayout._container) fullLayout._container.remove();
        delete gd._context;
        return gd;
      }
      function calcInverseTransform(gd) {
        var fullLayout = gd._fullLayout;
        var newBBox = gd.getBoundingClientRect();
        if (Lib.equalDomRects(newBBox, fullLayout._lastBBox)) return;
        var m = fullLayout._invTransform = Lib.inverseTransformMatrix(Lib.getFullTransformMatrix(gd));
        fullLayout._invScaleX = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);
        fullLayout._invScaleY = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);
        fullLayout._lastBBox = newBBox;
      }
      function makePlotFramework(gd) {
        var gd3 = d3.select(gd);
        var fullLayout = gd._fullLayout;
        fullLayout._calcInverseTransform = calcInverseTransform;
        fullLayout._calcInverseTransform(gd);
        fullLayout._container = gd3.selectAll(".plot-container").data([0]);
        fullLayout._container.enter().insert("div", ":first-child").classed("plot-container", true).classed("plotly", true).style({
          width: "100%",
          height: "100%"
        });
        fullLayout._paperdiv = fullLayout._container.selectAll(".svg-container").data([0]);
        fullLayout._paperdiv.enter().append("div").classed("user-select-none", true).classed("svg-container", true).style("position", "relative");
        fullLayout._glcontainer = fullLayout._paperdiv.selectAll(".gl-container").data([{}]);
        fullLayout._glcontainer.enter().append("div").classed("gl-container", true);
        fullLayout._paperdiv.selectAll(".main-svg").remove();
        fullLayout._paperdiv.select(".modebar-container").remove();
        fullLayout._paper = fullLayout._paperdiv.insert("svg", ":first-child").classed("main-svg", true);
        fullLayout._toppaper = fullLayout._paperdiv.append("svg").classed("main-svg", true);
        fullLayout._modebardiv = fullLayout._paperdiv.append("div");
        delete fullLayout._modeBar;
        fullLayout._hoverpaper = fullLayout._paperdiv.append("svg").classed("main-svg", true);
        if (!fullLayout._uid) {
          var otherUids = {};
          d3.selectAll("defs").each(function() {
            if (this.id) otherUids[this.id.split("-")[1]] = 1;
          });
          fullLayout._uid = Lib.randstr(otherUids);
        }
        fullLayout._paperdiv.selectAll(".main-svg").attr(xmlnsNamespaces.svgAttrs);
        fullLayout._defs = fullLayout._paper.append("defs").attr("id", "defs-" + fullLayout._uid);
        fullLayout._clips = fullLayout._defs.append("g").classed("clips", true);
        fullLayout._topdefs = fullLayout._toppaper.append("defs").attr("id", "topdefs-" + fullLayout._uid);
        fullLayout._topclips = fullLayout._topdefs.append("g").classed("clips", true);
        fullLayout._bgLayer = fullLayout._paper.append("g").classed("bglayer", true);
        fullLayout._draggers = fullLayout._paper.append("g").classed("draglayer", true);
        var layerBelow = fullLayout._paper.append("g").classed("layer-below", true);
        fullLayout._imageLowerLayer = layerBelow.append("g").classed("imagelayer", true);
        fullLayout._shapeLowerLayer = layerBelow.append("g").classed("shapelayer", true);
        fullLayout._cartesianlayer = fullLayout._paper.append("g").classed("cartesianlayer", true);
        fullLayout._polarlayer = fullLayout._paper.append("g").classed("polarlayer", true);
        fullLayout._smithlayer = fullLayout._paper.append("g").classed("smithlayer", true);
        fullLayout._ternarylayer = fullLayout._paper.append("g").classed("ternarylayer", true);
        fullLayout._geolayer = fullLayout._paper.append("g").classed("geolayer", true);
        fullLayout._funnelarealayer = fullLayout._paper.append("g").classed("funnelarealayer", true);
        fullLayout._pielayer = fullLayout._paper.append("g").classed("pielayer", true);
        fullLayout._iciclelayer = fullLayout._paper.append("g").classed("iciclelayer", true);
        fullLayout._treemaplayer = fullLayout._paper.append("g").classed("treemaplayer", true);
        fullLayout._sunburstlayer = fullLayout._paper.append("g").classed("sunburstlayer", true);
        fullLayout._indicatorlayer = fullLayout._toppaper.append("g").classed("indicatorlayer", true);
        fullLayout._glimages = fullLayout._paper.append("g").classed("glimages", true);
        var layerAbove = fullLayout._toppaper.append("g").classed("layer-above", true);
        fullLayout._imageUpperLayer = layerAbove.append("g").classed("imagelayer", true);
        fullLayout._shapeUpperLayer = layerAbove.append("g").classed("shapelayer", true);
        fullLayout._selectionLayer = fullLayout._toppaper.append("g").classed("selectionlayer", true);
        fullLayout._infolayer = fullLayout._toppaper.append("g").classed("infolayer", true);
        fullLayout._menulayer = fullLayout._toppaper.append("g").classed("menulayer", true);
        fullLayout._zoomlayer = fullLayout._toppaper.append("g").classed("zoomlayer", true);
        fullLayout._hoverlayer = fullLayout._hoverpaper.append("g").classed("hoverlayer", true);
        fullLayout._modebardiv.classed("modebar-container", true).style("position", "absolute").style("top", "0px").style("right", "0px");
        gd.emit("plotly_framework");
      }
      exports.animate = animate;
      exports.addFrames = addFrames;
      exports.deleteFrames = deleteFrames;
      exports.addTraces = addTraces;
      exports.deleteTraces = deleteTraces;
      exports.extendTraces = extendTraces;
      exports.moveTraces = moveTraces;
      exports.prependTraces = prependTraces;
      exports.newPlot = newPlot;
      exports._doPlot = _doPlot;
      exports.purge = purge;
      exports.react = react;
      exports.redraw = redraw;
      exports.relayout = relayout;
      exports.restyle = restyle;
      exports.setPlotConfig = setPlotConfig;
      exports.update = update;
      exports._guiRelayout = guiEdit(relayout);
      exports._guiRestyle = guiEdit(restyle);
      exports._guiUpdate = guiEdit(update);
      exports._storeDirectGUIEdit = _storeDirectGUIEdit;
    }
  });

  // src/snapshot/helpers.js
  var require_helpers10 = __commonJS({
    "src/snapshot/helpers.js"(exports) {
      "use strict";
      var Registry = require_registry();
      exports.getDelay = function(fullLayout) {
        if (!fullLayout._has) return 0;
        return fullLayout._has("gl3d") || fullLayout._has("mapbox") || fullLayout._has("map") ? 500 : 0;
      };
      exports.getRedrawFunc = function(gd) {
        return function() {
          Registry.getComponentMethod("colorbar", "draw")(gd);
        };
      };
      exports.encodeSVG = function(svg) {
        return "data:image/svg+xml," + encodeURIComponent(svg);
      };
      exports.encodeJSON = function(json) {
        return "data:application/json," + encodeURIComponent(json);
      };
      var DOM_URL = window.URL || window.webkitURL;
      exports.createObjectURL = function(blob) {
        return DOM_URL.createObjectURL(blob);
      };
      exports.revokeObjectURL = function(url) {
        return DOM_URL.revokeObjectURL(url);
      };
      exports.createBlob = function(url, format) {
        if (format === "svg") {
          return new window.Blob([url], { type: "image/svg+xml;charset=utf-8" });
        } else if (format === "full-json") {
          return new window.Blob([url], { type: "application/json;charset=utf-8" });
        } else {
          var binary = fixBinary(window.atob(url));
          return new window.Blob([binary], { type: "image/" + format });
        }
      };
      exports.octetStream = function(s) {
        document.location.href = "data:application/octet-stream" + s;
      };
      function fixBinary(b) {
        var len = b.length;
        var buf = new ArrayBuffer(len);
        var arr = new Uint8Array(buf);
        for (var i = 0; i < len; i++) {
          arr[i] = b.charCodeAt(i);
        }
        return buf;
      }
      exports.IMAGE_URL_PREFIX = /^data:image\/\w+;base64,/;
    }
  });

  // src/snapshot/tosvg.js
  var require_tosvg = __commonJS({
    "src/snapshot/tosvg.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var Drawing = require_drawing();
      var Color = require_color();
      var xmlnsNamespaces = require_xmlns_namespaces();
      var DOUBLEQUOTE_REGEX = /"/g;
      var DUMMY_SUB = "TOBESTRIPPED";
      var DUMMY_REGEX = new RegExp('("' + DUMMY_SUB + ")|(" + DUMMY_SUB + '")', "g");
      function htmlEntityDecode(s) {
        var hiddenDiv = d3.select("body").append("div").style({ display: "none" }).html("");
        var replaced = s.replace(/(&[^;]*;)/gi, function(d) {
          if (d === "&lt;") {
            return "&#60;";
          }
          if (d === "&rt;") {
            return "&#62;";
          }
          if (d.indexOf("<") !== -1 || d.indexOf(">") !== -1) {
            return "";
          }
          return hiddenDiv.html(d).text();
        });
        hiddenDiv.remove();
        return replaced;
      }
      function xmlEntityEncode(str) {
        return str.replace(/&(?!\w+;|\#[0-9]+;| \#x[0-9A-F]+;)/g, "&amp;");
      }
      module.exports = function toSVG(gd, format, scale) {
        var fullLayout = gd._fullLayout;
        var svg = fullLayout._paper;
        var toppaper = fullLayout._toppaper;
        var width = fullLayout.width;
        var height = fullLayout.height;
        var i;
        svg.insert("rect", ":first-child").call(Drawing.setRect, 0, 0, width, height).call(Color.fill, fullLayout.paper_bgcolor);
        var basePlotModules = fullLayout._basePlotModules || [];
        for (i = 0; i < basePlotModules.length; i++) {
          var _module = basePlotModules[i];
          if (_module.toSVG) _module.toSVG(gd);
        }
        if (toppaper) {
          var nodes = toppaper.node().childNodes;
          var topGroups = Array.prototype.slice.call(nodes);
          for (i = 0; i < topGroups.length; i++) {
            var topGroup = topGroups[i];
            if (topGroup.childNodes.length) svg.node().appendChild(topGroup);
          }
        }
        if (fullLayout._draggers) {
          fullLayout._draggers.remove();
        }
        svg.node().style.background = "";
        svg.selectAll("text").attr({ "data-unformatted": null, "data-math": null }).each(function() {
          var txt = d3.select(this);
          if (this.style.visibility === "hidden" || this.style.display === "none") {
            txt.remove();
            return;
          } else {
            txt.style({ visibility: null, display: null });
          }
          var ff = this.style.fontFamily;
          if (ff && ff.indexOf('"') !== -1) {
            txt.style("font-family", ff.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
          }
          var fw = this.style.fontWeight;
          if (fw && (fw === "normal" || fw === "400")) {
            txt.style("font-weight", void 0);
          }
          var fs = this.style.fontStyle;
          if (fs && fs === "normal") {
            txt.style("font-style", void 0);
          }
          var fv = this.style.fontVariant;
          if (fv && fv === "normal") {
            txt.style("font-variant", void 0);
          }
        });
        svg.selectAll(".gradient_filled,.pattern_filled").each(function() {
          var pt = d3.select(this);
          var fill = this.style.fill;
          if (fill && fill.indexOf("url(") !== -1) {
            pt.style("fill", fill.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
          }
          var stroke = this.style.stroke;
          if (stroke && stroke.indexOf("url(") !== -1) {
            pt.style("stroke", stroke.replace(DOUBLEQUOTE_REGEX, DUMMY_SUB));
          }
        });
        if (format === "pdf" || format === "eps") {
          svg.selectAll("#MathJax_SVG_glyphs path").attr("stroke-width", 0);
        }
        if (format === "svg" && scale) {
          svg.attr("width", scale * width);
          svg.attr("height", scale * height);
          svg.attr("viewBox", "0 0 " + width + " " + height);
        }
        var s = new window.XMLSerializer().serializeToString(svg.node());
        s = htmlEntityDecode(s);
        s = xmlEntityEncode(s);
        s = s.replace(DUMMY_REGEX, "'");
        return s;
      };
    }
  });

  // src/snapshot/svgtoimg.js
  var require_svgtoimg = __commonJS({
    "src/snapshot/svgtoimg.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var EventEmitter = require_events().EventEmitter;
      var helpers = require_helpers10();
      function svgToImg(opts) {
        var ev = opts.emitter || new EventEmitter();
        var promise = new Promise(function(resolve, reject) {
          var Image2 = window.Image;
          var svg = opts.svg;
          var format = opts.format || "png";
          var canvas = opts.canvas;
          var scale = opts.scale || 1;
          var w0 = opts.width || 300;
          var h0 = opts.height || 150;
          var w1 = scale * w0;
          var h1 = scale * h0;
          var ctx = canvas.getContext("2d", { willReadFrequently: true });
          var img = new Image2();
          var svgBlob, url;
          if (format === "svg" || Lib.isSafari()) {
            url = helpers.encodeSVG(svg);
          } else {
            svgBlob = helpers.createBlob(svg, "svg");
            url = helpers.createObjectURL(svgBlob);
          }
          canvas.width = w1;
          canvas.height = h1;
          img.onload = function() {
            var imgData;
            svgBlob = null;
            helpers.revokeObjectURL(url);
            if (format !== "svg") {
              ctx.drawImage(img, 0, 0, w1, h1);
            }
            switch (format) {
              case "jpeg":
                imgData = canvas.toDataURL("image/jpeg");
                break;
              case "png":
                imgData = canvas.toDataURL("image/png");
                break;
              case "webp":
                imgData = canvas.toDataURL("image/webp");
                break;
              case "svg":
                imgData = url;
                break;
              default:
                var errorMsg = "Image format is not jpeg, png, svg or webp.";
                reject(new Error(errorMsg));
                if (!opts.promise) {
                  return ev.emit("error", errorMsg);
                }
            }
            resolve(imgData);
            if (!opts.promise) {
              ev.emit("success", imgData);
            }
          };
          img.onerror = function(err) {
            svgBlob = null;
            helpers.revokeObjectURL(url);
            reject(err);
            if (!opts.promise) {
              return ev.emit("error", err);
            }
          };
          img.src = url;
        });
        if (opts.promise) {
          return promise;
        }
        return ev;
      }
      module.exports = svgToImg;
    }
  });

  // src/plot_api/to_image.js
  var require_to_image = __commonJS({
    "src/plot_api/to_image.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var plotApi = require_plot_api();
      var plots = require_plots();
      var Lib = require_lib();
      var helpers = require_helpers10();
      var toSVG = require_tosvg();
      var svgToImg = require_svgtoimg();
      var version = require_version().version;
      var attrs = {
        format: {
          valType: "enumerated",
          values: ["png", "jpeg", "webp", "svg", "full-json"],
          dflt: "png"
        },
        width: {
          valType: "number",
          min: 1
        },
        height: {
          valType: "number",
          min: 1
        },
        scale: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        setBackground: {
          valType: "any",
          dflt: false
        },
        imageDataOnly: {
          valType: "boolean",
          dflt: false
        }
      };
      function toImage(gd, opts) {
        opts = opts || {};
        var data;
        var layout;
        var config;
        var fullLayout;
        if (Lib.isPlainObject(gd)) {
          data = gd.data || [];
          layout = gd.layout || {};
          config = gd.config || {};
          fullLayout = {};
        } else {
          gd = Lib.getGraphDiv(gd);
          data = Lib.extendDeep([], gd.data);
          layout = Lib.extendDeep({}, gd.layout);
          config = gd._context;
          fullLayout = gd._fullLayout || {};
        }
        function isImpliedOrValid(attr) {
          return !(attr in opts) || Lib.validate(opts[attr], attrs[attr]);
        }
        if (!isImpliedOrValid("width") && opts.width !== null || !isImpliedOrValid("height") && opts.height !== null) {
          throw new Error("Height and width should be pixel values.");
        }
        if (!isImpliedOrValid("format")) {
          throw new Error("Export format is not " + Lib.join2(attrs.format.values, ", ", " or ") + ".");
        }
        var fullOpts = {};
        function coerce(attr, dflt) {
          return Lib.coerce(opts, fullOpts, attrs, attr, dflt);
        }
        var format = coerce("format");
        var width = coerce("width");
        var height = coerce("height");
        var scale = coerce("scale");
        var setBackground = coerce("setBackground");
        var imageDataOnly = coerce("imageDataOnly");
        var clonedGd = document.createElement("div");
        clonedGd.style.position = "absolute";
        clonedGd.style.left = "-5000px";
        document.body.appendChild(clonedGd);
        var layoutImage = Lib.extendFlat({}, layout);
        if (width) {
          layoutImage.width = width;
        } else if (opts.width === null && isNumeric(fullLayout.width)) {
          layoutImage.width = fullLayout.width;
        }
        if (height) {
          layoutImage.height = height;
        } else if (opts.height === null && isNumeric(fullLayout.height)) {
          layoutImage.height = fullLayout.height;
        }
        var configImage = Lib.extendFlat({}, config, {
          _exportedPlot: true,
          staticPlot: true,
          setBackground
        });
        var redrawFunc = helpers.getRedrawFunc(clonedGd);
        function wait() {
          return new Promise(function(resolve) {
            setTimeout(resolve, helpers.getDelay(clonedGd._fullLayout));
          });
        }
        function convert() {
          return new Promise(function(resolve, reject) {
            var svg = toSVG(clonedGd, format, scale);
            var width2 = clonedGd._fullLayout.width;
            var height2 = clonedGd._fullLayout.height;
            function cleanup() {
              plotApi.purge(clonedGd);
              document.body.removeChild(clonedGd);
            }
            if (format === "full-json") {
              var json = plots.graphJson(clonedGd, false, "keepdata", "object", true, true);
              json.version = version;
              json = JSON.stringify(json);
              cleanup();
              if (imageDataOnly) {
                return resolve(json);
              } else {
                return resolve(helpers.encodeJSON(json));
              }
            }
            cleanup();
            if (format === "svg") {
              if (imageDataOnly) {
                return resolve(svg);
              } else {
                return resolve(helpers.encodeSVG(svg));
              }
            }
            var canvas = document.createElement("canvas");
            canvas.id = Lib.randstr();
            svgToImg({
              format,
              width: width2,
              height: height2,
              scale,
              canvas,
              svg,
              // ask svgToImg to return a Promise
              //  rather than EventEmitter
              //  leave EventEmitter for backward
              //  compatibility
              promise: true
            }).then(resolve).catch(reject);
          });
        }
        function urlToImageData(url) {
          if (imageDataOnly) {
            return url.replace(helpers.IMAGE_URL_PREFIX, "");
          } else {
            return url;
          }
        }
        return new Promise(function(resolve, reject) {
          plotApi.newPlot(clonedGd, data, layoutImage, configImage).then(redrawFunc).then(wait).then(convert).then(function(url) {
            resolve(urlToImageData(url));
          }).catch(function(err) {
            reject(err);
          });
        });
      }
      module.exports = toImage;
    }
  });

  // src/plot_api/validate.js
  var require_validate = __commonJS({
    "src/plot_api/validate.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Plots = require_plots();
      var PlotSchema = require_plot_schema();
      var dfltConfig = require_plot_config().dfltConfig;
      var isPlainObject = Lib.isPlainObject;
      var isArray = Array.isArray;
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      module.exports = function validate(data, layout) {
        if (data === void 0) data = [];
        if (layout === void 0) layout = {};
        var schema = PlotSchema.get();
        var errorList = [];
        var gd = { _context: Lib.extendFlat({}, dfltConfig) };
        var dataIn, layoutIn;
        if (isArray(data)) {
          gd.data = Lib.extendDeep([], data);
          dataIn = data;
        } else {
          gd.data = [];
          dataIn = [];
          errorList.push(format("array", "data"));
        }
        if (isPlainObject(layout)) {
          gd.layout = Lib.extendDeep({}, layout);
          layoutIn = layout;
        } else {
          gd.layout = {};
          layoutIn = {};
          if (arguments.length > 1) {
            errorList.push(format("object", "layout"));
          }
        }
        Plots.supplyDefaults(gd);
        var dataOut = gd._fullData;
        var len = dataIn.length;
        for (var i = 0; i < len; i++) {
          var traceIn = dataIn[i];
          var base = ["data", i];
          if (!isPlainObject(traceIn)) {
            errorList.push(format("object", base));
            continue;
          }
          var traceOut = dataOut[i];
          var traceType = traceOut.type;
          var traceSchema = schema.traces[traceType].attributes;
          traceSchema.type = {
            valType: "enumerated",
            values: [traceType]
          };
          if (traceOut.visible === false && traceIn.visible !== false) {
            errorList.push(format("invisible", base));
          }
          crawl(traceIn, traceOut, traceSchema, errorList, base);
        }
        var layoutOut = gd._fullLayout;
        var layoutSchema = fillLayoutSchema(schema, dataOut);
        crawl(layoutIn, layoutOut, layoutSchema, errorList, "layout");
        return errorList.length === 0 ? void 0 : errorList;
      };
      function crawl(objIn, objOut, schema, list, base, path) {
        path = path || [];
        var keys = Object.keys(objIn);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var p = path.slice();
          p.push(k);
          var valIn = objIn[k];
          var valOut = objOut[k];
          var nestedSchema = getNestedSchema(schema, k);
          var nestedValType = (nestedSchema || {}).valType;
          var isInfoArray = nestedValType === "info_array";
          var isColorscale = nestedValType === "colorscale";
          var items = (nestedSchema || {}).items;
          if (!isInSchema(schema, k)) {
            list.push(format("schema", base, p));
          } else if (isPlainObject(valIn) && isPlainObject(valOut) && nestedValType !== "any") {
            crawl(valIn, valOut, nestedSchema, list, base, p);
          } else if (isInfoArray && isArray(valIn)) {
            if (valIn.length > valOut.length) {
              list.push(format("unused", base, p.concat(valOut.length)));
            }
            var len = valOut.length;
            var arrayItems = Array.isArray(items);
            if (arrayItems) len = Math.min(len, items.length);
            var m, n, item, valInPart, valOutPart;
            if (nestedSchema.dimensions === 2) {
              for (n = 0; n < len; n++) {
                if (isArray(valIn[n])) {
                  if (valIn[n].length > valOut[n].length) {
                    list.push(format("unused", base, p.concat(n, valOut[n].length)));
                  }
                  var len2 = valOut[n].length;
                  for (m = 0; m < (arrayItems ? Math.min(len2, items[n].length) : len2); m++) {
                    item = arrayItems ? items[n][m] : items;
                    valInPart = valIn[n][m];
                    valOutPart = valOut[n][m];
                    if (!Lib.validate(valInPart, item)) {
                      list.push(format("value", base, p.concat(n, m), valInPart));
                    } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {
                      list.push(format("dynamic", base, p.concat(n, m), valInPart, valOutPart));
                    }
                  }
                } else {
                  list.push(format("array", base, p.concat(n), valIn[n]));
                }
              }
            } else {
              for (n = 0; n < len; n++) {
                item = arrayItems ? items[n] : items;
                valInPart = valIn[n];
                valOutPart = valOut[n];
                if (!Lib.validate(valInPart, item)) {
                  list.push(format("value", base, p.concat(n), valInPart));
                } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {
                  list.push(format("dynamic", base, p.concat(n), valInPart, valOutPart));
                }
              }
            }
          } else if (nestedSchema.items && !isInfoArray && isArray(valIn)) {
            var _nestedSchema = items[Object.keys(items)[0]];
            var indexList = [];
            var j, _p;
            for (j = 0; j < valOut.length; j++) {
              var _index = valOut[j]._index || j;
              _p = p.slice();
              _p.push(_index);
              if (isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {
                indexList.push(_index);
                var valInj = valIn[_index];
                var valOutj = valOut[j];
                if (isPlainObject(valInj) && valInj.visible !== false && valOutj.visible === false) {
                  list.push(format("invisible", base, _p));
                } else crawl(valInj, valOutj, _nestedSchema, list, base, _p);
              }
            }
            for (j = 0; j < valIn.length; j++) {
              _p = p.slice();
              _p.push(j);
              if (!isPlainObject(valIn[j])) {
                list.push(format("object", base, _p, valIn[j]));
              } else if (indexList.indexOf(j) === -1) {
                list.push(format("unused", base, _p));
              }
            }
          } else if (!isPlainObject(valIn) && isPlainObject(valOut)) {
            list.push(format("object", base, p, valIn));
          } else if (!isArrayOrTypedArray(valIn) && isArrayOrTypedArray(valOut) && !isInfoArray && !isColorscale) {
            list.push(format("array", base, p, valIn));
          } else if (!(k in objOut)) {
            list.push(format("unused", base, p, valIn));
          } else if (!Lib.validate(valIn, nestedSchema)) {
            list.push(format("value", base, p, valIn));
          } else if (nestedSchema.valType === "enumerated" && (nestedSchema.coerceNumber && valIn !== +valOut || valIn !== valOut)) {
            list.push(format("dynamic", base, p, valIn, valOut));
          }
        }
        return list;
      }
      function fillLayoutSchema(schema, dataOut) {
        var layoutSchema = schema.layout.layoutAttributes;
        for (var i = 0; i < dataOut.length; i++) {
          var traceOut = dataOut[i];
          var traceSchema = schema.traces[traceOut.type];
          var traceLayoutAttr = traceSchema.layoutAttributes;
          if (traceLayoutAttr) {
            if (traceOut.subplot) {
              Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt], traceLayoutAttr);
            } else {
              Lib.extendFlat(layoutSchema, traceLayoutAttr);
            }
          }
        }
        return layoutSchema;
      }
      var code2msgFunc = {
        object: function(base, astr) {
          var prefix;
          if (base === "layout" && astr === "") prefix = "The layout argument";
          else if (base[0] === "data" && astr === "") {
            prefix = "Trace " + base[1] + " in the data argument";
          } else prefix = inBase(base) + "key " + astr;
          return prefix + " must be linked to an object container";
        },
        array: function(base, astr) {
          var prefix;
          if (base === "data") prefix = "The data argument";
          else prefix = inBase(base) + "key " + astr;
          return prefix + " must be linked to an array container";
        },
        schema: function(base, astr) {
          return inBase(base) + "key " + astr + " is not part of the schema";
        },
        unused: function(base, astr, valIn) {
          var target = isPlainObject(valIn) ? "container" : "key";
          return inBase(base) + target + " " + astr + " did not get coerced";
        },
        dynamic: function(base, astr, valIn, valOut) {
          return [
            inBase(base) + "key",
            astr,
            "(set to '" + valIn + "')",
            "got reset to",
            "'" + valOut + "'",
            "during defaults."
          ].join(" ");
        },
        invisible: function(base, astr) {
          return (astr ? inBase(base) + "item " + astr : "Trace " + base[1]) + " got defaulted to be not visible";
        },
        value: function(base, astr, valIn) {
          return [
            inBase(base) + "key " + astr,
            "is set to an invalid value (" + valIn + ")"
          ].join(" ");
        }
      };
      function inBase(base) {
        if (isArray(base)) return "In data trace " + base[1] + ", ";
        return "In " + base + ", ";
      }
      function format(code, base, path, valIn, valOut) {
        path = path || "";
        var container, trace;
        if (isArray(base)) {
          container = base[0];
          trace = base[1];
        } else {
          container = base;
          trace = null;
        }
        var astr = convertPathToAttributeString(path);
        var msg = code2msgFunc[code](base, astr, valIn, valOut);
        Lib.log(msg);
        return {
          code,
          container,
          trace,
          path,
          astr,
          msg
        };
      }
      function isInSchema(schema, key) {
        var parts = splitKey(key);
        var keyMinusId = parts.keyMinusId;
        var id = parts.id;
        if (keyMinusId in schema && schema[keyMinusId]._isSubplotObj && id) {
          return true;
        }
        return key in schema;
      }
      function getNestedSchema(schema, key) {
        if (key in schema) return schema[key];
        var parts = splitKey(key);
        return schema[parts.keyMinusId];
      }
      var idRegex = Lib.counterRegex("([a-z]+)");
      function splitKey(key) {
        var idMatch = key.match(idRegex);
        return {
          keyMinusId: idMatch && idMatch[1],
          id: idMatch && idMatch[2]
        };
      }
      function convertPathToAttributeString(path) {
        if (!isArray(path)) return String(path);
        var astr = "";
        for (var i = 0; i < path.length; i++) {
          var p = path[i];
          if (typeof p === "number") {
            astr = astr.substr(0, astr.length - 1) + "[" + p + "]";
          } else {
            astr += p;
          }
          if (i < path.length - 1) astr += ".";
        }
        return astr;
      }
    }
  });

  // src/snapshot/filesaver.js
  var require_filesaver = __commonJS({
    "src/snapshot/filesaver.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var helpers = require_helpers10();
      function fileSaver(url, name, format) {
        var saveLink = document.createElement("a");
        var canUseSaveLink = "download" in saveLink;
        var promise = new Promise(function(resolve, reject) {
          var blob;
          var objectUrl;
          if (canUseSaveLink) {
            blob = helpers.createBlob(url, format);
            objectUrl = helpers.createObjectURL(blob);
            saveLink.href = objectUrl;
            saveLink.download = name;
            document.body.appendChild(saveLink);
            saveLink.click();
            document.body.removeChild(saveLink);
            helpers.revokeObjectURL(objectUrl);
            blob = null;
            return resolve(name);
          }
          if (Lib.isSafari()) {
            var prefix = format === "svg" ? "," : ";base64,";
            helpers.octetStream(prefix + encodeURIComponent(url));
            return resolve(name);
          }
          reject(new Error("download error"));
        });
        return promise;
      }
      module.exports = fileSaver;
    }
  });

  // src/snapshot/download.js
  var require_download = __commonJS({
    "src/snapshot/download.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var toImage = require_to_image();
      var fileSaver = require_filesaver();
      var helpers = require_helpers10();
      function downloadImage(gd, opts) {
        var _gd;
        if (!Lib.isPlainObject(gd)) _gd = Lib.getGraphDiv(gd);
        opts = opts || {};
        opts.format = opts.format || "png";
        opts.width = opts.width || null;
        opts.height = opts.height || null;
        opts.imageDataOnly = true;
        return new Promise(function(resolve, reject) {
          if (_gd && _gd._snapshotInProgress) {
            reject(new Error("Snapshotting already in progress."));
          }
          if (_gd) _gd._snapshotInProgress = true;
          var promise = toImage(gd, opts);
          var filename = opts.filename || gd.fn || "newplot";
          filename += "." + opts.format.replace("-", ".");
          promise.then(function(result) {
            if (_gd) _gd._snapshotInProgress = false;
            return fileSaver(result, filename, opts.format);
          }).then(function(name) {
            resolve(name);
          }).catch(function(err) {
            if (_gd) _gd._snapshotInProgress = false;
            reject(err);
          });
        });
      }
      module.exports = downloadImage;
    }
  });

  // src/plot_api/template_api.js
  var require_template_api = __commonJS({
    "src/plot_api/template_api.js"(exports) {
      "use strict";
      var Lib = require_lib();
      var isPlainObject = Lib.isPlainObject;
      var PlotSchema = require_plot_schema();
      var Plots = require_plots();
      var plotAttributes = require_attributes2();
      var Template = require_plot_template();
      var dfltConfig = require_plot_config().dfltConfig;
      exports.makeTemplate = function(figure) {
        figure = Lib.isPlainObject(figure) ? figure : Lib.getGraphDiv(figure);
        figure = Lib.extendDeep({ _context: dfltConfig }, { data: figure.data, layout: figure.layout });
        Plots.supplyDefaults(figure);
        var data = figure.data || [];
        var layout = figure.layout || {};
        layout._basePlotModules = figure._fullLayout._basePlotModules;
        layout._modules = figure._fullLayout._modules;
        var template = {
          data: {},
          layout: {}
        };
        data.forEach(function(trace) {
          var traceTemplate = {};
          walkStyleKeys(trace, traceTemplate, getTraceInfo.bind(null, trace));
          var traceType2 = Lib.coerce(trace, {}, plotAttributes, "type");
          var typeTemplates2 = template.data[traceType2];
          if (!typeTemplates2) typeTemplates2 = template.data[traceType2] = [];
          typeTemplates2.push(traceTemplate);
        });
        walkStyleKeys(layout, template.layout, getLayoutInfo.bind(null, layout));
        delete template.layout.template;
        var oldTemplate = layout.template;
        if (isPlainObject(oldTemplate)) {
          var oldLayoutTemplate = oldTemplate.layout;
          var i, traceType, oldTypeTemplates, oldTypeLen, typeTemplates, typeLen;
          if (isPlainObject(oldLayoutTemplate)) {
            mergeTemplates(oldLayoutTemplate, template.layout);
          }
          var oldDataTemplate = oldTemplate.data;
          if (isPlainObject(oldDataTemplate)) {
            for (traceType in template.data) {
              oldTypeTemplates = oldDataTemplate[traceType];
              if (Array.isArray(oldTypeTemplates)) {
                typeTemplates = template.data[traceType];
                typeLen = typeTemplates.length;
                oldTypeLen = oldTypeTemplates.length;
                for (i = 0; i < typeLen; i++) {
                  mergeTemplates(oldTypeTemplates[i % oldTypeLen], typeTemplates[i]);
                }
                for (i = typeLen; i < oldTypeLen; i++) {
                  typeTemplates.push(Lib.extendDeep({}, oldTypeTemplates[i]));
                }
              }
            }
            for (traceType in oldDataTemplate) {
              if (!(traceType in template.data)) {
                template.data[traceType] = Lib.extendDeep([], oldDataTemplate[traceType]);
              }
            }
          }
        }
        return template;
      };
      function mergeTemplates(oldTemplate, newTemplate) {
        oldTemplate = Lib.extendDeep({}, oldTemplate);
        var oldKeys = Object.keys(oldTemplate).sort();
        var i, j;
        function mergeOne(oldVal2, newVal, key3) {
          if (isPlainObject(newVal) && isPlainObject(oldVal2)) {
            mergeTemplates(oldVal2, newVal);
          } else if (Array.isArray(newVal) && Array.isArray(oldVal2)) {
            var templater = Template.arrayTemplater({ _template: oldTemplate }, key3);
            for (j = 0; j < newVal.length; j++) {
              var item = newVal[j];
              var oldItem = templater.newItem(item)._template;
              if (oldItem) mergeTemplates(oldItem, item);
            }
            var defaultItems = templater.defaultItems();
            for (j = 0; j < defaultItems.length; j++) newVal.push(defaultItems[j]._template);
            for (j = 0; j < newVal.length; j++) delete newVal[j].templateitemname;
          }
        }
        for (i = 0; i < oldKeys.length; i++) {
          var key = oldKeys[i];
          var oldVal = oldTemplate[key];
          if (key in newTemplate) {
            mergeOne(oldVal, newTemplate[key], key);
          } else newTemplate[key] = oldVal;
          if (getBaseKey(key) === key) {
            for (var key2 in newTemplate) {
              var baseKey2 = getBaseKey(key2);
              if (key2 !== baseKey2 && baseKey2 === key && !(key2 in oldTemplate)) {
                mergeOne(oldVal, newTemplate[key2], key);
              }
            }
          }
        }
      }
      function getBaseKey(key) {
        return key.replace(/[0-9]+$/, "");
      }
      function walkStyleKeys(parent, templateOut, getAttributeInfo, path, basePath) {
        var pathAttr = basePath && getAttributeInfo(basePath);
        for (var key in parent) {
          var child = parent[key];
          var nextPath = getNextPath(parent, key, path);
          var nextBasePath = getNextPath(parent, key, basePath);
          var attr = getAttributeInfo(nextBasePath);
          if (!attr) {
            var baseKey = getBaseKey(key);
            if (baseKey !== key) {
              nextBasePath = getNextPath(parent, baseKey, basePath);
              attr = getAttributeInfo(nextBasePath);
            }
          }
          if (pathAttr && pathAttr === attr) continue;
          if (!attr || attr._noTemplating || attr.valType === "data_array" || attr.arrayOk && Array.isArray(child)) {
            continue;
          }
          if (!attr.valType && isPlainObject(child)) {
            walkStyleKeys(child, templateOut, getAttributeInfo, nextPath, nextBasePath);
          } else if (attr._isLinkedToArray && Array.isArray(child)) {
            var dfltDone = false;
            var namedIndex = 0;
            var usedNames = {};
            for (var i = 0; i < child.length; i++) {
              var item = child[i];
              if (isPlainObject(item)) {
                var name = item.name;
                if (name) {
                  if (!usedNames[name]) {
                    walkStyleKeys(
                      item,
                      templateOut,
                      getAttributeInfo,
                      getNextPath(child, namedIndex, nextPath),
                      getNextPath(child, namedIndex, nextBasePath)
                    );
                    namedIndex++;
                    usedNames[name] = 1;
                  }
                } else if (!dfltDone) {
                  var dfltKey = Template.arrayDefaultKey(key);
                  var dfltPath = getNextPath(parent, dfltKey, path);
                  var pathInArray = getNextPath(child, namedIndex, nextPath);
                  walkStyleKeys(
                    item,
                    templateOut,
                    getAttributeInfo,
                    pathInArray,
                    getNextPath(child, namedIndex, nextBasePath)
                  );
                  var itemPropInArray = Lib.nestedProperty(templateOut, pathInArray);
                  var dfltProp = Lib.nestedProperty(templateOut, dfltPath);
                  dfltProp.set(itemPropInArray.get());
                  itemPropInArray.set(null);
                  dfltDone = true;
                }
              }
            }
          } else {
            var templateProp = Lib.nestedProperty(templateOut, nextPath);
            templateProp.set(child);
          }
        }
      }
      function getLayoutInfo(layout, path) {
        return PlotSchema.getLayoutValObject(
          layout,
          Lib.nestedProperty({}, path).parts
        );
      }
      function getTraceInfo(trace, path) {
        return PlotSchema.getTraceValObject(
          trace,
          Lib.nestedProperty({}, path).parts
        );
      }
      function getNextPath(parent, key, path) {
        var nextPath;
        if (!path) nextPath = key;
        else if (Array.isArray(parent)) nextPath = path + "[" + key + "]";
        else nextPath = path + "." + key;
        return nextPath;
      }
      exports.validateTemplate = function(figureIn, template) {
        var figure = Lib.extendDeep({}, {
          _context: dfltConfig,
          data: figureIn.data,
          layout: figureIn.layout
        });
        var layout = figure.layout || {};
        if (!isPlainObject(template)) template = layout.template || {};
        var layoutTemplate = template.layout;
        var dataTemplate = template.data;
        var errorList = [];
        figure.layout = layout;
        figure.layout.template = template;
        Plots.supplyDefaults(figure);
        var fullLayout = figure._fullLayout;
        var fullData = figure._fullData;
        var layoutPaths = {};
        function crawlLayoutForContainers(obj, paths) {
          for (var key in obj) {
            if (key.charAt(0) !== "_" && isPlainObject(obj[key])) {
              var baseKey = getBaseKey(key);
              var nextPaths = [];
              var i2;
              for (i2 = 0; i2 < paths.length; i2++) {
                nextPaths.push(getNextPath(obj, key, paths[i2]));
                if (baseKey !== key) nextPaths.push(getNextPath(obj, baseKey, paths[i2]));
              }
              for (i2 = 0; i2 < nextPaths.length; i2++) {
                layoutPaths[nextPaths[i2]] = 1;
              }
              crawlLayoutForContainers(obj[key], nextPaths);
            }
          }
        }
        function crawlLayoutTemplateForContainers(obj, path) {
          for (var key in obj) {
            if (key.indexOf("defaults") === -1 && isPlainObject(obj[key])) {
              var nextPath = getNextPath(obj, key, path);
              if (layoutPaths[nextPath]) {
                crawlLayoutTemplateForContainers(obj[key], nextPath);
              } else {
                errorList.push({ code: "unused", path: nextPath });
              }
            }
          }
        }
        if (!isPlainObject(layoutTemplate)) {
          errorList.push({ code: "layout" });
        } else {
          crawlLayoutForContainers(fullLayout, ["layout"]);
          crawlLayoutTemplateForContainers(layoutTemplate, "layout");
        }
        if (!isPlainObject(dataTemplate)) {
          errorList.push({ code: "data" });
        } else {
          var typeCount = {};
          var traceType;
          for (var i = 0; i < fullData.length; i++) {
            var fullTrace = fullData[i];
            traceType = fullTrace.type;
            typeCount[traceType] = (typeCount[traceType] || 0) + 1;
            if (!fullTrace._fullInput._template) {
              errorList.push({
                code: "missing",
                index: fullTrace.index,
                traceType
              });
            }
          }
          for (traceType in dataTemplate) {
            var templateCount = dataTemplate[traceType].length;
            var dataCount = typeCount[traceType] || 0;
            if (templateCount > dataCount) {
              errorList.push({
                code: "unused",
                traceType,
                templateCount,
                dataCount
              });
            } else if (dataCount > templateCount) {
              errorList.push({
                code: "reused",
                traceType,
                templateCount,
                dataCount
              });
            }
          }
        }
        function crawlForMissingTemplates(obj, path) {
          for (var key in obj) {
            if (key.charAt(0) === "_") continue;
            var val = obj[key];
            var nextPath = getNextPath(obj, key, path);
            if (isPlainObject(val)) {
              if (Array.isArray(obj) && val._template === false && val.templateitemname) {
                errorList.push({
                  code: "missing",
                  path: nextPath,
                  templateitemname: val.templateitemname
                });
              }
              crawlForMissingTemplates(val, nextPath);
            } else if (Array.isArray(val) && hasPlainObject(val)) {
              crawlForMissingTemplates(val, nextPath);
            }
          }
        }
        crawlForMissingTemplates({ data: fullData, layout: fullLayout }, "");
        if (errorList.length) return errorList.map(format);
      };
      function hasPlainObject(arr) {
        for (var i = 0; i < arr.length; i++) {
          if (isPlainObject(arr[i])) return true;
        }
      }
      function format(opts) {
        var msg;
        switch (opts.code) {
          case "data":
            msg = "The template has no key data.";
            break;
          case "layout":
            msg = "The template has no key layout.";
            break;
          case "missing":
            if (opts.path) {
              msg = "There are no templates for item " + opts.path + " with name " + opts.templateitemname;
            } else {
              msg = "There are no templates for trace " + opts.index + ", of type " + opts.traceType + ".";
            }
            break;
          case "unused":
            if (opts.path) {
              msg = "The template item at " + opts.path + " was not used in constructing the plot.";
            } else if (opts.dataCount) {
              msg = "Some of the templates of type " + opts.traceType + " were not used. The template has " + opts.templateCount + " traces, the data only has " + opts.dataCount + " of this type.";
            } else {
              msg = "The template has " + opts.templateCount + " traces of type " + opts.traceType + " but there are none in the data.";
            }
            break;
          case "reused":
            msg = "Some of the templates of type " + opts.traceType + " were used more than once. The template has " + opts.templateCount + " traces, the data has " + opts.dataCount + " of this type.";
            break;
        }
        opts.msg = msg;
        return opts;
      }
    }
  });

  // src/plot_api/index.js
  var require_plot_api2 = __commonJS({
    "src/plot_api/index.js"(exports) {
      "use strict";
      var main = require_plot_api();
      exports._doPlot = main._doPlot;
      exports.newPlot = main.newPlot;
      exports.restyle = main.restyle;
      exports.relayout = main.relayout;
      exports.redraw = main.redraw;
      exports.update = main.update;
      exports._guiRestyle = main._guiRestyle;
      exports._guiRelayout = main._guiRelayout;
      exports._guiUpdate = main._guiUpdate;
      exports._storeDirectGUIEdit = main._storeDirectGUIEdit;
      exports.react = main.react;
      exports.extendTraces = main.extendTraces;
      exports.prependTraces = main.prependTraces;
      exports.addTraces = main.addTraces;
      exports.deleteTraces = main.deleteTraces;
      exports.moveTraces = main.moveTraces;
      exports.purge = main.purge;
      exports.addFrames = main.addFrames;
      exports.deleteFrames = main.deleteFrames;
      exports.animate = main.animate;
      exports.setPlotConfig = main.setPlotConfig;
      var getGraphDiv = require_dom().getGraphDiv;
      var eraseActiveShape = require_draw2().eraseActiveShape;
      exports.deleteActiveShape = function(gd) {
        return eraseActiveShape(getGraphDiv(gd));
      };
      exports.toImage = require_to_image();
      exports.validate = require_validate();
      exports.downloadImage = require_download();
      var templateApi = require_template_api();
      exports.makeTemplate = templateApi.makeTemplate;
      exports.validateTemplate = templateApi.validateTemplate;
    }
  });

  // src/traces/scatter/xy_defaults.js
  var require_xy_defaults = __commonJS({
    "src/traces/scatter/xy_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      module.exports = function handleXYDefaults(traceIn, traceOut, layout, coerce) {
        var x = coerce("x");
        var y = coerce("y");
        var len;
        var handleCalendarDefaults = Registry.getComponentMethod("calendars", "handleTraceDefaults");
        handleCalendarDefaults(traceIn, traceOut, ["x", "y"], layout);
        if (x) {
          var xlen = Lib.minRowLength(x);
          if (y) {
            len = Math.min(xlen, Lib.minRowLength(y));
          } else {
            len = xlen;
            coerce("y0");
            coerce("dy");
          }
        } else {
          if (!y) return 0;
          len = Lib.minRowLength(y);
          coerce("x0");
          coerce("dx");
        }
        traceOut._length = len;
        return len;
      };
    }
  });

  // src/traces/scatter/period_defaults.js
  var require_period_defaults = __commonJS({
    "src/traces/scatter/period_defaults.js"(exports, module) {
      "use strict";
      var dateTick0 = require_lib().dateTick0;
      var numConstants = require_numerical();
      var ONEWEEK = numConstants.ONEWEEK;
      function getPeriod0Dflt(period, calendar) {
        if (period % ONEWEEK === 0) {
          return dateTick0(calendar, 1);
        }
        return dateTick0(calendar, 0);
      }
      module.exports = function handlePeriodDefaults(traceIn, traceOut, layout, coerce, opts) {
        if (!opts) {
          opts = {
            x: true,
            y: true
          };
        }
        if (opts.x) {
          var xperiod = coerce("xperiod");
          if (xperiod) {
            coerce("xperiod0", getPeriod0Dflt(xperiod, traceOut.xcalendar));
            coerce("xperiodalignment");
          }
        }
        if (opts.y) {
          var yperiod = coerce("yperiod");
          if (yperiod) {
            coerce("yperiod0", getPeriod0Dflt(yperiod, traceOut.ycalendar));
            coerce("yperiodalignment");
          }
        }
      };
    }
  });

  // src/traces/scatter/stack_defaults.js
  var require_stack_defaults = __commonJS({
    "src/traces/scatter/stack_defaults.js"(exports, module) {
      "use strict";
      var perStackAttrs = ["orientation", "groupnorm", "stackgaps"];
      module.exports = function handleStackDefaults(traceIn, traceOut, layout, coerce) {
        var stackOpts = layout._scatterStackOpts;
        var stackGroup = coerce("stackgroup");
        if (stackGroup) {
          var subplot = traceOut.xaxis + traceOut.yaxis;
          var subplotStackOpts = stackOpts[subplot];
          if (!subplotStackOpts) subplotStackOpts = stackOpts[subplot] = {};
          var groupOpts = subplotStackOpts[stackGroup];
          var firstTrace = false;
          if (groupOpts) {
            groupOpts.traces.push(traceOut);
          } else {
            groupOpts = subplotStackOpts[stackGroup] = {
              // keep track of trace indices for use during stacking calculations
              // this will be filled in during `calc` and used during `crossTraceCalc`
              // so it's OK if we don't recreate it during a non-calc edit
              traceIndices: [],
              // Hold on to the whole set of prior traces
              // First one is most important, so we can clear defaults
              // there if we find explicit values only in later traces.
              // We're only going to *use* the values stored in groupOpts,
              // but for the editor and validate we want things self-consistent
              // The full set of traces is used only to fix `fill` default if
              // we find `orientation: 'h'` beyond the first trace
              traces: [traceOut]
            };
            firstTrace = true;
          }
          var dflts = {
            orientation: traceOut.x && !traceOut.y ? "h" : "v"
          };
          for (var i = 0; i < perStackAttrs.length; i++) {
            var attr = perStackAttrs[i];
            var attrFound = attr + "Found";
            if (!groupOpts[attrFound]) {
              var traceHasAttr = traceIn[attr] !== void 0;
              var isOrientation = attr === "orientation";
              if (traceHasAttr || firstTrace) {
                groupOpts[attr] = coerce(attr, dflts[attr]);
                if (isOrientation) {
                  groupOpts.fillDflt = groupOpts[attr] === "h" ? "tonextx" : "tonexty";
                }
                if (traceHasAttr) {
                  groupOpts[attrFound] = true;
                  if (!firstTrace) {
                    delete groupOpts.traces[0][attr];
                    if (isOrientation) {
                      for (var j = 0; j < groupOpts.traces.length - 1; j++) {
                        var trace2 = groupOpts.traces[j];
                        if (trace2._input.fill !== trace2.fill) {
                          trace2.fill = groupOpts.fillDflt;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          return groupOpts;
        }
      };
    }
  });

  // src/traces/scatter/marker_defaults.js
  var require_marker_defaults = __commonJS({
    "src/traces/scatter/marker_defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var hasColorscale = require_helpers().hasColorscale;
      var colorscaleDefaults = require_defaults2();
      var subTypes = require_subtypes();
      module.exports = function markerDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {
        var isBubble = subTypes.isBubble(traceIn);
        var lineColor = (traceIn.line || {}).color;
        var defaultMLC;
        opts = opts || {};
        if (lineColor) defaultColor = lineColor;
        coerce("marker.symbol");
        coerce("marker.opacity", isBubble ? 0.7 : 1);
        coerce("marker.size");
        if (!opts.noAngle) {
          coerce("marker.angle");
          if (!opts.noAngleRef) {
            coerce("marker.angleref");
          }
          if (!opts.noStandOff) {
            coerce("marker.standoff");
          }
        }
        coerce("marker.color", defaultColor);
        if (hasColorscale(traceIn, "marker")) {
          colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "marker.", cLetter: "c" });
        }
        if (!opts.noSelect) {
          coerce("selected.marker.color");
          coerce("unselected.marker.color");
          coerce("selected.marker.size");
          coerce("unselected.marker.size");
        }
        if (!opts.noLine) {
          if (lineColor && !Array.isArray(lineColor) && traceOut.marker.color !== lineColor) {
            defaultMLC = lineColor;
          } else if (isBubble) defaultMLC = Color.background;
          else defaultMLC = Color.defaultLine;
          coerce("marker.line.color", defaultMLC);
          if (hasColorscale(traceIn, "marker.line")) {
            colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "marker.line.", cLetter: "c" });
          }
          coerce("marker.line.width", isBubble ? 1 : 0);
        }
        if (isBubble) {
          coerce("marker.sizeref");
          coerce("marker.sizemin");
          coerce("marker.sizemode");
        }
        if (opts.gradient) {
          var gradientType = coerce("marker.gradient.type");
          if (gradientType !== "none") {
            coerce("marker.gradient.color");
          }
        }
      };
    }
  });

  // src/traces/scatter/line_defaults.js
  var require_line_defaults = __commonJS({
    "src/traces/scatter/line_defaults.js"(exports, module) {
      "use strict";
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var hasColorscale = require_helpers().hasColorscale;
      var colorscaleDefaults = require_defaults2();
      module.exports = function lineDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {
        if (!opts) opts = {};
        var markerColor = (traceIn.marker || {}).color;
        if (markerColor && markerColor._inputArray) markerColor = markerColor._inputArray;
        coerce("line.color", defaultColor);
        if (hasColorscale(traceIn, "line")) {
          colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "line.", cLetter: "c" });
        } else {
          var lineColorDflt = (isArrayOrTypedArray(markerColor) ? false : markerColor) || defaultColor;
          coerce("line.color", lineColorDflt);
        }
        coerce("line.width");
        if (!opts.noDash) coerce("line.dash");
        if (opts.backoff) coerce("line.backoff");
      };
    }
  });

  // src/traces/scatter/line_shape_defaults.js
  var require_line_shape_defaults = __commonJS({
    "src/traces/scatter/line_shape_defaults.js"(exports, module) {
      "use strict";
      module.exports = function handleLineShapeDefaults(traceIn, traceOut, coerce) {
        var shape = coerce("line.shape");
        if (shape === "spline") coerce("line.smoothing");
      };
    }
  });

  // src/traces/scatter/text_defaults.js
  var require_text_defaults = __commonJS({
    "src/traces/scatter/text_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function(traceIn, traceOut, layout, coerce, opts) {
        opts = opts || {};
        coerce("textposition");
        Lib.coerceFont(coerce, "textfont", opts.font || layout.font, opts);
        if (!opts.noSelect) {
          coerce("selected.textfont.color");
          coerce("unselected.textfont.color");
        }
      };
    }
  });

  // src/traces/scatter/fillcolor_defaults.js
  var require_fillcolor_defaults = __commonJS({
    "src/traces/scatter/fillcolor_defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      function averageColors(colorscale) {
        var color = Color.interpolate(colorscale[0][1], colorscale[1][1], 0.5);
        for (var i = 2; i < colorscale.length; i++) {
          var averageColorI = Color.interpolate(colorscale[i - 1][1], colorscale[i][1], 0.5);
          color = Color.interpolate(color, averageColorI, colorscale[i - 1][0] / colorscale[i][0]);
        }
        return color;
      }
      module.exports = function fillColorDefaults(traceIn, traceOut, defaultColor, coerce, opts) {
        if (!opts) opts = {};
        var inheritColorFromMarker = false;
        if (traceOut.marker) {
          var markerColor = traceOut.marker.color;
          var markerLineColor = (traceOut.marker.line || {}).color;
          if (markerColor && !isArrayOrTypedArray(markerColor)) {
            inheritColorFromMarker = markerColor;
          } else if (markerLineColor && !isArrayOrTypedArray(markerLineColor)) {
            inheritColorFromMarker = markerLineColor;
          }
        }
        var averageGradientColor;
        if (opts.moduleHasFillgradient) {
          var gradientOrientation = coerce("fillgradient.type");
          if (gradientOrientation !== "none") {
            coerce("fillgradient.start");
            coerce("fillgradient.stop");
            var gradientColorscale = coerce("fillgradient.colorscale");
            if (gradientColorscale) {
              averageGradientColor = averageColors(gradientColorscale);
            }
          }
        }
        coerce("fillcolor", Color.addOpacity(
          (traceOut.line || {}).color || inheritColorFromMarker || averageGradientColor || defaultColor,
          0.5
        ));
      };
    }
  });

  // src/traces/scatter/defaults.js
  var require_defaults8 = __commonJS({
    "src/traces/scatter/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      var attributes = require_attributes12();
      var constants = require_constants8();
      var subTypes = require_subtypes();
      var handleXYDefaults = require_xy_defaults();
      var handlePeriodDefaults = require_period_defaults();
      var handleStackDefaults = require_stack_defaults();
      var handleMarkerDefaults = require_marker_defaults();
      var handleLineDefaults = require_line_defaults();
      var handleLineShapeDefaults = require_line_shape_defaults();
      var handleTextDefaults = require_text_defaults();
      var handleFillColorDefaults = require_fillcolor_defaults();
      var coercePattern = require_lib().coercePattern;
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var len = handleXYDefaults(traceIn, traceOut, layout, coerce);
        if (!len) traceOut.visible = false;
        if (!traceOut.visible) return;
        handlePeriodDefaults(traceIn, traceOut, layout, coerce);
        coerce("xhoverformat");
        coerce("yhoverformat");
        coerce("zorder");
        var stackGroupOpts = handleStackDefaults(traceIn, traceOut, layout, coerce);
        if (layout.scattermode === "group" && traceOut.orientation === void 0) {
          coerce("orientation", "v");
        }
        var defaultMode = !stackGroupOpts && len < constants.PTS_LINESONLY ? "lines+markers" : "lines";
        coerce("text");
        coerce("hovertext");
        coerce("mode", defaultMode);
        if (subTypes.hasMarkers(traceOut)) {
          handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce, { gradient: true });
        }
        if (subTypes.hasLines(traceOut)) {
          handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce, { backoff: true });
          handleLineShapeDefaults(traceIn, traceOut, coerce);
          coerce("connectgaps");
          coerce("line.simplify");
        }
        if (subTypes.hasText(traceOut)) {
          coerce("texttemplate");
          handleTextDefaults(traceIn, traceOut, layout, coerce);
        }
        var dfltHoverOn = [];
        if (subTypes.hasMarkers(traceOut) || subTypes.hasText(traceOut)) {
          coerce("cliponaxis");
          coerce("marker.maxdisplayed");
          dfltHoverOn.push("points");
        }
        coerce("fill", stackGroupOpts ? stackGroupOpts.fillDflt : "none");
        if (traceOut.fill !== "none") {
          handleFillColorDefaults(traceIn, traceOut, defaultColor, coerce, {
            moduleHasFillgradient: true
          });
          if (!subTypes.hasLines(traceOut)) handleLineShapeDefaults(traceIn, traceOut, coerce);
          coercePattern(coerce, "fillpattern", traceOut.fillcolor, false);
        }
        var lineColor = (traceOut.line || {}).color;
        var markerColor = (traceOut.marker || {}).color;
        if (traceOut.fill === "tonext" || traceOut.fill === "toself") {
          dfltHoverOn.push("fills");
        }
        coerce("hoveron", dfltHoverOn.join("+") || "points");
        if (traceOut.hoveron !== "fills") coerce("hovertemplate");
        var errorBarsSupplyDefaults = Registry.getComponentMethod("errorbars", "supplyDefaults");
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, { axis: "y" });
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, { axis: "x", inherit: "y" });
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
      };
    }
  });

  // src/traces/scatter/grouping_defaults.js
  var require_grouping_defaults = __commonJS({
    "src/traces/scatter/grouping_defaults.js"(exports, module) {
      "use strict";
      var getAxisGroup = require_constraints().getAxisGroup;
      module.exports = function handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce, barmode) {
        var orientation = traceOut.orientation;
        var posAxId = traceOut[{ v: "x", h: "y" }[orientation] + "axis"];
        var groupId = getAxisGroup(fullLayout, posAxId) + orientation;
        var alignmentOpts = fullLayout._alignmentOpts || {};
        var alignmentgroup = coerce("alignmentgroup");
        var alignmentGroups = alignmentOpts[groupId];
        if (!alignmentGroups) alignmentGroups = alignmentOpts[groupId] = {};
        var alignmentGroupOpts = alignmentGroups[alignmentgroup];
        if (alignmentGroupOpts) {
          alignmentGroupOpts.traces.push(traceOut);
        } else {
          alignmentGroupOpts = alignmentGroups[alignmentgroup] = {
            traces: [traceOut],
            alignmentIndex: Object.keys(alignmentGroups).length,
            offsetGroups: {}
          };
        }
        var offsetgroup = coerce("offsetgroup") || "";
        var offsetGroups = alignmentGroupOpts.offsetGroups;
        var offsetGroupOpts = offsetGroups[offsetgroup];
        traceOut._offsetIndex = 0;
        if (barmode !== "group" || offsetgroup) {
          if (!offsetGroupOpts) {
            offsetGroupOpts = offsetGroups[offsetgroup] = {
              offsetIndex: Object.keys(offsetGroups).length
            };
          }
          traceOut._offsetIndex = offsetGroupOpts.offsetIndex;
        }
      };
    }
  });

  // src/traces/scatter/cross_trace_defaults.js
  var require_cross_trace_defaults2 = __commonJS({
    "src/traces/scatter/cross_trace_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleGroupingDefaults = require_grouping_defaults();
      var attributes = require_attributes12();
      module.exports = function crossTraceDefaults(fullData, fullLayout) {
        var traceIn, traceOut, i;
        var scattermode = fullLayout.scattermode;
        function coerce(attr) {
          return Lib.coerce(traceOut._input, traceOut, attributes, attr);
        }
        if (fullLayout.scattermode === "group") {
          for (i = 0; i < fullData.length; i++) {
            traceOut = fullData[i];
            if (traceOut.type === "scatter") {
              traceIn = traceOut._input;
              handleGroupingDefaults(traceIn, traceOut, fullLayout, coerce, scattermode);
            }
          }
        }
        for (i = 0; i < fullData.length; i++) {
          var tracei = fullData[i];
          if (tracei.type !== "scatter") continue;
          var filli = tracei.fill;
          if (filli === "none" || filli === "toself") continue;
          tracei.opacity = void 0;
          if (filli === "tonexty" || filli === "tonextx") {
            for (var j = i - 1; j >= 0; j--) {
              var tracej = fullData[j];
              if (tracej.type === "scatter" && tracej.xaxis === tracei.xaxis && tracej.yaxis === tracei.yaxis) {
                tracej.opacity = void 0;
                break;
              }
            }
          }
        }
      };
    }
  });

  // src/traces/scatter/layout_defaults.js
  var require_layout_defaults3 = __commonJS({
    "src/traces/scatter/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var layoutAttributes = require_layout_attributes3();
      module.exports = function(layoutIn, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
        }
        var groupBarmode = layoutOut.barmode === "group";
        if (layoutOut.scattermode === "group") {
          coerce("scattergap", groupBarmode ? layoutOut.bargap : 0.2);
        }
      };
    }
  });

  // src/plots/cartesian/align_period.js
  var require_align_period = __commonJS({
    "src/plots/cartesian/align_period.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var dateTime2ms = Lib.dateTime2ms;
      var incrementMonth = Lib.incrementMonth;
      var constants = require_numerical();
      var ONEAVGMONTH = constants.ONEAVGMONTH;
      module.exports = function alignPeriod(trace, ax, axLetter, vals) {
        if (ax.type !== "date") return { vals };
        var alignment = trace[axLetter + "periodalignment"];
        if (!alignment) return { vals };
        var period = trace[axLetter + "period"];
        var mPeriod;
        if (isNumeric(period)) {
          period = +period;
          if (period <= 0) return { vals };
        } else if (typeof period === "string" && period.charAt(0) === "M") {
          var n = +period.substring(1);
          if (n > 0 && Math.round(n) === n) {
            mPeriod = n;
          } else return { vals };
        }
        var calendar = ax.calendar;
        var isStart = "start" === alignment;
        var isEnd = "end" === alignment;
        var period0 = trace[axLetter + "period0"];
        var base = dateTime2ms(period0, calendar) || 0;
        var newVals = [];
        var starts = [];
        var ends = [];
        var len = vals.length;
        for (var i = 0; i < len; i++) {
          var v = vals[i];
          var nEstimated, startTime, endTime;
          if (mPeriod) {
            nEstimated = Math.round((v - base) / (mPeriod * ONEAVGMONTH));
            endTime = incrementMonth(base, mPeriod * nEstimated, calendar);
            while (endTime > v) {
              endTime = incrementMonth(endTime, -mPeriod, calendar);
            }
            while (endTime <= v) {
              endTime = incrementMonth(endTime, mPeriod, calendar);
            }
            startTime = incrementMonth(endTime, -mPeriod, calendar);
          } else {
            nEstimated = Math.round((v - base) / period);
            endTime = base + nEstimated * period;
            while (endTime > v) {
              endTime -= period;
            }
            while (endTime <= v) {
              endTime += period;
            }
            startTime = endTime - period;
          }
          newVals[i] = isStart ? startTime : isEnd ? endTime : (startTime + endTime) / 2;
          starts[i] = startTime;
          ends[i] = endTime;
        }
        return {
          vals: newVals,
          starts,
          ends
        };
      };
    }
  });

  // src/traces/scatter/colorscale_calc.js
  var require_colorscale_calc = __commonJS({
    "src/traces/scatter/colorscale_calc.js"(exports, module) {
      "use strict";
      var hasColorscale = require_helpers().hasColorscale;
      var calcColorscale = require_calc();
      var subTypes = require_subtypes();
      module.exports = function calcMarkerColorscale(gd, trace) {
        if (subTypes.hasLines(trace) && hasColorscale(trace, "line")) {
          calcColorscale(gd, trace, {
            vals: trace.line.color,
            containerStr: "line",
            cLetter: "c"
          });
        }
        if (subTypes.hasMarkers(trace)) {
          if (hasColorscale(trace, "marker")) {
            calcColorscale(gd, trace, {
              vals: trace.marker.color,
              containerStr: "marker",
              cLetter: "c"
            });
          }
          if (hasColorscale(trace, "marker.line")) {
            calcColorscale(gd, trace, {
              vals: trace.marker.line.color,
              containerStr: "marker.line",
              cLetter: "c"
            });
          }
        }
      };
    }
  });

  // src/traces/scatter/arrays_to_calcdata.js
  var require_arrays_to_calcdata = __commonJS({
    "src/traces/scatter/arrays_to_calcdata.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function arraysToCalcdata(cd, trace) {
        for (var i = 0; i < cd.length; i++) cd[i].i = i;
        Lib.mergeArray(trace.text, cd, "tx");
        Lib.mergeArray(trace.texttemplate, cd, "txt");
        Lib.mergeArray(trace.hovertext, cd, "htx");
        Lib.mergeArray(trace.customdata, cd, "data");
        Lib.mergeArray(trace.textposition, cd, "tp");
        if (trace.textfont) {
          Lib.mergeArrayCastPositive(trace.textfont.size, cd, "ts");
          Lib.mergeArray(trace.textfont.color, cd, "tc");
          Lib.mergeArray(trace.textfont.family, cd, "tf");
          Lib.mergeArray(trace.textfont.weight, cd, "tw");
          Lib.mergeArray(trace.textfont.style, cd, "ty");
          Lib.mergeArray(trace.textfont.variant, cd, "tv");
          Lib.mergeArray(trace.textfont.textcase, cd, "tC");
          Lib.mergeArray(trace.textfont.lineposition, cd, "tE");
          Lib.mergeArray(trace.textfont.shadow, cd, "tS");
        }
        var marker = trace.marker;
        if (marker) {
          Lib.mergeArrayCastPositive(marker.size, cd, "ms");
          Lib.mergeArrayCastPositive(marker.opacity, cd, "mo");
          Lib.mergeArray(marker.symbol, cd, "mx");
          Lib.mergeArray(marker.angle, cd, "ma");
          Lib.mergeArray(marker.standoff, cd, "mf");
          Lib.mergeArray(marker.color, cd, "mc");
          var markerLine = marker.line;
          if (marker.line) {
            Lib.mergeArray(markerLine.color, cd, "mlc");
            Lib.mergeArrayCastPositive(markerLine.width, cd, "mlw");
          }
          var markerGradient = marker.gradient;
          if (markerGradient && markerGradient.type !== "none") {
            Lib.mergeArray(markerGradient.type, cd, "mgt");
            Lib.mergeArray(markerGradient.color, cd, "mgc");
          }
        }
      };
    }
  });

  // src/traces/scatter/calc_selection.js
  var require_calc_selection = __commonJS({
    "src/traces/scatter/calc_selection.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function calcSelection(cd, trace) {
        if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {
          Lib.tagSelected(cd, trace);
        }
      };
    }
  });

  // src/traces/scatter/calc.js
  var require_calc3 = __commonJS({
    "src/traces/scatter/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      var Axes = require_axes();
      var alignPeriod = require_align_period();
      var BADNUM = require_numerical().BADNUM;
      var subTypes = require_subtypes();
      var calcColorscale = require_colorscale_calc();
      var arraysToCalcdata = require_arrays_to_calcdata();
      var calcSelection = require_calc_selection();
      function calc(gd, trace) {
        var fullLayout = gd._fullLayout;
        var xa = trace._xA = Axes.getFromId(gd, trace.xaxis || "x", "x");
        var ya = trace._yA = Axes.getFromId(gd, trace.yaxis || "y", "y");
        var origX = xa.makeCalcdata(trace, "x");
        var origY = ya.makeCalcdata(trace, "y");
        var xObj = alignPeriod(trace, xa, "x", origX);
        var yObj = alignPeriod(trace, ya, "y", origY);
        var x = xObj.vals;
        var y = yObj.vals;
        var serieslen = trace._length;
        var cd = new Array(serieslen);
        var ids = trace.ids;
        var stackGroupOpts = getStackOpts(trace, fullLayout, xa, ya);
        var interpolateGaps = false;
        var isV, i, j, k, interpolate, vali;
        setFirstScatter(fullLayout, trace);
        var xAttr = "x";
        var yAttr = "y";
        var posAttr;
        if (stackGroupOpts) {
          Lib.pushUnique(stackGroupOpts.traceIndices, trace.index);
          isV = stackGroupOpts.orientation === "v";
          if (isV) {
            yAttr = "s";
            posAttr = "x";
          } else {
            xAttr = "s";
            posAttr = "y";
          }
          interpolate = stackGroupOpts.stackgaps === "interpolate";
        } else {
          var ppad = calcMarkerSize(trace, serieslen);
          calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);
        }
        var hasPeriodX = !!trace.xperiodalignment;
        var hasPeriodY = !!trace.yperiodalignment;
        for (i = 0; i < serieslen; i++) {
          var cdi = cd[i] = {};
          var xValid = isNumeric(x[i]);
          var yValid = isNumeric(y[i]);
          if (xValid && yValid) {
            cdi[xAttr] = x[i];
            cdi[yAttr] = y[i];
            if (hasPeriodX) {
              cdi.orig_x = origX[i];
              cdi.xEnd = xObj.ends[i];
              cdi.xStart = xObj.starts[i];
            }
            if (hasPeriodY) {
              cdi.orig_y = origY[i];
              cdi.yEnd = yObj.ends[i];
              cdi.yStart = yObj.starts[i];
            }
          } else if (stackGroupOpts && (isV ? xValid : yValid)) {
            cdi[posAttr] = isV ? x[i] : y[i];
            cdi.gap = true;
            if (interpolate) {
              cdi.s = BADNUM;
              interpolateGaps = true;
            } else {
              cdi.s = 0;
            }
          } else {
            cdi[xAttr] = cdi[yAttr] = BADNUM;
          }
          if (ids) {
            cdi.id = String(ids[i]);
          }
        }
        arraysToCalcdata(cd, trace);
        calcColorscale(gd, trace);
        calcSelection(cd, trace);
        if (stackGroupOpts) {
          i = 0;
          while (i < cd.length) {
            if (cd[i][posAttr] === BADNUM) {
              cd.splice(i, 1);
            } else i++;
          }
          Lib.sort(cd, function(a, b) {
            return a[posAttr] - b[posAttr] || a.i - b.i;
          });
          if (interpolateGaps) {
            i = 0;
            while (i < cd.length - 1 && cd[i].gap) {
              i++;
            }
            vali = cd[i].s;
            if (!vali) vali = cd[i].s = 0;
            for (j = 0; j < i; j++) {
              cd[j].s = vali;
            }
            k = cd.length - 1;
            while (k > i && cd[k].gap) {
              k--;
            }
            vali = cd[k].s;
            for (j = cd.length - 1; j > k; j--) {
              cd[j].s = vali;
            }
            while (i < k) {
              i++;
              if (cd[i].gap) {
                j = i + 1;
                while (cd[j].gap) {
                  j++;
                }
                var pos0 = cd[i - 1][posAttr];
                var size0 = cd[i - 1].s;
                var m = (cd[j].s - size0) / (cd[j][posAttr] - pos0);
                while (i < j) {
                  cd[i].s = size0 + (cd[i][posAttr] - pos0) * m;
                  i++;
                }
              }
            }
          }
        }
        return cd;
      }
      function calcAxisExpansion(gd, trace, xa, ya, x, y, ppad) {
        var serieslen = trace._length;
        var fullLayout = gd._fullLayout;
        var xId = xa._id;
        var yId = ya._id;
        var firstScatter = fullLayout._firstScatter[firstScatterGroup(trace)] === trace.uid;
        var stackOrientation = (getStackOpts(trace, fullLayout, xa, ya) || {}).orientation;
        var fill = trace.fill;
        xa._minDtick = 0;
        ya._minDtick = 0;
        var xOptions = { padded: true };
        var yOptions = { padded: true };
        if (ppad) {
          xOptions.ppad = yOptions.ppad = ppad;
        }
        var openEnded = serieslen < 2 || x[0] !== x[serieslen - 1] || y[0] !== y[serieslen - 1];
        if (openEnded && (fill === "tozerox" || fill === "tonextx" && (firstScatter || stackOrientation === "h"))) {
          xOptions.tozero = true;
        } else if (!(trace.error_y || {}).visible && // if no error bars, markers or text, or fill to y=0 remove x padding
        (fill === "tonexty" || fill === "tozeroy" || !subTypes.hasMarkers(trace) && !subTypes.hasText(trace))) {
          xOptions.padded = false;
          xOptions.ppad = 0;
        }
        if (openEnded && (fill === "tozeroy" || fill === "tonexty" && (firstScatter || stackOrientation === "v"))) {
          yOptions.tozero = true;
        } else if (fill === "tonextx" || fill === "tozerox") {
          yOptions.padded = false;
        }
        if (xId) trace._extremes[xId] = Axes.findExtremes(xa, x, xOptions);
        if (yId) trace._extremes[yId] = Axes.findExtremes(ya, y, yOptions);
      }
      function calcMarkerSize(trace, serieslen) {
        if (!subTypes.hasMarkers(trace)) return;
        var marker = trace.marker;
        var sizeref = 1.6 * (trace.marker.sizeref || 1);
        var markerTrans;
        if (trace.marker.sizemode === "area") {
          markerTrans = function(v) {
            return Math.max(Math.sqrt((v || 0) / sizeref), 3);
          };
        } else {
          markerTrans = function(v) {
            return Math.max((v || 0) / sizeref, 3);
          };
        }
        if (Lib.isArrayOrTypedArray(marker.size)) {
          var ax = { type: "linear" };
          Axes.setConvert(ax);
          var s = ax.makeCalcdata(trace.marker, "size");
          var sizeOut = new Array(serieslen);
          for (var i = 0; i < serieslen; i++) {
            sizeOut[i] = markerTrans(s[i]);
          }
          return sizeOut;
        } else {
          return markerTrans(marker.size);
        }
      }
      function setFirstScatter(fullLayout, trace) {
        var group = firstScatterGroup(trace);
        var firstScatter = fullLayout._firstScatter;
        if (!firstScatter[group]) firstScatter[group] = trace.uid;
      }
      function firstScatterGroup(trace) {
        var stackGroup = trace.stackgroup;
        return trace.xaxis + trace.yaxis + trace.type + (stackGroup ? "-" + stackGroup : "");
      }
      function getStackOpts(trace, fullLayout, xa, ya) {
        var stackGroup = trace.stackgroup;
        if (!stackGroup) return;
        var stackOpts = fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup];
        var stackAx = stackOpts.orientation === "v" ? ya : xa;
        if (stackAx.type === "linear" || stackAx.type === "log") return stackOpts;
      }
      module.exports = {
        calc,
        calcMarkerSize,
        calcAxisExpansion,
        setFirstScatter,
        getStackOpts
      };
    }
  });

  // src/traces/bar/sieve.js
  var require_sieve = __commonJS({
    "src/traces/bar/sieve.js"(exports, module) {
      "use strict";
      module.exports = Sieve;
      var distinctVals = require_lib().distinctVals;
      function Sieve(traces, opts) {
        this.traces = traces;
        this.sepNegVal = opts.sepNegVal;
        this.overlapNoMerge = opts.overlapNoMerge;
        var width1 = Infinity;
        var axLetter = opts.posAxis._id.charAt(0);
        var positions = [];
        for (var i = 0; i < traces.length; i++) {
          var trace = traces[i];
          for (var j = 0; j < trace.length; j++) {
            var bar = trace[j];
            var pos = bar.p;
            if (pos === void 0) {
              pos = bar[axLetter];
            }
            if (pos !== void 0) positions.push(pos);
          }
          if (trace[0] && trace[0].width1) {
            width1 = Math.min(trace[0].width1, width1);
          }
        }
        this.positions = positions;
        var dv = distinctVals(positions);
        this.distinctPositions = dv.vals;
        if (dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;
        else this.minDiff = Math.min(dv.minDiff, width1);
        var type = (opts.posAxis || {}).type;
        if (type === "category" || type === "multicategory") {
          this.minDiff = 1;
        }
        this.binWidth = this.minDiff;
        this.bins = {};
      }
      Sieve.prototype.put = function put(position, group, value) {
        var label = this.getLabel(position, group, value);
        var oldValue = this.bins[label] || 0;
        this.bins[label] = oldValue + value;
        return oldValue;
      };
      Sieve.prototype.get = function get(position, group, value) {
        var label = this.getLabel(position, group, value);
        return this.bins[label] || 0;
      };
      Sieve.prototype.getLabel = function getLabel(position, group, value) {
        var prefix = value < 0 && this.sepNegVal ? "v" : "^";
        var label = this.overlapNoMerge ? position : Math.round(position / this.binWidth);
        return prefix + label + "g" + group;
      };
    }
  });

  // src/traces/bar/cross_trace_calc.js
  var require_cross_trace_calc = __commonJS({
    "src/traces/bar/cross_trace_calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var BADNUM = require_numerical().BADNUM;
      var Registry = require_registry();
      var Axes = require_axes();
      var getAxisGroup = require_constraints().getAxisGroup;
      var Sieve = require_sieve();
      function crossTraceCalc(gd, plotinfo) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var fullLayout = gd._fullLayout;
        var fullTraces = gd._fullData;
        var calcTraces = gd.calcdata;
        var calcTracesHorz = [];
        var calcTracesVert = [];
        for (var i = 0; i < fullTraces.length; i++) {
          var fullTrace = fullTraces[i];
          if (fullTrace.visible === true && Registry.traceIs(fullTrace, "bar") && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {
            if (fullTrace.orientation === "h") {
              calcTracesHorz.push(calcTraces[i]);
            } else {
              calcTracesVert.push(calcTraces[i]);
            }
            if (fullTrace._computePh) {
              var cd = gd.calcdata[i];
              for (var j = 0; j < cd.length; j++) {
                if (typeof cd[j].ph0 === "function") cd[j].ph0 = cd[j].ph0();
                if (typeof cd[j].ph1 === "function") cd[j].ph1 = cd[j].ph1();
              }
            }
          }
        }
        var opts = {
          xCat: xa.type === "category" || xa.type === "multicategory",
          yCat: ya.type === "category" || ya.type === "multicategory",
          mode: fullLayout.barmode,
          norm: fullLayout.barnorm,
          gap: fullLayout.bargap,
          groupgap: fullLayout.bargroupgap
        };
        setGroupPositions(gd, xa, ya, calcTracesVert, opts);
        setGroupPositions(gd, ya, xa, calcTracesHorz, opts);
      }
      function setGroupPositions(gd, pa, sa, calcTraces, opts) {
        if (!calcTraces.length) return;
        var excluded;
        var included;
        var i, calcTrace, fullTrace;
        initBase(sa, calcTraces);
        switch (opts.mode) {
          case "overlay":
            setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces, opts);
            break;
          case "group":
            excluded = [];
            included = [];
            for (i = 0; i < calcTraces.length; i++) {
              calcTrace = calcTraces[i];
              fullTrace = calcTrace[0].trace;
              if (fullTrace.offset === void 0) included.push(calcTrace);
              else excluded.push(calcTrace);
            }
            if (included.length) {
              setGroupPositionsInGroupMode(gd, pa, sa, included, opts);
            }
            if (excluded.length) {
              setGroupPositionsInOverlayMode(gd, pa, sa, excluded, opts);
            }
            break;
          case "stack":
          case "relative":
            excluded = [];
            included = [];
            for (i = 0; i < calcTraces.length; i++) {
              calcTrace = calcTraces[i];
              fullTrace = calcTrace[0].trace;
              if (fullTrace.base === void 0) included.push(calcTrace);
              else excluded.push(calcTrace);
            }
            standardizeCornerradius(included);
            if (included.length) {
              setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included, opts);
            }
            if (excluded.length) {
              setGroupPositionsInOverlayMode(gd, pa, sa, excluded, opts);
            }
            break;
        }
        setCornerradius(calcTraces);
        collectExtents(calcTraces, pa);
      }
      function setCornerradius(calcTraces) {
        var i, calcTrace, fullTrace, t, cr, crValue, crForm;
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          t = calcTrace[0].t;
          if (t.cornerradiusvalue === void 0) {
            cr = fullTrace.marker ? fullTrace.marker.cornerradius : void 0;
            if (cr !== void 0) {
              crValue = isNumeric(cr) ? +cr : +cr.slice(0, -1);
              crForm = isNumeric(cr) ? "px" : "%";
              t.cornerradiusvalue = crValue;
              t.cornerradiusform = crForm;
            }
          }
        }
      }
      function standardizeCornerradius(calcTraces) {
        if (calcTraces.length < 2) return;
        var i, calcTrace, fullTrace, t;
        var cr, crValue, crForm;
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          cr = fullTrace.marker ? fullTrace.marker.cornerradius : void 0;
          if (cr !== void 0) break;
        }
        if (cr !== void 0) {
          crValue = isNumeric(cr) ? +cr : +cr.slice(0, -1);
          crForm = isNumeric(cr) ? "px" : "%";
          for (i = 0; i < calcTraces.length; i++) {
            calcTrace = calcTraces[i];
            t = calcTrace[0].t;
            t.cornerradiusvalue = crValue;
            t.cornerradiusform = crForm;
          }
        }
      }
      function initBase(sa, calcTraces) {
        var i, j;
        for (i = 0; i < calcTraces.length; i++) {
          var cd = calcTraces[i];
          var trace = cd[0].trace;
          var base = trace.type === "funnel" ? trace._base : trace.base;
          var b;
          var scalendar = trace.orientation === "h" ? trace.xcalendar : trace.ycalendar;
          var d2c = sa.type === "category" || sa.type === "multicategory" ? function() {
            return null;
          } : sa.d2c;
          if (isArrayOrTypedArray(base)) {
            for (j = 0; j < Math.min(base.length, cd.length); j++) {
              b = d2c(base[j], 0, scalendar);
              if (isNumeric(b)) {
                cd[j].b = +b;
                cd[j].hasB = 1;
              } else cd[j].b = 0;
            }
            for (; j < cd.length; j++) {
              cd[j].b = 0;
            }
          } else {
            b = d2c(base, 0, scalendar);
            var hasBase = isNumeric(b);
            b = hasBase ? b : 0;
            for (j = 0; j < cd.length; j++) {
              cd[j].b = b;
              if (hasBase) cd[j].hasB = 1;
            }
          }
        }
      }
      function setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces, opts) {
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var sieve = new Sieve([calcTrace], {
            posAxis: pa,
            sepNegVal: false,
            overlapNoMerge: !opts.norm
          });
          setOffsetAndWidth(gd, pa, sieve, opts);
          if (opts.norm) {
            sieveBars(sieve);
            normalizeBars(sa, sieve, opts);
          } else {
            setBaseAndTop(sa, sieve);
          }
        }
      }
      function setGroupPositionsInGroupMode(gd, pa, sa, calcTraces, opts) {
        var sieve = new Sieve(calcTraces, {
          posAxis: pa,
          sepNegVal: false,
          overlapNoMerge: !opts.norm
        });
        setOffsetAndWidth(gd, pa, sieve, opts);
        unhideBarsWithinTrace(sieve, pa);
        if (opts.norm) {
          sieveBars(sieve);
          normalizeBars(sa, sieve, opts);
        } else {
          setBaseAndTop(sa, sieve);
        }
      }
      function setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces, opts) {
        var sieve = new Sieve(calcTraces, {
          posAxis: pa,
          sepNegVal: opts.mode === "relative",
          overlapNoMerge: !(opts.norm || opts.mode === "stack" || opts.mode === "relative")
        });
        setOffsetAndWidth(gd, pa, sieve, opts);
        stackBars(sa, sieve, opts);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var offsetIndex = calcTrace[0].t.offsetindex;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              var isOutmostBar = bar.b + bar.s === sieve.get(bar.p, offsetIndex, bar.s);
              if (isOutmostBar) bar._outmost = true;
            }
          }
        }
        if (opts.norm) normalizeBars(sa, sieve, opts);
      }
      function setOffsetAndWidth(gd, pa, sieve, opts) {
        var fullLayout = gd._fullLayout;
        var positions = sieve.positions;
        var distinctPositions = sieve.distinctPositions;
        var minDiff = sieve.minDiff;
        var calcTraces = sieve.traces;
        var nTraces = calcTraces.length;
        var overlap = positions.length !== distinctPositions.length;
        var barGroupWidth = minDiff * (1 - opts.gap);
        var barWidthPlusGap;
        var barWidth;
        var offsetFromCenter;
        var alignmentGroups;
        if (pa._id === "angularaxis") {
          barWidthPlusGap = barGroupWidth;
          barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));
          offsetFromCenter = -barWidth / 2;
        } else {
          var groupId = getAxisGroup(fullLayout, pa._id) + calcTraces[0][0].trace.orientation;
          alignmentGroups = fullLayout._alignmentOpts[groupId] || {};
        }
        for (var i = 0; i < nTraces; i++) {
          var calcTrace = calcTraces[i];
          var trace = calcTrace[0].trace;
          if (pa._id !== "angularaxis") {
            var alignmentGroupOpts = alignmentGroups[trace.alignmentgroup] || {};
            var nOffsetGroups = Object.keys(alignmentGroupOpts.offsetGroups || {}).length;
            if (nOffsetGroups) {
              barWidthPlusGap = barGroupWidth / nOffsetGroups;
            } else {
              barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;
            }
            barWidth = barWidthPlusGap * (1 - (opts.groupgap || 0));
            if (nOffsetGroups) {
              offsetFromCenter = ((2 * trace._offsetIndex + 1 - nOffsetGroups) * barWidthPlusGap - barWidth) / 2;
            } else {
              offsetFromCenter = overlap ? ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 : -barWidth / 2;
            }
          }
          var t = calcTrace[0].t;
          t.barwidth = barWidth;
          t.offsetindex = trace._offsetIndex || 0;
          t.poffset = offsetFromCenter;
          t.bargroupwidth = barGroupWidth;
          t.bardelta = minDiff;
        }
        sieve.binWidth = calcTraces[0][0].t.barwidth / 100;
        applyAttributes(sieve);
        setBarCenterAndWidth(pa, sieve);
        if (pa._id === "angularaxis") {
          updatePositionAxis(pa, sieve);
        } else {
          updatePositionAxis(pa, sieve, overlap);
        }
      }
      function applyAttributes(sieve) {
        var calcTraces = sieve.traces;
        var i, j;
        for (i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var calcTrace0 = calcTrace[0];
          var fullTrace = calcTrace0.trace;
          var t = calcTrace0.t;
          var offset = fullTrace._offset || fullTrace.offset;
          var initialPoffset = t.poffset;
          var newPoffset;
          if (isArrayOrTypedArray(offset)) {
            newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);
            for (j = 0; j < newPoffset.length; j++) {
              if (!isNumeric(newPoffset[j])) {
                newPoffset[j] = initialPoffset;
              }
            }
            for (j = newPoffset.length; j < calcTrace.length; j++) {
              newPoffset.push(initialPoffset);
            }
            t.poffset = newPoffset;
          } else if (offset !== void 0) {
            t.poffset = offset;
          }
          var width = fullTrace._width || fullTrace.width;
          var initialBarwidth = t.barwidth;
          if (isArrayOrTypedArray(width)) {
            var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);
            for (j = 0; j < newBarwidth.length; j++) {
              if (!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;
            }
            for (j = newBarwidth.length; j < calcTrace.length; j++) {
              newBarwidth.push(initialBarwidth);
            }
            t.barwidth = newBarwidth;
            if (offset === void 0) {
              newPoffset = [];
              for (j = 0; j < calcTrace.length; j++) {
                newPoffset.push(
                  initialPoffset + (initialBarwidth - newBarwidth[j]) / 2
                );
              }
              t.poffset = newPoffset;
            }
          } else if (width !== void 0) {
            t.barwidth = width;
            if (offset === void 0) {
              t.poffset = initialPoffset + (initialBarwidth - width) / 2;
            }
          }
        }
      }
      function setBarCenterAndWidth(pa, sieve) {
        var calcTraces = sieve.traces;
        var pLetter = getAxisLetter(pa);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var t = calcTrace[0].t;
          var poffset = t.poffset;
          var poffsetIsArray = isArrayOrTypedArray(poffset);
          var barwidth = t.barwidth;
          var barwidthIsArray = isArrayOrTypedArray(barwidth);
          for (var j = 0; j < calcTrace.length; j++) {
            var calcBar = calcTrace[j];
            var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;
            if (calcBar.p === void 0) {
              calcBar.p = calcBar[pLetter];
              calcBar["orig_" + pLetter] = calcBar[pLetter];
            }
            var delta = (poffsetIsArray ? poffset[j] : poffset) + width / 2;
            calcBar[pLetter] = calcBar.p + delta;
          }
        }
      }
      function updatePositionAxis(pa, sieve, allowMinDtick) {
        var calcTraces = sieve.traces;
        var minDiff = sieve.minDiff;
        var vpad = minDiff / 2;
        Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var calcTrace0 = calcTrace[0];
          var fullTrace = calcTrace0.trace;
          var pts = [];
          var bar, l, r, j;
          for (j = 0; j < calcTrace.length; j++) {
            bar = calcTrace[j];
            l = bar.p - vpad;
            r = bar.p + vpad;
            pts.push(l, r);
          }
          if (fullTrace.width || fullTrace.offset) {
            var t = calcTrace0.t;
            var poffset = t.poffset;
            var barwidth = t.barwidth;
            var poffsetIsArray = isArrayOrTypedArray(poffset);
            var barwidthIsArray = isArrayOrTypedArray(barwidth);
            for (j = 0; j < calcTrace.length; j++) {
              bar = calcTrace[j];
              var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;
              var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;
              l = bar.p + calcBarOffset;
              r = l + calcBarWidth;
              pts.push(l, r);
            }
          }
          fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, { padded: false });
        }
      }
      function setBaseAndTop(sa, sieve) {
        var calcTraces = sieve.traces;
        var sLetter = getAxisLetter(sa);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var fullTrace = calcTrace[0].trace;
          var isScatter = fullTrace.type === "scatter";
          var isVertical = fullTrace.orientation === "v";
          var pts = [];
          var tozero = false;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            var base = isScatter ? 0 : bar.b;
            var top = isScatter ? isVertical ? bar.y : bar.x : base + bar.s;
            bar[sLetter] = top;
            pts.push(top);
            if (bar.hasB) pts.push(base);
            if (!bar.hasB || !bar.b) {
              tozero = true;
            }
          }
          fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
            tozero,
            padded: true
          });
        }
      }
      function stackBars(sa, sieve, opts) {
        var sLetter = getAxisLetter(sa);
        var calcTraces = sieve.traces;
        var calcTrace;
        var fullTrace;
        var isFunnel;
        var i, j;
        var bar;
        var offsetIndex;
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          if (fullTrace.type === "funnel") {
            offsetIndex = calcTrace[0].t.offsetindex;
            for (j = 0; j < calcTrace.length; j++) {
              bar = calcTrace[j];
              if (bar.s !== BADNUM) {
                sieve.put(bar.p, offsetIndex, -0.5 * bar.s);
              }
            }
          }
        }
        for (i = 0; i < calcTraces.length; i++) {
          calcTrace = calcTraces[i];
          fullTrace = calcTrace[0].trace;
          isFunnel = fullTrace.type === "funnel";
          offsetIndex = fullTrace.type === "barpolar" ? 0 : calcTrace[0].t.offsetindex;
          var pts = [];
          for (j = 0; j < calcTrace.length; j++) {
            bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              var value;
              if (isFunnel) {
                value = bar.s;
              } else {
                value = bar.s + bar.b;
              }
              var base = sieve.put(bar.p, offsetIndex, value);
              var top = base + value;
              bar.b = base;
              bar[sLetter] = top;
              if (!opts.norm) {
                pts.push(top);
                if (bar.hasB) {
                  pts.push(base);
                }
              }
            }
          }
          if (!opts.norm) {
            fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
              // N.B. we don't stack base with 'base',
              // so set tozero:true always!
              tozero: true,
              padded: true
            });
          }
        }
      }
      function sieveBars(sieve) {
        var calcTraces = sieve.traces;
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var offsetIndex = calcTrace[0].t.offsetindex;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              sieve.put(bar.p, offsetIndex, bar.b + bar.s);
            }
          }
        }
      }
      function unhideBarsWithinTrace(sieve, pa) {
        var calcTraces = sieve.traces;
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var fullTrace = calcTrace[0].trace;
          var offsetIndex = calcTrace[0].t.offsetindex;
          if (fullTrace.base === void 0) {
            var inTraceSieve = new Sieve([calcTrace], {
              posAxis: pa,
              sepNegVal: true,
              overlapNoMerge: true
            });
            for (var j = 0; j < calcTrace.length; j++) {
              var bar = calcTrace[j];
              if (bar.p !== BADNUM) {
                var base = inTraceSieve.put(bar.p, offsetIndex, bar.b + bar.s);
                if (base) bar.b = base;
              }
            }
          }
        }
      }
      function normalizeBars(sa, sieve, opts) {
        var calcTraces = sieve.traces;
        var sLetter = getAxisLetter(sa);
        var sTop = opts.norm === "fraction" ? 1 : 100;
        var sTiny = sTop / 1e9;
        var sMin = sa.l2c(sa.c2l(0));
        var sMax = opts.mode === "stack" ? sTop : sMin;
        function needsPadding(v) {
          return isNumeric(sa.c2l(v)) && (v < sMin - sTiny || v > sMax + sTiny || !isNumeric(sMin));
        }
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          var offsetIndex = calcTrace[0].t.offsetindex;
          var fullTrace = calcTrace[0].trace;
          var pts = [];
          var tozero = false;
          var padded = false;
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            if (bar.s !== BADNUM) {
              var scale = Math.abs(sTop / sieve.get(bar.p, offsetIndex, bar.s));
              bar.b *= scale;
              bar.s *= scale;
              var base = bar.b;
              var top = base + bar.s;
              bar[sLetter] = top;
              pts.push(top);
              padded = padded || needsPadding(top);
              if (bar.hasB) {
                pts.push(base);
                padded = padded || needsPadding(base);
              }
              if (!bar.hasB || !bar.b) {
                tozero = true;
              }
            }
          }
          fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {
            tozero,
            padded
          });
        }
      }
      function setHelperValuesForRoundedCorners(calcTraces, sMinByPos, sMaxByPos, pa) {
        var pLetter = getAxisLetter(pa);
        for (var i = 0; i < calcTraces.length; i++) {
          var calcTrace = calcTraces[i];
          for (var j = 0; j < calcTrace.length; j++) {
            var bar = calcTrace[j];
            var pos = bar[pLetter];
            bar._sMin = sMinByPos[pos];
            bar._sMax = sMaxByPos[pos];
          }
        }
      }
      function collectExtents(calcTraces, pa) {
        var pLetter = getAxisLetter(pa);
        var extents = {};
        var i, j, cd;
        var pMin = Infinity;
        var pMax = -Infinity;
        for (i = 0; i < calcTraces.length; i++) {
          cd = calcTraces[i];
          for (j = 0; j < cd.length; j++) {
            var p = cd[j].p;
            if (isNumeric(p)) {
              pMin = Math.min(pMin, p);
              pMax = Math.max(pMax, p);
            }
          }
        }
        var roundFactor = 1e4 / (pMax - pMin);
        var round = extents.round = function(p2) {
          return String(Math.round(roundFactor * (p2 - pMin)));
        };
        var sMinByPos = {};
        var sMaxByPos = {};
        var anyTraceHasCornerradius = calcTraces.some(function(x) {
          var trace = x[0].trace;
          return "marker" in trace && trace.marker.cornerradius;
        });
        for (i = 0; i < calcTraces.length; i++) {
          cd = calcTraces[i];
          cd[0].t.extents = extents;
          var poffset = cd[0].t.poffset;
          var poffsetIsArray = isArrayOrTypedArray(poffset);
          for (j = 0; j < cd.length; j++) {
            var di = cd[j];
            var p0 = di[pLetter] - di.w / 2;
            if (isNumeric(p0)) {
              var p1 = di[pLetter] + di.w / 2;
              var pVal = round(di.p);
              if (extents[pVal]) {
                extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];
              } else {
                extents[pVal] = [p0, p1];
              }
            }
            di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);
            di.p1 = di.p0 + di.w;
            di.s0 = di.b;
            di.s1 = di.s0 + di.s;
            if (anyTraceHasCornerradius) {
              var sMin = Math.min(di.s0, di.s1) || 0;
              var sMax = Math.max(di.s0, di.s1) || 0;
              var pos = di[pLetter];
              sMinByPos[pos] = pos in sMinByPos ? Math.min(sMinByPos[pos], sMin) : sMin;
              sMaxByPos[pos] = pos in sMaxByPos ? Math.max(sMaxByPos[pos], sMax) : sMax;
            }
          }
        }
        if (anyTraceHasCornerradius) {
          setHelperValuesForRoundedCorners(calcTraces, sMinByPos, sMaxByPos, pa);
        }
      }
      function getAxisLetter(ax) {
        return ax._id.charAt(0);
      }
      module.exports = {
        crossTraceCalc,
        setGroupPositions
      };
    }
  });

  // src/traces/scatter/cross_trace_calc.js
  var require_cross_trace_calc2 = __commonJS({
    "src/traces/scatter/cross_trace_calc.js"(exports, module) {
      "use strict";
      var calc = require_calc3();
      var setGroupPositions = require_cross_trace_calc().setGroupPositions;
      function groupCrossTraceCalc(gd, plotinfo) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var fullLayout = gd._fullLayout;
        var fullTraces = gd._fullData;
        var calcTraces = gd.calcdata;
        var calcTracesHorz = [];
        var calcTracesVert = [];
        for (var i = 0; i < fullTraces.length; i++) {
          var fullTrace = fullTraces[i];
          if (fullTrace.visible === true && fullTrace.type === "scatter" && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {
            if (fullTrace.orientation === "h") {
              calcTracesHorz.push(calcTraces[i]);
            } else if (fullTrace.orientation === "v") {
              calcTracesVert.push(calcTraces[i]);
            }
          }
        }
        var opts = {
          mode: fullLayout.scattermode,
          gap: fullLayout.scattergap
        };
        setGroupPositions(gd, xa, ya, calcTracesVert, opts);
        setGroupPositions(gd, ya, xa, calcTracesHorz, opts);
      }
      module.exports = function crossTraceCalc(gd, plotinfo) {
        if (gd._fullLayout.scattermode === "group") {
          groupCrossTraceCalc(gd, plotinfo);
        }
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var subplot = xa._id + ya._id;
        var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];
        if (!subplotStackOpts) return;
        var calcTraces = gd.calcdata;
        var i, j, k, i2, cd, cd0, posj, sumj, norm;
        var groupOpts, interpolate, groupnorm, posAttr, valAttr;
        var hasAnyBlanks;
        for (var stackGroup in subplotStackOpts) {
          groupOpts = subplotStackOpts[stackGroup];
          var indices = groupOpts.traceIndices;
          if (!indices.length) continue;
          interpolate = groupOpts.stackgaps === "interpolate";
          groupnorm = groupOpts.groupnorm;
          if (groupOpts.orientation === "v") {
            posAttr = "x";
            valAttr = "y";
          } else {
            posAttr = "y";
            valAttr = "x";
          }
          hasAnyBlanks = new Array(indices.length);
          for (i = 0; i < hasAnyBlanks.length; i++) {
            hasAnyBlanks[i] = false;
          }
          cd0 = calcTraces[indices[0]];
          var allPositions = new Array(cd0.length);
          for (i = 0; i < cd0.length; i++) {
            allPositions[i] = cd0[i][posAttr];
          }
          for (i = 1; i < indices.length; i++) {
            cd = calcTraces[indices[i]];
            for (j = k = 0; j < cd.length; j++) {
              posj = cd[j][posAttr];
              for (; posj > allPositions[k] && k < allPositions.length; k++) {
                insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);
                j++;
              }
              if (posj !== allPositions[k]) {
                for (i2 = 0; i2 < i; i2++) {
                  insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);
                }
                allPositions.splice(k, 0, posj);
              }
              k++;
            }
            for (; k < allPositions.length; k++) {
              insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);
              j++;
            }
          }
          var serieslen = allPositions.length;
          for (j = 0; j < cd0.length; j++) {
            sumj = cd0[j][valAttr] = cd0[j].s;
            for (i = 1; i < indices.length; i++) {
              cd = calcTraces[indices[i]];
              cd[0].trace._rawLength = cd[0].trace._length;
              cd[0].trace._length = serieslen;
              sumj += cd[j].s;
              cd[j][valAttr] = sumj;
            }
            if (groupnorm) {
              norm = (groupnorm === "fraction" ? sumj : sumj / 100) || 1;
              for (i = 0; i < indices.length; i++) {
                var cdj = calcTraces[indices[i]][j];
                cdj[valAttr] /= norm;
                cdj.sNorm = cdj.s / norm;
              }
            }
          }
          for (i = 0; i < indices.length; i++) {
            cd = calcTraces[indices[i]];
            var trace = cd[0].trace;
            var ppad = calc.calcMarkerSize(trace, trace._rawLength);
            var arrayPad = Array.isArray(ppad);
            if (ppad && hasAnyBlanks[i] || arrayPad) {
              var ppadRaw = ppad;
              ppad = new Array(serieslen);
              for (j = 0; j < serieslen; j++) {
                ppad[j] = cd[j].gap ? 0 : arrayPad ? ppadRaw[cd[j].i] : ppadRaw;
              }
            }
            var x = new Array(serieslen);
            var y = new Array(serieslen);
            for (j = 0; j < serieslen; j++) {
              x[j] = cd[j].x;
              y[j] = cd[j].y;
            }
            calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);
            cd[0].t.orientation = groupOpts.orientation;
          }
        }
      };
      function insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {
        hasAnyBlanks[traceIndex] = true;
        var newEntry = {
          i: null,
          gap: true,
          s: 0
        };
        newEntry[posAttr] = position;
        calcTrace.splice(index, 0, newEntry);
        if (index && position === calcTrace[index - 1][posAttr]) {
          var prevEntry = calcTrace[index - 1];
          newEntry.s = prevEntry.s;
          newEntry.i = prevEntry.i;
          newEntry.gap = prevEntry.gap;
        } else if (interpolate) {
          newEntry.s = getInterp(calcTrace, index, position, posAttr);
        }
        if (!index) {
          calcTrace[0].t = calcTrace[1].t;
          calcTrace[0].trace = calcTrace[1].trace;
          delete calcTrace[1].t;
          delete calcTrace[1].trace;
        }
      }
      function getInterp(calcTrace, index, position, posAttr) {
        var pt0 = calcTrace[index - 1];
        var pt1 = calcTrace[index + 1];
        if (!pt1) return pt0.s;
        if (!pt0) return pt1.s;
        return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);
      }
    }
  });

  // src/traces/scatter/line_points.js
  var require_line_points = __commonJS({
    "src/traces/scatter/line_points.js"(exports, module) {
      "use strict";
      var Drawing = require_drawing();
      var numConstants = require_numerical();
      var BADNUM = numConstants.BADNUM;
      var LOG_CLIP = numConstants.LOG_CLIP;
      var LOG_CLIP_PLUS = LOG_CLIP + 0.5;
      var LOG_CLIP_MINUS = LOG_CLIP - 0.5;
      var Lib = require_lib();
      var segmentsIntersect = Lib.segmentsIntersect;
      var constrain = Lib.constrain;
      var constants = require_constants8();
      module.exports = function linePoints(d, opts) {
        var trace = opts.trace || {};
        var xa = opts.xaxis;
        var ya = opts.yaxis;
        var xLog = xa.type === "log";
        var yLog = ya.type === "log";
        var xLen = xa._length;
        var yLen = ya._length;
        var backoff = opts.backoff;
        var marker = trace.marker;
        var connectGaps = opts.connectGaps;
        var baseTolerance = opts.baseTolerance;
        var shape = opts.shape;
        var linear = shape === "linear";
        var fill = trace.fill && trace.fill !== "none";
        var segments = [];
        var minTolerance = constants.minTolerance;
        var len = d.length;
        var pts = new Array(len);
        var pti = 0;
        var i;
        var clusterStartPt, clusterEndPt, clusterHighPt, clusterLowPt;
        var thisPt;
        var clusterHighFirst;
        var clusterUnitVector;
        var thisVector;
        var clusterRefDist, clusterHighVal, clusterLowVal, thisVal;
        var clusterMinDeviation, clusterMaxDeviation, thisDeviation;
        function getPt(index) {
          var di = d[index];
          if (!di) return false;
          var x = opts.linearized ? xa.l2p(di.x) : xa.c2p(di.x);
          var y = opts.linearized ? ya.l2p(di.y) : ya.c2p(di.y);
          if (x === BADNUM) {
            if (xLog) x = xa.c2p(di.x, true);
            if (x === BADNUM) return false;
            if (yLog && y === BADNUM) {
              x *= Math.abs(xa._m * yLen * (xa._m > 0 ? LOG_CLIP_PLUS : LOG_CLIP_MINUS) / (ya._m * xLen * (ya._m > 0 ? LOG_CLIP_PLUS : LOG_CLIP_MINUS)));
            }
            x *= 1e3;
          }
          if (y === BADNUM) {
            if (yLog) y = ya.c2p(di.y, true);
            if (y === BADNUM) return false;
            y *= 1e3;
          }
          return [x, y];
        }
        function crossesViewport(xFrac0, yFrac0, xFrac1, yFrac1) {
          var dx = xFrac1 - xFrac0;
          var dy = yFrac1 - yFrac0;
          var dx0 = 0.5 - xFrac0;
          var dy0 = 0.5 - yFrac0;
          var norm2 = dx * dx + dy * dy;
          var dot = dx * dx0 + dy * dy0;
          if (dot > 0 && dot < norm2) {
            var cross = dx0 * dy - dy0 * dx;
            if (cross * cross < norm2) return true;
          }
        }
        var latestXFrac, latestYFrac;
        function getTolerance(pt, nextPt2) {
          var xFrac = pt[0] / xLen;
          var yFrac = pt[1] / yLen;
          var offScreenFraction = Math.max(0, -xFrac, xFrac - 1, -yFrac, yFrac - 1);
          if (offScreenFraction && latestXFrac !== void 0 && crossesViewport(xFrac, yFrac, latestXFrac, latestYFrac)) {
            offScreenFraction = 0;
          }
          if (offScreenFraction && nextPt2 && crossesViewport(xFrac, yFrac, nextPt2[0] / xLen, nextPt2[1] / yLen)) {
            offScreenFraction = 0;
          }
          return (1 + constants.toleranceGrowth * offScreenFraction) * baseTolerance;
        }
        function ptDist(pt1, pt2) {
          var dx = pt1[0] - pt2[0];
          var dy = pt1[1] - pt2[1];
          return Math.sqrt(dx * dx + dy * dy);
        }
        var maxScreensAway = constants.maxScreensAway;
        var xEdge0 = -xLen * maxScreensAway;
        var xEdge1 = xLen * (1 + maxScreensAway);
        var yEdge0 = -yLen * maxScreensAway;
        var yEdge1 = yLen * (1 + maxScreensAway);
        var edges = [
          [xEdge0, yEdge0, xEdge1, yEdge0],
          [xEdge1, yEdge0, xEdge1, yEdge1],
          [xEdge1, yEdge1, xEdge0, yEdge1],
          [xEdge0, yEdge1, xEdge0, yEdge0]
        ];
        var xEdge, yEdge, lastXEdge, lastYEdge, lastFarPt, edgePt;
        function getLinearEdgeIntersections(pt1, pt2) {
          var out = [];
          var ptCount = 0;
          for (var i2 = 0; i2 < 4; i2++) {
            var edge = edges[i2];
            var ptInt = segmentsIntersect(
              pt1[0],
              pt1[1],
              pt2[0],
              pt2[1],
              edge[0],
              edge[1],
              edge[2],
              edge[3]
            );
            if (ptInt && (!ptCount || Math.abs(ptInt.x - out[0][0]) > 1 || Math.abs(ptInt.y - out[0][1]) > 1)) {
              ptInt = [ptInt.x, ptInt.y];
              if (ptCount && ptDist(ptInt, pt1) < ptDist(out[0], pt1)) out.unshift(ptInt);
              else out.push(ptInt);
              ptCount++;
            }
          }
          return out;
        }
        function onlyConstrainedPoint(pt) {
          if (pt[0] < xEdge0 || pt[0] > xEdge1 || pt[1] < yEdge0 || pt[1] > yEdge1) {
            return [constrain(pt[0], xEdge0, xEdge1), constrain(pt[1], yEdge0, yEdge1)];
          }
        }
        function sameEdge(pt1, pt2) {
          if (pt1[0] === pt2[0] && (pt1[0] === xEdge0 || pt1[0] === xEdge1)) return true;
          if (pt1[1] === pt2[1] && (pt1[1] === yEdge0 || pt1[1] === yEdge1)) return true;
        }
        function getHVEdgeIntersections(pt1, pt2) {
          var out = [];
          var ptInt1 = onlyConstrainedPoint(pt1);
          var ptInt2 = onlyConstrainedPoint(pt2);
          if (ptInt1 && ptInt2 && sameEdge(ptInt1, ptInt2)) return out;
          if (ptInt1) out.push(ptInt1);
          if (ptInt2) out.push(ptInt2);
          return out;
        }
        function getABAEdgeIntersections(dim, limit0, limit1) {
          return function(pt1, pt2) {
            var ptInt1 = onlyConstrainedPoint(pt1);
            var ptInt2 = onlyConstrainedPoint(pt2);
            var out = [];
            if (ptInt1 && ptInt2 && sameEdge(ptInt1, ptInt2)) return out;
            if (ptInt1) out.push(ptInt1);
            if (ptInt2) out.push(ptInt2);
            var midShift = 2 * Lib.constrain((pt1[dim] + pt2[dim]) / 2, limit0, limit1) - ((ptInt1 || pt1)[dim] + (ptInt2 || pt2)[dim]);
            if (midShift) {
              var ptToAlter;
              if (ptInt1 && ptInt2) {
                ptToAlter = midShift > 0 === ptInt1[dim] > ptInt2[dim] ? ptInt1 : ptInt2;
              } else ptToAlter = ptInt1 || ptInt2;
              ptToAlter[dim] += midShift;
            }
            return out;
          };
        }
        var getEdgeIntersections;
        if (shape === "linear" || shape === "spline") {
          getEdgeIntersections = getLinearEdgeIntersections;
        } else if (shape === "hv" || shape === "vh") {
          getEdgeIntersections = getHVEdgeIntersections;
        } else if (shape === "hvh") getEdgeIntersections = getABAEdgeIntersections(0, xEdge0, xEdge1);
        else if (shape === "vhv") getEdgeIntersections = getABAEdgeIntersections(1, yEdge0, yEdge1);
        function getClosestCorner(pt1, pt2) {
          var dx = pt2[0] - pt1[0];
          var m = (pt2[1] - pt1[1]) / dx;
          var b = (pt1[1] * pt2[0] - pt2[1] * pt1[0]) / dx;
          if (b > 0) return [m > 0 ? xEdge0 : xEdge1, yEdge1];
          else return [m > 0 ? xEdge1 : xEdge0, yEdge0];
        }
        function updateEdge(pt) {
          var x = pt[0];
          var y = pt[1];
          var xSame = x === pts[pti - 1][0];
          var ySame = y === pts[pti - 1][1];
          if (xSame && ySame) return;
          if (pti > 1) {
            var xSame2 = x === pts[pti - 2][0];
            var ySame2 = y === pts[pti - 2][1];
            if (xSame && (x === xEdge0 || x === xEdge1) && xSame2) {
              if (ySame2) pti--;
              else pts[pti - 1] = pt;
            } else if (ySame && (y === yEdge0 || y === yEdge1) && ySame2) {
              if (xSame2) pti--;
              else pts[pti - 1] = pt;
            } else pts[pti++] = pt;
          } else pts[pti++] = pt;
        }
        function updateEdgesForReentry(pt) {
          if (pts[pti - 1][0] !== pt[0] && pts[pti - 1][1] !== pt[1]) {
            updateEdge([lastXEdge, lastYEdge]);
          }
          updateEdge(pt);
          lastFarPt = null;
          lastXEdge = lastYEdge = 0;
        }
        var arrayMarker = Lib.isArrayOrTypedArray(marker);
        function addPt(pt) {
          if (pt && backoff) {
            pt.i = i;
            pt.d = d;
            pt.trace = trace;
            pt.marker = arrayMarker ? marker[pt.i] : marker;
            pt.backoff = backoff;
          }
          latestXFrac = pt[0] / xLen;
          latestYFrac = pt[1] / yLen;
          xEdge = pt[0] < xEdge0 ? xEdge0 : pt[0] > xEdge1 ? xEdge1 : 0;
          yEdge = pt[1] < yEdge0 ? yEdge0 : pt[1] > yEdge1 ? yEdge1 : 0;
          if (xEdge || yEdge) {
            if (!pti) {
              pts[pti++] = [xEdge || pt[0], yEdge || pt[1]];
            } else if (lastFarPt) {
              var intersections = getEdgeIntersections(lastFarPt, pt);
              if (intersections.length > 1) {
                updateEdgesForReentry(intersections[0]);
                pts[pti++] = intersections[1];
              }
            } else {
              edgePt = getEdgeIntersections(pts[pti - 1], pt)[0];
              pts[pti++] = edgePt;
            }
            var lastPt = pts[pti - 1];
            if (xEdge && yEdge && (lastPt[0] !== xEdge || lastPt[1] !== yEdge)) {
              if (lastFarPt) {
                if (lastXEdge !== xEdge && lastYEdge !== yEdge) {
                  if (lastXEdge && lastYEdge) {
                    updateEdge(getClosestCorner(lastFarPt, pt));
                  } else {
                    updateEdge([lastXEdge || xEdge, lastYEdge || yEdge]);
                  }
                } else if (lastXEdge && lastYEdge) {
                  updateEdge([lastXEdge, lastYEdge]);
                }
              }
              updateEdge([xEdge, yEdge]);
            } else if (lastXEdge - xEdge && lastYEdge - yEdge) {
              updateEdge([xEdge || lastXEdge, yEdge || lastYEdge]);
            }
            lastFarPt = pt;
            lastXEdge = xEdge;
            lastYEdge = yEdge;
          } else {
            if (lastFarPt) {
              updateEdgesForReentry(getEdgeIntersections(lastFarPt, pt)[0]);
            }
            pts[pti++] = pt;
          }
        }
        for (i = 0; i < len; i++) {
          clusterStartPt = getPt(i);
          if (!clusterStartPt) continue;
          pti = 0;
          lastFarPt = null;
          addPt(clusterStartPt);
          for (i++; i < len; i++) {
            clusterHighPt = getPt(i);
            if (!clusterHighPt) {
              if (connectGaps) continue;
              else break;
            }
            if (!linear || !opts.simplify) {
              addPt(clusterHighPt);
              continue;
            }
            var nextPt = getPt(i + 1);
            clusterRefDist = ptDist(clusterHighPt, clusterStartPt);
            if (!(fill && (pti === 0 || pti === len - 1)) && clusterRefDist < getTolerance(clusterHighPt, nextPt) * minTolerance) continue;
            clusterUnitVector = [
              (clusterHighPt[0] - clusterStartPt[0]) / clusterRefDist,
              (clusterHighPt[1] - clusterStartPt[1]) / clusterRefDist
            ];
            clusterLowPt = clusterStartPt;
            clusterHighVal = clusterRefDist;
            clusterLowVal = clusterMinDeviation = clusterMaxDeviation = 0;
            clusterHighFirst = false;
            clusterEndPt = clusterHighPt;
            for (i++; i < d.length; i++) {
              thisPt = nextPt;
              nextPt = getPt(i + 1);
              if (!thisPt) {
                if (connectGaps) continue;
                else break;
              }
              thisVector = [
                thisPt[0] - clusterStartPt[0],
                thisPt[1] - clusterStartPt[1]
              ];
              thisDeviation = thisVector[0] * clusterUnitVector[1] - thisVector[1] * clusterUnitVector[0];
              clusterMinDeviation = Math.min(clusterMinDeviation, thisDeviation);
              clusterMaxDeviation = Math.max(clusterMaxDeviation, thisDeviation);
              if (clusterMaxDeviation - clusterMinDeviation > getTolerance(thisPt, nextPt)) break;
              clusterEndPt = thisPt;
              thisVal = thisVector[0] * clusterUnitVector[0] + thisVector[1] * clusterUnitVector[1];
              if (thisVal > clusterHighVal) {
                clusterHighVal = thisVal;
                clusterHighPt = thisPt;
                clusterHighFirst = false;
              } else if (thisVal < clusterLowVal) {
                clusterLowVal = thisVal;
                clusterLowPt = thisPt;
                clusterHighFirst = true;
              }
            }
            if (clusterHighFirst) {
              addPt(clusterHighPt);
              if (clusterEndPt !== clusterLowPt) addPt(clusterLowPt);
            } else {
              if (clusterLowPt !== clusterStartPt) addPt(clusterLowPt);
              if (clusterEndPt !== clusterHighPt) addPt(clusterHighPt);
            }
            addPt(clusterEndPt);
            if (i >= d.length || !thisPt) break;
            addPt(thisPt);
            clusterStartPt = thisPt;
          }
          if (lastFarPt) updateEdge([lastXEdge || lastFarPt[0], lastYEdge || lastFarPt[1]]);
          segments.push(pts.slice(0, pti));
        }
        var lastShapeChar = shape.slice(shape.length - 1);
        if (backoff && lastShapeChar !== "h" && lastShapeChar !== "v") {
          var trimmed = false;
          var n = -1;
          var newSegments = [];
          for (var j = 0; j < segments.length; j++) {
            for (var k = 0; k < segments[j].length - 1; k++) {
              var start = segments[j][k];
              var end = segments[j][k + 1];
              var xy = Drawing.applyBackoff(end, start);
              if (xy[0] !== end[0] || xy[1] !== end[1]) {
                trimmed = true;
              }
              if (!newSegments[n + 1]) {
                n++;
                newSegments[n] = [
                  start,
                  [xy[0], xy[1]]
                ];
              }
            }
          }
          return trimmed ? newSegments : segments;
        }
        return segments;
      };
    }
  });

  // src/traces/scatter/link_traces.js
  var require_link_traces = __commonJS({
    "src/traces/scatter/link_traces.js"(exports, module) {
      "use strict";
      var LINKEDFILLS = { tonextx: 1, tonexty: 1, tonext: 1 };
      module.exports = function linkTraces(gd, plotinfo, cdscatter) {
        var trace, i, group, prevtrace, groupIndex;
        var groupIndices = {};
        var needsSort = false;
        var prevGroupIndex = -1;
        var nextGroupIndex = 0;
        var prevUnstackedGroupIndex = -1;
        for (i = 0; i < cdscatter.length; i++) {
          trace = cdscatter[i][0].trace;
          group = trace.stackgroup || "";
          if (group) {
            if (group in groupIndices) {
              groupIndex = groupIndices[group];
            } else {
              groupIndex = groupIndices[group] = nextGroupIndex;
              nextGroupIndex++;
            }
          } else if (trace.fill in LINKEDFILLS && prevUnstackedGroupIndex >= 0) {
            groupIndex = prevUnstackedGroupIndex;
          } else {
            groupIndex = prevUnstackedGroupIndex = nextGroupIndex;
            nextGroupIndex++;
          }
          if (groupIndex < prevGroupIndex) needsSort = true;
          trace._groupIndex = prevGroupIndex = groupIndex;
        }
        var cdscatterSorted = cdscatter.slice();
        if (needsSort) {
          cdscatterSorted.sort(function(a, b) {
            var traceA = a[0].trace;
            var traceB = b[0].trace;
            return traceA._groupIndex - traceB._groupIndex || traceA.index - traceB.index;
          });
        }
        var prevtraces = {};
        for (i = 0; i < cdscatterSorted.length; i++) {
          trace = cdscatterSorted[i][0].trace;
          group = trace.stackgroup || "";
          if (trace.visible === true) {
            trace._nexttrace = null;
            if (trace.fill in LINKEDFILLS) {
              prevtrace = prevtraces[group];
              trace._prevtrace = prevtrace || null;
              if (prevtrace) {
                prevtrace._nexttrace = trace;
              }
            }
            trace._ownfill = trace.fill && (trace.fill.substr(0, 6) === "tozero" || trace.fill === "toself" || trace.fill.substr(0, 2) === "to" && !trace._prevtrace);
            prevtraces[group] = trace;
          } else {
            trace._prevtrace = trace._nexttrace = trace._ownfill = null;
          }
        }
        return cdscatterSorted;
      };
    }
  });

  // src/traces/scatter/plot.js
  var require_plot = __commonJS({
    "src/traces/scatter/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var ensureSingle = Lib.ensureSingle;
      var identity = Lib.identity;
      var Drawing = require_drawing();
      var subTypes = require_subtypes();
      var linePoints = require_line_points();
      var linkTraces = require_link_traces();
      var polygonTester = require_polygon().tester;
      module.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {
        var join, onComplete;
        var isFullReplot = !transitionOpts;
        var hasTransition = !!transitionOpts && transitionOpts.duration > 0;
        var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);
        join = scatterLayer.selectAll("g.trace").data(cdscatterSorted, function(d) {
          return d[0].trace.uid;
        });
        join.enter().append("g").attr("class", function(d) {
          return "trace scatter trace" + d[0].trace.uid;
        }).style("stroke-miterlimit", 2);
        join.order();
        createFills(gd, join, plotinfo);
        if (hasTransition) {
          if (makeOnCompleteCallback) {
            onComplete = makeOnCompleteCallback();
          }
          var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each("end", function() {
            onComplete && onComplete();
          }).each("interrupt", function() {
            onComplete && onComplete();
          });
          transition.each(function() {
            scatterLayer.selectAll("g.trace").each(function(d, i) {
              plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);
            });
          });
        } else {
          join.each(function(d, i) {
            plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);
          });
        }
        if (isFullReplot) {
          join.exit().remove();
        }
        scatterLayer.selectAll("path:not([d])").remove();
      };
      function createFills(gd, traceJoin, plotinfo) {
        traceJoin.each(function(d) {
          var fills = ensureSingle(d3.select(this), "g", "fills");
          Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);
          var trace = d[0].trace;
          var fillData = [];
          if (trace._ownfill) fillData.push("_ownFill");
          if (trace._nexttrace) fillData.push("_nextFill");
          var fillJoin = fills.selectAll("g").data(fillData, identity);
          fillJoin.enter().append("g");
          fillJoin.exit().each(function(d2) {
            trace[d2] = null;
          }).remove();
          fillJoin.order().each(function(d2) {
            trace[d2] = ensureSingle(d3.select(this), "path", "js-fill");
          });
        });
      }
      function plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {
        var isStatic = gd._context.staticPlot;
        var i;
        selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);
        var hasTransition = !!transitionOpts && transitionOpts.duration > 0;
        function transition(selection) {
          return hasTransition ? selection.transition() : selection;
        }
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var trace = cdscatter[0].trace;
        var line = trace.line;
        var tr = d3.select(element);
        var errorBarGroup = ensureSingle(tr, "g", "errorbars");
        var lines = ensureSingle(tr, "g", "lines");
        var points = ensureSingle(tr, "g", "points");
        var text = ensureSingle(tr, "g", "text");
        Registry.getComponentMethod("errorbars", "plot")(gd, errorBarGroup, plotinfo, transitionOpts);
        if (trace.visible !== true) return;
        transition(tr).style("opacity", trace.opacity);
        var ownFillEl3, tonext;
        var ownFillDir = trace.fill.charAt(trace.fill.length - 1);
        if (ownFillDir !== "x" && ownFillDir !== "y") ownFillDir = "";
        var fillAxisIndex, fillAxisZero;
        if (ownFillDir === "y") {
          fillAxisIndex = 1;
          fillAxisZero = ya.c2p(0, true);
        } else if (ownFillDir === "x") {
          fillAxisIndex = 0;
          fillAxisZero = xa.c2p(0, true);
        }
        cdscatter[0][plotinfo.isRangePlot ? "nodeRangePlot3" : "node3"] = tr;
        var prevRevpath = "";
        var prevPolygons = [];
        var prevtrace = trace._prevtrace;
        var prevFillsegments = null;
        var prevFillElement = null;
        if (prevtrace) {
          prevRevpath = prevtrace._prevRevpath || "";
          tonext = prevtrace._nextFill;
          prevPolygons = prevtrace._ownPolygons;
          prevFillsegments = prevtrace._fillsegments;
          prevFillElement = prevtrace._fillElement;
        }
        var thispath;
        var thisrevpath;
        var fullpath = "";
        var revpath = "";
        var pathfn, revpathbase, revpathfn;
        var pt0, lastSegment, pt1;
        var thisPolygons = [];
        trace._polygons = [];
        var fillsegments = [];
        var segments = [];
        var makeUpdate = Lib.noop;
        ownFillEl3 = trace._ownFill;
        if (subTypes.hasLines(trace) || trace.fill !== "none") {
          if (tonext) {
            tonext.datum(cdscatter);
          }
          if (["hv", "vh", "hvh", "vhv"].indexOf(line.shape) !== -1) {
            pathfn = Drawing.steps(line.shape);
            revpathbase = Drawing.steps(
              line.shape.split("").reverse().join("")
            );
          } else if (line.shape === "spline") {
            pathfn = revpathbase = function(pts2) {
              var pLast = pts2[pts2.length - 1];
              if (pts2.length > 1 && pts2[0][0] === pLast[0] && pts2[0][1] === pLast[1]) {
                return Drawing.smoothclosed(pts2.slice(1), line.smoothing);
              } else {
                return Drawing.smoothopen(pts2, line.smoothing);
              }
            };
          } else {
            pathfn = revpathbase = function(pts2) {
              return "M" + pts2.join("L");
            };
          }
          revpathfn = function(pts2) {
            return revpathbase(pts2.reverse());
          };
          segments = linePoints(cdscatter, {
            xaxis: xa,
            yaxis: ya,
            trace,
            connectGaps: trace.connectgaps,
            baseTolerance: Math.max(line.width || 1, 3) / 4,
            shape: line.shape,
            backoff: line.backoff,
            simplify: line.simplify,
            fill: trace.fill
          });
          fillsegments = new Array(segments.length);
          var fillsegmentCount = 0;
          for (i = 0; i < segments.length; i++) {
            var curpoints;
            var pts = segments[i];
            if (!curpoints || !ownFillDir) {
              curpoints = pts.slice();
              fillsegments[fillsegmentCount] = curpoints;
              fillsegmentCount++;
            } else {
              curpoints.push.apply(curpoints, pts);
            }
          }
          trace._fillElement = null;
          trace._fillExclusionElement = prevFillElement;
          trace._fillsegments = fillsegments.slice(0, fillsegmentCount);
          fillsegments = trace._fillsegments;
          if (segments.length) {
            pt0 = segments[0][0].slice();
            lastSegment = segments[segments.length - 1];
            pt1 = lastSegment[lastSegment.length - 1].slice();
          }
          makeUpdate = function(isEnter) {
            return function(pts2) {
              thispath = pathfn(pts2);
              thisrevpath = revpathfn(pts2);
              if (!fullpath) {
                fullpath = thispath;
                revpath = thisrevpath;
              } else if (ownFillDir) {
                fullpath += "L" + thispath.substr(1);
                revpath = thisrevpath + ("L" + revpath.substr(1));
              } else {
                fullpath += "Z" + thispath;
                revpath = thisrevpath + "Z" + revpath;
              }
              if (subTypes.hasLines(trace)) {
                var el = d3.select(this);
                el.datum(cdscatter);
                if (isEnter) {
                  transition(el.style("opacity", 0).attr("d", thispath).call(Drawing.lineGroupStyle)).style("opacity", 1);
                } else {
                  var sel = transition(el);
                  sel.attr("d", thispath);
                  Drawing.singleLineStyle(cdscatter, sel);
                }
              }
            };
          };
        }
        var lineJoin = lines.selectAll(".js-line").data(segments);
        transition(lineJoin.exit()).style("opacity", 0).remove();
        lineJoin.each(makeUpdate(false));
        lineJoin.enter().append("path").classed("js-line", true).style("vector-effect", isStatic ? "none" : "non-scaling-stroke").call(Drawing.lineGroupStyle).each(makeUpdate(true));
        Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);
        function clearFill(selection) {
          transition(selection).attr("d", "M0,0Z");
        }
        var makeSelfPolygons = function() {
          var polygons = new Array(fillsegments.length);
          for (i = 0; i < fillsegments.length; i++) {
            polygons[i] = polygonTester(fillsegments[i]);
          }
          return polygons;
        };
        var makePolygonsToPrevious = function(prevFillsegments2) {
          var polygons, i2;
          if (!prevFillsegments2 || prevFillsegments2.length === 0) {
            polygons = new Array(fillsegments.length);
            for (i2 = 0; i2 < fillsegments.length; i2++) {
              var pt02 = fillsegments[i2][0].slice();
              var pt12 = fillsegments[i2][fillsegments[i2].length - 1].slice();
              pt02[fillAxisIndex] = pt12[fillAxisIndex] = fillAxisZero;
              var zeropoints = [pt12, pt02];
              var polypoints = zeropoints.concat(fillsegments[i2]);
              polygons[i2] = polygonTester(polypoints);
            }
          } else {
            polygons = new Array(prevFillsegments2.length - 1 + fillsegments.length);
            for (i2 = 0; i2 < prevFillsegments2.length - 1; i2++) {
              polygons[i2] = polygonTester(prevFillsegments2[i2]);
            }
            var reversedPrevFillsegment = prevFillsegments2[prevFillsegments2.length - 1].slice();
            reversedPrevFillsegment.reverse();
            for (i2 = 0; i2 < fillsegments.length; i2++) {
              polygons[prevFillsegments2.length - 1 + i2] = polygonTester(fillsegments[i2].concat(reversedPrevFillsegment));
            }
          }
          return polygons;
        };
        if (segments.length) {
          if (ownFillEl3) {
            ownFillEl3.datum(cdscatter);
            if (pt0 && pt1) {
              if (ownFillDir) {
                pt0[fillAxisIndex] = pt1[fillAxisIndex] = fillAxisZero;
                transition(ownFillEl3).attr("d", "M" + pt1 + "L" + pt0 + "L" + fullpath.substr(1)).call(Drawing.singleFillStyle, gd);
                thisPolygons = makePolygonsToPrevious(null);
              } else {
                transition(ownFillEl3).attr("d", fullpath + "Z").call(Drawing.singleFillStyle, gd);
                thisPolygons = makeSelfPolygons();
              }
            }
            trace._polygons = thisPolygons;
            trace._fillElement = ownFillEl3;
          } else if (tonext) {
            if (trace.fill.substr(0, 6) === "tonext" && fullpath && prevRevpath) {
              if (trace.fill === "tonext") {
                transition(tonext).attr("d", fullpath + "Z" + prevRevpath + "Z").call(Drawing.singleFillStyle, gd);
                thisPolygons = makeSelfPolygons();
                trace._polygons = thisPolygons.concat(prevPolygons);
              } else {
                transition(tonext).attr("d", fullpath + "L" + prevRevpath.substr(1) + "Z").call(Drawing.singleFillStyle, gd);
                thisPolygons = makePolygonsToPrevious(prevFillsegments);
                trace._polygons = thisPolygons;
              }
              trace._fillElement = tonext;
            } else {
              clearFill(tonext);
            }
          }
          trace._prevRevpath = revpath;
        } else {
          if (ownFillEl3) clearFill(ownFillEl3);
          else if (tonext) clearFill(tonext);
          trace._prevRevpath = null;
        }
        trace._ownPolygons = thisPolygons;
        function visFilter(d) {
          return d.filter(function(v) {
            return !v.gap && v.vis;
          });
        }
        function visFilterWithGaps(d) {
          return d.filter(function(v) {
            return v.vis;
          });
        }
        function gapFilter(d) {
          return d.filter(function(v) {
            return !v.gap;
          });
        }
        function keyFunc(d) {
          return d.id;
        }
        function getKeyFunc(trace2) {
          if (trace2.ids) {
            return keyFunc;
          }
        }
        function hideFilter() {
          return false;
        }
        function makePoints(points2, text2, cdscatter2) {
          var join, selection, hasNode;
          var trace2 = cdscatter2[0].trace;
          var showMarkers = subTypes.hasMarkers(trace2);
          var showText = subTypes.hasText(trace2);
          var keyFunc2 = getKeyFunc(trace2);
          var markerFilter = hideFilter;
          var textFilter = hideFilter;
          if (showMarkers || showText) {
            var showFilter = identity;
            var stackGroup = trace2.stackgroup;
            var isInferZero = stackGroup && gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === "infer zero";
            if (trace2.marker.maxdisplayed || trace2._needsCull) {
              showFilter = isInferZero ? visFilterWithGaps : visFilter;
            } else if (stackGroup && !isInferZero) {
              showFilter = gapFilter;
            }
            if (showMarkers) markerFilter = showFilter;
            if (showText) textFilter = showFilter;
          }
          selection = points2.selectAll("path.point");
          join = selection.data(markerFilter, keyFunc2);
          var enter = join.enter().append("path").classed("point", true);
          if (hasTransition) {
            enter.call(Drawing.pointStyle, trace2, gd).call(Drawing.translatePoints, xa, ya).style("opacity", 0).transition().style("opacity", 1);
          }
          join.order();
          var styleFns;
          if (showMarkers) {
            styleFns = Drawing.makePointStyleFns(trace2);
          }
          join.each(function(d) {
            var el = d3.select(this);
            var sel = transition(el);
            hasNode = Drawing.translatePoint(d, sel, xa, ya);
            if (hasNode) {
              Drawing.singlePointStyle(d, sel, trace2, styleFns, gd);
              if (plotinfo.layerClipId) {
                Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace2.xcalendar, trace2.ycalendar);
              }
              if (trace2.customdata) {
                el.classed("plotly-customdata", d.data !== null && d.data !== void 0);
              }
            } else {
              sel.remove();
            }
          });
          if (hasTransition) {
            join.exit().transition().style("opacity", 0).remove();
          } else {
            join.exit().remove();
          }
          selection = text2.selectAll("g");
          join = selection.data(textFilter, keyFunc2);
          join.enter().append("g").classed("textpoint", true).append("text");
          join.order();
          join.each(function(d) {
            var g = d3.select(this);
            var sel = transition(g.select("text"));
            hasNode = Drawing.translatePoint(d, sel, xa, ya);
            if (hasNode) {
              if (plotinfo.layerClipId) {
                Drawing.hideOutsideRangePoint(d, g, xa, ya, trace2.xcalendar, trace2.ycalendar);
              }
            } else {
              g.remove();
            }
          });
          join.selectAll("text").call(Drawing.textPointStyle, trace2, gd).each(function(d) {
            var x = xa.c2p(d.x);
            var y = ya.c2p(d.y);
            d3.select(this).selectAll("tspan.line").each(function() {
              transition(d3.select(this)).attr({ x, y });
            });
          });
          join.exit().remove();
        }
        points.datum(cdscatter);
        text.datum(cdscatter);
        makePoints(points, text, cdscatter);
        var hasClipOnAxisFalse = trace.cliponaxis === false;
        var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;
        Drawing.setClipUrl(points, clipUrl, gd);
        Drawing.setClipUrl(text, clipUrl, gd);
      }
      function selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));
        var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));
        var trace = cdscatter[0].trace;
        if (!subTypes.hasMarkers(trace)) return;
        var mnum = trace.marker.maxdisplayed;
        if (mnum === 0) return;
        var cd = cdscatter.filter(function(v) {
          return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];
        });
        var inc = Math.ceil(cd.length / mnum);
        var tnum = 0;
        cdscatterAll.forEach(function(cdj, j) {
          var tracei = cdj[0].trace;
          if (subTypes.hasMarkers(tracei) && tracei.marker.maxdisplayed > 0 && j < idx) {
            tnum++;
          }
        });
        var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1);
        cdscatter.forEach(function(v) {
          delete v.vis;
        });
        cd.forEach(function(v, i) {
          if (Math.round((i + i0) % inc) === 0) v.vis = true;
        });
      }
    }
  });

  // src/traces/scatter/marker_colorbar.js
  var require_marker_colorbar = __commonJS({
    "src/traces/scatter/marker_colorbar.js"(exports, module) {
      "use strict";
      module.exports = {
        container: "marker",
        min: "cmin",
        max: "cmax"
      };
    }
  });

  // src/traces/scatter/format_labels.js
  var require_format_labels = __commonJS({
    "src/traces/scatter/format_labels.js"(exports, module) {
      "use strict";
      var Axes = require_axes();
      module.exports = function formatLabels(cdi, trace, fullLayout) {
        var labels = {};
        var mockGd = { _fullLayout: fullLayout };
        var xa = Axes.getFromTrace(mockGd, trace, "x");
        var ya = Axes.getFromTrace(mockGd, trace, "y");
        var x = cdi.orig_x;
        if (x === void 0) x = cdi.x;
        var y = cdi.orig_y;
        if (y === void 0) y = cdi.y;
        labels.xLabel = Axes.tickText(xa, xa.c2l(x), true).text;
        labels.yLabel = Axes.tickText(ya, ya.c2l(y), true).text;
        return labels;
      };
    }
  });

  // src/traces/scatter/style.js
  var require_style2 = __commonJS({
    "src/traces/scatter/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Drawing = require_drawing();
      var Registry = require_registry();
      function style(gd) {
        var s = d3.select(gd).selectAll("g.trace.scatter");
        s.style("opacity", function(d) {
          return d[0].trace.opacity;
        });
        s.selectAll("g.points").each(function(d) {
          var sel = d3.select(this);
          var trace = d.trace || d[0].trace;
          stylePoints(sel, trace, gd);
        });
        s.selectAll("g.text").each(function(d) {
          var sel = d3.select(this);
          var trace = d.trace || d[0].trace;
          styleText(sel, trace, gd);
        });
        s.selectAll("g.trace path.js-line").call(Drawing.lineGroupStyle);
        s.selectAll("g.trace path.js-fill").call(Drawing.fillGroupStyle, gd, false);
        Registry.getComponentMethod("errorbars", "style")(s);
      }
      function stylePoints(sel, trace, gd) {
        Drawing.pointStyle(sel.selectAll("path.point"), trace, gd);
      }
      function styleText(sel, trace, gd) {
        Drawing.textPointStyle(sel.selectAll("text"), trace, gd);
      }
      function styleOnSelect(gd, cd, sel) {
        var trace = cd[0].trace;
        if (trace.selectedpoints) {
          Drawing.selectedPointStyle(sel.selectAll("path.point"), trace);
          Drawing.selectedTextStyle(sel.selectAll("text"), trace);
        } else {
          stylePoints(sel, trace, gd);
          styleText(sel, trace, gd);
        }
      }
      module.exports = {
        style,
        stylePoints,
        styleText,
        styleOnSelect
      };
    }
  });

  // src/traces/scatter/get_trace_color.js
  var require_get_trace_color = __commonJS({
    "src/traces/scatter/get_trace_color.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var subtypes = require_subtypes();
      module.exports = function getTraceColor(trace, di) {
        var lc, tc;
        if (trace.mode === "lines") {
          lc = trace.line.color;
          return lc && Color.opacity(lc) ? lc : trace.fillcolor;
        } else if (trace.mode === "none") {
          return trace.fill ? trace.fillcolor : "";
        } else {
          var mc = di.mcc || (trace.marker || {}).color;
          var mlc = di.mlcc || ((trace.marker || {}).line || {}).color;
          tc = mc && Color.opacity(mc) ? mc : mlc && Color.opacity(mlc) && (di.mlw || ((trace.marker || {}).line || {}).width) ? mlc : "";
          if (tc) {
            if (Color.opacity(tc) < 0.3) {
              return Color.addOpacity(tc, 0.3);
            } else return tc;
          } else {
            lc = (trace.line || {}).color;
            return lc && Color.opacity(lc) && subtypes.hasLines(trace) && trace.line.width ? lc : trace.fillcolor;
          }
        }
      };
    }
  });

  // src/traces/scatter/hover.js
  var require_hover2 = __commonJS({
    "src/traces/scatter/hover.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Fx = require_fx();
      var Registry = require_registry();
      var getTraceColor = require_get_trace_color();
      var Color = require_color();
      var fillText = Lib.fillText;
      module.exports = function hoverPoints(pointData, xval, yval, hovermode) {
        var cd = pointData.cd;
        var trace = cd[0].trace;
        var xa = pointData.xa;
        var ya = pointData.ya;
        var xpx = xa.c2p(xval);
        var ypx = ya.c2p(yval);
        var pt = [xpx, ypx];
        var hoveron = trace.hoveron || "";
        var minRad = trace.mode.indexOf("markers") !== -1 ? 3 : 0.5;
        var xPeriod = !!trace.xperiodalignment;
        var yPeriod = !!trace.yperiodalignment;
        if (hoveron.indexOf("points") !== -1) {
          var dx = function(di2) {
            if (xPeriod) {
              var x0 = xa.c2p(di2.xStart);
              var x1 = xa.c2p(di2.xEnd);
              return xpx >= Math.min(x0, x1) && xpx <= Math.max(x0, x1) ? 0 : Infinity;
            }
            var rad2 = Math.max(3, di2.mrc || 0);
            var kink = 1 - 1 / rad2;
            var dxRaw = Math.abs(xa.c2p(di2.x) - xpx);
            return dxRaw < rad2 ? kink * dxRaw / rad2 : dxRaw - rad2 + kink;
          };
          var dy = function(di2) {
            if (yPeriod) {
              var y0 = ya.c2p(di2.yStart);
              var y1 = ya.c2p(di2.yEnd);
              return ypx >= Math.min(y0, y1) && ypx <= Math.max(y0, y1) ? 0 : Infinity;
            }
            var rad2 = Math.max(3, di2.mrc || 0);
            var kink = 1 - 1 / rad2;
            var dyRaw = Math.abs(ya.c2p(di2.y) - ypx);
            return dyRaw < rad2 ? kink * dyRaw / rad2 : dyRaw - rad2 + kink;
          };
          var dxy = function(di2) {
            var rad2 = Math.max(minRad, di2.mrc || 0);
            var dx2 = xa.c2p(di2.x) - xpx;
            var dy2 = ya.c2p(di2.y) - ypx;
            return Math.max(Math.sqrt(dx2 * dx2 + dy2 * dy2) - rad2, 1 - minRad / rad2);
          };
          var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);
          Fx.getClosest(cd, distfn, pointData);
          if (pointData.index !== false) {
            var di = cd[pointData.index];
            var xc = xa.c2p(di.x, true);
            var yc = ya.c2p(di.y, true);
            var rad = di.mrc || 1;
            pointData.index = di.i;
            var orientation = cd[0].t.orientation;
            var sizeVal = orientation && (di.sNorm || di.s);
            var xLabelVal = orientation === "h" ? sizeVal : di.orig_x !== void 0 ? di.orig_x : di.x;
            var yLabelVal = orientation === "v" ? sizeVal : di.orig_y !== void 0 ? di.orig_y : di.y;
            Lib.extendFlat(pointData, {
              color: getTraceColor(trace, di),
              x0: xc - rad,
              x1: xc + rad,
              xLabelVal,
              y0: yc - rad,
              y1: yc + rad,
              yLabelVal,
              spikeDistance: dxy(di),
              hovertemplate: trace.hovertemplate
            });
            fillText(di, trace, pointData);
            Registry.getComponentMethod("errorbars", "hoverInfo")(di, trace, pointData);
            return [pointData];
          }
        }
        function isHoverPointInFillElement(el) {
          if (!el) {
            return false;
          }
          var svgElement = el.node();
          try {
            var domPoint = new DOMPoint(pt[0], pt[1]);
            return svgElement.isPointInFill(domPoint);
          } catch (TypeError2) {
            var svgPoint = svgElement.ownerSVGElement.createSVGPoint();
            svgPoint.x = pt[0];
            svgPoint.y = pt[1];
            return svgElement.isPointInFill(svgPoint);
          }
        }
        function getHoverLabelPosition(polygons) {
          var i;
          var polygonsIn = [];
          var xmin = Infinity;
          var xmax = -Infinity;
          var ymin = Infinity;
          var ymax = -Infinity;
          var yPos;
          for (i = 0; i < polygons.length; i++) {
            var polygon = polygons[i];
            if (polygon.contains(pt)) {
              polygonsIn.push(polygon);
              ymin = Math.min(ymin, polygon.ymin);
              ymax = Math.max(ymax, polygon.ymax);
            }
          }
          if (polygonsIn.length === 0) {
            return null;
          }
          ymin = Math.max(ymin, 0);
          ymax = Math.min(ymax, ya._length);
          yPos = (ymin + ymax) / 2;
          var j, pts, xAtYPos, x0, x1, y0, y1;
          for (i = 0; i < polygonsIn.length; i++) {
            pts = polygonsIn[i].pts;
            for (j = 1; j < pts.length; j++) {
              y0 = pts[j - 1][1];
              y1 = pts[j][1];
              if (y0 > yPos !== y1 >= yPos) {
                x0 = pts[j - 1][0];
                x1 = pts[j][0];
                if (y1 - y0) {
                  xAtYPos = x0 + (x1 - x0) * (yPos - y0) / (y1 - y0);
                  xmin = Math.min(xmin, xAtYPos);
                  xmax = Math.max(xmax, xAtYPos);
                }
              }
            }
          }
          xmin = Math.max(xmin, 0);
          xmax = Math.min(xmax, xa._length);
          return {
            x0: xmin,
            x1: xmax,
            y0: yPos,
            y1: yPos
          };
        }
        if (hoveron.indexOf("fills") !== -1 && trace._fillElement) {
          var inside = isHoverPointInFillElement(trace._fillElement) && !isHoverPointInFillElement(trace._fillExclusionElement);
          if (inside) {
            var hoverLabelCoords = getHoverLabelPosition(trace._polygons);
            if (hoverLabelCoords === null) {
              hoverLabelCoords = {
                x0: pt[0],
                x1: pt[0],
                y0: pt[1],
                y1: pt[1]
              };
            }
            var color = Color.defaultLine;
            if (Color.opacity(trace.fillcolor)) color = trace.fillcolor;
            else if (Color.opacity((trace.line || {}).color)) {
              color = trace.line.color;
            }
            Lib.extendFlat(pointData, {
              // never let a 2D override 1D type as closest point
              // also: no spikeDistance, it's not allowed for fills
              distance: pointData.maxHoverDistance,
              x0: hoverLabelCoords.x0,
              x1: hoverLabelCoords.x1,
              y0: hoverLabelCoords.y0,
              y1: hoverLabelCoords.y1,
              color,
              hovertemplate: false
            });
            delete pointData.index;
            if (trace.text && !Lib.isArrayOrTypedArray(trace.text)) {
              pointData.text = String(trace.text);
            } else pointData.text = trace.name;
            return [pointData];
          }
        }
      };
    }
  });

  // src/traces/scatter/select.js
  var require_select2 = __commonJS({
    "src/traces/scatter/select.js"(exports, module) {
      "use strict";
      var subtypes = require_subtypes();
      module.exports = function selectPoints(searchInfo, selectionTester) {
        var cd = searchInfo.cd;
        var xa = searchInfo.xaxis;
        var ya = searchInfo.yaxis;
        var selection = [];
        var trace = cd[0].trace;
        var i;
        var di;
        var x;
        var y;
        var hasOnlyLines = !subtypes.hasMarkers(trace) && !subtypes.hasText(trace);
        if (hasOnlyLines) return [];
        if (selectionTester === false) {
          for (i = 0; i < cd.length; i++) {
            cd[i].selected = 0;
          }
        } else {
          for (i = 0; i < cd.length; i++) {
            di = cd[i];
            x = xa.c2p(di.x);
            y = ya.c2p(di.y);
            if (di.i !== null && selectionTester.contains([x, y], false, i, searchInfo)) {
              selection.push({
                pointNumber: di.i,
                x: xa.c2d(di.x),
                y: ya.c2d(di.y)
              });
              di.selected = 1;
            } else {
              di.selected = 0;
            }
          }
        }
        return selection;
      };
    }
  });

  // src/plots/cartesian/attributes.js
  var require_attributes14 = __commonJS({
    "src/plots/cartesian/attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        xaxis: {
          valType: "subplotid",
          dflt: "x",
          editType: "calc+clearAxisTypes"
        },
        yaxis: {
          valType: "subplotid",
          dflt: "y",
          editType: "calc+clearAxisTypes"
        }
      };
    }
  });

  // src/plots/cartesian/type_defaults.js
  var require_type_defaults = __commonJS({
    "src/plots/cartesian/type_defaults.js"(exports, module) {
      "use strict";
      var traceIs = require_registry().traceIs;
      var autoType = require_axis_autotype();
      module.exports = function handleTypeDefaults(containerIn, containerOut, coerce, options) {
        coerce("autotypenumbers", options.autotypenumbersDflt);
        var axType = coerce("type", (options.splomStash || {}).type);
        if (axType === "-") {
          setAutoType(containerOut, options.data);
          if (containerOut.type === "-") {
            containerOut.type = "linear";
          } else {
            containerIn.type = containerOut.type;
          }
        }
      };
      function setAutoType(ax, data) {
        if (ax.type !== "-") return;
        var id = ax._id;
        var axLetter = id.charAt(0);
        var i;
        if (id.indexOf("scene") !== -1) id = axLetter;
        var d0 = getFirstNonEmptyTrace(data, id, axLetter);
        if (!d0) return;
        if (d0.type === "histogram" && axLetter === { v: "y", h: "x" }[d0.orientation || "v"]) {
          ax.type = "linear";
          return;
        }
        var calAttr = axLetter + "calendar";
        var calendar = d0[calAttr];
        var opts = { noMultiCategory: !traceIs(d0, "cartesian") || traceIs(d0, "noMultiCategory") };
        if (d0.type === "box" && d0._hasPreCompStats && axLetter === { h: "x", v: "y" }[d0.orientation || "v"]) {
          opts.noMultiCategory = true;
        }
        opts.autotypenumbers = ax.autotypenumbers;
        if (isBoxWithoutPositionCoords(d0, axLetter)) {
          var posLetter = getBoxPosLetter(d0);
          var boxPositions = [];
          for (i = 0; i < data.length; i++) {
            var trace = data[i];
            if (!traceIs(trace, "box-violin") || (trace[axLetter + "axis"] || axLetter) !== id) continue;
            if (trace[posLetter] !== void 0) boxPositions.push(trace[posLetter][0]);
            else if (trace.name !== void 0) boxPositions.push(trace.name);
            else boxPositions.push("text");
            if (trace[calAttr] !== calendar) calendar = void 0;
          }
          ax.type = autoType(boxPositions, calendar, opts);
        } else if (d0.type === "splom") {
          var dimensions = d0.dimensions;
          var dim = dimensions[d0._axesDim[id]];
          if (dim.visible) ax.type = autoType(dim.values, calendar, opts);
        } else {
          ax.type = autoType(d0[axLetter] || [d0[axLetter + "0"]], calendar, opts);
        }
      }
      function getFirstNonEmptyTrace(data, id, axLetter) {
        for (var i = 0; i < data.length; i++) {
          var trace = data[i];
          if (trace.type === "splom" && trace._length > 0 && (trace["_" + axLetter + "axes"] || {})[id]) {
            return trace;
          }
          if ((trace[axLetter + "axis"] || axLetter) === id) {
            if (isBoxWithoutPositionCoords(trace, axLetter)) {
              return trace;
            } else if ((trace[axLetter] || []).length || trace[axLetter + "0"]) {
              return trace;
            }
          }
        }
      }
      function getBoxPosLetter(trace) {
        return { v: "x", h: "y" }[trace.orientation || "v"];
      }
      function isBoxWithoutPositionCoords(trace, axLetter) {
        var posLetter = getBoxPosLetter(trace);
        var isBox = traceIs(trace, "box-violin");
        var isCandlestick = traceIs(trace._fullInput || {}, "candlestick");
        return isBox && !isCandlestick && axLetter === posLetter && trace[posLetter] === void 0 && trace[posLetter + "0"] === void 0;
      }
    }
  });

  // src/plots/cartesian/category_order_defaults.js
  var require_category_order_defaults = __commonJS({
    "src/plots/cartesian/category_order_defaults.js"(exports, module) {
      "use strict";
      var isTypedArraySpec = require_array().isTypedArraySpec;
      function findCategories(ax, opts) {
        var dataAttr = opts.dataAttr || ax._id.charAt(0);
        var lookup = {};
        var axData;
        var i, j;
        if (opts.axData) {
          axData = opts.axData;
        } else {
          axData = [];
          for (i = 0; i < opts.data.length; i++) {
            var trace = opts.data[i];
            if (trace[dataAttr + "axis"] === ax._id) {
              axData.push(trace);
            }
          }
        }
        for (i = 0; i < axData.length; i++) {
          var vals = axData[i][dataAttr];
          for (j = 0; j < vals.length; j++) {
            var v = vals[j];
            if (v !== null && v !== void 0) {
              lookup[v] = 1;
            }
          }
        }
        return Object.keys(lookup);
      }
      module.exports = function handleCategoryOrderDefaults(containerIn, containerOut, coerce, opts) {
        if (containerOut.type !== "category") return;
        var arrayIn = containerIn.categoryarray;
        var isValidArray = Array.isArray(arrayIn) && arrayIn.length > 0 || isTypedArraySpec(arrayIn);
        var orderDefault;
        if (isValidArray) orderDefault = "array";
        var order = coerce("categoryorder", orderDefault);
        var array;
        if (order === "array") {
          array = coerce("categoryarray");
        }
        if (!isValidArray && order === "array") {
          order = containerOut.categoryorder = "trace";
        }
        if (order === "trace") {
          containerOut._initialCategories = [];
        } else if (order === "array") {
          containerOut._initialCategories = array.slice();
        } else {
          array = findCategories(containerOut, opts).sort();
          if (order === "category ascending") {
            containerOut._initialCategories = array;
          } else if (order === "category descending") {
            containerOut._initialCategories = array.reverse();
          }
        }
      };
    }
  });

  // src/plots/cartesian/line_grid_defaults.js
  var require_line_grid_defaults = __commonJS({
    "src/plots/cartesian/line_grid_defaults.js"(exports, module) {
      "use strict";
      var colorMix = require_tinycolor().mix;
      var colorAttrs = require_attributes3();
      var Lib = require_lib();
      module.exports = function handleLineGridDefaults(containerIn, containerOut, coerce, opts) {
        opts = opts || {};
        var dfltColor = opts.dfltColor;
        function coerce2(attr, dflt) {
          return Lib.coerce2(containerIn, containerOut, opts.attributes, attr, dflt);
        }
        var lineColor = coerce2("linecolor", dfltColor);
        var lineWidth = coerce2("linewidth");
        var showLine = coerce("showline", opts.showLine || !!lineColor || !!lineWidth);
        if (!showLine) {
          delete containerOut.linecolor;
          delete containerOut.linewidth;
        }
        var gridColorDflt = colorMix(dfltColor, opts.bgColor, opts.blend || colorAttrs.lightFraction).toRgbString();
        var gridColor = coerce2("gridcolor", gridColorDflt);
        var gridWidth = coerce2("gridwidth");
        var gridDash = coerce2("griddash");
        var showGridLines = coerce(
          "showgrid",
          opts.showGrid || !!gridColor || !!gridWidth || !!gridDash
        );
        if (!showGridLines) {
          delete containerOut.gridcolor;
          delete containerOut.gridwidth;
          delete containerOut.griddash;
        }
        if (opts.hasMinor) {
          var minorGridColorDflt = colorMix(containerOut.gridcolor, opts.bgColor, 67).toRgbString();
          var minorGridColor = coerce2("minor.gridcolor", minorGridColorDflt);
          var minorGridWidth = coerce2("minor.gridwidth", containerOut.gridwidth || 1);
          var minorGridDash = coerce2("minor.griddash", containerOut.griddash || "solid");
          var minorShowGridLines = coerce(
            "minor.showgrid",
            !!minorGridColor || !!minorGridWidth || !!minorGridDash
          );
          if (!minorShowGridLines) {
            delete containerOut.minor.gridcolor;
            delete containerOut.minor.gridwidth;
            delete containerOut.minor.griddash;
          }
        }
        if (!opts.noZeroLine) {
          var zeroLineColor = coerce2("zerolinecolor", dfltColor);
          var zeroLineWidth = coerce2("zerolinewidth");
          var showZeroLine = coerce("zeroline", opts.showGrid || !!zeroLineColor || !!zeroLineWidth);
          if (!showZeroLine) {
            delete containerOut.zerolinecolor;
            delete containerOut.zerolinewidth;
          }
        }
      };
    }
  });

  // src/plots/cartesian/axis_defaults.js
  var require_axis_defaults = __commonJS({
    "src/plots/cartesian/axis_defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Registry = require_registry();
      var Lib = require_lib();
      var Template = require_plot_template();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var layoutAttributes = require_layout_attributes4();
      var handleTickValueDefaults = require_tick_value_defaults();
      var handleTickMarkDefaults = require_tick_mark_defaults();
      var handleTickLabelDefaults = require_tick_label_defaults();
      var handlePrefixSuffixDefaults = require_prefix_suffix_defaults();
      var handleCategoryOrderDefaults = require_category_order_defaults();
      var handleLineGridDefaults = require_line_grid_defaults();
      var handleRangeDefaults = require_range_defaults();
      var setConvert = require_set_convert();
      var DAY_OF_WEEK = require_constants2().WEEKDAY_PATTERN;
      var HOUR = require_constants2().HOUR_PATTERN;
      module.exports = function handleAxisDefaults(containerIn, containerOut, coerce, options, layoutOut) {
        var letter = options.letter;
        var font = options.font || {};
        var splomStash = options.splomStash || {};
        var visible = coerce("visible", !options.visibleDflt);
        var axTemplate = containerOut._template || {};
        var axType = containerOut.type || axTemplate.type || "-";
        var ticklabelmode;
        if (axType === "date") {
          var handleCalendarDefaults = Registry.getComponentMethod("calendars", "handleDefaults");
          handleCalendarDefaults(containerIn, containerOut, "calendar", options.calendar);
          if (!options.noTicklabelmode) {
            ticklabelmode = coerce("ticklabelmode");
          }
        }
        if (!options.noTicklabelindex && (axType === "date" || axType === "linear")) {
          coerce("ticklabelindex");
        }
        var ticklabelposition = "";
        if (!options.noTicklabelposition || axType === "multicategory") {
          ticklabelposition = Lib.coerce(containerIn, containerOut, {
            ticklabelposition: {
              valType: "enumerated",
              dflt: "outside",
              values: ticklabelmode === "period" ? ["outside", "inside"] : letter === "x" ? [
                "outside",
                "inside",
                "outside left",
                "inside left",
                "outside right",
                "inside right"
              ] : [
                "outside",
                "inside",
                "outside top",
                "inside top",
                "outside bottom",
                "inside bottom"
              ]
            }
          }, "ticklabelposition");
        }
        if (!options.noTicklabeloverflow) {
          coerce(
            "ticklabeloverflow",
            ticklabelposition.indexOf("inside") !== -1 ? "hide past domain" : axType === "category" || axType === "multicategory" ? "allow" : "hide past div"
          );
        }
        setConvert(containerOut, layoutOut);
        handleRangeDefaults(containerIn, containerOut, coerce, options);
        handleCategoryOrderDefaults(containerIn, containerOut, coerce, options);
        if (axType !== "category" && !options.noHover) coerce("hoverformat");
        var dfltColor = coerce("color");
        var dfltFontColor = dfltColor !== layoutAttributes.color.dflt ? dfltColor : font.color;
        var dfltTitle = splomStash.label || layoutOut._dfltTitle[letter];
        handlePrefixSuffixDefaults(containerIn, containerOut, coerce, axType, options);
        if (!visible) return containerOut;
        coerce("title.text", dfltTitle);
        Lib.coerceFont(coerce, "title.font", font, { overrideDflt: {
          size: Lib.bigFont(font.size),
          color: dfltFontColor
        } });
        handleTickValueDefaults(containerIn, containerOut, coerce, axType);
        var hasMinor = options.hasMinor;
        if (hasMinor) {
          Template.newContainer(containerOut, "minor");
          handleTickValueDefaults(containerIn, containerOut, coerce, axType, { isMinor: true });
        }
        handleTickLabelDefaults(containerIn, containerOut, coerce, axType, options);
        handleTickMarkDefaults(containerIn, containerOut, coerce, options);
        if (hasMinor) {
          var keepIsMinor = options.isMinor;
          options.isMinor = true;
          handleTickMarkDefaults(containerIn, containerOut, coerce, options);
          options.isMinor = keepIsMinor;
        }
        handleLineGridDefaults(containerIn, containerOut, coerce, {
          dfltColor,
          bgColor: options.bgColor,
          showGrid: options.showGrid,
          hasMinor,
          attributes: layoutAttributes
        });
        if (hasMinor && !containerOut.minor.ticks && !containerOut.minor.showgrid) {
          delete containerOut.minor;
        }
        if (containerOut.showline || containerOut.ticks) coerce("mirror");
        var isMultiCategory = axType === "multicategory";
        if (!options.noTickson && (axType === "category" || isMultiCategory) && (containerOut.ticks || containerOut.showgrid)) {
          var ticksonDflt;
          if (isMultiCategory) ticksonDflt = "boundaries";
          var tickson = coerce("tickson", ticksonDflt);
          if (tickson === "boundaries") {
            delete containerOut.ticklabelposition;
          }
        }
        if (isMultiCategory) {
          var showDividers = coerce("showdividers");
          if (showDividers) {
            coerce("dividercolor");
            coerce("dividerwidth");
          }
        }
        if (axType === "date") {
          handleArrayContainerDefaults(containerIn, containerOut, {
            name: "rangebreaks",
            inclusionAttr: "enabled",
            handleItemDefaults: rangebreaksDefaults
          });
          if (!containerOut.rangebreaks.length) {
            delete containerOut.rangebreaks;
          } else {
            for (var k = 0; k < containerOut.rangebreaks.length; k++) {
              if (containerOut.rangebreaks[k].pattern === DAY_OF_WEEK) {
                containerOut._hasDayOfWeekBreaks = true;
                break;
              }
            }
            setConvert(containerOut, layoutOut);
            if (layoutOut._has("scattergl") || layoutOut._has("splom")) {
              for (var i = 0; i < options.data.length; i++) {
                var trace = options.data[i];
                if (trace.type === "scattergl" || trace.type === "splom") {
                  trace.visible = false;
                  Lib.warn(trace.type + " traces do not work on axes with rangebreaks. Setting trace " + trace.index + " to `visible: false`.");
                }
              }
            }
          }
        }
        return containerOut;
      };
      function rangebreaksDefaults(itemIn, itemOut, containerOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(itemIn, itemOut, layoutAttributes.rangebreaks, attr, dflt);
        }
        var enabled = coerce("enabled");
        if (enabled) {
          var bnds = coerce("bounds");
          if (bnds && bnds.length >= 2) {
            var dfltPattern = "";
            var i, q;
            if (bnds.length === 2) {
              for (i = 0; i < 2; i++) {
                q = indexOfDay(bnds[i]);
                if (q) {
                  dfltPattern = DAY_OF_WEEK;
                  break;
                }
              }
            }
            var pattern = coerce("pattern", dfltPattern);
            if (pattern === DAY_OF_WEEK) {
              for (i = 0; i < 2; i++) {
                q = indexOfDay(bnds[i]);
                if (q) {
                  itemOut.bounds[i] = bnds[i] = q - 1;
                }
              }
            }
            if (pattern) {
              for (i = 0; i < 2; i++) {
                q = bnds[i];
                switch (pattern) {
                  case DAY_OF_WEEK:
                    if (!isNumeric(q)) {
                      itemOut.enabled = false;
                      return;
                    }
                    q = +q;
                    if (q !== Math.floor(q) || // don't accept fractional days for mow
                    q < 0 || q >= 7) {
                      itemOut.enabled = false;
                      return;
                    }
                    itemOut.bounds[i] = bnds[i] = q;
                    break;
                  case HOUR:
                    if (!isNumeric(q)) {
                      itemOut.enabled = false;
                      return;
                    }
                    q = +q;
                    if (q < 0 || q > 24) {
                      itemOut.enabled = false;
                      return;
                    }
                    itemOut.bounds[i] = bnds[i] = q;
                    break;
                }
              }
            }
            if (containerOut.autorange === false) {
              var rng = containerOut.range;
              if (rng[0] < rng[1]) {
                if (bnds[0] < rng[0] && bnds[1] > rng[1]) {
                  itemOut.enabled = false;
                  return;
                }
              } else if (bnds[0] > rng[0] && bnds[1] < rng[1]) {
                itemOut.enabled = false;
                return;
              }
            }
          } else {
            var values = coerce("values");
            if (values && values.length) {
              coerce("dvalue");
            } else {
              itemOut.enabled = false;
              return;
            }
          }
        }
      }
      var dayStrToNum = {
        sun: 1,
        mon: 2,
        tue: 3,
        wed: 4,
        thu: 5,
        fri: 6,
        sat: 7
      };
      function indexOfDay(v) {
        if (typeof v !== "string") return;
        return dayStrToNum[v.substr(0, 3).toLowerCase()];
      }
    }
  });

  // src/plots/cartesian/position_defaults.js
  var require_position_defaults = __commonJS({
    "src/plots/cartesian/position_defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Lib = require_lib();
      module.exports = function handlePositionDefaults(containerIn, containerOut, coerce, options) {
        var counterAxes = options.counterAxes || [];
        var overlayableAxes = options.overlayableAxes || [];
        var letter = options.letter;
        var grid = options.grid;
        var overlayingDomain = options.overlayingDomain;
        var dfltAnchor, dfltDomain, dfltSide, dfltPosition, dfltShift, dfltAutomargin;
        if (grid) {
          dfltDomain = grid._domains[letter][grid._axisMap[containerOut._id]];
          dfltAnchor = grid._anchors[containerOut._id];
          if (dfltDomain) {
            dfltSide = grid[letter + "side"].split(" ")[0];
            dfltPosition = grid.domain[letter][dfltSide === "right" || dfltSide === "top" ? 1 : 0];
          }
        }
        dfltDomain = dfltDomain || [0, 1];
        dfltAnchor = dfltAnchor || (isNumeric(containerIn.position) ? "free" : counterAxes[0] || "free");
        dfltSide = dfltSide || (letter === "x" ? "bottom" : "left");
        dfltPosition = dfltPosition || 0;
        dfltShift = 0;
        dfltAutomargin = false;
        var anchor = Lib.coerce(containerIn, containerOut, {
          anchor: {
            valType: "enumerated",
            values: ["free"].concat(counterAxes),
            dflt: dfltAnchor
          }
        }, "anchor");
        var side = Lib.coerce(containerIn, containerOut, {
          side: {
            valType: "enumerated",
            values: letter === "x" ? ["bottom", "top"] : ["left", "right"],
            dflt: dfltSide
          }
        }, "side");
        if (anchor === "free") {
          if (letter === "y") {
            var autoshift = coerce("autoshift");
            if (autoshift) {
              dfltPosition = side === "left" ? overlayingDomain[0] : overlayingDomain[1];
              dfltAutomargin = containerOut.automargin ? containerOut.automargin : true;
              dfltShift = side === "left" ? -3 : 3;
            }
            coerce("shift", dfltShift);
          }
          coerce("position", dfltPosition);
        }
        coerce("automargin", dfltAutomargin);
        var overlaying = false;
        if (overlayableAxes.length) {
          overlaying = Lib.coerce(containerIn, containerOut, {
            overlaying: {
              valType: "enumerated",
              values: [false].concat(overlayableAxes),
              dflt: false
            }
          }, "overlaying");
        }
        if (!overlaying) {
          var domain = coerce("domain", dfltDomain);
          if (domain[0] > domain[1] - 1 / 4096) containerOut.domain = dfltDomain;
          Lib.noneOrAll(containerIn.domain, containerOut.domain, dfltDomain);
          if (containerOut.tickmode === "sync") {
            containerOut.tickmode = "auto";
          }
        }
        coerce("layer");
        return containerOut;
      };
    }
  });

  // src/plots/cartesian/layout_defaults.js
  var require_layout_defaults4 = __commonJS({
    "src/plots/cartesian/layout_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var isUnifiedHover = require_helpers2().isUnifiedHover;
      var handleHoverModeDefaults = require_hovermode_defaults();
      var Template = require_plot_template();
      var basePlotLayoutAttributes = require_layout_attributes2();
      var layoutAttributes = require_layout_attributes4();
      var handleTypeDefaults = require_type_defaults();
      var handleAxisDefaults = require_axis_defaults();
      var constraints = require_constraints();
      var handlePositionDefaults = require_position_defaults();
      var axisIds = require_axis_ids();
      var id2name = axisIds.id2name;
      var name2id = axisIds.name2id;
      var AX_ID_PATTERN = require_constants2().AX_ID_PATTERN;
      var Registry = require_registry();
      var traceIs = Registry.traceIs;
      var getComponentMethod = Registry.getComponentMethod;
      function appendList(cont, k, item) {
        if (Array.isArray(cont[k])) cont[k].push(item);
        else cont[k] = [item];
      }
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
        var autotypenumbersDflt = layoutOut.autotypenumbers;
        var ax2traces = {};
        var xaMayHide = {};
        var yaMayHide = {};
        var xaMustDisplay = {};
        var yaMustDisplay = {};
        var yaMustNotReverse = {};
        var yaMayReverse = {};
        var axHasImage = {};
        var outerTicks = {};
        var noGrids = {};
        var i, j;
        for (i = 0; i < fullData.length; i++) {
          var trace = fullData[i];
          if (!traceIs(trace, "cartesian")) continue;
          var xaName;
          if (trace.xaxis) {
            xaName = id2name(trace.xaxis);
            appendList(ax2traces, xaName, trace);
          } else if (trace.xaxes) {
            for (j = 0; j < trace.xaxes.length; j++) {
              appendList(ax2traces, id2name(trace.xaxes[j]), trace);
            }
          }
          var yaName;
          if (trace.yaxis) {
            yaName = id2name(trace.yaxis);
            appendList(ax2traces, yaName, trace);
          } else if (trace.yaxes) {
            for (j = 0; j < trace.yaxes.length; j++) {
              appendList(ax2traces, id2name(trace.yaxes[j]), trace);
            }
          }
          if (trace.type === "funnel") {
            if (trace.orientation === "h") {
              if (xaName) xaMayHide[xaName] = true;
              if (yaName) yaMayReverse[yaName] = true;
            } else {
              if (yaName) yaMayHide[yaName] = true;
            }
          } else if (trace.type === "image") {
            if (yaName) axHasImage[yaName] = true;
            if (xaName) axHasImage[xaName] = true;
          } else {
            if (yaName) {
              yaMustDisplay[yaName] = true;
              yaMustNotReverse[yaName] = true;
            }
            if (!traceIs(trace, "carpet") || trace.type === "carpet" && !trace._cheater) {
              if (xaName) xaMustDisplay[xaName] = true;
            }
          }
          if (trace.type === "carpet" && trace._cheater) {
            if (xaName) xaMayHide[xaName] = true;
          }
          if (traceIs(trace, "2dMap")) {
            outerTicks[xaName] = true;
            outerTicks[yaName] = true;
          }
          if (traceIs(trace, "oriented")) {
            var positionAxis = trace.orientation === "h" ? yaName : xaName;
            noGrids[positionAxis] = true;
          }
        }
        var subplots = layoutOut._subplots;
        var xIds = subplots.xaxis;
        var yIds = subplots.yaxis;
        var xNames = Lib.simpleMap(xIds, id2name);
        var yNames = Lib.simpleMap(yIds, id2name);
        var axNames = xNames.concat(yNames);
        var plotBgColor = Color.background;
        if (xIds.length && yIds.length) {
          plotBgColor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, "plot_bgcolor");
        }
        var bgColor = Color.combine(plotBgColor, layoutOut.paper_bgcolor);
        var axName;
        var axId;
        var axLetter;
        var axLayoutIn;
        var axLayoutOut;
        function newAxLayoutOut() {
          var traces = ax2traces[axName] || [];
          axLayoutOut._traceIndices = traces.map(function(t) {
            return t.index;
          });
          axLayoutOut._annIndices = [];
          axLayoutOut._shapeIndices = [];
          axLayoutOut._selectionIndices = [];
          axLayoutOut._imgIndices = [];
          axLayoutOut._subplotsWith = [];
          axLayoutOut._counterAxes = [];
          axLayoutOut._name = axLayoutOut._attr = axName;
          axLayoutOut._id = axId;
        }
        function coerce(attr, dflt) {
          return Lib.coerce(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);
        }
        function coerce2(attr, dflt) {
          return Lib.coerce2(axLayoutIn, axLayoutOut, layoutAttributes, attr, dflt);
        }
        function getCounterAxes(axLetter2) {
          return axLetter2 === "x" ? yIds : xIds;
        }
        function getOverlayableAxes(axLetter2, axName2) {
          var list = axLetter2 === "x" ? xNames : yNames;
          var out = [];
          for (var j2 = 0; j2 < list.length; j2++) {
            var axName22 = list[j2];
            if (axName22 !== axName2 && !(layoutIn[axName22] || {}).overlaying) {
              out.push(name2id(axName22));
            }
          }
          return out;
        }
        var counterAxes = { x: getCounterAxes("x"), y: getCounterAxes("y") };
        var allAxisIds = counterAxes.x.concat(counterAxes.y);
        var missingMatchedAxisIdsLookup = {};
        var missingMatchedAxisIds = [];
        function addMissingMatchedAxis() {
          var matchesIn = axLayoutIn.matches;
          if (AX_ID_PATTERN.test(matchesIn) && allAxisIds.indexOf(matchesIn) === -1) {
            missingMatchedAxisIdsLookup[matchesIn] = axLayoutIn.type;
            missingMatchedAxisIds = Object.keys(missingMatchedAxisIdsLookup);
          }
        }
        var hovermode = handleHoverModeDefaults(layoutIn, layoutOut);
        var unifiedHover = isUnifiedHover(hovermode);
        for (i = 0; i < axNames.length; i++) {
          axName = axNames[i];
          axId = name2id(axName);
          axLetter = axName.charAt(0);
          if (!Lib.isPlainObject(layoutIn[axName])) {
            layoutIn[axName] = {};
          }
          axLayoutIn = layoutIn[axName];
          axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + "axis");
          newAxLayoutOut();
          var visibleDflt = axLetter === "x" && !xaMustDisplay[axName] && xaMayHide[axName] || axLetter === "y" && !yaMustDisplay[axName] && yaMayHide[axName];
          var reverseDflt = axLetter === "y" && (!yaMustNotReverse[axName] && yaMayReverse[axName] || axHasImage[axName]);
          var defaultOptions = {
            hasMinor: true,
            letter: axLetter,
            font: layoutOut.font,
            outerTicks: outerTicks[axName],
            showGrid: !noGrids[axName],
            data: ax2traces[axName] || [],
            bgColor,
            calendar: layoutOut.calendar,
            automargin: true,
            visibleDflt,
            reverseDflt,
            autotypenumbersDflt,
            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId],
            noAutotickangles: axLetter === "y"
          };
          coerce("uirevision", layoutOut.uirevision);
          handleTypeDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions);
          handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions, layoutOut);
          var unifiedSpike = unifiedHover && axLetter === hovermode.charAt(0);
          var spikecolor = coerce2("spikecolor", unifiedHover ? axLayoutOut.color : void 0);
          var spikethickness = coerce2("spikethickness", unifiedHover ? 1.5 : void 0);
          var spikedash = coerce2("spikedash", unifiedHover ? "dot" : void 0);
          var spikemode = coerce2("spikemode", unifiedHover ? "across" : void 0);
          var spikesnap = coerce2("spikesnap");
          var showSpikes = coerce("showspikes", !!unifiedSpike || !!spikecolor || !!spikethickness || !!spikedash || !!spikemode || !!spikesnap);
          if (!showSpikes) {
            delete axLayoutOut.spikecolor;
            delete axLayoutOut.spikethickness;
            delete axLayoutOut.spikedash;
            delete axLayoutOut.spikemode;
            delete axLayoutOut.spikesnap;
          }
          var overlayingAxis = id2name(axLayoutIn.overlaying);
          var overlayingAnchorDomain = [0, 1];
          if (layoutOut[overlayingAxis] !== void 0) {
            var overlayingAnchor = id2name(layoutOut[overlayingAxis].anchor);
            if (layoutOut[overlayingAnchor] !== void 0) {
              overlayingAnchorDomain = layoutOut[overlayingAnchor].domain;
            }
          }
          handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {
            letter: axLetter,
            counterAxes: counterAxes[axLetter],
            overlayableAxes: getOverlayableAxes(axLetter, axName),
            grid: layoutOut.grid,
            overlayingDomain: overlayingAnchorDomain
          });
          coerce("title.standoff");
          addMissingMatchedAxis();
          axLayoutOut._input = axLayoutIn;
        }
        i = 0;
        while (i < missingMatchedAxisIds.length) {
          axId = missingMatchedAxisIds[i++];
          axName = id2name(axId);
          axLetter = axName.charAt(0);
          if (!Lib.isPlainObject(layoutIn[axName])) {
            layoutIn[axName] = {};
          }
          axLayoutIn = layoutIn[axName];
          axLayoutOut = Template.newContainer(layoutOut, axName, axLetter + "axis");
          newAxLayoutOut();
          var defaultOptions2 = {
            letter: axLetter,
            font: layoutOut.font,
            outerTicks: outerTicks[axName],
            showGrid: !noGrids[axName],
            data: [],
            bgColor,
            calendar: layoutOut.calendar,
            automargin: true,
            visibleDflt: false,
            reverseDflt: false,
            autotypenumbersDflt,
            splomStash: ((layoutOut._splomAxes || {})[axLetter] || {})[axId]
          };
          coerce("uirevision", layoutOut.uirevision);
          axLayoutOut.type = missingMatchedAxisIdsLookup[axId] || "linear";
          handleAxisDefaults(axLayoutIn, axLayoutOut, coerce, defaultOptions2, layoutOut);
          handlePositionDefaults(axLayoutIn, axLayoutOut, coerce, {
            letter: axLetter,
            counterAxes: counterAxes[axLetter],
            overlayableAxes: getOverlayableAxes(axLetter, axName),
            grid: layoutOut.grid
          });
          coerce("fixedrange");
          addMissingMatchedAxis();
          axLayoutOut._input = axLayoutIn;
        }
        var rangeSliderDefaults = getComponentMethod("rangeslider", "handleDefaults");
        var rangeSelectorDefaults = getComponentMethod("rangeselector", "handleDefaults");
        for (i = 0; i < xNames.length; i++) {
          axName = xNames[i];
          axLayoutIn = layoutIn[axName];
          axLayoutOut = layoutOut[axName];
          rangeSliderDefaults(layoutIn, layoutOut, axName);
          if (axLayoutOut.type === "date") {
            rangeSelectorDefaults(
              axLayoutIn,
              axLayoutOut,
              layoutOut,
              yNames,
              axLayoutOut.calendar
            );
          }
          coerce("fixedrange");
        }
        for (i = 0; i < yNames.length; i++) {
          axName = yNames[i];
          axLayoutIn = layoutIn[axName];
          axLayoutOut = layoutOut[axName];
          var anchoredAxis = layoutOut[id2name(axLayoutOut.anchor)];
          var fixedRangeDflt = getComponentMethod("rangeslider", "isVisible")(anchoredAxis);
          coerce("fixedrange", fixedRangeDflt);
        }
        constraints.handleDefaults(layoutIn, layoutOut, {
          axIds: allAxisIds.concat(missingMatchedAxisIds).sort(axisIds.idSort),
          axHasImage
        });
      };
    }
  });

  // src/plots/cartesian/transition_axes.js
  var require_transition_axes = __commonJS({
    "src/plots/cartesian/transition_axes.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var Drawing = require_drawing();
      var Axes = require_axes();
      module.exports = function transitionAxes(gd, edits, transitionOpts, makeOnCompleteCallback) {
        var fullLayout = gd._fullLayout;
        if (edits.length === 0) {
          Axes.redrawComponents(gd);
          return;
        }
        function unsetSubplotTransform(subplot) {
          var xa = subplot.xaxis;
          var ya = subplot.yaxis;
          fullLayout._defs.select("#" + subplot.clipId + "> rect").call(Drawing.setTranslate, 0, 0).call(Drawing.setScale, 1, 1);
          subplot.plot.call(Drawing.setTranslate, xa._offset, ya._offset).call(Drawing.setScale, 1, 1);
          var traceGroups = subplot.plot.selectAll(".scatterlayer .trace");
          traceGroups.selectAll(".point").call(Drawing.setPointGroupScale, 1, 1);
          traceGroups.selectAll(".textpoint").call(Drawing.setTextPointsScale, 1, 1);
          traceGroups.call(Drawing.hideOutsideRangePoints, subplot);
        }
        function updateSubplot(edit, progress) {
          var plotinfo = edit.plotinfo;
          var xa = plotinfo.xaxis;
          var ya = plotinfo.yaxis;
          var xlen = xa._length;
          var ylen = ya._length;
          var editX = !!edit.xr1;
          var editY = !!edit.yr1;
          var viewBox = [];
          if (editX) {
            var xr0 = Lib.simpleMap(edit.xr0, xa.r2l);
            var xr1 = Lib.simpleMap(edit.xr1, xa.r2l);
            var dx0 = xr0[1] - xr0[0];
            var dx1 = xr1[1] - xr1[0];
            viewBox[0] = (xr0[0] * (1 - progress) + progress * xr1[0] - xr0[0]) / (xr0[1] - xr0[0]) * xlen;
            viewBox[2] = xlen * (1 - progress + progress * dx1 / dx0);
            xa.range[0] = xa.l2r(xr0[0] * (1 - progress) + progress * xr1[0]);
            xa.range[1] = xa.l2r(xr0[1] * (1 - progress) + progress * xr1[1]);
          } else {
            viewBox[0] = 0;
            viewBox[2] = xlen;
          }
          if (editY) {
            var yr0 = Lib.simpleMap(edit.yr0, ya.r2l);
            var yr1 = Lib.simpleMap(edit.yr1, ya.r2l);
            var dy0 = yr0[1] - yr0[0];
            var dy1 = yr1[1] - yr1[0];
            viewBox[1] = (yr0[1] * (1 - progress) + progress * yr1[1] - yr0[1]) / (yr0[0] - yr0[1]) * ylen;
            viewBox[3] = ylen * (1 - progress + progress * dy1 / dy0);
            ya.range[0] = xa.l2r(yr0[0] * (1 - progress) + progress * yr1[0]);
            ya.range[1] = ya.l2r(yr0[1] * (1 - progress) + progress * yr1[1]);
          } else {
            viewBox[1] = 0;
            viewBox[3] = ylen;
          }
          Axes.drawOne(gd, xa, { skipTitle: true });
          Axes.drawOne(gd, ya, { skipTitle: true });
          Axes.redrawComponents(gd, [xa._id, ya._id]);
          var xScaleFactor = editX ? xlen / viewBox[2] : 1;
          var yScaleFactor = editY ? ylen / viewBox[3] : 1;
          var clipDx = editX ? viewBox[0] : 0;
          var clipDy = editY ? viewBox[1] : 0;
          var fracDx = editX ? viewBox[0] / viewBox[2] * xlen : 0;
          var fracDy = editY ? viewBox[1] / viewBox[3] * ylen : 0;
          var plotDx = xa._offset - fracDx;
          var plotDy = ya._offset - fracDy;
          plotinfo.clipRect.call(Drawing.setTranslate, clipDx, clipDy).call(Drawing.setScale, 1 / xScaleFactor, 1 / yScaleFactor);
          plotinfo.plot.call(Drawing.setTranslate, plotDx, plotDy).call(Drawing.setScale, xScaleFactor, yScaleFactor);
          Drawing.setPointGroupScale(plotinfo.zoomScalePts, 1 / xScaleFactor, 1 / yScaleFactor);
          Drawing.setTextPointsScale(plotinfo.zoomScaleTxt, 1 / xScaleFactor, 1 / yScaleFactor);
        }
        var onComplete;
        if (makeOnCompleteCallback) {
          onComplete = makeOnCompleteCallback();
        }
        function transitionComplete() {
          var aobj = {};
          for (var i = 0; i < edits.length; i++) {
            var edit = edits[i];
            var xa = edit.plotinfo.xaxis;
            var ya = edit.plotinfo.yaxis;
            if (edit.xr1) aobj[xa._name + ".range"] = edit.xr1.slice();
            if (edit.yr1) aobj[ya._name + ".range"] = edit.yr1.slice();
          }
          onComplete && onComplete();
          return Registry.call("relayout", gd, aobj).then(function() {
            for (var i2 = 0; i2 < edits.length; i2++) {
              unsetSubplotTransform(edits[i2].plotinfo);
            }
          });
        }
        function transitionInterrupt() {
          var aobj = {};
          for (var i = 0; i < edits.length; i++) {
            var edit = edits[i];
            var xa = edit.plotinfo.xaxis;
            var ya = edit.plotinfo.yaxis;
            if (edit.xr0) aobj[xa._name + ".range"] = edit.xr0.slice();
            if (edit.yr0) aobj[ya._name + ".range"] = edit.yr0.slice();
          }
          return Registry.call("relayout", gd, aobj).then(function() {
            for (var i2 = 0; i2 < edits.length; i2++) {
              unsetSubplotTransform(edits[i2].plotinfo);
            }
          });
        }
        var t1, t2, raf;
        var easeFn = d3.ease(transitionOpts.easing);
        gd._transitionData._interruptCallbacks.push(function() {
          window.cancelAnimationFrame(raf);
          raf = null;
          return transitionInterrupt();
        });
        function doFrame() {
          t2 = Date.now();
          var tInterp = Math.min(1, (t2 - t1) / transitionOpts.duration);
          var progress = easeFn(tInterp);
          for (var i = 0; i < edits.length; i++) {
            updateSubplot(edits[i], progress);
          }
          if (t2 - t1 > transitionOpts.duration) {
            transitionComplete();
            raf = window.cancelAnimationFrame(doFrame);
          } else {
            raf = window.requestAnimationFrame(doFrame);
          }
        }
        t1 = Date.now();
        raf = window.requestAnimationFrame(doFrame);
        return Promise.resolve();
      };
    }
  });

  // src/plots/cartesian/index.js
  var require_cartesian = __commonJS({
    "src/plots/cartesian/index.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Lib = require_lib();
      var Plots = require_plots();
      var Drawing = require_drawing();
      var getModuleCalcData = require_get_data().getModuleCalcData;
      var axisIds = require_axis_ids();
      var constants = require_constants2();
      var xmlnsNamespaces = require_xmlns_namespaces();
      var ensureSingle = Lib.ensureSingle;
      function ensureSingleAndAddDatum(parent, nodeType, className) {
        return Lib.ensureSingle(parent, nodeType, className, function(s) {
          s.datum(className);
        });
      }
      var zindexSeparator = constants.zindexSeparator;
      exports.name = "cartesian";
      exports.attr = ["xaxis", "yaxis"];
      exports.idRoot = ["x", "y"];
      exports.idRegex = constants.idRegex;
      exports.attrRegex = constants.attrRegex;
      exports.attributes = require_attributes14();
      exports.layoutAttributes = require_layout_attributes4();
      exports.supplyLayoutDefaults = require_layout_defaults4();
      exports.transitionAxes = require_transition_axes();
      exports.finalizeSubplots = function(layoutIn, layoutOut) {
        var subplots = layoutOut._subplots;
        var xList = subplots.xaxis;
        var yList = subplots.yaxis;
        var spSVG = subplots.cartesian;
        var spAll = spSVG;
        var allX = {};
        var allY = {};
        var i, xi, yi;
        for (i = 0; i < spAll.length; i++) {
          var parts = spAll[i].split("y");
          allX[parts[0]] = 1;
          allY["y" + parts[1]] = 1;
        }
        for (i = 0; i < xList.length; i++) {
          xi = xList[i];
          if (!allX[xi]) {
            yi = (layoutIn[axisIds.id2name(xi)] || {}).anchor;
            if (!constants.idRegex.y.test(yi)) yi = "y";
            spSVG.push(xi + yi);
            spAll.push(xi + yi);
            if (!allY[yi]) {
              allY[yi] = 1;
              Lib.pushUnique(yList, yi);
            }
          }
        }
        for (i = 0; i < yList.length; i++) {
          yi = yList[i];
          if (!allY[yi]) {
            xi = (layoutIn[axisIds.id2name(yi)] || {}).anchor;
            if (!constants.idRegex.x.test(xi)) xi = "x";
            spSVG.push(xi + yi);
            spAll.push(xi + yi);
            if (!allX[xi]) {
              allX[xi] = 1;
              Lib.pushUnique(xList, xi);
            }
          }
        }
        if (!spAll.length) {
          xi = "";
          yi = "";
          for (var ki in layoutIn) {
            if (constants.attrRegex.test(ki)) {
              var axLetter = ki.charAt(0);
              if (axLetter === "x") {
                if (!xi || +ki.substr(5) < +xi.substr(5)) {
                  xi = ki;
                }
              } else if (!yi || +ki.substr(5) < +yi.substr(5)) {
                yi = ki;
              }
            }
          }
          xi = xi ? axisIds.name2id(xi) : "x";
          yi = yi ? axisIds.name2id(yi) : "y";
          xList.push(xi);
          yList.push(yi);
          spSVG.push(xi + yi);
        }
      };
      exports.plot = function(gd, traces, transitionOpts, makeOnCompleteCallback) {
        var fullLayout = gd._fullLayout;
        var subplots = fullLayout._subplots.cartesian;
        var calcdata = gd.calcdata;
        var i;
        if (!Array.isArray(traces)) {
          traces = [];
          for (i = 0; i < calcdata.length; i++) traces.push(i);
        }
        var zindices = fullLayout._zindices;
        for (var z = 0; z < zindices.length; z++) {
          var zorder = zindices[z];
          for (i = 0; i < subplots.length; i++) {
            var subplot = subplots[i];
            var subplotInfo = fullLayout._plots[subplot];
            if (z > 0) {
              var idWithZ = subplotInfo.id;
              if (idWithZ.indexOf(zindexSeparator) !== -1) continue;
              idWithZ += zindexSeparator + (z + 1);
              subplotInfo = Lib.extendFlat({}, subplotInfo, {
                id: idWithZ,
                plot: fullLayout._cartesianlayer.selectAll(".subplot").select("." + idWithZ)
              });
            }
            var cdSubplot = [];
            var pcd;
            for (var j = 0; j < calcdata.length; j++) {
              var cd = calcdata[j];
              var trace = cd[0].trace;
              if (zorder !== (trace.zorder || 0)) continue;
              if (trace.xaxis + trace.yaxis === subplot) {
                if (traces.indexOf(trace.index) !== -1 || trace.carpet) {
                  if (pcd && pcd[0].trace.xaxis + pcd[0].trace.yaxis === subplot && ["tonextx", "tonexty", "tonext"].indexOf(trace.fill) !== -1 && cdSubplot.indexOf(pcd) === -1) {
                    cdSubplot.push(pcd);
                  }
                  cdSubplot.push(cd);
                }
                pcd = cd;
              }
            }
            plotOne(gd, subplotInfo, cdSubplot, transitionOpts, makeOnCompleteCallback);
          }
        }
      };
      function plotOne(gd, plotinfo, cdSubplot, transitionOpts, makeOnCompleteCallback) {
        var traceLayerClasses = constants.traceLayerClasses;
        var fullLayout = gd._fullLayout;
        var zindices = fullLayout._zindices;
        var modules = fullLayout._modules;
        var _module, cdModuleAndOthers, cdModule;
        var layerData = [];
        var zoomScaleQueryParts = [];
        for (var z = 0; z < zindices.length; z++) {
          var zorder = zindices[z];
          for (var i = 0; i < modules.length; i++) {
            _module = modules[i];
            var name = _module.name;
            var categories = Registry.modules[name].categories;
            if (categories.svg) {
              var classBaseName = _module.layerName || name + "layer";
              var className = classBaseName + (z ? Number(z) + 1 : "");
              var plotMethod = _module.plot;
              cdModuleAndOthers = getModuleCalcData(cdSubplot, plotMethod, zorder);
              cdModule = cdModuleAndOthers[0];
              cdSubplot = cdModuleAndOthers[1];
              if (cdModule.length) {
                layerData.push({
                  i: traceLayerClasses.indexOf(classBaseName),
                  zindex: z,
                  className,
                  plotMethod,
                  cdModule
                });
              }
              if (categories.zoomScale) {
                zoomScaleQueryParts.push("." + className);
              }
            }
          }
        }
        layerData.sort(function(a, b) {
          return (a.zindex || 0) - (b.zindex || 0) || a.i - b.i;
        });
        var layers = plotinfo.plot.selectAll("g.mlayer").data(layerData, function(d) {
          return d.className;
        });
        layers.enter().append("g").attr("class", function(d) {
          return d.className;
        }).classed("mlayer", true).classed("rangeplot", plotinfo.isRangePlot);
        layers.exit().remove();
        layers.order();
        layers.each(function(d) {
          var sel = d3.select(this);
          var className2 = d.className;
          d.plotMethod(
            gd,
            plotinfo,
            d.cdModule,
            sel,
            transitionOpts,
            makeOnCompleteCallback
          );
          if (constants.clipOnAxisFalseQuery.indexOf("." + className2) === -1) {
            Drawing.setClipUrl(sel, plotinfo.layerClipId, gd);
          }
        });
        if (fullLayout._has("scattergl")) {
          _module = Registry.getModule("scattergl");
          cdModule = getModuleCalcData(cdSubplot, _module)[0];
          _module.plot(gd, plotinfo, cdModule);
        }
        if (!gd._context.staticPlot) {
          if (plotinfo._hasClipOnAxisFalse) {
            plotinfo.clipOnAxisFalseTraces = plotinfo.plot.selectAll(constants.clipOnAxisFalseQuery.join(",")).selectAll(".trace");
          }
          if (zoomScaleQueryParts.length) {
            var traces = plotinfo.plot.selectAll(zoomScaleQueryParts.join(",")).selectAll(".trace");
            plotinfo.zoomScalePts = traces.selectAll("path.point");
            plotinfo.zoomScaleTxt = traces.selectAll(".textpoint");
          }
        }
      }
      exports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var oldPlots = oldFullLayout._plots || {};
        var newPlots = newFullLayout._plots || {};
        var oldSubplotList = oldFullLayout._subplots || {};
        var plotinfo;
        var i, k;
        if (oldFullLayout._hasOnlyLargeSploms && !newFullLayout._hasOnlyLargeSploms) {
          for (k in oldPlots) {
            plotinfo = oldPlots[k];
            if (plotinfo.plotgroup) plotinfo.plotgroup.remove();
          }
        }
        var hadGl = oldFullLayout._has && oldFullLayout._has("gl");
        var hasGl = newFullLayout._has && newFullLayout._has("gl");
        if (hadGl && !hasGl) {
          for (k in oldPlots) {
            plotinfo = oldPlots[k];
            if (plotinfo._scene) plotinfo._scene.destroy();
          }
        }
        if (oldSubplotList.xaxis && oldSubplotList.yaxis) {
          var oldAxIDs = axisIds.listIds({ _fullLayout: oldFullLayout });
          for (i = 0; i < oldAxIDs.length; i++) {
            var oldAxId = oldAxIDs[i];
            if (!newFullLayout[axisIds.id2name(oldAxId)]) {
              oldFullLayout._infolayer.selectAll(".g-" + oldAxId + "title").remove();
            }
          }
        }
        var hadCartesian = oldFullLayout._has && oldFullLayout._has("cartesian");
        var hasCartesian = newFullLayout._has && newFullLayout._has("cartesian");
        if (hadCartesian && !hasCartesian) {
          purgeSubplotLayers(oldFullLayout._cartesianlayer.selectAll(".subplot"), oldFullLayout);
          oldFullLayout._defs.selectAll(".axesclip").remove();
          delete oldFullLayout._axisConstraintGroups;
          delete oldFullLayout._axisMatchGroups;
        } else if (oldSubplotList.cartesian) {
          for (i = 0; i < oldSubplotList.cartesian.length; i++) {
            var oldSubplotId = oldSubplotList.cartesian[i];
            if (oldSubplotId.indexOf(zindexSeparator) !== -1) continue;
            if (!newPlots[oldSubplotId]) {
              var selector = "." + oldSubplotId + ",." + oldSubplotId + "-x,." + oldSubplotId + "-y";
              oldFullLayout._cartesianlayer.selectAll(selector).remove();
              removeSubplotExtras(oldSubplotId, oldFullLayout);
            }
          }
        }
      };
      exports.drawFramework = function(gd) {
        var fullLayout = gd._fullLayout;
        var calcdata = gd.calcdata;
        var i;
        var traceZorderGroups = {};
        for (i = 0; i < calcdata.length; i++) {
          var cdi = calcdata[i][0];
          var trace = cdi.trace;
          var zi = trace.zorder || 0;
          if (!traceZorderGroups[zi]) traceZorderGroups[zi] = [];
          traceZorderGroups[zi].push(cdi);
        }
        var zindices = Object.keys(traceZorderGroups).map(Number).sort(Lib.sorterAsc);
        if (!zindices.length) zindices = [0];
        fullLayout._zindices = zindices;
        var initialSubplotData = makeSubplotData(gd);
        var len = initialSubplotData.length;
        var subplotData = [];
        for (i = 0; i < len; i++) {
          subplotData[i] = initialSubplotData[i].slice();
        }
        for (var z = 1; z < zindices.length; z++) {
          var newSubplotData = [];
          for (i = 0; i < len; i++) {
            newSubplotData[i] = initialSubplotData[i].slice();
            newSubplotData[i][0] += zindexSeparator + (z + 1);
          }
          subplotData = subplotData.concat(newSubplotData);
        }
        var subplotLayers = fullLayout._cartesianlayer.selectAll(".subplot").data(subplotData, String);
        subplotLayers.enter().append("g").attr("class", function(d) {
          return "subplot " + d[0];
        });
        subplotLayers.order();
        subplotLayers.exit().call(purgeSubplotLayers, fullLayout);
        subplotLayers.each(function(d) {
          var id = d[0];
          var posZ = id.indexOf(zindexSeparator);
          var hasZ = posZ !== -1;
          var idWithoutZ = hasZ ? id.slice(0, posZ) : id;
          var plotinfo = fullLayout._plots[id];
          if (!plotinfo) {
            plotinfo = Lib.extendFlat({}, fullLayout._plots[idWithoutZ]);
            if (plotinfo) {
              plotinfo.id = id;
              fullLayout._plots[id] = plotinfo;
              fullLayout._subplots.cartesian.push(id);
            }
          }
          if (plotinfo) {
            plotinfo.plotgroup = d3.select(this);
            makeSubplotLayer(gd, plotinfo);
            if (!hasZ) {
              plotinfo.draglayer = ensureSingle(fullLayout._draggers, "g", id);
            }
          }
        });
      };
      exports.rangePlot = function(gd, plotinfo, cdSubplot) {
        makeSubplotLayer(gd, plotinfo);
        plotOne(gd, plotinfo, cdSubplot);
        Plots.style(gd);
      };
      function makeSubplotData(gd) {
        var fullLayout = gd._fullLayout;
        var numZ = fullLayout._zindices.length;
        var ids = fullLayout._subplots.cartesian;
        var len = ids.length;
        var i, j, id, plotinfo, xa, ya;
        var regulars = [];
        var overlays = [];
        for (i = 0; i < len; i++) {
          id = ids[i];
          plotinfo = fullLayout._plots[id];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          var xa2 = xa._mainAxis;
          var ya2 = ya._mainAxis;
          var mainplot = xa2._id + ya2._id;
          var mainplotinfo = fullLayout._plots[mainplot];
          plotinfo.overlays = [];
          if (mainplot !== id && mainplotinfo) {
            plotinfo.mainplot = mainplot;
            plotinfo.mainplotinfo = mainplotinfo;
            overlays.push(id);
          } else {
            plotinfo.mainplot = void 0;
            plotinfo.mainplotinfo = void 0;
            regulars.push(id);
          }
        }
        for (i = 0; i < overlays.length; i++) {
          id = overlays[i];
          plotinfo = fullLayout._plots[id];
          plotinfo.mainplotinfo.overlays.push(plotinfo);
        }
        var subplotIds = regulars.concat(overlays);
        var subplotData = [];
        for (i = 0; i < len; i++) {
          id = subplotIds[i];
          plotinfo = fullLayout._plots[id];
          xa = plotinfo.xaxis;
          ya = plotinfo.yaxis;
          var d = [];
          for (var z = 1; z <= numZ; z++) {
            var zStr = "";
            if (z > 1) zStr += zindexSeparator + z;
            d.push(id + zStr);
            for (j = 0; j < plotinfo.overlays.length; j++) {
              d.push(plotinfo.overlays[j].id + zStr);
            }
          }
          d = d.concat([
            xa.layer,
            ya.layer,
            xa.overlaying || "",
            ya.overlaying || ""
          ]);
          subplotData.push(d);
        }
        return subplotData;
      }
      function makeSubplotLayer(gd, plotinfo) {
        var fullLayout = gd._fullLayout;
        var plotgroup = plotinfo.plotgroup;
        var id = plotinfo.id;
        var posZ = id.indexOf(zindexSeparator);
        var hasZ = posZ !== -1;
        var xLayer = constants.layerValue2layerClass[plotinfo.xaxis.layer];
        var yLayer = constants.layerValue2layerClass[plotinfo.yaxis.layer];
        var hasOnlyLargeSploms = fullLayout._hasOnlyLargeSploms;
        var hasMultipleZ = fullLayout._zindices.length > 1;
        var mainplotinfo = plotinfo.mainplotinfo;
        if (!plotinfo.mainplot || hasMultipleZ) {
          if (hasOnlyLargeSploms) {
            plotinfo.xlines = ensureSingle(plotgroup, "path", "xlines-above");
            plotinfo.ylines = ensureSingle(plotgroup, "path", "ylines-above");
            plotinfo.xaxislayer = ensureSingle(plotgroup, "g", "xaxislayer-above");
            plotinfo.yaxislayer = ensureSingle(plotgroup, "g", "yaxislayer-above");
          } else {
            if (!hasZ) {
              var backLayer = ensureSingle(plotgroup, "g", "layer-subplot");
              plotinfo.shapelayer = ensureSingle(backLayer, "g", "shapelayer");
              plotinfo.imagelayer = ensureSingle(backLayer, "g", "imagelayer");
              if (mainplotinfo && hasMultipleZ) {
                plotinfo.minorGridlayer = mainplotinfo.minorGridlayer;
                plotinfo.gridlayer = mainplotinfo.gridlayer;
                plotinfo.zerolinelayer = mainplotinfo.zerolinelayer;
              } else {
                plotinfo.minorGridlayer = ensureSingle(plotgroup, "g", "minor-gridlayer");
                plotinfo.gridlayer = ensureSingle(plotgroup, "g", "gridlayer");
                plotinfo.zerolinelayer = ensureSingle(plotgroup, "g", "zerolinelayer");
              }
              var betweenLayer = ensureSingle(plotgroup, "g", "layer-between");
              plotinfo.shapelayerBetween = ensureSingle(betweenLayer, "g", "shapelayer");
              plotinfo.imagelayerBetween = ensureSingle(betweenLayer, "g", "imagelayer");
              ensureSingle(plotgroup, "path", "xlines-below");
              ensureSingle(plotgroup, "path", "ylines-below");
              plotinfo.overlinesBelow = ensureSingle(plotgroup, "g", "overlines-below");
              ensureSingle(plotgroup, "g", "xaxislayer-below");
              ensureSingle(plotgroup, "g", "yaxislayer-below");
              plotinfo.overaxesBelow = ensureSingle(plotgroup, "g", "overaxes-below");
            }
            plotinfo.overplot = ensureSingle(plotgroup, "g", "overplot");
            plotinfo.plot = ensureSingle(plotinfo.overplot, "g", id);
            if (!hasZ) {
              plotinfo.xlines = ensureSingle(plotgroup, "path", "xlines-above");
              plotinfo.ylines = ensureSingle(plotgroup, "path", "ylines-above");
              plotinfo.overlinesAbove = ensureSingle(plotgroup, "g", "overlines-above");
              ensureSingle(plotgroup, "g", "xaxislayer-above");
              ensureSingle(plotgroup, "g", "yaxislayer-above");
              plotinfo.overaxesAbove = ensureSingle(plotgroup, "g", "overaxes-above");
              plotinfo.xlines = plotgroup.select(".xlines-" + xLayer);
              plotinfo.ylines = plotgroup.select(".ylines-" + yLayer);
              plotinfo.xaxislayer = plotgroup.select(".xaxislayer-" + xLayer);
              plotinfo.yaxislayer = plotgroup.select(".yaxislayer-" + yLayer);
            }
          }
        } else {
          var mainplotgroup = mainplotinfo.plotgroup;
          var xId = id + "-x";
          var yId = id + "-y";
          plotinfo.minorGridlayer = mainplotinfo.minorGridlayer;
          plotinfo.gridlayer = mainplotinfo.gridlayer;
          plotinfo.zerolinelayer = mainplotinfo.zerolinelayer;
          ensureSingle(mainplotinfo.overlinesBelow, "path", xId);
          ensureSingle(mainplotinfo.overlinesBelow, "path", yId);
          ensureSingle(mainplotinfo.overaxesBelow, "g", xId);
          ensureSingle(mainplotinfo.overaxesBelow, "g", yId);
          plotinfo.plot = ensureSingle(mainplotinfo.overplot, "g", id);
          ensureSingle(mainplotinfo.overlinesAbove, "path", xId);
          ensureSingle(mainplotinfo.overlinesAbove, "path", yId);
          ensureSingle(mainplotinfo.overaxesAbove, "g", xId);
          ensureSingle(mainplotinfo.overaxesAbove, "g", yId);
          plotinfo.xlines = mainplotgroup.select(".overlines-" + xLayer).select("." + xId);
          plotinfo.ylines = mainplotgroup.select(".overlines-" + yLayer).select("." + yId);
          plotinfo.xaxislayer = mainplotgroup.select(".overaxes-" + xLayer).select("." + xId);
          plotinfo.yaxislayer = mainplotgroup.select(".overaxes-" + yLayer).select("." + yId);
        }
        if (!hasZ) {
          if (!hasOnlyLargeSploms) {
            ensureSingleAndAddDatum(plotinfo.minorGridlayer, "g", plotinfo.xaxis._id);
            ensureSingleAndAddDatum(plotinfo.minorGridlayer, "g", plotinfo.yaxis._id);
            plotinfo.minorGridlayer.selectAll("g").map(function(d) {
              return d[0];
            }).sort(axisIds.idSort);
            ensureSingleAndAddDatum(plotinfo.gridlayer, "g", plotinfo.xaxis._id);
            ensureSingleAndAddDatum(plotinfo.gridlayer, "g", plotinfo.yaxis._id);
            plotinfo.gridlayer.selectAll("g").map(function(d) {
              return d[0];
            }).sort(axisIds.idSort);
          }
          plotinfo.xlines.style("fill", "none").classed("crisp", true);
          plotinfo.ylines.style("fill", "none").classed("crisp", true);
        }
      }
      function purgeSubplotLayers(layers, fullLayout) {
        if (!layers) return;
        var overlayIdsToRemove = {};
        layers.each(function(d) {
          var id = d[0];
          var plotgroup = d3.select(this);
          plotgroup.remove();
          removeSubplotExtras(id, fullLayout);
          overlayIdsToRemove[id] = true;
        });
        for (var k in fullLayout._plots) {
          var subplotInfo = fullLayout._plots[k];
          var overlays = subplotInfo.overlays || [];
          for (var j = 0; j < overlays.length; j++) {
            var overlayInfo = overlays[j];
            if (overlayIdsToRemove[overlayInfo.id]) {
              overlayInfo.plot.selectAll(".trace").remove();
            }
          }
        }
      }
      function removeSubplotExtras(subplotId, fullLayout) {
        fullLayout._draggers.selectAll("g." + subplotId).remove();
        fullLayout._defs.select("#clip" + fullLayout._uid + subplotId + "plot").remove();
      }
      exports.toSVG = function(gd) {
        var imageRoot = gd._fullLayout._glimages;
        var root = d3.select(gd).selectAll(".svg-container");
        var canvases = root.filter(function(d, i) {
          return i === root.size() - 1;
        }).selectAll(".gl-canvas-context, .gl-canvas-focus");
        function canvasToImage() {
          var canvas = this;
          var imageData = canvas.toDataURL("image/png");
          var image = imageRoot.append("svg:image");
          image.attr({
            xmlns: xmlnsNamespaces.svg,
            "xlink:href": imageData,
            preserveAspectRatio: "none",
            x: 0,
            y: 0,
            width: canvas.style.width,
            height: canvas.style.height
          });
        }
        canvases.each(canvasToImage);
      };
      exports.updateFx = require_graph_interact().updateFx;
    }
  });

  // src/traces/scatter/index.js
  var require_scatter = __commonJS({
    "src/traces/scatter/index.js"(exports, module) {
      "use strict";
      var subtypes = require_subtypes();
      module.exports = {
        hasLines: subtypes.hasLines,
        hasMarkers: subtypes.hasMarkers,
        hasText: subtypes.hasText,
        isBubble: subtypes.isBubble,
        attributes: require_attributes12(),
        layoutAttributes: require_layout_attributes3(),
        supplyDefaults: require_defaults8(),
        crossTraceDefaults: require_cross_trace_defaults2(),
        supplyLayoutDefaults: require_layout_defaults3(),
        calc: require_calc3().calc,
        crossTraceCalc: require_cross_trace_calc2(),
        arraysToCalcdata: require_arrays_to_calcdata(),
        plot: require_plot(),
        colorbar: require_marker_colorbar(),
        formatLabels: require_format_labels(),
        style: require_style2().style,
        styleOnSelect: require_style2().styleOnSelect,
        hoverPoints: require_hover2(),
        selectPoints: require_select2(),
        animatable: true,
        moduleType: "trace",
        name: "scatter",
        basePlotModule: require_cartesian(),
        categories: [
          "cartesian",
          "svg",
          "symbols",
          "errorBarsOK",
          "showLegend",
          "scatter-like",
          "zoomScale"
        ],
        meta: {}
      };
    }
  });

  // src/components/annotations/draw_arrow_head.js
  var require_draw_arrow_head = __commonJS({
    "src/components/annotations/draw_arrow_head.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Color = require_color();
      var ARROWPATHS = require_arrow_paths();
      var Lib = require_lib();
      var strScale = Lib.strScale;
      var strRotate = Lib.strRotate;
      var strTranslate = Lib.strTranslate;
      module.exports = function drawArrowHead(el3, ends, options) {
        var el = el3.node();
        var headStyle = ARROWPATHS[options.arrowhead || 0];
        var startHeadStyle = ARROWPATHS[options.startarrowhead || 0];
        var scale = (options.arrowwidth || 1) * (options.arrowsize || 1);
        var startScale = (options.arrowwidth || 1) * (options.startarrowsize || 1);
        var doStart = ends.indexOf("start") >= 0;
        var doEnd = ends.indexOf("end") >= 0;
        var backOff = headStyle.backoff * scale + options.standoff;
        var startBackOff = startHeadStyle.backoff * startScale + options.startstandoff;
        var start, end, startRot, endRot;
        if (el.nodeName === "line") {
          start = { x: +el3.attr("x1"), y: +el3.attr("y1") };
          end = { x: +el3.attr("x2"), y: +el3.attr("y2") };
          var dx = start.x - end.x;
          var dy = start.y - end.y;
          startRot = Math.atan2(dy, dx);
          endRot = startRot + Math.PI;
          if (backOff && startBackOff) {
            if (backOff + startBackOff > Math.sqrt(dx * dx + dy * dy)) {
              hideLine();
              return;
            }
          }
          if (backOff) {
            if (backOff * backOff > dx * dx + dy * dy) {
              hideLine();
              return;
            }
            var backOffX = backOff * Math.cos(startRot);
            var backOffY = backOff * Math.sin(startRot);
            end.x += backOffX;
            end.y += backOffY;
            el3.attr({ x2: end.x, y2: end.y });
          }
          if (startBackOff) {
            if (startBackOff * startBackOff > dx * dx + dy * dy) {
              hideLine();
              return;
            }
            var startBackOffX = startBackOff * Math.cos(startRot);
            var startbackOffY = startBackOff * Math.sin(startRot);
            start.x -= startBackOffX;
            start.y -= startbackOffY;
            el3.attr({ x1: start.x, y1: start.y });
          }
        } else if (el.nodeName === "path") {
          var pathlen = el.getTotalLength();
          var dashArray = "";
          if (pathlen < backOff + startBackOff) {
            hideLine();
            return;
          }
          var start0 = el.getPointAtLength(0);
          var dstart = el.getPointAtLength(0.1);
          startRot = Math.atan2(start0.y - dstart.y, start0.x - dstart.x);
          start = el.getPointAtLength(Math.min(startBackOff, pathlen));
          dashArray = "0px," + startBackOff + "px,";
          var end0 = el.getPointAtLength(pathlen);
          var dend = el.getPointAtLength(pathlen - 0.1);
          endRot = Math.atan2(end0.y - dend.y, end0.x - dend.x);
          end = el.getPointAtLength(Math.max(0, pathlen - backOff));
          var shortening = dashArray ? startBackOff + backOff : backOff;
          dashArray += pathlen - shortening + "px," + pathlen + "px";
          el3.style("stroke-dasharray", dashArray);
        }
        function hideLine() {
          el3.style("stroke-dasharray", "0px,100px");
        }
        function drawhead(arrowHeadStyle, p, rot, arrowScale) {
          if (!arrowHeadStyle.path) return;
          if (arrowHeadStyle.noRotate) rot = 0;
          d3.select(el.parentNode).append("path").attr({
            class: el3.attr("class"),
            d: arrowHeadStyle.path,
            transform: strTranslate(p.x, p.y) + strRotate(rot * 180 / Math.PI) + strScale(arrowScale)
          }).style({
            fill: Color.rgb(options.arrowcolor),
            "stroke-width": 0
          });
        }
        if (doStart) drawhead(startHeadStyle, start, startRot, startScale);
        if (doEnd) drawhead(headStyle, end, endRot, scale);
      };
    }
  });

  // src/components/annotations/draw.js
  var require_draw4 = __commonJS({
    "src/components/annotations/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Axes = require_axes();
      var Color = require_color();
      var Drawing = require_drawing();
      var Fx = require_fx();
      var svgTextUtils = require_svg_text_utils();
      var setCursor = require_setcursor();
      var dragElement = require_dragelement();
      var arrayEditor = require_plot_template().arrayEditor;
      var drawArrowHead = require_draw_arrow_head();
      module.exports = {
        draw,
        drawOne,
        drawRaw
      };
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        fullLayout._infolayer.selectAll(".annotation").remove();
        for (var i = 0; i < fullLayout.annotations.length; i++) {
          if (fullLayout.annotations[i].visible) {
            drawOne(gd, i);
          }
        }
        return Plots.previousPromises(gd);
      }
      function drawOne(gd, index) {
        var fullLayout = gd._fullLayout;
        var options = fullLayout.annotations[index] || {};
        var xa = Axes.getFromId(gd, options.xref);
        var ya = Axes.getFromId(gd, options.yref);
        if (xa) xa.setScale();
        if (ya) ya.setScale();
        drawRaw(gd, options, index, false, xa, ya);
      }
      function shiftPosition(axa, dAx, axLetter, gs, options) {
        var optAx = options[axLetter];
        var axRef = options[axLetter + "ref"];
        var vertical = axLetter.indexOf("y") !== -1;
        var axDomainRef = Axes.getRefType(axRef) === "domain";
        var gsDim = vertical ? gs.h : gs.w;
        if (axa) {
          if (axDomainRef) {
            return optAx + (vertical ? -dAx : dAx) / axa._length;
          } else {
            return axa.p2r(axa.r2p(optAx) + dAx);
          }
        } else {
          return optAx + (vertical ? -dAx : dAx) / gsDim;
        }
      }
      function drawRaw(gd, options, index, subplotId, xa, ya) {
        var fullLayout = gd._fullLayout;
        var gs = gd._fullLayout._size;
        var edits = gd._context.edits;
        var className, containerStr;
        if (subplotId) {
          className = "annotation-" + subplotId;
          containerStr = subplotId + ".annotations";
        } else {
          className = "annotation";
          containerStr = "annotations";
        }
        var editHelpers = arrayEditor(gd.layout, containerStr, options);
        var modifyBase = editHelpers.modifyBase;
        var modifyItem = editHelpers.modifyItem;
        var getUpdateObj = editHelpers.getUpdateObj;
        fullLayout._infolayer.selectAll("." + className + '[data-index="' + index + '"]').remove();
        var annClipID = "clip" + fullLayout._uid + "_ann" + index;
        if (!options._input || options.visible === false) {
          d3.selectAll("#" + annClipID).remove();
          return;
        }
        var annPosPx = { x: {}, y: {} };
        var textangle = +options.textangle || 0;
        var annGroup = fullLayout._infolayer.append("g").classed(className, true).attr("data-index", String(index)).style("opacity", options.opacity);
        var annTextGroup = annGroup.append("g").classed("annotation-text-g", true);
        var editTextPosition = edits[options.showarrow ? "annotationTail" : "annotationPosition"];
        var textEvents = options.captureevents || edits.annotationText || editTextPosition;
        function makeEventData(initialEvent) {
          var eventData = {
            index,
            annotation: options._input,
            fullAnnotation: options,
            event: initialEvent
          };
          if (subplotId) {
            eventData.subplotId = subplotId;
          }
          return eventData;
        }
        var annTextGroupInner = annTextGroup.append("g").style("pointer-events", textEvents ? "all" : null).call(setCursor, "pointer").on("click", function() {
          gd._dragging = false;
          gd.emit("plotly_clickannotation", makeEventData(d3.event));
        });
        if (options.hovertext) {
          annTextGroupInner.on("mouseover", function() {
            var hoverOptions = options.hoverlabel;
            var hoverFont = hoverOptions.font;
            var bBox = this.getBoundingClientRect();
            var bBoxRef = gd.getBoundingClientRect();
            Fx.loneHover({
              x0: bBox.left - bBoxRef.left,
              x1: bBox.right - bBoxRef.left,
              y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,
              text: options.hovertext,
              color: hoverOptions.bgcolor,
              borderColor: hoverOptions.bordercolor,
              fontFamily: hoverFont.family,
              fontSize: hoverFont.size,
              fontColor: hoverFont.color,
              fontWeight: hoverFont.weight,
              fontStyle: hoverFont.style,
              fontVariant: hoverFont.variant,
              fontShadow: hoverFont.fontShadow,
              fontLineposition: hoverFont.fontLineposition,
              fontTextcase: hoverFont.fontTextcase
            }, {
              container: fullLayout._hoverlayer.node(),
              outerContainer: fullLayout._paper.node(),
              gd
            });
          }).on("mouseout", function() {
            Fx.loneUnhover(fullLayout._hoverlayer.node());
          });
        }
        var borderwidth = options.borderwidth;
        var borderpad = options.borderpad;
        var borderfull = borderwidth + borderpad;
        var annTextBG = annTextGroupInner.append("rect").attr("class", "bg").style("stroke-width", borderwidth + "px").call(Color.stroke, options.bordercolor).call(Color.fill, options.bgcolor);
        var isSizeConstrained = options.width || options.height;
        var annTextClip = fullLayout._topclips.selectAll("#" + annClipID).data(isSizeConstrained ? [0] : []);
        annTextClip.enter().append("clipPath").classed("annclip", true).attr("id", annClipID).append("rect");
        annTextClip.exit().remove();
        var font = options.font;
        var text = fullLayout._meta ? Lib.templateString(options.text, fullLayout._meta) : options.text;
        var annText = annTextGroupInner.append("text").classed("annotation-text", true).text(text);
        function textLayout(s) {
          s.call(Drawing.font, font).attr({
            "text-anchor": {
              left: "start",
              right: "end"
            }[options.align] || "middle"
          });
          svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);
          return s;
        }
        function drawGraphicalElements() {
          var anchor3 = annText.selectAll("a");
          if (anchor3.size() === 1 && anchor3.text() === annText.text()) {
            var wholeLink = annTextGroupInner.insert("a", ":first-child").attr({
              "xlink:xlink:href": anchor3.attr("xlink:href"),
              "xlink:xlink:show": anchor3.attr("xlink:show")
            }).style({ cursor: "pointer" });
            wholeLink.node().appendChild(annTextBG.node());
          }
          var mathjaxGroup = annTextGroupInner.select(".annotation-text-math-group");
          var hasMathjax = !mathjaxGroup.empty();
          var anntextBB = Drawing.bBox(
            (hasMathjax ? mathjaxGroup : annText).node()
          );
          var textWidth = anntextBB.width;
          var textHeight = anntextBB.height;
          var annWidth = options.width || textWidth;
          var annHeight = options.height || textHeight;
          var outerWidth = Math.round(annWidth + 2 * borderfull);
          var outerHeight = Math.round(annHeight + 2 * borderfull);
          function shiftFraction(v, anchor2) {
            if (anchor2 === "auto") {
              if (v < 1 / 3) anchor2 = "left";
              else if (v > 2 / 3) anchor2 = "right";
              else anchor2 = "center";
            }
            return {
              center: 0,
              middle: 0,
              left: 0.5,
              bottom: -0.5,
              right: -0.5,
              top: 0.5
            }[anchor2];
          }
          var annotationIsOffscreen = false;
          var letters = ["x", "y"];
          for (var i = 0; i < letters.length; i++) {
            var axLetter = letters[i];
            var axRef = options[axLetter + "ref"] || axLetter;
            var tailRef = options["a" + axLetter + "ref"];
            var ax = { x: xa, y: ya }[axLetter];
            var dimAngle = (textangle + (axLetter === "x" ? 0 : -90)) * Math.PI / 180;
            var annSizeFromWidth = outerWidth * Math.cos(dimAngle);
            var annSizeFromHeight = outerHeight * Math.sin(dimAngle);
            var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);
            var anchor = options[axLetter + "anchor"];
            var overallShift = options[axLetter + "shift"] * (axLetter === "x" ? 1 : -1);
            var posPx = annPosPx[axLetter];
            var basePx;
            var textPadShift;
            var alignPosition;
            var autoAlignFraction;
            var textShift;
            var axRefType = Axes.getRefType(axRef);
            if (ax && axRefType !== "domain") {
              var posFraction = ax.r2fraction(options[axLetter]);
              if (posFraction < 0 || posFraction > 1) {
                if (tailRef === axRef) {
                  posFraction = ax.r2fraction(options["a" + axLetter]);
                  if (posFraction < 0 || posFraction > 1) {
                    annotationIsOffscreen = true;
                  }
                } else {
                  annotationIsOffscreen = true;
                }
              }
              basePx = ax._offset + ax.r2p(options[axLetter]);
              autoAlignFraction = 0.5;
            } else {
              var axRefTypeEqDomain = axRefType === "domain";
              if (axLetter === "x") {
                alignPosition = options[axLetter];
                basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.l + gs.w * alignPosition;
              } else {
                alignPosition = 1 - options[axLetter];
                basePx = axRefTypeEqDomain ? ax._offset + ax._length * alignPosition : basePx = gs.t + gs.h * alignPosition;
              }
              autoAlignFraction = options.showarrow ? 0.5 : alignPosition;
            }
            if (options.showarrow) {
              posPx.head = basePx;
              var arrowLength = options["a" + axLetter];
              textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) - annSizeFromHeight * shiftFraction(0.5, options.yanchor);
              if (tailRef === axRef) {
                var tailRefType = Axes.getRefType(tailRef);
                if (tailRefType === "domain") {
                  if (axLetter === "y") {
                    arrowLength = 1 - arrowLength;
                  }
                  posPx.tail = ax._offset + ax._length * arrowLength;
                } else if (tailRefType === "paper") {
                  if (axLetter === "y") {
                    arrowLength = 1 - arrowLength;
                    posPx.tail = gs.t + gs.h * arrowLength;
                  } else {
                    posPx.tail = gs.l + gs.w * arrowLength;
                  }
                } else {
                  posPx.tail = ax._offset + ax.r2p(arrowLength);
                }
                textPadShift = textShift;
              } else {
                posPx.tail = basePx + arrowLength;
                textPadShift = textShift + arrowLength;
              }
              posPx.text = posPx.tail + textShift;
              var maxPx = fullLayout[axLetter === "x" ? "width" : "height"];
              if (axRef === "paper") {
                posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);
              }
              if (tailRef === "pixel") {
                var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);
                var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;
                if (shiftPlus > 0) {
                  posPx.tail += shiftPlus;
                  posPx.text += shiftPlus;
                } else if (shiftMinus > 0) {
                  posPx.tail -= shiftMinus;
                  posPx.text -= shiftMinus;
                }
              }
              posPx.tail += overallShift;
              posPx.head += overallShift;
            } else {
              textShift = annSize * shiftFraction(autoAlignFraction, anchor);
              textPadShift = textShift;
              posPx.text = basePx + textShift;
            }
            posPx.text += overallShift;
            textShift += overallShift;
            textPadShift += overallShift;
            options["_" + axLetter + "padplus"] = annSize / 2 + textPadShift;
            options["_" + axLetter + "padminus"] = annSize / 2 - textPadShift;
            options["_" + axLetter + "size"] = annSize;
            options["_" + axLetter + "shift"] = textShift;
          }
          if (annotationIsOffscreen) {
            annTextGroupInner.remove();
            return;
          }
          var xShift = 0;
          var yShift = 0;
          if (options.align !== "left") {
            xShift = (annWidth - textWidth) * (options.align === "center" ? 0.5 : 1);
          }
          if (options.valign !== "top") {
            yShift = (annHeight - textHeight) * (options.valign === "middle" ? 0.5 : 1);
          }
          if (hasMathjax) {
            mathjaxGroup.select("svg").attr({
              x: borderfull + xShift - 1,
              y: borderfull + yShift
            }).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);
          } else {
            var texty = borderfull + yShift - anntextBB.top;
            var textx = borderfull + xShift - anntextBB.left;
            annText.call(svgTextUtils.positionText, textx, texty).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);
          }
          annTextClip.select("rect").call(
            Drawing.setRect,
            borderfull,
            borderfull,
            annWidth,
            annHeight
          );
          annTextBG.call(
            Drawing.setRect,
            borderwidth / 2,
            borderwidth / 2,
            outerWidth - borderwidth,
            outerHeight - borderwidth
          );
          annTextGroupInner.call(
            Drawing.setTranslate,
            Math.round(annPosPx.x.text - outerWidth / 2),
            Math.round(annPosPx.y.text - outerHeight / 2)
          );
          annTextGroup.attr({ transform: "rotate(" + textangle + "," + annPosPx.x.text + "," + annPosPx.y.text + ")" });
          var drawArrow = function(dx, dy) {
            annGroup.selectAll(".annotation-arrow-g").remove();
            var headX = annPosPx.x.head;
            var headY = annPosPx.y.head;
            var tailX = annPosPx.x.tail + dx;
            var tailY = annPosPx.y.tail + dy;
            var textX = annPosPx.x.text + dx;
            var textY = annPosPx.y.text + dy;
            var transform = Lib.rotationXYMatrix(textangle, textX, textY);
            var applyTransform = Lib.apply2DTransform(transform);
            var applyTransform2 = Lib.apply2DTransform2(transform);
            var width = +annTextBG.attr("width");
            var height = +annTextBG.attr("height");
            var xLeft = textX - 0.5 * width;
            var xRight = xLeft + width;
            var yTop = textY - 0.5 * height;
            var yBottom = yTop + height;
            var edges = [
              [xLeft, yTop, xLeft, yBottom],
              [xLeft, yBottom, xRight, yBottom],
              [xRight, yBottom, xRight, yTop],
              [xRight, yTop, xLeft, yTop]
            ].map(applyTransform2);
            if (edges.reduce(function(a, x) {
              return a ^ !!Lib.segmentsIntersect(
                headX,
                headY,
                headX + 1e6,
                headY + 1e6,
                x[0],
                x[1],
                x[2],
                x[3]
              );
            }, false)) {
              return;
            }
            edges.forEach(function(x) {
              var p = Lib.segmentsIntersect(
                tailX,
                tailY,
                headX,
                headY,
                x[0],
                x[1],
                x[2],
                x[3]
              );
              if (p) {
                tailX = p.x;
                tailY = p.y;
              }
            });
            var strokewidth = options.arrowwidth;
            var arrowColor = options.arrowcolor;
            var arrowSide = options.arrowside;
            var arrowGroup = annGroup.append("g").style({ opacity: Color.opacity(arrowColor) }).classed("annotation-arrow-g", true);
            var arrow = arrowGroup.append("path").attr("d", "M" + tailX + "," + tailY + "L" + headX + "," + headY).style("stroke-width", strokewidth + "px").call(Color.stroke, Color.rgb(arrowColor));
            drawArrowHead(arrow, arrowSide, options);
            if (edits.annotationPosition && arrow.node().parentNode && !subplotId) {
              var arrowDragHeadX = headX;
              var arrowDragHeadY = headY;
              if (options.standoff) {
                var arrowLength2 = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));
                arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength2;
                arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength2;
              }
              var arrowDrag = arrowGroup.append("path").classed("annotation-arrow", true).classed("anndrag", true).classed("cursor-move", true).attr({
                d: "M3,3H-3V-3H3ZM0,0L" + (tailX - arrowDragHeadX) + "," + (tailY - arrowDragHeadY),
                transform: strTranslate(arrowDragHeadX, arrowDragHeadY)
              }).style("stroke-width", strokewidth + 6 + "px").call(Color.stroke, "rgba(0,0,0,0)").call(Color.fill, "rgba(0,0,0,0)");
              var annx0, anny0;
              dragElement.init({
                element: arrowDrag.node(),
                gd,
                prepFn: function() {
                  var pos = Drawing.getTranslate(annTextGroupInner);
                  annx0 = pos.x;
                  anny0 = pos.y;
                  if (xa && xa.autorange) {
                    modifyBase(xa._name + ".autorange", true);
                  }
                  if (ya && ya.autorange) {
                    modifyBase(ya._name + ".autorange", true);
                  }
                },
                moveFn: function(dx2, dy2) {
                  var annxy0 = applyTransform(annx0, anny0);
                  var xcenter = annxy0[0] + dx2;
                  var ycenter = annxy0[1] + dy2;
                  annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);
                  modifyItem(
                    "x",
                    shiftPosition(xa, dx2, "x", gs, options)
                  );
                  modifyItem(
                    "y",
                    shiftPosition(ya, dy2, "y", gs, options)
                  );
                  if (options.axref === options.xref) {
                    modifyItem("ax", shiftPosition(xa, dx2, "ax", gs, options));
                  }
                  if (options.ayref === options.yref) {
                    modifyItem("ay", shiftPosition(ya, dy2, "ay", gs, options));
                  }
                  arrowGroup.attr("transform", strTranslate(dx2, dy2));
                  annTextGroup.attr({
                    transform: "rotate(" + textangle + "," + xcenter + "," + ycenter + ")"
                  });
                },
                doneFn: function() {
                  Registry.call("_guiRelayout", gd, getUpdateObj());
                  var notesBox = document.querySelector(".js-notes-box-panel");
                  if (notesBox) notesBox.redraw(notesBox.selectedObj);
                }
              });
            }
          };
          if (options.showarrow) drawArrow(0, 0);
          if (editTextPosition) {
            var baseTextTransform;
            dragElement.init({
              element: annTextGroupInner.node(),
              gd,
              prepFn: function() {
                baseTextTransform = annTextGroup.attr("transform");
              },
              moveFn: function(dx, dy) {
                var csr = "pointer";
                if (options.showarrow) {
                  if (options.axref === options.xref) {
                    modifyItem("ax", shiftPosition(xa, dx, "ax", gs, options));
                  } else {
                    modifyItem("ax", options.ax + dx);
                  }
                  if (options.ayref === options.yref) {
                    modifyItem("ay", shiftPosition(ya, dy, "ay", gs.w, options));
                  } else {
                    modifyItem("ay", options.ay + dy);
                  }
                  drawArrow(dx, dy);
                } else if (!subplotId) {
                  var xUpdate, yUpdate;
                  if (xa) {
                    xUpdate = shiftPosition(xa, dx, "x", gs, options);
                  } else {
                    var widthFraction = options._xsize / gs.w;
                    var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;
                    xUpdate = dragElement.align(
                      xLeft + dx / gs.w,
                      widthFraction,
                      0,
                      1,
                      options.xanchor
                    );
                  }
                  if (ya) {
                    yUpdate = shiftPosition(ya, dy, "y", gs, options);
                  } else {
                    var heightFraction = options._ysize / gs.h;
                    var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;
                    yUpdate = dragElement.align(
                      yBottom - dy / gs.h,
                      heightFraction,
                      0,
                      1,
                      options.yanchor
                    );
                  }
                  modifyItem("x", xUpdate);
                  modifyItem("y", yUpdate);
                  if (!xa || !ya) {
                    csr = dragElement.getCursor(
                      xa ? 0.5 : xUpdate,
                      ya ? 0.5 : yUpdate,
                      options.xanchor,
                      options.yanchor
                    );
                  }
                } else return;
                annTextGroup.attr({
                  transform: strTranslate(dx, dy) + baseTextTransform
                });
                setCursor(annTextGroupInner, csr);
              },
              clickFn: function(_, initialEvent) {
                if (options.captureevents) {
                  gd.emit("plotly_clickannotation", makeEventData(initialEvent));
                }
              },
              doneFn: function() {
                setCursor(annTextGroupInner);
                Registry.call("_guiRelayout", gd, getUpdateObj());
                var notesBox = document.querySelector(".js-notes-box-panel");
                if (notesBox) notesBox.redraw(notesBox.selectedObj);
              }
            });
          }
        }
        if (edits.annotationText) {
          annText.call(svgTextUtils.makeEditable, { delegate: annTextGroupInner, gd }).call(textLayout).on("edit", function(_text) {
            options.text = _text;
            this.call(textLayout);
            modifyItem("text", _text);
            if (xa && xa.autorange) {
              modifyBase(xa._name + ".autorange", true);
            }
            if (ya && ya.autorange) {
              modifyBase(ya._name + ".autorange", true);
            }
            Registry.call("_guiRelayout", gd, getUpdateObj());
          });
        } else annText.call(textLayout);
      }
    }
  });

  // src/components/annotations/click.js
  var require_click2 = __commonJS({
    "src/components/annotations/click.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      var arrayEditor = require_plot_template().arrayEditor;
      module.exports = {
        hasClickToShow,
        onClick
      };
      function hasClickToShow(gd, hoverData) {
        var sets = getToggleSets(gd, hoverData);
        return sets.on.length > 0 || sets.explicitOff.length > 0;
      }
      function onClick(gd, hoverData) {
        var toggleSets = getToggleSets(gd, hoverData);
        var onSet = toggleSets.on;
        var offSet = toggleSets.off.concat(toggleSets.explicitOff);
        var update = {};
        var annotationsOut = gd._fullLayout.annotations;
        var i, editHelpers;
        if (!(onSet.length || offSet.length)) return;
        for (i = 0; i < onSet.length; i++) {
          editHelpers = arrayEditor(gd.layout, "annotations", annotationsOut[onSet[i]]);
          editHelpers.modifyItem("visible", true);
          Lib.extendFlat(update, editHelpers.getUpdateObj());
        }
        for (i = 0; i < offSet.length; i++) {
          editHelpers = arrayEditor(gd.layout, "annotations", annotationsOut[offSet[i]]);
          editHelpers.modifyItem("visible", false);
          Lib.extendFlat(update, editHelpers.getUpdateObj());
        }
        return Registry.call("update", gd, {}, update);
      }
      function getToggleSets(gd, hoverData) {
        var annotations = gd._fullLayout.annotations;
        var onSet = [];
        var offSet = [];
        var explicitOffSet = [];
        var hoverLen = (hoverData || []).length;
        var i, j, anni, showMode, pointj, xa, ya, toggleType;
        for (i = 0; i < annotations.length; i++) {
          anni = annotations[i];
          showMode = anni.clicktoshow;
          if (showMode) {
            for (j = 0; j < hoverLen; j++) {
              pointj = hoverData[j];
              xa = pointj.xaxis;
              ya = pointj.yaxis;
              if (xa._id === anni.xref && ya._id === anni.yref && xa.d2r(pointj.x) === clickData2r(anni._xclick, xa) && ya.d2r(pointj.y) === clickData2r(anni._yclick, ya)) {
                if (anni.visible) {
                  if (showMode === "onout") toggleType = offSet;
                  else toggleType = explicitOffSet;
                } else {
                  toggleType = onSet;
                }
                toggleType.push(i);
                break;
              }
            }
            if (j === hoverLen) {
              if (anni.visible && showMode === "onout") offSet.push(i);
            }
          }
        }
        return { on: onSet, off: offSet, explicitOff: explicitOffSet };
      }
      function clickData2r(d, ax) {
        return ax.type === "log" ? ax.l2r(d) : ax.d2r(d);
      }
    }
  });

  // src/components/annotations/common_defaults.js
  var require_common_defaults = __commonJS({
    "src/components/annotations/common_defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      module.exports = function handleAnnotationCommonDefaults(annIn, annOut, fullLayout, coerce) {
        coerce("opacity");
        var bgColor = coerce("bgcolor");
        var borderColor = coerce("bordercolor");
        var borderOpacity = Color.opacity(borderColor);
        coerce("borderpad");
        var borderWidth = coerce("borderwidth");
        var showArrow = coerce("showarrow");
        coerce("text", showArrow ? " " : fullLayout._dfltTitle.annotation);
        coerce("textangle");
        Lib.coerceFont(coerce, "font", fullLayout.font);
        coerce("width");
        coerce("align");
        var h = coerce("height");
        if (h) coerce("valign");
        if (showArrow) {
          var arrowside = coerce("arrowside");
          var arrowhead;
          var arrowsize;
          if (arrowside.indexOf("end") !== -1) {
            arrowhead = coerce("arrowhead");
            arrowsize = coerce("arrowsize");
          }
          if (arrowside.indexOf("start") !== -1) {
            coerce("startarrowhead", arrowhead);
            coerce("startarrowsize", arrowsize);
          }
          coerce("arrowcolor", borderOpacity ? annOut.bordercolor : Color.defaultLine);
          coerce("arrowwidth", (borderOpacity && borderWidth || 1) * 2);
          coerce("standoff");
          coerce("startstandoff");
        }
        var hoverText = coerce("hovertext");
        var globalHoverLabel = fullLayout.hoverlabel || {};
        if (hoverText) {
          var hoverBG = coerce(
            "hoverlabel.bgcolor",
            globalHoverLabel.bgcolor || (Color.opacity(bgColor) ? Color.rgb(bgColor) : Color.defaultLine)
          );
          var hoverBorder = coerce(
            "hoverlabel.bordercolor",
            globalHoverLabel.bordercolor || Color.contrast(hoverBG)
          );
          var fontDflt = Lib.extendFlat({}, globalHoverLabel.font);
          if (!fontDflt.color) {
            fontDflt.color = hoverBorder;
          }
          Lib.coerceFont(coerce, "hoverlabel.font", fontDflt);
        }
        coerce("captureevents", !!hoverText);
      };
    }
  });

  // src/components/annotations/defaults.js
  var require_defaults9 = __commonJS({
    "src/components/annotations/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var handleAnnotationCommonDefaults = require_common_defaults();
      var attributes = require_attributes11();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name: "annotations",
          handleItemDefaults: handleAnnotationDefaults
        });
      };
      function handleAnnotationDefaults(annIn, annOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(annIn, annOut, attributes, attr, dflt);
        }
        var visible = coerce("visible");
        var clickToShow = coerce("clicktoshow");
        if (!(visible || clickToShow)) return;
        handleAnnotationCommonDefaults(annIn, annOut, fullLayout, coerce);
        var showArrow = annOut.showarrow;
        var axLetters = ["x", "y"];
        var arrowPosDflt = [-10, -30];
        var gdMock = { _fullLayout: fullLayout };
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var axRef = Axes.coerceRef(annIn, annOut, gdMock, axLetter, "", "paper");
          if (axRef !== "paper") {
            var ax = Axes.getFromId(gdMock, axRef);
            ax._annIndices.push(annOut._index);
          }
          Axes.coercePosition(annOut, gdMock, coerce, axRef, axLetter, 0.5);
          if (showArrow) {
            var arrowPosAttr = "a" + axLetter;
            var aaxRef = Axes.coerceRef(
              annIn,
              annOut,
              gdMock,
              arrowPosAttr,
              "pixel",
              ["pixel", "paper"]
            );
            if (aaxRef !== "pixel" && aaxRef !== axRef) {
              aaxRef = annOut[arrowPosAttr] = "pixel";
            }
            var aDflt = aaxRef === "pixel" ? arrowPosDflt[i] : 0.4;
            Axes.coercePosition(annOut, gdMock, coerce, aaxRef, arrowPosAttr, aDflt);
          }
          coerce(axLetter + "anchor");
          coerce(axLetter + "shift");
        }
        Lib.noneOrAll(annIn, annOut, ["x", "y"]);
        if (showArrow) {
          Lib.noneOrAll(annIn, annOut, ["ax", "ay"]);
        }
        if (clickToShow) {
          var xClick = coerce("xclick");
          var yClick = coerce("yclick");
          annOut._xclick = xClick === void 0 ? annOut.x : Axes.cleanPosition(xClick, gdMock, annOut.xref);
          annOut._yclick = yClick === void 0 ? annOut.y : Axes.cleanPosition(yClick, gdMock, annOut.yref);
        }
      }
    }
  });

  // src/components/annotations/calc_autorange.js
  var require_calc_autorange = __commonJS({
    "src/components/annotations/calc_autorange.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var draw = require_draw4().draw;
      module.exports = function calcAutorange(gd) {
        var fullLayout = gd._fullLayout;
        var annotationList = Lib.filterVisible(fullLayout.annotations);
        if (annotationList.length && gd._fullData.length) {
          return Lib.syncOrAsync([draw, annAutorange], gd);
        }
      };
      function annAutorange(gd) {
        var fullLayout = gd._fullLayout;
        Lib.filterVisible(fullLayout.annotations).forEach(function(ann) {
          var xa = Axes.getFromId(gd, ann.xref);
          var ya = Axes.getFromId(gd, ann.yref);
          var xRefType = Axes.getRefType(ann.xref);
          var yRefType = Axes.getRefType(ann.yref);
          ann._extremes = {};
          if (xRefType === "range") calcAxisExpansion(ann, xa);
          if (yRefType === "range") calcAxisExpansion(ann, ya);
        });
      }
      function calcAxisExpansion(ann, ax) {
        var axId = ax._id;
        var letter = axId.charAt(0);
        var pos = ann[letter];
        var apos = ann["a" + letter];
        var ref = ann[letter + "ref"];
        var aref = ann["a" + letter + "ref"];
        var padplus = ann["_" + letter + "padplus"];
        var padminus = ann["_" + letter + "padminus"];
        var shift = { x: 1, y: -1 }[letter] * ann[letter + "shift"];
        var headSize = 3 * ann.arrowsize * ann.arrowwidth || 0;
        var headPlus = headSize + shift;
        var headMinus = headSize - shift;
        var startHeadSize = 3 * ann.startarrowsize * ann.arrowwidth || 0;
        var startHeadPlus = startHeadSize + shift;
        var startHeadMinus = startHeadSize - shift;
        var extremes;
        if (aref === ref) {
          var extremeArrowHead = Axes.findExtremes(ax, [ax.r2c(pos)], {
            ppadplus: headPlus,
            ppadminus: headMinus
          });
          var extremeText = Axes.findExtremes(ax, [ax.r2c(apos)], {
            ppadplus: Math.max(padplus, startHeadPlus),
            ppadminus: Math.max(padminus, startHeadMinus)
          });
          extremes = {
            min: [extremeArrowHead.min[0], extremeText.min[0]],
            max: [extremeArrowHead.max[0], extremeText.max[0]]
          };
        } else {
          startHeadPlus = apos ? startHeadPlus + apos : startHeadPlus;
          startHeadMinus = apos ? startHeadMinus - apos : startHeadMinus;
          extremes = Axes.findExtremes(ax, [ax.r2c(pos)], {
            ppadplus: Math.max(padplus, headPlus, startHeadPlus),
            ppadminus: Math.max(padminus, headMinus, startHeadMinus)
          });
        }
        ann._extremes[axId] = extremes;
      }
    }
  });

  // src/components/annotations/convert_coords.js
  var require_convert_coords = __commonJS({
    "src/components/annotations/convert_coords.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var toLogRange = require_to_log_range();
      module.exports = function convertCoords(gd, ax, newType, doExtra) {
        ax = ax || {};
        var toLog = newType === "log" && ax.type === "linear";
        var fromLog = newType === "linear" && ax.type === "log";
        if (!(toLog || fromLog)) return;
        var annotations = gd._fullLayout.annotations;
        var axLetter = ax._id.charAt(0);
        var ann;
        var attrPrefix;
        function convert(attr) {
          var currentVal = ann[attr];
          var newVal = null;
          if (toLog) newVal = toLogRange(currentVal, ax.range);
          else newVal = Math.pow(10, currentVal);
          if (!isNumeric(newVal)) newVal = null;
          doExtra(attrPrefix + attr, newVal);
        }
        for (var i = 0; i < annotations.length; i++) {
          ann = annotations[i];
          attrPrefix = "annotations[" + i + "].";
          if (ann[axLetter + "ref"] === ax._id) convert(axLetter);
          if (ann["a" + axLetter + "ref"] === ax._id) convert("a" + axLetter);
        }
      };
    }
  });

  // src/components/annotations/index.js
  var require_annotations = __commonJS({
    "src/components/annotations/index.js"(exports, module) {
      "use strict";
      var drawModule = require_draw4();
      var clickModule = require_click2();
      module.exports = {
        moduleType: "component",
        name: "annotations",
        layoutAttributes: require_attributes11(),
        supplyLayoutDefaults: require_defaults9(),
        includeBasePlot: require_include_components()("annotations"),
        calcAutorange: require_calc_autorange(),
        draw: drawModule.draw,
        drawOne: drawModule.drawOne,
        drawRaw: drawModule.drawRaw,
        hasClickToShow: clickModule.hasClickToShow,
        onClick: clickModule.onClick,
        convertCoords: require_convert_coords()
      };
    }
  });

  // src/components/annotations3d/attributes.js
  var require_attributes15 = __commonJS({
    "src/components/annotations3d/attributes.js"(exports, module) {
      "use strict";
      var annAttrs = require_attributes11();
      var overrideAll = require_edit_types().overrideAll;
      var templatedArray = require_plot_template().templatedArray;
      module.exports = overrideAll(templatedArray("annotation", {
        visible: annAttrs.visible,
        x: {
          valType: "any"
        },
        y: {
          valType: "any"
        },
        z: {
          valType: "any"
        },
        ax: {
          valType: "number"
        },
        ay: {
          valType: "number"
        },
        xanchor: annAttrs.xanchor,
        xshift: annAttrs.xshift,
        yanchor: annAttrs.yanchor,
        yshift: annAttrs.yshift,
        text: annAttrs.text,
        textangle: annAttrs.textangle,
        font: annAttrs.font,
        width: annAttrs.width,
        height: annAttrs.height,
        opacity: annAttrs.opacity,
        align: annAttrs.align,
        valign: annAttrs.valign,
        bgcolor: annAttrs.bgcolor,
        bordercolor: annAttrs.bordercolor,
        borderpad: annAttrs.borderpad,
        borderwidth: annAttrs.borderwidth,
        showarrow: annAttrs.showarrow,
        arrowcolor: annAttrs.arrowcolor,
        arrowhead: annAttrs.arrowhead,
        startarrowhead: annAttrs.startarrowhead,
        arrowside: annAttrs.arrowside,
        arrowsize: annAttrs.arrowsize,
        startarrowsize: annAttrs.startarrowsize,
        arrowwidth: annAttrs.arrowwidth,
        standoff: annAttrs.standoff,
        startstandoff: annAttrs.startstandoff,
        hovertext: annAttrs.hovertext,
        hoverlabel: annAttrs.hoverlabel,
        captureevents: annAttrs.captureevents
        // maybes later?
        // clicktoshow: annAttrs.clicktoshow,
        // xclick: annAttrs.xclick,
        // yclick: annAttrs.yclick,
        // not needed!
        // axref: 'pixel'
        // ayref: 'pixel'
        // xref: 'x'
        // yref: 'y
        // zref: 'z'
      }), "calc", "from-root");
    }
  });

  // src/components/annotations3d/defaults.js
  var require_defaults10 = __commonJS({
    "src/components/annotations3d/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var handleAnnotationCommonDefaults = require_common_defaults();
      var attributes = require_attributes15();
      module.exports = function handleDefaults(sceneLayoutIn, sceneLayoutOut, opts) {
        handleArrayContainerDefaults(sceneLayoutIn, sceneLayoutOut, {
          name: "annotations",
          handleItemDefaults: handleAnnotationDefaults,
          fullLayout: opts.fullLayout
        });
      };
      function handleAnnotationDefaults(annIn, annOut, sceneLayout, opts) {
        function coerce(attr, dflt) {
          return Lib.coerce(annIn, annOut, attributes, attr, dflt);
        }
        function coercePosition(axLetter) {
          var axName = axLetter + "axis";
          var gdMock = { _fullLayout: {} };
          gdMock._fullLayout[axName] = sceneLayout[axName];
          return Axes.coercePosition(annOut, gdMock, coerce, axLetter, axLetter, 0.5);
        }
        var visible = coerce("visible");
        if (!visible) return;
        handleAnnotationCommonDefaults(annIn, annOut, opts.fullLayout, coerce);
        coercePosition("x");
        coercePosition("y");
        coercePosition("z");
        Lib.noneOrAll(annIn, annOut, ["x", "y", "z"]);
        annOut.xref = "x";
        annOut.yref = "y";
        annOut.zref = "z";
        coerce("xanchor");
        coerce("yanchor");
        coerce("xshift");
        coerce("yshift");
        if (annOut.showarrow) {
          annOut.axref = "pixel";
          annOut.ayref = "pixel";
          coerce("ax", -10);
          coerce("ay", -30);
          Lib.noneOrAll(annIn, annOut, ["ax", "ay"]);
        }
      }
    }
  });

  // src/components/annotations3d/convert.js
  var require_convert = __commonJS({
    "src/components/annotations3d/convert.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      module.exports = function convert(scene) {
        var fullSceneLayout = scene.fullSceneLayout;
        var anns = fullSceneLayout.annotations;
        for (var i = 0; i < anns.length; i++) {
          mockAnnAxes(anns[i], scene);
        }
        scene.fullLayout._infolayer.selectAll(".annotation-" + scene.id).remove();
      };
      function mockAnnAxes(ann, scene) {
        var fullSceneLayout = scene.fullSceneLayout;
        var domain = fullSceneLayout.domain;
        var size = scene.fullLayout._size;
        var base = {
          // this gets fill in on render
          pdata: null,
          // to get setConvert to not execute cleanly
          type: "linear",
          // don't try to update them on `editable: true`
          autorange: false,
          // set infinite range so that annotation draw routine
          // does not try to remove 'outside-range' annotations,
          // this case is handled in the render loop
          range: [-Infinity, Infinity]
        };
        ann._xa = {};
        Lib.extendFlat(ann._xa, base);
        Axes.setConvert(ann._xa);
        ann._xa._offset = size.l + domain.x[0] * size.w;
        ann._xa.l2p = function() {
          return 0.5 * (1 + ann._pdata[0] / ann._pdata[3]) * size.w * (domain.x[1] - domain.x[0]);
        };
        ann._ya = {};
        Lib.extendFlat(ann._ya, base);
        Axes.setConvert(ann._ya);
        ann._ya._offset = size.t + (1 - domain.y[1]) * size.h;
        ann._ya.l2p = function() {
          return 0.5 * (1 - ann._pdata[1] / ann._pdata[3]) * size.h * (domain.y[1] - domain.y[0]);
        };
      }
    }
  });

  // src/plots/gl3d/project.js
  var require_project = __commonJS({
    "src/plots/gl3d/project.js"(exports, module) {
      "use strict";
      function xformMatrix(m, v) {
        var out = [0, 0, 0, 0];
        var i, j;
        for (i = 0; i < 4; ++i) {
          for (j = 0; j < 4; ++j) {
            out[j] += m[4 * i + j] * v[i];
          }
        }
        return out;
      }
      function project(camera, v) {
        var p = xformMatrix(
          camera.projection,
          xformMatrix(
            camera.view,
            xformMatrix(camera.model, [v[0], v[1], v[2], 1])
          )
        );
        return p;
      }
      module.exports = project;
    }
  });

  // src/components/annotations3d/draw.js
  var require_draw5 = __commonJS({
    "src/components/annotations3d/draw.js"(exports, module) {
      "use strict";
      var drawRaw = require_draw4().drawRaw;
      var project = require_project();
      var axLetters = ["x", "y", "z"];
      module.exports = function draw(scene) {
        var fullSceneLayout = scene.fullSceneLayout;
        var dataScale = scene.dataScale;
        var anns = fullSceneLayout.annotations;
        for (var i = 0; i < anns.length; i++) {
          var ann = anns[i];
          var annotationIsOffscreen = false;
          for (var j = 0; j < 3; j++) {
            var axLetter = axLetters[j];
            var pos = ann[axLetter];
            var ax = fullSceneLayout[axLetter + "axis"];
            var posFraction = ax.r2fraction(pos);
            if (posFraction < 0 || posFraction > 1) {
              annotationIsOffscreen = true;
              break;
            }
          }
          if (annotationIsOffscreen) {
            scene.fullLayout._infolayer.select(".annotation-" + scene.id + '[data-index="' + i + '"]').remove();
          } else {
            ann._pdata = project(scene.glplot.cameraParams, [
              fullSceneLayout.xaxis.r2l(ann.x) * dataScale[0],
              fullSceneLayout.yaxis.r2l(ann.y) * dataScale[1],
              fullSceneLayout.zaxis.r2l(ann.z) * dataScale[2]
            ]);
            drawRaw(scene.graphDiv, ann, i, scene.id, ann._xa, ann._ya);
          }
        }
      };
    }
  });

  // src/components/annotations3d/index.js
  var require_annotations3d = __commonJS({
    "src/components/annotations3d/index.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      module.exports = {
        moduleType: "component",
        name: "annotations3d",
        schema: {
          subplots: {
            scene: { annotations: require_attributes15() }
          }
        },
        layoutAttributes: require_attributes15(),
        handleDefaults: require_defaults10(),
        includeBasePlot: includeGL3D,
        convert: require_convert(),
        draw: require_draw5()
      };
      function includeGL3D(layoutIn, layoutOut) {
        var GL3D = Registry.subplotsRegistry.gl3d;
        if (!GL3D) return;
        var attrRegex = GL3D.attrRegex;
        var keys = Object.keys(layoutIn);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          if (attrRegex.test(k) && (layoutIn[k].annotations || []).length) {
            Lib.pushUnique(layoutOut._basePlotModules, GL3D);
            Lib.pushUnique(layoutOut._subplots.gl3d, k);
          }
        }
      }
    }
  });

  // src/components/shapes/attributes.js
  var require_attributes16 = __commonJS({
    "src/components/shapes/attributes.js"(exports, module) {
      "use strict";
      var annAttrs = require_attributes11();
      var fontAttrs = require_font_attributes();
      var scatterLineAttrs = require_attributes12().line;
      var dash = require_attributes4().dash;
      var extendFlat = require_extend().extendFlat;
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      var basePlotAttributes = require_attributes2();
      var shapeTexttemplateAttrs = require_template_attributes().shapeTexttemplateAttrs;
      var shapeLabelTexttemplateVars = require_label_texttemplate();
      module.exports = templatedArray("shape", {
        visible: extendFlat({}, basePlotAttributes.visible, {
          editType: "calc+arraydraw"
        }),
        showlegend: {
          valType: "boolean",
          dflt: false,
          editType: "calc+arraydraw"
        },
        legend: extendFlat({}, basePlotAttributes.legend, {
          editType: "calc+arraydraw"
        }),
        legendgroup: extendFlat({}, basePlotAttributes.legendgroup, {
          editType: "calc+arraydraw"
        }),
        legendgrouptitle: {
          text: extendFlat({}, basePlotAttributes.legendgrouptitle.text, {
            editType: "calc+arraydraw"
          }),
          font: fontAttrs({
            editType: "calc+arraydraw"
          }),
          editType: "calc+arraydraw"
        },
        legendrank: extendFlat({}, basePlotAttributes.legendrank, {
          editType: "calc+arraydraw"
        }),
        legendwidth: extendFlat({}, basePlotAttributes.legendwidth, {
          editType: "calc+arraydraw"
        }),
        type: {
          valType: "enumerated",
          values: ["circle", "rect", "path", "line"],
          editType: "calc+arraydraw"
        },
        layer: {
          valType: "enumerated",
          values: ["below", "above", "between"],
          dflt: "above",
          editType: "arraydraw"
        },
        xref: extendFlat({}, annAttrs.xref, {}),
        xsizemode: {
          valType: "enumerated",
          values: ["scaled", "pixel"],
          dflt: "scaled",
          editType: "calc+arraydraw"
        },
        xanchor: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        x0: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        x1: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        x0shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        x1shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        yref: extendFlat({}, annAttrs.yref, {}),
        ysizemode: {
          valType: "enumerated",
          values: ["scaled", "pixel"],
          dflt: "scaled",
          editType: "calc+arraydraw"
        },
        yanchor: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        y0: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        y1: {
          valType: "any",
          editType: "calc+arraydraw"
        },
        y0shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        y1shift: {
          valType: "number",
          dflt: 0,
          min: -1,
          max: 1,
          editType: "calc"
        },
        path: {
          valType: "string",
          editType: "calc+arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "arraydraw"
        },
        line: {
          color: extendFlat({}, scatterLineAttrs.color, { editType: "arraydraw" }),
          width: extendFlat({}, scatterLineAttrs.width, { editType: "calc+arraydraw" }),
          dash: extendFlat({}, dash, { editType: "arraydraw" }),
          editType: "calc+arraydraw"
        },
        fillcolor: {
          valType: "color",
          dflt: "rgba(0,0,0,0)",
          editType: "arraydraw"
        },
        fillrule: {
          valType: "enumerated",
          values: ["evenodd", "nonzero"],
          dflt: "evenodd",
          editType: "arraydraw"
        },
        editable: {
          valType: "boolean",
          dflt: false,
          editType: "calc+arraydraw"
        },
        label: {
          text: {
            valType: "string",
            dflt: "",
            editType: "arraydraw"
          },
          texttemplate: shapeTexttemplateAttrs({}, { keys: Object.keys(shapeLabelTexttemplateVars) }),
          font: fontAttrs({
            editType: "calc+arraydraw",
            colorEditType: "arraydraw"
          }),
          textposition: {
            valType: "enumerated",
            values: [
              "top left",
              "top center",
              "top right",
              "middle left",
              "middle center",
              "middle right",
              "bottom left",
              "bottom center",
              "bottom right",
              "start",
              "middle",
              "end"
            ],
            editType: "arraydraw"
          },
          textangle: {
            valType: "angle",
            dflt: "auto",
            editType: "calc+arraydraw"
          },
          xanchor: {
            valType: "enumerated",
            values: ["auto", "left", "center", "right"],
            dflt: "auto",
            editType: "calc+arraydraw"
          },
          yanchor: {
            valType: "enumerated",
            values: ["top", "middle", "bottom"],
            editType: "calc+arraydraw"
          },
          padding: {
            valType: "number",
            dflt: 3,
            min: 0,
            editType: "arraydraw"
          },
          editType: "arraydraw"
        },
        editType: "arraydraw"
      });
    }
  });

  // src/components/shapes/defaults.js
  var require_defaults11 = __commonJS({
    "src/components/shapes/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes16();
      var helpers = require_helpers8();
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name: "shapes",
          handleItemDefaults: handleShapeDefaults
        });
      };
      function dfltLabelYanchor(isLine, labelTextPosition) {
        return isLine ? "bottom" : labelTextPosition.indexOf("top") !== -1 ? "top" : labelTextPosition.indexOf("bottom") !== -1 ? "bottom" : "middle";
      }
      function handleShapeDefaults(shapeIn, shapeOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(shapeIn, shapeOut, attributes, attr, dflt);
        }
        shapeOut._isShape = true;
        var visible = coerce("visible");
        if (!visible) return;
        var showlegend = coerce("showlegend");
        if (showlegend) {
          coerce("legend");
          coerce("legendwidth");
          coerce("legendgroup");
          coerce("legendgrouptitle.text");
          Lib.coerceFont(coerce, "legendgrouptitle.font");
          coerce("legendrank");
        }
        var path = coerce("path");
        var dfltType = path ? "path" : "rect";
        var shapeType = coerce("type", dfltType);
        var noPath = shapeType !== "path";
        if (noPath) delete shapeOut.path;
        coerce("editable");
        coerce("layer");
        coerce("opacity");
        coerce("fillcolor");
        coerce("fillrule");
        var lineWidth = coerce("line.width");
        if (lineWidth) {
          coerce("line.color");
          coerce("line.dash");
        }
        var xSizeMode = coerce("xsizemode");
        var ySizeMode = coerce("ysizemode");
        var axLetters = ["x", "y"];
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var attrAnchor = axLetter + "anchor";
          var sizeMode = axLetter === "x" ? xSizeMode : ySizeMode;
          var gdMock = { _fullLayout: fullLayout };
          var ax;
          var pos2r;
          var r2pos;
          var axRef = Axes.coerceRef(
            shapeIn,
            shapeOut,
            gdMock,
            axLetter,
            void 0,
            "paper"
          );
          var axRefType = Axes.getRefType(axRef);
          if (axRefType === "range") {
            ax = Axes.getFromId(gdMock, axRef);
            ax._shapeIndices.push(shapeOut._index);
            r2pos = helpers.rangeToShapePosition(ax);
            pos2r = helpers.shapePositionToRange(ax);
            if (ax.type === "category" || ax.type === "multicategory") {
              coerce(axLetter + "0shift");
              coerce(axLetter + "1shift");
            }
          } else {
            pos2r = r2pos = Lib.identity;
          }
          if (noPath) {
            var dflt0 = 0.25;
            var dflt1 = 0.75;
            var attr0 = axLetter + "0";
            var attr1 = axLetter + "1";
            var in0 = shapeIn[attr0];
            var in1 = shapeIn[attr1];
            shapeIn[attr0] = pos2r(shapeIn[attr0], true);
            shapeIn[attr1] = pos2r(shapeIn[attr1], true);
            if (sizeMode === "pixel") {
              coerce(attr0, 0);
              coerce(attr1, 10);
            } else {
              Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr0, dflt0);
              Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attr1, dflt1);
            }
            shapeOut[attr0] = r2pos(shapeOut[attr0]);
            shapeOut[attr1] = r2pos(shapeOut[attr1]);
            shapeIn[attr0] = in0;
            shapeIn[attr1] = in1;
          }
          if (sizeMode === "pixel") {
            var inAnchor = shapeIn[attrAnchor];
            shapeIn[attrAnchor] = pos2r(shapeIn[attrAnchor], true);
            Axes.coercePosition(shapeOut, gdMock, coerce, axRef, attrAnchor, 0.25);
            shapeOut[attrAnchor] = r2pos(shapeOut[attrAnchor]);
            shapeIn[attrAnchor] = inAnchor;
          }
        }
        if (noPath) {
          Lib.noneOrAll(shapeIn, shapeOut, ["x0", "x1", "y0", "y1"]);
        }
        var isLine = shapeType === "line";
        var labelTextTemplate, labelText;
        if (noPath) {
          labelTextTemplate = coerce("label.texttemplate");
        }
        if (!labelTextTemplate) {
          labelText = coerce("label.text");
        }
        if (labelText || labelTextTemplate) {
          coerce("label.textangle");
          var labelTextPosition = coerce("label.textposition", isLine ? "middle" : "middle center");
          coerce("label.xanchor");
          coerce("label.yanchor", dfltLabelYanchor(isLine, labelTextPosition));
          coerce("label.padding");
          Lib.coerceFont(coerce, "label.font", fullLayout.font);
        }
      }
    }
  });

  // src/components/shapes/draw_newshape/defaults.js
  var require_defaults12 = __commonJS({
    "src/components/shapes/draw_newshape/defaults.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var Lib = require_lib();
      function dfltLabelYanchor(isLine, labelTextPosition) {
        return isLine ? "bottom" : labelTextPosition.indexOf("top") !== -1 ? "top" : labelTextPosition.indexOf("bottom") !== -1 ? "bottom" : "middle";
      }
      module.exports = function supplyDrawNewShapeDefaults(layoutIn, layoutOut, coerce) {
        coerce("newshape.visible");
        coerce("newshape.name");
        coerce("newshape.showlegend");
        coerce("newshape.legend");
        coerce("newshape.legendwidth");
        coerce("newshape.legendgroup");
        coerce("newshape.legendgrouptitle.text");
        Lib.coerceFont(coerce, "newshape.legendgrouptitle.font");
        coerce("newshape.legendrank");
        coerce("newshape.drawdirection");
        coerce("newshape.layer");
        coerce("newshape.fillcolor");
        coerce("newshape.fillrule");
        coerce("newshape.opacity");
        var newshapeLineWidth = coerce("newshape.line.width");
        if (newshapeLineWidth) {
          var bgcolor = (layoutIn || {}).plot_bgcolor || "#FFF";
          coerce("newshape.line.color", Color.contrast(bgcolor));
          coerce("newshape.line.dash");
        }
        var isLine = layoutIn.dragmode === "drawline";
        var labelText = coerce("newshape.label.text");
        var labelTextTemplate = coerce("newshape.label.texttemplate");
        if (labelText || labelTextTemplate) {
          coerce("newshape.label.textangle");
          var labelTextPosition = coerce("newshape.label.textposition", isLine ? "middle" : "middle center");
          coerce("newshape.label.xanchor");
          coerce("newshape.label.yanchor", dfltLabelYanchor(isLine, labelTextPosition));
          coerce("newshape.label.padding");
          Lib.coerceFont(coerce, "newshape.label.font", layoutOut.font);
        }
        coerce("activeshape.fillcolor");
        coerce("activeshape.opacity");
      };
    }
  });

  // src/components/shapes/calc_autorange.js
  var require_calc_autorange2 = __commonJS({
    "src/components/shapes/calc_autorange.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var constants = require_constants5();
      var helpers = require_helpers8();
      module.exports = function calcAutorange(gd) {
        var fullLayout = gd._fullLayout;
        var shapeList = Lib.filterVisible(fullLayout.shapes);
        if (!shapeList.length || !gd._fullData.length) return;
        for (var i = 0; i < shapeList.length; i++) {
          var shape = shapeList[i];
          shape._extremes = {};
          var ax;
          var bounds;
          var xRefType = Axes.getRefType(shape.xref);
          var yRefType = Axes.getRefType(shape.yref);
          if (shape.xref !== "paper" && xRefType !== "domain") {
            ax = Axes.getFromId(gd, shape.xref);
            bounds = shapeBounds(ax, shape, constants.paramIsX);
            if (bounds) {
              shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcXPaddingOptions(shape));
            }
          }
          if (shape.yref !== "paper" && yRefType !== "domain") {
            ax = Axes.getFromId(gd, shape.yref);
            bounds = shapeBounds(ax, shape, constants.paramIsY);
            if (bounds) {
              shape._extremes[ax._id] = Axes.findExtremes(ax, bounds, calcYPaddingOptions(shape));
            }
          }
        }
      };
      function calcXPaddingOptions(shape) {
        return calcPaddingOptions(shape.line.width, shape.xsizemode, shape.x0, shape.x1, shape.path, false);
      }
      function calcYPaddingOptions(shape) {
        return calcPaddingOptions(shape.line.width, shape.ysizemode, shape.y0, shape.y1, shape.path, true);
      }
      function calcPaddingOptions(lineWidth, sizeMode, v0, v1, path, isYAxis) {
        var ppad = lineWidth / 2;
        var axisDirectionReverted = isYAxis;
        if (sizeMode === "pixel") {
          var coords = path ? helpers.extractPathCoords(path, isYAxis ? constants.paramIsY : constants.paramIsX) : [v0, v1];
          var maxValue = Lib.aggNums(Math.max, null, coords);
          var minValue = Lib.aggNums(Math.min, null, coords);
          var beforePad = minValue < 0 ? Math.abs(minValue) + ppad : ppad;
          var afterPad = maxValue > 0 ? maxValue + ppad : ppad;
          return {
            ppad,
            ppadplus: axisDirectionReverted ? beforePad : afterPad,
            ppadminus: axisDirectionReverted ? afterPad : beforePad
          };
        } else {
          return { ppad };
        }
      }
      function shapeBounds(ax, shape, paramsToUse) {
        var dim = ax._id.charAt(0) === "x" ? "x" : "y";
        var isCategory = ax.type === "category" || ax.type === "multicategory";
        var v0;
        var v1;
        var shiftStart = 0;
        var shiftEnd = 0;
        var convertVal = isCategory ? ax.r2c : ax.d2c;
        var isSizeModeScale = shape[dim + "sizemode"] === "scaled";
        if (isSizeModeScale) {
          v0 = shape[dim + "0"];
          v1 = shape[dim + "1"];
          if (isCategory) {
            shiftStart = shape[dim + "0shift"];
            shiftEnd = shape[dim + "1shift"];
          }
        } else {
          v0 = shape[dim + "anchor"];
          v1 = shape[dim + "anchor"];
        }
        if (v0 !== void 0) return [convertVal(v0) + shiftStart, convertVal(v1) + shiftEnd];
        if (!shape.path) return;
        var min = Infinity;
        var max = -Infinity;
        var segments = shape.path.match(constants.segmentRE);
        var i;
        var segment;
        var drawnParam;
        var params;
        var val;
        if (ax.type === "date") convertVal = helpers.decodeDate(convertVal);
        for (i = 0; i < segments.length; i++) {
          segment = segments[i];
          drawnParam = paramsToUse[segment.charAt(0)].drawn;
          if (drawnParam === void 0) continue;
          params = segments[i].substr(1).match(constants.paramRE);
          if (!params || params.length < drawnParam) continue;
          val = convertVal(params[drawnParam]);
          if (val < min) min = val;
          if (val > max) max = val;
        }
        if (max >= min) return [min, max];
      }
    }
  });

  // src/components/shapes/index.js
  var require_shapes = __commonJS({
    "src/components/shapes/index.js"(exports, module) {
      "use strict";
      var drawModule = require_draw2();
      module.exports = {
        moduleType: "component",
        name: "shapes",
        layoutAttributes: require_attributes16(),
        supplyLayoutDefaults: require_defaults11(),
        supplyDrawNewShapeDefaults: require_defaults12(),
        includeBasePlot: require_include_components()("shapes"),
        calcAutorange: require_calc_autorange2(),
        draw: drawModule.draw,
        drawOne: drawModule.drawOne
      };
    }
  });

  // src/components/images/attributes.js
  var require_attributes17 = __commonJS({
    "src/components/images/attributes.js"(exports, module) {
      "use strict";
      var cartesianConstants = require_constants2();
      var templatedArray = require_plot_template().templatedArray;
      var axisPlaceableObjs = require_axis_placeable_objects();
      module.exports = templatedArray("image", {
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "arraydraw"
        },
        source: {
          valType: "string",
          editType: "arraydraw"
        },
        layer: {
          valType: "enumerated",
          values: ["below", "above"],
          dflt: "above",
          editType: "arraydraw"
        },
        sizex: {
          valType: "number",
          dflt: 0,
          editType: "arraydraw"
        },
        sizey: {
          valType: "number",
          dflt: 0,
          editType: "arraydraw"
        },
        sizing: {
          valType: "enumerated",
          values: ["fill", "contain", "stretch"],
          dflt: "contain",
          editType: "arraydraw"
        },
        opacity: {
          valType: "number",
          min: 0,
          max: 1,
          dflt: 1,
          editType: "arraydraw"
        },
        x: {
          valType: "any",
          dflt: 0,
          editType: "arraydraw"
        },
        y: {
          valType: "any",
          dflt: 0,
          editType: "arraydraw"
        },
        xanchor: {
          valType: "enumerated",
          values: ["left", "center", "right"],
          dflt: "left",
          editType: "arraydraw"
        },
        yanchor: {
          valType: "enumerated",
          values: ["top", "middle", "bottom"],
          dflt: "top",
          editType: "arraydraw"
        },
        xref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.x.toString()
          ],
          dflt: "paper",
          editType: "arraydraw"
        },
        yref: {
          valType: "enumerated",
          values: [
            "paper",
            cartesianConstants.idRegex.y.toString()
          ],
          dflt: "paper",
          editType: "arraydraw"
        },
        editType: "arraydraw"
      });
    }
  });

  // src/components/images/defaults.js
  var require_defaults13 = __commonJS({
    "src/components/images/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Axes = require_axes();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes17();
      var name = "images";
      module.exports = function supplyLayoutDefaults(layoutIn, layoutOut) {
        var opts = {
          name,
          handleItemDefaults: imageDefaults
        };
        handleArrayContainerDefaults(layoutIn, layoutOut, opts);
      };
      function imageDefaults(imageIn, imageOut, fullLayout) {
        function coerce(attr, dflt) {
          return Lib.coerce(imageIn, imageOut, attributes, attr, dflt);
        }
        var source = coerce("source");
        var visible = coerce("visible", !!source);
        if (!visible) return imageOut;
        coerce("layer");
        coerce("xanchor");
        coerce("yanchor");
        coerce("sizex");
        coerce("sizey");
        coerce("sizing");
        coerce("opacity");
        var gdMock = { _fullLayout: fullLayout };
        var axLetters = ["x", "y"];
        for (var i = 0; i < 2; i++) {
          var axLetter = axLetters[i];
          var axRef = Axes.coerceRef(imageIn, imageOut, gdMock, axLetter, "paper", void 0);
          if (axRef !== "paper") {
            var ax = Axes.getFromId(gdMock, axRef);
            ax._imgIndices.push(imageOut._index);
          }
          Axes.coercePosition(imageOut, gdMock, coerce, axRef, axLetter, 0);
        }
        return imageOut;
      }
    }
  });

  // src/components/images/draw.js
  var require_draw6 = __commonJS({
    "src/components/images/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Drawing = require_drawing();
      var Axes = require_axes();
      var axisIds = require_axis_ids();
      var xmlnsNamespaces = require_xmlns_namespaces();
      module.exports = function draw(gd) {
        var fullLayout = gd._fullLayout;
        var imageDataAbove = [];
        var imageDataSubplot = {};
        var imageDataBelow = [];
        var subplot;
        var i;
        for (i = 0; i < fullLayout.images.length; i++) {
          var img = fullLayout.images[i];
          if (img.visible) {
            if (img.layer === "below" && img.xref !== "paper" && img.yref !== "paper") {
              subplot = axisIds.ref2id(img.xref) + axisIds.ref2id(img.yref);
              var plotinfo = fullLayout._plots[subplot];
              if (!plotinfo) {
                imageDataBelow.push(img);
                continue;
              }
              if (plotinfo.mainplot) {
                subplot = plotinfo.mainplot.id;
              }
              if (!imageDataSubplot[subplot]) {
                imageDataSubplot[subplot] = [];
              }
              imageDataSubplot[subplot].push(img);
            } else if (img.layer === "above") {
              imageDataAbove.push(img);
            } else {
              imageDataBelow.push(img);
            }
          }
        }
        var anchors = {
          x: {
            left: { sizing: "xMin", offset: 0 },
            center: { sizing: "xMid", offset: -1 / 2 },
            right: { sizing: "xMax", offset: -1 }
          },
          y: {
            top: { sizing: "YMin", offset: 0 },
            middle: { sizing: "YMid", offset: -1 / 2 },
            bottom: { sizing: "YMax", offset: -1 }
          }
        };
        function setImage(d) {
          var thisImage = d3.select(this);
          if (this._imgSrc === d.source) {
            return;
          }
          thisImage.attr("xmlns", xmlnsNamespaces.svg);
          if (!gd._context.staticPlot || d.source && d.source.slice(0, 5) === "data:") {
            thisImage.attr("xlink:href", d.source);
            this._imgSrc = d.source;
          } else {
            var imagePromise = new Promise(function(resolve) {
              var img2 = new Image();
              this.img = img2;
              img2.setAttribute("crossOrigin", "anonymous");
              img2.onerror = errorHandler;
              img2.onload = function() {
                var canvas = document.createElement("canvas");
                canvas.width = this.width;
                canvas.height = this.height;
                var ctx = canvas.getContext("2d", { willReadFrequently: true });
                ctx.drawImage(this, 0, 0);
                var dataURL = canvas.toDataURL("image/png");
                thisImage.attr("xlink:href", dataURL);
                resolve();
              };
              thisImage.on("error", errorHandler);
              img2.src = d.source;
              this._imgSrc = d.source;
              function errorHandler() {
                thisImage.remove();
                resolve();
              }
            }.bind(this));
            gd._promises.push(imagePromise);
          }
        }
        function applyAttributes(d) {
          var thisImage = d3.select(this);
          var xa = Axes.getFromId(gd, d.xref);
          var ya = Axes.getFromId(gd, d.yref);
          var xIsDomain = Axes.getRefType(d.xref) === "domain";
          var yIsDomain = Axes.getRefType(d.yref) === "domain";
          var size = fullLayout._size;
          var width, height;
          if (xa !== void 0) {
            width = typeof d.xref === "string" && xIsDomain ? xa._length * d.sizex : Math.abs(xa.l2p(d.sizex) - xa.l2p(0));
          } else {
            width = d.sizex * size.w;
          }
          if (ya !== void 0) {
            height = typeof d.yref === "string" && yIsDomain ? ya._length * d.sizey : Math.abs(ya.l2p(d.sizey) - ya.l2p(0));
          } else {
            height = d.sizey * size.h;
          }
          var xOffset = width * anchors.x[d.xanchor].offset;
          var yOffset = height * anchors.y[d.yanchor].offset;
          var sizing = anchors.x[d.xanchor].sizing + anchors.y[d.yanchor].sizing;
          var xPos, yPos;
          if (xa !== void 0) {
            xPos = typeof d.xref === "string" && xIsDomain ? xa._length * d.x + xa._offset : xa.r2p(d.x) + xa._offset;
          } else {
            xPos = d.x * size.w + size.l;
          }
          xPos += xOffset;
          if (ya !== void 0) {
            yPos = typeof d.yref === "string" && yIsDomain ? (
              // consistent with "paper" yref value, where positive values
              // move up the page
              ya._length * (1 - d.y) + ya._offset
            ) : ya.r2p(d.y) + ya._offset;
          } else {
            yPos = size.h - d.y * size.h + size.t;
          }
          yPos += yOffset;
          switch (d.sizing) {
            case "fill":
              sizing += " slice";
              break;
            case "stretch":
              sizing = "none";
              break;
          }
          thisImage.attr({
            x: xPos,
            y: yPos,
            width,
            height,
            preserveAspectRatio: sizing,
            opacity: d.opacity
          });
          var xId = xa && Axes.getRefType(d.xref) !== "domain" ? xa._id : "";
          var yId = ya && Axes.getRefType(d.yref) !== "domain" ? ya._id : "";
          var clipAxes = xId + yId;
          Drawing.setClipUrl(
            thisImage,
            clipAxes ? "clip" + fullLayout._uid + clipAxes : null,
            gd
          );
        }
        function imgDataFunc(d) {
          return [d.xref, d.x, d.sizex, d.yref, d.y, d.sizey].join("_");
        }
        function imgSort(a, b) {
          return a._index - b._index;
        }
        var imagesBelow = fullLayout._imageLowerLayer.selectAll("image").data(imageDataBelow, imgDataFunc);
        var imagesAbove = fullLayout._imageUpperLayer.selectAll("image").data(imageDataAbove, imgDataFunc);
        imagesBelow.enter().append("image");
        imagesAbove.enter().append("image");
        imagesBelow.exit().remove();
        imagesAbove.exit().remove();
        imagesBelow.each(function(d) {
          setImage.bind(this)(d);
          applyAttributes.bind(this)(d);
        });
        imagesAbove.each(function(d) {
          setImage.bind(this)(d);
          applyAttributes.bind(this)(d);
        });
        imagesBelow.sort(imgSort);
        imagesAbove.sort(imgSort);
        var allSubplots = Object.keys(fullLayout._plots);
        for (i = 0; i < allSubplots.length; i++) {
          subplot = allSubplots[i];
          var subplotObj = fullLayout._plots[subplot];
          if (!subplotObj.imagelayer) continue;
          var imagesOnSubplot = subplotObj.imagelayer.selectAll("image").data(imageDataSubplot[subplot] || [], imgDataFunc);
          imagesOnSubplot.enter().append("image");
          imagesOnSubplot.exit().remove();
          imagesOnSubplot.each(function(d) {
            setImage.bind(this)(d);
            applyAttributes.bind(this)(d);
          });
          imagesOnSubplot.sort(imgSort);
        }
      };
    }
  });

  // src/components/images/convert_coords.js
  var require_convert_coords2 = __commonJS({
    "src/components/images/convert_coords.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var toLogRange = require_to_log_range();
      module.exports = function convertCoords(gd, ax, newType, doExtra) {
        ax = ax || {};
        var toLog = newType === "log" && ax.type === "linear";
        var fromLog = newType === "linear" && ax.type === "log";
        if (!(toLog || fromLog)) return;
        var images = gd._fullLayout.images;
        var axLetter = ax._id.charAt(0);
        var image;
        var attrPrefix;
        for (var i = 0; i < images.length; i++) {
          image = images[i];
          attrPrefix = "images[" + i + "].";
          if (image[axLetter + "ref"] === ax._id) {
            var currentPos = image[axLetter];
            var currentSize = image["size" + axLetter];
            var newPos = null;
            var newSize = null;
            if (toLog) {
              newPos = toLogRange(currentPos, ax.range);
              var dx = currentSize / Math.pow(10, newPos) / 2;
              newSize = 2 * Math.log(dx + Math.sqrt(1 + dx * dx)) / Math.LN10;
            } else {
              newPos = Math.pow(10, currentPos);
              newSize = newPos * (Math.pow(10, currentSize / 2) - Math.pow(10, -currentSize / 2));
            }
            if (!isNumeric(newPos)) {
              newPos = null;
              newSize = null;
            } else if (!isNumeric(newSize)) newSize = null;
            doExtra(attrPrefix + axLetter, newPos);
            doExtra(attrPrefix + "size" + axLetter, newSize);
          }
        }
      };
    }
  });

  // src/components/images/index.js
  var require_images = __commonJS({
    "src/components/images/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "images",
        layoutAttributes: require_attributes17(),
        supplyLayoutDefaults: require_defaults13(),
        includeBasePlot: require_include_components()("images"),
        draw: require_draw6(),
        convertCoords: require_convert_coords2()
      };
    }
  });

  // src/components/updatemenus/constants.js
  var require_constants9 = __commonJS({
    "src/components/updatemenus/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // layout attribute name
        name: "updatemenus",
        // class names
        containerClassName: "updatemenu-container",
        headerGroupClassName: "updatemenu-header-group",
        headerClassName: "updatemenu-header",
        headerArrowClassName: "updatemenu-header-arrow",
        dropdownButtonGroupClassName: "updatemenu-dropdown-button-group",
        dropdownButtonClassName: "updatemenu-dropdown-button",
        buttonClassName: "updatemenu-button",
        itemRectClassName: "updatemenu-item-rect",
        itemTextClassName: "updatemenu-item-text",
        // DOM attribute name in button group keeping track
        // of active update menu
        menuIndexAttrName: "updatemenu-active-index",
        // id root pass to Plots.autoMargin
        autoMarginIdRoot: "updatemenu-",
        // options when 'active: -1'
        blankHeaderOpts: { label: "  " },
        // min item width / height
        minWidth: 30,
        minHeight: 30,
        // padding around item text
        textPadX: 24,
        arrowPadX: 16,
        // item rect radii
        rx: 2,
        ry: 2,
        // item  text x offset off left edge
        textOffsetX: 12,
        // item  text y offset (w.r.t. middle)
        textOffsetY: 3,
        // arrow offset off right edge
        arrowOffsetX: 4,
        // gap between header and buttons
        gapButtonHeader: 5,
        // gap between between buttons
        gapButton: 2,
        // color given to active buttons
        activeColor: "#F4FAFF",
        // color given to hovered buttons
        hoverColor: "#F4FAFF",
        // symbol for menu open arrow
        arrowSymbol: {
          left: "\u25C4",
          right: "\u25BA",
          up: "\u25B2",
          down: "\u25BC"
        }
      };
    }
  });

  // src/components/updatemenus/attributes.js
  var require_attributes18 = __commonJS({
    "src/components/updatemenus/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      var padAttrs = require_pad_attributes();
      var templatedArray = require_plot_template().templatedArray;
      var buttonsAttrs = templatedArray("button", {
        visible: {
          valType: "boolean"
        },
        method: {
          valType: "enumerated",
          values: ["restyle", "relayout", "animate", "update", "skip"],
          dflt: "restyle"
        },
        args: {
          valType: "info_array",
          freeLength: true,
          items: [
            { valType: "any" },
            { valType: "any" },
            { valType: "any" }
          ]
        },
        args2: {
          valType: "info_array",
          freeLength: true,
          items: [
            { valType: "any" },
            { valType: "any" },
            { valType: "any" }
          ]
        },
        label: {
          valType: "string",
          dflt: ""
        },
        execute: {
          valType: "boolean",
          dflt: true
        }
      });
      module.exports = overrideAll(templatedArray("updatemenu", {
        _arrayAttrRegexps: [/^updatemenus\[(0|[1-9][0-9]+)\]\.buttons/],
        visible: {
          valType: "boolean"
        },
        type: {
          valType: "enumerated",
          values: ["dropdown", "buttons"],
          dflt: "dropdown"
        },
        direction: {
          valType: "enumerated",
          values: ["left", "right", "up", "down"],
          dflt: "down"
        },
        active: {
          valType: "integer",
          min: -1,
          dflt: 0
        },
        showactive: {
          valType: "boolean",
          dflt: true
        },
        buttons: buttonsAttrs,
        x: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: -0.05
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "right"
        },
        y: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: 1
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "top"
        },
        pad: extendFlat(padAttrs({ editType: "arraydraw" }), {}),
        font: fontAttrs({}),
        bgcolor: {
          valType: "color"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttrs.borderLine
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "arraydraw"
        }
      }), "arraydraw", "from-root");
    }
  });

  // src/components/updatemenus/defaults.js
  var require_defaults14 = __commonJS({
    "src/components/updatemenus/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes18();
      var constants = require_constants9();
      var name = constants.name;
      var buttonAttrs = attributes.buttons;
      module.exports = function updateMenusDefaults(layoutIn, layoutOut) {
        var opts = {
          name,
          handleItemDefaults: menuDefaults
        };
        handleArrayContainerDefaults(layoutIn, layoutOut, opts);
      };
      function menuDefaults(menuIn, menuOut, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(menuIn, menuOut, attributes, attr, dflt);
        }
        var buttons = handleArrayContainerDefaults(menuIn, menuOut, {
          name: "buttons",
          handleItemDefaults: buttonDefaults
        });
        var visible = coerce("visible", buttons.length > 0);
        if (!visible) return;
        coerce("active");
        coerce("direction");
        coerce("type");
        coerce("showactive");
        coerce("x");
        coerce("y");
        Lib.noneOrAll(menuIn, menuOut, ["x", "y"]);
        coerce("xanchor");
        coerce("yanchor");
        coerce("pad.t");
        coerce("pad.r");
        coerce("pad.b");
        coerce("pad.l");
        Lib.coerceFont(coerce, "font", layoutOut.font);
        coerce("bgcolor", layoutOut.paper_bgcolor);
        coerce("bordercolor");
        coerce("borderwidth");
      }
      function buttonDefaults(buttonIn, buttonOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(buttonIn, buttonOut, buttonAttrs, attr, dflt);
        }
        var visible = coerce(
          "visible",
          buttonIn.method === "skip" || Array.isArray(buttonIn.args)
        );
        if (visible) {
          coerce("method");
          coerce("args");
          coerce("args2");
          coerce("label");
          coerce("execute");
        }
      }
    }
  });

  // src/components/updatemenus/scrollbox.js
  var require_scrollbox = __commonJS({
    "src/components/updatemenus/scrollbox.js"(exports, module) {
      "use strict";
      module.exports = ScrollBox;
      var d3 = require_d3();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      function ScrollBox(gd, container, id) {
        this.gd = gd;
        this.container = container;
        this.id = id;
        this.position = null;
        this.translateX = null;
        this.translateY = null;
        this.hbar = null;
        this.vbar = null;
        this.bg = this.container.selectAll("rect.scrollbox-bg").data([0]);
        this.bg.exit().on(".drag", null).on("wheel", null).remove();
        this.bg.enter().append("rect").classed("scrollbox-bg", true).style("pointer-events", "all").attr({
          opacity: 0,
          x: 0,
          y: 0,
          width: 0,
          height: 0
        });
      }
      ScrollBox.barWidth = 2;
      ScrollBox.barLength = 20;
      ScrollBox.barRadius = 2;
      ScrollBox.barPad = 1;
      ScrollBox.barColor = "#808BA4";
      ScrollBox.prototype.enable = function enable(position, translateX, translateY) {
        var fullLayout = this.gd._fullLayout;
        var fullWidth = fullLayout.width;
        var fullHeight = fullLayout.height;
        this.position = position;
        var l = this.position.l;
        var w = this.position.w;
        var t = this.position.t;
        var h = this.position.h;
        var direction = this.position.direction;
        var isDown = direction === "down";
        var isLeft = direction === "left";
        var isRight = direction === "right";
        var isUp = direction === "up";
        var boxW = w;
        var boxH = h;
        var boxL, boxR;
        var boxT, boxB;
        if (!isDown && !isLeft && !isRight && !isUp) {
          this.position.direction = "down";
          isDown = true;
        }
        var isVertical = isDown || isUp;
        if (isVertical) {
          boxL = l;
          boxR = boxL + boxW;
          if (isDown) {
            boxT = t;
            boxB = Math.min(boxT + boxH, fullHeight);
            boxH = boxB - boxT;
          } else {
            boxB = t + boxH;
            boxT = Math.max(boxB - boxH, 0);
            boxH = boxB - boxT;
          }
        } else {
          boxT = t;
          boxB = boxT + boxH;
          if (isLeft) {
            boxR = l + boxW;
            boxL = Math.max(boxR - boxW, 0);
            boxW = boxR - boxL;
          } else {
            boxL = l;
            boxR = Math.min(boxL + boxW, fullWidth);
            boxW = boxR - boxL;
          }
        }
        this._box = {
          l: boxL,
          t: boxT,
          w: boxW,
          h: boxH
        };
        var needsHorizontalScrollBar = w > boxW;
        var hbarW = ScrollBox.barLength + 2 * ScrollBox.barPad;
        var hbarH = ScrollBox.barWidth + 2 * ScrollBox.barPad;
        var hbarL = l;
        var hbarT = t + h;
        if (hbarT + hbarH > fullHeight) hbarT = fullHeight - hbarH;
        var hbar = this.container.selectAll("rect.scrollbar-horizontal").data(
          needsHorizontalScrollBar ? [0] : []
        );
        hbar.exit().on(".drag", null).remove();
        hbar.enter().append("rect").classed("scrollbar-horizontal", true).call(Color.fill, ScrollBox.barColor);
        if (needsHorizontalScrollBar) {
          this.hbar = hbar.attr({
            rx: ScrollBox.barRadius,
            ry: ScrollBox.barRadius,
            x: hbarL,
            y: hbarT,
            width: hbarW,
            height: hbarH
          });
          this._hbarXMin = hbarL + hbarW / 2;
          this._hbarTranslateMax = boxW - hbarW;
        } else {
          delete this.hbar;
          delete this._hbarXMin;
          delete this._hbarTranslateMax;
        }
        var needsVerticalScrollBar = h > boxH;
        var vbarW = ScrollBox.barWidth + 2 * ScrollBox.barPad;
        var vbarH = ScrollBox.barLength + 2 * ScrollBox.barPad;
        var vbarL = l + w;
        var vbarT = t;
        if (vbarL + vbarW > fullWidth) vbarL = fullWidth - vbarW;
        var vbar = this.container.selectAll("rect.scrollbar-vertical").data(
          needsVerticalScrollBar ? [0] : []
        );
        vbar.exit().on(".drag", null).remove();
        vbar.enter().append("rect").classed("scrollbar-vertical", true).call(Color.fill, ScrollBox.barColor);
        if (needsVerticalScrollBar) {
          this.vbar = vbar.attr({
            rx: ScrollBox.barRadius,
            ry: ScrollBox.barRadius,
            x: vbarL,
            y: vbarT,
            width: vbarW,
            height: vbarH
          });
          this._vbarYMin = vbarT + vbarH / 2;
          this._vbarTranslateMax = boxH - vbarH;
        } else {
          delete this.vbar;
          delete this._vbarYMin;
          delete this._vbarTranslateMax;
        }
        var clipId = this.id;
        var clipL = boxL - 0.5;
        var clipR = needsVerticalScrollBar ? boxR + vbarW + 0.5 : boxR + 0.5;
        var clipT = boxT - 0.5;
        var clipB = needsHorizontalScrollBar ? boxB + hbarH + 0.5 : boxB + 0.5;
        var clipPath = fullLayout._topdefs.selectAll("#" + clipId).data(needsHorizontalScrollBar || needsVerticalScrollBar ? [0] : []);
        clipPath.exit().remove();
        clipPath.enter().append("clipPath").attr("id", clipId).append("rect");
        if (needsHorizontalScrollBar || needsVerticalScrollBar) {
          this._clipRect = clipPath.select("rect").attr({
            x: Math.floor(clipL),
            y: Math.floor(clipT),
            width: Math.ceil(clipR) - Math.floor(clipL),
            height: Math.ceil(clipB) - Math.floor(clipT)
          });
          this.container.call(Drawing.setClipUrl, clipId, this.gd);
          this.bg.attr({
            x: l,
            y: t,
            width: w,
            height: h
          });
        } else {
          this.bg.attr({
            width: 0,
            height: 0
          });
          this.container.on("wheel", null).on(".drag", null).call(Drawing.setClipUrl, null);
          delete this._clipRect;
        }
        if (needsHorizontalScrollBar || needsVerticalScrollBar) {
          var onBoxDrag = d3.behavior.drag().on("dragstart", function() {
            d3.event.sourceEvent.preventDefault();
          }).on("drag", this._onBoxDrag.bind(this));
          this.container.on("wheel", null).on("wheel", this._onBoxWheel.bind(this)).on(".drag", null).call(onBoxDrag);
          var onBarDrag = d3.behavior.drag().on("dragstart", function() {
            d3.event.sourceEvent.preventDefault();
            d3.event.sourceEvent.stopPropagation();
          }).on("drag", this._onBarDrag.bind(this));
          if (needsHorizontalScrollBar) {
            this.hbar.on(".drag", null).call(onBarDrag);
          }
          if (needsVerticalScrollBar) {
            this.vbar.on(".drag", null).call(onBarDrag);
          }
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype.disable = function disable() {
        if (this.hbar || this.vbar) {
          this.bg.attr({
            width: 0,
            height: 0
          });
          this.container.on("wheel", null).on(".drag", null).call(Drawing.setClipUrl, null);
          delete this._clipRect;
        }
        if (this.hbar) {
          this.hbar.on(".drag", null);
          this.hbar.remove();
          delete this.hbar;
          delete this._hbarXMin;
          delete this._hbarTranslateMax;
        }
        if (this.vbar) {
          this.vbar.on(".drag", null);
          this.vbar.remove();
          delete this.vbar;
          delete this._vbarYMin;
          delete this._vbarTranslateMax;
        }
      };
      ScrollBox.prototype._onBoxDrag = function _onBoxDrag() {
        var translateX = this.translateX;
        var translateY = this.translateY;
        if (this.hbar) {
          translateX -= d3.event.dx;
        }
        if (this.vbar) {
          translateY -= d3.event.dy;
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype._onBoxWheel = function _onBoxWheel() {
        var translateX = this.translateX;
        var translateY = this.translateY;
        if (this.hbar) {
          translateX += d3.event.deltaY;
        }
        if (this.vbar) {
          translateY += d3.event.deltaY;
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype._onBarDrag = function _onBarDrag() {
        var translateX = this.translateX;
        var translateY = this.translateY;
        if (this.hbar) {
          var xMin = translateX + this._hbarXMin;
          var xMax = xMin + this._hbarTranslateMax;
          var x = Lib.constrain(d3.event.x, xMin, xMax);
          var xf = (x - xMin) / (xMax - xMin);
          var translateXMax = this.position.w - this._box.w;
          translateX = xf * translateXMax;
        }
        if (this.vbar) {
          var yMin = translateY + this._vbarYMin;
          var yMax = yMin + this._vbarTranslateMax;
          var y = Lib.constrain(d3.event.y, yMin, yMax);
          var yf = (y - yMin) / (yMax - yMin);
          var translateYMax = this.position.h - this._box.h;
          translateY = yf * translateYMax;
        }
        this.setTranslate(translateX, translateY);
      };
      ScrollBox.prototype.setTranslate = function setTranslate(translateX, translateY) {
        var translateXMax = this.position.w - this._box.w;
        var translateYMax = this.position.h - this._box.h;
        translateX = Lib.constrain(translateX || 0, 0, translateXMax);
        translateY = Lib.constrain(translateY || 0, 0, translateYMax);
        this.translateX = translateX;
        this.translateY = translateY;
        this.container.call(
          Drawing.setTranslate,
          this._box.l - this.position.l - translateX,
          this._box.t - this.position.t - translateY
        );
        if (this._clipRect) {
          this._clipRect.attr({
            x: Math.floor(this.position.l + translateX - 0.5),
            y: Math.floor(this.position.t + translateY - 0.5)
          });
        }
        if (this.hbar) {
          var xf = translateX / translateXMax;
          this.hbar.call(
            Drawing.setTranslate,
            translateX + xf * this._hbarTranslateMax,
            translateY
          );
        }
        if (this.vbar) {
          var yf = translateY / translateYMax;
          this.vbar.call(
            Drawing.setTranslate,
            translateX,
            translateY + yf * this._vbarTranslateMax
          );
        }
      };
    }
  });

  // src/components/updatemenus/draw.js
  var require_draw7 = __commonJS({
    "src/components/updatemenus/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Plots = require_plots();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var svgTextUtils = require_svg_text_utils();
      var arrayEditor = require_plot_template().arrayEditor;
      var LINE_SPACING = require_alignment().LINE_SPACING;
      var constants = require_constants9();
      var ScrollBox = require_scrollbox();
      module.exports = function draw(gd) {
        var fullLayout = gd._fullLayout;
        var menuData = Lib.filterVisible(fullLayout[constants.name]);
        function clearAutoMargin(menuOpts2) {
          Plots.autoMargin(gd, autoMarginId(menuOpts2));
        }
        var menus = fullLayout._menulayer.selectAll("g." + constants.containerClassName).data(menuData.length > 0 ? [0] : []);
        menus.enter().append("g").classed(constants.containerClassName, true).style("cursor", "pointer");
        menus.exit().each(function() {
          d3.select(this).selectAll("g." + constants.headerGroupClassName).each(clearAutoMargin);
        }).remove();
        if (menuData.length === 0) return;
        var headerGroups = menus.selectAll("g." + constants.headerGroupClassName).data(menuData, keyFunction);
        headerGroups.enter().append("g").classed(constants.headerGroupClassName, true);
        var gButton = Lib.ensureSingle(menus, "g", constants.dropdownButtonGroupClassName, function(s) {
          s.style("pointer-events", "all");
        });
        for (var i = 0; i < menuData.length; i++) {
          var menuOpts = menuData[i];
          findDimensions(gd, menuOpts);
        }
        var scrollBoxId = "updatemenus" + fullLayout._uid;
        var scrollBox = new ScrollBox(gd, gButton, scrollBoxId);
        if (headerGroups.enter().size()) {
          gButton.node().parentNode.appendChild(gButton.node());
          gButton.call(removeAllButtons);
        }
        headerGroups.exit().each(function(menuOpts2) {
          gButton.call(removeAllButtons);
          clearAutoMargin(menuOpts2);
        }).remove();
        headerGroups.each(function(menuOpts2) {
          var gHeader = d3.select(this);
          var _gButton = menuOpts2.type === "dropdown" ? gButton : null;
          Plots.manageCommandObserver(gd, menuOpts2, menuOpts2.buttons, function(data) {
            setActive(gd, menuOpts2, menuOpts2.buttons[data.index], gHeader, _gButton, scrollBox, data.index, true);
          });
          if (menuOpts2.type === "dropdown") {
            drawHeader(gd, gHeader, gButton, scrollBox, menuOpts2);
            if (isActive(gButton, menuOpts2)) {
              drawButtons(gd, gHeader, gButton, scrollBox, menuOpts2);
            }
          } else {
            drawButtons(gd, gHeader, null, null, menuOpts2);
          }
        });
      };
      function keyFunction(menuOpts) {
        return menuOpts._index;
      }
      function isFolded(gButton) {
        return +gButton.attr(constants.menuIndexAttrName) === -1;
      }
      function isActive(gButton, menuOpts) {
        return +gButton.attr(constants.menuIndexAttrName) === menuOpts._index;
      }
      function setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex, isSilentUpdate) {
        menuOpts.active = buttonIndex;
        arrayEditor(gd.layout, constants.name, menuOpts).applyUpdate("active", buttonIndex);
        if (menuOpts.type === "buttons") {
          drawButtons(gd, gHeader, null, null, menuOpts);
        } else if (menuOpts.type === "dropdown") {
          gButton.attr(constants.menuIndexAttrName, "-1");
          drawHeader(gd, gHeader, gButton, scrollBox, menuOpts);
          if (!isSilentUpdate) {
            drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
          }
        }
      }
      function drawHeader(gd, gHeader, gButton, scrollBox, menuOpts) {
        var header = Lib.ensureSingle(gHeader, "g", constants.headerClassName, function(s) {
          s.style("pointer-events", "all");
        });
        var dims = menuOpts._dims;
        var active = menuOpts.active;
        var headerOpts = menuOpts.buttons[active] || constants.blankHeaderOpts;
        var posOpts = { y: menuOpts.pad.t, yPad: 0, x: menuOpts.pad.l, xPad: 0, index: 0 };
        var positionOverrides = {
          width: dims.headerWidth,
          height: dims.headerHeight
        };
        header.call(drawItem, menuOpts, headerOpts, gd).call(setItemPosition, menuOpts, posOpts, positionOverrides);
        var arrow = Lib.ensureSingle(gHeader, "text", constants.headerArrowClassName, function(s) {
          s.attr("text-anchor", "end").call(Drawing.font, menuOpts.font).text(constants.arrowSymbol[menuOpts.direction]);
        });
        arrow.attr({
          x: dims.headerWidth - constants.arrowOffsetX + menuOpts.pad.l,
          y: dims.headerHeight / 2 + constants.textOffsetY + menuOpts.pad.t
        });
        header.on("click", function() {
          gButton.call(
            removeAllButtons,
            String(isActive(gButton, menuOpts) ? -1 : menuOpts._index)
          );
          drawButtons(gd, gHeader, gButton, scrollBox, menuOpts);
        });
        header.on("mouseover", function() {
          header.call(styleOnMouseOver);
        });
        header.on("mouseout", function() {
          header.call(styleOnMouseOut, menuOpts);
        });
        Drawing.setTranslate(gHeader, dims.lx, dims.ly);
      }
      function drawButtons(gd, gHeader, gButton, scrollBox, menuOpts) {
        if (!gButton) {
          gButton = gHeader;
          gButton.attr("pointer-events", "all");
        }
        var buttonData = !isFolded(gButton) || menuOpts.type === "buttons" ? menuOpts.buttons : [];
        var klass = menuOpts.type === "dropdown" ? constants.dropdownButtonClassName : constants.buttonClassName;
        var buttons = gButton.selectAll("g." + klass).data(Lib.filterVisible(buttonData));
        var enter = buttons.enter().append("g").classed(klass, true);
        var exit = buttons.exit();
        if (menuOpts.type === "dropdown") {
          enter.attr("opacity", "0").transition().attr("opacity", "1");
          exit.transition().attr("opacity", "0").remove();
        } else {
          exit.remove();
        }
        var x0 = 0;
        var y0 = 0;
        var dims = menuOpts._dims;
        var isVertical = ["up", "down"].indexOf(menuOpts.direction) !== -1;
        if (menuOpts.type === "dropdown") {
          if (isVertical) {
            y0 = dims.headerHeight + constants.gapButtonHeader;
          } else {
            x0 = dims.headerWidth + constants.gapButtonHeader;
          }
        }
        if (menuOpts.type === "dropdown" && menuOpts.direction === "up") {
          y0 = -constants.gapButtonHeader + constants.gapButton - dims.openHeight;
        }
        if (menuOpts.type === "dropdown" && menuOpts.direction === "left") {
          x0 = -constants.gapButtonHeader + constants.gapButton - dims.openWidth;
        }
        var posOpts = {
          x: dims.lx + x0 + menuOpts.pad.l,
          y: dims.ly + y0 + menuOpts.pad.t,
          yPad: constants.gapButton,
          xPad: constants.gapButton,
          index: 0
        };
        var scrollBoxPosition = {
          l: posOpts.x + menuOpts.borderwidth,
          t: posOpts.y + menuOpts.borderwidth
        };
        buttons.each(function(buttonOpts, buttonIndex) {
          var button = d3.select(this);
          button.call(drawItem, menuOpts, buttonOpts, gd).call(setItemPosition, menuOpts, posOpts);
          button.on("click", function() {
            if (d3.event.defaultPrevented) return;
            if (buttonOpts.execute) {
              if (buttonOpts.args2 && menuOpts.active === buttonIndex) {
                setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, -1);
                Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args2);
              } else {
                setActive(gd, menuOpts, buttonOpts, gHeader, gButton, scrollBox, buttonIndex);
                Plots.executeAPICommand(gd, buttonOpts.method, buttonOpts.args);
              }
            }
            gd.emit("plotly_buttonclicked", { menu: menuOpts, button: buttonOpts, active: menuOpts.active });
          });
          button.on("mouseover", function() {
            button.call(styleOnMouseOver);
          });
          button.on("mouseout", function() {
            button.call(styleOnMouseOut, menuOpts);
            buttons.call(styleButtons, menuOpts);
          });
        });
        buttons.call(styleButtons, menuOpts);
        if (isVertical) {
          scrollBoxPosition.w = Math.max(dims.openWidth, dims.headerWidth);
          scrollBoxPosition.h = posOpts.y - scrollBoxPosition.t;
        } else {
          scrollBoxPosition.w = posOpts.x - scrollBoxPosition.l;
          scrollBoxPosition.h = Math.max(dims.openHeight, dims.headerHeight);
        }
        scrollBoxPosition.direction = menuOpts.direction;
        if (scrollBox) {
          if (buttons.size()) {
            drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, scrollBoxPosition);
          } else {
            hideScrollBox(scrollBox);
          }
        }
      }
      function drawScrollBox(gd, gHeader, gButton, scrollBox, menuOpts, position) {
        var direction = menuOpts.direction;
        var isVertical = direction === "up" || direction === "down";
        var dims = menuOpts._dims;
        var active = menuOpts.active;
        var translateX, translateY;
        var i;
        if (isVertical) {
          translateY = 0;
          for (i = 0; i < active; i++) {
            translateY += dims.heights[i] + constants.gapButton;
          }
        } else {
          translateX = 0;
          for (i = 0; i < active; i++) {
            translateX += dims.widths[i] + constants.gapButton;
          }
        }
        scrollBox.enable(position, translateX, translateY);
        if (scrollBox.hbar) {
          scrollBox.hbar.attr("opacity", "0").transition().attr("opacity", "1");
        }
        if (scrollBox.vbar) {
          scrollBox.vbar.attr("opacity", "0").transition().attr("opacity", "1");
        }
      }
      function hideScrollBox(scrollBox) {
        var hasHBar = !!scrollBox.hbar;
        var hasVBar = !!scrollBox.vbar;
        if (hasHBar) {
          scrollBox.hbar.transition().attr("opacity", "0").each("end", function() {
            hasHBar = false;
            if (!hasVBar) scrollBox.disable();
          });
        }
        if (hasVBar) {
          scrollBox.vbar.transition().attr("opacity", "0").each("end", function() {
            hasVBar = false;
            if (!hasHBar) scrollBox.disable();
          });
        }
      }
      function drawItem(item, menuOpts, itemOpts, gd) {
        item.call(drawItemRect, menuOpts).call(drawItemText, menuOpts, itemOpts, gd);
      }
      function drawItemRect(item, menuOpts) {
        var rect = Lib.ensureSingle(item, "rect", constants.itemRectClassName, function(s) {
          s.attr({
            rx: constants.rx,
            ry: constants.ry,
            "shape-rendering": "crispEdges"
          });
        });
        rect.call(Color.stroke, menuOpts.bordercolor).call(Color.fill, menuOpts.bgcolor).style("stroke-width", menuOpts.borderwidth + "px");
      }
      function drawItemText(item, menuOpts, itemOpts, gd) {
        var text = Lib.ensureSingle(item, "text", constants.itemTextClassName, function(s) {
          s.attr({
            "text-anchor": "start",
            "data-notex": 1
          });
        });
        var tx = itemOpts.label;
        var _meta = gd._fullLayout._meta;
        if (_meta) tx = Lib.templateString(tx, _meta);
        text.call(Drawing.font, menuOpts.font).text(tx).call(svgTextUtils.convertToTspans, gd);
      }
      function styleButtons(buttons, menuOpts) {
        var active = menuOpts.active;
        buttons.each(function(buttonOpts, i) {
          var button = d3.select(this);
          if (i === active && menuOpts.showactive) {
            button.select("rect." + constants.itemRectClassName).call(Color.fill, constants.activeColor);
          }
        });
      }
      function styleOnMouseOver(item) {
        item.select("rect." + constants.itemRectClassName).call(Color.fill, constants.hoverColor);
      }
      function styleOnMouseOut(item, menuOpts) {
        item.select("rect." + constants.itemRectClassName).call(Color.fill, menuOpts.bgcolor);
      }
      function findDimensions(gd, menuOpts) {
        var dims = menuOpts._dims = {
          width1: 0,
          height1: 0,
          heights: [],
          widths: [],
          totalWidth: 0,
          totalHeight: 0,
          openWidth: 0,
          openHeight: 0,
          lx: 0,
          ly: 0
        };
        var fakeButtons = Drawing.tester.selectAll("g." + constants.dropdownButtonClassName).data(Lib.filterVisible(menuOpts.buttons));
        fakeButtons.enter().append("g").classed(constants.dropdownButtonClassName, true);
        var isVertical = ["up", "down"].indexOf(menuOpts.direction) !== -1;
        fakeButtons.each(function(buttonOpts, i) {
          var button = d3.select(this);
          button.call(drawItem, menuOpts, buttonOpts, gd);
          var text = button.select("." + constants.itemTextClassName);
          var tWidth = text.node() && Drawing.bBox(text.node()).width;
          var wEff = Math.max(tWidth + constants.textPadX, constants.minWidth);
          var tHeight = menuOpts.font.size * LINE_SPACING;
          var tLines = svgTextUtils.lineCount(text);
          var hEff = Math.max(tHeight * tLines, constants.minHeight) + constants.textOffsetY;
          hEff = Math.ceil(hEff);
          wEff = Math.ceil(wEff);
          dims.widths[i] = wEff;
          dims.heights[i] = hEff;
          dims.height1 = Math.max(dims.height1, hEff);
          dims.width1 = Math.max(dims.width1, wEff);
          if (isVertical) {
            dims.totalWidth = Math.max(dims.totalWidth, wEff);
            dims.openWidth = dims.totalWidth;
            dims.totalHeight += hEff + constants.gapButton;
            dims.openHeight += hEff + constants.gapButton;
          } else {
            dims.totalWidth += wEff + constants.gapButton;
            dims.openWidth += wEff + constants.gapButton;
            dims.totalHeight = Math.max(dims.totalHeight, hEff);
            dims.openHeight = dims.totalHeight;
          }
        });
        if (isVertical) {
          dims.totalHeight -= constants.gapButton;
        } else {
          dims.totalWidth -= constants.gapButton;
        }
        dims.headerWidth = dims.width1 + constants.arrowPadX;
        dims.headerHeight = dims.height1;
        if (menuOpts.type === "dropdown") {
          if (isVertical) {
            dims.width1 += constants.arrowPadX;
            dims.totalHeight = dims.height1;
          } else {
            dims.totalWidth = dims.width1;
          }
          dims.totalWidth += constants.arrowPadX;
        }
        fakeButtons.remove();
        var paddedWidth = dims.totalWidth + menuOpts.pad.l + menuOpts.pad.r;
        var paddedHeight = dims.totalHeight + menuOpts.pad.t + menuOpts.pad.b;
        var graphSize = gd._fullLayout._size;
        dims.lx = graphSize.l + graphSize.w * menuOpts.x;
        dims.ly = graphSize.t + graphSize.h * (1 - menuOpts.y);
        var xanchor = "left";
        if (Lib.isRightAnchor(menuOpts)) {
          dims.lx -= paddedWidth;
          xanchor = "right";
        }
        if (Lib.isCenterAnchor(menuOpts)) {
          dims.lx -= paddedWidth / 2;
          xanchor = "center";
        }
        var yanchor = "top";
        if (Lib.isBottomAnchor(menuOpts)) {
          dims.ly -= paddedHeight;
          yanchor = "bottom";
        }
        if (Lib.isMiddleAnchor(menuOpts)) {
          dims.ly -= paddedHeight / 2;
          yanchor = "middle";
        }
        dims.totalWidth = Math.ceil(dims.totalWidth);
        dims.totalHeight = Math.ceil(dims.totalHeight);
        dims.lx = Math.round(dims.lx);
        dims.ly = Math.round(dims.ly);
        Plots.autoMargin(gd, autoMarginId(menuOpts), {
          x: menuOpts.x,
          y: menuOpts.y,
          l: paddedWidth * ({ right: 1, center: 0.5 }[xanchor] || 0),
          r: paddedWidth * ({ left: 1, center: 0.5 }[xanchor] || 0),
          b: paddedHeight * ({ top: 1, middle: 0.5 }[yanchor] || 0),
          t: paddedHeight * ({ bottom: 1, middle: 0.5 }[yanchor] || 0)
        });
      }
      function autoMarginId(menuOpts) {
        return constants.autoMarginIdRoot + menuOpts._index;
      }
      function setItemPosition(item, menuOpts, posOpts, overrideOpts) {
        overrideOpts = overrideOpts || {};
        var rect = item.select("." + constants.itemRectClassName);
        var text = item.select("." + constants.itemTextClassName);
        var borderWidth = menuOpts.borderwidth;
        var index = posOpts.index;
        var dims = menuOpts._dims;
        Drawing.setTranslate(item, borderWidth + posOpts.x, borderWidth + posOpts.y);
        var isVertical = ["up", "down"].indexOf(menuOpts.direction) !== -1;
        var finalHeight = overrideOpts.height || (isVertical ? dims.heights[index] : dims.height1);
        rect.attr({
          x: 0,
          y: 0,
          width: overrideOpts.width || (isVertical ? dims.width1 : dims.widths[index]),
          height: finalHeight
        });
        var tHeight = menuOpts.font.size * LINE_SPACING;
        var tLines = svgTextUtils.lineCount(text);
        var spanOffset = (tLines - 1) * tHeight / 2;
        svgTextUtils.positionText(
          text,
          constants.textOffsetX,
          finalHeight / 2 - spanOffset + constants.textOffsetY
        );
        if (isVertical) {
          posOpts.y += dims.heights[index] + posOpts.yPad;
        } else {
          posOpts.x += dims.widths[index] + posOpts.xPad;
        }
        posOpts.index++;
      }
      function removeAllButtons(gButton, newMenuIndexAttr) {
        gButton.attr(constants.menuIndexAttrName, newMenuIndexAttr || "-1").selectAll("g." + constants.dropdownButtonClassName).remove();
      }
    }
  });

  // src/components/updatemenus/index.js
  var require_updatemenus = __commonJS({
    "src/components/updatemenus/index.js"(exports, module) {
      "use strict";
      var constants = require_constants9();
      module.exports = {
        moduleType: "component",
        name: constants.name,
        layoutAttributes: require_attributes18(),
        supplyLayoutDefaults: require_defaults14(),
        draw: require_draw7()
      };
    }
  });

  // src/components/sliders/constants.js
  var require_constants10 = __commonJS({
    "src/components/sliders/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // layout attribute name
        name: "sliders",
        // class names
        containerClassName: "slider-container",
        groupClassName: "slider-group",
        inputAreaClass: "slider-input-area",
        railRectClass: "slider-rail-rect",
        railTouchRectClass: "slider-rail-touch-rect",
        gripRectClass: "slider-grip-rect",
        tickRectClass: "slider-tick-rect",
        inputProxyClass: "slider-input-proxy",
        labelsClass: "slider-labels",
        labelGroupClass: "slider-label-group",
        labelClass: "slider-label",
        currentValueClass: "slider-current-value",
        railHeight: 5,
        // DOM attribute name in button group keeping track
        // of active update menu
        menuIndexAttrName: "slider-active-index",
        // id root pass to Plots.autoMargin
        autoMarginIdRoot: "slider-",
        // min item width / height
        minWidth: 30,
        minHeight: 30,
        // padding around item text
        textPadX: 40,
        // arrow offset off right edge
        arrowOffsetX: 4,
        railRadius: 2,
        railWidth: 5,
        railBorder: 4,
        railBorderWidth: 1,
        railBorderColor: "#bec8d9",
        railBgColor: "#f8fafc",
        // The distance of the rail from the edge of the touchable area
        // Slightly less than the step inset because of the curved edges
        // of the rail
        railInset: 8,
        // The distance from the extremal tick marks to the edge of the
        // touchable area. This is basically the same as the grip radius,
        // but for other styles it wouldn't really need to be.
        stepInset: 10,
        gripRadius: 10,
        gripWidth: 20,
        gripHeight: 20,
        gripBorder: 20,
        gripBorderWidth: 1,
        gripBorderColor: "#bec8d9",
        gripBgColor: "#f6f8fa",
        gripBgActiveColor: "#dbdde0",
        labelPadding: 8,
        labelOffset: 0,
        tickWidth: 1,
        tickColor: "#333",
        tickOffset: 25,
        tickLength: 7,
        minorTickOffset: 25,
        minorTickColor: "#333",
        minorTickLength: 4,
        // Extra space below the current value label:
        currentValuePadding: 8,
        currentValueInset: 0
      };
    }
  });

  // src/components/sliders/attributes.js
  var require_attributes19 = __commonJS({
    "src/components/sliders/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var padAttrs = require_pad_attributes();
      var extendDeepAll = require_extend().extendDeepAll;
      var overrideAll = require_edit_types().overrideAll;
      var animationAttrs = require_animation_attributes();
      var templatedArray = require_plot_template().templatedArray;
      var constants = require_constants10();
      var stepsAttrs = templatedArray("step", {
        visible: {
          valType: "boolean",
          dflt: true
        },
        method: {
          valType: "enumerated",
          values: ["restyle", "relayout", "animate", "update", "skip"],
          dflt: "restyle"
        },
        args: {
          valType: "info_array",
          freeLength: true,
          items: [
            { valType: "any" },
            { valType: "any" },
            { valType: "any" }
          ]
        },
        label: {
          valType: "string"
        },
        value: {
          valType: "string"
        },
        execute: {
          valType: "boolean",
          dflt: true
        }
      });
      module.exports = overrideAll(templatedArray("slider", {
        visible: {
          valType: "boolean",
          dflt: true
        },
        active: {
          valType: "number",
          min: 0,
          dflt: 0
        },
        steps: stepsAttrs,
        lenmode: {
          valType: "enumerated",
          values: ["fraction", "pixels"],
          dflt: "fraction"
        },
        len: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        x: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: 0
        },
        pad: extendDeepAll(padAttrs({ editType: "arraydraw" }), {}, { t: { dflt: 20 } }),
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "left"
        },
        y: {
          valType: "number",
          min: -2,
          max: 3,
          dflt: 0
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "top"
        },
        transition: {
          duration: {
            valType: "number",
            min: 0,
            dflt: 150
          },
          easing: {
            valType: "enumerated",
            values: animationAttrs.transition.easing.values,
            dflt: "cubic-in-out"
          }
        },
        currentvalue: {
          visible: {
            valType: "boolean",
            dflt: true
          },
          xanchor: {
            valType: "enumerated",
            values: ["left", "center", "right"],
            dflt: "left"
          },
          offset: {
            valType: "number",
            dflt: 10
          },
          prefix: {
            valType: "string"
          },
          suffix: {
            valType: "string"
          },
          font: fontAttrs({})
        },
        font: fontAttrs({}),
        activebgcolor: {
          valType: "color",
          dflt: constants.gripBgActiveColor
        },
        bgcolor: {
          valType: "color",
          dflt: constants.railBgColor
        },
        bordercolor: {
          valType: "color",
          dflt: constants.railBorderColor
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: constants.railBorderWidth
        },
        ticklen: {
          valType: "number",
          min: 0,
          dflt: constants.tickLength
        },
        tickcolor: {
          valType: "color",
          dflt: constants.tickColor
        },
        tickwidth: {
          valType: "number",
          min: 0,
          dflt: 1
        },
        minorticklen: {
          valType: "number",
          min: 0,
          dflt: constants.minorTickLength
        }
      }), "arraydraw", "from-root");
    }
  });

  // src/components/sliders/defaults.js
  var require_defaults15 = __commonJS({
    "src/components/sliders/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes19();
      var constants = require_constants10();
      var name = constants.name;
      var stepAttrs = attributes.steps;
      module.exports = function slidersDefaults(layoutIn, layoutOut) {
        handleArrayContainerDefaults(layoutIn, layoutOut, {
          name,
          handleItemDefaults: sliderDefaults
        });
      };
      function sliderDefaults(sliderIn, sliderOut, layoutOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(sliderIn, sliderOut, attributes, attr, dflt);
        }
        var steps = handleArrayContainerDefaults(sliderIn, sliderOut, {
          name: "steps",
          handleItemDefaults: stepDefaults
        });
        var stepCount = 0;
        for (var i = 0; i < steps.length; i++) {
          if (steps[i].visible) stepCount++;
        }
        var visible;
        if (stepCount < 2) visible = sliderOut.visible = false;
        else visible = coerce("visible");
        if (!visible) return;
        sliderOut._stepCount = stepCount;
        var visSteps = sliderOut._visibleSteps = Lib.filterVisible(steps);
        var active = coerce("active");
        if (!(steps[active] || {}).visible) sliderOut.active = visSteps[0]._index;
        coerce("x");
        coerce("y");
        Lib.noneOrAll(sliderIn, sliderOut, ["x", "y"]);
        coerce("xanchor");
        coerce("yanchor");
        coerce("len");
        coerce("lenmode");
        coerce("pad.t");
        coerce("pad.r");
        coerce("pad.b");
        coerce("pad.l");
        Lib.coerceFont(coerce, "font", layoutOut.font);
        var currentValueIsVisible = coerce("currentvalue.visible");
        if (currentValueIsVisible) {
          coerce("currentvalue.xanchor");
          coerce("currentvalue.prefix");
          coerce("currentvalue.suffix");
          coerce("currentvalue.offset");
          Lib.coerceFont(coerce, "currentvalue.font", sliderOut.font);
        }
        coerce("transition.duration");
        coerce("transition.easing");
        coerce("bgcolor");
        coerce("activebgcolor");
        coerce("bordercolor");
        coerce("borderwidth");
        coerce("ticklen");
        coerce("tickwidth");
        coerce("tickcolor");
        coerce("minorticklen");
      }
      function stepDefaults(valueIn, valueOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(valueIn, valueOut, stepAttrs, attr, dflt);
        }
        var visible;
        if (valueIn.method !== "skip" && !Array.isArray(valueIn.args)) {
          visible = valueOut.visible = false;
        } else visible = coerce("visible");
        if (visible) {
          coerce("method");
          coerce("args");
          var label = coerce("label", "step-" + valueOut._index);
          coerce("value", label);
          coerce("execute");
        }
      }
    }
  });

  // src/components/sliders/draw.js
  var require_draw8 = __commonJS({
    "src/components/sliders/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Plots = require_plots();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var arrayEditor = require_plot_template().arrayEditor;
      var constants = require_constants10();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      module.exports = function draw(gd) {
        var staticPlot = gd._context.staticPlot;
        var fullLayout = gd._fullLayout;
        var sliderData = makeSliderData(fullLayout, gd);
        var sliders = fullLayout._infolayer.selectAll("g." + constants.containerClassName).data(sliderData.length > 0 ? [0] : []);
        sliders.enter().append("g").classed(constants.containerClassName, true).style("cursor", staticPlot ? null : "ew-resize");
        function clearSlider(sliderOpts2) {
          if (sliderOpts2._commandObserver) {
            sliderOpts2._commandObserver.remove();
            delete sliderOpts2._commandObserver;
          }
          Plots.autoMargin(gd, autoMarginId(sliderOpts2));
        }
        sliders.exit().each(function() {
          d3.select(this).selectAll("g." + constants.groupClassName).each(clearSlider);
        }).remove();
        if (sliderData.length === 0) return;
        var sliderGroups = sliders.selectAll("g." + constants.groupClassName).data(sliderData, keyFunction);
        sliderGroups.enter().append("g").classed(constants.groupClassName, true);
        sliderGroups.exit().each(clearSlider).remove();
        for (var i = 0; i < sliderData.length; i++) {
          var sliderOpts = sliderData[i];
          findDimensions(gd, sliderOpts);
        }
        sliderGroups.each(function(sliderOpts2) {
          var gSlider = d3.select(this);
          computeLabelSteps(sliderOpts2);
          Plots.manageCommandObserver(gd, sliderOpts2, sliderOpts2._visibleSteps, function(data) {
            var opts = gSlider.data()[0];
            if (opts.active === data.index) return;
            if (opts._dragging) return;
            setActive(gd, gSlider, opts, data.index, false, true);
          });
          drawSlider(gd, d3.select(this), sliderOpts2);
        });
      };
      function autoMarginId(sliderOpts) {
        return constants.autoMarginIdRoot + sliderOpts._index;
      }
      function makeSliderData(fullLayout, gd) {
        var contOpts = fullLayout[constants.name];
        var sliderData = [];
        for (var i = 0; i < contOpts.length; i++) {
          var item = contOpts[i];
          if (!item.visible) continue;
          item._gd = gd;
          sliderData.push(item);
        }
        return sliderData;
      }
      function keyFunction(opts) {
        return opts._index;
      }
      function findDimensions(gd, sliderOpts) {
        var sliderLabels = Drawing.tester.selectAll("g." + constants.labelGroupClass).data(sliderOpts._visibleSteps);
        sliderLabels.enter().append("g").classed(constants.labelGroupClass, true);
        var maxLabelWidth = 0;
        var labelHeight = 0;
        sliderLabels.each(function(stepOpts) {
          var labelGroup = d3.select(this);
          var text = drawLabel(labelGroup, { step: stepOpts }, sliderOpts);
          var textNode = text.node();
          if (textNode) {
            var bBox = Drawing.bBox(textNode);
            labelHeight = Math.max(labelHeight, bBox.height);
            maxLabelWidth = Math.max(maxLabelWidth, bBox.width);
          }
        });
        sliderLabels.remove();
        var dims = sliderOpts._dims = {};
        dims.inputAreaWidth = Math.max(
          constants.railWidth,
          constants.gripHeight
        );
        var graphSize = gd._fullLayout._size;
        dims.lx = graphSize.l + graphSize.w * sliderOpts.x;
        dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);
        if (sliderOpts.lenmode === "fraction") {
          dims.outerLength = Math.round(graphSize.w * sliderOpts.len);
        } else {
          dims.outerLength = sliderOpts.len;
        }
        dims.inputAreaStart = 0;
        dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);
        var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;
        var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);
        var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;
        dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));
        dims.labelHeight = labelHeight;
        dims.currentValueMaxWidth = 0;
        dims.currentValueHeight = 0;
        dims.currentValueTotalHeight = 0;
        dims.currentValueMaxLines = 1;
        if (sliderOpts.currentvalue.visible) {
          var dummyGroup = Drawing.tester.append("g");
          sliderLabels.each(function(stepOpts) {
            var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);
            var curValSize = curValPrefix.node() && Drawing.bBox(curValPrefix.node()) || { width: 0, height: 0 };
            var lines = svgTextUtils.lineCount(curValPrefix);
            dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));
            dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));
            dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);
          });
          dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;
          dummyGroup.remove();
        }
        dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;
        var xanchor = "left";
        if (Lib.isRightAnchor(sliderOpts)) {
          dims.lx -= dims.outerLength;
          xanchor = "right";
        }
        if (Lib.isCenterAnchor(sliderOpts)) {
          dims.lx -= dims.outerLength / 2;
          xanchor = "center";
        }
        var yanchor = "top";
        if (Lib.isBottomAnchor(sliderOpts)) {
          dims.ly -= dims.height;
          yanchor = "bottom";
        }
        if (Lib.isMiddleAnchor(sliderOpts)) {
          dims.ly -= dims.height / 2;
          yanchor = "middle";
        }
        dims.outerLength = Math.ceil(dims.outerLength);
        dims.height = Math.ceil(dims.height);
        dims.lx = Math.round(dims.lx);
        dims.ly = Math.round(dims.ly);
        var marginOpts = {
          y: sliderOpts.y,
          b: dims.height * FROM_BR[yanchor],
          t: dims.height * FROM_TL[yanchor]
        };
        if (sliderOpts.lenmode === "fraction") {
          marginOpts.l = 0;
          marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];
          marginOpts.r = 0;
          marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];
        } else {
          marginOpts.x = sliderOpts.x;
          marginOpts.l = dims.outerLength * FROM_TL[xanchor];
          marginOpts.r = dims.outerLength * FROM_BR[xanchor];
        }
        Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);
      }
      function drawSlider(gd, sliderGroup, sliderOpts) {
        if (!(sliderOpts.steps[sliderOpts.active] || {}).visible) {
          sliderOpts.active = sliderOpts._visibleSteps[0]._index;
        }
        sliderGroup.call(drawCurrentValue, sliderOpts).call(drawRail, sliderOpts).call(drawLabelGroup, sliderOpts).call(drawTicks, sliderOpts).call(drawTouchRect, gd, sliderOpts).call(drawGrip, gd, sliderOpts);
        var dims = sliderOpts._dims;
        Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);
        sliderGroup.call(setGripPosition, sliderOpts, false);
        sliderGroup.call(drawCurrentValue, sliderOpts);
      }
      function drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {
        if (!sliderOpts.currentvalue.visible) return;
        var dims = sliderOpts._dims;
        var x0, textAnchor;
        switch (sliderOpts.currentvalue.xanchor) {
          case "right":
            x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;
            textAnchor = "left";
            break;
          case "center":
            x0 = dims.inputAreaLength * 0.5;
            textAnchor = "middle";
            break;
          default:
            x0 = constants.currentValueInset;
            textAnchor = "left";
        }
        var text = Lib.ensureSingle(sliderGroup, "text", constants.labelClass, function(s) {
          s.attr({
            "text-anchor": textAnchor,
            "data-notex": 1
          });
        });
        var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : "";
        if (typeof valueOverride === "string") {
          str += valueOverride;
        } else {
          var curVal = sliderOpts.steps[sliderOpts.active].label;
          var _meta = sliderOpts._gd._fullLayout._meta;
          if (_meta) curVal = Lib.templateString(curVal, _meta);
          str += curVal;
        }
        if (sliderOpts.currentvalue.suffix) {
          str += sliderOpts.currentvalue.suffix;
        }
        text.call(Drawing.font, sliderOpts.currentvalue.font).text(str).call(svgTextUtils.convertToTspans, sliderOpts._gd);
        var lines = svgTextUtils.lineCount(text);
        var y0 = (dims.currentValueMaxLines + 1 - lines) * sliderOpts.currentvalue.font.size * LINE_SPACING;
        svgTextUtils.positionText(text, x0, y0);
        return text;
      }
      function drawGrip(sliderGroup, gd, sliderOpts) {
        var grip = Lib.ensureSingle(sliderGroup, "rect", constants.gripRectClass, function(s) {
          s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style("pointer-events", "all");
        });
        grip.attr({
          width: constants.gripWidth,
          height: constants.gripHeight,
          rx: constants.gripRadius,
          ry: constants.gripRadius
        }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style("stroke-width", sliderOpts.borderwidth + "px");
      }
      function drawLabel(item, data, sliderOpts) {
        var text = Lib.ensureSingle(item, "text", constants.labelClass, function(s) {
          s.attr({
            "text-anchor": "middle",
            "data-notex": 1
          });
        });
        var tx = data.step.label;
        var _meta = sliderOpts._gd._fullLayout._meta;
        if (_meta) tx = Lib.templateString(tx, _meta);
        text.call(Drawing.font, sliderOpts.font).text(tx).call(svgTextUtils.convertToTspans, sliderOpts._gd);
        return text;
      }
      function drawLabelGroup(sliderGroup, sliderOpts) {
        var labels = Lib.ensureSingle(sliderGroup, "g", constants.labelsClass);
        var dims = sliderOpts._dims;
        var labelItems = labels.selectAll("g." + constants.labelGroupClass).data(dims.labelSteps);
        labelItems.enter().append("g").classed(constants.labelGroupClass, true);
        labelItems.exit().remove();
        labelItems.each(function(d) {
          var item = d3.select(this);
          item.call(drawLabel, d, sliderOpts);
          Drawing.setTranslate(
            item,
            normalizedValueToPosition(sliderOpts, d.fraction),
            constants.tickOffset + sliderOpts.ticklen + // position is the baseline of the top line of text only, even
            // if the label spans multiple lines
            sliderOpts.font.size * LINE_SPACING + constants.labelOffset + dims.currentValueTotalHeight
          );
        });
      }
      function handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {
        var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));
        var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;
        if (quantizedIndex !== sliderOpts.active) {
          setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);
        }
      }
      function setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {
        var previousActive = sliderOpts.active;
        sliderOpts.active = index;
        arrayEditor(gd.layout, constants.name, sliderOpts).applyUpdate("active", index);
        var step = sliderOpts.steps[sliderOpts.active];
        sliderGroup.call(setGripPosition, sliderOpts, doTransition);
        sliderGroup.call(drawCurrentValue, sliderOpts);
        gd.emit("plotly_sliderchange", {
          slider: sliderOpts,
          step: sliderOpts.steps[sliderOpts.active],
          interaction: doCallback,
          previousActive
        });
        if (step && step.method && doCallback) {
          if (sliderGroup._nextMethod) {
            sliderGroup._nextMethod.step = step;
            sliderGroup._nextMethod.doCallback = doCallback;
            sliderGroup._nextMethod.doTransition = doTransition;
          } else {
            sliderGroup._nextMethod = { step, doCallback, doTransition };
            sliderGroup._nextMethodRaf = window.requestAnimationFrame(function() {
              var _step = sliderGroup._nextMethod.step;
              if (!_step.method) return;
              if (_step.execute) {
                Plots.executeAPICommand(gd, _step.method, _step.args);
              }
              sliderGroup._nextMethod = null;
              sliderGroup._nextMethodRaf = null;
            });
          }
        }
      }
      function attachGripEvents(item, gd, sliderGroup) {
        if (gd._context.staticPlot) return;
        var node = sliderGroup.node();
        var $gd = d3.select(gd);
        function getSliderOpts() {
          return sliderGroup.data()[0];
        }
        function mouseDownHandler() {
          var sliderOpts = getSliderOpts();
          gd.emit("plotly_sliderstart", { slider: sliderOpts });
          var grip = sliderGroup.select("." + constants.gripRectClass);
          d3.event.stopPropagation();
          d3.event.preventDefault();
          grip.call(Color.fill, sliderOpts.activebgcolor);
          var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);
          handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);
          sliderOpts._dragging = true;
          function mouseMoveHandler() {
            var sliderOpts2 = getSliderOpts();
            var normalizedPosition2 = positionToNormalizedValue(sliderOpts2, d3.mouse(node)[0]);
            handleInput(gd, sliderGroup, sliderOpts2, normalizedPosition2, false);
          }
          $gd.on("mousemove", mouseMoveHandler);
          $gd.on("touchmove", mouseMoveHandler);
          function mouseUpHandler() {
            var sliderOpts2 = getSliderOpts();
            sliderOpts2._dragging = false;
            grip.call(Color.fill, sliderOpts2.bgcolor);
            $gd.on("mouseup", null);
            $gd.on("mousemove", null);
            $gd.on("touchend", null);
            $gd.on("touchmove", null);
            gd.emit("plotly_sliderend", {
              slider: sliderOpts2,
              step: sliderOpts2.steps[sliderOpts2.active]
            });
          }
          $gd.on("mouseup", mouseUpHandler);
          $gd.on("touchend", mouseUpHandler);
        }
        item.on("mousedown", mouseDownHandler);
        item.on("touchstart", mouseDownHandler);
      }
      function drawTicks(sliderGroup, sliderOpts) {
        var tick = sliderGroup.selectAll("rect." + constants.tickRectClass).data(sliderOpts._visibleSteps);
        var dims = sliderOpts._dims;
        tick.enter().append("rect").classed(constants.tickRectClass, true);
        tick.exit().remove();
        tick.attr({
          width: sliderOpts.tickwidth + "px",
          "shape-rendering": "crispEdges"
        });
        tick.each(function(d, i) {
          var isMajor = i % dims.labelStride === 0;
          var item = d3.select(this);
          item.attr({ height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen }).call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);
          Drawing.setTranslate(
            item,
            normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth,
            (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight
          );
        });
      }
      function computeLabelSteps(sliderOpts) {
        var dims = sliderOpts._dims;
        dims.labelSteps = [];
        var nsteps = sliderOpts._stepCount;
        for (var i = 0; i < nsteps; i += dims.labelStride) {
          dims.labelSteps.push({
            fraction: i / (nsteps - 1),
            step: sliderOpts._visibleSteps[i]
          });
        }
      }
      function setGripPosition(sliderGroup, sliderOpts, doTransition) {
        var grip = sliderGroup.select("rect." + constants.gripRectClass);
        var quantizedIndex = 0;
        for (var i = 0; i < sliderOpts._stepCount; i++) {
          if (sliderOpts._visibleSteps[i]._index === sliderOpts.active) {
            quantizedIndex = i;
            break;
          }
        }
        var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1));
        if (sliderOpts._invokingCommand) return;
        var el = grip;
        if (doTransition && sliderOpts.transition.duration > 0) {
          el = el.transition().duration(sliderOpts.transition.duration).ease(sliderOpts.transition.easing);
        }
        el.attr("transform", strTranslate(x - constants.gripWidth * 0.5, sliderOpts._dims.currentValueTotalHeight));
      }
      function normalizedValueToPosition(sliderOpts, normalizedPosition) {
        var dims = sliderOpts._dims;
        return dims.inputAreaStart + constants.stepInset + (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));
      }
      function positionToNormalizedValue(sliderOpts, position) {
        var dims = sliderOpts._dims;
        return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));
      }
      function drawTouchRect(sliderGroup, gd, sliderOpts) {
        var dims = sliderOpts._dims;
        var rect = Lib.ensureSingle(sliderGroup, "rect", constants.railTouchRectClass, function(s) {
          s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style("pointer-events", "all");
        });
        rect.attr({
          width: dims.inputAreaLength,
          height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)
        }).call(Color.fill, sliderOpts.bgcolor).attr("opacity", 0);
        Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);
      }
      function drawRail(sliderGroup, sliderOpts) {
        var dims = sliderOpts._dims;
        var computedLength = dims.inputAreaLength - constants.railInset * 2;
        var rect = Lib.ensureSingle(sliderGroup, "rect", constants.railRectClass);
        rect.attr({
          width: computedLength,
          height: constants.railWidth,
          rx: constants.railRadius,
          ry: constants.railRadius,
          "shape-rendering": "crispEdges"
        }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style("stroke-width", sliderOpts.borderwidth + "px");
        Drawing.setTranslate(
          rect,
          constants.railInset,
          (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight
        );
      }
    }
  });

  // src/components/sliders/index.js
  var require_sliders = __commonJS({
    "src/components/sliders/index.js"(exports, module) {
      "use strict";
      var constants = require_constants10();
      module.exports = {
        moduleType: "component",
        name: constants.name,
        layoutAttributes: require_attributes19(),
        supplyLayoutDefaults: require_defaults15(),
        draw: require_draw8()
      };
    }
  });

  // src/components/rangeslider/attributes.js
  var require_attributes20 = __commonJS({
    "src/components/rangeslider/attributes.js"(exports, module) {
      "use strict";
      var colorAttributes = require_attributes3();
      module.exports = {
        bgcolor: {
          valType: "color",
          dflt: colorAttributes.background,
          editType: "plot"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttributes.defaultLine,
          editType: "plot"
        },
        borderwidth: {
          valType: "integer",
          dflt: 0,
          min: 0,
          editType: "plot"
        },
        autorange: {
          valType: "boolean",
          dflt: true,
          editType: "calc",
          impliedEdits: { "range[0]": void 0, "range[1]": void 0 }
        },
        range: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "calc", impliedEdits: { "^autorange": false } },
            { valType: "any", editType: "calc", impliedEdits: { "^autorange": false } }
          ],
          editType: "calc",
          impliedEdits: { autorange: false }
        },
        thickness: {
          valType: "number",
          dflt: 0.15,
          min: 0,
          max: 1,
          editType: "plot"
        },
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "calc"
        },
        editType: "calc"
      };
    }
  });

  // src/components/rangeslider/oppaxis_attributes.js
  var require_oppaxis_attributes = __commonJS({
    "src/components/rangeslider/oppaxis_attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        // not really a 'subplot' attribute container,
        // but this is the flag we use to denote attributes that
        // support yaxis, yaxis2, yaxis3, ... counters
        _isSubplotObj: true,
        rangemode: {
          valType: "enumerated",
          values: ["auto", "fixed", "match"],
          dflt: "match",
          editType: "calc"
        },
        range: {
          valType: "info_array",
          items: [
            { valType: "any", editType: "plot" },
            { valType: "any", editType: "plot" }
          ],
          editType: "plot"
        },
        editType: "calc"
      };
    }
  });

  // src/components/rangeslider/constants.js
  var require_constants11 = __commonJS({
    "src/components/rangeslider/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // attribute container name
        name: "rangeslider",
        // class names
        containerClassName: "rangeslider-container",
        bgClassName: "rangeslider-bg",
        rangePlotClassName: "rangeslider-rangeplot",
        maskMinClassName: "rangeslider-mask-min",
        maskMaxClassName: "rangeslider-mask-max",
        slideBoxClassName: "rangeslider-slidebox",
        grabberMinClassName: "rangeslider-grabber-min",
        grabAreaMinClassName: "rangeslider-grabarea-min",
        handleMinClassName: "rangeslider-handle-min",
        grabberMaxClassName: "rangeslider-grabber-max",
        grabAreaMaxClassName: "rangeslider-grabarea-max",
        handleMaxClassName: "rangeslider-handle-max",
        maskMinOppAxisClassName: "rangeslider-mask-min-opp-axis",
        maskMaxOppAxisClassName: "rangeslider-mask-max-opp-axis",
        // style constants
        maskColor: "rgba(0,0,0,0.4)",
        maskOppAxisColor: "rgba(0,0,0,0.2)",
        slideBoxFill: "transparent",
        slideBoxCursor: "ew-resize",
        grabAreaFill: "transparent",
        grabAreaCursor: "col-resize",
        grabAreaWidth: 10,
        handleWidth: 4,
        handleRadius: 1,
        handleStrokeWidth: 1,
        extraPad: 15
      };
    }
  });

  // src/components/rangeslider/helpers.js
  var require_helpers11 = __commonJS({
    "src/components/rangeslider/helpers.js"(exports) {
      "use strict";
      var axisIDs = require_axis_ids();
      var svgTextUtils = require_svg_text_utils();
      var constants = require_constants11();
      var LINE_SPACING = require_alignment().LINE_SPACING;
      var name = constants.name;
      function isVisible(ax) {
        var rangeSlider = ax && ax[name];
        return rangeSlider && rangeSlider.visible;
      }
      exports.isVisible = isVisible;
      exports.makeData = function(fullLayout) {
        var axes = axisIDs.list({ _fullLayout: fullLayout }, "x", true);
        var margin = fullLayout.margin;
        var rangeSliderData = [];
        for (var i = 0; i < axes.length; i++) {
          var ax = axes[i];
          if (isVisible(ax)) {
            rangeSliderData.push(ax);
            var opts = ax[name];
            opts._id = name + ax._id;
            opts._height = (fullLayout.height - margin.b - margin.t) * opts.thickness;
            opts._offsetShift = Math.floor(opts.borderwidth / 2);
          }
        }
        fullLayout._rangeSliderData = rangeSliderData;
      };
      exports.autoMarginOpts = function(gd, ax) {
        var fullLayout = gd._fullLayout;
        var opts = ax[name];
        var axLetter = ax._id.charAt(0);
        var bottomDepth = 0;
        var titleHeight = 0;
        if (ax.side === "bottom") {
          bottomDepth = ax._depth;
          if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {
            titleHeight = 1.5 * ax.title.font.size + 10 + opts._offsetShift;
            var extraLines = (ax.title.text.match(svgTextUtils.BR_TAG_ALL) || []).length;
            titleHeight += extraLines * ax.title.font.size * LINE_SPACING;
          }
        }
        return {
          x: 0,
          y: ax._counterDomainMin,
          l: 0,
          r: 0,
          t: 0,
          b: opts._height + bottomDepth + Math.max(fullLayout.margin.b, titleHeight),
          pad: constants.extraPad + opts._offsetShift * 2
        };
      };
    }
  });

  // src/components/rangeslider/defaults.js
  var require_defaults16 = __commonJS({
    "src/components/rangeslider/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Template = require_plot_template();
      var axisIds = require_axis_ids();
      var attributes = require_attributes20();
      var oppAxisAttrs = require_oppaxis_attributes();
      module.exports = function handleDefaults(layoutIn, layoutOut, axName) {
        var axIn = layoutIn[axName];
        var axOut = layoutOut[axName];
        if (!(axIn.rangeslider || layoutOut._requestRangeslider[axOut._id])) return;
        if (!Lib.isPlainObject(axIn.rangeslider)) {
          axIn.rangeslider = {};
        }
        var containerIn = axIn.rangeslider;
        var containerOut = Template.newContainer(axOut, "rangeslider");
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        var rangeContainerIn, rangeContainerOut;
        function coerceRange(attr, dflt) {
          return Lib.coerce(rangeContainerIn, rangeContainerOut, oppAxisAttrs, attr, dflt);
        }
        var visible = coerce("visible");
        if (!visible) return;
        coerce("bgcolor", layoutOut.plot_bgcolor);
        coerce("bordercolor");
        coerce("borderwidth");
        coerce("thickness");
        coerce("autorange", !axOut.isValidRange(containerIn.range));
        coerce("range");
        var subplots = layoutOut._subplots;
        if (subplots) {
          var yIds = subplots.cartesian.filter(function(subplotId) {
            return subplotId.substr(0, subplotId.indexOf("y")) === axisIds.name2id(axName);
          }).map(function(subplotId) {
            return subplotId.substr(subplotId.indexOf("y"), subplotId.length);
          });
          var yNames = Lib.simpleMap(yIds, axisIds.id2name);
          for (var i = 0; i < yNames.length; i++) {
            var yName = yNames[i];
            rangeContainerIn = containerIn[yName] || {};
            rangeContainerOut = Template.newContainer(containerOut, yName, "yaxis");
            var yAxOut = layoutOut[yName];
            var rangemodeDflt;
            if (rangeContainerIn.range && yAxOut.isValidRange(rangeContainerIn.range)) {
              rangemodeDflt = "fixed";
            }
            var rangeMode = coerceRange("rangemode", rangemodeDflt);
            if (rangeMode !== "match") {
              coerceRange("range", yAxOut.range.slice());
            }
          }
        }
        containerOut._input = containerIn;
      };
    }
  });

  // src/components/rangeslider/calc_autorange.js
  var require_calc_autorange3 = __commonJS({
    "src/components/rangeslider/calc_autorange.js"(exports, module) {
      "use strict";
      var listAxes = require_axis_ids().list;
      var getAutoRange = require_autorange().getAutoRange;
      var constants = require_constants11();
      module.exports = function calcAutorange(gd) {
        var axes = listAxes(gd, "x", true);
        for (var i = 0; i < axes.length; i++) {
          var ax = axes[i];
          var opts = ax[constants.name];
          if (opts && opts.visible && opts.autorange) {
            opts._input.autorange = true;
            opts._input.range = opts.range = getAutoRange(gd, ax);
          }
        }
      };
    }
  });

  // src/components/rangeslider/draw.js
  var require_draw9 = __commonJS({
    "src/components/rangeslider/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var Drawing = require_drawing();
      var Color = require_color();
      var Titles = require_titles();
      var Cartesian = require_cartesian();
      var axisIDs = require_axis_ids();
      var dragElement = require_dragelement();
      var setCursor = require_setcursor();
      var constants = require_constants11();
      module.exports = function(gd) {
        var fullLayout = gd._fullLayout;
        var rangeSliderData = fullLayout._rangeSliderData;
        for (var i = 0; i < rangeSliderData.length; i++) {
          var opts = rangeSliderData[i][constants.name];
          opts._clipId = opts._id + "-" + fullLayout._uid;
        }
        function keyFunction(axisOpts) {
          return axisOpts._name;
        }
        var rangeSliders = fullLayout._infolayer.selectAll("g." + constants.containerClassName).data(rangeSliderData, keyFunction);
        rangeSliders.exit().each(function(axisOpts) {
          var opts2 = axisOpts[constants.name];
          fullLayout._topdefs.select("#" + opts2._clipId).remove();
        }).remove();
        if (rangeSliderData.length === 0) return;
        rangeSliders.enter().append("g").classed(constants.containerClassName, true).attr("pointer-events", "all");
        rangeSliders.each(function(axisOpts) {
          var rangeSlider = d3.select(this);
          var opts2 = axisOpts[constants.name];
          var oppAxisOpts = fullLayout[axisIDs.id2name(axisOpts.anchor)];
          var oppAxisRangeOpts = opts2[axisIDs.id2name(axisOpts.anchor)];
          if (opts2.range) {
            var rng = Lib.simpleMap(opts2.range, axisOpts.r2l);
            var axRng = Lib.simpleMap(axisOpts.range, axisOpts.r2l);
            var newRng;
            if (axRng[0] < axRng[1]) {
              newRng = [
                Math.min(rng[0], axRng[0]),
                Math.max(rng[1], axRng[1])
              ];
            } else {
              newRng = [
                Math.max(rng[0], axRng[0]),
                Math.min(rng[1], axRng[1])
              ];
            }
            opts2.range = opts2._input.range = Lib.simpleMap(newRng, axisOpts.l2r);
          }
          axisOpts.cleanRange("rangeslider.range");
          var gs = fullLayout._size;
          var domain = axisOpts.domain;
          opts2._width = gs.w * (domain[1] - domain[0]);
          var x = Math.round(gs.l + gs.w * domain[0]);
          var y = Math.round(
            gs.t + gs.h * (1 - axisOpts._counterDomainMin) + (axisOpts.side === "bottom" ? axisOpts._depth : 0) + opts2._offsetShift + constants.extraPad
          );
          rangeSlider.attr("transform", strTranslate(x, y));
          opts2._rl = Lib.simpleMap(opts2.range, axisOpts.r2l);
          var rl0 = opts2._rl[0];
          var rl1 = opts2._rl[1];
          var drl = rl1 - rl0;
          opts2.p2d = function(v) {
            return v / opts2._width * drl + rl0;
          };
          opts2.d2p = function(v) {
            return (v - rl0) / drl * opts2._width;
          };
          if (axisOpts.rangebreaks) {
            var rsBreaks = axisOpts.locateBreaks(rl0, rl1);
            if (rsBreaks.length) {
              var j, brk;
              var lBreaks = 0;
              for (j = 0; j < rsBreaks.length; j++) {
                brk = rsBreaks[j];
                lBreaks += brk.max - brk.min;
              }
              var m2 = opts2._width / (rl1 - rl0 - lBreaks);
              var _B = [-m2 * rl0];
              for (j = 0; j < rsBreaks.length; j++) {
                brk = rsBreaks[j];
                _B.push(_B[_B.length - 1] - m2 * (brk.max - brk.min));
              }
              opts2.d2p = function(v) {
                var b = _B[0];
                for (var j2 = 0; j2 < rsBreaks.length; j2++) {
                  var brk2 = rsBreaks[j2];
                  if (v >= brk2.max) b = _B[j2 + 1];
                  else if (v < brk2.min) break;
                }
                return b + m2 * v;
              };
              for (j = 0; j < rsBreaks.length; j++) {
                brk = rsBreaks[j];
                brk.pmin = opts2.d2p(brk.min);
                brk.pmax = opts2.d2p(brk.max);
              }
              opts2.p2d = function(v) {
                var b = _B[0];
                for (var j2 = 0; j2 < rsBreaks.length; j2++) {
                  var brk2 = rsBreaks[j2];
                  if (v >= brk2.pmax) b = _B[j2 + 1];
                  else if (v < brk2.pmin) break;
                }
                return (v - b) / m2;
              };
            }
          }
          if (oppAxisRangeOpts.rangemode !== "match") {
            var range0OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[0]);
            var range1OppAxis = oppAxisOpts.r2l(oppAxisRangeOpts.range[1]);
            var distOppAxis = range1OppAxis - range0OppAxis;
            opts2.d2pOppAxis = function(v) {
              return (v - range0OppAxis) / distOppAxis * opts2._height;
            };
          }
          rangeSlider.call(drawBg, gd, axisOpts, opts2).call(addClipPath, gd, axisOpts, opts2).call(drawRangePlot, gd, axisOpts, opts2).call(drawMasks, gd, axisOpts, opts2, oppAxisRangeOpts).call(drawSlideBox, gd, axisOpts, opts2).call(drawGrabbers, gd, axisOpts, opts2);
          setupDragElement(rangeSlider, gd, axisOpts, opts2);
          setPixelRange(rangeSlider, gd, axisOpts, opts2, oppAxisOpts, oppAxisRangeOpts);
          if (axisOpts.side === "bottom") {
            Titles.draw(gd, axisOpts._id + "title", {
              propContainer: axisOpts,
              propName: axisOpts._name + ".title",
              placeholder: fullLayout._dfltTitle.x,
              attributes: {
                x: axisOpts._offset + axisOpts._length / 2,
                y: y + opts2._height + opts2._offsetShift + 10 + 1.5 * axisOpts.title.font.size,
                "text-anchor": "middle"
              }
            });
          }
        });
      };
      function eventX(event) {
        if (typeof event.clientX === "number") {
          return event.clientX;
        }
        if (event.touches && event.touches.length > 0) {
          return event.touches[0].clientX;
        }
        return 0;
      }
      function setupDragElement(rangeSlider, gd, axisOpts, opts) {
        if (gd._context.staticPlot) return;
        var slideBox = rangeSlider.select("rect." + constants.slideBoxClassName).node();
        var grabAreaMin = rangeSlider.select("rect." + constants.grabAreaMinClassName).node();
        var grabAreaMax = rangeSlider.select("rect." + constants.grabAreaMaxClassName).node();
        function mouseDownHandler() {
          var event = d3.event;
          var target = event.target;
          var startX = eventX(event);
          var offsetX = startX - rangeSlider.node().getBoundingClientRect().left;
          var minVal = opts.d2p(axisOpts._rl[0]);
          var maxVal = opts.d2p(axisOpts._rl[1]);
          var dragCover = dragElement.coverSlip();
          this.addEventListener("touchmove", mouseMove);
          this.addEventListener("touchend", mouseUp);
          dragCover.addEventListener("mousemove", mouseMove);
          dragCover.addEventListener("mouseup", mouseUp);
          function mouseMove(e) {
            var clientX = eventX(e);
            var delta = +clientX - startX;
            var pixelMin, pixelMax, cursor;
            switch (target) {
              case slideBox:
                cursor = "ew-resize";
                if (minVal + delta > axisOpts._length || maxVal + delta < 0) {
                  return;
                }
                pixelMin = minVal + delta;
                pixelMax = maxVal + delta;
                break;
              case grabAreaMin:
                cursor = "col-resize";
                if (minVal + delta > axisOpts._length) {
                  return;
                }
                pixelMin = minVal + delta;
                pixelMax = maxVal;
                break;
              case grabAreaMax:
                cursor = "col-resize";
                if (maxVal + delta < 0) {
                  return;
                }
                pixelMin = minVal;
                pixelMax = maxVal + delta;
                break;
              default:
                cursor = "ew-resize";
                pixelMin = offsetX;
                pixelMax = offsetX + delta;
                break;
            }
            if (pixelMax < pixelMin) {
              var tmp = pixelMax;
              pixelMax = pixelMin;
              pixelMin = tmp;
            }
            opts._pixelMin = pixelMin;
            opts._pixelMax = pixelMax;
            setCursor(d3.select(dragCover), cursor);
            setDataRange(rangeSlider, gd, axisOpts, opts);
          }
          function mouseUp() {
            dragCover.removeEventListener("mousemove", mouseMove);
            dragCover.removeEventListener("mouseup", mouseUp);
            this.removeEventListener("touchmove", mouseMove);
            this.removeEventListener("touchend", mouseUp);
            Lib.removeElement(dragCover);
          }
        }
        rangeSlider.on("mousedown", mouseDownHandler);
        rangeSlider.on("touchstart", mouseDownHandler);
      }
      function setDataRange(rangeSlider, gd, axisOpts, opts) {
        function clamp(v) {
          return axisOpts.l2r(Lib.constrain(v, opts._rl[0], opts._rl[1]));
        }
        var dataMin = clamp(opts.p2d(opts._pixelMin));
        var dataMax = clamp(opts.p2d(opts._pixelMax));
        window.requestAnimationFrame(function() {
          Registry.call("_guiRelayout", gd, axisOpts._name + ".range", [dataMin, dataMax]);
        });
      }
      function setPixelRange(rangeSlider, gd, axisOpts, opts, oppAxisOpts, oppAxisRangeOpts) {
        var hw2 = constants.handleWidth / 2;
        function clamp(v) {
          return Lib.constrain(v, 0, opts._width);
        }
        function clampOppAxis(v) {
          return Lib.constrain(v, 0, opts._height);
        }
        function clampHandle(v) {
          return Lib.constrain(v, -hw2, opts._width + hw2);
        }
        var pixelMin = clamp(opts.d2p(axisOpts._rl[0]));
        var pixelMax = clamp(opts.d2p(axisOpts._rl[1]));
        rangeSlider.select("rect." + constants.slideBoxClassName).attr("x", pixelMin).attr("width", pixelMax - pixelMin);
        rangeSlider.select("rect." + constants.maskMinClassName).attr("width", pixelMin);
        rangeSlider.select("rect." + constants.maskMaxClassName).attr("x", pixelMax).attr("width", opts._width - pixelMax);
        if (oppAxisRangeOpts.rangemode !== "match") {
          var pixelMinOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[1]));
          var pixelMaxOppAxis = opts._height - clampOppAxis(opts.d2pOppAxis(oppAxisOpts._rl[0]));
          rangeSlider.select("rect." + constants.maskMinOppAxisClassName).attr("x", pixelMin).attr("height", pixelMinOppAxis).attr("width", pixelMax - pixelMin);
          rangeSlider.select("rect." + constants.maskMaxOppAxisClassName).attr("x", pixelMin).attr("y", pixelMaxOppAxis).attr("height", opts._height - pixelMaxOppAxis).attr("width", pixelMax - pixelMin);
          rangeSlider.select("rect." + constants.slideBoxClassName).attr("y", pixelMinOppAxis).attr("height", pixelMaxOppAxis - pixelMinOppAxis);
        }
        var offset = 0.5;
        var xMin = Math.round(clampHandle(pixelMin - hw2)) - offset;
        var xMax = Math.round(clampHandle(pixelMax - hw2)) + offset;
        rangeSlider.select("g." + constants.grabberMinClassName).attr("transform", strTranslate(xMin, offset));
        rangeSlider.select("g." + constants.grabberMaxClassName).attr("transform", strTranslate(xMax, offset));
      }
      function drawBg(rangeSlider, gd, axisOpts, opts) {
        var bg = Lib.ensureSingle(rangeSlider, "rect", constants.bgClassName, function(s) {
          s.attr({
            x: 0,
            y: 0,
            "shape-rendering": "crispEdges"
          });
        });
        var borderCorrect = opts.borderwidth % 2 === 0 ? opts.borderwidth : opts.borderwidth - 1;
        var offsetShift = -opts._offsetShift;
        var lw = Drawing.crispRound(gd, opts.borderwidth);
        bg.attr({
          width: opts._width + borderCorrect,
          height: opts._height + borderCorrect,
          transform: strTranslate(offsetShift, offsetShift),
          "stroke-width": lw
        }).call(Color.stroke, opts.bordercolor).call(Color.fill, opts.bgcolor);
      }
      function addClipPath(rangeSlider, gd, axisOpts, opts) {
        var fullLayout = gd._fullLayout;
        var clipPath = Lib.ensureSingleById(fullLayout._topdefs, "clipPath", opts._clipId, function(s) {
          s.append("rect").attr({ x: 0, y: 0 });
        });
        clipPath.select("rect").attr({
          width: opts._width,
          height: opts._height
        });
      }
      function drawRangePlot(rangeSlider, gd, axisOpts, opts) {
        var calcData = gd.calcdata;
        var rangePlots = rangeSlider.selectAll("g." + constants.rangePlotClassName).data(axisOpts._subplotsWith, Lib.identity);
        rangePlots.enter().append("g").attr("class", function(id) {
          return constants.rangePlotClassName + " " + id;
        }).call(Drawing.setClipUrl, opts._clipId, gd);
        rangePlots.order();
        rangePlots.exit().remove();
        var mainplotinfo;
        rangePlots.each(function(id, i) {
          var plotgroup = d3.select(this);
          var isMainPlot = i === 0;
          var oppAxisOpts = axisIDs.getFromId(gd, id, "y");
          var oppAxisName = oppAxisOpts._name;
          var oppAxisRangeOpts = opts[oppAxisName];
          var mockFigure = {
            data: [],
            layout: {
              xaxis: {
                type: axisOpts.type,
                domain: [0, 1],
                range: opts.range.slice(),
                calendar: axisOpts.calendar
              },
              width: opts._width,
              height: opts._height,
              margin: { t: 0, b: 0, l: 0, r: 0 }
            },
            _context: gd._context
          };
          if (axisOpts.rangebreaks) {
            mockFigure.layout.xaxis.rangebreaks = axisOpts.rangebreaks;
          }
          mockFigure.layout[oppAxisName] = {
            type: oppAxisOpts.type,
            domain: [0, 1],
            range: oppAxisRangeOpts.rangemode !== "match" ? oppAxisRangeOpts.range.slice() : oppAxisOpts.range.slice(),
            calendar: oppAxisOpts.calendar
          };
          if (oppAxisOpts.rangebreaks) {
            mockFigure.layout[oppAxisName].rangebreaks = oppAxisOpts.rangebreaks;
          }
          Plots.supplyDefaults(mockFigure);
          var xa = mockFigure._fullLayout.xaxis;
          var ya = mockFigure._fullLayout[oppAxisName];
          xa.clearCalc();
          xa.setScale();
          ya.clearCalc();
          ya.setScale();
          var plotinfo = {
            id,
            plotgroup,
            xaxis: xa,
            yaxis: ya,
            isRangePlot: true
          };
          if (isMainPlot) mainplotinfo = plotinfo;
          else {
            plotinfo.mainplot = "xy";
            plotinfo.mainplotinfo = mainplotinfo;
          }
          Cartesian.rangePlot(gd, plotinfo, filterRangePlotCalcData(calcData, id));
        });
      }
      function filterRangePlotCalcData(calcData, subplotId) {
        var out = [];
        for (var i = 0; i < calcData.length; i++) {
          var calcTrace = calcData[i];
          var trace = calcTrace[0].trace;
          if (trace.xaxis + trace.yaxis === subplotId) {
            out.push(calcTrace);
          }
        }
        return out;
      }
      function drawMasks(rangeSlider, gd, axisOpts, opts, oppAxisRangeOpts) {
        var maskMin = Lib.ensureSingle(rangeSlider, "rect", constants.maskMinClassName, function(s) {
          s.attr({
            x: 0,
            y: 0,
            "shape-rendering": "crispEdges"
          });
        });
        maskMin.attr("height", opts._height).call(Color.fill, constants.maskColor);
        var maskMax = Lib.ensureSingle(rangeSlider, "rect", constants.maskMaxClassName, function(s) {
          s.attr({
            y: 0,
            "shape-rendering": "crispEdges"
          });
        });
        maskMax.attr("height", opts._height).call(Color.fill, constants.maskColor);
        if (oppAxisRangeOpts.rangemode !== "match") {
          var maskMinOppAxis = Lib.ensureSingle(rangeSlider, "rect", constants.maskMinOppAxisClassName, function(s) {
            s.attr({
              y: 0,
              "shape-rendering": "crispEdges"
            });
          });
          maskMinOppAxis.attr("width", opts._width).call(Color.fill, constants.maskOppAxisColor);
          var maskMaxOppAxis = Lib.ensureSingle(rangeSlider, "rect", constants.maskMaxOppAxisClassName, function(s) {
            s.attr({
              y: 0,
              "shape-rendering": "crispEdges"
            });
          });
          maskMaxOppAxis.attr("width", opts._width).style("border-top", constants.maskOppBorder).call(Color.fill, constants.maskOppAxisColor);
        }
      }
      function drawSlideBox(rangeSlider, gd, axisOpts, opts) {
        if (gd._context.staticPlot) return;
        var slideBox = Lib.ensureSingle(rangeSlider, "rect", constants.slideBoxClassName, function(s) {
          s.attr({
            y: 0,
            cursor: constants.slideBoxCursor,
            "shape-rendering": "crispEdges"
          });
        });
        slideBox.attr({
          height: opts._height,
          fill: constants.slideBoxFill
        });
      }
      function drawGrabbers(rangeSlider, gd, axisOpts, opts) {
        var grabberMin = Lib.ensureSingle(rangeSlider, "g", constants.grabberMinClassName);
        var grabberMax = Lib.ensureSingle(rangeSlider, "g", constants.grabberMaxClassName);
        var handleFixAttrs = {
          x: 0,
          width: constants.handleWidth,
          rx: constants.handleRadius,
          fill: Color.background,
          stroke: Color.defaultLine,
          "stroke-width": constants.handleStrokeWidth,
          "shape-rendering": "crispEdges"
        };
        var handleDynamicAttrs = {
          y: Math.round(opts._height / 4),
          height: Math.round(opts._height / 2)
        };
        var handleMin = Lib.ensureSingle(grabberMin, "rect", constants.handleMinClassName, function(s) {
          s.attr(handleFixAttrs);
        });
        handleMin.attr(handleDynamicAttrs);
        var handleMax = Lib.ensureSingle(grabberMax, "rect", constants.handleMaxClassName, function(s) {
          s.attr(handleFixAttrs);
        });
        handleMax.attr(handleDynamicAttrs);
        var grabAreaFixAttrs = {
          width: constants.grabAreaWidth,
          x: 0,
          y: 0,
          fill: constants.grabAreaFill,
          cursor: !gd._context.staticPlot ? constants.grabAreaCursor : void 0
        };
        var grabAreaMin = Lib.ensureSingle(grabberMin, "rect", constants.grabAreaMinClassName, function(s) {
          s.attr(grabAreaFixAttrs);
        });
        grabAreaMin.attr("height", opts._height);
        var grabAreaMax = Lib.ensureSingle(grabberMax, "rect", constants.grabAreaMaxClassName, function(s) {
          s.attr(grabAreaFixAttrs);
        });
        grabAreaMax.attr("height", opts._height);
      }
    }
  });

  // src/components/rangeslider/index.js
  var require_rangeslider = __commonJS({
    "src/components/rangeslider/index.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var attrs = require_attributes20();
      var oppAxisAttrs = require_oppaxis_attributes();
      var helpers = require_helpers11();
      module.exports = {
        moduleType: "component",
        name: "rangeslider",
        schema: {
          subplots: {
            xaxis: {
              rangeslider: Lib.extendFlat({}, attrs, {
                yaxis: oppAxisAttrs
              })
            }
          }
        },
        layoutAttributes: require_attributes20(),
        handleDefaults: require_defaults16(),
        calcAutorange: require_calc_autorange3(),
        draw: require_draw9(),
        isVisible: helpers.isVisible,
        makeData: helpers.makeData,
        autoMarginOpts: helpers.autoMarginOpts
      };
    }
  });

  // src/components/rangeselector/attributes.js
  var require_attributes21 = __commonJS({
    "src/components/rangeselector/attributes.js"(exports, module) {
      "use strict";
      var fontAttrs = require_font_attributes();
      var colorAttrs = require_attributes3();
      var templatedArray = require_plot_template().templatedArray;
      var buttonAttrs = templatedArray("button", {
        visible: {
          valType: "boolean",
          dflt: true,
          editType: "plot"
        },
        step: {
          valType: "enumerated",
          values: ["month", "year", "day", "hour", "minute", "second", "all"],
          dflt: "month",
          editType: "plot"
        },
        stepmode: {
          valType: "enumerated",
          values: ["backward", "todate"],
          dflt: "backward",
          editType: "plot"
        },
        count: {
          valType: "number",
          min: 0,
          dflt: 1,
          editType: "plot"
        },
        label: {
          valType: "string",
          editType: "plot"
        },
        editType: "plot"
      });
      module.exports = {
        visible: {
          valType: "boolean",
          editType: "plot"
        },
        buttons: buttonAttrs,
        x: {
          valType: "number",
          min: -2,
          max: 3,
          editType: "plot"
        },
        xanchor: {
          valType: "enumerated",
          values: ["auto", "left", "center", "right"],
          dflt: "left",
          editType: "plot"
        },
        y: {
          valType: "number",
          min: -2,
          max: 3,
          editType: "plot"
        },
        yanchor: {
          valType: "enumerated",
          values: ["auto", "top", "middle", "bottom"],
          dflt: "bottom",
          editType: "plot"
        },
        font: fontAttrs({
          editType: "plot"
        }),
        bgcolor: {
          valType: "color",
          dflt: colorAttrs.lightLine,
          editType: "plot"
        },
        activecolor: {
          valType: "color",
          editType: "plot"
        },
        bordercolor: {
          valType: "color",
          dflt: colorAttrs.defaultLine,
          editType: "plot"
        },
        borderwidth: {
          valType: "number",
          min: 0,
          dflt: 0,
          editType: "plot"
        },
        editType: "plot"
      };
    }
  });

  // src/components/rangeselector/constants.js
  var require_constants12 = __commonJS({
    "src/components/rangeselector/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        // 'y' position pad above counter axis domain
        yPad: 0.02,
        // minimum button width (regardless of text size)
        minButtonWidth: 30,
        // buttons rect radii
        rx: 3,
        ry: 3,
        // light fraction used to compute the 'activecolor' default
        lightAmount: 25,
        darkAmount: 10
      };
    }
  });

  // src/components/rangeselector/defaults.js
  var require_defaults17 = __commonJS({
    "src/components/rangeselector/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var Template = require_plot_template();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes21();
      var constants = require_constants12();
      module.exports = function handleDefaults(containerIn, containerOut, layout, counterAxes, calendar) {
        var selectorIn = containerIn.rangeselector || {};
        var selectorOut = Template.newContainer(containerOut, "rangeselector");
        function coerce(attr, dflt) {
          return Lib.coerce(selectorIn, selectorOut, attributes, attr, dflt);
        }
        var buttons = handleArrayContainerDefaults(selectorIn, selectorOut, {
          name: "buttons",
          handleItemDefaults: buttonDefaults,
          calendar
        });
        var visible = coerce("visible", buttons.length > 0);
        if (visible) {
          var posDflt = getPosDflt(containerOut, layout, counterAxes);
          coerce("x", posDflt[0]);
          coerce("y", posDflt[1]);
          Lib.noneOrAll(containerIn, containerOut, ["x", "y"]);
          coerce("xanchor");
          coerce("yanchor");
          Lib.coerceFont(coerce, "font", layout.font);
          var bgColor = coerce("bgcolor");
          coerce("activecolor", Color.contrast(bgColor, constants.lightAmount, constants.darkAmount));
          coerce("bordercolor");
          coerce("borderwidth");
        }
      };
      function buttonDefaults(buttonIn, buttonOut, selectorOut, opts) {
        var calendar = opts.calendar;
        function coerce(attr, dflt) {
          return Lib.coerce(buttonIn, buttonOut, attributes.buttons, attr, dflt);
        }
        var visible = coerce("visible");
        if (visible) {
          var step = coerce("step");
          if (step !== "all") {
            if (calendar && calendar !== "gregorian" && (step === "month" || step === "year")) {
              buttonOut.stepmode = "backward";
            } else {
              coerce("stepmode");
            }
            coerce("count");
          }
          coerce("label");
        }
      }
      function getPosDflt(containerOut, layout, counterAxes) {
        var anchoredList = counterAxes.filter(function(ax) {
          return layout[ax].anchor === containerOut._id;
        });
        var posY = 0;
        for (var i = 0; i < anchoredList.length; i++) {
          var domain = layout[anchoredList[i]].domain;
          if (domain) posY = Math.max(domain[1], posY);
        }
        return [containerOut.domain[0], posY + constants.yPad];
      }
    }
  });

  // src/components/rangeselector/get_update_object.js
  var require_get_update_object = __commonJS({
    "src/components/rangeselector/get_update_object.js"(exports, module) {
      "use strict";
      var d3Time = require_d3_time();
      var titleCase = require_lib().titleCase;
      module.exports = function getUpdateObject(axisLayout, buttonLayout) {
        var axName = axisLayout._name;
        var update = {};
        if (buttonLayout.step === "all") {
          update[axName + ".autorange"] = true;
        } else {
          var xrange = getXRange(axisLayout, buttonLayout);
          update[axName + ".range[0]"] = xrange[0];
          update[axName + ".range[1]"] = xrange[1];
        }
        return update;
      };
      function getXRange(axisLayout, buttonLayout) {
        var currentRange = axisLayout.range;
        var base = new Date(axisLayout.r2l(currentRange[1]));
        var step = buttonLayout.step;
        var utcStep = d3Time["utc" + titleCase(step)];
        var count = buttonLayout.count;
        var range0;
        switch (buttonLayout.stepmode) {
          case "backward":
            range0 = axisLayout.l2r(+utcStep.offset(base, -count));
            break;
          case "todate":
            var base2 = utcStep.offset(base, -count);
            range0 = axisLayout.l2r(+utcStep.ceil(base2));
            break;
        }
        var range1 = currentRange[1];
        return [range0, range1];
      }
    }
  });

  // src/components/rangeselector/draw.js
  var require_draw10 = __commonJS({
    "src/components/rangeselector/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Registry = require_registry();
      var Plots = require_plots();
      var Color = require_color();
      var Drawing = require_drawing();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var axisIds = require_axis_ids();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      var constants = require_constants12();
      var getUpdateObject = require_get_update_object();
      module.exports = function draw(gd) {
        var fullLayout = gd._fullLayout;
        var selectors = fullLayout._infolayer.selectAll(".rangeselector").data(makeSelectorData(gd), selectorKeyFunc);
        selectors.enter().append("g").classed("rangeselector", true);
        selectors.exit().remove();
        selectors.style({
          cursor: "pointer",
          "pointer-events": "all"
        });
        selectors.each(function(d) {
          var selector = d3.select(this);
          var axisLayout = d;
          var selectorLayout = axisLayout.rangeselector;
          var buttons = selector.selectAll("g.button").data(Lib.filterVisible(selectorLayout.buttons));
          buttons.enter().append("g").classed("button", true);
          buttons.exit().remove();
          buttons.each(function(d2) {
            var button = d3.select(this);
            var update = getUpdateObject(axisLayout, d2);
            d2._isActive = isActive(axisLayout, d2, update);
            button.call(drawButtonRect, selectorLayout, d2);
            button.call(drawButtonText, selectorLayout, d2, gd);
            button.on("click", function() {
              if (gd._dragged) return;
              Registry.call("_guiRelayout", gd, update);
            });
            button.on("mouseover", function() {
              d2._isHovered = true;
              button.call(drawButtonRect, selectorLayout, d2);
            });
            button.on("mouseout", function() {
              d2._isHovered = false;
              button.call(drawButtonRect, selectorLayout, d2);
            });
          });
          reposition(gd, buttons, selectorLayout, axisLayout._name, selector);
        });
      };
      function makeSelectorData(gd) {
        var axes = axisIds.list(gd, "x", true);
        var data = [];
        for (var i = 0; i < axes.length; i++) {
          var axis = axes[i];
          if (axis.rangeselector && axis.rangeselector.visible) {
            data.push(axis);
          }
        }
        return data;
      }
      function selectorKeyFunc(d) {
        return d._id;
      }
      function isActive(axisLayout, opts, update) {
        if (opts.step === "all") {
          return axisLayout.autorange === true;
        } else {
          var keys = Object.keys(update);
          return axisLayout.range[0] === update[keys[0]] && axisLayout.range[1] === update[keys[1]];
        }
      }
      function drawButtonRect(button, selectorLayout, d) {
        var rect = Lib.ensureSingle(button, "rect", "selector-rect", function(s) {
          s.attr("shape-rendering", "crispEdges");
        });
        rect.attr({
          rx: constants.rx,
          ry: constants.ry
        });
        rect.call(Color.stroke, selectorLayout.bordercolor).call(Color.fill, getFillColor(selectorLayout, d)).style("stroke-width", selectorLayout.borderwidth + "px");
      }
      function getFillColor(selectorLayout, d) {
        return d._isActive || d._isHovered ? selectorLayout.activecolor : selectorLayout.bgcolor;
      }
      function drawButtonText(button, selectorLayout, d, gd) {
        function textLayout(s) {
          svgTextUtils.convertToTspans(s, gd);
        }
        var text = Lib.ensureSingle(button, "text", "selector-text", function(s) {
          s.attr("text-anchor", "middle");
        });
        text.call(Drawing.font, selectorLayout.font).text(getLabel(d, gd._fullLayout._meta)).call(textLayout);
      }
      function getLabel(opts, _meta) {
        if (opts.label) {
          return _meta ? Lib.templateString(opts.label, _meta) : opts.label;
        }
        if (opts.step === "all") return "all";
        return opts.count + opts.step.charAt(0);
      }
      function reposition(gd, buttons, opts, axName, selector) {
        var width = 0;
        var height = 0;
        var borderWidth = opts.borderwidth;
        buttons.each(function() {
          var button = d3.select(this);
          var text = button.select(".selector-text");
          var tHeight = opts.font.size * LINE_SPACING;
          var hEff = Math.max(tHeight * svgTextUtils.lineCount(text), 16) + 3;
          height = Math.max(height, hEff);
        });
        buttons.each(function() {
          var button = d3.select(this);
          var rect = button.select(".selector-rect");
          var text = button.select(".selector-text");
          var tWidth = text.node() && Drawing.bBox(text.node()).width;
          var tHeight = opts.font.size * LINE_SPACING;
          var tLines = svgTextUtils.lineCount(text);
          var wEff = Math.max(tWidth + 10, constants.minButtonWidth);
          button.attr("transform", strTranslate(borderWidth + width, borderWidth));
          rect.attr({
            x: 0,
            y: 0,
            width: wEff,
            height
          });
          svgTextUtils.positionText(
            text,
            wEff / 2,
            height / 2 - (tLines - 1) * tHeight / 2 + 3
          );
          width += wEff + 5;
        });
        var graphSize = gd._fullLayout._size;
        var lx = graphSize.l + graphSize.w * opts.x;
        var ly = graphSize.t + graphSize.h * (1 - opts.y);
        var xanchor = "left";
        if (Lib.isRightAnchor(opts)) {
          lx -= width;
          xanchor = "right";
        }
        if (Lib.isCenterAnchor(opts)) {
          lx -= width / 2;
          xanchor = "center";
        }
        var yanchor = "top";
        if (Lib.isBottomAnchor(opts)) {
          ly -= height;
          yanchor = "bottom";
        }
        if (Lib.isMiddleAnchor(opts)) {
          ly -= height / 2;
          yanchor = "middle";
        }
        width = Math.ceil(width);
        height = Math.ceil(height);
        lx = Math.round(lx);
        ly = Math.round(ly);
        Plots.autoMargin(gd, axName + "-range-selector", {
          x: opts.x,
          y: opts.y,
          l: width * FROM_TL[xanchor],
          r: width * FROM_BR[xanchor],
          b: height * FROM_BR[yanchor],
          t: height * FROM_TL[yanchor]
        });
        selector.attr("transform", strTranslate(lx, ly));
      }
    }
  });

  // src/components/rangeselector/index.js
  var require_rangeselector = __commonJS({
    "src/components/rangeselector/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "rangeselector",
        schema: {
          subplots: {
            xaxis: { rangeselector: require_attributes21() }
          }
        },
        layoutAttributes: require_attributes21(),
        handleDefaults: require_defaults17(),
        draw: require_draw10()
      };
    }
  });

  // src/plots/domain.js
  var require_domain = __commonJS({
    "src/plots/domain.js"(exports) {
      "use strict";
      var extendFlat = require_extend().extendFlat;
      exports.attributes = function(opts, extra) {
        opts = opts || {};
        extra = extra || {};
        var base = {
          valType: "info_array",
          editType: opts.editType,
          items: [
            { valType: "number", min: 0, max: 1, editType: opts.editType },
            { valType: "number", min: 0, max: 1, editType: opts.editType }
          ],
          dflt: [0, 1]
        };
        var namePart = opts.name ? opts.name + " " : "";
        var contPart = opts.trace ? "trace " : "subplot ";
        var descPart = extra.description ? " " + extra.description : "";
        var out = {
          x: extendFlat({}, base, {}),
          y: extendFlat({}, base, {}),
          editType: opts.editType
        };
        if (!opts.noGridCell) {
          out.row = {
            valType: "integer",
            min: 0,
            dflt: 0,
            editType: opts.editType
          };
          out.column = {
            valType: "integer",
            min: 0,
            dflt: 0,
            editType: opts.editType
          };
        }
        return out;
      };
      exports.defaults = function(containerOut, layout, coerce, dfltDomains) {
        var dfltX = dfltDomains && dfltDomains.x || [0, 1];
        var dfltY = dfltDomains && dfltDomains.y || [0, 1];
        var grid = layout.grid;
        if (grid) {
          var column = coerce("domain.column");
          if (column !== void 0) {
            if (column < grid.columns) dfltX = grid._domains.x[column];
            else delete containerOut.domain.column;
          }
          var row = coerce("domain.row");
          if (row !== void 0) {
            if (row < grid.rows) dfltY = grid._domains.y[row];
            else delete containerOut.domain.row;
          }
        }
        var x = coerce("domain.x", dfltX);
        var y = coerce("domain.y", dfltY);
        if (!(x[0] < x[1])) containerOut.domain.x = dfltX.slice();
        if (!(y[0] < y[1])) containerOut.domain.y = dfltY.slice();
      };
    }
  });

  // src/components/grid/index.js
  var require_grid = __commonJS({
    "src/components/grid/index.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var counterRegex = require_regex().counter;
      var domainAttrs = require_domain().attributes;
      var cartesianIdRegex = require_constants2().idRegex;
      var Template = require_plot_template();
      var gridAttrs = {
        rows: {
          valType: "integer",
          min: 1,
          editType: "plot"
        },
        roworder: {
          valType: "enumerated",
          values: ["top to bottom", "bottom to top"],
          dflt: "top to bottom",
          editType: "plot"
        },
        columns: {
          valType: "integer",
          min: 1,
          editType: "plot"
        },
        subplots: {
          valType: "info_array",
          freeLength: true,
          dimensions: 2,
          items: { valType: "enumerated", values: [counterRegex("xy").toString(), ""], editType: "plot" },
          editType: "plot"
        },
        xaxes: {
          valType: "info_array",
          freeLength: true,
          items: { valType: "enumerated", values: [cartesianIdRegex.x.toString(), ""], editType: "plot" },
          editType: "plot"
        },
        yaxes: {
          valType: "info_array",
          freeLength: true,
          items: { valType: "enumerated", values: [cartesianIdRegex.y.toString(), ""], editType: "plot" },
          editType: "plot"
        },
        pattern: {
          valType: "enumerated",
          values: ["independent", "coupled"],
          dflt: "coupled",
          editType: "plot"
        },
        xgap: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "plot"
        },
        ygap: {
          valType: "number",
          min: 0,
          max: 1,
          editType: "plot"
        },
        domain: domainAttrs({ name: "grid", editType: "plot", noGridCell: true }, {}),
        xside: {
          valType: "enumerated",
          values: ["bottom", "bottom plot", "top plot", "top"],
          dflt: "bottom plot",
          editType: "plot"
        },
        yside: {
          valType: "enumerated",
          values: ["left", "left plot", "right plot", "right"],
          dflt: "left plot",
          editType: "plot"
        },
        editType: "plot"
      };
      function getAxes(layout, grid, axLetter) {
        var gridVal = grid[axLetter + "axes"];
        var splomVal = Object.keys((layout._splomAxes || {})[axLetter] || {});
        if (Array.isArray(gridVal)) return gridVal;
        if (splomVal.length) return splomVal;
      }
      function sizeDefaults(layoutIn, layoutOut) {
        var gridIn = layoutIn.grid || {};
        var xAxes = getAxes(layoutOut, gridIn, "x");
        var yAxes = getAxes(layoutOut, gridIn, "y");
        if (!layoutIn.grid && !xAxes && !yAxes) return;
        var hasSubplotGrid = Array.isArray(gridIn.subplots) && Array.isArray(gridIn.subplots[0]);
        var hasXaxes = Array.isArray(xAxes);
        var hasYaxes = Array.isArray(yAxes);
        var isSplomGenerated = hasXaxes && xAxes !== gridIn.xaxes && hasYaxes && yAxes !== gridIn.yaxes;
        var dfltRows, dfltColumns;
        if (hasSubplotGrid) {
          dfltRows = gridIn.subplots.length;
          dfltColumns = gridIn.subplots[0].length;
        } else {
          if (hasYaxes) dfltRows = yAxes.length;
          if (hasXaxes) dfltColumns = xAxes.length;
        }
        var gridOut = Template.newContainer(layoutOut, "grid");
        function coerce(attr, dflt) {
          return Lib.coerce(gridIn, gridOut, gridAttrs, attr, dflt);
        }
        var rows = coerce("rows", dfltRows);
        var columns = coerce("columns", dfltColumns);
        if (!(rows * columns > 1)) {
          delete layoutOut.grid;
          return;
        }
        if (!hasSubplotGrid && !hasXaxes && !hasYaxes) {
          var useDefaultSubplots = coerce("pattern") === "independent";
          if (useDefaultSubplots) hasSubplotGrid = true;
        }
        gridOut._hasSubplotGrid = hasSubplotGrid;
        var rowOrder = coerce("roworder");
        var reversed = rowOrder === "top to bottom";
        var dfltGapX = hasSubplotGrid ? 0.2 : 0.1;
        var dfltGapY = hasSubplotGrid ? 0.3 : 0.1;
        var dfltSideX, dfltSideY;
        if (isSplomGenerated && layoutOut._splomGridDflt) {
          dfltSideX = layoutOut._splomGridDflt.xside;
          dfltSideY = layoutOut._splomGridDflt.yside;
        }
        gridOut._domains = {
          x: fillGridPositions("x", coerce, dfltGapX, dfltSideX, columns),
          y: fillGridPositions("y", coerce, dfltGapY, dfltSideY, rows, reversed)
        };
      }
      function fillGridPositions(axLetter, coerce, dfltGap, dfltSide, len, reversed) {
        var dirGap = coerce(axLetter + "gap", dfltGap);
        var domain = coerce("domain." + axLetter);
        coerce(axLetter + "side", dfltSide);
        var out = new Array(len);
        var start = domain[0];
        var step = (domain[1] - start) / (len - dirGap);
        var cellDomain = step * (1 - dirGap);
        for (var i = 0; i < len; i++) {
          var cellStart = start + step * i;
          out[reversed ? len - 1 - i : i] = [cellStart, cellStart + cellDomain];
        }
        return out;
      }
      function contentDefaults(layoutIn, layoutOut) {
        var gridOut = layoutOut.grid;
        if (!gridOut || !gridOut._domains) return;
        var gridIn = layoutIn.grid || {};
        var subplots = layoutOut._subplots;
        var hasSubplotGrid = gridOut._hasSubplotGrid;
        var rows = gridOut.rows;
        var columns = gridOut.columns;
        var useDefaultSubplots = gridOut.pattern === "independent";
        var i, j, xId, yId, subplotId, subplotsOut, yPos;
        var axisMap = gridOut._axisMap = {};
        if (hasSubplotGrid) {
          var subplotsIn = gridIn.subplots || [];
          subplotsOut = gridOut.subplots = new Array(rows);
          var index = 1;
          for (i = 0; i < rows; i++) {
            var rowOut = subplotsOut[i] = new Array(columns);
            var rowIn = subplotsIn[i] || [];
            for (j = 0; j < columns; j++) {
              if (useDefaultSubplots) {
                subplotId = index === 1 ? "xy" : "x" + index + "y" + index;
                index++;
              } else subplotId = rowIn[j];
              rowOut[j] = "";
              if (subplots.cartesian.indexOf(subplotId) !== -1) {
                yPos = subplotId.indexOf("y");
                xId = subplotId.slice(0, yPos);
                yId = subplotId.slice(yPos);
                if (axisMap[xId] !== void 0 && axisMap[xId] !== j || axisMap[yId] !== void 0 && axisMap[yId] !== i) {
                  continue;
                }
                rowOut[j] = subplotId;
                axisMap[xId] = j;
                axisMap[yId] = i;
              }
            }
          }
        } else {
          var xAxes = getAxes(layoutOut, gridIn, "x");
          var yAxes = getAxes(layoutOut, gridIn, "y");
          gridOut.xaxes = fillGridAxes(xAxes, subplots.xaxis, columns, axisMap, "x");
          gridOut.yaxes = fillGridAxes(yAxes, subplots.yaxis, rows, axisMap, "y");
        }
        var anchors = gridOut._anchors = {};
        var reversed = gridOut.roworder === "top to bottom";
        for (var axisId in axisMap) {
          var axLetter = axisId.charAt(0);
          var side = gridOut[axLetter + "side"];
          var i0, inc, iFinal;
          if (side.length < 8) {
            anchors[axisId] = "free";
          } else if (axLetter === "x") {
            if (side.charAt(0) === "t" === reversed) {
              i0 = 0;
              inc = 1;
              iFinal = rows;
            } else {
              i0 = rows - 1;
              inc = -1;
              iFinal = -1;
            }
            if (hasSubplotGrid) {
              var column = axisMap[axisId];
              for (i = i0; i !== iFinal; i += inc) {
                subplotId = subplotsOut[i][column];
                if (!subplotId) continue;
                yPos = subplotId.indexOf("y");
                if (subplotId.slice(0, yPos) === axisId) {
                  anchors[axisId] = subplotId.slice(yPos);
                  break;
                }
              }
            } else {
              for (i = i0; i !== iFinal; i += inc) {
                yId = gridOut.yaxes[i];
                if (subplots.cartesian.indexOf(axisId + yId) !== -1) {
                  anchors[axisId] = yId;
                  break;
                }
              }
            }
          } else {
            if (side.charAt(0) === "l") {
              i0 = 0;
              inc = 1;
              iFinal = columns;
            } else {
              i0 = columns - 1;
              inc = -1;
              iFinal = -1;
            }
            if (hasSubplotGrid) {
              var row = axisMap[axisId];
              for (i = i0; i !== iFinal; i += inc) {
                subplotId = subplotsOut[row][i];
                if (!subplotId) continue;
                yPos = subplotId.indexOf("y");
                if (subplotId.slice(yPos) === axisId) {
                  anchors[axisId] = subplotId.slice(0, yPos);
                  break;
                }
              }
            } else {
              for (i = i0; i !== iFinal; i += inc) {
                xId = gridOut.xaxes[i];
                if (subplots.cartesian.indexOf(xId + axisId) !== -1) {
                  anchors[axisId] = xId;
                  break;
                }
              }
            }
          }
        }
      }
      function fillGridAxes(axesIn, axesAllowed, len, axisMap, axLetter) {
        var out = new Array(len);
        var i;
        function fillOneAxis(i2, axisId) {
          if (axesAllowed.indexOf(axisId) !== -1 && axisMap[axisId] === void 0) {
            out[i2] = axisId;
            axisMap[axisId] = i2;
          } else out[i2] = "";
        }
        if (Array.isArray(axesIn)) {
          for (i = 0; i < len; i++) {
            fillOneAxis(i, axesIn[i]);
          }
        } else {
          fillOneAxis(0, axLetter);
          for (i = 1; i < len; i++) {
            fillOneAxis(i, axLetter + (i + 1));
          }
        }
        return out;
      }
      module.exports = {
        moduleType: "component",
        name: "grid",
        schema: {
          layout: { grid: gridAttrs }
        },
        layoutAttributes: gridAttrs,
        sizeDefaults,
        contentDefaults
      };
    }
  });

  // src/components/errorbars/attributes.js
  var require_attributes22 = __commonJS({
    "src/components/errorbars/attributes.js"(exports, module) {
      "use strict";
      module.exports = {
        visible: {
          valType: "boolean",
          editType: "calc"
        },
        type: {
          valType: "enumerated",
          values: ["percent", "constant", "sqrt", "data"],
          editType: "calc"
        },
        symmetric: {
          valType: "boolean",
          editType: "calc"
        },
        array: {
          valType: "data_array",
          editType: "calc"
        },
        arrayminus: {
          valType: "data_array",
          editType: "calc"
        },
        value: {
          valType: "number",
          min: 0,
          dflt: 10,
          editType: "calc"
        },
        valueminus: {
          valType: "number",
          min: 0,
          dflt: 10,
          editType: "calc"
        },
        traceref: {
          valType: "integer",
          min: 0,
          dflt: 0,
          editType: "style"
        },
        tracerefminus: {
          valType: "integer",
          min: 0,
          dflt: 0,
          editType: "style"
        },
        copy_ystyle: {
          valType: "boolean",
          editType: "plot"
        },
        copy_zstyle: {
          valType: "boolean",
          editType: "style"
        },
        color: {
          valType: "color",
          editType: "style"
        },
        thickness: {
          valType: "number",
          min: 0,
          dflt: 2,
          editType: "style"
        },
        width: {
          valType: "number",
          min: 0,
          editType: "plot"
        },
        editType: "calc"
      };
    }
  });

  // src/components/errorbars/defaults.js
  var require_defaults18 = __commonJS({
    "src/components/errorbars/defaults.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Registry = require_registry();
      var Lib = require_lib();
      var Template = require_plot_template();
      var attributes = require_attributes22();
      module.exports = function(traceIn, traceOut, defaultColor, opts) {
        var objName = "error_" + opts.axis;
        var containerOut = Template.newContainer(traceOut, objName);
        var containerIn = traceIn[objName] || {};
        function coerce(attr, dflt) {
          return Lib.coerce(containerIn, containerOut, attributes, attr, dflt);
        }
        var hasErrorBars = containerIn.array !== void 0 || containerIn.value !== void 0 || containerIn.type === "sqrt";
        var visible = coerce("visible", hasErrorBars);
        if (visible === false) return;
        var type = coerce("type", "array" in containerIn ? "data" : "percent");
        var symmetric = true;
        if (type !== "sqrt") {
          symmetric = coerce(
            "symmetric",
            !((type === "data" ? "arrayminus" : "valueminus") in containerIn)
          );
        }
        if (type === "data") {
          coerce("array");
          coerce("traceref");
          if (!symmetric) {
            coerce("arrayminus");
            coerce("tracerefminus");
          }
        } else if (type === "percent" || type === "constant") {
          coerce("value");
          if (!symmetric) coerce("valueminus");
        }
        var copyAttr = "copy_" + opts.inherit + "style";
        if (opts.inherit) {
          var inheritObj = traceOut["error_" + opts.inherit];
          if ((inheritObj || {}).visible) {
            coerce(copyAttr, !(containerIn.color || isNumeric(containerIn.thickness) || isNumeric(containerIn.width)));
          }
        }
        if (!opts.inherit || !containerOut[copyAttr]) {
          coerce("color", defaultColor);
          coerce("thickness");
          coerce("width", Registry.traceIs(traceOut, "gl3d") ? 0 : 4);
        }
      };
    }
  });

  // src/components/errorbars/compute_error.js
  var require_compute_error = __commonJS({
    "src/components/errorbars/compute_error.js"(exports, module) {
      "use strict";
      module.exports = function makeComputeError(opts) {
        var type = opts.type;
        var symmetric = opts.symmetric;
        if (type === "data") {
          var array = opts.array || [];
          if (symmetric) {
            return function computeError(dataPt, index) {
              var val = +array[index];
              return [val, val];
            };
          } else {
            var arrayminus = opts.arrayminus || [];
            return function computeError(dataPt, index) {
              var val = +array[index];
              var valMinus = +arrayminus[index];
              if (!isNaN(val) || !isNaN(valMinus)) {
                return [valMinus || 0, val || 0];
              }
              return [NaN, NaN];
            };
          }
        } else {
          var computeErrorValue = makeComputeErrorValue(type, opts.value);
          var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);
          if (symmetric || opts.valueminus === void 0) {
            return function computeError(dataPt) {
              var val = computeErrorValue(dataPt);
              return [val, val];
            };
          } else {
            return function computeError(dataPt) {
              return [
                computeErrorValueMinus(dataPt),
                computeErrorValue(dataPt)
              ];
            };
          }
        }
      };
      function makeComputeErrorValue(type, value) {
        if (type === "percent") {
          return function(dataPt) {
            return Math.abs(dataPt * value / 100);
          };
        }
        if (type === "constant") {
          return function() {
            return Math.abs(value);
          };
        }
        if (type === "sqrt") {
          return function(dataPt) {
            return Math.sqrt(Math.abs(dataPt));
          };
        }
      }
    }
  });

  // src/components/errorbars/calc.js
  var require_calc4 = __commonJS({
    "src/components/errorbars/calc.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var Registry = require_registry();
      var Axes = require_axes();
      var Lib = require_lib();
      var makeComputeError = require_compute_error();
      module.exports = function calc(gd) {
        var calcdata = gd.calcdata;
        for (var i = 0; i < calcdata.length; i++) {
          var calcTrace = calcdata[i];
          var trace = calcTrace[0].trace;
          if (trace.visible === true && Registry.traceIs(trace, "errorBarsOK")) {
            var xa = Axes.getFromId(gd, trace.xaxis);
            var ya = Axes.getFromId(gd, trace.yaxis);
            calcOneAxis(calcTrace, trace, xa, "x");
            calcOneAxis(calcTrace, trace, ya, "y");
          }
        }
      };
      function calcOneAxis(calcTrace, trace, axis, coord) {
        var opts = trace["error_" + coord] || {};
        var isVisible = opts.visible && ["linear", "log"].indexOf(axis.type) !== -1;
        var vals = [];
        if (!isVisible) return;
        var computeError = makeComputeError(opts);
        for (var i = 0; i < calcTrace.length; i++) {
          var calcPt = calcTrace[i];
          var iIn = calcPt.i;
          if (iIn === void 0) iIn = i;
          else if (iIn === null) continue;
          var calcCoord = calcPt[coord];
          if (!isNumeric(axis.c2l(calcCoord))) continue;
          var errors = computeError(calcCoord, iIn);
          if (isNumeric(errors[0]) && isNumeric(errors[1])) {
            var shoe = calcPt[coord + "s"] = calcCoord - errors[0];
            var hat = calcPt[coord + "h"] = calcCoord + errors[1];
            vals.push(shoe, hat);
          }
        }
        var axId = axis._id;
        var baseExtremes = trace._extremes[axId];
        var extremes = Axes.findExtremes(
          axis,
          vals,
          Lib.extendFlat({ tozero: baseExtremes.opts.tozero }, { padded: true })
        );
        baseExtremes.min = baseExtremes.min.concat(extremes.min);
        baseExtremes.max = baseExtremes.max.concat(extremes.max);
      }
    }
  });

  // src/components/errorbars/plot.js
  var require_plot2 = __commonJS({
    "src/components/errorbars/plot.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var isNumeric = require_fast_isnumeric();
      var Drawing = require_drawing();
      var subTypes = require_subtypes();
      module.exports = function plot(gd, traces, plotinfo, transitionOpts) {
        var isNew;
        var xa = plotinfo.xaxis;
        var ya = plotinfo.yaxis;
        var hasAnimation = transitionOpts && transitionOpts.duration > 0;
        var isStatic = gd._context.staticPlot;
        traces.each(function(d) {
          var trace = d[0].trace;
          var xObj = trace.error_x || {};
          var yObj = trace.error_y || {};
          var keyFunc;
          if (trace.ids) {
            keyFunc = function(d2) {
              return d2.id;
            };
          }
          var sparse = subTypes.hasMarkers(trace) && trace.marker.maxdisplayed > 0;
          if (!yObj.visible && !xObj.visible) d = [];
          var errorbars = d3.select(this).selectAll("g.errorbar").data(d, keyFunc);
          errorbars.exit().remove();
          if (!d.length) return;
          if (!xObj.visible) errorbars.selectAll("path.xerror").remove();
          if (!yObj.visible) errorbars.selectAll("path.yerror").remove();
          errorbars.style("opacity", 1);
          var enter = errorbars.enter().append("g").classed("errorbar", true);
          if (hasAnimation) {
            enter.style("opacity", 0).transition().duration(transitionOpts.duration).style("opacity", 1);
          }
          Drawing.setClipUrl(errorbars, plotinfo.layerClipId, gd);
          errorbars.each(function(d2) {
            var errorbar = d3.select(this);
            var coords = errorCoords(d2, xa, ya);
            if (sparse && !d2.vis) return;
            var path;
            var yerror = errorbar.select("path.yerror");
            if (yObj.visible && isNumeric(coords.x) && isNumeric(coords.yh) && isNumeric(coords.ys)) {
              var yw = yObj.width;
              path = "M" + (coords.x - yw) + "," + coords.yh + "h" + 2 * yw + // hat
              "m-" + yw + ",0V" + coords.ys;
              if (!coords.noYS) path += "m-" + yw + ",0h" + 2 * yw;
              isNew = !yerror.size();
              if (isNew) {
                yerror = errorbar.append("path").style("vector-effect", isStatic ? "none" : "non-scaling-stroke").classed("yerror", true);
              } else if (hasAnimation) {
                yerror = yerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);
              }
              yerror.attr("d", path);
            } else yerror.remove();
            var xerror = errorbar.select("path.xerror");
            if (xObj.visible && isNumeric(coords.y) && isNumeric(coords.xh) && isNumeric(coords.xs)) {
              var xw = (xObj.copy_ystyle ? yObj : xObj).width;
              path = "M" + coords.xh + "," + (coords.y - xw) + "v" + 2 * xw + // hat
              "m0,-" + xw + "H" + coords.xs;
              if (!coords.noXS) path += "m0,-" + xw + "v" + 2 * xw;
              isNew = !xerror.size();
              if (isNew) {
                xerror = errorbar.append("path").style("vector-effect", isStatic ? "none" : "non-scaling-stroke").classed("xerror", true);
              } else if (hasAnimation) {
                xerror = xerror.transition().duration(transitionOpts.duration).ease(transitionOpts.easing);
              }
              xerror.attr("d", path);
            } else xerror.remove();
          });
        });
      };
      function errorCoords(d, xa, ya) {
        var out = {
          x: xa.c2p(d.x),
          y: ya.c2p(d.y)
        };
        if (d.yh !== void 0) {
          out.yh = ya.c2p(d.yh);
          out.ys = ya.c2p(d.ys);
          if (!isNumeric(out.ys)) {
            out.noYS = true;
            out.ys = ya.c2p(d.ys, true);
          }
        }
        if (d.xh !== void 0) {
          out.xh = xa.c2p(d.xh);
          out.xs = xa.c2p(d.xs);
          if (!isNumeric(out.xs)) {
            out.noXS = true;
            out.xs = xa.c2p(d.xs, true);
          }
        }
        return out;
      }
    }
  });

  // src/components/errorbars/style.js
  var require_style3 = __commonJS({
    "src/components/errorbars/style.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Color = require_color();
      module.exports = function style(traces) {
        traces.each(function(d) {
          var trace = d[0].trace;
          var yObj = trace.error_y || {};
          var xObj = trace.error_x || {};
          var s = d3.select(this);
          s.selectAll("path.yerror").style("stroke-width", yObj.thickness + "px").call(Color.stroke, yObj.color);
          if (xObj.copy_ystyle) xObj = yObj;
          s.selectAll("path.xerror").style("stroke-width", xObj.thickness + "px").call(Color.stroke, xObj.color);
        });
      };
    }
  });

  // src/components/errorbars/index.js
  var require_errorbars = __commonJS({
    "src/components/errorbars/index.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var overrideAll = require_edit_types().overrideAll;
      var attributes = require_attributes22();
      var xyAttrs = {
        error_x: Lib.extendFlat({}, attributes),
        error_y: Lib.extendFlat({}, attributes)
      };
      delete xyAttrs.error_x.copy_zstyle;
      delete xyAttrs.error_y.copy_zstyle;
      delete xyAttrs.error_y.copy_ystyle;
      var xyzAttrs = {
        error_x: Lib.extendFlat({}, attributes),
        error_y: Lib.extendFlat({}, attributes),
        error_z: Lib.extendFlat({}, attributes)
      };
      delete xyzAttrs.error_x.copy_ystyle;
      delete xyzAttrs.error_y.copy_ystyle;
      delete xyzAttrs.error_z.copy_ystyle;
      delete xyzAttrs.error_z.copy_zstyle;
      module.exports = {
        moduleType: "component",
        name: "errorbars",
        schema: {
          traces: {
            scatter: xyAttrs,
            bar: xyAttrs,
            histogram: xyAttrs,
            scatter3d: overrideAll(xyzAttrs, "calc", "nested"),
            scattergl: overrideAll(xyAttrs, "calc", "nested")
          }
        },
        supplyDefaults: require_defaults18(),
        calc: require_calc4(),
        makeComputeError: require_compute_error(),
        plot: require_plot2(),
        style: require_style3(),
        hoverInfo
      };
      function hoverInfo(calcPoint, trace, hoverPoint) {
        if ((trace.error_y || {}).visible) {
          hoverPoint.yerr = calcPoint.yh - calcPoint.y;
          if (!trace.error_y.symmetric) hoverPoint.yerrneg = calcPoint.y - calcPoint.ys;
        }
        if ((trace.error_x || {}).visible) {
          hoverPoint.xerr = calcPoint.xh - calcPoint.x;
          if (!trace.error_x.symmetric) hoverPoint.xerrneg = calcPoint.x - calcPoint.xs;
        }
      }
    }
  });

  // src/components/colorbar/constants.js
  var require_constants13 = __commonJS({
    "src/components/colorbar/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        cn: {
          colorbar: "colorbar",
          cbbg: "cbbg",
          cbfill: "cbfill",
          cbfills: "cbfills",
          cbline: "cbline",
          cblines: "cblines",
          cbaxis: "cbaxis",
          cbtitleunshift: "cbtitleunshift",
          cbtitle: "cbtitle",
          cboutline: "cboutline",
          crisp: "crisp",
          jsPlaceholder: "js-placeholder"
        }
      };
    }
  });

  // src/components/colorbar/draw.js
  var require_draw11 = __commonJS({
    "src/components/colorbar/draw.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var tinycolor = require_tinycolor();
      var Plots = require_plots();
      var Registry = require_registry();
      var Axes = require_axes();
      var dragElement = require_dragelement();
      var Lib = require_lib();
      var strTranslate = Lib.strTranslate;
      var extendFlat = require_extend().extendFlat;
      var setCursor = require_setcursor();
      var Drawing = require_drawing();
      var Color = require_color();
      var Titles = require_titles();
      var svgTextUtils = require_svg_text_utils();
      var flipScale = require_helpers().flipScale;
      var handleAxisDefaults = require_axis_defaults();
      var handleAxisPositionDefaults = require_position_defaults();
      var axisLayoutAttrs = require_layout_attributes4();
      var alignmentConstants = require_alignment();
      var LINE_SPACING = alignmentConstants.LINE_SPACING;
      var FROM_TL = alignmentConstants.FROM_TL;
      var FROM_BR = alignmentConstants.FROM_BR;
      var cn = require_constants13().cn;
      function draw(gd) {
        var fullLayout = gd._fullLayout;
        var colorBars = fullLayout._infolayer.selectAll("g." + cn.colorbar).data(makeColorBarData(gd), function(opts) {
          return opts._id;
        });
        colorBars.enter().append("g").attr("class", function(opts) {
          return opts._id;
        }).classed(cn.colorbar, true);
        colorBars.each(function(opts) {
          var g = d3.select(this);
          Lib.ensureSingle(g, "rect", cn.cbbg);
          Lib.ensureSingle(g, "g", cn.cbfills);
          Lib.ensureSingle(g, "g", cn.cblines);
          Lib.ensureSingle(g, "g", cn.cbaxis, function(s) {
            s.classed(cn.crisp, true);
          });
          Lib.ensureSingle(g, "g", cn.cbtitleunshift, function(s) {
            s.append("g").classed(cn.cbtitle, true);
          });
          Lib.ensureSingle(g, "rect", cn.cboutline);
          var done = drawColorBar(g, opts, gd);
          if (done && done.then) (gd._promises || []).push(done);
          if (gd._context.edits.colorbarPosition) {
            makeEditable(g, opts, gd);
          }
        });
        colorBars.exit().each(function(opts) {
          Plots.autoMargin(gd, opts._id);
        }).remove();
        colorBars.order();
      }
      function makeColorBarData(gd) {
        var fullLayout = gd._fullLayout;
        var calcdata = gd.calcdata;
        var out = [];
        var opts;
        var cont;
        var trace;
        var cbOpt;
        function initOpts(opts2) {
          return extendFlat(opts2, {
            // fillcolor can be a d3 scale, domain is z values, range is colors
            // or leave it out for no fill,
            // or set to a string constant for single-color fill
            _fillcolor: null,
            // line.color has the same options as fillcolor
            _line: { color: null, width: null, dash: null },
            // levels of lines to draw.
            // note that this DOES NOT determine the extent of the bar
            // that's given by the domain of fillcolor
            // (or line.color if no fillcolor domain)
            _levels: { start: null, end: null, size: null },
            // separate fill levels (for example, heatmap coloring of a
            // contour map) if this is omitted, fillcolors will be
            // evaluated halfway between levels
            _filllevels: null,
            // for continuous colorscales: fill with a gradient instead of explicit levels
            // value should be the colorscale [[0, c0], [v1, c1], ..., [1, cEnd]]
            _fillgradient: null,
            // when using a gradient, we need the data range specified separately
            _zrange: null
          });
        }
        function calcOpts() {
          if (typeof cbOpt.calc === "function") {
            cbOpt.calc(gd, trace, opts);
          } else {
            opts._fillgradient = cont.reversescale ? flipScale(cont.colorscale) : cont.colorscale;
            opts._zrange = [cont[cbOpt.min], cont[cbOpt.max]];
          }
        }
        for (var i = 0; i < calcdata.length; i++) {
          var cd = calcdata[i];
          trace = cd[0].trace;
          if (!trace._module) continue;
          var moduleOpts = trace._module.colorbar;
          if (trace.visible === true && moduleOpts) {
            var allowsMultiplotCbs = Array.isArray(moduleOpts);
            var cbOpts = allowsMultiplotCbs ? moduleOpts : [moduleOpts];
            for (var j = 0; j < cbOpts.length; j++) {
              cbOpt = cbOpts[j];
              var contName = cbOpt.container;
              cont = contName ? trace[contName] : trace;
              if (cont && cont.showscale) {
                opts = initOpts(cont.colorbar);
                opts._id = "cb" + trace.uid + (allowsMultiplotCbs && contName ? "-" + contName : "");
                opts._traceIndex = trace.index;
                opts._propPrefix = (contName ? contName + "." : "") + "colorbar.";
                opts._meta = trace._meta;
                calcOpts();
                out.push(opts);
              }
            }
          }
        }
        for (var k in fullLayout._colorAxes) {
          cont = fullLayout[k];
          if (cont.showscale) {
            var colorAxOpts = fullLayout._colorAxes[k];
            opts = initOpts(cont.colorbar);
            opts._id = "cb" + k;
            opts._propPrefix = k + ".colorbar.";
            opts._meta = fullLayout._meta;
            cbOpt = { min: "cmin", max: "cmax" };
            if (colorAxOpts[0] !== "heatmap") {
              trace = colorAxOpts[1];
              cbOpt.calc = trace._module.colorbar.calc;
            }
            calcOpts();
            out.push(opts);
          }
        }
        return out;
      }
      function drawColorBar(g, opts, gd) {
        var isVertical = opts.orientation === "v";
        var len = opts.len;
        var lenmode = opts.lenmode;
        var thickness = opts.thickness;
        var thicknessmode = opts.thicknessmode;
        var outlinewidth = opts.outlinewidth;
        var borderwidth = opts.borderwidth;
        var bgcolor = opts.bgcolor;
        var xanchor = opts.xanchor;
        var yanchor = opts.yanchor;
        var xpad = opts.xpad;
        var ypad = opts.ypad;
        var optsX = opts.x;
        var optsY = isVertical ? opts.y : 1 - opts.y;
        var isPaperY = opts.yref === "paper";
        var isPaperX = opts.xref === "paper";
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var fillColor = opts._fillcolor;
        var line = opts._line;
        var title = opts.title;
        var titleSide = title.side;
        var zrange = opts._zrange || d3.extent((typeof fillColor === "function" ? fillColor : line.color).domain());
        var lineColormap = typeof line.color === "function" ? line.color : function() {
          return line.color;
        };
        var fillColormap = typeof fillColor === "function" ? fillColor : function() {
          return fillColor;
        };
        var levelsIn = opts._levels;
        var levelsOut = calcLevels(gd, opts, zrange);
        var fillLevels = levelsOut.fill;
        var lineLevels = levelsOut.line;
        var thickPx = Math.round(thickness * (thicknessmode === "fraction" ? isVertical ? gs.w : gs.h : 1));
        var thickFrac = thickPx / (isVertical ? gs.w : gs.h);
        var lenPx = Math.round(len * (lenmode === "fraction" ? isVertical ? gs.h : gs.w : 1));
        var lenFrac = lenPx / (isVertical ? gs.h : gs.w);
        var posW = isPaperX ? gs.w : gd._fullLayout.width;
        var posH = isPaperY ? gs.h : gd._fullLayout.height;
        var uPx = Math.round(
          isVertical ? optsX * posW + xpad : optsY * posH + ypad
        );
        var xRatio = { center: 0.5, right: 1 }[xanchor] || 0;
        var yRatio = { top: 1, middle: 0.5 }[yanchor] || 0;
        var uFrac = isVertical ? optsX - xRatio * thickFrac : optsY - yRatio * thickFrac;
        var vFrac = isVertical ? optsY - yRatio * lenFrac : optsX - xRatio * lenFrac;
        var vPx = Math.round(
          isVertical ? posH * (1 - vFrac) : posW * vFrac
        );
        opts._lenFrac = lenFrac;
        opts._thickFrac = thickFrac;
        opts._uFrac = uFrac;
        opts._vFrac = vFrac;
        var ax = opts._axis = mockColorBarAxis(gd, opts, zrange);
        ax.position = thickFrac + (isVertical ? optsX + xpad / gs.w : optsY + ypad / gs.h);
        var topOrBottom = ["top", "bottom"].indexOf(titleSide) !== -1;
        if (isVertical && topOrBottom) {
          ax.title.side = titleSide;
          ax.titlex = optsX + xpad / gs.w;
          ax.titley = vFrac + (title.side === "top" ? lenFrac - ypad / gs.h : ypad / gs.h);
        }
        if (!isVertical && !topOrBottom) {
          ax.title.side = titleSide;
          ax.titley = optsY + ypad / gs.h;
          ax.titlex = vFrac + xpad / gs.w;
        }
        if (line.color && opts.tickmode === "auto") {
          ax.tickmode = "linear";
          ax.tick0 = levelsIn.start;
          var dtick = levelsIn.size;
          var autoNtick = Lib.constrain(lenPx / 50, 4, 15) + 1;
          var dtFactor = (zrange[1] - zrange[0]) / ((opts.nticks || autoNtick) * dtick);
          if (dtFactor > 1) {
            var dtexp = Math.pow(10, Math.floor(Math.log(dtFactor) / Math.LN10));
            dtick *= dtexp * Lib.roundUp(dtFactor / dtexp, [2, 5, 10]);
            if ((Math.abs(levelsIn.start) / levelsIn.size + 1e-6) % 1 < 2e-6) {
              ax.tick0 = 0;
            }
          }
          ax.dtick = dtick;
        }
        ax.domain = isVertical ? [
          vFrac + ypad / gs.h,
          vFrac + lenFrac - ypad / gs.h
        ] : [
          vFrac + xpad / gs.w,
          vFrac + lenFrac - xpad / gs.w
        ];
        ax.setScale();
        g.attr("transform", strTranslate(Math.round(gs.l), Math.round(gs.t)));
        var titleCont = g.select("." + cn.cbtitleunshift).attr("transform", strTranslate(-Math.round(gs.l), -Math.round(gs.t)));
        var ticklabelposition = ax.ticklabelposition;
        var titleFontSize = ax.title.font.size;
        var axLayer = g.select("." + cn.cbaxis);
        var titleEl;
        var titleHeight = 0;
        var titleWidth = 0;
        function drawTitle(titleClass, titleOpts) {
          var dfltTitleOpts = {
            propContainer: ax,
            propName: opts._propPrefix + "title",
            traceIndex: opts._traceIndex,
            _meta: opts._meta,
            placeholder: fullLayout._dfltTitle.colorbar,
            containerGroup: g.select("." + cn.cbtitle)
          };
          var otherClass = titleClass.charAt(0) === "h" ? titleClass.substr(1) : "h" + titleClass;
          g.selectAll("." + otherClass + ",." + otherClass + "-math-group").remove();
          Titles.draw(gd, titleClass, extendFlat(dfltTitleOpts, titleOpts || {}));
        }
        function drawDummyTitle() {
          if (isVertical && topOrBottom || !isVertical && !topOrBottom) {
            var x, y;
            if (titleSide === "top") {
              x = xpad + gs.l + posW * optsX;
              y = ypad + gs.t + posH * (1 - vFrac - lenFrac) + 3 + titleFontSize * 0.75;
            }
            if (titleSide === "bottom") {
              x = xpad + gs.l + posW * optsX;
              y = ypad + gs.t + posH * (1 - vFrac) - 3 - titleFontSize * 0.25;
            }
            if (titleSide === "right") {
              y = ypad + gs.t + posH * optsY + 3 + titleFontSize * 0.75;
              x = xpad + gs.l + posW * vFrac;
            }
            drawTitle(ax._id + "title", {
              attributes: { x, y, "text-anchor": isVertical ? "start" : "middle" }
            });
          }
        }
        function drawCbTitle() {
          if (isVertical && !topOrBottom || !isVertical && topOrBottom) {
            var pos = ax.position || 0;
            var mid = ax._offset + ax._length / 2;
            var x, y;
            if (titleSide === "right") {
              y = mid;
              x = gs.l + posW * pos + 10 + titleFontSize * (ax.showticklabels ? 1 : 0.5);
            } else {
              x = mid;
              if (titleSide === "bottom") {
                y = gs.t + posH * pos + 10 + (ticklabelposition.indexOf("inside") === -1 ? ax.tickfont.size : 0) + (ax.ticks !== "intside" ? opts.ticklen || 0 : 0);
              }
              if (titleSide === "top") {
                var nlines = title.text.split("<br>").length;
                y = gs.t + posH * pos + 10 - thickPx - LINE_SPACING * titleFontSize * nlines;
              }
            }
            drawTitle((isVertical ? (
              // the 'h' + is a hack to get around the fact that
              // convertToTspans rotates any 'y...' class by 90 degrees.
              // TODO: find a better way to control this.
              "h"
            ) : "v") + ax._id + "title", {
              avoid: {
                selection: d3.select(gd).selectAll("g." + ax._id + "tick"),
                side: titleSide,
                offsetTop: isVertical ? 0 : gs.t,
                offsetLeft: isVertical ? gs.l : 0,
                maxShift: isVertical ? fullLayout.width : fullLayout.height
              },
              attributes: { x, y, "text-anchor": "middle" },
              transform: { rotate: isVertical ? -90 : 0, offset: 0 }
            });
          }
        }
        function drawAxis() {
          if (!isVertical && !topOrBottom || isVertical && topOrBottom) {
            var titleGroup = g.select("." + cn.cbtitle);
            var titleText = titleGroup.select("text");
            var titleTrans = [-outlinewidth / 2, outlinewidth / 2];
            var mathJaxNode = titleGroup.select(".h" + ax._id + "title-math-group").node();
            var lineSize = 15.6;
            if (titleText.node()) {
              lineSize = parseInt(titleText.node().style.fontSize, 10) * LINE_SPACING;
            }
            var bb;
            if (mathJaxNode) {
              bb = Drawing.bBox(mathJaxNode);
              titleWidth = bb.width;
              titleHeight = bb.height;
              if (titleHeight > lineSize) {
                titleTrans[1] -= (titleHeight - lineSize) / 2;
              }
            } else if (titleText.node() && !titleText.classed(cn.jsPlaceholder)) {
              bb = Drawing.bBox(titleText.node());
              titleWidth = bb.width;
              titleHeight = bb.height;
            }
            if (isVertical) {
              if (titleHeight) {
                titleHeight += 5;
                if (titleSide === "top") {
                  ax.domain[1] -= titleHeight / gs.h;
                  titleTrans[1] *= -1;
                } else {
                  ax.domain[0] += titleHeight / gs.h;
                  var nlines = svgTextUtils.lineCount(titleText);
                  titleTrans[1] += (1 - nlines) * lineSize;
                }
                titleGroup.attr("transform", strTranslate(titleTrans[0], titleTrans[1]));
                ax.setScale();
              }
            } else {
              if (titleWidth) {
                if (titleSide === "right") {
                  ax.domain[0] += (titleWidth + titleFontSize / 2) / gs.w;
                }
                titleGroup.attr("transform", strTranslate(titleTrans[0], titleTrans[1]));
                ax.setScale();
              }
            }
          }
          g.selectAll("." + cn.cbfills + ",." + cn.cblines).attr(
            "transform",
            isVertical ? strTranslate(0, Math.round(gs.h * (1 - ax.domain[1]))) : strTranslate(Math.round(gs.w * ax.domain[0]), 0)
          );
          axLayer.attr(
            "transform",
            isVertical ? strTranslate(0, Math.round(-gs.t)) : strTranslate(Math.round(-gs.l), 0)
          );
          var fills = g.select("." + cn.cbfills).selectAll("rect." + cn.cbfill).attr("style", "").data(fillLevels);
          fills.enter().append("rect").classed(cn.cbfill, true).attr("style", "");
          fills.exit().remove();
          var zBounds = zrange.map(ax.c2p).map(Math.round).sort(function(a, b) {
            return a - b;
          });
          fills.each(function(d, i) {
            var z = [
              i === 0 ? zrange[0] : (fillLevels[i] + fillLevels[i - 1]) / 2,
              i === fillLevels.length - 1 ? zrange[1] : (fillLevels[i] + fillLevels[i + 1]) / 2
            ].map(ax.c2p).map(Math.round);
            if (isVertical) {
              z[1] = Lib.constrain(z[1] + (z[1] > z[0]) ? 1 : -1, zBounds[0], zBounds[1]);
            }
            var fillEl = d3.select(this).attr(isVertical ? "x" : "y", uPx).attr(isVertical ? "y" : "x", d3.min(z)).attr(isVertical ? "width" : "height", Math.max(thickPx, 2)).attr(isVertical ? "height" : "width", Math.max(d3.max(z) - d3.min(z), 2));
            if (opts._fillgradient) {
              Drawing.gradient(fillEl, gd, opts._id, isVertical ? "vertical" : "horizontalreversed", opts._fillgradient, "fill");
            } else {
              var colorString = fillColormap(d).replace("e-", "");
              fillEl.attr("fill", tinycolor(colorString).toHexString());
            }
          });
          var lines = g.select("." + cn.cblines).selectAll("path." + cn.cbline).data(line.color && line.width ? lineLevels : []);
          lines.enter().append("path").classed(cn.cbline, true);
          lines.exit().remove();
          lines.each(function(d) {
            var a = uPx;
            var b = Math.round(ax.c2p(d)) + line.width / 2 % 1;
            d3.select(this).attr(
              "d",
              "M" + (isVertical ? a + "," + b : b + "," + a) + (isVertical ? "h" : "v") + thickPx
            ).call(Drawing.lineGroupStyle, line.width, lineColormap(d), line.dash);
          });
          axLayer.selectAll("g." + ax._id + "tick,path").remove();
          var shift = uPx + thickPx + (outlinewidth || 0) / 2 - (opts.ticks === "outside" ? 1 : 0);
          var vals = Axes.calcTicks(ax);
          var tickSign = Axes.getTickSigns(ax)[2];
          Axes.drawTicks(gd, ax, {
            vals: ax.ticks === "inside" ? Axes.clipEnds(ax, vals) : vals,
            layer: axLayer,
            path: Axes.makeTickPath(ax, shift, tickSign),
            transFn: Axes.makeTransTickFn(ax)
          });
          return Axes.drawLabels(gd, ax, {
            vals,
            layer: axLayer,
            transFn: Axes.makeTransTickLabelFn(ax),
            labelFns: Axes.makeLabelFns(ax, shift)
          });
        }
        function positionCB() {
          var bb;
          var innerThickness = thickPx + outlinewidth / 2;
          if (ticklabelposition.indexOf("inside") === -1) {
            bb = Drawing.bBox(axLayer.node());
            innerThickness += isVertical ? bb.width : bb.height;
          }
          titleEl = titleCont.select("text");
          var titleWidth2 = 0;
          var topSideVertical = isVertical && titleSide === "top";
          var rightSideHorizontal = !isVertical && titleSide === "right";
          var moveY = 0;
          if (titleEl.node() && !titleEl.classed(cn.jsPlaceholder)) {
            var _titleHeight;
            var mathJaxNode = titleCont.select(".h" + ax._id + "title-math-group").node();
            if (mathJaxNode && (isVertical && topOrBottom || !isVertical && !topOrBottom)) {
              bb = Drawing.bBox(mathJaxNode);
              titleWidth2 = bb.width;
              _titleHeight = bb.height;
            } else {
              bb = Drawing.bBox(titleCont.node());
              titleWidth2 = bb.right - gs.l - (isVertical ? uPx : vPx);
              _titleHeight = bb.bottom - gs.t - (isVertical ? vPx : uPx);
              if (!isVertical && titleSide === "top") {
                innerThickness += bb.height;
                moveY = bb.height;
              }
            }
            if (rightSideHorizontal) {
              titleEl.attr("transform", strTranslate(titleWidth2 / 2 + titleFontSize / 2, 0));
              titleWidth2 *= 2;
            }
            innerThickness = Math.max(
              innerThickness,
              isVertical ? titleWidth2 : _titleHeight
            );
          }
          var outerThickness = (isVertical ? xpad : ypad) * 2 + innerThickness + borderwidth + outlinewidth / 2;
          var hColorbarMoveTitle = 0;
          if (!isVertical && title.text && yanchor === "bottom" && optsY <= 0) {
            hColorbarMoveTitle = outerThickness / 2;
            outerThickness += hColorbarMoveTitle;
            moveY += hColorbarMoveTitle;
          }
          fullLayout._hColorbarMoveTitle = hColorbarMoveTitle;
          fullLayout._hColorbarMoveCBTitle = moveY;
          var extraW = borderwidth + outlinewidth;
          var lx = (isVertical ? uPx : vPx) - extraW / 2 - (isVertical ? xpad : 0);
          var ly = (isVertical ? vPx : uPx) - (isVertical ? lenPx : ypad + moveY - hColorbarMoveTitle);
          g.select("." + cn.cbbg).attr("x", lx).attr("y", ly).attr(isVertical ? "width" : "height", Math.max(outerThickness - hColorbarMoveTitle, 2)).attr(isVertical ? "height" : "width", Math.max(lenPx + extraW, 2)).call(Color.fill, bgcolor).call(Color.stroke, opts.bordercolor).style("stroke-width", borderwidth);
          var moveX = rightSideHorizontal ? Math.max(titleWidth2 - 10, 0) : 0;
          g.selectAll("." + cn.cboutline).attr("x", (isVertical ? uPx : vPx + xpad) + moveX).attr("y", (isVertical ? vPx + ypad - lenPx : uPx) + (topSideVertical ? titleHeight : 0)).attr(isVertical ? "width" : "height", Math.max(thickPx, 2)).attr(isVertical ? "height" : "width", Math.max(lenPx - (isVertical ? 2 * ypad + titleHeight : 2 * xpad + moveX), 2)).call(Color.stroke, opts.outlinecolor).style({
            fill: "none",
            "stroke-width": outlinewidth
          });
          var xShift = isVertical ? xRatio * outerThickness : 0;
          var yShift = isVertical ? 0 : (1 - yRatio) * outerThickness - moveY;
          xShift = isPaperX ? gs.l - xShift : -xShift;
          yShift = isPaperY ? gs.t - yShift : -yShift;
          g.attr("transform", strTranslate(
            xShift,
            yShift
          ));
          if (!isVertical && (borderwidth || tinycolor(bgcolor).getAlpha() && !tinycolor.equals(fullLayout.paper_bgcolor, bgcolor))) {
            var tickLabels = axLayer.selectAll("text");
            var numTicks = tickLabels[0].length;
            var border = g.select("." + cn.cbbg).node();
            var oBb = Drawing.bBox(border);
            var oTr = Drawing.getTranslate(g);
            var TEXTPAD = 2;
            tickLabels.each(function(d, i) {
              var first = 0;
              var last = numTicks - 1;
              if (i === first || i === last) {
                var iBb = Drawing.bBox(this);
                var iTr = Drawing.getTranslate(this);
                var deltaX;
                if (i === last) {
                  var iRight = iBb.right + iTr.x;
                  var oRight = oBb.right + oTr.x + vPx - borderwidth - TEXTPAD + optsX;
                  deltaX = oRight - iRight;
                  if (deltaX > 0) deltaX = 0;
                } else if (i === first) {
                  var iLeft = iBb.left + iTr.x;
                  var oLeft = oBb.left + oTr.x + vPx + borderwidth + TEXTPAD;
                  deltaX = oLeft - iLeft;
                  if (deltaX < 0) deltaX = 0;
                }
                if (deltaX) {
                  if (numTicks < 3) {
                    this.setAttribute(
                      "transform",
                      "translate(" + deltaX + ",0) " + this.getAttribute("transform")
                    );
                  } else {
                    this.setAttribute("visibility", "hidden");
                  }
                }
              }
            });
          }
          var marginOpts = {};
          var lFrac = FROM_TL[xanchor];
          var rFrac = FROM_BR[xanchor];
          var tFrac = FROM_TL[yanchor];
          var bFrac = FROM_BR[yanchor];
          var extraThickness = outerThickness - thickPx;
          if (isVertical) {
            if (lenmode === "pixels") {
              marginOpts.y = optsY;
              marginOpts.t = lenPx * tFrac;
              marginOpts.b = lenPx * bFrac;
            } else {
              marginOpts.t = marginOpts.b = 0;
              marginOpts.yt = optsY + len * tFrac;
              marginOpts.yb = optsY - len * bFrac;
            }
            if (thicknessmode === "pixels") {
              marginOpts.x = optsX;
              marginOpts.l = outerThickness * lFrac;
              marginOpts.r = outerThickness * rFrac;
            } else {
              marginOpts.l = extraThickness * lFrac;
              marginOpts.r = extraThickness * rFrac;
              marginOpts.xl = optsX - thickness * lFrac;
              marginOpts.xr = optsX + thickness * rFrac;
            }
          } else {
            if (lenmode === "pixels") {
              marginOpts.x = optsX;
              marginOpts.l = lenPx * lFrac;
              marginOpts.r = lenPx * rFrac;
            } else {
              marginOpts.l = marginOpts.r = 0;
              marginOpts.xl = optsX + len * lFrac;
              marginOpts.xr = optsX - len * rFrac;
            }
            if (thicknessmode === "pixels") {
              marginOpts.y = 1 - optsY;
              marginOpts.t = outerThickness * tFrac;
              marginOpts.b = outerThickness * bFrac;
            } else {
              marginOpts.t = extraThickness * tFrac;
              marginOpts.b = extraThickness * bFrac;
              marginOpts.yt = optsY - thickness * tFrac;
              marginOpts.yb = optsY + thickness * bFrac;
            }
          }
          var sideY = opts.y < 0.5 ? "b" : "t";
          var sideX = opts.x < 0.5 ? "l" : "r";
          gd._fullLayout._reservedMargin[opts._id] = {};
          var possibleReservedMargins = {
            r: fullLayout.width - lx - xShift,
            l: lx + marginOpts.r,
            b: fullLayout.height - ly - yShift,
            t: ly + marginOpts.b
          };
          if (isPaperX && isPaperY) {
            Plots.autoMargin(gd, opts._id, marginOpts);
          } else if (isPaperX) {
            gd._fullLayout._reservedMargin[opts._id][sideY] = possibleReservedMargins[sideY];
          } else if (isPaperY) {
            gd._fullLayout._reservedMargin[opts._id][sideX] = possibleReservedMargins[sideX];
          } else {
            if (isVertical) {
              gd._fullLayout._reservedMargin[opts._id][sideX] = possibleReservedMargins[sideX];
            } else {
              gd._fullLayout._reservedMargin[opts._id][sideY] = possibleReservedMargins[sideY];
            }
          }
        }
        return Lib.syncOrAsync([
          Plots.previousPromises,
          drawDummyTitle,
          drawAxis,
          drawCbTitle,
          Plots.previousPromises,
          positionCB
        ], gd);
      }
      function makeEditable(g, opts, gd) {
        var isVertical = opts.orientation === "v";
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var t0, xf, yf;
        dragElement.init({
          element: g.node(),
          gd,
          prepFn: function() {
            t0 = g.attr("transform");
            setCursor(g);
          },
          moveFn: function(dx, dy) {
            g.attr("transform", t0 + strTranslate(dx, dy));
            xf = dragElement.align(
              (isVertical ? opts._uFrac : opts._vFrac) + dx / gs.w,
              isVertical ? opts._thickFrac : opts._lenFrac,
              0,
              1,
              opts.xanchor
            );
            yf = dragElement.align(
              (isVertical ? opts._vFrac : 1 - opts._uFrac) - dy / gs.h,
              isVertical ? opts._lenFrac : opts._thickFrac,
              0,
              1,
              opts.yanchor
            );
            var csr = dragElement.getCursor(xf, yf, opts.xanchor, opts.yanchor);
            setCursor(g, csr);
          },
          doneFn: function() {
            setCursor(g);
            if (xf !== void 0 && yf !== void 0) {
              var update = {};
              update[opts._propPrefix + "x"] = xf;
              update[opts._propPrefix + "y"] = yf;
              if (opts._traceIndex !== void 0) {
                Registry.call("_guiRestyle", gd, update, opts._traceIndex);
              } else {
                Registry.call("_guiRelayout", gd, update);
              }
            }
          }
        });
      }
      function calcLevels(gd, opts, zrange) {
        var levelsIn = opts._levels;
        var lineLevels = [];
        var fillLevels = [];
        var l;
        var i;
        var l0 = levelsIn.end + levelsIn.size / 100;
        var ls = levelsIn.size;
        var zr0 = 1.001 * zrange[0] - 1e-3 * zrange[1];
        var zr1 = 1.001 * zrange[1] - 1e-3 * zrange[0];
        for (i = 0; i < 1e5; i++) {
          l = levelsIn.start + i * ls;
          if (ls > 0 ? l >= l0 : l <= l0) break;
          if (l > zr0 && l < zr1) lineLevels.push(l);
        }
        if (opts._fillgradient) {
          fillLevels = [0];
        } else if (typeof opts._fillcolor === "function") {
          var fillLevelsIn = opts._filllevels;
          if (fillLevelsIn) {
            l0 = fillLevelsIn.end + fillLevelsIn.size / 100;
            ls = fillLevelsIn.size;
            for (i = 0; i < 1e5; i++) {
              l = fillLevelsIn.start + i * ls;
              if (ls > 0 ? l >= l0 : l <= l0) break;
              if (l > zrange[0] && l < zrange[1]) fillLevels.push(l);
            }
          } else {
            fillLevels = lineLevels.map(function(v) {
              return v - levelsIn.size / 2;
            });
            fillLevels.push(fillLevels[fillLevels.length - 1] + levelsIn.size);
          }
        } else if (opts._fillcolor && typeof opts._fillcolor === "string") {
          fillLevels = [0];
        }
        if (levelsIn.size < 0) {
          lineLevels.reverse();
          fillLevels.reverse();
        }
        return { line: lineLevels, fill: fillLevels };
      }
      function mockColorBarAxis(gd, opts, zrange) {
        var fullLayout = gd._fullLayout;
        var isVertical = opts.orientation === "v";
        var cbAxisIn = {
          type: "linear",
          range: zrange,
          tickmode: opts.tickmode,
          nticks: opts.nticks,
          tick0: opts.tick0,
          dtick: opts.dtick,
          tickvals: opts.tickvals,
          ticktext: opts.ticktext,
          ticks: opts.ticks,
          ticklen: opts.ticklen,
          tickwidth: opts.tickwidth,
          tickcolor: opts.tickcolor,
          showticklabels: opts.showticklabels,
          labelalias: opts.labelalias,
          ticklabelposition: opts.ticklabelposition,
          ticklabeloverflow: opts.ticklabeloverflow,
          ticklabelstep: opts.ticklabelstep,
          tickfont: opts.tickfont,
          tickangle: opts.tickangle,
          tickformat: opts.tickformat,
          exponentformat: opts.exponentformat,
          minexponent: opts.minexponent,
          separatethousands: opts.separatethousands,
          showexponent: opts.showexponent,
          showtickprefix: opts.showtickprefix,
          tickprefix: opts.tickprefix,
          showticksuffix: opts.showticksuffix,
          ticksuffix: opts.ticksuffix,
          title: opts.title,
          showline: true,
          anchor: "free",
          side: isVertical ? "right" : "bottom",
          position: 1
        };
        var letter = isVertical ? "y" : "x";
        var cbAxisOut = {
          type: "linear",
          _id: letter + opts._id
        };
        var axisOptions = {
          letter,
          font: fullLayout.font,
          noAutotickangles: letter === "y",
          noHover: true,
          noTickson: true,
          noTicklabelmode: true,
          noInsideRange: true,
          calendar: fullLayout.calendar
          // not really necessary (yet?)
        };
        function coerce(attr, dflt) {
          return Lib.coerce(cbAxisIn, cbAxisOut, axisLayoutAttrs, attr, dflt);
        }
        handleAxisDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions, fullLayout);
        handleAxisPositionDefaults(cbAxisIn, cbAxisOut, coerce, axisOptions);
        return cbAxisOut;
      }
      module.exports = {
        draw
      };
    }
  });

  // src/components/colorbar/index.js
  var require_colorbar = __commonJS({
    "src/components/colorbar/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "colorbar",
        attributes: require_attributes7(),
        supplyDefaults: require_defaults(),
        draw: require_draw11().draw,
        hasColorbar: require_has_colorbar()
      };
    }
  });

  // src/components/legend/index.js
  var require_legend = __commonJS({
    "src/components/legend/index.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "component",
        name: "legend",
        layoutAttributes: require_attributes9(),
        supplyLayoutDefaults: require_defaults3(),
        draw: require_draw(),
        style: require_style()
      };
    }
  });

  // src/locale-en.js
  var require_locale_en = __commonJS({
    "src/locale-en.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "locale",
        name: "en",
        dictionary: {
          "Click to enter Colorscale title": "Click to enter Colourscale title"
        },
        format: {
          days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
          shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          months: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ],
          shortMonths: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          periods: ["AM", "PM"],
          dateTime: "%a %b %e %X %Y",
          date: "%d/%m/%Y",
          time: "%H:%M:%S",
          decimal: ".",
          thousands: ",",
          grouping: [3],
          currency: ["$", ""],
          year: "%Y",
          month: "%b %Y",
          dayMonth: "%b %-d",
          dayMonthYear: "%b %-d, %Y"
        }
      };
    }
  });

  // src/locale-en-us.js
  var require_locale_en_us = __commonJS({
    "src/locale-en-us.js"(exports, module) {
      "use strict";
      module.exports = {
        moduleType: "locale",
        name: "en-US",
        dictionary: {
          "Click to enter Colorscale title": "Click to enter Colorscale title"
        },
        format: {
          date: "%m/%d/%Y"
        }
      };
    }
  });

  // src/snapshot/cloneplot.js
  var require_cloneplot = __commonJS({
    "src/snapshot/cloneplot.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var extendFlat = Lib.extendFlat;
      var extendDeep = Lib.extendDeep;
      function cloneLayoutOverride(tileClass) {
        var override;
        switch (tileClass) {
          case "themes__thumb":
            override = {
              autosize: true,
              width: 150,
              height: 150,
              title: { text: "" },
              showlegend: false,
              margin: { l: 5, r: 5, t: 5, b: 5, pad: 0 },
              annotations: []
            };
            break;
          case "thumbnail":
            override = {
              title: { text: "" },
              hidesources: true,
              showlegend: false,
              borderwidth: 0,
              bordercolor: "",
              margin: { l: 1, r: 1, t: 1, b: 1, pad: 0 },
              annotations: []
            };
            break;
          default:
            override = {};
        }
        return override;
      }
      function keyIsAxis(keyName) {
        var types = ["xaxis", "yaxis", "zaxis"];
        return types.indexOf(keyName.slice(0, 5)) > -1;
      }
      module.exports = function clonePlot(graphObj, options) {
        var i;
        var oldData = graphObj.data;
        var oldLayout = graphObj.layout;
        var newData = extendDeep([], oldData);
        var newLayout = extendDeep({}, oldLayout, cloneLayoutOverride(options.tileClass));
        var context = graphObj._context || {};
        if (options.width) newLayout.width = options.width;
        if (options.height) newLayout.height = options.height;
        if (options.tileClass === "thumbnail" || options.tileClass === "themes__thumb") {
          newLayout.annotations = [];
          var keys = Object.keys(newLayout);
          for (i = 0; i < keys.length; i++) {
            if (keyIsAxis(keys[i])) {
              newLayout[keys[i]].title = { text: "" };
            }
          }
          for (i = 0; i < newData.length; i++) {
            var trace = newData[i];
            trace.showscale = false;
            if (trace.marker) trace.marker.showscale = false;
            if (Registry.traceIs(trace, "pie-like")) trace.textposition = "none";
          }
        }
        if (Array.isArray(options.annotations)) {
          for (i = 0; i < options.annotations.length; i++) {
            newLayout.annotations.push(options.annotations[i]);
          }
        }
        var sceneIds = Object.keys(newLayout).filter(function(key) {
          return key.match(/^scene\d*$/);
        });
        if (sceneIds.length) {
          var axesImageOverride = {};
          if (options.tileClass === "thumbnail") {
            axesImageOverride = {
              title: { text: "" },
              showaxeslabels: false,
              showticklabels: false,
              linetickenable: false
            };
          }
          for (i = 0; i < sceneIds.length; i++) {
            var scene = newLayout[sceneIds[i]];
            if (!scene.xaxis) {
              scene.xaxis = {};
            }
            if (!scene.yaxis) {
              scene.yaxis = {};
            }
            if (!scene.zaxis) {
              scene.zaxis = {};
            }
            extendFlat(scene.xaxis, axesImageOverride);
            extendFlat(scene.yaxis, axesImageOverride);
            extendFlat(scene.zaxis, axesImageOverride);
            scene._scene = null;
          }
        }
        var gd = document.createElement("div");
        if (options.tileClass) gd.className = options.tileClass;
        var plotTile = {
          gd,
          td: gd,
          // for external (image server) compatibility
          layout: newLayout,
          data: newData,
          config: {
            staticPlot: options.staticPlot === void 0 ? true : options.staticPlot,
            plotGlPixelRatio: options.plotGlPixelRatio === void 0 ? 2 : options.plotGlPixelRatio,
            displaylogo: options.displaylogo || false,
            showLink: options.showLink || false,
            showTips: options.showTips || false,
            mapboxAccessToken: context.mapboxAccessToken
          }
        };
        if (options.setBackground !== "transparent") {
          plotTile.config.setBackground = options.setBackground || "opaque";
        }
        plotTile.gd.defaultLayout = cloneLayoutOverride(options.tileClass);
        return plotTile;
      };
    }
  });

  // src/snapshot/toimage.js
  var require_toimage = __commonJS({
    "src/snapshot/toimage.js"(exports, module) {
      "use strict";
      var EventEmitter = require_events().EventEmitter;
      var Registry = require_registry();
      var Lib = require_lib();
      var helpers = require_helpers10();
      var clonePlot = require_cloneplot();
      var toSVG = require_tosvg();
      var svgToImg = require_svgtoimg();
      function toImage(gd, opts) {
        var ev = new EventEmitter();
        var clone = clonePlot(gd, { format: "png" });
        var clonedGd = clone.gd;
        clonedGd.style.position = "absolute";
        clonedGd.style.left = "-5000px";
        document.body.appendChild(clonedGd);
        function wait() {
          var delay = helpers.getDelay(clonedGd._fullLayout);
          setTimeout(function() {
            var svg = toSVG(clonedGd);
            var canvas = document.createElement("canvas");
            canvas.id = Lib.randstr();
            ev = svgToImg({
              format: opts.format,
              width: clonedGd._fullLayout.width,
              height: clonedGd._fullLayout.height,
              canvas,
              emitter: ev,
              svg
            });
            ev.clean = function() {
              if (clonedGd) document.body.removeChild(clonedGd);
            };
          }, delay);
        }
        var redrawFunc = helpers.getRedrawFunc(clonedGd);
        Registry.call("_doPlot", clonedGd, clone.data, clone.layout, clone.config).then(redrawFunc).then(wait).catch(function(err) {
          ev.emit("error", err);
        });
        return ev;
      }
      module.exports = toImage;
    }
  });

  // src/snapshot/index.js
  var require_snapshot = __commonJS({
    "src/snapshot/index.js"(exports, module) {
      "use strict";
      var helpers = require_helpers10();
      var Snapshot = {
        getDelay: helpers.getDelay,
        getRedrawFunc: helpers.getRedrawFunc,
        clone: require_cloneplot(),
        toSVG: require_tosvg(),
        svgToImg: require_svgtoimg(),
        toImage: require_toimage(),
        downloadImage: require_download()
      };
      module.exports = Snapshot;
    }
  });

  // src/core.js
  var require_core = __commonJS({
    "src/core.js"(exports) {
      "use strict";
      exports.version = require_version().version;
      require_npo_src();
      require_plotcss();
      var Registry = require_registry();
      var register = exports.register = Registry.register;
      var plotApi = require_plot_api2();
      var methodNames = Object.keys(plotApi);
      for (i = 0; i < methodNames.length; i++) {
        name = methodNames[i];
        if (name.charAt(0) !== "_") exports[name] = plotApi[name];
        register({
          moduleType: "apiMethod",
          name,
          fn: plotApi[name]
        });
      }
      var name;
      var i;
      register(require_scatter());
      register([
        require_annotations(),
        require_annotations3d(),
        require_selections(),
        require_shapes(),
        require_images(),
        require_updatemenus(),
        require_sliders(),
        require_rangeslider(),
        require_rangeselector(),
        require_grid(),
        require_errorbars(),
        require_colorscale(),
        require_colorbar(),
        require_legend(),
        // legend needs to come after shape | legend defaults depends on shapes
        require_fx(),
        // fx needs to come after legend | unified hover defaults depends on legends
        require_modebar2()
      ]);
      register([
        require_locale_en(),
        require_locale_en_us()
      ]);
      if (window.PlotlyLocales && Array.isArray(window.PlotlyLocales)) {
        register(window.PlotlyLocales);
        delete window.PlotlyLocales;
      }
      exports.Icons = require_ploticon();
      var Fx = require_fx();
      var Plots = require_plots();
      exports.Plots = {
        resize: Plots.resize,
        graphJson: Plots.graphJson,
        sendDataToCloud: Plots.sendDataToCloud
      };
      exports.Fx = {
        hover: Fx.hover,
        unhover: Fx.unhover,
        loneHover: Fx.loneHover,
        loneUnhover: Fx.loneUnhover
      };
      exports.Snapshot = require_snapshot();
      exports.PlotSchema = require_plot_schema();
    }
  });

  // lib/core.js
  var require_core2 = __commonJS({
    "lib/core.js"(exports, module) {
      "use strict";
      module.exports = require_core();
    }
  });

  // src/traces/scattergl/hover.js
  var require_hover3 = __commonJS({
    "src/traces/scattergl/hover.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Lib = require_lib();
      var getTraceColor = require_get_trace_color();
      function hoverPoints(pointData, xval, yval, hovermode) {
        var cd = pointData.cd;
        var stash = cd[0].t;
        var trace = cd[0].trace;
        var xa = pointData.xa;
        var ya = pointData.ya;
        var x = stash.x;
        var y = stash.y;
        var xpx = xa.c2p(xval);
        var ypx = ya.c2p(yval);
        var maxDistance = pointData.distance;
        var ids;
        if (stash.tree) {
          var xl = xa.p2c(xpx - maxDistance);
          var xr = xa.p2c(xpx + maxDistance);
          var yl = ya.p2c(ypx - maxDistance);
          var yr = ya.p2c(ypx + maxDistance);
          if (hovermode === "x") {
            ids = stash.tree.range(
              Math.min(xl, xr),
              Math.min(ya._rl[0], ya._rl[1]),
              Math.max(xl, xr),
              Math.max(ya._rl[0], ya._rl[1])
            );
          } else {
            ids = stash.tree.range(
              Math.min(xl, xr),
              Math.min(yl, yr),
              Math.max(xl, xr),
              Math.max(yl, yr)
            );
          }
        } else {
          ids = stash.ids;
        }
        var k, closestId, ptx, pty, i, dx, dy, dist, dxy;
        var minDist = maxDistance;
        if (hovermode === "x") {
          var xPeriod = !!trace.xperiodalignment;
          var yPeriod = !!trace.yperiodalignment;
          for (i = 0; i < ids.length; i++) {
            k = ids[i];
            ptx = x[k];
            dx = Math.abs(xa.c2p(ptx) - xpx);
            if (xPeriod) {
              var x0 = xa.c2p(trace._xStarts[k]);
              var x1 = xa.c2p(trace._xEnds[k]);
              dx = xpx >= Math.min(x0, x1) && xpx <= Math.max(x0, x1) ? 0 : Infinity;
            }
            if (dx < minDist) {
              minDist = dx;
              pty = y[k];
              dy = ya.c2p(pty) - ypx;
              if (yPeriod) {
                var y0 = ya.c2p(trace._yStarts[k]);
                var y1 = ya.c2p(trace._yEnds[k]);
                dy = ypx >= Math.min(y0, y1) && ypx <= Math.max(y0, y1) ? 0 : Infinity;
              }
              dxy = Math.sqrt(dx * dx + dy * dy);
              closestId = ids[i];
            }
          }
        } else {
          for (i = ids.length - 1; i > -1; i--) {
            k = ids[i];
            ptx = x[k];
            pty = y[k];
            dx = xa.c2p(ptx) - xpx;
            dy = ya.c2p(pty) - ypx;
            dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDist) {
              minDist = dxy = dist;
              closestId = k;
            }
          }
        }
        pointData.index = closestId;
        pointData.distance = minDist;
        pointData.dxy = dxy;
        if (closestId === void 0) return [pointData];
        return [calcHover(pointData, x, y, trace)];
      }
      function calcHover(pointData, x, y, trace) {
        var xa = pointData.xa;
        var ya = pointData.ya;
        var minDist = pointData.distance;
        var dxy = pointData.dxy;
        var id = pointData.index;
        var di = {
          pointNumber: id,
          x: x[id],
          y: y[id]
        };
        di.tx = Lib.isArrayOrTypedArray(trace.text) ? trace.text[id] : trace.text;
        di.htx = Array.isArray(trace.hovertext) ? trace.hovertext[id] : trace.hovertext;
        di.data = Array.isArray(trace.customdata) ? trace.customdata[id] : trace.customdata;
        di.tp = Array.isArray(trace.textposition) ? trace.textposition[id] : trace.textposition;
        var font = trace.textfont;
        if (font) {
          di.ts = Lib.isArrayOrTypedArray(font.size) ? font.size[id] : font.size;
          di.tc = Lib.isArrayOrTypedArray(font.color) ? font.color[id] : font.color;
          di.tf = Array.isArray(font.family) ? font.family[id] : font.family;
          di.tw = Array.isArray(font.weight) ? font.weight[id] : font.weight;
          di.ty = Array.isArray(font.style) ? font.style[id] : font.style;
          di.tv = Array.isArray(font.variant) ? font.variant[id] : font.variant;
        }
        var marker = trace.marker;
        if (marker) {
          di.ms = Lib.isArrayOrTypedArray(marker.size) ? marker.size[id] : marker.size;
          di.mo = Lib.isArrayOrTypedArray(marker.opacity) ? marker.opacity[id] : marker.opacity;
          di.mx = Lib.isArrayOrTypedArray(marker.symbol) ? marker.symbol[id] : marker.symbol;
          di.ma = Lib.isArrayOrTypedArray(marker.angle) ? marker.angle[id] : marker.angle;
          di.mc = Lib.isArrayOrTypedArray(marker.color) ? marker.color[id] : marker.color;
        }
        var line = marker && marker.line;
        if (line) {
          di.mlc = Array.isArray(line.color) ? line.color[id] : line.color;
          di.mlw = Lib.isArrayOrTypedArray(line.width) ? line.width[id] : line.width;
        }
        var grad = marker && marker.gradient;
        if (grad && grad.type !== "none") {
          di.mgt = Array.isArray(grad.type) ? grad.type[id] : grad.type;
          di.mgc = Array.isArray(grad.color) ? grad.color[id] : grad.color;
        }
        var xp = xa.c2p(di.x, true);
        var yp = ya.c2p(di.y, true);
        var rad = di.mrc || 1;
        var hoverlabel = trace.hoverlabel;
        if (hoverlabel) {
          di.hbg = Array.isArray(hoverlabel.bgcolor) ? hoverlabel.bgcolor[id] : hoverlabel.bgcolor;
          di.hbc = Array.isArray(hoverlabel.bordercolor) ? hoverlabel.bordercolor[id] : hoverlabel.bordercolor;
          di.hts = Lib.isArrayOrTypedArray(hoverlabel.font.size) ? hoverlabel.font.size[id] : hoverlabel.font.size;
          di.htc = Array.isArray(hoverlabel.font.color) ? hoverlabel.font.color[id] : hoverlabel.font.color;
          di.htf = Array.isArray(hoverlabel.font.family) ? hoverlabel.font.family[id] : hoverlabel.font.family;
          di.hnl = Lib.isArrayOrTypedArray(hoverlabel.namelength) ? hoverlabel.namelength[id] : hoverlabel.namelength;
        }
        var hoverinfo = trace.hoverinfo;
        if (hoverinfo) {
          di.hi = Array.isArray(hoverinfo) ? hoverinfo[id] : hoverinfo;
        }
        var hovertemplate = trace.hovertemplate;
        if (hovertemplate) {
          di.ht = Array.isArray(hovertemplate) ? hovertemplate[id] : hovertemplate;
        }
        var fakeCd = {};
        fakeCd[pointData.index] = di;
        var origX = trace._origX;
        var origY = trace._origY;
        var pointData2 = Lib.extendFlat({}, pointData, {
          color: getTraceColor(trace, di),
          x0: xp - rad,
          x1: xp + rad,
          xLabelVal: origX ? origX[id] : di.x,
          y0: yp - rad,
          y1: yp + rad,
          yLabelVal: origY ? origY[id] : di.y,
          cd: fakeCd,
          distance: minDist,
          spikeDistance: dxy,
          hovertemplate: di.ht
        });
        if (di.htx) pointData2.text = di.htx;
        else if (di.tx) pointData2.text = di.tx;
        else if (trace.text) pointData2.text = trace.text;
        Lib.fillText(di, trace, pointData2);
        Registry.getComponentMethod("errorbars", "hoverInfo")(di, trace, pointData2);
        return pointData2;
      }
      module.exports = {
        hoverPoints,
        calcHover
      };
    }
  });

  // src/traces/scattergl/constants.js
  var require_constants14 = __commonJS({
    "src/traces/scattergl/constants.js"(exports, module) {
      "use strict";
      var SYMBOL_SIZE = 20;
      module.exports = {
        TOO_MANY_POINTS: 1e5,
        SYMBOL_SDF_SIZE: 200,
        SYMBOL_SIZE,
        SYMBOL_STROKE: SYMBOL_SIZE / 20,
        DOT_RE: /-dot/,
        OPEN_RE: /-open/,
        DASHES: {
          solid: [1],
          dot: [1, 1],
          dash: [4, 1],
          longdash: [8, 1],
          dashdot: [4, 1, 1, 1],
          longdashdot: [8, 1, 1, 1]
        }
      };
    }
  });

  // src/traces/scattergl/attributes.js
  var require_attributes23 = __commonJS({
    "src/traces/scattergl/attributes.js"(exports, module) {
      "use strict";
      var baseAttrs = require_attributes2();
      var fontAttrs = require_font_attributes();
      var makeFillcolorAttr = require_fillcolor_attribute();
      var scatterAttrs = require_attributes12();
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var colorScaleAttrs = require_attributes8();
      var sortObjectKeys = require_sort_object_keys();
      var extendFlat = require_extend().extendFlat;
      var overrideAll = require_edit_types().overrideAll;
      var DASHES = require_constants14().DASHES;
      var scatterLineAttrs = scatterAttrs.line;
      var scatterMarkerAttrs = scatterAttrs.marker;
      var scatterMarkerLineAttrs = scatterMarkerAttrs.line;
      var attrs = module.exports = overrideAll({
        x: scatterAttrs.x,
        x0: scatterAttrs.x0,
        dx: scatterAttrs.dx,
        y: scatterAttrs.y,
        y0: scatterAttrs.y0,
        dy: scatterAttrs.dy,
        xperiod: scatterAttrs.xperiod,
        yperiod: scatterAttrs.yperiod,
        xperiod0: scatterAttrs.xperiod0,
        yperiod0: scatterAttrs.yperiod0,
        xperiodalignment: scatterAttrs.xperiodalignment,
        yperiodalignment: scatterAttrs.yperiodalignment,
        xhoverformat: axisHoverFormat("x"),
        yhoverformat: axisHoverFormat("y"),
        text: scatterAttrs.text,
        hovertext: scatterAttrs.hovertext,
        textposition: scatterAttrs.textposition,
        textfont: fontAttrs({
          noFontShadow: true,
          noFontLineposition: true,
          noFontTextcase: true,
          editType: "calc",
          colorEditType: "style",
          arrayOk: true,
          noNumericWeightValues: true,
          variantValues: ["normal", "small-caps"]
        }),
        mode: {
          valType: "flaglist",
          flags: ["lines", "markers", "text"],
          extras: ["none"]
        },
        line: {
          color: scatterLineAttrs.color,
          width: scatterLineAttrs.width,
          shape: {
            valType: "enumerated",
            values: ["linear", "hv", "vh", "hvh", "vhv"],
            dflt: "linear",
            editType: "plot"
          },
          dash: {
            valType: "enumerated",
            values: sortObjectKeys(DASHES),
            dflt: "solid"
          }
        },
        marker: extendFlat({}, colorScaleAttrs("marker"), {
          symbol: scatterMarkerAttrs.symbol,
          angle: scatterMarkerAttrs.angle,
          size: scatterMarkerAttrs.size,
          sizeref: scatterMarkerAttrs.sizeref,
          sizemin: scatterMarkerAttrs.sizemin,
          sizemode: scatterMarkerAttrs.sizemode,
          opacity: scatterMarkerAttrs.opacity,
          colorbar: scatterMarkerAttrs.colorbar,
          line: extendFlat({}, colorScaleAttrs("marker.line"), {
            width: scatterMarkerLineAttrs.width
          })
        }),
        connectgaps: scatterAttrs.connectgaps,
        fill: extendFlat({}, scatterAttrs.fill, { dflt: "none" }),
        fillcolor: makeFillcolorAttr(),
        // no hoveron
        selected: {
          marker: scatterAttrs.selected.marker,
          textfont: scatterAttrs.selected.textfont
        },
        unselected: {
          marker: scatterAttrs.unselected.marker,
          textfont: scatterAttrs.unselected.textfont
        },
        opacity: baseAttrs.opacity
      }, "calc", "nested");
      attrs.x.editType = attrs.y.editType = attrs.x0.editType = attrs.y0.editType = "calc+clearAxisTypes";
      attrs.hovertemplate = scatterAttrs.hovertemplate;
      attrs.texttemplate = scatterAttrs.texttemplate;
    }
  });

  // src/traces/scattergl/helpers.js
  var require_helpers12 = __commonJS({
    "src/traces/scattergl/helpers.js"(exports) {
      "use strict";
      var constants = require_constants14();
      exports.isOpenSymbol = function(symbol) {
        return typeof symbol === "string" ? constants.OPEN_RE.test(symbol) : symbol % 200 > 100;
      };
      exports.isDotSymbol = function(symbol) {
        return typeof symbol === "string" ? constants.DOT_RE.test(symbol) : symbol > 200;
      };
    }
  });

  // src/traces/scattergl/defaults.js
  var require_defaults19 = __commonJS({
    "src/traces/scattergl/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Registry = require_registry();
      var helpers = require_helpers12();
      var attributes = require_attributes23();
      var constants = require_constants8();
      var subTypes = require_subtypes();
      var handleXYDefaults = require_xy_defaults();
      var handlePeriodDefaults = require_period_defaults();
      var handleMarkerDefaults = require_marker_defaults();
      var handleLineDefaults = require_line_defaults();
      var handleFillColorDefaults = require_fillcolor_defaults();
      var handleTextDefaults = require_text_defaults();
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var isOpen = traceIn.marker ? helpers.isOpenSymbol(traceIn.marker.symbol) : false;
        var isBubble = subTypes.isBubble(traceIn);
        var len = handleXYDefaults(traceIn, traceOut, layout, coerce);
        if (!len) {
          traceOut.visible = false;
          return;
        }
        handlePeriodDefaults(traceIn, traceOut, layout, coerce);
        coerce("xhoverformat");
        coerce("yhoverformat");
        var defaultMode = len < constants.PTS_LINESONLY ? "lines+markers" : "lines";
        coerce("text");
        coerce("hovertext");
        coerce("hovertemplate");
        coerce("mode", defaultMode);
        if (subTypes.hasMarkers(traceOut)) {
          handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce, { noAngleRef: true, noStandOff: true });
          coerce("marker.line.width", isOpen || isBubble ? 1 : 0);
        }
        if (subTypes.hasLines(traceOut)) {
          coerce("connectgaps");
          handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce);
          coerce("line.shape");
        }
        if (subTypes.hasText(traceOut)) {
          coerce("texttemplate");
          handleTextDefaults(traceIn, traceOut, layout, coerce, {
            noFontShadow: true,
            noFontLineposition: true,
            noFontTextcase: true
          });
        }
        var lineColor = (traceOut.line || {}).color;
        var markerColor = (traceOut.marker || {}).color;
        coerce("fill");
        if (traceOut.fill !== "none") {
          handleFillColorDefaults(traceIn, traceOut, defaultColor, coerce);
        }
        var errorBarsSupplyDefaults = Registry.getComponentMethod("errorbars", "supplyDefaults");
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, { axis: "y" });
        errorBarsSupplyDefaults(traceIn, traceOut, lineColor || markerColor || defaultColor, { axis: "x", inherit: "y" });
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
      };
    }
  });

  // src/traces/scattergl/format_labels.js
  var require_format_labels2 = __commonJS({
    "src/traces/scattergl/format_labels.js"(exports, module) {
      "use strict";
      var scatterFormatLabels = require_format_labels();
      module.exports = function formatLabels(cdi, trace, fullLayout) {
        var i = cdi.i;
        if (!("x" in cdi)) cdi.x = trace._x[i];
        if (!("y" in cdi)) cdi.y = trace._y[i];
        return scatterFormatLabels(cdi, trace, fullLayout);
      };
    }
  });

  // node_modules/binary-search-bounds/search-bounds.js
  var require_search_bounds = __commonJS({
    "node_modules/binary-search-bounds/search-bounds.js"(exports, module) {
      "use strict";
      function ge(a, y, c, l, h) {
        var i = h + 1;
        while (l <= h) {
          var m = l + h >>> 1, x = a[m];
          var p = c !== void 0 ? c(x, y) : x - y;
          if (p >= 0) {
            i = m;
            h = m - 1;
          } else {
            l = m + 1;
          }
        }
        return i;
      }
      function gt(a, y, c, l, h) {
        var i = h + 1;
        while (l <= h) {
          var m = l + h >>> 1, x = a[m];
          var p = c !== void 0 ? c(x, y) : x - y;
          if (p > 0) {
            i = m;
            h = m - 1;
          } else {
            l = m + 1;
          }
        }
        return i;
      }
      function lt(a, y, c, l, h) {
        var i = l - 1;
        while (l <= h) {
          var m = l + h >>> 1, x = a[m];
          var p = c !== void 0 ? c(x, y) : x - y;
          if (p < 0) {
            i = m;
            l = m + 1;
          } else {
            h = m - 1;
          }
        }
        return i;
      }
      function le(a, y, c, l, h) {
        var i = l - 1;
        while (l <= h) {
          var m = l + h >>> 1, x = a[m];
          var p = c !== void 0 ? c(x, y) : x - y;
          if (p <= 0) {
            i = m;
            l = m + 1;
          } else {
            h = m - 1;
          }
        }
        return i;
      }
      function eq(a, y, c, l, h) {
        while (l <= h) {
          var m = l + h >>> 1, x = a[m];
          var p = c !== void 0 ? c(x, y) : x - y;
          if (p === 0) {
            return m;
          }
          if (p <= 0) {
            l = m + 1;
          } else {
            h = m - 1;
          }
        }
        return -1;
      }
      function norm(a, y, c, l, h, f) {
        if (typeof c === "function") {
          return f(a, y, c, l === void 0 ? 0 : l | 0, h === void 0 ? a.length - 1 : h | 0);
        }
        return f(a, y, void 0, c === void 0 ? 0 : c | 0, l === void 0 ? a.length - 1 : l | 0);
      }
      module.exports = {
        ge: function(a, y, c, l, h) {
          return norm(a, y, c, l, h, ge);
        },
        gt: function(a, y, c, l, h) {
          return norm(a, y, c, l, h, gt);
        },
        lt: function(a, y, c, l, h) {
          return norm(a, y, c, l, h, lt);
        },
        le: function(a, y, c, l, h) {
          return norm(a, y, c, l, h, le);
        },
        eq: function(a, y, c, l, h) {
          return norm(a, y, c, l, h, eq);
        }
      };
    }
  });

  // node_modules/clamp/index.js
  var require_clamp = __commonJS({
    "node_modules/clamp/index.js"(exports, module) {
      module.exports = clamp;
      function clamp(value, min, max) {
        return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
      }
    }
  });

  // node_modules/pick-by-alias/index.js
  var require_pick_by_alias = __commonJS({
    "node_modules/pick-by-alias/index.js"(exports, module) {
      "use strict";
      module.exports = function pick(src, props, keepRest) {
        var result = {}, prop, i;
        if (typeof props === "string") props = toList(props);
        if (Array.isArray(props)) {
          var res = {};
          for (i = 0; i < props.length; i++) {
            res[props[i]] = true;
          }
          props = res;
        }
        for (prop in props) {
          props[prop] = toList(props[prop]);
        }
        var occupied = {};
        for (prop in props) {
          var aliases = props[prop];
          if (Array.isArray(aliases)) {
            for (i = 0; i < aliases.length; i++) {
              var alias = aliases[i];
              if (keepRest) {
                occupied[alias] = true;
              }
              if (alias in src) {
                result[prop] = src[alias];
                if (keepRest) {
                  for (var j = i; j < aliases.length; j++) {
                    occupied[aliases[j]] = true;
                  }
                }
                break;
              }
            }
          } else if (prop in src) {
            if (props[prop]) {
              result[prop] = src[prop];
            }
            if (keepRest) {
              occupied[prop] = true;
            }
          }
        }
        if (keepRest) {
          for (prop in src) {
            if (occupied[prop]) continue;
            result[prop] = src[prop];
          }
        }
        return result;
      };
      var CACHE = {};
      function toList(arg) {
        if (CACHE[arg]) return CACHE[arg];
        if (typeof arg === "string") {
          arg = CACHE[arg] = arg.split(/\s*,\s*|\s+/);
        }
        return arg;
      }
    }
  });

  // node_modules/parse-rect/index.js
  var require_parse_rect = __commonJS({
    "node_modules/parse-rect/index.js"(exports, module) {
      "use strict";
      var pick = require_pick_by_alias();
      module.exports = parseRect;
      function parseRect(arg) {
        var rect;
        if (arguments.length > 1) {
          arg = arguments;
        }
        if (typeof arg === "string") {
          arg = arg.split(/\s/).map(parseFloat);
        } else if (typeof arg === "number") {
          arg = [arg];
        }
        if (arg.length && typeof arg[0] === "number") {
          if (arg.length === 1) {
            rect = {
              width: arg[0],
              height: arg[0],
              x: 0,
              y: 0
            };
          } else if (arg.length === 2) {
            rect = {
              width: arg[0],
              height: arg[1],
              x: 0,
              y: 0
            };
          } else {
            rect = {
              x: arg[0],
              y: arg[1],
              width: arg[2] - arg[0] || 0,
              height: arg[3] - arg[1] || 0
            };
          }
        } else if (arg) {
          arg = pick(arg, {
            left: "x l left Left",
            top: "y t top Top",
            width: "w width W Width",
            height: "h height W Width",
            bottom: "b bottom Bottom",
            right: "r right Right"
          });
          rect = {
            x: arg.left || 0,
            y: arg.top || 0
          };
          if (arg.width == null) {
            if (arg.right) rect.width = arg.right - rect.x;
            else rect.width = 0;
          } else {
            rect.width = arg.width;
          }
          if (arg.height == null) {
            if (arg.bottom) rect.height = arg.bottom - rect.y;
            else rect.height = 0;
          } else {
            rect.height = arg.height;
          }
        }
        return rect;
      }
    }
  });

  // node_modules/array-bounds/index.js
  var require_array_bounds = __commonJS({
    "node_modules/array-bounds/index.js"(exports, module) {
      "use strict";
      module.exports = normalize;
      function normalize(arr, dim) {
        if (!arr || arr.length == null) throw Error("Argument should be an array");
        if (dim == null) dim = 1;
        else dim = Math.floor(dim);
        var bounds = Array(dim * 2);
        for (var offset = 0; offset < dim; offset++) {
          var max = -Infinity, min = Infinity, i = offset, l = arr.length;
          for (; i < l; i += dim) {
            if (arr[i] > max) max = arr[i];
            if (arr[i] < min) min = arr[i];
          }
          bounds[offset] = min;
          bounds[dim + offset] = max;
        }
        return bounds;
      }
    }
  });

  // node_modules/defined/index.js
  var require_defined = __commonJS({
    "node_modules/defined/index.js"(exports, module) {
      module.exports = function() {
        for (var i = 0; i < arguments.length; i++) {
          if (arguments[i] !== void 0) return arguments[i];
        }
      };
    }
  });

  // node_modules/dtype/index.js
  var require_dtype = __commonJS({
    "node_modules/dtype/index.js"(exports, module) {
      module.exports = function(dtype) {
        switch (dtype) {
          case "int8":
            return Int8Array;
          case "int16":
            return Int16Array;
          case "int32":
            return Int32Array;
          case "uint8":
            return Uint8Array;
          case "uint16":
            return Uint16Array;
          case "uint32":
            return Uint32Array;
          case "float32":
            return Float32Array;
          case "float64":
            return Float64Array;
          case "array":
            return Array;
          case "uint8_clamped":
            return Uint8ClampedArray;
        }
      };
    }
  });

  // node_modules/flatten-vertex-data/index.js
  var require_flatten_vertex_data = __commonJS({
    "node_modules/flatten-vertex-data/index.js"(exports, module) {
      var dtype = require_dtype();
      module.exports = flattenVertexData;
      function flattenVertexData(data, output, offset) {
        if (!data) throw new TypeError("must specify data as first parameter");
        offset = +(offset || 0) | 0;
        if (Array.isArray(data) && (data[0] && typeof data[0][0] === "number")) {
          var dim = data[0].length;
          var length = data.length * dim;
          var i, j, k, l;
          if (!output || typeof output === "string") {
            output = new (dtype(output || "float32"))(length + offset);
          }
          var dstLength = output.length - offset;
          if (length !== dstLength) {
            throw new Error("source length " + length + " (" + dim + "x" + data.length + ") does not match destination length " + dstLength);
          }
          for (i = 0, k = offset; i < data.length; i++) {
            for (j = 0; j < dim; j++) {
              output[k++] = data[i][j] === null ? NaN : data[i][j];
            }
          }
        } else {
          if (!output || typeof output === "string") {
            var Ctor = dtype(output || "float32");
            if (Array.isArray(data) || output === "array") {
              output = new Ctor(data.length + offset);
              for (i = 0, k = offset, l = output.length; k < l; k++, i++) {
                output[k] = data[i] === null ? NaN : data[i];
              }
            } else {
              if (offset === 0) {
                output = new Ctor(data);
              } else {
                output = new Ctor(data.length + offset);
                output.set(data, offset);
              }
            }
          } else {
            output.set(data, offset);
          }
        }
        return output;
      }
    }
  });

  // node_modules/is-obj/index.js
  var require_is_obj = __commonJS({
    "node_modules/is-obj/index.js"(exports, module) {
      "use strict";
      module.exports = function(x) {
        var type = typeof x;
        return x !== null && (type === "object" || type === "function");
      };
    }
  });

  // node_modules/math-log2/index.js
  var require_math_log2 = __commonJS({
    "node_modules/math-log2/index.js"(exports, module) {
      "use strict";
      module.exports = Math.log2 || function(x) {
        return Math.log(x) * Math.LOG2E;
      };
    }
  });

  // node_modules/@plotly/point-cluster/quad.js
  var require_quad = __commonJS({
    "node_modules/@plotly/point-cluster/quad.js"(exports, module) {
      "use strict";
      var search = require_search_bounds();
      var clamp = require_clamp();
      var rect = require_parse_rect();
      var getBounds = require_array_bounds();
      var pick = require_pick_by_alias();
      var defined = require_defined();
      var flatten = require_flatten_vertex_data();
      var isObj = require_is_obj();
      var dtype = require_dtype();
      var log2 = require_math_log2();
      var MAX_GROUP_ID = 1073741824;
      module.exports = function cluster(srcPoints, options) {
        if (!options) options = {};
        srcPoints = flatten(srcPoints, "float64");
        options = pick(options, {
          bounds: "range bounds dataBox databox",
          maxDepth: "depth maxDepth maxdepth level maxLevel maxlevel levels",
          dtype: "type dtype format out dst output destination"
          // sort: 'sortBy sortby sort',
          // pick: 'pick levelPoint',
          // nodeSize: 'node nodeSize minNodeSize minSize size'
        });
        let maxDepth = defined(options.maxDepth, 255);
        let bounds = defined(options.bounds, getBounds(srcPoints, 2));
        if (bounds[0] === bounds[2]) bounds[2]++;
        if (bounds[1] === bounds[3]) bounds[3]++;
        let points = normalize(srcPoints, bounds);
        let n = srcPoints.length >>> 1;
        let ids;
        if (!options.dtype) options.dtype = "array";
        if (typeof options.dtype === "string") {
          ids = new (dtype(options.dtype))(n);
        } else if (options.dtype) {
          ids = options.dtype;
          if (Array.isArray(ids)) ids.length = n;
        }
        for (let i = 0; i < n; ++i) {
          ids[i] = i;
        }
        let levels = [];
        let sublevels = [];
        let groups = [];
        let offsets = [];
        sort(0, 0, 1, ids, 0, 1);
        let offset = 0;
        for (let level = 0; level < levels.length; level++) {
          let levelItems = levels[level];
          if (ids.set) ids.set(levelItems, offset);
          else {
            for (let i = 0, l = levelItems.length; i < l; i++) {
              ids[i + offset] = levelItems[i];
            }
          }
          let nextOffset = offset + levels[level].length;
          offsets[level] = [offset, nextOffset];
          offset = nextOffset;
        }
        ids.range = range;
        return ids;
        function sort(x, y, diam, ids2, level, group2) {
          if (!ids2.length) return null;
          let levelItems = levels[level] || (levels[level] = []);
          let levelGroups = groups[level] || (groups[level] = []);
          let sublevel = sublevels[level] || (sublevels[level] = []);
          let offset2 = levelItems.length;
          level++;
          if (level > maxDepth || group2 > MAX_GROUP_ID) {
            for (let i = 0; i < ids2.length; i++) {
              levelItems.push(ids2[i]);
              levelGroups.push(group2);
              sublevel.push(null, null, null, null);
            }
            return offset2;
          }
          levelItems.push(ids2[0]);
          levelGroups.push(group2);
          if (ids2.length <= 1) {
            sublevel.push(null, null, null, null);
            return offset2;
          }
          let d2 = diam * 0.5;
          let cx = x + d2, cy = y + d2;
          let lolo = [], lohi = [], hilo = [], hihi = [];
          for (let i = 1, l = ids2.length; i < l; i++) {
            let idx = ids2[i], x2 = points[idx * 2], y2 = points[idx * 2 + 1];
            x2 < cx ? y2 < cy ? lolo.push(idx) : lohi.push(idx) : y2 < cy ? hilo.push(idx) : hihi.push(idx);
          }
          group2 <<= 2;
          sublevel.push(
            sort(x, y, d2, lolo, level, group2),
            sort(x, cy, d2, lohi, level, group2 + 1),
            sort(cx, y, d2, hilo, level, group2 + 2),
            sort(cx, cy, d2, hihi, level, group2 + 3)
          );
          return offset2;
        }
        function range(...args) {
          let options2;
          if (isObj(args[args.length - 1])) {
            let arg = args.pop();
            if (!args.length && (arg.x != null || arg.l != null || arg.left != null)) {
              args = [arg];
              options2 = {};
            }
            options2 = pick(arg, {
              level: "level maxLevel",
              d: "d diam diameter r radius px pxSize pixel pixelSize maxD size minSize",
              lod: "lod details ranges offsets"
            });
          } else {
            options2 = {};
          }
          if (!args.length) args = bounds;
          let box = rect(...args);
          let [minX, minY, maxX, maxY] = [
            Math.min(box.x, box.x + box.width),
            Math.min(box.y, box.y + box.height),
            Math.max(box.x, box.x + box.width),
            Math.max(box.y, box.y + box.height)
          ];
          let [nminX, nminY, nmaxX, nmaxY] = normalize([minX, minY, maxX, maxY], bounds);
          let maxLevel = defined(options2.level, levels.length);
          if (options2.d != null) {
            let d;
            if (typeof options2.d === "number") d = [options2.d, options2.d];
            else if (options2.d.length) d = options2.d;
            maxLevel = Math.min(
              Math.max(
                Math.ceil(-log2(Math.abs(d[0]) / (bounds[2] - bounds[0]))),
                Math.ceil(-log2(Math.abs(d[1]) / (bounds[3] - bounds[1])))
              ),
              maxLevel
            );
          }
          maxLevel = Math.min(maxLevel, levels.length);
          if (options2.lod) {
            return lod(nminX, nminY, nmaxX, nmaxY, maxLevel);
          }
          let selection = [];
          select(0, 0, 1, 0, 0, 1);
          function select(lox, loy, d, level, from, to) {
            if (from === null || to === null) return;
            let hix = lox + d;
            let hiy = loy + d;
            if (nminX > hix || nminY > hiy || nmaxX < lox || nmaxY < loy) return;
            if (level >= maxLevel) return;
            if (from === to) return;
            let levelItems = levels[level];
            if (to === void 0) to = levelItems.length;
            for (let i = from; i < to; i++) {
              let id = levelItems[i];
              let px = srcPoints[id * 2];
              let py = srcPoints[id * 2 + 1];
              if (px >= minX && px <= maxX && py >= minY && py <= maxY) {
                selection.push(id);
              }
            }
            let offsets2 = sublevels[level];
            let off0 = offsets2[from * 4 + 0];
            let off1 = offsets2[from * 4 + 1];
            let off2 = offsets2[from * 4 + 2];
            let off3 = offsets2[from * 4 + 3];
            let end = nextOffset(offsets2, from + 1);
            let d2 = d * 0.5;
            let nextLevel = level + 1;
            select(lox, loy, d2, nextLevel, off0, off1 || off2 || off3 || end);
            select(lox, loy + d2, d2, nextLevel, off1, off2 || off3 || end);
            select(lox + d2, loy, d2, nextLevel, off2, off3 || end);
            select(lox + d2, loy + d2, d2, nextLevel, off3, end);
          }
          function nextOffset(offsets2, from) {
            let offset2 = null, i = 0;
            while (offset2 === null) {
              offset2 = offsets2[from * 4 + i];
              i++;
              if (i > offsets2.length) return null;
            }
            return offset2;
          }
          return selection;
        }
        function lod(lox, loy, hix, hiy, maxLevel) {
          let ranges = [];
          for (let level = 0; level < maxLevel; level++) {
            let levelGroups = groups[level];
            let from = offsets[level][0];
            let levelGroupStart = group(lox, loy, level);
            let levelGroupEnd = group(hix, hiy, level);
            let startOffset = search.ge(levelGroups, levelGroupStart);
            let endOffset = search.gt(levelGroups, levelGroupEnd, startOffset, levelGroups.length - 1);
            ranges[level] = [startOffset + from, endOffset + from];
          }
          return ranges;
        }
        function group(x, y, level) {
          let group2 = 1;
          let cx = 0.5, cy = 0.5;
          let diam = 0.5;
          for (let i = 0; i < level; i++) {
            group2 <<= 2;
            group2 += x < cx ? y < cy ? 0 : 1 : y < cy ? 2 : 3;
            diam *= 0.5;
            cx += x < cx ? -diam : diam;
            cy += y < cy ? -diam : diam;
          }
          return group2;
        }
      };
      function normalize(pts, bounds) {
        let [lox, loy, hix, hiy] = bounds;
        let scaleX = 1 / (hix - lox);
        let scaleY = 1 / (hiy - loy);
        let result = new Array(pts.length);
        for (let i = 0, n = pts.length / 2; i < n; i++) {
          result[2 * i] = clamp((pts[2 * i] - lox) * scaleX, 0, 1);
          result[2 * i + 1] = clamp((pts[2 * i + 1] - loy) * scaleY, 0, 1);
        }
        return result;
      }
    }
  });

  // node_modules/@plotly/point-cluster/index.js
  var require_point_cluster = __commonJS({
    "node_modules/@plotly/point-cluster/index.js"(exports, module) {
      "use strict";
      module.exports = require_quad();
    }
  });

  // node_modules/abs-svg-path/index.js
  var require_abs_svg_path = __commonJS({
    "node_modules/abs-svg-path/index.js"(exports, module) {
      module.exports = absolutize;
      function absolutize(path) {
        var startX = 0;
        var startY = 0;
        var x = 0;
        var y = 0;
        return path.map(function(seg) {
          seg = seg.slice();
          var type = seg[0];
          var command = type.toUpperCase();
          if (type != command) {
            seg[0] = command;
            switch (type) {
              case "a":
                seg[6] += x;
                seg[7] += y;
                break;
              case "v":
                seg[1] += y;
                break;
              case "h":
                seg[1] += x;
                break;
              default:
                for (var i = 1; i < seg.length; ) {
                  seg[i++] += x;
                  seg[i++] += y;
                }
            }
          }
          switch (command) {
            case "Z":
              x = startX;
              y = startY;
              break;
            case "H":
              x = seg[1];
              break;
            case "V":
              y = seg[1];
              break;
            case "M":
              x = startX = seg[1];
              y = startY = seg[2];
              break;
            default:
              x = seg[seg.length - 2];
              y = seg[seg.length - 1];
          }
          return seg;
        });
      }
    }
  });

  // node_modules/svg-arc-to-cubic-bezier/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/svg-arc-to-cubic-bezier/cjs/index.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _slicedToArray = /* @__PURE__ */ function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var TAU = Math.PI * 2;
      var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
        var x = _ref.x, y = _ref.y;
        x *= rx;
        y *= ry;
        var xp = cosphi * x - sinphi * y;
        var yp = sinphi * x + cosphi * y;
        return {
          x: xp + centerx,
          y: yp + centery
        };
      };
      var approxUnitArc = function approxUnitArc2(ang1, ang2) {
        var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
        var x1 = Math.cos(ang1);
        var y1 = Math.sin(ang1);
        var x2 = Math.cos(ang1 + ang2);
        var y2 = Math.sin(ang1 + ang2);
        return [{
          x: x1 - y1 * a,
          y: y1 + x1 * a
        }, {
          x: x2 + y2 * a,
          y: y2 - x2 * a
        }, {
          x: x2,
          y: y2
        }];
      };
      var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
        var sign = ux * vy - uy * vx < 0 ? -1 : 1;
        var dot = ux * vx + uy * vy;
        if (dot > 1) {
          dot = 1;
        }
        if (dot < -1) {
          dot = -1;
        }
        return sign * Math.acos(dot);
      };
      var getArcCenter = function getArcCenter2(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
        var rxsq = Math.pow(rx, 2);
        var rysq = Math.pow(ry, 2);
        var pxpsq = Math.pow(pxp, 2);
        var pypsq = Math.pow(pyp, 2);
        var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
        if (radicant < 0) {
          radicant = 0;
        }
        radicant /= rxsq * pypsq + rysq * pxpsq;
        radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
        var centerxp = radicant * rx / ry * pyp;
        var centeryp = radicant * -ry / rx * pxp;
        var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
        var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
        var vx1 = (pxp - centerxp) / rx;
        var vy1 = (pyp - centeryp) / ry;
        var vx2 = (-pxp - centerxp) / rx;
        var vy2 = (-pyp - centeryp) / ry;
        var ang1 = vectorAngle(1, 0, vx1, vy1);
        var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
        if (sweepFlag === 0 && ang2 > 0) {
          ang2 -= TAU;
        }
        if (sweepFlag === 1 && ang2 < 0) {
          ang2 += TAU;
        }
        return [centerx, centery, ang1, ang2];
      };
      var arcToBezier = function arcToBezier2(_ref2) {
        var px = _ref2.px, py = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
        var curves = [];
        if (rx === 0 || ry === 0) {
          return [];
        }
        var sinphi = Math.sin(xAxisRotation * TAU / 360);
        var cosphi = Math.cos(xAxisRotation * TAU / 360);
        var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
        var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
        if (pxp === 0 && pyp === 0) {
          return [];
        }
        rx = Math.abs(rx);
        ry = Math.abs(ry);
        var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
        if (lambda > 1) {
          rx *= Math.sqrt(lambda);
          ry *= Math.sqrt(lambda);
        }
        var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
        var ratio = Math.abs(ang2) / (TAU / 4);
        if (Math.abs(1 - ratio) < 1e-7) {
          ratio = 1;
        }
        var segments = Math.max(Math.ceil(ratio), 1);
        ang2 /= segments;
        for (var i = 0; i < segments; i++) {
          curves.push(approxUnitArc(ang1, ang2));
          ang1 += ang2;
        }
        return curves.map(function(curve) {
          var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
          var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
          var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y = _mapToEllipse3.y;
          return { x1, y1, x2, y2, x, y };
        });
      };
      exports.default = arcToBezier;
      module.exports = exports.default;
    }
  });

  // node_modules/svg-path-bounds/node_modules/normalize-svg-path/index.js
  var require_normalize_svg_path = __commonJS({
    "node_modules/svg-path-bounds/node_modules/normalize-svg-path/index.js"(exports, module) {
      "use strict";
      module.exports = normalize;
      var arcToCurve = require_cjs();
      function normalize(path) {
        var prev;
        var result = [];
        var bezierX = 0;
        var bezierY = 0;
        var startX = 0;
        var startY = 0;
        var quadX = null;
        var quadY = null;
        var x = 0;
        var y = 0;
        for (var i = 0, len = path.length; i < len; i++) {
          var seg = path[i];
          var command = seg[0];
          switch (command) {
            case "M":
              startX = seg[1];
              startY = seg[2];
              break;
            case "A":
              var curves = arcToCurve({
                px: x,
                py: y,
                cx: seg[6],
                cy: seg[7],
                rx: seg[1],
                ry: seg[2],
                xAxisRotation: seg[3],
                largeArcFlag: seg[4],
                sweepFlag: seg[5]
              });
              if (!curves.length) continue;
              for (var j = 0, c; j < curves.length; j++) {
                c = curves[j];
                seg = ["C", c.x1, c.y1, c.x2, c.y2, c.x, c.y];
                if (j < curves.length - 1) result.push(seg);
              }
              break;
            case "S":
              var cx = x;
              var cy = y;
              if (prev == "C" || prev == "S") {
                cx += cx - bezierX;
                cy += cy - bezierY;
              }
              seg = ["C", cx, cy, seg[1], seg[2], seg[3], seg[4]];
              break;
            case "T":
              if (prev == "Q" || prev == "T") {
                quadX = x * 2 - quadX;
                quadY = y * 2 - quadY;
              } else {
                quadX = x;
                quadY = y;
              }
              seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);
              break;
            case "Q":
              quadX = seg[1];
              quadY = seg[2];
              seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);
              break;
            case "L":
              seg = line(x, y, seg[1], seg[2]);
              break;
            case "H":
              seg = line(x, y, seg[1], y);
              break;
            case "V":
              seg = line(x, y, x, seg[1]);
              break;
            case "Z":
              seg = line(x, y, startX, startY);
              break;
          }
          prev = command;
          x = seg[seg.length - 2];
          y = seg[seg.length - 1];
          if (seg.length > 4) {
            bezierX = seg[seg.length - 4];
            bezierY = seg[seg.length - 3];
          } else {
            bezierX = x;
            bezierY = y;
          }
          result.push(seg);
        }
        return result;
      }
      function line(x1, y1, x2, y2) {
        return ["C", x1, y1, x2, y2, x2, y2];
      }
      function quadratic(x1, y1, cx, cy, x2, y2) {
        return [
          "C",
          x1 / 3 + 2 / 3 * cx,
          y1 / 3 + 2 / 3 * cy,
          x2 / 3 + 2 / 3 * cx,
          y2 / 3 + 2 / 3 * cy,
          x2,
          y2
        ];
      }
    }
  });

  // node_modules/is-svg-path/index.js
  var require_is_svg_path = __commonJS({
    "node_modules/is-svg-path/index.js"(exports, module) {
      "use strict";
      module.exports = function isPath(str) {
        if (typeof str !== "string") return false;
        str = str.trim();
        if (/^[mzlhvcsqta]\s*[-+.0-9][^mlhvzcsqta]+/i.test(str) && /[\dz]$/i.test(str) && str.length > 4) return true;
        return false;
      };
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/es-errors/index.js
  var require_es_errors = __commonJS({
    "node_modules/es-errors/index.js"(exports, module) {
      "use strict";
      module.exports = Error;
    }
  });

  // node_modules/es-errors/eval.js
  var require_eval = __commonJS({
    "node_modules/es-errors/eval.js"(exports, module) {
      "use strict";
      module.exports = EvalError;
    }
  });

  // node_modules/es-errors/range.js
  var require_range = __commonJS({
    "node_modules/es-errors/range.js"(exports, module) {
      "use strict";
      module.exports = RangeError;
    }
  });

  // node_modules/es-errors/ref.js
  var require_ref = __commonJS({
    "node_modules/es-errors/ref.js"(exports, module) {
      "use strict";
      module.exports = ReferenceError;
    }
  });

  // node_modules/es-errors/syntax.js
  var require_syntax = __commonJS({
    "node_modules/es-errors/syntax.js"(exports, module) {
      "use strict";
      module.exports = SyntaxError;
    }
  });

  // node_modules/es-errors/type.js
  var require_type = __commonJS({
    "node_modules/es-errors/type.js"(exports, module) {
      "use strict";
      module.exports = TypeError;
    }
  });

  // node_modules/es-errors/uri.js
  var require_uri = __commonJS({
    "node_modules/es-errors/uri.js"(exports, module) {
      "use strict";
      module.exports = URIError;
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/has-proto/index.js
  var require_has_proto = __commonJS({
    "node_modules/has-proto/index.js"(exports, module) {
      "use strict";
      var test = {
        foo: {}
      };
      var $Object = Object;
      module.exports = function hasProto() {
        return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var toStr = Object.prototype.toString;
      var max = Math.max;
      var funcType = "[object Function]";
      var concatty = function concatty2(a, b) {
        var arr = [];
        for (var i = 0; i < a.length; i += 1) {
          arr[i] = a[i];
        }
        for (var j = 0; j < b.length; j += 1) {
          arr[j + a.length] = b[j];
        }
        return arr;
      };
      var slicy = function slicy2(arrLike, offset) {
        var arr = [];
        for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
          arr[j] = arrLike[i];
        }
        return arr;
      };
      var joiny = function(arr, joiner) {
        var str = "";
        for (var i = 0; i < arr.length; i += 1) {
          str += arr[i];
          if (i + 1 < arr.length) {
            str += joiner;
          }
        }
        return str;
      };
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.apply(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slicy(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              concatty(args, arguments)
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          }
          return target.apply(
            that,
            concatty(args, arguments)
          );
        };
        var boundLength = max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs[i] = "$" + i;
        }
        bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      var implementation = require_implementation();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/hasown/index.js
  var require_hasown = __commonJS({
    "node_modules/hasown/index.js"(exports, module) {
      "use strict";
      var call = Function.prototype.call;
      var $hasOwn = Object.prototype.hasOwnProperty;
      var bind = require_function_bind();
      module.exports = bind.call(call, $hasOwn);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      var undefined2;
      var $Error = require_es_errors();
      var $EvalError = require_eval();
      var $RangeError = require_range();
      var $ReferenceError = require_ref();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var $URIError = require_uri();
      var $Function = Function;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var hasProto = require_has_proto()();
      var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
        return x.__proto__;
      } : null);
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": $Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": $EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": $RangeError,
        "%ReferenceError%": $ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": $URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      if (getProto) {
        try {
          null.error;
        } catch (e) {
          errorProto = getProto(getProto(e));
          INTRINSICS["%Error.prototype%"] = errorProto;
        }
      }
      var errorProto;
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen && getProto) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_hasown();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/es-define-property/index.js
  var require_es_define_property = __commonJS({
    "node_modules/es-define-property/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = false;
        }
      }
      module.exports = $defineProperty;
    }
  });

  // node_modules/gopd/index.js
  var require_gopd = __commonJS({
    "node_modules/gopd/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e) {
          $gOPD = null;
        }
      }
      module.exports = $gOPD;
    }
  });

  // node_modules/define-data-property/index.js
  var require_define_data_property = __commonJS({
    "node_modules/define-data-property/index.js"(exports, module) {
      "use strict";
      var $defineProperty = require_es_define_property();
      var $SyntaxError = require_syntax();
      var $TypeError = require_type();
      var gopd = require_gopd();
      module.exports = function defineDataProperty(obj, property, value) {
        if (!obj || typeof obj !== "object" && typeof obj !== "function") {
          throw new $TypeError("`obj` must be an object or a function`");
        }
        if (typeof property !== "string" && typeof property !== "symbol") {
          throw new $TypeError("`property` must be a string or a symbol`");
        }
        if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
          throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
          throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
          throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
        }
        if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
          throw new $TypeError("`loose`, if provided, must be a boolean");
        }
        var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
        var nonWritable = arguments.length > 4 ? arguments[4] : null;
        var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
        var loose = arguments.length > 6 ? arguments[6] : false;
        var desc = !!gopd && gopd(obj, property);
        if ($defineProperty) {
          $defineProperty(obj, property, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
          });
        } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
          obj[property] = value;
        } else {
          throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
        }
      };
    }
  });

  // node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "node_modules/has-property-descriptors/index.js"(exports, module) {
      "use strict";
      var $defineProperty = require_es_define_property();
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        return !!$defineProperty;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!$defineProperty) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    }
  });

  // node_modules/set-function-length/index.js
  var require_set_function_length = __commonJS({
    "node_modules/set-function-length/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var define2 = require_define_data_property();
      var hasDescriptors = require_has_property_descriptors()();
      var gOPD = require_gopd();
      var $TypeError = require_type();
      var $floor = GetIntrinsic("%Math.floor%");
      module.exports = function setFunctionLength(fn, length) {
        if (typeof fn !== "function") {
          throw new $TypeError("`fn` is not a function");
        }
        if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
          throw new $TypeError("`length` must be a positive 32-bit integer");
        }
        var loose = arguments.length > 2 && !!arguments[2];
        var functionLengthIsConfigurable = true;
        var functionLengthIsWritable = true;
        if ("length" in fn && gOPD) {
          var desc = gOPD(fn, "length");
          if (desc && !desc.configurable) {
            functionLengthIsConfigurable = false;
          }
          if (desc && !desc.writable) {
            functionLengthIsWritable = false;
          }
        }
        if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
          if (hasDescriptors) {
            define2(
              /** @type {Parameters<define>[0]} */
              fn,
              "length",
              length,
              true,
              true
            );
          } else {
            define2(
              /** @type {Parameters<define>[0]} */
              fn,
              "length",
              length
            );
          }
        }
        return fn;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var setFunctionLength = require_set_function_length();
      var $TypeError = require_type();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $defineProperty = require_es_define_property();
      var $max = GetIntrinsic("%Math.max%");
      module.exports = function callBind(originalFunction) {
        if (typeof originalFunction !== "function") {
          throw new $TypeError("a function is required");
        }
        var func = $reflectApply(bind, $call, arguments);
        return setFunctionLength(
          func,
          1 + $max(0, originalFunction.length - (arguments.length - 1)),
          true
        );
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e) {
        }
      };
      var GeneratorFunction;
      module.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "node_modules/is-callable/index.js"(exports, module) {
      "use strict";
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str = toStr.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
              } catch (e) {
              }
            }
            return false;
          };
        }
      }
      var all;
      module.exports = reflectApply ? function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e) {
          if (e !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
    }
  });

  // node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "node_modules/for-each/index.js"(exports, module) {
      "use strict";
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i = 0, len = array.length; i < len; i++) {
          if (hasOwnProperty2.call(array, i)) {
            if (receiver == null) {
              iterator(array[i], i, array);
            } else {
              iterator.call(receiver, array[i], i, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string, iterator, receiver) {
        for (var i = 0, len = string.length; i < len; i++) {
          if (receiver == null) {
            iterator(string.charAt(i), i, string);
          } else {
            iterator.call(receiver, string.charAt(i), i, string);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty2.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      var forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module.exports = forEach;
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports, module) {
      "use strict";
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g = typeof globalThis === "undefined" ? window : globalThis;
      module.exports = function availableTypedArrays() {
        var out = [];
        for (var i = 0; i < possibleNames.length; i++) {
          if (typeof g[possibleNames[i]] === "function") {
            out[out.length] = possibleNames[i];
          }
        }
        return out;
      };
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports, module) {
      "use strict";
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBind = require_call_bind();
      var callBound = require_callBound();
      var gOPD = require_gopd();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g = typeof globalThis === "undefined" ? window : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var getPrototypeOf = Object.getPrototypeOf;
      var $indexOf = callBound("Array.prototype.indexOf", true) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
      function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var cache = { __proto__: null };
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            cache["$" + typedArray] = callBind(descriptor.get);
          }
        });
      } else {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          var fn = arr.slice || arr.set;
          if (fn) {
            cache["$" + typedArray] = callBind(fn);
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var found = false;
        forEach(
          // eslint-disable-next-line no-extra-parens
          /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
          /** @type {any} */
          cache,
          /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
          function(getter, typedArray) {
            if (!found) {
              try {
                if ("$" + getter(value) === typedArray) {
                  found = $slice(typedArray, 1);
                }
              } catch (e) {
              }
            }
          }
        );
        return found;
      };
      var trySlices = function tryAllSlices(value) {
        var found = false;
        forEach(
          // eslint-disable-next-line no-extra-parens
          /** @type {any} */
          cache,
          /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
          function(getter, name) {
            if (!found) {
              try {
                getter(value);
                found = $slice(name, 1);
              } catch (e) {
              }
            }
          }
        );
        return found;
      };
      module.exports = function whichTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag) {
          var tag = $slice($toString(value), 8, -1);
          if ($indexOf(typedArrays, tag) > -1) {
            return tag;
          }
          if (tag !== "Object") {
            return false;
          }
          return trySlices(value);
        }
        if (!gOPD) {
          return null;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports, module) {
      "use strict";
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var gOPD = require_gopd();
      var g = typeof globalThis === "undefined" ? window : globalThis;
      var typedArrays = availableTypedArrays();
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i = 0; i < array.length; i += 1) {
          if (array[i] === value) {
            return i;
          }
        }
        return -1;
      };
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e) {
            }
          }
        });
        return anyTrue;
      };
      module.exports = function isTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          var tag = $slice($toString(value), 8, -1);
          return $indexOf(typedArrays, tag) > -1;
        }
        if (!gOPD) {
          return false;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports) {
      "use strict";
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports.isArgumentsObject = isArgumentsObject;
      exports.isGeneratorFunction = isGeneratorFunction;
      exports.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports, module) {
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/util/util.js"(exports) {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%") return "%";
          if (i >= len) return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if ("false") {
        debugEnv = "false";
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports.debuglog = function(set) {
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (debugEnvRegex.test(set)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3) ctx.depth = arguments[2];
        if (arguments.length >= 4) ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
        if (isUndefined(ctx.depth)) ctx.depth = 2;
        if (isUndefined(ctx.colors)) ctx.colors = false;
        if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
        if (ctx.colors) ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        // "name": intentionally not styling
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty2(value, String(i))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty2(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0) numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      exports.types = require_types();
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      exports.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      exports.types.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports.isError = isError;
      exports.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
        typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = /* @__PURE__ */ new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add) {
        if (!add || !isObject(add)) return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty2(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return Object.defineProperties(
          fn,
          getOwnPropertyDescriptors(original)
        );
      };
      exports.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports.callbackify = callbackify;
    }
  });

  // node_modules/assert/build/internal/errors.js
  var require_errors = __commonJS({
    "node_modules/assert/build/internal/errors.js"(exports, module) {
      "use strict";
      function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof(o);
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return _typeof(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (_typeof(input) !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof(res) !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        Object.defineProperty(subClass, "prototype", { writable: false });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        } else if (call !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var codes = {};
      var assert;
      var util;
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inherits(NodeError2, _Base);
          var _super = _createSuper(NodeError2);
          function NodeError2(arg1, arg2, arg3) {
            var _this;
            _classCallCheck(this, NodeError2);
            _this = _super.call(this, getMessage(arg1, arg2, arg3));
            _this.code = code;
            return _this;
          }
          return _createClass(NodeError2);
        }(Base);
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        if (assert === void 0) assert = require_assert();
        assert(typeof name === "string", "'name' must be a string");
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(_typeof(actual));
        return msg;
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
        var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
        if (util === void 0) util = require_util();
        var inspected = util.inspect(value);
        if (inspected.length > 128) {
          inspected = "".concat(inspected.slice(0, 128), "...");
        }
        return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
      }, TypeError, RangeError);
      createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
        var type;
        if (value && value.constructor && value.constructor.name) {
          type = "instance of ".concat(value.constructor.name);
        } else {
          type = "type ".concat(_typeof(value));
        }
        return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
      }, TypeError);
      createErrorType("ERR_MISSING_ARGS", function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (assert === void 0) assert = require_assert();
        assert(args.length > 0, "At least one arg needs to be specified");
        var msg = "The ";
        var len = args.length;
        args = args.map(function(a) {
          return '"'.concat(a, '"');
        });
        switch (len) {
          case 1:
            msg += "".concat(args[0], " argument");
            break;
          case 2:
            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
            break;
          default:
            msg += args.slice(0, len - 1).join(", ");
            msg += ", and ".concat(args[len - 1], " arguments");
            break;
        }
        return "".concat(msg, " must be specified");
      }, TypeError);
      module.exports.codes = codes;
    }
  });

  // node_modules/assert/build/internal/assert/assertion_error.js
  var require_assertion_error = __commonJS({
    "node_modules/assert/build/internal/assert/assertion_error.js"(exports, module) {
      "use strict";
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
          var t = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
            _defineProperty(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return _typeof(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (_typeof(input) !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof(res) !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        Object.defineProperty(subClass, "prototype", { writable: false });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        } else if (call !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2)) return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2) _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof(o);
      }
      var _require = require_util();
      var inspect = _require.inspect;
      var _require2 = require_errors();
      var ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function repeat(str, count) {
        count = Math.floor(count);
        if (str.length == 0 || count == 0) return "";
        var maxCount = str.length * count;
        count = Math.floor(Math.log(count) / Math.log(2));
        while (count) {
          str += str;
          count--;
        }
        str += str.substring(0, maxCount - str.length);
        return str;
      }
      var blue = "";
      var green = "";
      var red = "";
      var white = "";
      var kReadableOperator = {
        deepStrictEqual: "Expected values to be strictly deep-equal:",
        strictEqual: "Expected values to be strictly equal:",
        strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
        deepEqual: "Expected values to be loosely deep-equal:",
        equal: "Expected values to be loosely equal:",
        notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
        notStrictEqual: 'Expected "actual" to be strictly unequal to:',
        notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
        notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
        notEqual: 'Expected "actual" to be loosely unequal to:',
        notIdentical: "Values identical but not reference-equal:"
      };
      var kMaxShortLength = 10;
      function copyError(source) {
        var keys = Object.keys(source);
        var target = Object.create(Object.getPrototypeOf(source));
        keys.forEach(function(key) {
          target[key] = source[key];
        });
        Object.defineProperty(target, "message", {
          value: source.message
        });
        return target;
      }
      function inspectValue(val) {
        return inspect(val, {
          compact: false,
          customInspect: false,
          depth: 1e3,
          maxArrayLength: Infinity,
          // Assert compares only enumerable properties (with a few exceptions).
          showHidden: false,
          // Having a long line as error is better than wrapping the line for
          // comparison for now.
          // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
          // have meta information about the inspected properties (i.e., know where
          // in what line the property starts and ends).
          breakLength: Infinity,
          // Assert does not detect proxies currently.
          showProxy: false,
          sorted: true,
          // Inspect getters as we also check them when comparing entries.
          getters: true
        });
      }
      function createErrDiff(actual, expected, operator) {
        var other = "";
        var res = "";
        var lastPos = 0;
        var end = "";
        var skipped = false;
        var actualInspected = inspectValue(actual);
        var actualLines = actualInspected.split("\n");
        var expectedLines = inspectValue(expected).split("\n");
        var i = 0;
        var indicator = "";
        if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
          operator = "strictEqualObject";
        }
        if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
          var inputLength = actualLines[0].length + expectedLines[0].length;
          if (inputLength <= kMaxShortLength) {
            if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
              return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
            }
          } else if (operator !== "strictEqualObject") {
            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
            if (inputLength < maxLength) {
              while (actualLines[0][i] === expectedLines[0][i]) {
                i++;
              }
              if (i > 2) {
                indicator = "\n  ".concat(repeat(" ", i), "^");
                i = 0;
              }
            }
          }
        }
        var a = actualLines[actualLines.length - 1];
        var b = expectedLines[expectedLines.length - 1];
        while (a === b) {
          if (i++ < 2) {
            end = "\n  ".concat(a).concat(end);
          } else {
            other = a;
          }
          actualLines.pop();
          expectedLines.pop();
          if (actualLines.length === 0 || expectedLines.length === 0) break;
          a = actualLines[actualLines.length - 1];
          b = expectedLines[expectedLines.length - 1];
        }
        var maxLines = Math.max(actualLines.length, expectedLines.length);
        if (maxLines === 0) {
          var _actualLines = actualInspected.split("\n");
          if (_actualLines.length > 30) {
            _actualLines[26] = "".concat(blue, "...").concat(white);
            while (_actualLines.length > 27) {
              _actualLines.pop();
            }
          }
          return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
        }
        if (i > 3) {
          end = "\n".concat(blue, "...").concat(white).concat(end);
          skipped = true;
        }
        if (other !== "") {
          end = "\n  ".concat(other).concat(end);
          other = "";
        }
        var printedLines = 0;
        var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
        var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
        for (i = 0; i < maxLines; i++) {
          var cur = i - lastPos;
          if (actualLines.length < i + 1) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(expectedLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(expectedLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
            printedLines++;
          } else if (expectedLines.length < i + 1) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
            printedLines++;
          } else {
            var expectedLine = expectedLines[i];
            var actualLine = actualLines[i];
            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
            if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
              divergingLines = false;
              actualLine += ",";
            }
            if (divergingLines) {
              if (cur > 1 && i > 2) {
                if (cur > 4) {
                  res += "\n".concat(blue, "...").concat(white);
                  skipped = true;
                } else if (cur > 3) {
                  res += "\n  ".concat(actualLines[i - 2]);
                  printedLines++;
                }
                res += "\n  ".concat(actualLines[i - 1]);
                printedLines++;
              }
              lastPos = i;
              res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
              other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
              printedLines += 2;
            } else {
              res += other;
              other = "";
              if (cur === 1 || i === 0) {
                res += "\n  ".concat(actualLine);
                printedLines++;
              }
            }
          }
          if (printedLines > 20 && i < maxLines - 2) {
            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
          }
        }
        return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
      }
      var AssertionError = /* @__PURE__ */ function(_Error, _inspect$custom) {
        _inherits(AssertionError2, _Error);
        var _super = _createSuper(AssertionError2);
        function AssertionError2(options) {
          var _this;
          _classCallCheck(this, AssertionError2);
          if (_typeof(options) !== "object" || options === null) {
            throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
          }
          var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
          var actual = options.actual, expected = options.expected;
          var limit = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          if (message != null) {
            _this = _super.call(this, String(message));
          } else {
            if (process.stderr && process.stderr.isTTY) {
              if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                blue = "\x1B[34m";
                green = "\x1B[32m";
                white = "\x1B[39m";
                red = "\x1B[31m";
              } else {
                blue = "";
                green = "";
                white = "";
                red = "";
              }
            }
            if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
              actual = copyError(actual);
              expected = copyError(expected);
            }
            if (operator === "deepStrictEqual" || operator === "strictEqual") {
              _this = _super.call(this, createErrDiff(actual, expected, operator));
            } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
              var base = kReadableOperator[operator];
              var res = inspectValue(actual).split("\n");
              if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
                base = kReadableOperator.notStrictEqualObject;
              }
              if (res.length > 30) {
                res[26] = "".concat(blue, "...").concat(white);
                while (res.length > 27) {
                  res.pop();
                }
              }
              if (res.length === 1) {
                _this = _super.call(this, "".concat(base, " ").concat(res[0]));
              } else {
                _this = _super.call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n"));
              }
            } else {
              var _res = inspectValue(actual);
              var other = "";
              var knownOperators = kReadableOperator[operator];
              if (operator === "notDeepEqual" || operator === "notEqual") {
                _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                if (_res.length > 1024) {
                  _res = "".concat(_res.slice(0, 1021), "...");
                }
              } else {
                other = "".concat(inspectValue(expected));
                if (_res.length > 512) {
                  _res = "".concat(_res.slice(0, 509), "...");
                }
                if (other.length > 512) {
                  other = "".concat(other.slice(0, 509), "...");
                }
                if (operator === "deepEqual" || operator === "equal") {
                  _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                } else {
                  other = " ".concat(operator, " ").concat(other);
                }
              }
              _this = _super.call(this, "".concat(_res).concat(other));
            }
          }
          Error.stackTraceLimit = limit;
          _this.generatedMessage = !message;
          Object.defineProperty(_assertThisInitialized(_this), "name", {
            value: "AssertionError [ERR_ASSERTION]",
            enumerable: false,
            writable: true,
            configurable: true
          });
          _this.code = "ERR_ASSERTION";
          _this.actual = actual;
          _this.expected = expected;
          _this.operator = operator;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
          }
          _this.stack;
          _this.name = "AssertionError";
          return _possibleConstructorReturn(_this);
        }
        _createClass(AssertionError2, [{
          key: "toString",
          value: function toString() {
            return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
          }
        }, {
          key: _inspect$custom,
          value: function value(recurseTimes, ctx) {
            return inspect(this, _objectSpread(_objectSpread({}, ctx), {}, {
              customInspect: false,
              depth: 0
            }));
          }
        }]);
        return AssertionError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error), inspect.custom);
      module.exports = AssertionError;
    }
  });

  // node_modules/object-keys/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/object-keys/isArguments.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      module.exports = function isArguments(value) {
        var str = toStr.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) {
          isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
      };
    }
  });

  // node_modules/object-keys/implementation.js
  var require_implementation2 = __commonJS({
    "node_modules/object-keys/implementation.js"(exports, module) {
      "use strict";
      var keysShim;
      if (!Object.keys) {
        has = Object.prototype.hasOwnProperty;
        toStr = Object.prototype.toString;
        isArgs = require_isArguments();
        isEnumerable = Object.prototype.propertyIsEnumerable;
        hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        hasProtoEnumBug = isEnumerable.call(function() {
        }, "prototype");
        dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ];
        equalsConstructorPrototype = function(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        hasAutomationEqualityBug = function() {
          if (typeof window === "undefined") {
            return false;
          }
          for (var k in window) {
            try {
              if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                try {
                  equalsConstructorPrototype(window[k]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        }();
        equalsConstructorPrototypeIfNotBuggy = function(o) {
          if (typeof window === "undefined" || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object) {
          var isObject = object !== null && typeof object === "object";
          var isFunction = toStr.call(object) === "[object Function]";
          var isArguments = isArgs(object);
          var isString = isObject && toStr.call(object) === "[object String]";
          var theKeys = [];
          if (!isObject && !isFunction && !isArguments) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object.length > 0 && !has.call(object, 0)) {
            for (var i = 0; i < object.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object.length > 0) {
            for (var j = 0; j < object.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object) {
              if (!(skipProto && name === "prototype") && has.call(object, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
      }
      var has;
      var toStr;
      var isArgs;
      var isEnumerable;
      var hasDontEnumBug;
      var hasProtoEnumBug;
      var dontEnums;
      var equalsConstructorPrototype;
      var excludedKeys;
      var hasAutomationEqualityBug;
      var equalsConstructorPrototypeIfNotBuggy;
      module.exports = keysShim;
    }
  });

  // node_modules/object-keys/index.js
  var require_object_keys = __commonJS({
    "node_modules/object-keys/index.js"(exports, module) {
      "use strict";
      var slice = Array.prototype.slice;
      var isArgs = require_isArguments();
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : require_implementation2();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object) {
              if (isArgs(object)) {
                return originalKeys(slice.call(object));
              }
              return originalKeys(object);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module.exports = keysShim;
    }
  });

  // node_modules/object.assign/implementation.js
  var require_implementation3 = __commonJS({
    "node_modules/object.assign/implementation.js"(exports, module) {
      "use strict";
      var objectKeys = require_object_keys();
      var hasSymbols = require_shams()();
      var callBound = require_callBound();
      var toObject = Object;
      var $push = callBound("Array.prototype.push");
      var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
      var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;
      module.exports = function assign(target, source1) {
        if (target == null) {
          throw new TypeError("target must be an object");
        }
        var to = toObject(target);
        if (arguments.length === 1) {
          return to;
        }
        for (var s = 1; s < arguments.length; ++s) {
          var from = toObject(arguments[s]);
          var keys = objectKeys(from);
          var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
          if (getSymbols) {
            var syms = getSymbols(from);
            for (var j = 0; j < syms.length; ++j) {
              var key = syms[j];
              if ($propIsEnumerable(from, key)) {
                $push(keys, key);
              }
            }
          }
          for (var i = 0; i < keys.length; ++i) {
            var nextKey = keys[i];
            if ($propIsEnumerable(from, nextKey)) {
              var propValue = from[nextKey];
              to[nextKey] = propValue;
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/object.assign/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/object.assign/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation3();
      var lacksProperEnumerationOrder = function() {
        if (!Object.assign) {
          return false;
        }
        var str = "abcdefghijklmnopqrst";
        var letters = str.split("");
        var map = {};
        for (var i = 0; i < letters.length; ++i) {
          map[letters[i]] = letters[i];
        }
        var obj = Object.assign({}, map);
        var actual = "";
        for (var k in obj) {
          actual += k;
        }
        return str !== actual;
      };
      var assignHasPendingExceptions = function() {
        if (!Object.assign || !Object.preventExtensions) {
          return false;
        }
        var thrower = Object.preventExtensions({ 1: 2 });
        try {
          Object.assign(thrower, "xy");
        } catch (e) {
          return thrower[1] === "y";
        }
        return false;
      };
      module.exports = function getPolyfill() {
        if (!Object.assign) {
          return implementation;
        }
        if (lacksProperEnumerationOrder()) {
          return implementation;
        }
        if (assignHasPendingExceptions()) {
          return implementation;
        }
        return Object.assign;
      };
    }
  });

  // node_modules/object-is/implementation.js
  var require_implementation4 = __commonJS({
    "node_modules/object-is/implementation.js"(exports, module) {
      "use strict";
      var numberIsNaN = function(value) {
        return value !== value;
      };
      module.exports = function is(a, b) {
        if (a === 0 && b === 0) {
          return 1 / a === 1 / b;
        }
        if (a === b) {
          return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b)) {
          return true;
        }
        return false;
      };
    }
  });

  // node_modules/object-is/polyfill.js
  var require_polyfill2 = __commonJS({
    "node_modules/object-is/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation4();
      module.exports = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation;
      };
    }
  });

  // node_modules/define-properties/index.js
  var require_define_properties = __commonJS({
    "node_modules/define-properties/index.js"(exports, module) {
      "use strict";
      var keys = require_object_keys();
      var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr = Object.prototype.toString;
      var concat = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction = function(fn) {
        return typeof fn === "function" && toStr.call(fn) === "[object Function]";
      };
      var hasPropertyDescriptors = require_has_property_descriptors()();
      var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
      var defineProperty = function(object, name, value, predicate) {
        if (name in object) {
          if (predicate === true) {
            if (object[name] === value) {
              return;
            }
          } else if (!isFunction(predicate) || !predicate()) {
            return;
          }
        }
        if (supportsDescriptors) {
          origDefineProperty(object, name, {
            configurable: true,
            enumerable: false,
            value,
            writable: true
          });
        } else {
          object[name] = value;
        }
      };
      var defineProperties = function(object, map) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map);
        if (hasSymbols) {
          props = concat.call(props, Object.getOwnPropertySymbols(map));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module.exports = defineProperties;
    }
  });

  // node_modules/object-is/shim.js
  var require_shim = __commonJS({
    "node_modules/object-is/shim.js"(exports, module) {
      "use strict";
      var getPolyfill = require_polyfill2();
      var define2 = require_define_properties();
      module.exports = function shimObjectIs() {
        var polyfill = getPolyfill();
        define2(Object, { is: polyfill }, {
          is: function testObjectIs() {
            return Object.is !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/object-is/index.js
  var require_object_is = __commonJS({
    "node_modules/object-is/index.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation4();
      var getPolyfill = require_polyfill2();
      var shim = require_shim();
      var polyfill = callBind(getPolyfill(), Object);
      define2(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // node_modules/is-nan/implementation.js
  var require_implementation5 = __commonJS({
    "node_modules/is-nan/implementation.js"(exports, module) {
      "use strict";
      module.exports = function isNaN2(value) {
        return value !== value;
      };
    }
  });

  // node_modules/is-nan/polyfill.js
  var require_polyfill3 = __commonJS({
    "node_modules/is-nan/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation5();
      module.exports = function getPolyfill() {
        if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
          return Number.isNaN;
        }
        return implementation;
      };
    }
  });

  // node_modules/is-nan/shim.js
  var require_shim2 = __commonJS({
    "node_modules/is-nan/shim.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var getPolyfill = require_polyfill3();
      module.exports = function shimNumberIsNaN() {
        var polyfill = getPolyfill();
        define2(Number, { isNaN: polyfill }, {
          isNaN: function testIsNaN() {
            return Number.isNaN !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/is-nan/index.js
  var require_is_nan = __commonJS({
    "node_modules/is-nan/index.js"(exports, module) {
      "use strict";
      var callBind = require_call_bind();
      var define2 = require_define_properties();
      var implementation = require_implementation5();
      var getPolyfill = require_polyfill3();
      var shim = require_shim2();
      var polyfill = callBind(getPolyfill(), Number);
      define2(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // node_modules/assert/build/internal/util/comparisons.js
  var require_comparisons = __commonJS({
    "node_modules/assert/build/internal/util/comparisons.js"(exports, module) {
      "use strict";
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function _iterableToArrayLimit(r, l) {
        var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (null != t) {
          var e, n, i, u, a = [], f = true, o = false;
          try {
            if (i = (t = t.call(r)).next, 0 === l) {
              if (Object(t) !== t) return;
              f = false;
            } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
          } catch (r2) {
            o = true, n = r2;
          } finally {
            try {
              if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
            } finally {
              if (o) throw n;
            }
          }
          return a;
        }
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof(o);
      }
      var regexFlagsSupported = /a/g.flags !== void 0;
      var arrayFromSet = function arrayFromSet2(set) {
        var array = [];
        set.forEach(function(value) {
          return array.push(value);
        });
        return array;
      };
      var arrayFromMap = function arrayFromMap2(map) {
        var array = [];
        map.forEach(function(value, key) {
          return array.push([key, value]);
        });
        return array;
      };
      var objectIs = Object.is ? Object.is : require_object_is();
      var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return [];
      };
      var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var hasOwnProperty2 = uncurryThis(Object.prototype.hasOwnProperty);
      var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
      var objectToString = uncurryThis(Object.prototype.toString);
      var _require$types = require_util().types;
      var isAnyArrayBuffer = _require$types.isAnyArrayBuffer;
      var isArrayBufferView = _require$types.isArrayBufferView;
      var isDate = _require$types.isDate;
      var isMap = _require$types.isMap;
      var isRegExp = _require$types.isRegExp;
      var isSet = _require$types.isSet;
      var isNativeError = _require$types.isNativeError;
      var isBoxedPrimitive = _require$types.isBoxedPrimitive;
      var isNumberObject = _require$types.isNumberObject;
      var isStringObject = _require$types.isStringObject;
      var isBooleanObject = _require$types.isBooleanObject;
      var isBigIntObject = _require$types.isBigIntObject;
      var isSymbolObject = _require$types.isSymbolObject;
      var isFloat32Array = _require$types.isFloat32Array;
      var isFloat64Array = _require$types.isFloat64Array;
      function isNonIndex(key) {
        if (key.length === 0 || key.length > 10) return true;
        for (var i = 0; i < key.length; i++) {
          var code = key.charCodeAt(i);
          if (code < 48 || code > 57) return true;
        }
        return key.length === 10 && key >= Math.pow(2, 32);
      }
      function getOwnNonIndexProperties(value) {
        return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
      }
      function compare(a, b) {
        if (a === b) {
          return 0;
        }
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) {
          return -1;
        }
        if (y < x) {
          return 1;
        }
        return 0;
      }
      var ONLY_ENUMERABLE = void 0;
      var kStrict = true;
      var kLoose = false;
      var kNoIterator = 0;
      var kIsArray = 1;
      var kIsSet = 2;
      var kIsMap = 3;
      function areSimilarRegExps(a, b) {
        return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
      }
      function areSimilarFloatArrays(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        for (var offset = 0; offset < a.byteLength; offset++) {
          if (a[offset] !== b[offset]) {
            return false;
          }
        }
        return true;
      }
      function areSimilarTypedArrays(a, b) {
        if (a.byteLength !== b.byteLength) {
          return false;
        }
        return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
      }
      function areEqualArrayBuffers(buf1, buf2) {
        return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
      }
      function isEqualBoxedPrimitive(val1, val2) {
        if (isNumberObject(val1)) {
          return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
        }
        if (isStringObject(val1)) {
          return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
        }
        if (isBooleanObject(val1)) {
          return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
        }
        if (isBigIntObject(val1)) {
          return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
        }
        return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
      }
      function innerDeepEqual(val1, val2, strict, memos) {
        if (val1 === val2) {
          if (val1 !== 0) return true;
          return strict ? objectIs(val1, val2) : true;
        }
        if (strict) {
          if (_typeof(val1) !== "object") {
            return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
          }
          if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
            return false;
          }
          if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
            return false;
          }
        } else {
          if (val1 === null || _typeof(val1) !== "object") {
            if (val2 === null || _typeof(val2) !== "object") {
              return val1 == val2;
            }
            return false;
          }
          if (val2 === null || _typeof(val2) !== "object") {
            return false;
          }
        }
        var val1Tag = objectToString(val1);
        var val2Tag = objectToString(val2);
        if (val1Tag !== val2Tag) {
          return false;
        }
        if (Array.isArray(val1)) {
          if (val1.length !== val2.length) {
            return false;
          }
          var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
          var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
        }
        if (val1Tag === "[object Object]") {
          if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
            return false;
          }
        }
        if (isDate(val1)) {
          if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
            return false;
          }
        } else if (isRegExp(val1)) {
          if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
            return false;
          }
        } else if (isNativeError(val1) || val1 instanceof Error) {
          if (val1.message !== val2.message || val1.name !== val2.name) {
            return false;
          }
        } else if (isArrayBufferView(val1)) {
          if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
            if (!areSimilarFloatArrays(val1, val2)) {
              return false;
            }
          } else if (!areSimilarTypedArrays(val1, val2)) {
            return false;
          }
          var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
          var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
          if (_keys.length !== _keys2.length) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
        } else if (isSet(val1)) {
          if (!isSet(val2) || val1.size !== val2.size) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsSet);
        } else if (isMap(val1)) {
          if (!isMap(val2) || val1.size !== val2.size) {
            return false;
          }
          return keyCheck(val1, val2, strict, memos, kIsMap);
        } else if (isAnyArrayBuffer(val1)) {
          if (!areEqualArrayBuffers(val1, val2)) {
            return false;
          }
        } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator);
      }
      function getEnumerables(val, keys) {
        return keys.filter(function(k) {
          return propertyIsEnumerable(val, k);
        });
      }
      function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
        if (arguments.length === 5) {
          aKeys = Object.keys(val1);
          var bKeys = Object.keys(val2);
          if (aKeys.length !== bKeys.length) {
            return false;
          }
        }
        var i = 0;
        for (; i < aKeys.length; i++) {
          if (!hasOwnProperty2(val2, aKeys[i])) {
            return false;
          }
        }
        if (strict && arguments.length === 5) {
          var symbolKeysA = objectGetOwnPropertySymbols(val1);
          if (symbolKeysA.length !== 0) {
            var count = 0;
            for (i = 0; i < symbolKeysA.length; i++) {
              var key = symbolKeysA[i];
              if (propertyIsEnumerable(val1, key)) {
                if (!propertyIsEnumerable(val2, key)) {
                  return false;
                }
                aKeys.push(key);
                count++;
              } else if (propertyIsEnumerable(val2, key)) {
                return false;
              }
            }
            var symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
              return false;
            }
          } else {
            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
              return false;
            }
          }
        }
        if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
          return true;
        }
        if (memos === void 0) {
          memos = {
            val1: /* @__PURE__ */ new Map(),
            val2: /* @__PURE__ */ new Map(),
            position: 0
          };
        } else {
          var val2MemoA = memos.val1.get(val1);
          if (val2MemoA !== void 0) {
            var val2MemoB = memos.val2.get(val2);
            if (val2MemoB !== void 0) {
              return val2MemoA === val2MemoB;
            }
          }
          memos.position++;
        }
        memos.val1.set(val1, memos.position);
        memos.val2.set(val2, memos.position);
        var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
        memos.val1.delete(val1);
        memos.val2.delete(val2);
        return areEq;
      }
      function setHasEqualElement(set, val1, strict, memo) {
        var setValues = arrayFromSet(set);
        for (var i = 0; i < setValues.length; i++) {
          var val2 = setValues[i];
          if (innerDeepEqual(val1, val2, strict, memo)) {
            set.delete(val2);
            return true;
          }
        }
        return false;
      }
      function findLooseMatchingPrimitives(prim) {
        switch (_typeof(prim)) {
          case "undefined":
            return null;
          case "object":
            return void 0;
          case "symbol":
            return false;
          case "string":
            prim = +prim;
          // Loose equal entries exist only if the string is possible to convert to
          // a regular number and not NaN.
          // Fall through
          case "number":
            if (numberIsNaN(prim)) {
              return false;
            }
        }
        return true;
      }
      function setMightHaveLoosePrim(a, b, prim) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) return altValue;
        return b.has(altValue) && !a.has(altValue);
      }
      function mapMightHaveLoosePrim(a, b, prim, item, memo) {
        var altValue = findLooseMatchingPrimitives(prim);
        if (altValue != null) {
          return altValue;
        }
        var curB = b.get(altValue);
        if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
          return false;
        }
        return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
      }
      function setEquiv(a, b, strict, memo) {
        var set = null;
        var aValues = arrayFromSet(a);
        for (var i = 0; i < aValues.length; i++) {
          var val = aValues[i];
          if (_typeof(val) === "object" && val !== null) {
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(val);
          } else if (!b.has(val)) {
            if (strict) return false;
            if (!setMightHaveLoosePrim(a, b, val)) {
              return false;
            }
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(val);
          }
        }
        if (set !== null) {
          var bValues = arrayFromSet(b);
          for (var _i = 0; _i < bValues.length; _i++) {
            var _val = bValues[_i];
            if (_typeof(_val) === "object" && _val !== null) {
              if (!setHasEqualElement(set, _val, strict, memo)) return false;
            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
              return false;
            }
          }
          return set.size === 0;
        }
        return true;
      }
      function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
        var setValues = arrayFromSet(set);
        for (var i = 0; i < setValues.length; i++) {
          var key2 = setValues[i];
          if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
            set.delete(key2);
            return true;
          }
        }
        return false;
      }
      function mapEquiv(a, b, strict, memo) {
        var set = null;
        var aEntries = arrayFromMap(a);
        for (var i = 0; i < aEntries.length; i++) {
          var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
          if (_typeof(key) === "object" && key !== null) {
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key);
          } else {
            var item2 = b.get(key);
            if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
              if (strict) return false;
              if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
              if (set === null) {
                set = /* @__PURE__ */ new Set();
              }
              set.add(key);
            }
          }
        }
        if (set !== null) {
          var bEntries = arrayFromMap(b);
          for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), _key = _bEntries$_i[0], item = _bEntries$_i[1];
            if (_typeof(_key) === "object" && _key !== null) {
              if (!mapHasEqualEntry(set, a, _key, item, strict, memo)) return false;
            } else if (!strict && (!a.has(_key) || !innerDeepEqual(a.get(_key), item, false, memo)) && !mapHasEqualEntry(set, a, _key, item, false, memo)) {
              return false;
            }
          }
          return set.size === 0;
        }
        return true;
      }
      function objEquiv(a, b, strict, keys, memos, iterationType) {
        var i = 0;
        if (iterationType === kIsSet) {
          if (!setEquiv(a, b, strict, memos)) {
            return false;
          }
        } else if (iterationType === kIsMap) {
          if (!mapEquiv(a, b, strict, memos)) {
            return false;
          }
        } else if (iterationType === kIsArray) {
          for (; i < a.length; i++) {
            if (hasOwnProperty2(a, i)) {
              if (!hasOwnProperty2(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                return false;
              }
            } else if (hasOwnProperty2(b, i)) {
              return false;
            } else {
              var keysA = Object.keys(a);
              for (; i < keysA.length; i++) {
                var key = keysA[i];
                if (!hasOwnProperty2(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                  return false;
                }
              }
              if (keysA.length !== Object.keys(b).length) {
                return false;
              }
              return true;
            }
          }
        }
        for (i = 0; i < keys.length; i++) {
          var _key2 = keys[i];
          if (!innerDeepEqual(a[_key2], b[_key2], strict, memos)) {
            return false;
          }
        }
        return true;
      }
      function isDeepEqual(val1, val2) {
        return innerDeepEqual(val1, val2, kLoose);
      }
      function isDeepStrictEqual(val1, val2) {
        return innerDeepEqual(val1, val2, kStrict);
      }
      module.exports = {
        isDeepEqual,
        isDeepStrictEqual
      };
    }
  });

  // node_modules/assert/build/assert.js
  var require_assert = __commonJS({
    "node_modules/assert/build/assert.js"(exports, module) {
      "use strict";
      function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
          return typeof o2;
        } : function(o2) {
          return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
        }, _typeof(o);
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return _typeof(key) === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (_typeof(input) !== "object" || input === null) return input;
        var prim = input[Symbol.toPrimitive];
        if (prim !== void 0) {
          var res = prim.call(input, hint || "default");
          if (_typeof(res) !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _require = require_errors();
      var _require$codes = _require.codes;
      var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
      var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var AssertionError = require_assertion_error();
      var _require2 = require_util();
      var inspect = _require2.inspect;
      var _require$types = require_util().types;
      var isPromise = _require$types.isPromise;
      var isRegExp = _require$types.isRegExp;
      var objectAssign = require_polyfill()();
      var objectIs = require_polyfill2()();
      var RegExpPrototypeTest = require_callBound()("RegExp.prototype.test");
      var isDeepEqual;
      var isDeepStrictEqual;
      function lazyLoadComparison() {
        var comparison = require_comparisons();
        isDeepEqual = comparison.isDeepEqual;
        isDeepStrictEqual = comparison.isDeepStrictEqual;
      }
      var warned = false;
      var assert = module.exports = ok;
      var NO_EXCEPTION_SENTINEL = {};
      function innerFail(obj) {
        if (obj.message instanceof Error) throw obj.message;
        throw new AssertionError(obj);
      }
      function fail(actual, expected, message, operator, stackStartFn) {
        var argsLen = arguments.length;
        var internalMessage;
        if (argsLen === 0) {
          internalMessage = "Failed";
        } else if (argsLen === 1) {
          message = actual;
          actual = void 0;
        } else {
          if (warned === false) {
            warned = true;
            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
            warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
          }
          if (argsLen === 2) operator = "!=";
        }
        if (message instanceof Error) throw message;
        var errArgs = {
          actual,
          expected,
          operator: operator === void 0 ? "fail" : operator,
          stackStartFn: stackStartFn || fail
        };
        if (message !== void 0) {
          errArgs.message = message;
        }
        var err = new AssertionError(errArgs);
        if (internalMessage) {
          err.message = internalMessage;
          err.generatedMessage = true;
        }
        throw err;
      }
      assert.fail = fail;
      assert.AssertionError = AssertionError;
      function innerOk(fn, argLen, value, message) {
        if (!value) {
          var generatedMessage = false;
          if (argLen === 0) {
            generatedMessage = true;
            message = "No value argument passed to `assert.ok()`";
          } else if (message instanceof Error) {
            throw message;
          }
          var err = new AssertionError({
            actual: value,
            expected: true,
            message,
            operator: "==",
            stackStartFn: fn
          });
          err.generatedMessage = generatedMessage;
          throw err;
        }
      }
      function ok() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        innerOk.apply(void 0, [ok, args.length].concat(args));
      }
      assert.ok = ok;
      assert.equal = function equal(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (actual != expected) {
          innerFail({
            actual,
            expected,
            message,
            operator: "==",
            stackStartFn: equal
          });
        }
      };
      assert.notEqual = function notEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (actual == expected) {
          innerFail({
            actual,
            expected,
            message,
            operator: "!=",
            stackStartFn: notEqual
          });
        }
      };
      assert.deepEqual = function deepEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0) lazyLoadComparison();
        if (!isDeepEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "deepEqual",
            stackStartFn: deepEqual
          });
        }
      };
      assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0) lazyLoadComparison();
        if (isDeepEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notDeepEqual",
            stackStartFn: notDeepEqual
          });
        }
      };
      assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0) lazyLoadComparison();
        if (!isDeepStrictEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "deepStrictEqual",
            stackStartFn: deepStrictEqual
          });
        }
      };
      assert.notDeepStrictEqual = notDeepStrictEqual;
      function notDeepStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (isDeepEqual === void 0) lazyLoadComparison();
        if (isDeepStrictEqual(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notDeepStrictEqual",
            stackStartFn: notDeepStrictEqual
          });
        }
      }
      assert.strictEqual = function strictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (!objectIs(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "strictEqual",
            stackStartFn: strictEqual
          });
        }
      };
      assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
        if (arguments.length < 2) {
          throw new ERR_MISSING_ARGS("actual", "expected");
        }
        if (objectIs(actual, expected)) {
          innerFail({
            actual,
            expected,
            message,
            operator: "notStrictEqual",
            stackStartFn: notStrictEqual
          });
        }
      };
      var Comparison = /* @__PURE__ */ _createClass(function Comparison2(obj, keys, actual) {
        var _this = this;
        _classCallCheck(this, Comparison2);
        keys.forEach(function(key) {
          if (key in obj) {
            if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && RegExpPrototypeTest(obj[key], actual[key])) {
              _this[key] = actual[key];
            } else {
              _this[key] = obj[key];
            }
          }
        });
      });
      function compareExceptionKey(actual, expected, key, message, keys, fn) {
        if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
          if (!message) {
            var a = new Comparison(actual, keys);
            var b = new Comparison(expected, keys, actual);
            var err = new AssertionError({
              actual: a,
              expected: b,
              operator: "deepStrictEqual",
              stackStartFn: fn
            });
            err.actual = actual;
            err.expected = expected;
            err.operator = fn.name;
            throw err;
          }
          innerFail({
            actual,
            expected,
            message,
            operator: fn.name,
            stackStartFn: fn
          });
        }
      }
      function expectedException(actual, expected, msg, fn) {
        if (typeof expected !== "function") {
          if (isRegExp(expected)) return RegExpPrototypeTest(expected, actual);
          if (arguments.length === 2) {
            throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
          }
          if (_typeof(actual) !== "object" || actual === null) {
            var err = new AssertionError({
              actual,
              expected,
              message: msg,
              operator: "deepStrictEqual",
              stackStartFn: fn
            });
            err.operator = fn.name;
            throw err;
          }
          var keys = Object.keys(expected);
          if (expected instanceof Error) {
            keys.push("name", "message");
          } else if (keys.length === 0) {
            throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
          }
          if (isDeepEqual === void 0) lazyLoadComparison();
          keys.forEach(function(key) {
            if (typeof actual[key] === "string" && isRegExp(expected[key]) && RegExpPrototypeTest(expected[key], actual[key])) {
              return;
            }
            compareExceptionKey(actual, expected, key, msg, keys, fn);
          });
          return true;
        }
        if (expected.prototype !== void 0 && actual instanceof expected) {
          return true;
        }
        if (Error.isPrototypeOf(expected)) {
          return false;
        }
        return expected.call({}, actual) === true;
      }
      function getActual(fn) {
        if (typeof fn !== "function") {
          throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
        }
        try {
          fn();
        } catch (e) {
          return e;
        }
        return NO_EXCEPTION_SENTINEL;
      }
      function checkIsPromise(obj) {
        return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
      }
      function waitForActual(promiseFn) {
        return Promise.resolve().then(function() {
          var resultPromise;
          if (typeof promiseFn === "function") {
            resultPromise = promiseFn();
            if (!checkIsPromise(resultPromise)) {
              throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
            }
          } else if (checkIsPromise(promiseFn)) {
            resultPromise = promiseFn;
          } else {
            throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
          }
          return Promise.resolve().then(function() {
            return resultPromise;
          }).then(function() {
            return NO_EXCEPTION_SENTINEL;
          }).catch(function(e) {
            return e;
          });
        });
      }
      function expectsError(stackStartFn, actual, error, message) {
        if (typeof error === "string") {
          if (arguments.length === 4) {
            throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
          }
          if (_typeof(actual) === "object" && actual !== null) {
            if (actual.message === error) {
              throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
            }
          } else if (actual === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
          }
          message = error;
          error = void 0;
        } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
        }
        if (actual === NO_EXCEPTION_SENTINEL) {
          var details = "";
          if (error && error.name) {
            details += " (".concat(error.name, ")");
          }
          details += message ? ": ".concat(message) : ".";
          var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
          innerFail({
            actual: void 0,
            expected: error,
            operator: stackStartFn.name,
            message: "Missing expected ".concat(fnType).concat(details),
            stackStartFn
          });
        }
        if (error && !expectedException(actual, error, message, stackStartFn)) {
          throw actual;
        }
      }
      function expectsNoError(stackStartFn, actual, error, message) {
        if (actual === NO_EXCEPTION_SENTINEL) return;
        if (typeof error === "string") {
          message = error;
          error = void 0;
        }
        if (!error || expectedException(actual, error)) {
          var details = message ? ": ".concat(message) : ".";
          var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
          innerFail({
            actual,
            expected: error,
            operator: stackStartFn.name,
            message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
            stackStartFn
          });
        }
        throw actual;
      }
      assert.throws = function throws(promiseFn) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
      };
      assert.rejects = function rejects(promiseFn) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        return waitForActual(promiseFn).then(function(result) {
          return expectsError.apply(void 0, [rejects, result].concat(args));
        });
      };
      assert.doesNotThrow = function doesNotThrow(fn) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
      };
      assert.doesNotReject = function doesNotReject(fn) {
        for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          args[_key5 - 1] = arguments[_key5];
        }
        return waitForActual(fn).then(function(result) {
          return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
        });
      };
      assert.ifError = function ifError(err) {
        if (err !== null && err !== void 0) {
          var message = "ifError got unwanted exception: ";
          if (_typeof(err) === "object" && typeof err.message === "string") {
            if (err.message.length === 0 && err.constructor) {
              message += err.constructor.name;
            } else {
              message += err.message;
            }
          } else {
            message += inspect(err);
          }
          var newErr = new AssertionError({
            actual: err,
            expected: null,
            operator: "ifError",
            message,
            stackStartFn: ifError
          });
          var origStack = err.stack;
          if (typeof origStack === "string") {
            var tmp2 = origStack.split("\n");
            tmp2.shift();
            var tmp1 = newErr.stack.split("\n");
            for (var i = 0; i < tmp2.length; i++) {
              var pos = tmp1.indexOf(tmp2[i]);
              if (pos !== -1) {
                tmp1 = tmp1.slice(0, pos);
                break;
              }
            }
            newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
          }
          throw newErr;
        }
      };
      function internalMatch(string, regexp, message, fn, fnName) {
        if (!isRegExp(regexp)) {
          throw new ERR_INVALID_ARG_TYPE("regexp", "RegExp", regexp);
        }
        var match = fnName === "match";
        if (typeof string !== "string" || RegExpPrototypeTest(regexp, string) !== match) {
          if (message instanceof Error) {
            throw message;
          }
          var generatedMessage = !message;
          message = message || (typeof string !== "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(_typeof(string), " (").concat(inspect(string), ")") : (match ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(inspect(regexp), ". Input:\n\n").concat(inspect(string), "\n"));
          var err = new AssertionError({
            actual: string,
            expected: regexp,
            message,
            operator: fnName,
            stackStartFn: fn
          });
          err.generatedMessage = generatedMessage;
          throw err;
        }
      }
      assert.match = function match(string, regexp, message) {
        internalMatch(string, regexp, message, match, "match");
      };
      assert.doesNotMatch = function doesNotMatch(string, regexp, message) {
        internalMatch(string, regexp, message, doesNotMatch, "doesNotMatch");
      };
      function strict() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        innerOk.apply(void 0, [strict, args.length].concat(args));
      }
      assert.strict = objectAssign(strict, assert, {
        equal: assert.strictEqual,
        deepEqual: assert.deepStrictEqual,
        notEqual: assert.notStrictEqual,
        notDeepEqual: assert.notDeepStrictEqual
      });
      assert.strict.strict = assert.strict;
    }
  });

  // node_modules/svg-path-bounds/index.js
  var require_svg_path_bounds = __commonJS({
    "node_modules/svg-path-bounds/index.js"(exports, module) {
      "use strict";
      var parse2 = require_parse_svg_path();
      var abs = require_abs_svg_path();
      var normalize = require_normalize_svg_path();
      var isSvgPath = require_is_svg_path();
      var assert = require_assert();
      module.exports = pathBounds;
      function pathBounds(path) {
        if (Array.isArray(path) && path.length === 1 && typeof path[0] === "string") path = path[0];
        if (typeof path === "string") {
          assert(isSvgPath(path), "String is not an SVG path.");
          path = parse2(path);
        }
        assert(Array.isArray(path), "Argument should be a string or an array of path segments.");
        path = abs(path);
        path = normalize(path);
        if (!path.length) return [0, 0, 0, 0];
        var bounds = [Infinity, Infinity, -Infinity, -Infinity];
        for (var i = 0, l = path.length; i < l; i++) {
          var points = path[i].slice(1);
          for (var j = 0; j < points.length; j += 2) {
            if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];
            if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];
            if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];
            if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];
          }
        }
        return bounds;
      }
    }
  });

  // node_modules/normalize-svg-path/index.js
  var require_normalize_svg_path2 = __commonJS({
    "node_modules/normalize-svg-path/index.js"(exports, module) {
      var \u03C0 = Math.PI;
      var _120 = radians(120);
      module.exports = normalize;
      function normalize(path) {
        var prev;
        var result = [];
        var bezierX = 0;
        var bezierY = 0;
        var startX = 0;
        var startY = 0;
        var quadX = null;
        var quadY = null;
        var x = 0;
        var y = 0;
        for (var i = 0, len = path.length; i < len; i++) {
          var seg = path[i];
          var command = seg[0];
          switch (command) {
            case "M":
              startX = seg[1];
              startY = seg[2];
              break;
            case "A":
              seg = arc(x, y, seg[1], seg[2], radians(seg[3]), seg[4], seg[5], seg[6], seg[7]);
              seg.unshift("C");
              if (seg.length > 7) {
                result.push(seg.splice(0, 7));
                seg.unshift("C");
              }
              break;
            case "S":
              var cx = x;
              var cy = y;
              if (prev == "C" || prev == "S") {
                cx += cx - bezierX;
                cy += cy - bezierY;
              }
              seg = ["C", cx, cy, seg[1], seg[2], seg[3], seg[4]];
              break;
            case "T":
              if (prev == "Q" || prev == "T") {
                quadX = x * 2 - quadX;
                quadY = y * 2 - quadY;
              } else {
                quadX = x;
                quadY = y;
              }
              seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);
              break;
            case "Q":
              quadX = seg[1];
              quadY = seg[2];
              seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);
              break;
            case "L":
              seg = line(x, y, seg[1], seg[2]);
              break;
            case "H":
              seg = line(x, y, seg[1], y);
              break;
            case "V":
              seg = line(x, y, x, seg[1]);
              break;
            case "Z":
              seg = line(x, y, startX, startY);
              break;
          }
          prev = command;
          x = seg[seg.length - 2];
          y = seg[seg.length - 1];
          if (seg.length > 4) {
            bezierX = seg[seg.length - 4];
            bezierY = seg[seg.length - 3];
          } else {
            bezierX = x;
            bezierY = y;
          }
          result.push(seg);
        }
        return result;
      }
      function line(x1, y1, x2, y2) {
        return ["C", x1, y1, x2, y2, x2, y2];
      }
      function quadratic(x1, y1, cx, cy, x2, y2) {
        return [
          "C",
          x1 / 3 + 2 / 3 * cx,
          y1 / 3 + 2 / 3 * cy,
          x2 / 3 + 2 / 3 * cx,
          y2 / 3 + 2 / 3 * cy,
          x2,
          y2
        ];
      }
      function arc(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        if (!recursive) {
          var xy = rotate(x1, y1, -angle);
          x1 = xy.x;
          y1 = xy.y;
          xy = rotate(x2, y2, -angle);
          x2 = xy.x;
          y2 = xy.y;
          var x = (x1 - x2) / 2;
          var y = (y1 - y2) / 2;
          var h = x * x / (rx * rx) + y * y / (ry * ry);
          if (h > 1) {
            h = Math.sqrt(h);
            rx = h * rx;
            ry = h * ry;
          }
          var rx2 = rx * rx;
          var ry2 = ry * ry;
          var k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
          if (k == Infinity) k = 1;
          var cx = k * rx * y / ry + (x1 + x2) / 2;
          var cy = k * -ry * x / rx + (y1 + y2) / 2;
          var f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
          var f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
          f1 = x1 < cx ? \u03C0 - f1 : f1;
          f2 = x2 < cx ? \u03C0 - f2 : f2;
          if (f1 < 0) f1 = \u03C0 * 2 + f1;
          if (f2 < 0) f2 = \u03C0 * 2 + f2;
          if (sweep_flag && f1 > f2) f1 = f1 - \u03C0 * 2;
          if (!sweep_flag && f2 > f1) f2 = f2 - \u03C0 * 2;
        } else {
          f1 = recursive[0];
          f2 = recursive[1];
          cx = recursive[2];
          cy = recursive[3];
        }
        if (Math.abs(f2 - f1) > _120) {
          var f2old = f2;
          var x2old = x2;
          var y2old = y2;
          f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
          x2 = cx + rx * Math.cos(f2);
          y2 = cy + ry * Math.sin(f2);
          var res = arc(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        var t = Math.tan((f2 - f1) / 4);
        var hx = 4 / 3 * rx * t;
        var hy = 4 / 3 * ry * t;
        var curve = [
          2 * x1 - (x1 + hx * Math.sin(f1)),
          2 * y1 - (y1 - hy * Math.cos(f1)),
          x2 + hx * Math.sin(f2),
          y2 - hy * Math.cos(f2),
          x2,
          y2
        ];
        if (recursive) return curve;
        if (res) curve = curve.concat(res);
        for (var i = 0; i < curve.length; ) {
          var rot = rotate(curve[i], curve[i + 1], angle);
          curve[i++] = rot.x;
          curve[i++] = rot.y;
        }
        return curve;
      }
      function rotate(x, y, rad) {
        return {
          x: x * Math.cos(rad) - y * Math.sin(rad),
          y: x * Math.sin(rad) + y * Math.cos(rad)
        };
      }
      function radians(degress) {
        return degress * (\u03C0 / 180);
      }
    }
  });

  // node_modules/draw-svg-path/index.js
  var require_draw_svg_path = __commonJS({
    "node_modules/draw-svg-path/index.js"(exports, module) {
      var abs = require_abs_svg_path();
      var normalize = require_normalize_svg_path2();
      var methods = {
        "M": "moveTo",
        "C": "bezierCurveTo"
      };
      module.exports = function(context, segments) {
        context.beginPath();
        normalize(abs(segments)).forEach(
          function(segment) {
            var command = segment[0];
            var args = segment.slice(1);
            context[methods[command]].apply(context, args);
          }
        );
        context.closePath();
      };
    }
  });

  // node_modules/bitmap-sdf/index.js
  var require_bitmap_sdf = __commonJS({
    "node_modules/bitmap-sdf/index.js"(exports, module) {
      "use strict";
      var clamp = require_clamp();
      module.exports = calcSDF;
      var INF = 1e20;
      function calcSDF(src, options) {
        if (!options) options = {};
        var cutoff = options.cutoff == null ? 0.25 : options.cutoff;
        var radius = options.radius == null ? 8 : options.radius;
        var channel = options.channel || 0;
        var w, h, size, data, intData, stride, ctx, canvas, imgData, i, l;
        if (ArrayBuffer.isView(src) || Array.isArray(src)) {
          if (!options.width || !options.height) throw Error("For raw data width and height should be provided by options");
          w = options.width, h = options.height;
          data = src;
          if (!options.stride) stride = Math.floor(src.length / w / h);
          else stride = options.stride;
        } else {
          if (window.HTMLCanvasElement && src instanceof window.HTMLCanvasElement) {
            canvas = src;
            ctx = canvas.getContext("2d");
            w = canvas.width, h = canvas.height;
            imgData = ctx.getImageData(0, 0, w, h);
            data = imgData.data;
            stride = 4;
          } else if (window.CanvasRenderingContext2D && src instanceof window.CanvasRenderingContext2D) {
            canvas = src.canvas;
            ctx = src;
            w = canvas.width, h = canvas.height;
            imgData = ctx.getImageData(0, 0, w, h);
            data = imgData.data;
            stride = 4;
          } else if (window.ImageData && src instanceof window.ImageData) {
            imgData = src;
            w = src.width, h = src.height;
            data = imgData.data;
            stride = 4;
          }
        }
        size = Math.max(w, h);
        if (window.Uint8ClampedArray && data instanceof window.Uint8ClampedArray || window.Uint8Array && data instanceof window.Uint8Array) {
          intData = data;
          data = Array(w * h);
          for (i = 0, l = intData.length; i < l; i++) {
            data[i] = intData[i * stride + channel] / 255;
          }
        } else {
          if (stride !== 1) throw Error("Raw data can have only 1 value per pixel");
        }
        var gridOuter = Array(w * h);
        var gridInner = Array(w * h);
        var f = Array(size);
        var d = Array(size);
        var z = Array(size + 1);
        var v = Array(size);
        for (i = 0, l = w * h; i < l; i++) {
          var a = data[i];
          gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);
          gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);
        }
        edt(gridOuter, w, h, f, d, v, z);
        edt(gridInner, w, h, f, d, v, z);
        var dist = window.Float32Array ? new Float32Array(w * h) : new Array(w * h);
        for (i = 0, l = w * h; i < l; i++) {
          dist[i] = clamp(1 - ((gridOuter[i] - gridInner[i]) / radius + cutoff), 0, 1);
        }
        return dist;
      }
      function edt(data, width, height, f, d, v, z) {
        for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
            f[y] = data[y * width + x];
          }
          edt1d(f, d, v, z, height);
          for (y = 0; y < height; y++) {
            data[y * width + x] = d[y];
          }
        }
        for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
            f[x] = data[y * width + x];
          }
          edt1d(f, d, v, z, width);
          for (x = 0; x < width; x++) {
            data[y * width + x] = Math.sqrt(d[x]);
          }
        }
      }
      function edt1d(f, d, v, z, n) {
        v[0] = 0;
        z[0] = -INF;
        z[1] = +INF;
        for (var q = 1, k = 0; q < n; q++) {
          var s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
          while (s <= z[k]) {
            k--;
            s = (f[q] + q * q - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
          }
          k++;
          v[k] = q;
          z[k] = s;
          z[k + 1] = +INF;
        }
        for (q = 0, k = 0; q < n; q++) {
          while (z[k + 1] < q) k++;
          d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];
        }
      }
    }
  });

  // node_modules/svg-path-sdf/index.js
  var require_svg_path_sdf = __commonJS({
    "node_modules/svg-path-sdf/index.js"(exports, module) {
      "use strict";
      var pathBounds = require_svg_path_bounds();
      var parsePath = require_parse_svg_path();
      var drawPath = require_draw_svg_path();
      var isSvgPath = require_is_svg_path();
      var bitmapSdf = require_bitmap_sdf();
      var canvas = document.createElement("canvas");
      var ctx = canvas.getContext("2d");
      module.exports = pathSdf;
      function pathSdf(path, options) {
        if (!isSvgPath(path)) throw Error("Argument should be valid svg path string");
        if (!options) options = {};
        var w, h;
        if (options.shape) {
          w = options.shape[0];
          h = options.shape[1];
        } else {
          w = canvas.width = options.w || options.width || 200;
          h = canvas.height = options.h || options.height || 200;
        }
        var size = Math.min(w, h);
        var stroke = options.stroke || 0;
        var viewbox = options.viewbox || options.viewBox || pathBounds(path);
        var scale = [w / (viewbox[2] - viewbox[0]), h / (viewbox[3] - viewbox[1])];
        var maxScale = Math.min(scale[0] || 0, scale[1] || 0) / 2;
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = "white";
        if (stroke) {
          if (typeof stroke != "number") stroke = 1;
          if (stroke > 0) {
            ctx.strokeStyle = "white";
          } else {
            ctx.strokeStyle = "black";
          }
          ctx.lineWidth = Math.abs(stroke);
        }
        ctx.translate(w * 0.5, h * 0.5);
        ctx.scale(maxScale, maxScale);
        if (isPath2DSupported()) {
          var path2d = new Path2D(path);
          ctx.fill(path2d);
          stroke && ctx.stroke(path2d);
        } else {
          var segments = parsePath(path);
          drawPath(ctx, segments);
          ctx.fill();
          stroke && ctx.stroke();
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        var data = bitmapSdf(ctx, {
          cutoff: options.cutoff != null ? options.cutoff : 0.5,
          radius: options.radius != null ? options.radius : size * 0.5
        });
        return data;
      }
      var path2DSupported;
      function isPath2DSupported() {
        if (path2DSupported != null) return path2DSupported;
        var ctx2 = document.createElement("canvas").getContext("2d");
        ctx2.canvas.width = ctx2.canvas.height = 1;
        if (!window.Path2D) return path2DSupported = false;
        var path = new Path2D("M0,0h1v1h-1v-1Z");
        ctx2.fillStyle = "black";
        ctx2.fill(path);
        var idata = ctx2.getImageData(0, 0, 1, 1);
        return path2DSupported = idata && idata.data && idata.data[3] === 255;
      }
    }
  });

  // node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // node_modules/color-normalize/node_modules/color-parse/index.js
  var require_color_parse = __commonJS({
    "node_modules/color-normalize/node_modules/color-parse/index.js"(exports, module) {
      "use strict";
      var names2 = require_color_name();
      module.exports = parse2;
      var baseHues2 = {
        red: 0,
        orange: 60,
        yellow: 120,
        green: 180,
        blue: 240,
        purple: 300
      };
      function parse2(cstr) {
        var m, parts = [], alpha = 1, space;
        if (typeof cstr === "string") {
          cstr = cstr.toLowerCase();
          if (names2[cstr]) {
            parts = names2[cstr].slice();
            space = "rgb";
          } else if (cstr === "transparent") {
            alpha = 0;
            space = "rgb";
            parts = [0, 0, 0];
          } else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
            var base = cstr.slice(1);
            var size = base.length;
            var isShort = size <= 4;
            alpha = 1;
            if (isShort) {
              parts = [
                parseInt(base[0] + base[0], 16),
                parseInt(base[1] + base[1], 16),
                parseInt(base[2] + base[2], 16)
              ];
              if (size === 4) {
                alpha = parseInt(base[3] + base[3], 16) / 255;
              }
            } else {
              parts = [
                parseInt(base[0] + base[1], 16),
                parseInt(base[2] + base[3], 16),
                parseInt(base[4] + base[5], 16)
              ];
              if (size === 8) {
                alpha = parseInt(base[6] + base[7], 16) / 255;
              }
            }
            if (!parts[0]) parts[0] = 0;
            if (!parts[1]) parts[1] = 0;
            if (!parts[2]) parts[2] = 0;
            space = "rgb";
          } else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
            var name = m[1];
            var isRGB = name === "rgb";
            var base = name.replace(/a$/, "");
            space = base;
            var size = base === "cmyk" ? 4 : base === "gray" ? 1 : 3;
            parts = m[2].trim().split(/\s*[,\/]\s*|\s+/).map(function(x, i) {
              if (/%$/.test(x)) {
                if (i === size) return parseFloat(x) / 100;
                if (base === "rgb") return parseFloat(x) * 255 / 100;
                return parseFloat(x);
              } else if (base[i] === "h") {
                if (/deg$/.test(x)) {
                  return parseFloat(x);
                } else if (baseHues2[x] !== void 0) {
                  return baseHues2[x];
                }
              }
              return parseFloat(x);
            });
            if (name === base) parts.push(1);
            alpha = isRGB ? 1 : parts[size] === void 0 ? 1 : parts[size];
            parts = parts.slice(0, size);
          } else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
            parts = cstr.match(/([0-9]+)/g).map(function(value) {
              return parseFloat(value);
            });
            space = cstr.match(/([a-z])/ig).join("").toLowerCase();
          }
        } else if (!isNaN(cstr)) {
          space = "rgb";
          parts = [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255];
        } else if (Array.isArray(cstr) || cstr.length) {
          parts = [cstr[0], cstr[1], cstr[2]];
          space = "rgb";
          alpha = cstr.length === 4 ? cstr[3] : 1;
        } else if (cstr instanceof Object) {
          if (cstr.r != null || cstr.red != null || cstr.R != null) {
            space = "rgb";
            parts = [
              cstr.r || cstr.red || cstr.R || 0,
              cstr.g || cstr.green || cstr.G || 0,
              cstr.b || cstr.blue || cstr.B || 0
            ];
          } else {
            space = "hsl";
            parts = [
              cstr.h || cstr.hue || cstr.H || 0,
              cstr.s || cstr.saturation || cstr.S || 0,
              cstr.l || cstr.lightness || cstr.L || cstr.b || cstr.brightness
            ];
          }
          alpha = cstr.a || cstr.alpha || cstr.opacity || 1;
          if (cstr.opacity != null) alpha /= 100;
        }
        return {
          space,
          values: parts,
          alpha
        };
      }
    }
  });

  // node_modules/color-normalize/node_modules/color-rgba/index.js
  var require_color_rgba = __commonJS({
    "node_modules/color-normalize/node_modules/color-rgba/index.js"(exports, module) {
      "use strict";
      var parse2 = require_color_parse();
      module.exports = function rgba2(color) {
        if (Array.isArray(color) && color.raw) color = String.raw.apply(null, arguments);
        var values, i, l;
        var parsed = parse2(color);
        if (!parsed.space) return [];
        var min = [0, 0, 0], max = parsed.space[0] === "h" ? [360, 100, 100] : [255, 255, 255];
        values = Array(3);
        values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
        values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
        values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);
        if (parsed.space[0] === "h") values = hsl2rgb(values);
        values.push(Math.min(Math.max(parsed.alpha, 0), 1));
        return values;
      };
      function hsl2rgb(hsl) {
        var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val, i = 0;
        if (s === 0) return val = l * 255, [val, val, val];
        t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
        t1 = 2 * l - t2;
        rgb = [0, 0, 0];
        for (; i < 3; ) {
          t3 = h + 1 / 3 * -(i - 1);
          t3 < 0 ? t3++ : t3 > 1 && t3--;
          val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
          rgb[i++] = val * 255;
        }
        return rgb;
      }
    }
  });

  // node_modules/color-normalize/index.js
  var require_color_normalize = __commonJS({
    "node_modules/color-normalize/index.js"(exports, module) {
      "use strict";
      var rgba2 = require_color_rgba();
      var clamp = require_clamp();
      var dtype = require_dtype();
      module.exports = function normalize(color, type) {
        if (type === "float" || !type) type = "array";
        if (type === "uint") type = "uint8";
        if (type === "uint_clamped") type = "uint8_clamped";
        var Ctor = dtype(type);
        var output = new Ctor(4);
        var normalize2 = type !== "uint8" && type !== "uint8_clamped";
        if (!color.length || typeof color === "string") {
          color = rgba2(color);
          color[0] /= 255;
          color[1] /= 255;
          color[2] /= 255;
        }
        if (isInt(color)) {
          output[0] = color[0];
          output[1] = color[1];
          output[2] = color[2];
          output[3] = color[3] != null ? color[3] : 255;
          if (normalize2) {
            output[0] /= 255;
            output[1] /= 255;
            output[2] /= 255;
            output[3] /= 255;
          }
          return output;
        }
        if (!normalize2) {
          output[0] = clamp(Math.floor(color[0] * 255), 0, 255);
          output[1] = clamp(Math.floor(color[1] * 255), 0, 255);
          output[2] = clamp(Math.floor(color[2] * 255), 0, 255);
          output[3] = color[3] == null ? 255 : clamp(Math.floor(color[3] * 255), 0, 255);
        } else {
          output[0] = color[0];
          output[1] = color[1];
          output[2] = color[2];
          output[3] = color[3] != null ? color[3] : 1;
        }
        return output;
      };
      function isInt(color) {
        if (color instanceof Uint8Array || color instanceof Uint8ClampedArray) return true;
        if (Array.isArray(color) && (color[0] > 1 || color[0] === 0) && (color[1] > 1 || color[1] === 0) && (color[2] > 1 || color[2] === 0) && (!color[3] || color[3] > 1)) return true;
        return false;
      }
    }
  });

  // src/lib/gl_format_color.js
  var require_gl_format_color = __commonJS({
    "src/lib/gl_format_color.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var tinycolor = require_tinycolor();
      var rgba2 = require_color_normalize();
      var Colorscale = require_colorscale();
      var colorDflt = require_attributes3().defaultLine;
      var isArrayOrTypedArray = require_array().isArrayOrTypedArray;
      var colorDfltRgba = rgba2(colorDflt);
      var opacityDflt = 1;
      function calculateColor(colorIn, opacityIn) {
        var colorOut = colorIn;
        colorOut[3] *= opacityIn;
        return colorOut;
      }
      function validateColor(colorIn) {
        if (isNumeric(colorIn)) return colorDfltRgba;
        var colorOut = rgba2(colorIn);
        return colorOut.length ? colorOut : colorDfltRgba;
      }
      function validateOpacity(opacityIn) {
        return isNumeric(opacityIn) ? opacityIn : opacityDflt;
      }
      function formatColor(containerIn, opacityIn, len) {
        var colorIn = containerIn.color;
        if (colorIn && colorIn._inputArray) colorIn = colorIn._inputArray;
        var isArrayColorIn = isArrayOrTypedArray(colorIn);
        var isArrayOpacityIn = isArrayOrTypedArray(opacityIn);
        var cOpts = Colorscale.extractOpts(containerIn);
        var colorOut = [];
        var sclFunc, getColor, getOpacity, colori, opacityi;
        if (cOpts.colorscale !== void 0) {
          sclFunc = Colorscale.makeColorScaleFuncFromTrace(containerIn);
        } else {
          sclFunc = validateColor;
        }
        if (isArrayColorIn) {
          getColor = function(c, i2) {
            return c[i2] === void 0 ? colorDfltRgba : rgba2(sclFunc(c[i2]));
          };
        } else getColor = validateColor;
        if (isArrayOpacityIn) {
          getOpacity = function(o, i2) {
            return o[i2] === void 0 ? opacityDflt : validateOpacity(o[i2]);
          };
        } else getOpacity = validateOpacity;
        if (isArrayColorIn || isArrayOpacityIn) {
          for (var i = 0; i < len; i++) {
            colori = getColor(colorIn, i);
            opacityi = getOpacity(opacityIn, i);
            colorOut[i] = calculateColor(colori, opacityi);
          }
        } else colorOut = calculateColor(rgba2(colorIn), opacityIn);
        return colorOut;
      }
      function parseColorScale(cont) {
        var cOpts = Colorscale.extractOpts(cont);
        var colorscale = cOpts.colorscale;
        if (cOpts.reversescale) colorscale = Colorscale.flipScale(cOpts.colorscale);
        return colorscale.map(function(elem) {
          var index = elem[0];
          var color = tinycolor(elem[1]);
          var rgb = color.toRgb();
          return {
            index,
            rgb: [rgb.r, rgb.g, rgb.b, rgb.a]
          };
        });
      }
      module.exports = {
        formatColor,
        parseColorScale
      };
    }
  });

  // src/traces/scattergl/convert.js
  var require_convert2 = __commonJS({
    "src/traces/scattergl/convert.js"(exports, module) {
      "use strict";
      var isNumeric = require_fast_isnumeric();
      var svgSdf = require_svg_path_sdf();
      var rgba2 = require_color_normalize();
      var Registry = require_registry();
      var Lib = require_lib();
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var Drawing = require_drawing();
      var AxisIDs = require_axis_ids();
      var formatColor = require_gl_format_color().formatColor;
      var subTypes = require_subtypes();
      var makeBubbleSizeFn = require_make_bubble_size_func();
      var helpers = require_helpers12();
      var constants = require_constants14();
      var DESELECTDIM = require_interactions().DESELECTDIM;
      var TEXTOFFSETSIGN = {
        start: 1,
        left: 1,
        end: -1,
        right: -1,
        middle: 0,
        center: 0,
        bottom: 1,
        top: -1
      };
      var appendArrayPointValue = require_helpers2().appendArrayPointValue;
      function convertStyle(gd, trace) {
        var i;
        var opts = {
          marker: void 0,
          markerSel: void 0,
          markerUnsel: void 0,
          line: void 0,
          fill: void 0,
          errorX: void 0,
          errorY: void 0,
          text: void 0,
          textSel: void 0,
          textUnsel: void 0
        };
        var plotGlPixelRatio = gd._context.plotGlPixelRatio;
        if (trace.visible !== true) return opts;
        if (subTypes.hasText(trace)) {
          opts.text = convertTextStyle(gd, trace);
          opts.textSel = convertTextSelection(gd, trace, trace.selected);
          opts.textUnsel = convertTextSelection(gd, trace, trace.unselected);
        }
        if (subTypes.hasMarkers(trace)) {
          opts.marker = convertMarkerStyle(gd, trace);
          opts.markerSel = convertMarkerSelection(gd, trace, trace.selected);
          opts.markerUnsel = convertMarkerSelection(gd, trace, trace.unselected);
          if (!trace.unselected && isArrayOrTypedArray(trace.marker.opacity)) {
            var mo = trace.marker.opacity;
            opts.markerUnsel.opacity = new Array(mo.length);
            for (i = 0; i < mo.length; i++) {
              opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];
            }
          }
        }
        if (subTypes.hasLines(trace)) {
          opts.line = {
            overlay: true,
            thickness: trace.line.width * plotGlPixelRatio,
            color: trace.line.color,
            opacity: trace.opacity
          };
          var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();
          for (i = 0; i < dashes.length; ++i) {
            dashes[i] *= trace.line.width * plotGlPixelRatio;
          }
          opts.line.dashes = dashes;
        }
        if (trace.error_x && trace.error_x.visible) {
          opts.errorX = convertErrorBarStyle(trace, trace.error_x, plotGlPixelRatio);
        }
        if (trace.error_y && trace.error_y.visible) {
          opts.errorY = convertErrorBarStyle(trace, trace.error_y, plotGlPixelRatio);
        }
        if (!!trace.fill && trace.fill !== "none") {
          opts.fill = {
            closed: true,
            fill: trace.fillcolor,
            thickness: 0
          };
        }
        return opts;
      }
      function convertTextStyle(gd, trace) {
        var fullLayout = gd._fullLayout;
        var count = trace._length;
        var textfontIn = trace.textfont;
        var textpositionIn = trace.textposition;
        var textPos = isArrayOrTypedArray(textpositionIn) ? textpositionIn : [textpositionIn];
        var tfc = textfontIn.color;
        var tfs = textfontIn.size;
        var tff = textfontIn.family;
        var tfw = textfontIn.weight;
        var tfy = textfontIn.style;
        var tfv = textfontIn.variant;
        var optsOut = {};
        var i;
        var plotGlPixelRatio = gd._context.plotGlPixelRatio;
        var texttemplate = trace.texttemplate;
        if (texttemplate) {
          optsOut.text = [];
          var d3locale = fullLayout._d3locale;
          var isArray = Array.isArray(texttemplate);
          var N = isArray ? Math.min(texttemplate.length, count) : count;
          var txt = isArray ? function(i2) {
            return texttemplate[i2];
          } : function() {
            return texttemplate;
          };
          for (i = 0; i < N; i++) {
            var d = { i };
            var labels = trace._module.formatLabels(d, trace, fullLayout);
            var pointValues = {};
            appendArrayPointValue(pointValues, trace, i);
            var meta = trace._meta || {};
            optsOut.text.push(Lib.texttemplateString(txt(i), labels, d3locale, pointValues, d, meta));
          }
        } else {
          if (isArrayOrTypedArray(trace.text) && trace.text.length < count) {
            optsOut.text = trace.text.slice();
          } else {
            optsOut.text = trace.text;
          }
        }
        if (isArrayOrTypedArray(optsOut.text)) {
          for (i = optsOut.text.length; i < count; i++) {
            optsOut.text[i] = "";
          }
        }
        optsOut.opacity = trace.opacity;
        optsOut.font = {};
        optsOut.align = [];
        optsOut.baseline = [];
        for (i = 0; i < textPos.length; i++) {
          var tp = textPos[i].split(/\s+/);
          switch (tp[1]) {
            case "left":
              optsOut.align.push("right");
              break;
            case "right":
              optsOut.align.push("left");
              break;
            default:
              optsOut.align.push(tp[1]);
          }
          switch (tp[0]) {
            case "top":
              optsOut.baseline.push("bottom");
              break;
            case "bottom":
              optsOut.baseline.push("top");
              break;
            default:
              optsOut.baseline.push(tp[0]);
          }
        }
        if (isArrayOrTypedArray(tfc)) {
          optsOut.color = new Array(count);
          for (i = 0; i < count; i++) {
            optsOut.color[i] = tfc[i];
          }
        } else {
          optsOut.color = tfc;
        }
        if (isArrayOrTypedArray(tfs) || Array.isArray(tff) || isArrayOrTypedArray(tfw) || Array.isArray(tfy) || Array.isArray(tfv)) {
          optsOut.font = new Array(count);
          for (i = 0; i < count; i++) {
            var fonti = optsOut.font[i] = {};
            fonti.size = (Lib.isTypedArray(tfs) ? tfs[i] : isArrayOrTypedArray(tfs) ? isNumeric(tfs[i]) ? tfs[i] : 0 : tfs) * plotGlPixelRatio;
            fonti.family = Array.isArray(tff) ? tff[i] : tff;
            fonti.weight = weightFallBack(isArrayOrTypedArray(tfw) ? tfw[i] : tfw);
            fonti.style = Array.isArray(tfy) ? tfy[i] : tfy;
            fonti.variant = Array.isArray(tfv) ? tfv[i] : tfv;
          }
        } else {
          optsOut.font = {
            size: tfs * plotGlPixelRatio,
            family: tff,
            weight: weightFallBack(tfw),
            style: tfy,
            variant: tfv
          };
        }
        return optsOut;
      }
      function weightFallBack(w) {
        if (w <= 1e3) {
          return w > 500 ? "bold" : "normal";
        }
        return w;
      }
      function convertMarkerStyle(gd, trace) {
        var count = trace._length;
        var optsIn = trace.marker;
        var optsOut = {};
        var i;
        var multiSymbol = isArrayOrTypedArray(optsIn.symbol);
        var multiAngle = isArrayOrTypedArray(optsIn.angle);
        var multiColor = isArrayOrTypedArray(optsIn.color);
        var multiLineColor = isArrayOrTypedArray(optsIn.line.color);
        var multiOpacity = isArrayOrTypedArray(optsIn.opacity);
        var multiSize = isArrayOrTypedArray(optsIn.size);
        var multiLineWidth = isArrayOrTypedArray(optsIn.line.width);
        var isOpen;
        if (!multiSymbol) isOpen = helpers.isOpenSymbol(optsIn.symbol);
        if (multiSymbol || multiColor || multiLineColor || multiOpacity || multiAngle) {
          optsOut.symbols = new Array(count);
          optsOut.angles = new Array(count);
          optsOut.colors = new Array(count);
          optsOut.borderColors = new Array(count);
          var symbols = optsIn.symbol;
          var angles = optsIn.angle;
          var colors = formatColor(optsIn, optsIn.opacity, count);
          var borderColors = formatColor(optsIn.line, optsIn.opacity, count);
          if (!isArrayOrTypedArray(borderColors[0])) {
            var borderColor = borderColors;
            borderColors = Array(count);
            for (i = 0; i < count; i++) {
              borderColors[i] = borderColor;
            }
          }
          if (!isArrayOrTypedArray(colors[0])) {
            var color = colors;
            colors = Array(count);
            for (i = 0; i < count; i++) {
              colors[i] = color;
            }
          }
          if (!isArrayOrTypedArray(symbols)) {
            var symbol = symbols;
            symbols = Array(count);
            for (i = 0; i < count; i++) {
              symbols[i] = symbol;
            }
          }
          if (!isArrayOrTypedArray(angles)) {
            var angle = angles;
            angles = Array(count);
            for (i = 0; i < count; i++) {
              angles[i] = angle;
            }
          }
          optsOut.symbols = symbols;
          optsOut.angles = angles;
          optsOut.colors = colors;
          optsOut.borderColors = borderColors;
          for (i = 0; i < count; i++) {
            if (multiSymbol) {
              isOpen = helpers.isOpenSymbol(optsIn.symbol[i]);
            }
            if (isOpen) {
              borderColors[i] = colors[i].slice();
              colors[i] = colors[i].slice();
              colors[i][3] = 0;
            }
          }
          optsOut.opacity = trace.opacity;
          optsOut.markers = new Array(count);
          for (i = 0; i < count; i++) {
            optsOut.markers[i] = getSymbolSdf({
              mx: optsOut.symbols[i],
              ma: optsOut.angles[i]
            }, trace);
          }
        } else {
          if (isOpen) {
            optsOut.color = rgba2(optsIn.color, "uint8");
            optsOut.color[3] = 0;
            optsOut.borderColor = rgba2(optsIn.color, "uint8");
          } else {
            optsOut.color = rgba2(optsIn.color, "uint8");
            optsOut.borderColor = rgba2(optsIn.line.color, "uint8");
          }
          optsOut.opacity = trace.opacity * optsIn.opacity;
          optsOut.marker = getSymbolSdf({
            mx: optsIn.symbol,
            ma: optsIn.angle
          }, trace);
        }
        var sizeFactor = 1;
        var markerSizeFunc = makeBubbleSizeFn(trace, sizeFactor);
        var s;
        if (multiSize || multiLineWidth) {
          var sizes = optsOut.sizes = new Array(count);
          var borderSizes = optsOut.borderSizes = new Array(count);
          var sizeTotal = 0;
          var sizeAvg;
          if (multiSize) {
            for (i = 0; i < count; i++) {
              sizes[i] = markerSizeFunc(optsIn.size[i]);
              sizeTotal += sizes[i];
            }
            sizeAvg = sizeTotal / count;
          } else {
            s = markerSizeFunc(optsIn.size);
            for (i = 0; i < count; i++) {
              sizes[i] = s;
            }
          }
          if (multiLineWidth) {
            for (i = 0; i < count; i++) {
              borderSizes[i] = optsIn.line.width[i];
            }
          } else {
            s = optsIn.line.width;
            for (i = 0; i < count; i++) {
              borderSizes[i] = s;
            }
          }
          optsOut.sizeAvg = sizeAvg;
        } else {
          optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);
          optsOut.borderSizes = markerSizeFunc(optsIn.line.width);
        }
        return optsOut;
      }
      function convertMarkerSelection(gd, trace, target) {
        var optsIn = trace.marker;
        var optsOut = {};
        if (!target) return optsOut;
        if (target.marker && target.marker.symbol) {
          optsOut = convertMarkerStyle(gd, Lib.extendFlat({}, optsIn, target.marker));
        } else if (target.marker) {
          if (target.marker.size) optsOut.size = target.marker.size;
          if (target.marker.color) optsOut.colors = target.marker.color;
          if (target.marker.opacity !== void 0) optsOut.opacity = target.marker.opacity;
        }
        return optsOut;
      }
      function convertTextSelection(gd, trace, target) {
        var optsOut = {};
        if (!target) return optsOut;
        if (target.textfont) {
          var optsIn = {
            opacity: 1,
            text: trace.text,
            texttemplate: trace.texttemplate,
            textposition: trace.textposition,
            textfont: Lib.extendFlat({}, trace.textfont)
          };
          if (target.textfont) {
            Lib.extendFlat(optsIn.textfont, target.textfont);
          }
          optsOut = convertTextStyle(gd, optsIn);
        }
        return optsOut;
      }
      function convertErrorBarStyle(trace, target, plotGlPixelRatio) {
        var optsOut = {
          capSize: target.width * 2 * plotGlPixelRatio,
          lineWidth: target.thickness * plotGlPixelRatio,
          color: target.color
        };
        if (target.copy_ystyle) {
          optsOut = trace.error_y;
        }
        return optsOut;
      }
      var SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;
      var SYMBOL_SIZE = constants.SYMBOL_SIZE;
      var SYMBOL_STROKE = constants.SYMBOL_STROKE;
      var SYMBOL_SDF = {};
      var SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);
      function getSymbolSdf(d, trace) {
        var symbol = d.mx;
        if (symbol === "circle") return null;
        var symbolPath, symbolSdf;
        var symbolNumber = Drawing.symbolNumber(symbol);
        var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];
        var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];
        var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];
        var isDot = helpers.isDotSymbol(symbol);
        if (d.ma) symbol += "_" + d.ma;
        if (SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];
        var angle = Drawing.getMarkerAngle(d, trace);
        if (isDot && !symbolNoDot) {
          symbolPath = symbolFunc(SYMBOL_SIZE * 1.1, angle) + SYMBOL_SVG_CIRCLE;
        } else {
          symbolPath = symbolFunc(SYMBOL_SIZE, angle);
        }
        symbolSdf = svgSdf(symbolPath, {
          w: SYMBOL_SDF_SIZE,
          h: SYMBOL_SDF_SIZE,
          viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],
          stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE
        });
        SYMBOL_SDF[symbol] = symbolSdf;
        return symbolSdf || null;
      }
      function convertLinePositions(gd, trace, positions) {
        var len = positions.length;
        var count = len / 2;
        var linePositions;
        var i;
        if (subTypes.hasLines(trace) && count) {
          if (trace.line.shape === "hv") {
            linePositions = [];
            for (i = 0; i < count - 1; i++) {
              if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {
                linePositions.push(NaN, NaN, NaN, NaN);
              } else {
                linePositions.push(positions[i * 2], positions[i * 2 + 1]);
                if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {
                  linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);
                } else {
                  linePositions.push(NaN, NaN);
                }
              }
            }
            linePositions.push(positions[len - 2], positions[len - 1]);
          } else if (trace.line.shape === "hvh") {
            linePositions = [];
            for (i = 0; i < count - 1; i++) {
              if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {
                if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {
                  linePositions.push(positions[i * 2], positions[i * 2 + 1]);
                } else {
                  linePositions.push(NaN, NaN);
                }
                linePositions.push(NaN, NaN);
              } else {
                var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;
                linePositions.push(
                  positions[i * 2],
                  positions[i * 2 + 1],
                  midPtX,
                  positions[i * 2 + 1],
                  midPtX,
                  positions[i * 2 + 3]
                );
              }
            }
            linePositions.push(positions[len - 2], positions[len - 1]);
          } else if (trace.line.shape === "vhv") {
            linePositions = [];
            for (i = 0; i < count - 1; i++) {
              if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {
                if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {
                  linePositions.push(positions[i * 2], positions[i * 2 + 1]);
                } else {
                  linePositions.push(NaN, NaN);
                }
                linePositions.push(NaN, NaN);
              } else {
                var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;
                linePositions.push(
                  positions[i * 2],
                  positions[i * 2 + 1],
                  positions[i * 2],
                  midPtY,
                  positions[i * 2 + 2],
                  midPtY
                );
              }
            }
            linePositions.push(positions[len - 2], positions[len - 1]);
          } else if (trace.line.shape === "vh") {
            linePositions = [];
            for (i = 0; i < count - 1; i++) {
              if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {
                linePositions.push(NaN, NaN, NaN, NaN);
              } else {
                linePositions.push(positions[i * 2], positions[i * 2 + 1]);
                if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {
                  linePositions.push(positions[i * 2], positions[i * 2 + 3]);
                } else {
                  linePositions.push(NaN, NaN);
                }
              }
            }
            linePositions.push(positions[len - 2], positions[len - 1]);
          } else {
            linePositions = positions;
          }
        }
        var hasNaN = false;
        for (i = 0; i < linePositions.length; i++) {
          if (isNaN(linePositions[i])) {
            hasNaN = true;
            break;
          }
        }
        var join = hasNaN || linePositions.length > constants.TOO_MANY_POINTS ? "rect" : subTypes.hasMarkers(trace) ? "rect" : "round";
        if (hasNaN && trace.connectgaps) {
          var lastX = linePositions[0];
          var lastY = linePositions[1];
          for (i = 0; i < linePositions.length; i += 2) {
            if (isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {
              linePositions[i] = lastX;
              linePositions[i + 1] = lastY;
            } else {
              lastX = linePositions[i];
              lastY = linePositions[i + 1];
            }
          }
        }
        return {
          join,
          positions: linePositions
        };
      }
      function convertErrorBarPositions(gd, trace, positions, x, y) {
        var makeComputeError = Registry.getComponentMethod("errorbars", "makeComputeError");
        var xa = AxisIDs.getFromId(gd, trace.xaxis, "x");
        var ya = AxisIDs.getFromId(gd, trace.yaxis, "y");
        var count = positions.length / 2;
        var out = {};
        function convertOneAxis(coords, ax) {
          var axLetter = ax._id.charAt(0);
          var opts = trace["error_" + axLetter];
          if (opts && opts.visible && (ax.type === "linear" || ax.type === "log")) {
            var computeError = makeComputeError(opts);
            var pOffset = { x: 0, y: 1 }[axLetter];
            var eOffset = { x: [0, 1, 2, 3], y: [2, 3, 0, 1] }[axLetter];
            var errors = new Float64Array(4 * count);
            var minShoe = Infinity;
            var maxHat = -Infinity;
            for (var i = 0, j = 0; i < count; i++, j += 4) {
              var dc = coords[i];
              if (isNumeric(dc)) {
                var dl = positions[i * 2 + pOffset];
                var vals = computeError(dc, i);
                var lv = vals[0];
                var hv = vals[1];
                if (isNumeric(lv) && isNumeric(hv)) {
                  var shoe = dc - lv;
                  var hat = dc + hv;
                  errors[j + eOffset[0]] = dl - ax.c2l(shoe);
                  errors[j + eOffset[1]] = ax.c2l(hat) - dl;
                  errors[j + eOffset[2]] = 0;
                  errors[j + eOffset[3]] = 0;
                  minShoe = Math.min(minShoe, dc - lv);
                  maxHat = Math.max(maxHat, dc + hv);
                }
              }
            }
            out[axLetter] = {
              positions,
              errors,
              _bnds: [minShoe, maxHat]
            };
          }
        }
        convertOneAxis(x, xa);
        convertOneAxis(y, ya);
        return out;
      }
      function convertTextPosition(gd, trace, textOpts, markerOpts) {
        var count = trace._length;
        var out = {};
        var i;
        if (subTypes.hasMarkers(trace)) {
          var fontOpts = textOpts.font;
          var align = textOpts.align;
          var baseline = textOpts.baseline;
          out.offset = new Array(count);
          for (i = 0; i < count; i++) {
            var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;
            var fs = isArrayOrTypedArray(fontOpts) ? fontOpts[i].size : fontOpts.size;
            var a = isArrayOrTypedArray(align) ? align.length > 1 ? align[i] : align[0] : align;
            var b = isArrayOrTypedArray(baseline) ? baseline.length > 1 ? baseline[i] : baseline[0] : baseline;
            var hSign = TEXTOFFSETSIGN[a];
            var vSign = TEXTOFFSETSIGN[b];
            var xPad = ms ? ms / 0.8 + 1 : 0;
            var yPad = -vSign * xPad - vSign * 0.5;
            out.offset[i] = [hSign * xPad / fs, yPad / fs];
          }
        }
        return out;
      }
      module.exports = {
        style: convertStyle,
        markerStyle: convertMarkerStyle,
        markerSelection: convertMarkerSelection,
        linePositions: convertLinePositions,
        errorBarPositions: convertErrorBarPositions,
        textPosition: convertTextPosition
      };
    }
  });

  // src/traces/scattergl/scene_update.js
  var require_scene_update = __commonJS({
    "src/traces/scattergl/scene_update.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function sceneUpdate(gd, subplot) {
        var scene = subplot._scene;
        var resetOpts = {
          // number of traces in subplot, since scene:subplot -> 1:1
          count: 0,
          // whether scene requires init hook in plot call (dirty plot call)
          dirty: true,
          // last used options
          lineOptions: [],
          fillOptions: [],
          markerOptions: [],
          markerSelectedOptions: [],
          markerUnselectedOptions: [],
          errorXOptions: [],
          errorYOptions: [],
          textOptions: [],
          textSelectedOptions: [],
          textUnselectedOptions: [],
          // selection batches
          selectBatch: [],
          unselectBatch: []
        };
        var initOpts = {
          fill2d: false,
          scatter2d: false,
          error2d: false,
          line2d: false,
          glText: false,
          select2d: false
        };
        if (!subplot._scene) {
          scene = subplot._scene = {};
          scene.init = function init() {
            Lib.extendFlat(scene, initOpts, resetOpts);
          };
          scene.init();
          scene.update = function update(opt) {
            var opts = Lib.repeat(opt, scene.count);
            if (scene.fill2d) scene.fill2d.update(opts);
            if (scene.scatter2d) scene.scatter2d.update(opts);
            if (scene.line2d) scene.line2d.update(opts);
            if (scene.error2d) scene.error2d.update(opts.concat(opts));
            if (scene.select2d) scene.select2d.update(opts);
            if (scene.glText) {
              for (var i = 0; i < scene.count; i++) {
                scene.glText[i].update(opt);
              }
            }
          };
          scene.draw = function draw() {
            var count = scene.count;
            var fill2d = scene.fill2d;
            var error2d = scene.error2d;
            var line2d = scene.line2d;
            var scatter2d = scene.scatter2d;
            var glText = scene.glText;
            var select2d = scene.select2d;
            var selectBatch = scene.selectBatch;
            var unselectBatch = scene.unselectBatch;
            for (var i = 0; i < count; i++) {
              if (fill2d && scene.fillOrder[i]) {
                fill2d.draw(scene.fillOrder[i]);
              }
              if (line2d && scene.lineOptions[i]) {
                line2d.draw(i);
              }
              if (error2d) {
                if (scene.errorXOptions[i]) error2d.draw(i);
                if (scene.errorYOptions[i]) error2d.draw(i + count);
              }
              if (scatter2d && scene.markerOptions[i]) {
                if (unselectBatch[i].length) {
                  var arg = Lib.repeat([], scene.count);
                  arg[i] = unselectBatch[i];
                  scatter2d.draw(arg);
                } else if (!selectBatch[i].length) {
                  scatter2d.draw(i);
                }
              }
              if (glText[i] && scene.textOptions[i]) {
                glText[i].render();
              }
            }
            if (select2d) {
              select2d.draw(selectBatch);
            }
            scene.dirty = false;
          };
          scene.destroy = function destroy() {
            if (scene.fill2d && scene.fill2d.destroy) scene.fill2d.destroy();
            if (scene.scatter2d && scene.scatter2d.destroy) scene.scatter2d.destroy();
            if (scene.error2d && scene.error2d.destroy) scene.error2d.destroy();
            if (scene.line2d && scene.line2d.destroy) scene.line2d.destroy();
            if (scene.select2d && scene.select2d.destroy) scene.select2d.destroy();
            if (scene.glText) {
              scene.glText.forEach(function(text) {
                if (text.destroy) text.destroy();
              });
            }
            scene.lineOptions = null;
            scene.fillOptions = null;
            scene.markerOptions = null;
            scene.markerSelectedOptions = null;
            scene.markerUnselectedOptions = null;
            scene.errorXOptions = null;
            scene.errorYOptions = null;
            scene.textOptions = null;
            scene.textSelectedOptions = null;
            scene.textUnselectedOptions = null;
            scene.selectBatch = null;
            scene.unselectBatch = null;
            subplot._scene = null;
          };
        }
        if (!scene.dirty) {
          Lib.extendFlat(scene, resetOpts);
        }
        return scene;
      };
    }
  });

  // src/traces/scattergl/calc.js
  var require_calc5 = __commonJS({
    "src/traces/scattergl/calc.js"(exports, module) {
      "use strict";
      var cluster = require_point_cluster();
      var Lib = require_lib();
      var AxisIDs = require_axis_ids();
      var findExtremes = require_autorange().findExtremes;
      var alignPeriod = require_align_period();
      var scatterCalc = require_calc3();
      var calcMarkerSize = scatterCalc.calcMarkerSize;
      var calcAxisExpansion = scatterCalc.calcAxisExpansion;
      var setFirstScatter = scatterCalc.setFirstScatter;
      var calcColorscale = require_colorscale_calc();
      var convert = require_convert2();
      var sceneUpdate = require_scene_update();
      var BADNUM = require_numerical().BADNUM;
      var TOO_MANY_POINTS = require_constants14().TOO_MANY_POINTS;
      module.exports = function calc(gd, trace) {
        var fullLayout = gd._fullLayout;
        var xa = trace._xA = AxisIDs.getFromId(gd, trace.xaxis, "x");
        var ya = trace._yA = AxisIDs.getFromId(gd, trace.yaxis, "y");
        var subplot = fullLayout._plots[trace.xaxis + trace.yaxis];
        var len = trace._length;
        var hasTooManyPoints = len >= TOO_MANY_POINTS;
        var len2 = len * 2;
        var stash = {};
        var i;
        var origX = xa.makeCalcdata(trace, "x");
        var origY = ya.makeCalcdata(trace, "y");
        var xObj = alignPeriod(trace, xa, "x", origX);
        var yObj = alignPeriod(trace, ya, "y", origY);
        var x = xObj.vals;
        var y = yObj.vals;
        trace._x = x;
        trace._y = y;
        if (trace.xperiodalignment) {
          trace._origX = origX;
          trace._xStarts = xObj.starts;
          trace._xEnds = xObj.ends;
        }
        if (trace.yperiodalignment) {
          trace._origY = origY;
          trace._yStarts = yObj.starts;
          trace._yEnds = yObj.ends;
        }
        var positions = new Array(len2);
        var _ids = new Array(len);
        for (i = 0; i < len; i++) {
          positions[i * 2] = x[i] === BADNUM ? NaN : x[i];
          positions[i * 2 + 1] = y[i] === BADNUM ? NaN : y[i];
          _ids[i] = i;
        }
        if (xa.type === "log") {
          for (i = 0; i < len2; i += 2) {
            positions[i] = xa.c2l(positions[i]);
          }
        }
        if (ya.type === "log") {
          for (i = 1; i < len2; i += 2) {
            positions[i] = ya.c2l(positions[i]);
          }
        }
        if (hasTooManyPoints && (xa.type !== "log" && ya.type !== "log")) {
          stash.tree = cluster(positions);
        } else {
          stash.ids = _ids;
        }
        calcColorscale(gd, trace);
        var opts = sceneOptions(gd, subplot, trace, positions, x, y);
        var scene = sceneUpdate(gd, subplot);
        setFirstScatter(fullLayout, trace);
        var ppad;
        if (!hasTooManyPoints) {
          ppad = calcMarkerSize(trace, len);
        } else if (opts.marker) {
          ppad = opts.marker.sizeAvg || Math.max(opts.marker.size, 3);
        }
        calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);
        if (opts.errorX) expandForErrorBars(trace, xa, opts.errorX);
        if (opts.errorY) expandForErrorBars(trace, ya, opts.errorY);
        if (opts.fill && !scene.fill2d) scene.fill2d = true;
        if (opts.marker && !scene.scatter2d) scene.scatter2d = true;
        if (opts.line && !scene.line2d) scene.line2d = true;
        if ((opts.errorX || opts.errorY) && !scene.error2d) scene.error2d = true;
        if (opts.text && !scene.glText) scene.glText = true;
        if (opts.marker) opts.marker.snap = len;
        scene.lineOptions.push(opts.line);
        scene.errorXOptions.push(opts.errorX);
        scene.errorYOptions.push(opts.errorY);
        scene.fillOptions.push(opts.fill);
        scene.markerOptions.push(opts.marker);
        scene.markerSelectedOptions.push(opts.markerSel);
        scene.markerUnselectedOptions.push(opts.markerUnsel);
        scene.textOptions.push(opts.text);
        scene.textSelectedOptions.push(opts.textSel);
        scene.textUnselectedOptions.push(opts.textUnsel);
        scene.selectBatch.push([]);
        scene.unselectBatch.push([]);
        stash._scene = scene;
        stash.index = scene.count;
        stash.x = x;
        stash.y = y;
        stash.positions = positions;
        scene.count++;
        return [{ x: false, y: false, t: stash, trace }];
      };
      function expandForErrorBars(trace, ax, opts) {
        var extremes = trace._extremes[ax._id];
        var errExt = findExtremes(ax, opts._bnds, { padded: true });
        extremes.min = extremes.min.concat(errExt.min);
        extremes.max = extremes.max.concat(errExt.max);
      }
      function sceneOptions(gd, subplot, trace, positions, x, y) {
        var opts = convert.style(gd, trace);
        if (opts.marker) {
          opts.marker.positions = positions;
        }
        if (opts.line && positions.length > 1) {
          Lib.extendFlat(
            opts.line,
            convert.linePositions(gd, trace, positions)
          );
        }
        if (opts.errorX || opts.errorY) {
          var errors = convert.errorBarPositions(gd, trace, positions, x, y);
          if (opts.errorX) {
            Lib.extendFlat(opts.errorX, errors.x);
          }
          if (opts.errorY) {
            Lib.extendFlat(opts.errorY, errors.y);
          }
        }
        if (opts.text) {
          Lib.extendFlat(
            opts.text,
            { positions },
            convert.textPosition(gd, trace, opts.text, opts.marker)
          );
          Lib.extendFlat(
            opts.textSel,
            { positions },
            convert.textPosition(gd, trace, opts.text, opts.markerSel)
          );
          Lib.extendFlat(
            opts.textUnsel,
            { positions },
            convert.textPosition(gd, trace, opts.text, opts.markerUnsel)
          );
        }
        return opts;
      }
    }
  });

  // src/traces/scattergl/edit_style.js
  var require_edit_style = __commonJS({
    "src/traces/scattergl/edit_style.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var Color = require_color();
      var DESELECTDIM = require_interactions().DESELECTDIM;
      function styleTextSelection(cd) {
        var cd0 = cd[0];
        var trace = cd0.trace;
        var stash = cd0.t;
        var scene = stash._scene;
        var index = stash.index;
        var els = scene.selectBatch[index];
        var unels = scene.unselectBatch[index];
        var baseOpts = scene.textOptions[index];
        var selOpts = scene.textSelectedOptions[index] || {};
        var unselOpts = scene.textUnselectedOptions[index] || {};
        var opts = Lib.extendFlat({}, baseOpts);
        var i, j;
        if (els.length || unels.length) {
          var stc = selOpts.color;
          var utc = unselOpts.color;
          var base = baseOpts.color;
          var hasArrayBase = Lib.isArrayOrTypedArray(base);
          opts.color = new Array(trace._length);
          for (i = 0; i < els.length; i++) {
            j = els[i];
            opts.color[j] = stc || (hasArrayBase ? base[j] : base);
          }
          for (i = 0; i < unels.length; i++) {
            j = unels[i];
            var basej = hasArrayBase ? base[j] : base;
            opts.color[j] = utc ? utc : stc ? basej : Color.addOpacity(basej, DESELECTDIM);
          }
        }
        scene.glText[index].update(opts);
      }
      module.exports = {
        styleTextSelection
      };
    }
  });

  // src/traces/scattergl/select.js
  var require_select3 = __commonJS({
    "src/traces/scattergl/select.js"(exports, module) {
      "use strict";
      var subTypes = require_subtypes();
      var styleTextSelection = require_edit_style().styleTextSelection;
      module.exports = function select(searchInfo, selectionTester) {
        var cd = searchInfo.cd;
        var xa = searchInfo.xaxis;
        var ya = searchInfo.yaxis;
        var selection = [];
        var trace = cd[0].trace;
        var stash = cd[0].t;
        var len = trace._length;
        var x = stash.x;
        var y = stash.y;
        var scene = stash._scene;
        var index = stash.index;
        if (!scene) return selection;
        var hasText = subTypes.hasText(trace);
        var hasMarkers = subTypes.hasMarkers(trace);
        var hasOnlyLines = !hasMarkers && !hasText;
        if (trace.visible !== true || hasOnlyLines) return selection;
        var els = [];
        var unels = [];
        if (selectionTester !== false && !selectionTester.degenerate) {
          for (var i = 0; i < len; i++) {
            if (selectionTester.contains([stash.xpx[i], stash.ypx[i]], false, i, searchInfo)) {
              els.push(i);
              selection.push({
                pointNumber: i,
                x: xa.c2d(x[i]),
                y: ya.c2d(y[i])
              });
            } else {
              unels.push(i);
            }
          }
        }
        if (hasMarkers) {
          var scatter2d = scene.scatter2d;
          if (!els.length && !unels.length) {
            var baseOpts = new Array(scene.count);
            baseOpts[index] = scene.markerOptions[index];
            scatter2d.update.apply(scatter2d, baseOpts);
          } else if (!scene.selectBatch[index].length && !scene.unselectBatch[index].length) {
            var unselOpts = new Array(scene.count);
            unselOpts[index] = scene.markerUnselectedOptions[index];
            scatter2d.update.apply(scatter2d, unselOpts);
          }
        }
        scene.selectBatch[index] = els;
        scene.unselectBatch[index] = unels;
        if (hasText) {
          styleTextSelection(cd);
        }
        return selection;
      };
    }
  });

  // src/traces/scattergl/base_index.js
  var require_base_index = __commonJS({
    "src/traces/scattergl/base_index.js"(exports, module) {
      "use strict";
      var hover = require_hover3();
      module.exports = {
        moduleType: "trace",
        name: "scattergl",
        basePlotModule: require_cartesian(),
        categories: ["gl", "regl", "cartesian", "symbols", "errorBarsOK", "showLegend", "scatter-like"],
        attributes: require_attributes23(),
        supplyDefaults: require_defaults19(),
        crossTraceDefaults: require_cross_trace_defaults2(),
        colorbar: require_marker_colorbar(),
        formatLabels: require_format_labels2(),
        calc: require_calc5(),
        hoverPoints: hover.hoverPoints,
        selectPoints: require_select3(),
        meta: {}
      };
    }
  });

  // node_modules/color-id/index.js
  var require_color_id = __commonJS({
    "node_modules/color-id/index.js"(exports, module) {
      "use strict";
      var clamp = require_clamp();
      module.exports = toNumber;
      module.exports.to = toNumber;
      module.exports.from = fromNumber;
      function toNumber(rgba2, normalized) {
        if (normalized == null) normalized = true;
        var r = rgba2[0], g = rgba2[1], b = rgba2[2], a = rgba2[3];
        if (a == null) a = normalized ? 1 : 255;
        if (normalized) {
          r *= 255;
          g *= 255;
          b *= 255;
          a *= 255;
        }
        r = clamp(r, 0, 255) & 255;
        g = clamp(g, 0, 255) & 255;
        b = clamp(b, 0, 255) & 255;
        a = clamp(a, 0, 255) & 255;
        var n = r * 16777216 + (g << 16) + (b << 8) + a;
        return n;
      }
      function fromNumber(n, normalized) {
        n = +n;
        var r = n >>> 24;
        var g = (n & 16711680) >>> 16;
        var b = (n & 65280) >>> 8;
        var a = n & 255;
        if (normalized === false) return [r, g, b, a];
        return [r / 255, g / 255, b / 255, a / 255];
      }
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty2.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/glslify/browser.js
  var require_browser = __commonJS({
    "node_modules/glslify/browser.js"(exports, module) {
      module.exports = function(strings) {
        if (typeof strings === "string") strings = [strings];
        var exprs = [].slice.call(arguments, 1);
        var parts = [];
        for (var i = 0; i < strings.length - 1; i++) {
          parts.push(strings[i], exprs[i] || "");
        }
        parts.push(strings[i]);
        return parts.join("");
      };
    }
  });

  // node_modules/update-diff/index.js
  var require_update_diff = __commonJS({
    "node_modules/update-diff/index.js"(exports, module) {
      "use strict";
      module.exports = function updateDiff(obj, diff, mappers) {
        if (!Array.isArray(mappers)) mappers = [].slice.call(arguments, 2);
        for (var i = 0, l = mappers.length; i < l; i++) {
          var dict = mappers[i];
          for (var prop in dict) {
            if (diff[prop] !== void 0 && !Array.isArray(diff[prop]) && obj[prop] === diff[prop]) continue;
            if (prop in diff) {
              var result;
              if (dict[prop] === true) result = diff[prop];
              else if (dict[prop] === false) continue;
              else if (typeof dict[prop] === "function") {
                result = dict[prop](diff[prop], obj, diff);
                if (result === void 0) continue;
              }
              obj[prop] = result;
            }
          }
        }
        return obj;
      };
    }
  });

  // node_modules/is-iexplorer/index.js
  var require_is_iexplorer = __commonJS({
    "node_modules/is-iexplorer/index.js"(exports, module) {
      "use strict";
      module.exports = typeof navigator !== "undefined" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion));
    }
  });

  // node_modules/to-float32/index.js
  var require_to_float32 = __commonJS({
    "node_modules/to-float32/index.js"(exports, module) {
      "use strict";
      module.exports = float32;
      module.exports.float32 = module.exports.float = float32;
      module.exports.fract32 = module.exports.fract = fract32;
      var narr = new Float32Array(1);
      function fract32(arr, fract) {
        if (arr.length) {
          if (arr instanceof Float32Array) return new Float32Array(arr.length);
          if (!(fract instanceof Float32Array)) fract = float32(arr);
          for (var i = 0, l = fract.length; i < l; i++) {
            fract[i] = arr[i] - fract[i];
          }
          return fract;
        }
        return float32(arr - float32(arr));
      }
      function float32(arr) {
        if (arr.length) {
          if (arr instanceof Float32Array) return arr;
          return new Float32Array(arr);
        }
        narr[0] = arr;
        return narr[0];
      }
    }
  });

  // node_modules/regl-scatter2d/bundle.js
  var require_bundle = __commonJS({
    "node_modules/regl-scatter2d/bundle.js"(exports, module) {
      "use strict";
      function _iterableToArrayLimit(arr, i) {
        var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
        if (null != _i) {
          var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
          try {
            if (_x = (_i = _i.call(arr)).next, 0 === i) {
              if (Object(_i) !== _i) return;
              _n = false;
            } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true) ;
          } catch (err) {
            _d = true, _e = err;
          } finally {
            try {
              if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
      }
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var rgba2 = require_color_normalize();
      var getBounds = require_array_bounds();
      var colorId = require_color_id();
      var cluster = require_point_cluster();
      var extend = require_object_assign();
      var glslify = require_browser();
      var pick = require_pick_by_alias();
      var updateDiff = require_update_diff();
      var flatten = require_flatten_vertex_data();
      var ie = require_is_iexplorer();
      var f32 = require_to_float32();
      var parseRect = require_parse_rect();
      var scatter = Scatter;
      function Scatter(regl, options) {
        var _this = this;
        if (!(this instanceof Scatter)) return new Scatter(regl, options);
        if (typeof regl === "function") {
          if (!options) options = {};
          options.regl = regl;
        } else {
          options = regl;
          regl = null;
        }
        if (options && options.length) options.positions = options;
        regl = options.regl;
        var gl = regl._gl, paletteTexture, palette = [], paletteIds = {}, groups = [], markerTextures = [null], markerCache = [null];
        var maxColors = 255, maxSize = 100;
        this.tooManyColors = ie;
        paletteTexture = regl.texture({
          data: new Uint8Array(maxColors * 4),
          width: maxColors,
          height: 1,
          type: "uint8",
          format: "rgba",
          wrapS: "clamp",
          wrapT: "clamp",
          mag: "nearest",
          min: "nearest"
        });
        extend(this, {
          regl,
          gl,
          groups,
          markerCache,
          markerTextures,
          palette,
          paletteIds,
          paletteTexture,
          maxColors,
          maxSize,
          canvas: gl.canvas
        });
        this.update(options);
        var shaderOptions = {
          uniforms: {
            constPointSize: !!options.constPointSize,
            opacity: regl.prop("opacity"),
            paletteSize: function paletteSize(ctx, prop) {
              return [_this.tooManyColors ? 0 : maxColors, paletteTexture.height];
            },
            pixelRatio: regl.context("pixelRatio"),
            scale: regl.prop("scale"),
            scaleFract: regl.prop("scaleFract"),
            translate: regl.prop("translate"),
            translateFract: regl.prop("translateFract"),
            markerTexture: regl.prop("markerTexture"),
            paletteTexture
          },
          attributes: {
            // FIXME: optimize these parts
            x: function x(ctx, prop) {
              return prop.xAttr || {
                buffer: prop.positionBuffer,
                stride: 8,
                offset: 0
              };
            },
            y: function y(ctx, prop) {
              return prop.yAttr || {
                buffer: prop.positionBuffer,
                stride: 8,
                offset: 4
              };
            },
            xFract: function xFract(ctx, prop) {
              return prop.xAttr ? {
                constant: [0, 0]
              } : {
                buffer: prop.positionFractBuffer,
                stride: 8,
                offset: 0
              };
            },
            yFract: function yFract(ctx, prop) {
              return prop.yAttr ? {
                constant: [0, 0]
              } : {
                buffer: prop.positionFractBuffer,
                stride: 8,
                offset: 4
              };
            },
            size: function size(ctx, prop) {
              return prop.size.length ? {
                buffer: prop.sizeBuffer,
                stride: 2,
                offset: 0
              } : {
                constant: [Math.round(prop.size * 255 / _this.maxSize)]
              };
            },
            borderSize: function borderSize(ctx, prop) {
              return prop.borderSize.length ? {
                buffer: prop.sizeBuffer,
                stride: 2,
                offset: 1
              } : {
                constant: [Math.round(prop.borderSize * 255 / _this.maxSize)]
              };
            },
            colorId: function colorId2(ctx, prop) {
              return prop.color.length ? {
                buffer: prop.colorBuffer,
                stride: _this.tooManyColors ? 8 : 4,
                offset: 0
              } : {
                constant: _this.tooManyColors ? palette.slice(prop.color * 4, prop.color * 4 + 4) : [prop.color]
              };
            },
            borderColorId: function borderColorId(ctx, prop) {
              return prop.borderColor.length ? {
                buffer: prop.colorBuffer,
                stride: _this.tooManyColors ? 8 : 4,
                offset: _this.tooManyColors ? 4 : 2
              } : {
                constant: _this.tooManyColors ? palette.slice(prop.borderColor * 4, prop.borderColor * 4 + 4) : [prop.borderColor]
              };
            },
            isActive: function isActive(ctx, prop) {
              return prop.activation === true ? {
                constant: [1]
              } : prop.activation ? prop.activation : {
                constant: [0]
              };
            }
          },
          blend: {
            enable: true,
            color: [0, 0, 0, 1],
            // photoshop blending
            func: {
              srcRGB: "src alpha",
              dstRGB: "one minus src alpha",
              srcAlpha: "one minus dst alpha",
              dstAlpha: "one"
            }
          },
          scissor: {
            enable: true,
            box: regl.prop("viewport")
          },
          viewport: regl.prop("viewport"),
          stencil: {
            enable: false
          },
          depth: {
            enable: false
          },
          elements: regl.prop("elements"),
          count: regl.prop("count"),
          offset: regl.prop("offset"),
          primitive: "points"
        };
        var markerOptions = extend({}, shaderOptions);
        markerOptions.frag = glslify(["precision highp float;\n#define GLSLIFY 1\n\nuniform float opacity;\nuniform sampler2D markerTexture;\n\nvarying vec4 fragColor, fragBorderColor;\nvarying float fragWidth, fragBorderColorLevel, fragColorLevel;\n\nfloat smoothStep(float x, float y) {\n  return 1.0 / (1.0 + exp(50.0*(x - y)));\n}\n\nvoid main() {\n  float dist = texture2D(markerTexture, gl_PointCoord).r, delta = fragWidth;\n\n  // max-distance alpha\n  if (dist < 0.003) discard;\n\n  // null-border case\n  if (fragBorderColorLevel == fragColorLevel || fragBorderColor.a == 0.) {\n    float colorAmt = smoothstep(.5 - delta, .5 + delta, dist);\n    gl_FragColor = vec4(fragColor.rgb, colorAmt * fragColor.a * opacity);\n  }\n  else {\n    float borderColorAmt = smoothstep(fragBorderColorLevel - delta, fragBorderColorLevel + delta, dist);\n    float colorAmt = smoothstep(fragColorLevel - delta, fragColorLevel + delta, dist);\n\n    vec4 color = fragBorderColor;\n    color.a *= borderColorAmt;\n    color = mix(color, fragColor, colorAmt);\n    color.a *= opacity;\n\n    gl_FragColor = color;\n  }\n\n}\n"]);
        markerOptions.vert = glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute float x, y, xFract, yFract;\nattribute float size, borderSize;\nattribute vec4 colorId, borderColorId;\nattribute float isActive;\n\n// `invariant` effectively turns off optimizations for the position.\n// We need this because -fast-math on M1 Macs is re-ordering\n// floating point operations in a way that causes floating point\n// precision limits to put points in the wrong locations.\ninvariant gl_Position;\n\nuniform bool constPointSize;\nuniform float pixelRatio;\nuniform vec2 scale, scaleFract, translate, translateFract, paletteSize;\nuniform sampler2D paletteTexture;\n\nconst float maxSize = 100.;\nconst float borderLevel = .5;\n\nvarying vec4 fragColor, fragBorderColor;\nvarying float fragPointSize, fragBorderRadius, fragWidth, fragBorderColorLevel, fragColorLevel;\n\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\n\nbool isDirect = (paletteSize.x < 1.);\n\nvec4 getColor(vec4 id) {\n  return isDirect ? id / 255. : texture2D(paletteTexture,\n    vec2(\n      (id.x + .5) / paletteSize.x,\n      (id.y + .5) / paletteSize.y\n    )\n  );\n}\n\nvoid main() {\n  // ignore inactive points\n  if (isActive == 0.) return;\n\n  vec2 position = vec2(x, y);\n  vec2 positionFract = vec2(xFract, yFract);\n\n  vec4 color = getColor(colorId);\n  vec4 borderColor = getColor(borderColorId);\n\n  float size = size * maxSize / 255.;\n  float borderSize = borderSize * maxSize / 255.;\n\n  gl_PointSize = 2. * size * pointSizeScale;\n  fragPointSize = size * pixelRatio;\n\n  vec2 pos = (position + translate) * scale\n      + (positionFract + translateFract) * scale\n      + (position + translate) * scaleFract\n      + (positionFract + translateFract) * scaleFract;\n\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\n\n  fragColor = color;\n  fragBorderColor = borderColor;\n  fragWidth = 1. / gl_PointSize;\n\n  fragBorderColorLevel = clamp(borderLevel - borderLevel * borderSize / size, 0., 1.);\n  fragColorLevel = clamp(borderLevel + (1. - borderLevel) * borderSize / size, 0., 1.);\n}\n"]);
        this.drawMarker = regl(markerOptions);
        var circleOptions = extend({}, shaderOptions);
        circleOptions.frag = glslify(["precision highp float;\n#define GLSLIFY 1\n\nvarying vec4 fragColor, fragBorderColor;\nvarying float fragBorderRadius, fragWidth;\n\nuniform float opacity;\n\nfloat smoothStep(float edge0, float edge1, float x) {\n	float t;\n	t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n	return t * t * (3.0 - 2.0 * t);\n}\n\nvoid main() {\n	float radius, alpha = 1.0, delta = fragWidth;\n\n	radius = length(2.0 * gl_PointCoord.xy - 1.0);\n\n	if (radius > 1.0 + delta) {\n		discard;\n	}\n\n	alpha -= smoothstep(1.0 - delta, 1.0 + delta, radius);\n\n	float borderRadius = fragBorderRadius;\n	float ratio = smoothstep(borderRadius - delta, borderRadius + delta, radius);\n	vec4 color = mix(fragColor, fragBorderColor, ratio);\n	color.a *= alpha * opacity;\n	gl_FragColor = color;\n}\n"]);
        circleOptions.vert = glslify(["precision highp float;\n#define GLSLIFY 1\n\nattribute float x, y, xFract, yFract;\nattribute float size, borderSize;\nattribute vec4 colorId, borderColorId;\nattribute float isActive;\n\n// `invariant` effectively turns off optimizations for the position.\n// We need this because -fast-math on M1 Macs is re-ordering\n// floating point operations in a way that causes floating point\n// precision limits to put points in the wrong locations.\ninvariant gl_Position;\n\nuniform bool constPointSize;\nuniform float pixelRatio;\nuniform vec2 paletteSize, scale, scaleFract, translate, translateFract;\nuniform sampler2D paletteTexture;\n\nconst float maxSize = 100.;\n\nvarying vec4 fragColor, fragBorderColor;\nvarying float fragBorderRadius, fragWidth;\n\nfloat pointSizeScale = (constPointSize) ? 2. : pixelRatio;\n\nbool isDirect = (paletteSize.x < 1.);\n\nvec4 getColor(vec4 id) {\n  return isDirect ? id / 255. : texture2D(paletteTexture,\n    vec2(\n      (id.x + .5) / paletteSize.x,\n      (id.y + .5) / paletteSize.y\n    )\n  );\n}\n\nvoid main() {\n  // ignore inactive points\n  if (isActive == 0.) return;\n\n  vec2 position = vec2(x, y);\n  vec2 positionFract = vec2(xFract, yFract);\n\n  vec4 color = getColor(colorId);\n  vec4 borderColor = getColor(borderColorId);\n\n  float size = size * maxSize / 255.;\n  float borderSize = borderSize * maxSize / 255.;\n\n  gl_PointSize = (size + borderSize) * pointSizeScale;\n\n  vec2 pos = (position + translate) * scale\n      + (positionFract + translateFract) * scale\n      + (position + translate) * scaleFract\n      + (positionFract + translateFract) * scaleFract;\n\n  gl_Position = vec4(pos * 2. - 1., 0., 1.);\n\n  fragBorderRadius = 1. - 2. * borderSize / (size + borderSize);\n  fragColor = color;\n  fragBorderColor = borderColor.a == 0. || borderSize == 0. ? vec4(color.rgb, 0.) : borderColor;\n  fragWidth = 1. / gl_PointSize;\n}\n"]);
        if (ie) {
          circleOptions.frag = circleOptions.frag.replace("smoothstep", "smoothStep");
          markerOptions.frag = markerOptions.frag.replace("smoothstep", "smoothStep");
        }
        this.drawCircle = regl(circleOptions);
      }
      Scatter.defaults = {
        color: "black",
        borderColor: "transparent",
        borderSize: 0,
        size: 12,
        opacity: 1,
        marker: void 0,
        viewport: null,
        range: null,
        pixelSize: null,
        count: 0,
        offset: 0,
        bounds: null,
        positions: [],
        snap: 1e4
      };
      Scatter.prototype.render = function() {
        if (arguments.length) {
          this.update.apply(this, arguments);
        }
        this.draw();
        return this;
      };
      Scatter.prototype.draw = function() {
        var _this2 = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var groups = this.groups;
        if (args.length === 1 && Array.isArray(args[0]) && (args[0][0] === null || Array.isArray(args[0][0]))) {
          args = args[0];
        }
        this.regl._refresh();
        if (args.length) {
          for (var i = 0; i < args.length; i++) {
            this.drawItem(i, args[i]);
          }
        } else {
          groups.forEach(function(group, i2) {
            _this2.drawItem(i2);
          });
        }
        return this;
      };
      Scatter.prototype.drawItem = function(id, els) {
        var groups = this.groups;
        var group = groups[id];
        if (typeof els === "number") {
          id = els;
          group = groups[els];
          els = null;
        }
        if (!(group && group.count && group.opacity)) return;
        if (group.activation[0]) {
          this.drawCircle(this.getMarkerDrawOptions(0, group, els));
        }
        var batch = [];
        for (var i = 1; i < group.activation.length; i++) {
          if (!group.activation[i] || group.activation[i] !== true && !group.activation[i].data.length) continue;
          batch.push.apply(batch, _toConsumableArray(this.getMarkerDrawOptions(i, group, els)));
        }
        if (batch.length) {
          this.drawMarker(batch);
        }
      };
      Scatter.prototype.getMarkerDrawOptions = function(markerId, group, elements) {
        var range = group.range, tree = group.tree, viewport = group.viewport, activation = group.activation, selectionBuffer = group.selectionBuffer, count = group.count;
        var regl = this.regl;
        if (!tree) {
          if (elements) {
            return [extend({}, group, {
              markerTexture: this.markerTextures[markerId],
              activation: activation[markerId],
              count: elements.length,
              elements,
              offset: 0
            })];
          }
          return [extend({}, group, {
            markerTexture: this.markerTextures[markerId],
            activation: activation[markerId],
            offset: 0
          })];
        }
        var batch = [];
        var lod = tree.range(range, {
          lod: true,
          px: [(range[2] - range[0]) / viewport.width, (range[3] - range[1]) / viewport.height]
        });
        if (elements) {
          var markerActivation = activation[markerId];
          var mask = markerActivation.data;
          var data = new Uint8Array(count);
          for (var i = 0; i < elements.length; i++) {
            var id = elements[i];
            data[id] = mask ? mask[id] : 1;
          }
          selectionBuffer.subdata(data);
        }
        for (var l = lod.length; l--; ) {
          var _lod$l = _slicedToArray(lod[l], 2), from = _lod$l[0], to = _lod$l[1];
          batch.push(extend({}, group, {
            markerTexture: this.markerTextures[markerId],
            activation: elements ? selectionBuffer : activation[markerId],
            offset: from,
            count: to - from
          }));
        }
        return batch;
      };
      Scatter.prototype.update = function() {
        var _this3 = this;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        if (!args.length) return;
        if (args.length === 1 && Array.isArray(args[0])) args = args[0];
        var groups = this.groups, gl = this.gl, regl = this.regl, maxSize = this.maxSize, maxColors = this.maxColors, palette = this.palette;
        this.groups = groups = args.map(function(options, i) {
          var group = groups[i];
          if (options === void 0) return group;
          if (options === null) options = {
            positions: null
          };
          else if (typeof options === "function") options = {
            ondraw: options
          };
          else if (typeof options[0] === "number") options = {
            positions: options
          };
          options = pick(options, {
            positions: "positions data points",
            snap: "snap cluster lod tree",
            size: "sizes size radius",
            borderSize: "borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline",
            color: "colors color fill fill-color fillColor",
            borderColor: "borderColors borderColor stroke stroke-color strokeColor",
            marker: "markers marker shape",
            range: "range dataBox databox",
            viewport: "viewport viewPort viewBox viewbox",
            opacity: "opacity alpha transparency",
            bounds: "bound bounds boundaries limits",
            tooManyColors: "tooManyColors palette paletteMode optimizePalette enablePalette"
          });
          if (options.positions === null) options.positions = [];
          if (options.tooManyColors != null) _this3.tooManyColors = options.tooManyColors;
          if (!group) {
            groups[i] = group = {
              id: i,
              scale: null,
              translate: null,
              scaleFract: null,
              translateFract: null,
              // buffers for active markers
              activation: [],
              // buffer for filtered markers
              selectionBuffer: regl.buffer({
                data: new Uint8Array(0),
                usage: "stream",
                type: "uint8"
              }),
              // buffers with data: it is faster to switch them per-pass
              // than provide one congregate buffer
              sizeBuffer: regl.buffer({
                data: new Uint8Array(0),
                usage: "dynamic",
                type: "uint8"
              }),
              colorBuffer: regl.buffer({
                data: new Uint8Array(0),
                usage: "dynamic",
                type: "uint8"
              }),
              positionBuffer: regl.buffer({
                data: new Uint8Array(0),
                usage: "dynamic",
                type: "float"
              }),
              positionFractBuffer: regl.buffer({
                data: new Uint8Array(0),
                usage: "dynamic",
                type: "float"
              })
            };
            options = extend({}, Scatter.defaults, options);
          }
          if (options.positions && !("marker" in options)) {
            options.marker = group.marker;
            delete group.marker;
          }
          if (options.marker && !("positions" in options)) {
            options.positions = group.positions;
            delete group.positions;
          }
          var hasSize = 0, hasColor = 0;
          updateDiff(group, options, [{
            snap: true,
            size: function size2(s, group2) {
              if (s == null) s = Scatter.defaults.size;
              hasSize += s && s.length ? 1 : 0;
              return s;
            },
            borderSize: function borderSize2(s, group2) {
              if (s == null) s = Scatter.defaults.borderSize;
              hasSize += s && s.length ? 1 : 0;
              return s;
            },
            opacity: parseFloat,
            // add colors to palette, save references
            color: function color2(c, group2) {
              if (c == null) c = Scatter.defaults.color;
              c = _this3.updateColor(c);
              hasColor++;
              return c;
            },
            borderColor: function borderColor2(c, group2) {
              if (c == null) c = Scatter.defaults.borderColor;
              c = _this3.updateColor(c);
              hasColor++;
              return c;
            },
            bounds: function bounds(_bounds, group2, options2) {
              if (!("range" in options2)) options2.range = null;
              return _bounds;
            },
            positions: function positions(_positions, group2, options2) {
              var snap = group2.snap;
              var positionBuffer = group2.positionBuffer, positionFractBuffer = group2.positionFractBuffer, selectionBuffer = group2.selectionBuffer;
              if (_positions.x || _positions.y) {
                if (_positions.x.length) {
                  group2.xAttr = {
                    buffer: regl.buffer(_positions.x),
                    offset: 0,
                    stride: 4,
                    count: _positions.x.length
                  };
                } else {
                  group2.xAttr = {
                    buffer: _positions.x.buffer,
                    offset: _positions.x.offset * 4 || 0,
                    stride: (_positions.x.stride || 1) * 4,
                    count: _positions.x.count
                  };
                }
                if (_positions.y.length) {
                  group2.yAttr = {
                    buffer: regl.buffer(_positions.y),
                    offset: 0,
                    stride: 4,
                    count: _positions.y.length
                  };
                } else {
                  group2.yAttr = {
                    buffer: _positions.y.buffer,
                    offset: _positions.y.offset * 4 || 0,
                    stride: (_positions.y.stride || 1) * 4,
                    count: _positions.y.count
                  };
                }
                group2.count = Math.max(group2.xAttr.count, group2.yAttr.count);
                return _positions;
              }
              _positions = flatten(_positions, "float64");
              var count2 = group2.count = Math.floor(_positions.length / 2);
              var bounds = group2.bounds = count2 ? getBounds(_positions, 2) : null;
              if (!options2.range && !group2.range) {
                delete group2.range;
                options2.range = bounds;
              }
              if (!options2.marker && !group2.marker) {
                delete group2.marker;
                options2.marker = null;
              }
              if (snap && (snap === true || count2 > snap)) {
                group2.tree = cluster(_positions, {
                  bounds
                });
              } else if (snap && snap.length) {
                group2.tree = snap;
              }
              if (group2.tree) {
                var opts = {
                  primitive: "points",
                  usage: "static",
                  data: group2.tree,
                  type: "uint32"
                };
                if (group2.elements) group2.elements(opts);
                else group2.elements = regl.elements(opts);
              }
              var float_data = f32.float32(_positions);
              positionBuffer({
                data: float_data,
                usage: "dynamic"
              });
              var frac_data = f32.fract32(_positions, float_data);
              positionFractBuffer({
                data: frac_data,
                usage: "dynamic"
              });
              selectionBuffer({
                data: new Uint8Array(count2),
                type: "uint8",
                usage: "stream"
              });
              return _positions;
            }
          }, {
            // create marker ids corresponding to known marker textures
            marker: function marker(markers, group2, options2) {
              var activation = group2.activation;
              activation.forEach(function(buffer) {
                return buffer && buffer.destroy && buffer.destroy();
              });
              activation.length = 0;
              if (!markers || typeof markers[0] === "number") {
                var id = _this3.addMarker(markers);
                activation[id] = true;
              } else {
                var markerMasks = [];
                for (var _i = 0, l = Math.min(markers.length, group2.count); _i < l; _i++) {
                  var _id = _this3.addMarker(markers[_i]);
                  if (!markerMasks[_id]) markerMasks[_id] = new Uint8Array(group2.count);
                  markerMasks[_id][_i] = 1;
                }
                for (var _id2 = 0; _id2 < markerMasks.length; _id2++) {
                  if (!markerMasks[_id2]) continue;
                  var opts = {
                    data: markerMasks[_id2],
                    type: "uint8",
                    usage: "static"
                  };
                  if (!activation[_id2]) {
                    activation[_id2] = regl.buffer(opts);
                  } else {
                    activation[_id2](opts);
                  }
                  activation[_id2].data = markerMasks[_id2];
                }
              }
              return markers;
            },
            range: function range(_range, group2, options2) {
              var bounds = group2.bounds;
              if (!bounds) return;
              if (!_range) _range = bounds;
              group2.scale = [1 / (_range[2] - _range[0]), 1 / (_range[3] - _range[1])];
              group2.translate = [-_range[0], -_range[1]];
              group2.scaleFract = f32.fract(group2.scale);
              group2.translateFract = f32.fract(group2.translate);
              return _range;
            },
            viewport: function viewport(vp) {
              var rect = parseRect(vp || [gl.drawingBufferWidth, gl.drawingBufferHeight]);
              return rect;
            }
          }]);
          if (hasSize) {
            var _group = group, count = _group.count, size = _group.size, borderSize = _group.borderSize, sizeBuffer = _group.sizeBuffer;
            var sizes = new Uint8Array(count * 2);
            if (size.length || borderSize.length) {
              for (var _i2 = 0; _i2 < count; _i2++) {
                sizes[_i2 * 2] = Math.round((size[_i2] == null ? size : size[_i2]) * 255 / maxSize);
                sizes[_i2 * 2 + 1] = Math.round((borderSize[_i2] == null ? borderSize : borderSize[_i2]) * 255 / maxSize);
              }
            }
            sizeBuffer({
              data: sizes,
              usage: "dynamic"
            });
          }
          if (hasColor) {
            var _group2 = group, _count = _group2.count, color = _group2.color, borderColor = _group2.borderColor, colorBuffer = _group2.colorBuffer;
            var colors;
            if (_this3.tooManyColors) {
              if (color.length || borderColor.length) {
                colors = new Uint8Array(_count * 8);
                for (var _i3 = 0; _i3 < _count; _i3++) {
                  var _colorId = color[_i3];
                  colors[_i3 * 8] = palette[_colorId * 4];
                  colors[_i3 * 8 + 1] = palette[_colorId * 4 + 1];
                  colors[_i3 * 8 + 2] = palette[_colorId * 4 + 2];
                  colors[_i3 * 8 + 3] = palette[_colorId * 4 + 3];
                  var borderColorId = borderColor[_i3];
                  colors[_i3 * 8 + 4] = palette[borderColorId * 4];
                  colors[_i3 * 8 + 5] = palette[borderColorId * 4 + 1];
                  colors[_i3 * 8 + 6] = palette[borderColorId * 4 + 2];
                  colors[_i3 * 8 + 7] = palette[borderColorId * 4 + 3];
                }
              }
            } else {
              if (color.length || borderColor.length) {
                colors = new Uint8Array(_count * 4 + 2);
                for (var _i4 = 0; _i4 < _count; _i4++) {
                  if (color[_i4] != null) {
                    colors[_i4 * 4] = color[_i4] % maxColors;
                    colors[_i4 * 4 + 1] = Math.floor(color[_i4] / maxColors);
                  }
                  if (borderColor[_i4] != null) {
                    colors[_i4 * 4 + 2] = borderColor[_i4] % maxColors;
                    colors[_i4 * 4 + 3] = Math.floor(borderColor[_i4] / maxColors);
                  }
                }
              }
            }
            colorBuffer({
              data: colors || new Uint8Array(0),
              type: "uint8",
              usage: "dynamic"
            });
          }
          return group;
        });
      };
      Scatter.prototype.addMarker = function(sdf) {
        var markerTextures = this.markerTextures, regl = this.regl, markerCache = this.markerCache;
        var pos = sdf == null ? 0 : markerCache.indexOf(sdf);
        if (pos >= 0) return pos;
        var distArr;
        if (sdf instanceof Uint8Array || sdf instanceof Uint8ClampedArray) {
          distArr = sdf;
        } else {
          distArr = new Uint8Array(sdf.length);
          for (var i = 0, l = sdf.length; i < l; i++) {
            distArr[i] = sdf[i] * 255;
          }
        }
        var radius = Math.floor(Math.sqrt(distArr.length));
        pos = markerTextures.length;
        markerCache.push(sdf);
        markerTextures.push(regl.texture({
          channels: 1,
          data: distArr,
          radius,
          mag: "linear",
          min: "linear"
        }));
        return pos;
      };
      Scatter.prototype.updateColor = function(colors) {
        var paletteIds = this.paletteIds, palette = this.palette, maxColors = this.maxColors;
        if (!Array.isArray(colors)) {
          colors = [colors];
        }
        var idx = [];
        if (typeof colors[0] === "number") {
          var grouped = [];
          if (Array.isArray(colors)) {
            for (var i = 0; i < colors.length; i += 4) {
              grouped.push(colors.slice(i, i + 4));
            }
          } else {
            for (var _i5 = 0; _i5 < colors.length; _i5 += 4) {
              grouped.push(colors.subarray(_i5, _i5 + 4));
            }
          }
          colors = grouped;
        }
        for (var _i6 = 0; _i6 < colors.length; _i6++) {
          var color = colors[_i6];
          color = rgba2(color, "uint8");
          var id = colorId(color, false);
          if (paletteIds[id] == null) {
            var pos = palette.length;
            paletteIds[id] = Math.floor(pos / 4);
            palette[pos] = color[0];
            palette[pos + 1] = color[1];
            palette[pos + 2] = color[2];
            palette[pos + 3] = color[3];
          }
          idx[_i6] = paletteIds[id];
        }
        if (!this.tooManyColors && palette.length > maxColors * 4) this.tooManyColors = true;
        this.updatePalette(palette);
        return idx.length === 1 ? idx[0] : idx;
      };
      Scatter.prototype.updatePalette = function(palette) {
        if (this.tooManyColors) return;
        var maxColors = this.maxColors, paletteTexture = this.paletteTexture;
        var requiredHeight = Math.ceil(palette.length * 0.25 / maxColors);
        if (requiredHeight > 1) {
          palette = palette.slice();
          for (var i = palette.length * 0.25 % maxColors; i < requiredHeight * maxColors; i++) {
            palette.push(0, 0, 0, 0);
          }
        }
        if (paletteTexture.height < requiredHeight) {
          paletteTexture.resize(maxColors, requiredHeight);
        }
        paletteTexture.subimage({
          width: Math.min(palette.length * 0.25, maxColors),
          height: requiredHeight,
          data: palette
        }, 0, 0);
      };
      Scatter.prototype.destroy = function() {
        this.groups.forEach(function(group) {
          group.sizeBuffer.destroy();
          group.positionBuffer.destroy();
          group.positionFractBuffer.destroy();
          group.colorBuffer.destroy();
          group.activation.forEach(function(b) {
            return b && b.destroy && b.destroy();
          });
          group.selectionBuffer.destroy();
          if (group.elements) group.elements.destroy();
        });
        this.groups.length = 0;
        this.paletteTexture.destroy();
        this.markerTextures.forEach(function(txt) {
          return txt && txt.destroy && txt.destroy();
        });
        return this;
      };
      var extend$1 = require_object_assign();
      var reglScatter2d = function reglScatter2d2(regl, options) {
        var scatter$1 = new scatter(regl, options);
        var render = scatter$1.render.bind(scatter$1);
        extend$1(render, {
          render,
          update: scatter$1.update.bind(scatter$1),
          draw: scatter$1.draw.bind(scatter$1),
          destroy: scatter$1.destroy.bind(scatter$1),
          regl: scatter$1.regl,
          gl: scatter$1.gl,
          canvas: scatter$1.gl.canvas,
          groups: scatter$1.groups,
          markers: scatter$1.markerCache,
          palette: scatter$1.palette
        });
        return render;
      };
      module.exports = reglScatter2d;
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut;
      module.exports.default = earcut;
      function earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start) return start;
        if (!end) end = start;
        var p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear) return;
        if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0) return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p = c.next;
        while (p !== a) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0) return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
          p = p.prevZ;
          if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
          var a = p.prev, b = p.next.next;
          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
          var b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next) list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          outerNode = eliminateHole(queue[i], outerNode);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
              qx = x;
              m = p.x < p.next.x ? p : p.next;
              if (x === hx) return m;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m) return null;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
          if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q) break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail) tail.nextZ = e;
              else list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x, y, minX, minY, invSize) {
        x = (x - minX) * invSize | 0;
        y = (y - minY) * invSize | 0;
        x = (x | x << 8) & 16711935;
        x = (x | x << 4) & 252645135;
        x = (x | x << 2) & 858993459;
        x = (x | x << 1) & 1431655765;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x | y << 1;
      }
      function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
        (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
        equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
      }
      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign(area(p1, q1, p2));
        var o2 = sign(area(p1, q1, q2));
        var o3 = sign(area(p2, q2, p1));
        var o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4) return true;
        if (o1 === 0 && onSegment(p1, p2, q1)) return true;
        if (o2 === 0 && onSegment(p1, q2, q1)) return true;
        if (o3 === 0 && onSegment(p2, p1, q2)) return true;
        if (o4 === 0 && onSegment(p2, q1, q2)) return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        var p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) p.prevZ.nextZ = p.nextZ;
        if (p.nextZ) p.nextZ.prevZ = p.prevZ;
      }
      function Node(i, x, y) {
        this.i = i;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
          sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum;
      }
      earcut.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/array-normalize/index.js
  var require_array_normalize = __commonJS({
    "node_modules/array-normalize/index.js"(exports, module) {
      "use strict";
      var getBounds = require_array_bounds();
      module.exports = normalize;
      function normalize(arr, dim, bounds) {
        if (!arr || arr.length == null) throw Error("Argument should be an array");
        if (dim == null) dim = 1;
        if (bounds == null) bounds = getBounds(arr, dim);
        for (var offset = 0; offset < dim; offset++) {
          var max = bounds[dim + offset], min = bounds[offset], i = offset, l = arr.length;
          if (max === Infinity && min === -Infinity) {
            for (i = offset; i < l; i += dim) {
              arr[i] = arr[i] === max ? 1 : arr[i] === min ? 0 : 0.5;
            }
          } else if (max === Infinity) {
            for (i = offset; i < l; i += dim) {
              arr[i] = arr[i] === max ? 1 : 0;
            }
          } else if (min === -Infinity) {
            for (i = offset; i < l; i += dim) {
              arr[i] = arr[i] === min ? 0 : 1;
            }
          } else {
            var range = max - min;
            for (i = offset; i < l; i += dim) {
              if (!isNaN(arr[i])) {
                arr[i] = range === 0 ? 0.5 : (arr[i] - min) / range;
              }
            }
          }
        }
        return arr;
      }
    }
  });

  // node_modules/es6-weak-map/is-implemented.js
  var require_is_implemented = __commonJS({
    "node_modules/es6-weak-map/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var weakMap, obj;
        if (typeof WeakMap !== "function") return false;
        try {
          weakMap = new WeakMap([[obj = {}, "one"], [{}, "two"], [{}, "three"]]);
        } catch (e) {
          return false;
        }
        if (String(weakMap) !== "[object WeakMap]") return false;
        if (typeof weakMap.set !== "function") return false;
        if (weakMap.set({}, 1) !== weakMap) return false;
        if (typeof weakMap.delete !== "function") return false;
        if (typeof weakMap.has !== "function") return false;
        if (weakMap.get(obj) !== "one") return false;
        return true;
      };
    }
  });

  // node_modules/es5-ext/function/noop.js
  var require_noop2 = __commonJS({
    "node_modules/es5-ext/function/noop.js"(exports, module) {
      "use strict";
      module.exports = function() {
      };
    }
  });

  // node_modules/es5-ext/object/is-value.js
  var require_is_value = __commonJS({
    "node_modules/es5-ext/object/is-value.js"(exports, module) {
      "use strict";
      var _undefined = require_noop2()();
      module.exports = function(val) {
        return val !== _undefined && val !== null;
      };
    }
  });

  // node_modules/es5-ext/object/set-prototype-of/is-implemented.js
  var require_is_implemented2 = __commonJS({
    "node_modules/es5-ext/object/set-prototype-of/is-implemented.js"(exports, module) {
      "use strict";
      var create = Object.create;
      var getPrototypeOf = Object.getPrototypeOf;
      var plainObject = {};
      module.exports = function() {
        var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
        if (typeof setPrototypeOf !== "function") return false;
        return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
      };
    }
  });

  // node_modules/es5-ext/object/is-object.js
  var require_is_object = __commonJS({
    "node_modules/es5-ext/object/is-object.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var map = { function: true, object: true };
      module.exports = function(value) {
        return isValue(value) && map[typeof value] || false;
      };
    }
  });

  // node_modules/es5-ext/object/valid-value.js
  var require_valid_value = __commonJS({
    "node_modules/es5-ext/object/valid-value.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      module.exports = function(value) {
        if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
        return value;
      };
    }
  });

  // node_modules/es5-ext/object/create.js
  var require_create2 = __commonJS({
    "node_modules/es5-ext/object/create.js"(exports, module) {
      "use strict";
      var create = Object.create;
      var shim;
      if (!require_is_implemented2()()) {
        shim = require_shim3();
      }
      module.exports = function() {
        var nullObject, polyProps, desc;
        if (!shim) return create;
        if (shim.level !== 1) return create;
        nullObject = {};
        polyProps = {};
        desc = { configurable: false, enumerable: false, writable: true, value: void 0 };
        Object.getOwnPropertyNames(Object.prototype).forEach(function(name) {
          if (name === "__proto__") {
            polyProps[name] = {
              configurable: true,
              enumerable: false,
              writable: true,
              value: void 0
            };
            return;
          }
          polyProps[name] = desc;
        });
        Object.defineProperties(nullObject, polyProps);
        Object.defineProperty(shim, "nullPolyfill", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: nullObject
        });
        return function(prototype, props) {
          return create(prototype === null ? nullObject : prototype, props);
        };
      }();
    }
  });

  // node_modules/es5-ext/object/set-prototype-of/shim.js
  var require_shim3 = __commonJS({
    "node_modules/es5-ext/object/set-prototype-of/shim.js"(exports, module) {
      "use strict";
      var isObject = require_is_object();
      var value = require_valid_value();
      var objIsPrototypeOf = Object.prototype.isPrototypeOf;
      var defineProperty = Object.defineProperty;
      var nullDesc = { configurable: true, enumerable: false, writable: true, value: void 0 };
      var validate;
      validate = function(obj, prototype) {
        value(obj);
        if (prototype === null || isObject(prototype)) return obj;
        throw new TypeError("Prototype must be null or an object");
      };
      module.exports = function(status) {
        var fn, set;
        if (!status) return null;
        if (status.level === 2) {
          if (status.set) {
            set = status.set;
            fn = function(obj, prototype) {
              set.call(validate(obj, prototype), prototype);
              return obj;
            };
          } else {
            fn = function(obj, prototype) {
              validate(obj, prototype).__proto__ = prototype;
              return obj;
            };
          }
        } else {
          fn = function self2(obj, prototype) {
            var isNullBase;
            validate(obj, prototype);
            isNullBase = objIsPrototypeOf.call(self2.nullPolyfill, obj);
            if (isNullBase) delete self2.nullPolyfill.__proto__;
            if (prototype === null) prototype = self2.nullPolyfill;
            obj.__proto__ = prototype;
            if (isNullBase) defineProperty(self2.nullPolyfill, "__proto__", nullDesc);
            return obj;
          };
        }
        return Object.defineProperty(fn, "level", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: status.level
        });
      }(
        function() {
          var tmpObj1 = /* @__PURE__ */ Object.create(null), tmpObj2 = {}, set, desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");
          if (desc) {
            try {
              set = desc.set;
              set.call(tmpObj1, tmpObj2);
            } catch (ignore) {
            }
            if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set, level: 2 };
          }
          tmpObj1.__proto__ = tmpObj2;
          if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };
          tmpObj1 = {};
          tmpObj1.__proto__ = tmpObj2;
          if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };
          return false;
        }()
      );
      require_create2();
    }
  });

  // node_modules/es5-ext/object/set-prototype-of/index.js
  var require_set_prototype_of = __commonJS({
    "node_modules/es5-ext/object/set-prototype-of/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented2()() ? Object.setPrototypeOf : require_shim3();
    }
  });

  // node_modules/es5-ext/object/valid-object.js
  var require_valid_object = __commonJS({
    "node_modules/es5-ext/object/valid-object.js"(exports, module) {
      "use strict";
      var isObject = require_is_object();
      module.exports = function(value) {
        if (!isObject(value)) throw new TypeError(value + " is not an Object");
        return value;
      };
    }
  });

  // node_modules/es5-ext/string/random-uniq.js
  var require_random_uniq = __commonJS({
    "node_modules/es5-ext/string/random-uniq.js"(exports, module) {
      "use strict";
      var generated = /* @__PURE__ */ Object.create(null);
      var random = Math.random;
      module.exports = function() {
        var str;
        do {
          str = random().toString(36).slice(2);
        } while (generated[str]);
        return str;
      };
    }
  });

  // node_modules/type/value/is.js
  var require_is = __commonJS({
    "node_modules/type/value/is.js"(exports, module) {
      "use strict";
      var _undefined = void 0;
      module.exports = function(value) {
        return value !== _undefined && value !== null;
      };
    }
  });

  // node_modules/type/object/is.js
  var require_is2 = __commonJS({
    "node_modules/type/object/is.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var possibleTypes = {
        "object": true,
        "function": true,
        "undefined": true
        /* document.all */
      };
      module.exports = function(value) {
        if (!isValue(value)) return false;
        return hasOwnProperty.call(possibleTypes, typeof value);
      };
    }
  });

  // node_modules/type/prototype/is.js
  var require_is3 = __commonJS({
    "node_modules/type/prototype/is.js"(exports, module) {
      "use strict";
      var isObject = require_is2();
      module.exports = function(value) {
        if (!isObject(value)) return false;
        try {
          if (!value.constructor) return false;
          return value.constructor.prototype === value;
        } catch (error) {
          return false;
        }
      };
    }
  });

  // node_modules/type/function/is.js
  var require_is4 = __commonJS({
    "node_modules/type/function/is.js"(exports, module) {
      "use strict";
      var isPrototype = require_is3();
      module.exports = function(value) {
        if (typeof value !== "function") return false;
        if (!hasOwnProperty.call(value, "length")) return false;
        try {
          if (typeof value.length !== "number") return false;
          if (typeof value.call !== "function") return false;
          if (typeof value.apply !== "function") return false;
        } catch (error) {
          return false;
        }
        return !isPrototype(value);
      };
    }
  });

  // node_modules/type/plain-function/is.js
  var require_is5 = __commonJS({
    "node_modules/type/plain-function/is.js"(exports, module) {
      "use strict";
      var isFunction = require_is4();
      var classRe = /^\s*class[\s{/}]/;
      var functionToString = Function.prototype.toString;
      module.exports = function(value) {
        if (!isFunction(value)) return false;
        if (classRe.test(functionToString.call(value))) return false;
        return true;
      };
    }
  });

  // node_modules/es5-ext/object/assign/is-implemented.js
  var require_is_implemented3 = __commonJS({
    "node_modules/es5-ext/object/assign/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var assign = Object.assign, obj;
        if (typeof assign !== "function") return false;
        obj = { foo: "raz" };
        assign(obj, { bar: "dwa" }, { trzy: "trzy" });
        return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
      };
    }
  });

  // node_modules/es5-ext/object/keys/is-implemented.js
  var require_is_implemented4 = __commonJS({
    "node_modules/es5-ext/object/keys/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        try {
          Object.keys("primitive");
          return true;
        } catch (e) {
          return false;
        }
      };
    }
  });

  // node_modules/es5-ext/object/keys/shim.js
  var require_shim4 = __commonJS({
    "node_modules/es5-ext/object/keys/shim.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var keys = Object.keys;
      module.exports = function(object) {
        return keys(isValue(object) ? Object(object) : object);
      };
    }
  });

  // node_modules/es5-ext/object/keys/index.js
  var require_keys = __commonJS({
    "node_modules/es5-ext/object/keys/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented4()() ? Object.keys : require_shim4();
    }
  });

  // node_modules/es5-ext/object/assign/shim.js
  var require_shim5 = __commonJS({
    "node_modules/es5-ext/object/assign/shim.js"(exports, module) {
      "use strict";
      var keys = require_keys();
      var value = require_valid_value();
      var max = Math.max;
      module.exports = function(dest, src) {
        var error, i, length = max(arguments.length, 2), assign;
        dest = Object(value(dest));
        assign = function(key) {
          try {
            dest[key] = src[key];
          } catch (e) {
            if (!error) error = e;
          }
        };
        for (i = 1; i < length; ++i) {
          src = arguments[i];
          keys(src).forEach(assign);
        }
        if (error !== void 0) throw error;
        return dest;
      };
    }
  });

  // node_modules/es5-ext/object/assign/index.js
  var require_assign = __commonJS({
    "node_modules/es5-ext/object/assign/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented3()() ? Object.assign : require_shim5();
    }
  });

  // node_modules/es5-ext/object/normalize-options.js
  var require_normalize_options = __commonJS({
    "node_modules/es5-ext/object/normalize-options.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var forEach = Array.prototype.forEach;
      var create = Object.create;
      var process2 = function(src, obj) {
        var key;
        for (key in src) obj[key] = src[key];
      };
      module.exports = function(opts1) {
        var result = create(null);
        forEach.call(arguments, function(options) {
          if (!isValue(options)) return;
          process2(Object(options), result);
        });
        return result;
      };
    }
  });

  // node_modules/es5-ext/string/#/contains/is-implemented.js
  var require_is_implemented5 = __commonJS({
    "node_modules/es5-ext/string/#/contains/is-implemented.js"(exports, module) {
      "use strict";
      var str = "razdwatrzy";
      module.exports = function() {
        if (typeof str.contains !== "function") return false;
        return str.contains("dwa") === true && str.contains("foo") === false;
      };
    }
  });

  // node_modules/es5-ext/string/#/contains/shim.js
  var require_shim6 = __commonJS({
    "node_modules/es5-ext/string/#/contains/shim.js"(exports, module) {
      "use strict";
      var indexOf = String.prototype.indexOf;
      module.exports = function(searchString) {
        return indexOf.call(this, searchString, arguments[1]) > -1;
      };
    }
  });

  // node_modules/es5-ext/string/#/contains/index.js
  var require_contains = __commonJS({
    "node_modules/es5-ext/string/#/contains/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented5()() ? String.prototype.contains : require_shim6();
    }
  });

  // node_modules/d/index.js
  var require_d = __commonJS({
    "node_modules/d/index.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var isPlainFunction = require_is5();
      var assign = require_assign();
      var normalizeOpts = require_normalize_options();
      var contains = require_contains();
      var d = module.exports = function(dscr, value) {
        var c, e, w, options, desc;
        if (arguments.length < 2 || typeof dscr !== "string") {
          options = value;
          value = dscr;
          dscr = null;
        } else {
          options = arguments[2];
        }
        if (isValue(dscr)) {
          c = contains.call(dscr, "c");
          e = contains.call(dscr, "e");
          w = contains.call(dscr, "w");
        } else {
          c = w = true;
          e = false;
        }
        desc = { value, configurable: c, enumerable: e, writable: w };
        return !options ? desc : assign(normalizeOpts(options), desc);
      };
      d.gs = function(dscr, get, set) {
        var c, e, options, desc;
        if (typeof dscr !== "string") {
          options = set;
          set = get;
          get = dscr;
          dscr = null;
        } else {
          options = arguments[3];
        }
        if (!isValue(get)) {
          get = void 0;
        } else if (!isPlainFunction(get)) {
          options = get;
          get = set = void 0;
        } else if (!isValue(set)) {
          set = void 0;
        } else if (!isPlainFunction(set)) {
          options = set;
          set = void 0;
        }
        if (isValue(dscr)) {
          c = contains.call(dscr, "c");
          e = contains.call(dscr, "e");
        } else {
          c = true;
          e = false;
        }
        desc = { get, set, configurable: c, enumerable: e };
        return !options ? desc : assign(normalizeOpts(options), desc);
      };
    }
  });

  // node_modules/es5-ext/function/is-arguments.js
  var require_is_arguments2 = __commonJS({
    "node_modules/es5-ext/function/is-arguments.js"(exports, module) {
      "use strict";
      var objToString = Object.prototype.toString;
      var id = objToString.call(/* @__PURE__ */ function() {
        return arguments;
      }());
      module.exports = function(value) {
        return objToString.call(value) === id;
      };
    }
  });

  // node_modules/es5-ext/string/is-string.js
  var require_is_string = __commonJS({
    "node_modules/es5-ext/string/is-string.js"(exports, module) {
      "use strict";
      var objToString = Object.prototype.toString;
      var id = objToString.call("");
      module.exports = function(value) {
        return typeof value === "string" || value && typeof value === "object" && (value instanceof String || objToString.call(value) === id) || false;
      };
    }
  });

  // node_modules/ext/global-this/is-implemented.js
  var require_is_implemented6 = __commonJS({
    "node_modules/ext/global-this/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        if (typeof globalThis !== "object") return false;
        if (!globalThis) return false;
        return globalThis.Array === Array;
      };
    }
  });

  // node_modules/ext/global-this/implementation.js
  var require_implementation6 = __commonJS({
    "node_modules/ext/global-this/implementation.js"(exports, module) {
      var naiveFallback = function() {
        if (typeof self === "object" && self) return self;
        if (typeof window === "object" && window) return window;
        throw new Error("Unable to resolve global `this`");
      };
      module.exports = function() {
        if (this) return this;
        try {
          Object.defineProperty(Object.prototype, "__global__", {
            get: function() {
              return this;
            },
            configurable: true
          });
        } catch (error) {
          return naiveFallback();
        }
        try {
          if (!__global__) return naiveFallback();
          return __global__;
        } finally {
          delete Object.prototype.__global__;
        }
      }();
    }
  });

  // node_modules/ext/global-this/index.js
  var require_global_this = __commonJS({
    "node_modules/ext/global-this/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented6()() ? globalThis : require_implementation6();
    }
  });

  // node_modules/es6-symbol/is-implemented.js
  var require_is_implemented7 = __commonJS({
    "node_modules/es6-symbol/is-implemented.js"(exports, module) {
      "use strict";
      var global2 = require_global_this();
      var validTypes = { object: true, symbol: true };
      module.exports = function() {
        var Symbol2 = global2.Symbol;
        var symbol;
        if (typeof Symbol2 !== "function") return false;
        symbol = Symbol2("test symbol");
        try {
          String(symbol);
        } catch (e) {
          return false;
        }
        if (!validTypes[typeof Symbol2.iterator]) return false;
        if (!validTypes[typeof Symbol2.toPrimitive]) return false;
        if (!validTypes[typeof Symbol2.toStringTag]) return false;
        return true;
      };
    }
  });

  // node_modules/es6-symbol/is-symbol.js
  var require_is_symbol = __commonJS({
    "node_modules/es6-symbol/is-symbol.js"(exports, module) {
      "use strict";
      module.exports = function(value) {
        if (!value) return false;
        if (typeof value === "symbol") return true;
        if (!value.constructor) return false;
        if (value.constructor.name !== "Symbol") return false;
        return value[value.constructor.toStringTag] === "Symbol";
      };
    }
  });

  // node_modules/es6-symbol/validate-symbol.js
  var require_validate_symbol = __commonJS({
    "node_modules/es6-symbol/validate-symbol.js"(exports, module) {
      "use strict";
      var isSymbol = require_is_symbol();
      module.exports = function(value) {
        if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
        return value;
      };
    }
  });

  // node_modules/es6-symbol/lib/private/generate-name.js
  var require_generate_name = __commonJS({
    "node_modules/es6-symbol/lib/private/generate-name.js"(exports, module) {
      "use strict";
      var d = require_d();
      var create = Object.create;
      var defineProperty = Object.defineProperty;
      var objPrototype = Object.prototype;
      var created = create(null);
      module.exports = function(desc) {
        var postfix = 0, name, ie11BugWorkaround;
        while (created[desc + (postfix || "")]) ++postfix;
        desc += postfix || "";
        created[desc] = true;
        name = "@@" + desc;
        defineProperty(
          objPrototype,
          name,
          d.gs(null, function(value) {
            if (ie11BugWorkaround) return;
            ie11BugWorkaround = true;
            defineProperty(this, name, d(value));
            ie11BugWorkaround = false;
          })
        );
        return name;
      };
    }
  });

  // node_modules/es6-symbol/lib/private/setup/standard-symbols.js
  var require_standard_symbols = __commonJS({
    "node_modules/es6-symbol/lib/private/setup/standard-symbols.js"(exports, module) {
      "use strict";
      var d = require_d();
      var NativeSymbol = require_global_this().Symbol;
      module.exports = function(SymbolPolyfill) {
        return Object.defineProperties(SymbolPolyfill, {
          // To ensure proper interoperability with other native functions (e.g. Array.from)
          // fallback to eventual native implementation of given symbol
          hasInstance: d(
            "",
            NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")
          ),
          isConcatSpreadable: d(
            "",
            NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")
          ),
          iterator: d("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
          match: d("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
          replace: d("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
          search: d("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
          species: d("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
          split: d("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
          toPrimitive: d(
            "",
            NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")
          ),
          toStringTag: d(
            "",
            NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")
          ),
          unscopables: d(
            "",
            NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables")
          )
        });
      };
    }
  });

  // node_modules/es6-symbol/lib/private/setup/symbol-registry.js
  var require_symbol_registry = __commonJS({
    "node_modules/es6-symbol/lib/private/setup/symbol-registry.js"(exports, module) {
      "use strict";
      var d = require_d();
      var validateSymbol = require_validate_symbol();
      var registry = /* @__PURE__ */ Object.create(null);
      module.exports = function(SymbolPolyfill) {
        return Object.defineProperties(SymbolPolyfill, {
          for: d(function(key) {
            if (registry[key]) return registry[key];
            return registry[key] = SymbolPolyfill(String(key));
          }),
          keyFor: d(function(symbol) {
            var key;
            validateSymbol(symbol);
            for (key in registry) {
              if (registry[key] === symbol) return key;
            }
            return void 0;
          })
        });
      };
    }
  });

  // node_modules/es6-symbol/polyfill.js
  var require_polyfill4 = __commonJS({
    "node_modules/es6-symbol/polyfill.js"(exports, module) {
      "use strict";
      var d = require_d();
      var validateSymbol = require_validate_symbol();
      var NativeSymbol = require_global_this().Symbol;
      var generateName = require_generate_name();
      var setupStandardSymbols = require_standard_symbols();
      var setupSymbolRegistry = require_symbol_registry();
      var create = Object.create;
      var defineProperties = Object.defineProperties;
      var defineProperty = Object.defineProperty;
      var SymbolPolyfill;
      var HiddenSymbol;
      var isNativeSafe;
      if (typeof NativeSymbol === "function") {
        try {
          String(NativeSymbol());
          isNativeSafe = true;
        } catch (ignore) {
        }
      } else {
        NativeSymbol = null;
      }
      HiddenSymbol = function Symbol2(description) {
        if (this instanceof HiddenSymbol) throw new TypeError("Symbol is not a constructor");
        return SymbolPolyfill(description);
      };
      module.exports = SymbolPolyfill = function Symbol2(description) {
        var symbol;
        if (this instanceof Symbol2) throw new TypeError("Symbol is not a constructor");
        if (isNativeSafe) return NativeSymbol(description);
        symbol = create(HiddenSymbol.prototype);
        description = description === void 0 ? "" : String(description);
        return defineProperties(symbol, {
          __description__: d("", description),
          __name__: d("", generateName(description))
        });
      };
      setupStandardSymbols(SymbolPolyfill);
      setupSymbolRegistry(SymbolPolyfill);
      defineProperties(HiddenSymbol.prototype, {
        constructor: d(SymbolPolyfill),
        toString: d("", function() {
          return this.__name__;
        })
      });
      defineProperties(SymbolPolyfill.prototype, {
        toString: d(function() {
          return "Symbol (" + validateSymbol(this).__description__ + ")";
        }),
        valueOf: d(function() {
          return validateSymbol(this);
        })
      });
      defineProperty(
        SymbolPolyfill.prototype,
        SymbolPolyfill.toPrimitive,
        d("", function() {
          var symbol = validateSymbol(this);
          if (typeof symbol === "symbol") return symbol;
          return symbol.toString();
        })
      );
      defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));
      defineProperty(
        HiddenSymbol.prototype,
        SymbolPolyfill.toStringTag,
        d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
      );
      defineProperty(
        HiddenSymbol.prototype,
        SymbolPolyfill.toPrimitive,
        d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
      );
    }
  });

  // node_modules/es6-symbol/index.js
  var require_es6_symbol = __commonJS({
    "node_modules/es6-symbol/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented7()() ? require_global_this().Symbol : require_polyfill4();
    }
  });

  // node_modules/es5-ext/array/#/clear.js
  var require_clear = __commonJS({
    "node_modules/es5-ext/array/#/clear.js"(exports, module) {
      "use strict";
      var value = require_valid_value();
      module.exports = function() {
        value(this).length = 0;
        return this;
      };
    }
  });

  // node_modules/es5-ext/object/valid-callable.js
  var require_valid_callable = __commonJS({
    "node_modules/es5-ext/object/valid-callable.js"(exports, module) {
      "use strict";
      module.exports = function(fn) {
        if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
        return fn;
      };
    }
  });

  // node_modules/type/string/coerce.js
  var require_coerce2 = __commonJS({
    "node_modules/type/string/coerce.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var isObject = require_is2();
      var objectToString = Object.prototype.toString;
      module.exports = function(value) {
        if (!isValue(value)) return null;
        if (isObject(value)) {
          var valueToString = value.toString;
          if (typeof valueToString !== "function") return null;
          if (valueToString === objectToString) return null;
        }
        try {
          return "" + value;
        } catch (error) {
          return null;
        }
      };
    }
  });

  // node_modules/type/lib/safe-to-string.js
  var require_safe_to_string = __commonJS({
    "node_modules/type/lib/safe-to-string.js"(exports, module) {
      "use strict";
      module.exports = function(value) {
        try {
          return value.toString();
        } catch (error) {
          try {
            return String(value);
          } catch (error2) {
            return null;
          }
        }
      };
    }
  });

  // node_modules/type/lib/to-short-string.js
  var require_to_short_string = __commonJS({
    "node_modules/type/lib/to-short-string.js"(exports, module) {
      "use strict";
      var safeToString = require_safe_to_string();
      var reNewLine = /[\n\r\u2028\u2029]/g;
      module.exports = function(value) {
        var string = safeToString(value);
        if (string === null) return "<Non-coercible to string value>";
        if (string.length > 100) string = string.slice(0, 99) + "\u2026";
        string = string.replace(reNewLine, function(char) {
          switch (char) {
            case "\n":
              return "\\n";
            case "\r":
              return "\\r";
            case "\u2028":
              return "\\u2028";
            case "\u2029":
              return "\\u2029";
            /* istanbul ignore next */
            default:
              throw new Error("Unexpected character");
          }
        });
        return string;
      };
    }
  });

  // node_modules/type/lib/resolve-exception.js
  var require_resolve_exception = __commonJS({
    "node_modules/type/lib/resolve-exception.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var isObject = require_is2();
      var stringCoerce = require_coerce2();
      var toShortString = require_to_short_string();
      var resolveMessage = function(message, value) {
        return message.replace("%v", toShortString(value));
      };
      module.exports = function(value, defaultMessage, inputOptions) {
        if (!isObject(inputOptions)) throw new TypeError(resolveMessage(defaultMessage, value));
        if (!isValue(value)) {
          if ("default" in inputOptions) return inputOptions["default"];
          if (inputOptions.isOptional) return null;
        }
        var errorMessage = stringCoerce(inputOptions.errorMessage);
        if (!isValue(errorMessage)) errorMessage = defaultMessage;
        throw new TypeError(resolveMessage(errorMessage, value));
      };
    }
  });

  // node_modules/type/value/ensure.js
  var require_ensure = __commonJS({
    "node_modules/type/value/ensure.js"(exports, module) {
      "use strict";
      var resolveException = require_resolve_exception();
      var is = require_is();
      module.exports = function(value) {
        if (is(value)) return value;
        return resolveException(value, "Cannot use %v", arguments[1]);
      };
    }
  });

  // node_modules/type/plain-function/ensure.js
  var require_ensure2 = __commonJS({
    "node_modules/type/plain-function/ensure.js"(exports, module) {
      "use strict";
      var resolveException = require_resolve_exception();
      var is = require_is5();
      module.exports = function(value) {
        if (is(value)) return value;
        return resolveException(value, "%v is not a plain function", arguments[1]);
      };
    }
  });

  // node_modules/es5-ext/array/from/is-implemented.js
  var require_is_implemented8 = __commonJS({
    "node_modules/es5-ext/array/from/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var from = Array.from, arr, result;
        if (typeof from !== "function") return false;
        arr = ["raz", "dwa"];
        result = from(arr);
        return Boolean(result && result !== arr && result[1] === "dwa");
      };
    }
  });

  // node_modules/es5-ext/function/is-function.js
  var require_is_function = __commonJS({
    "node_modules/es5-ext/function/is-function.js"(exports, module) {
      "use strict";
      var objToString = Object.prototype.toString;
      var isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
      module.exports = function(value) {
        return typeof value === "function" && isFunctionStringTag(objToString.call(value));
      };
    }
  });

  // node_modules/es5-ext/math/sign/is-implemented.js
  var require_is_implemented9 = __commonJS({
    "node_modules/es5-ext/math/sign/is-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        var sign = Math.sign;
        if (typeof sign !== "function") return false;
        return sign(10) === 1 && sign(-20) === -1;
      };
    }
  });

  // node_modules/es5-ext/math/sign/shim.js
  var require_shim7 = __commonJS({
    "node_modules/es5-ext/math/sign/shim.js"(exports, module) {
      "use strict";
      module.exports = function(value) {
        value = Number(value);
        if (isNaN(value) || value === 0) return value;
        return value > 0 ? 1 : -1;
      };
    }
  });

  // node_modules/es5-ext/math/sign/index.js
  var require_sign = __commonJS({
    "node_modules/es5-ext/math/sign/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented9()() ? Math.sign : require_shim7();
    }
  });

  // node_modules/es5-ext/number/to-integer.js
  var require_to_integer = __commonJS({
    "node_modules/es5-ext/number/to-integer.js"(exports, module) {
      "use strict";
      var sign = require_sign();
      var abs = Math.abs;
      var floor = Math.floor;
      module.exports = function(value) {
        if (isNaN(value)) return 0;
        value = Number(value);
        if (value === 0 || !isFinite(value)) return value;
        return sign(value) * floor(abs(value));
      };
    }
  });

  // node_modules/es5-ext/number/to-pos-integer.js
  var require_to_pos_integer = __commonJS({
    "node_modules/es5-ext/number/to-pos-integer.js"(exports, module) {
      "use strict";
      var toInteger = require_to_integer();
      var max = Math.max;
      module.exports = function(value) {
        return max(0, toInteger(value));
      };
    }
  });

  // node_modules/es5-ext/array/from/shim.js
  var require_shim8 = __commonJS({
    "node_modules/es5-ext/array/from/shim.js"(exports, module) {
      "use strict";
      var iteratorSymbol = require_es6_symbol().iterator;
      var isArguments = require_is_arguments2();
      var isFunction = require_is_function();
      var toPosInt = require_to_pos_integer();
      var callable = require_valid_callable();
      var validValue = require_valid_value();
      var isValue = require_is_value();
      var isString = require_is_string();
      var isArray = Array.isArray;
      var call = Function.prototype.call;
      var desc = { configurable: true, enumerable: true, writable: true, value: null };
      var defineProperty = Object.defineProperty;
      module.exports = function(arrayLike) {
        var mapFn = arguments[1], thisArg = arguments[2], Context, i, j, arr, length, code, iterator, result, getIterator, value;
        arrayLike = Object(validValue(arrayLike));
        if (isValue(mapFn)) callable(mapFn);
        if (!this || this === Array || !isFunction(this)) {
          if (!mapFn) {
            if (isArguments(arrayLike)) {
              length = arrayLike.length;
              if (length !== 1) return Array.apply(null, arrayLike);
              arr = new Array(1);
              arr[0] = arrayLike[0];
              return arr;
            }
            if (isArray(arrayLike)) {
              arr = new Array(length = arrayLike.length);
              for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
              return arr;
            }
          }
          arr = [];
        } else {
          Context = this;
        }
        if (!isArray(arrayLike)) {
          if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
            iterator = callable(getIterator).call(arrayLike);
            if (Context) arr = new Context();
            result = iterator.next();
            i = 0;
            while (!result.done) {
              value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
              if (Context) {
                desc.value = value;
                defineProperty(arr, i, desc);
              } else {
                arr[i] = value;
              }
              result = iterator.next();
              ++i;
            }
            length = i;
          } else if (isString(arrayLike)) {
            length = arrayLike.length;
            if (Context) arr = new Context();
            for (i = 0, j = 0; i < length; ++i) {
              value = arrayLike[i];
              if (i + 1 < length) {
                code = value.charCodeAt(0);
                if (code >= 55296 && code <= 56319) value += arrayLike[++i];
              }
              value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
              if (Context) {
                desc.value = value;
                defineProperty(arr, j, desc);
              } else {
                arr[j] = value;
              }
              ++j;
            }
            length = j;
          }
        }
        if (length === void 0) {
          length = toPosInt(arrayLike.length);
          if (Context) arr = new Context(length);
          for (i = 0; i < length; ++i) {
            value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
            if (Context) {
              desc.value = value;
              defineProperty(arr, i, desc);
            } else {
              arr[i] = value;
            }
          }
        }
        if (Context) {
          desc.value = null;
          arr.length = length;
        }
        return arr;
      };
    }
  });

  // node_modules/es5-ext/array/from/index.js
  var require_from = __commonJS({
    "node_modules/es5-ext/array/from/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented8()() ? Array.from : require_shim8();
    }
  });

  // node_modules/es5-ext/object/copy.js
  var require_copy2 = __commonJS({
    "node_modules/es5-ext/object/copy.js"(exports, module) {
      "use strict";
      var aFrom = require_from();
      var assign = require_assign();
      var value = require_valid_value();
      module.exports = function(obj) {
        var copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
        if (copy !== obj && !propertyNames) return copy;
        var result = {};
        if (propertyNames) {
          aFrom(propertyNames, function(propertyName) {
            if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];
          });
        } else {
          assign(result, obj);
        }
        return result;
      };
    }
  });

  // node_modules/es5-ext/object/_iterate.js
  var require_iterate = __commonJS({
    "node_modules/es5-ext/object/_iterate.js"(exports, module) {
      "use strict";
      var callable = require_valid_callable();
      var value = require_valid_value();
      var bind = Function.prototype.bind;
      var call = Function.prototype.call;
      var keys = Object.keys;
      var objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
      module.exports = function(method, defVal) {
        return function(obj, cb) {
          var list, thisArg = arguments[2], compareFn = arguments[3];
          obj = Object(value(obj));
          callable(cb);
          list = keys(obj);
          if (compareFn) {
            list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : void 0);
          }
          if (typeof method !== "function") method = list[method];
          return call.call(method, list, function(key, index) {
            if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
            return call.call(cb, thisArg, obj[key], key, obj, index);
          });
        };
      };
    }
  });

  // node_modules/es5-ext/object/for-each.js
  var require_for_each2 = __commonJS({
    "node_modules/es5-ext/object/for-each.js"(exports, module) {
      "use strict";
      module.exports = require_iterate()("forEach");
    }
  });

  // node_modules/es5-ext/object/map.js
  var require_map = __commonJS({
    "node_modules/es5-ext/object/map.js"(exports, module) {
      "use strict";
      var callable = require_valid_callable();
      var forEach = require_for_each2();
      var call = Function.prototype.call;
      module.exports = function(obj, cb) {
        var result = {}, thisArg = arguments[2];
        callable(cb);
        forEach(obj, function(value, key, targetObj, index) {
          result[key] = call.call(cb, thisArg, value, key, targetObj, index);
        });
        return result;
      };
    }
  });

  // node_modules/d/auto-bind.js
  var require_auto_bind = __commonJS({
    "node_modules/d/auto-bind.js"(exports, module) {
      "use strict";
      var isValue = require_is();
      var ensureValue = require_ensure();
      var ensurePlainFunction = require_ensure2();
      var copy = require_copy2();
      var normalizeOptions = require_normalize_options();
      var map = require_map();
      var bind = Function.prototype.bind;
      var defineProperty = Object.defineProperty;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var define2;
      define2 = function(name, desc, options) {
        var value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;
        dgs = copy(desc);
        delete dgs.writable;
        delete dgs.value;
        dgs.get = function() {
          if (!options.overwriteDefinition && hasOwnProperty2.call(this, name)) return value;
          desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
          defineProperty(this, name, desc);
          return this[name];
        };
        return dgs;
      };
      module.exports = function(props) {
        var options = normalizeOptions(arguments[1]);
        if (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);
        return map(props, function(desc, name) {
          return define2(name, desc, options);
        });
      };
    }
  });

  // node_modules/es6-iterator/index.js
  var require_es6_iterator = __commonJS({
    "node_modules/es6-iterator/index.js"(exports, module) {
      "use strict";
      var clear = require_clear();
      var assign = require_assign();
      var callable = require_valid_callable();
      var value = require_valid_value();
      var d = require_d();
      var autoBind = require_auto_bind();
      var Symbol2 = require_es6_symbol();
      var defineProperty = Object.defineProperty;
      var defineProperties = Object.defineProperties;
      var Iterator;
      module.exports = Iterator = function(list, context) {
        if (!(this instanceof Iterator)) throw new TypeError("Constructor requires 'new'");
        defineProperties(this, {
          __list__: d("w", value(list)),
          __context__: d("w", context),
          __nextIndex__: d("w", 0)
        });
        if (!context) return;
        callable(context.on);
        context.on("_add", this._onAdd);
        context.on("_delete", this._onDelete);
        context.on("_clear", this._onClear);
      };
      delete Iterator.prototype.constructor;
      defineProperties(
        Iterator.prototype,
        assign(
          {
            _next: d(function() {
              var i;
              if (!this.__list__) return void 0;
              if (this.__redo__) {
                i = this.__redo__.shift();
                if (i !== void 0) return i;
              }
              if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
              this._unBind();
              return void 0;
            }),
            next: d(function() {
              return this._createResult(this._next());
            }),
            _createResult: d(function(i) {
              if (i === void 0) return { done: true, value: void 0 };
              return { done: false, value: this._resolve(i) };
            }),
            _resolve: d(function(i) {
              return this.__list__[i];
            }),
            _unBind: d(function() {
              this.__list__ = null;
              delete this.__redo__;
              if (!this.__context__) return;
              this.__context__.off("_add", this._onAdd);
              this.__context__.off("_delete", this._onDelete);
              this.__context__.off("_clear", this._onClear);
              this.__context__ = null;
            }),
            toString: d(function() {
              return "[object " + (this[Symbol2.toStringTag] || "Object") + "]";
            })
          },
          autoBind({
            _onAdd: d(function(index) {
              if (index >= this.__nextIndex__) return;
              ++this.__nextIndex__;
              if (!this.__redo__) {
                defineProperty(this, "__redo__", d("c", [index]));
                return;
              }
              this.__redo__.forEach(function(redo, i) {
                if (redo >= index) this.__redo__[i] = ++redo;
              }, this);
              this.__redo__.push(index);
            }),
            _onDelete: d(function(index) {
              var i;
              if (index >= this.__nextIndex__) return;
              --this.__nextIndex__;
              if (!this.__redo__) return;
              i = this.__redo__.indexOf(index);
              if (i !== -1) this.__redo__.splice(i, 1);
              this.__redo__.forEach(function(redo, j) {
                if (redo > index) this.__redo__[j] = --redo;
              }, this);
            }),
            _onClear: d(function() {
              if (this.__redo__) clear.call(this.__redo__);
              this.__nextIndex__ = 0;
            })
          })
        )
      );
      defineProperty(
        Iterator.prototype,
        Symbol2.iterator,
        d(function() {
          return this;
        })
      );
    }
  });

  // node_modules/es6-iterator/array.js
  var require_array2 = __commonJS({
    "node_modules/es6-iterator/array.js"(exports, module) {
      "use strict";
      var setPrototypeOf = require_set_prototype_of();
      var contains = require_contains();
      var d = require_d();
      var Symbol2 = require_es6_symbol();
      var Iterator = require_es6_iterator();
      var defineProperty = Object.defineProperty;
      var ArrayIterator;
      ArrayIterator = module.exports = function(arr, kind) {
        if (!(this instanceof ArrayIterator)) throw new TypeError("Constructor requires 'new'");
        Iterator.call(this, arr);
        if (!kind) kind = "value";
        else if (contains.call(kind, "key+value")) kind = "key+value";
        else if (contains.call(kind, "key")) kind = "key";
        else kind = "value";
        defineProperty(this, "__kind__", d("", kind));
      };
      if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);
      delete ArrayIterator.prototype.constructor;
      ArrayIterator.prototype = Object.create(Iterator.prototype, {
        _resolve: d(function(i) {
          if (this.__kind__ === "value") return this.__list__[i];
          if (this.__kind__ === "key+value") return [i, this.__list__[i]];
          return i;
        })
      });
      defineProperty(ArrayIterator.prototype, Symbol2.toStringTag, d("c", "Array Iterator"));
    }
  });

  // node_modules/es6-iterator/string.js
  var require_string = __commonJS({
    "node_modules/es6-iterator/string.js"(exports, module) {
      "use strict";
      var setPrototypeOf = require_set_prototype_of();
      var d = require_d();
      var Symbol2 = require_es6_symbol();
      var Iterator = require_es6_iterator();
      var defineProperty = Object.defineProperty;
      var StringIterator;
      StringIterator = module.exports = function(str) {
        if (!(this instanceof StringIterator)) throw new TypeError("Constructor requires 'new'");
        str = String(str);
        Iterator.call(this, str);
        defineProperty(this, "__length__", d("", str.length));
      };
      if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);
      delete StringIterator.prototype.constructor;
      StringIterator.prototype = Object.create(Iterator.prototype, {
        _next: d(function() {
          if (!this.__list__) return void 0;
          if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
          this._unBind();
          return void 0;
        }),
        _resolve: d(function(i) {
          var char = this.__list__[i], code;
          if (this.__nextIndex__ === this.__length__) return char;
          code = char.charCodeAt(0);
          if (code >= 55296 && code <= 56319) return char + this.__list__[this.__nextIndex__++];
          return char;
        })
      });
      defineProperty(StringIterator.prototype, Symbol2.toStringTag, d("c", "String Iterator"));
    }
  });

  // node_modules/es6-iterator/is-iterable.js
  var require_is_iterable = __commonJS({
    "node_modules/es6-iterator/is-iterable.js"(exports, module) {
      "use strict";
      var isArguments = require_is_arguments2();
      var isValue = require_is_value();
      var isString = require_is_string();
      var iteratorSymbol = require_es6_symbol().iterator;
      var isArray = Array.isArray;
      module.exports = function(value) {
        if (!isValue(value)) return false;
        if (isArray(value)) return true;
        if (isString(value)) return true;
        if (isArguments(value)) return true;
        return typeof value[iteratorSymbol] === "function";
      };
    }
  });

  // node_modules/es6-iterator/valid-iterable.js
  var require_valid_iterable = __commonJS({
    "node_modules/es6-iterator/valid-iterable.js"(exports, module) {
      "use strict";
      var isIterable = require_is_iterable();
      module.exports = function(value) {
        if (!isIterable(value)) throw new TypeError(value + " is not iterable");
        return value;
      };
    }
  });

  // node_modules/es6-iterator/get.js
  var require_get = __commonJS({
    "node_modules/es6-iterator/get.js"(exports, module) {
      "use strict";
      var isArguments = require_is_arguments2();
      var isString = require_is_string();
      var ArrayIterator = require_array2();
      var StringIterator = require_string();
      var iterable = require_valid_iterable();
      var iteratorSymbol = require_es6_symbol().iterator;
      module.exports = function(obj) {
        if (typeof iterable(obj)[iteratorSymbol] === "function") return obj[iteratorSymbol]();
        if (isArguments(obj)) return new ArrayIterator(obj);
        if (isString(obj)) return new StringIterator(obj);
        return new ArrayIterator(obj);
      };
    }
  });

  // node_modules/es6-iterator/for-of.js
  var require_for_of = __commonJS({
    "node_modules/es6-iterator/for-of.js"(exports, module) {
      "use strict";
      var isArguments = require_is_arguments2();
      var callable = require_valid_callable();
      var isString = require_is_string();
      var get = require_get();
      var isArray = Array.isArray;
      var call = Function.prototype.call;
      var some = Array.prototype.some;
      module.exports = function(iterable, cb) {
        var mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;
        if (isArray(iterable) || isArguments(iterable)) mode = "array";
        else if (isString(iterable)) mode = "string";
        else iterable = get(iterable);
        callable(cb);
        doBreak = function() {
          broken = true;
        };
        if (mode === "array") {
          some.call(iterable, function(value) {
            call.call(cb, thisArg, value, doBreak);
            return broken;
          });
          return;
        }
        if (mode === "string") {
          length = iterable.length;
          for (i = 0; i < length; ++i) {
            char = iterable[i];
            if (i + 1 < length) {
              code = char.charCodeAt(0);
              if (code >= 55296 && code <= 56319) char += iterable[++i];
            }
            call.call(cb, thisArg, char, doBreak);
            if (broken) break;
          }
          return;
        }
        result = iterable.next();
        while (!result.done) {
          call.call(cb, thisArg, result.value, doBreak);
          if (broken) return;
          result = iterable.next();
        }
      };
    }
  });

  // node_modules/es6-weak-map/is-native-implemented.js
  var require_is_native_implemented = __commonJS({
    "node_modules/es6-weak-map/is-native-implemented.js"(exports, module) {
      "use strict";
      module.exports = function() {
        if (typeof WeakMap !== "function") return false;
        return Object.prototype.toString.call(/* @__PURE__ */ new WeakMap()) === "[object WeakMap]";
      }();
    }
  });

  // node_modules/es6-weak-map/polyfill.js
  var require_polyfill5 = __commonJS({
    "node_modules/es6-weak-map/polyfill.js"(exports, module) {
      "use strict";
      var isValue = require_is_value();
      var setPrototypeOf = require_set_prototype_of();
      var object = require_valid_object();
      var ensureValue = require_valid_value();
      var randomUniq = require_random_uniq();
      var d = require_d();
      var getIterator = require_get();
      var forOf = require_for_of();
      var toStringTagSymbol = require_es6_symbol().toStringTag;
      var isNative = require_is_native_implemented();
      var isArray = Array.isArray;
      var defineProperty = Object.defineProperty;
      var objHasOwnProperty = Object.prototype.hasOwnProperty;
      var getPrototypeOf = Object.getPrototypeOf;
      var WeakMapPoly;
      module.exports = WeakMapPoly = function() {
        var iterable = arguments[0], self2;
        if (!(this instanceof WeakMapPoly)) throw new TypeError("Constructor requires 'new'");
        self2 = isNative && setPrototypeOf && WeakMap !== WeakMapPoly ? setPrototypeOf(/* @__PURE__ */ new WeakMap(), getPrototypeOf(this)) : this;
        if (isValue(iterable)) {
          if (!isArray(iterable)) iterable = getIterator(iterable);
        }
        defineProperty(self2, "__weakMapData__", d("c", "$weakMap$" + randomUniq()));
        if (!iterable) return self2;
        forOf(iterable, function(val) {
          ensureValue(val);
          self2.set(val[0], val[1]);
        });
        return self2;
      };
      if (isNative) {
        if (setPrototypeOf) setPrototypeOf(WeakMapPoly, WeakMap);
        WeakMapPoly.prototype = Object.create(WeakMap.prototype, { constructor: d(WeakMapPoly) });
      }
      Object.defineProperties(WeakMapPoly.prototype, {
        delete: d(function(key) {
          if (objHasOwnProperty.call(object(key), this.__weakMapData__)) {
            delete key[this.__weakMapData__];
            return true;
          }
          return false;
        }),
        get: d(function(key) {
          if (!objHasOwnProperty.call(object(key), this.__weakMapData__)) return void 0;
          return key[this.__weakMapData__];
        }),
        has: d(function(key) {
          return objHasOwnProperty.call(object(key), this.__weakMapData__);
        }),
        set: d(function(key, value) {
          defineProperty(object(key), this.__weakMapData__, d("c", value));
          return this;
        }),
        toString: d(function() {
          return "[object WeakMap]";
        })
      });
      defineProperty(WeakMapPoly.prototype, toStringTagSymbol, d("c", "WeakMap"));
    }
  });

  // node_modules/es6-weak-map/index.js
  var require_es6_weak_map = __commonJS({
    "node_modules/es6-weak-map/index.js"(exports, module) {
      "use strict";
      module.exports = require_is_implemented()() ? WeakMap : require_polyfill5();
    }
  });

  // node_modules/array-find-index/index.js
  var require_array_find_index = __commonJS({
    "node_modules/array-find-index/index.js"(exports, module) {
      "use strict";
      module.exports = function(arr, predicate, ctx) {
        if (typeof Array.prototype.findIndex === "function") {
          return arr.findIndex(predicate, ctx);
        }
        if (typeof predicate !== "function") {
          throw new TypeError("predicate must be a function");
        }
        var list = Object(arr);
        var len = list.length;
        if (len === 0) {
          return -1;
        }
        for (var i = 0; i < len; i++) {
          if (predicate.call(ctx, list[i], i, list)) {
            return i;
          }
        }
        return -1;
      };
    }
  });

  // node_modules/regl-line2d/index.js
  var require_regl_line2d = __commonJS({
    "node_modules/regl-line2d/index.js"(exports, module) {
      "use strict";
      var rgba2 = require_color_normalize();
      var getBounds = require_array_bounds();
      var extend = require_object_assign();
      var pick = require_pick_by_alias();
      var flatten = require_flatten_vertex_data();
      var triangulate = require_earcut();
      var normalize = require_array_normalize();
      var { float32, fract32 } = require_to_float32();
      var WeakMap2 = require_es6_weak_map();
      var parseRect = require_parse_rect();
      var findIndex = require_array_find_index();
      var rectVert = `
precision highp float;

attribute vec2 aCoord, bCoord, aCoordFract, bCoordFract;
attribute vec4 color;
attribute float lineEnd, lineTop;

uniform vec2 scale, scaleFract, translate, translateFract;
uniform float thickness, pixelRatio, id, depth;
uniform vec4 viewport;

varying vec4 fragColor;
varying vec2 tangent;

vec2 project(vec2 position, vec2 positionFract, vec2 scale, vec2 scaleFract, vec2 translate, vec2 translateFract) {
	// the order is important
	return position * scale + translate
       + positionFract * scale + translateFract
       + position * scaleFract
       + positionFract * scaleFract;
}

void main() {
	float lineStart = 1. - lineEnd;
	float lineOffset = lineTop * 2. - 1.;

	vec2 diff = (bCoord + bCoordFract - aCoord - aCoordFract);
	tangent = normalize(diff * scale * viewport.zw);
	vec2 normal = vec2(-tangent.y, tangent.x);

	vec2 position = project(aCoord, aCoordFract, scale, scaleFract, translate, translateFract) * lineStart
		+ project(bCoord, bCoordFract, scale, scaleFract, translate, translateFract) * lineEnd

		+ thickness * normal * .5 * lineOffset / viewport.zw;

	gl_Position = vec4(position * 2.0 - 1.0, depth, 1);

	fragColor = color / 255.;
}
`;
      var rectFrag = `
precision highp float;

uniform float dashLength, pixelRatio, thickness, opacity, id;
uniform sampler2D dashTexture;

varying vec4 fragColor;
varying vec2 tangent;

void main() {
	float alpha = 1.;

	float t = fract(dot(tangent, gl_FragCoord.xy) / dashLength) * .5 + .25;
	float dash = texture2D(dashTexture, vec2(t, .5)).r;

	gl_FragColor = fragColor;
	gl_FragColor.a *= alpha * opacity * dash;
}
`;
      var fillVert = `
precision highp float;

attribute vec2 position, positionFract;

uniform vec4 color;
uniform vec2 scale, scaleFract, translate, translateFract;
uniform float pixelRatio, id;
uniform vec4 viewport;
uniform float opacity;

varying vec4 fragColor;

const float MAX_LINES = 256.;

void main() {
	float depth = (MAX_LINES - 4. - id) / (MAX_LINES);

	vec2 position = position * scale + translate
       + positionFract * scale + translateFract
       + position * scaleFract
       + positionFract * scaleFract;

	gl_Position = vec4(position * 2.0 - 1.0, depth, 1);

	fragColor = color / 255.;
	fragColor.a *= opacity;
}
`;
      var fillFrag = `
precision highp float;
varying vec4 fragColor;

void main() {
	gl_FragColor = fragColor;
}
`;
      var milterVert = `
precision highp float;

attribute vec2 aCoord, bCoord, nextCoord, prevCoord;
attribute vec4 aColor, bColor;
attribute float lineEnd, lineTop;

uniform vec2 scale, translate;
uniform float thickness, pixelRatio, id, depth;
uniform vec4 viewport;
uniform float miterLimit, miterMode;

varying vec4 fragColor;
varying vec4 startCutoff, endCutoff;
varying vec2 tangent;
varying vec2 startCoord, endCoord;
varying float enableStartMiter, enableEndMiter;

const float REVERSE_THRESHOLD = -.875;
const float MIN_DIFF = 1e-6;

// TODO: possible optimizations: avoid overcalculating all for vertices and calc just one instead
// TODO: precalculate dot products, normalize things beforehead etc.
// TODO: refactor to rectangular algorithm

float distToLine(vec2 p, vec2 a, vec2 b) {
	vec2 diff = b - a;
	vec2 perp = normalize(vec2(-diff.y, diff.x));
	return dot(p - a, perp);
}

bool isNaN( float val ){
  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;
}

void main() {
	vec2 aCoord = aCoord, bCoord = bCoord, prevCoord = prevCoord, nextCoord = nextCoord;

  vec2 adjustedScale;
  adjustedScale.x = (abs(scale.x) < MIN_DIFF) ? MIN_DIFF : scale.x;
  adjustedScale.y = (abs(scale.y) < MIN_DIFF) ? MIN_DIFF : scale.y;

  vec2 scaleRatio = adjustedScale * viewport.zw;
	vec2 normalWidth = thickness / scaleRatio;

	float lineStart = 1. - lineEnd;
	float lineBot = 1. - lineTop;

	fragColor = (lineStart * aColor + lineEnd * bColor) / 255.;

	if (isNaN(aCoord.x) || isNaN(aCoord.y) || isNaN(bCoord.x) || isNaN(bCoord.y)) return;

	if (aCoord == prevCoord) prevCoord = aCoord + normalize(bCoord - aCoord);
	if (bCoord == nextCoord) nextCoord = bCoord - normalize(bCoord - aCoord);


	vec2 prevDiff = aCoord - prevCoord;
	vec2 currDiff = bCoord - aCoord;
	vec2 nextDiff = nextCoord - bCoord;

	vec2 prevTangent = normalize(prevDiff * scaleRatio);
	vec2 currTangent = normalize(currDiff * scaleRatio);
	vec2 nextTangent = normalize(nextDiff * scaleRatio);

	vec2 prevNormal = vec2(-prevTangent.y, prevTangent.x);
	vec2 currNormal = vec2(-currTangent.y, currTangent.x);
	vec2 nextNormal = vec2(-nextTangent.y, nextTangent.x);

	vec2 startJoinDirection = normalize(prevTangent - currTangent);
	vec2 endJoinDirection = normalize(currTangent - nextTangent);

	// collapsed/unidirectional segment cases
	// FIXME: there should be more elegant solution
	vec2 prevTanDiff = abs(prevTangent - currTangent);
	vec2 nextTanDiff = abs(nextTangent - currTangent);
	if (max(prevTanDiff.x, prevTanDiff.y) < MIN_DIFF) {
		startJoinDirection = currNormal;
	}
	if (max(nextTanDiff.x, nextTanDiff.y) < MIN_DIFF) {
		endJoinDirection = currNormal;
	}
	if (aCoord == bCoord) {
		endJoinDirection = startJoinDirection;
		currNormal = prevNormal;
		currTangent = prevTangent;
	}

	tangent = currTangent;

	//calculate join shifts relative to normals
	float startJoinShift = dot(currNormal, startJoinDirection);
	float endJoinShift = dot(currNormal, endJoinDirection);

	float startMiterRatio = abs(1. / startJoinShift);
	float endMiterRatio = abs(1. / endJoinShift);

	vec2 startJoin = startJoinDirection * startMiterRatio;
	vec2 endJoin = endJoinDirection * endMiterRatio;

	vec2 startTopJoin, startBotJoin, endTopJoin, endBotJoin;
	startTopJoin = sign(startJoinShift) * startJoin * .5;
	startBotJoin = -startTopJoin;

	endTopJoin = sign(endJoinShift) * endJoin * .5;
	endBotJoin = -endTopJoin;

	vec2 aTopCoord = aCoord + normalWidth * startTopJoin;
	vec2 bTopCoord = bCoord + normalWidth * endTopJoin;
	vec2 aBotCoord = aCoord + normalWidth * startBotJoin;
	vec2 bBotCoord = bCoord + normalWidth * endBotJoin;

	//miter anti-clipping
	float baClipping = distToLine(bCoord, aCoord, aBotCoord) / dot(normalize(normalWidth * endBotJoin), normalize(normalWidth.yx * vec2(-startBotJoin.y, startBotJoin.x)));
	float abClipping = distToLine(aCoord, bCoord, bTopCoord) / dot(normalize(normalWidth * startBotJoin), normalize(normalWidth.yx * vec2(-endBotJoin.y, endBotJoin.x)));

	//prevent close to reverse direction switch
	bool prevReverse = dot(currTangent, prevTangent) <= REVERSE_THRESHOLD && abs(dot(currTangent, prevNormal)) * min(length(prevDiff), length(currDiff)) <  length(normalWidth * currNormal);
	bool nextReverse = dot(currTangent, nextTangent) <= REVERSE_THRESHOLD && abs(dot(currTangent, nextNormal)) * min(length(nextDiff), length(currDiff)) <  length(normalWidth * currNormal);

	if (prevReverse) {
		//make join rectangular
		vec2 miterShift = normalWidth * startJoinDirection * miterLimit * .5;
		float normalAdjust = 1. - min(miterLimit / startMiterRatio, 1.);
		aBotCoord = aCoord + miterShift - normalAdjust * normalWidth * currNormal * .5;
		aTopCoord = aCoord + miterShift + normalAdjust * normalWidth * currNormal * .5;
	}
	else if (!nextReverse && baClipping > 0. && baClipping < length(normalWidth * endBotJoin)) {
		//handle miter clipping
		bTopCoord -= normalWidth * endTopJoin;
		bTopCoord += normalize(endTopJoin * normalWidth) * baClipping;
	}

	if (nextReverse) {
		//make join rectangular
		vec2 miterShift = normalWidth * endJoinDirection * miterLimit * .5;
		float normalAdjust = 1. - min(miterLimit / endMiterRatio, 1.);
		bBotCoord = bCoord + miterShift - normalAdjust * normalWidth * currNormal * .5;
		bTopCoord = bCoord + miterShift + normalAdjust * normalWidth * currNormal * .5;
	}
	else if (!prevReverse && abClipping > 0. && abClipping < length(normalWidth * startBotJoin)) {
		//handle miter clipping
		aBotCoord -= normalWidth * startBotJoin;
		aBotCoord += normalize(startBotJoin * normalWidth) * abClipping;
	}

	vec2 aTopPosition = (aTopCoord) * adjustedScale + translate;
	vec2 aBotPosition = (aBotCoord) * adjustedScale + translate;

	vec2 bTopPosition = (bTopCoord) * adjustedScale + translate;
	vec2 bBotPosition = (bBotCoord) * adjustedScale + translate;

	//position is normalized 0..1 coord on the screen
	vec2 position = (aTopPosition * lineTop + aBotPosition * lineBot) * lineStart + (bTopPosition * lineTop + bBotPosition * lineBot) * lineEnd;

	startCoord = aCoord * scaleRatio + translate * viewport.zw + viewport.xy;
	endCoord = bCoord * scaleRatio + translate * viewport.zw + viewport.xy;

	gl_Position = vec4(position  * 2.0 - 1.0, depth, 1);

	enableStartMiter = step(dot(currTangent, prevTangent), .5);
	enableEndMiter = step(dot(currTangent, nextTangent), .5);

	//bevel miter cutoffs
	if (miterMode == 1.) {
		if (enableStartMiter == 1.) {
			vec2 startMiterWidth = vec2(startJoinDirection) * thickness * miterLimit * .5;
			startCutoff = vec4(aCoord, aCoord);
			startCutoff.zw += vec2(-startJoinDirection.y, startJoinDirection.x) / scaleRatio;
			startCutoff = startCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;
			startCutoff += viewport.xyxy;
			startCutoff += startMiterWidth.xyxy;
		}

		if (enableEndMiter == 1.) {
			vec2 endMiterWidth = vec2(endJoinDirection) * thickness * miterLimit * .5;
			endCutoff = vec4(bCoord, bCoord);
			endCutoff.zw += vec2(-endJoinDirection.y, endJoinDirection.x)  / scaleRatio;
			endCutoff = endCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;
			endCutoff += viewport.xyxy;
			endCutoff += endMiterWidth.xyxy;
		}
	}

	//round miter cutoffs
	else if (miterMode == 2.) {
		if (enableStartMiter == 1.) {
			vec2 startMiterWidth = vec2(startJoinDirection) * thickness * abs(dot(startJoinDirection, currNormal)) * .5;
			startCutoff = vec4(aCoord, aCoord);
			startCutoff.zw += vec2(-startJoinDirection.y, startJoinDirection.x) / scaleRatio;
			startCutoff = startCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;
			startCutoff += viewport.xyxy;
			startCutoff += startMiterWidth.xyxy;
		}

		if (enableEndMiter == 1.) {
			vec2 endMiterWidth = vec2(endJoinDirection) * thickness * abs(dot(endJoinDirection, currNormal)) * .5;
			endCutoff = vec4(bCoord, bCoord);
			endCutoff.zw += vec2(-endJoinDirection.y, endJoinDirection.x)  / scaleRatio;
			endCutoff = endCutoff * scaleRatio.xyxy + translate.xyxy * viewport.zwzw;
			endCutoff += viewport.xyxy;
			endCutoff += endMiterWidth.xyxy;
		}
	}
}
`;
      var milterFrag = `
precision highp float;

uniform float dashLength, pixelRatio, thickness, opacity, id, miterMode;
uniform sampler2D dashTexture;

varying vec4 fragColor;
varying vec2 tangent;
varying vec4 startCutoff, endCutoff;
varying vec2 startCoord, endCoord;
varying float enableStartMiter, enableEndMiter;

float distToLine(vec2 p, vec2 a, vec2 b) {
	vec2 diff = b - a;
	vec2 perp = normalize(vec2(-diff.y, diff.x));
	return dot(p - a, perp);
}

void main() {
	float alpha = 1., distToStart, distToEnd;
	float cutoff = thickness * .5;

	//bevel miter
	if (miterMode == 1.) {
		if (enableStartMiter == 1.) {
			distToStart = distToLine(gl_FragCoord.xy, startCutoff.xy, startCutoff.zw);
			if (distToStart < -1.) {
				discard;
				return;
			}
			alpha *= min(max(distToStart + 1., 0.), 1.);
		}

		if (enableEndMiter == 1.) {
			distToEnd = distToLine(gl_FragCoord.xy, endCutoff.xy, endCutoff.zw);
			if (distToEnd < -1.) {
				discard;
				return;
			}
			alpha *= min(max(distToEnd + 1., 0.), 1.);
		}
	}

	// round miter
	else if (miterMode == 2.) {
		if (enableStartMiter == 1.) {
			distToStart = distToLine(gl_FragCoord.xy, startCutoff.xy, startCutoff.zw);
			if (distToStart < 0.) {
				float radius = length(gl_FragCoord.xy - startCoord);

				if(radius > cutoff + .5) {
					discard;
					return;
				}

				alpha -= smoothstep(cutoff - .5, cutoff + .5, radius);
			}
		}

		if (enableEndMiter == 1.) {
			distToEnd = distToLine(gl_FragCoord.xy, endCutoff.xy, endCutoff.zw);
			if (distToEnd < 0.) {
				float radius = length(gl_FragCoord.xy - endCoord);

				if(radius > cutoff + .5) {
					discard;
					return;
				}

				alpha -= smoothstep(cutoff - .5, cutoff + .5, radius);
			}
		}
	}

	float t = fract(dot(tangent, gl_FragCoord.xy) / dashLength) * .5 + .25;
	float dash = texture2D(dashTexture, vec2(t, .5)).r;

	gl_FragColor = fragColor;
	gl_FragColor.a *= alpha * opacity * dash;
}
`;
      module.exports = Line2D;
      function Line2D(regl, options) {
        if (!(this instanceof Line2D)) return new Line2D(regl, options);
        if (typeof regl === "function") {
          if (!options) options = {};
          options.regl = regl;
        } else {
          options = regl;
        }
        if (options.length) options.positions = options;
        regl = options.regl;
        if (!regl.hasExtension("ANGLE_instanced_arrays")) {
          throw Error("regl-error2d: `ANGLE_instanced_arrays` extension should be enabled");
        }
        this.gl = regl._gl;
        this.regl = regl;
        this.passes = [];
        this.shaders = Line2D.shaders.has(regl) ? Line2D.shaders.get(regl) : Line2D.shaders.set(regl, Line2D.createShaders(regl)).get(regl);
        this.update(options);
      }
      Line2D.dashMult = 2;
      Line2D.maxPatternLength = 256;
      Line2D.precisionThreshold = 3e6;
      Line2D.maxPoints = 1e4;
      Line2D.maxLines = 2048;
      Line2D.shaders = new WeakMap2();
      Line2D.createShaders = function(regl) {
        let offsetBuffer = regl.buffer({
          usage: "static",
          type: "float",
          data: [0, 1, 0, 0, 1, 1, 1, 0]
        });
        let shaderOptions = {
          primitive: "triangle strip",
          instances: regl.prop("count"),
          count: 4,
          offset: 0,
          uniforms: {
            miterMode: (ctx, prop) => prop.join === "round" ? 2 : 1,
            miterLimit: regl.prop("miterLimit"),
            scale: regl.prop("scale"),
            scaleFract: regl.prop("scaleFract"),
            translateFract: regl.prop("translateFract"),
            translate: regl.prop("translate"),
            thickness: regl.prop("thickness"),
            dashTexture: regl.prop("dashTexture"),
            opacity: regl.prop("opacity"),
            pixelRatio: regl.context("pixelRatio"),
            id: regl.prop("id"),
            dashLength: regl.prop("dashLength"),
            viewport: (c, p) => [p.viewport.x, p.viewport.y, c.viewportWidth, c.viewportHeight],
            depth: regl.prop("depth")
          },
          blend: {
            enable: true,
            color: [0, 0, 0, 0],
            equation: {
              rgb: "add",
              alpha: "add"
            },
            func: {
              srcRGB: "src alpha",
              dstRGB: "one minus src alpha",
              srcAlpha: "one minus dst alpha",
              dstAlpha: "one"
            }
          },
          depth: {
            enable: (c, p) => {
              return !p.overlay;
            }
          },
          stencil: { enable: false },
          scissor: {
            enable: true,
            box: regl.prop("viewport")
          },
          viewport: regl.prop("viewport")
        };
        let drawRectLine = regl(extend({
          vert: rectVert,
          frag: rectFrag,
          attributes: {
            // if point is at the end of segment
            lineEnd: {
              buffer: offsetBuffer,
              divisor: 0,
              stride: 8,
              offset: 0
            },
            // if point is at the top of segment
            lineTop: {
              buffer: offsetBuffer,
              divisor: 0,
              stride: 8,
              offset: 4
            },
            // beginning of line coordinate
            aCoord: {
              buffer: regl.prop("positionBuffer"),
              stride: 8,
              offset: 8,
              divisor: 1
            },
            // end of line coordinate
            bCoord: {
              buffer: regl.prop("positionBuffer"),
              stride: 8,
              offset: 16,
              divisor: 1
            },
            aCoordFract: {
              buffer: regl.prop("positionFractBuffer"),
              stride: 8,
              offset: 8,
              divisor: 1
            },
            bCoordFract: {
              buffer: regl.prop("positionFractBuffer"),
              stride: 8,
              offset: 16,
              divisor: 1
            },
            color: {
              buffer: regl.prop("colorBuffer"),
              stride: 4,
              offset: 0,
              divisor: 1
            }
          }
        }, shaderOptions));
        let drawMiterLine;
        try {
          drawMiterLine = regl(extend({
            // culling removes polygon creasing
            cull: {
              enable: true,
              face: "back"
            },
            vert: milterVert,
            frag: milterFrag,
            attributes: {
              // is line end
              lineEnd: {
                buffer: offsetBuffer,
                divisor: 0,
                stride: 8,
                offset: 0
              },
              // is line top
              lineTop: {
                buffer: offsetBuffer,
                divisor: 0,
                stride: 8,
                offset: 4
              },
              // left color
              aColor: {
                buffer: regl.prop("colorBuffer"),
                stride: 4,
                offset: 0,
                divisor: 1
              },
              // right color
              bColor: {
                buffer: regl.prop("colorBuffer"),
                stride: 4,
                offset: 4,
                divisor: 1
              },
              prevCoord: {
                buffer: regl.prop("positionBuffer"),
                stride: 8,
                offset: 0,
                divisor: 1
              },
              aCoord: {
                buffer: regl.prop("positionBuffer"),
                stride: 8,
                offset: 8,
                divisor: 1
              },
              bCoord: {
                buffer: regl.prop("positionBuffer"),
                stride: 8,
                offset: 16,
                divisor: 1
              },
              nextCoord: {
                buffer: regl.prop("positionBuffer"),
                stride: 8,
                offset: 24,
                divisor: 1
              }
            }
          }, shaderOptions));
        } catch (e) {
          drawMiterLine = drawRectLine;
        }
        let drawFill = regl({
          primitive: "triangle",
          elements: (ctx, prop) => prop.triangles,
          offset: 0,
          vert: fillVert,
          frag: fillFrag,
          uniforms: {
            scale: regl.prop("scale"),
            color: regl.prop("fill"),
            scaleFract: regl.prop("scaleFract"),
            translateFract: regl.prop("translateFract"),
            translate: regl.prop("translate"),
            opacity: regl.prop("opacity"),
            pixelRatio: regl.context("pixelRatio"),
            id: regl.prop("id"),
            viewport: (ctx, prop) => [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight]
          },
          attributes: {
            position: {
              buffer: regl.prop("positionBuffer"),
              stride: 8,
              offset: 8
            },
            positionFract: {
              buffer: regl.prop("positionFractBuffer"),
              stride: 8,
              offset: 8
            }
          },
          blend: shaderOptions.blend,
          depth: { enable: false },
          scissor: shaderOptions.scissor,
          stencil: shaderOptions.stencil,
          viewport: shaderOptions.viewport
        });
        return {
          fill: drawFill,
          rect: drawRectLine,
          miter: drawMiterLine
        };
      };
      Line2D.defaults = {
        dashes: null,
        join: "miter",
        miterLimit: 1,
        thickness: 10,
        cap: "square",
        color: "black",
        opacity: 1,
        overlay: false,
        viewport: null,
        range: null,
        close: false,
        fill: null
      };
      Line2D.prototype.render = function(...args) {
        if (args.length) {
          this.update(...args);
        }
        this.draw();
      };
      Line2D.prototype.draw = function(...args) {
        (args.length ? args : this.passes).forEach((s, i) => {
          if (s && Array.isArray(s)) return this.draw(...s);
          if (typeof s === "number") s = this.passes[s];
          if (!(s && s.count > 1 && s.opacity)) return;
          this.regl._refresh();
          if (s.fill && s.triangles && s.triangles.length > 2) {
            this.shaders.fill(s);
          }
          if (!s.thickness) return;
          if (s.scale[0] * s.viewport.width > Line2D.precisionThreshold || s.scale[1] * s.viewport.height > Line2D.precisionThreshold) {
            this.shaders.rect(s);
          } else if (s.join === "rect" || !s.join && (s.thickness <= 2 || s.count >= Line2D.maxPoints)) {
            this.shaders.rect(s);
          } else {
            this.shaders.miter(s);
          }
        });
        return this;
      };
      Line2D.prototype.update = function(options) {
        if (!options) return;
        if (options.length != null) {
          if (typeof options[0] === "number") options = [{ positions: options }];
        } else if (!Array.isArray(options)) options = [options];
        let { regl, gl } = this;
        options.forEach((o, i) => {
          let state = this.passes[i];
          if (o === void 0) return;
          if (o === null) {
            this.passes[i] = null;
            return;
          }
          if (typeof o[0] === "number") o = { positions: o };
          o = pick(o, {
            positions: "positions points data coords",
            thickness: "thickness lineWidth lineWidths line-width linewidth width stroke-width strokewidth strokeWidth",
            join: "lineJoin linejoin join type mode",
            miterLimit: "miterlimit miterLimit",
            dashes: "dash dashes dasharray dash-array dashArray",
            color: "color colour stroke colors colours stroke-color strokeColor",
            fill: "fill fill-color fillColor",
            opacity: "alpha opacity",
            overlay: "overlay crease overlap intersect",
            close: "closed close closed-path closePath",
            range: "range dataBox",
            viewport: "viewport viewBox",
            hole: "holes hole hollow",
            splitNull: "splitNull"
          });
          if (!state) {
            this.passes[i] = state = {
              id: i,
              scale: null,
              scaleFract: null,
              translate: null,
              translateFract: null,
              count: 0,
              hole: [],
              depth: 0,
              dashLength: 1,
              dashTexture: regl.texture({
                channels: 1,
                data: new Uint8Array([255]),
                width: 1,
                height: 1,
                mag: "linear",
                min: "linear"
              }),
              colorBuffer: regl.buffer({
                usage: "dynamic",
                type: "uint8",
                data: new Uint8Array()
              }),
              positionBuffer: regl.buffer({
                usage: "dynamic",
                type: "float",
                data: new Uint8Array()
              }),
              positionFractBuffer: regl.buffer({
                usage: "dynamic",
                type: "float",
                data: new Uint8Array()
              })
            };
            o = extend({}, Line2D.defaults, o);
          }
          if (o.thickness != null) state.thickness = parseFloat(o.thickness);
          if (o.opacity != null) state.opacity = parseFloat(o.opacity);
          if (o.miterLimit != null) state.miterLimit = parseFloat(o.miterLimit);
          if (o.overlay != null) {
            state.overlay = !!o.overlay;
            if (i < Line2D.maxLines) {
              state.depth = 2 * (Line2D.maxLines - 1 - i % Line2D.maxLines) / Line2D.maxLines - 1;
            }
          }
          if (o.join != null) state.join = o.join;
          if (o.hole != null) state.hole = o.hole;
          if (o.fill != null) state.fill = !o.fill ? null : rgba2(o.fill, "uint8");
          if (o.viewport != null) state.viewport = parseRect(o.viewport);
          if (!state.viewport) {
            state.viewport = parseRect([
              gl.drawingBufferWidth,
              gl.drawingBufferHeight
            ]);
          }
          if (o.close != null) state.close = o.close;
          if (o.positions === null) o.positions = [];
          if (o.positions) {
            let positions, count;
            if (o.positions.x && o.positions.y) {
              let xPos = o.positions.x;
              let yPos = o.positions.y;
              count = state.count = Math.max(
                xPos.length,
                yPos.length
              );
              positions = new Float64Array(count * 2);
              for (let i2 = 0; i2 < count; i2++) {
                positions[i2 * 2] = xPos[i2];
                positions[i2 * 2 + 1] = yPos[i2];
              }
            } else {
              positions = flatten(o.positions, "float64");
              count = state.count = Math.floor(positions.length / 2);
            }
            let bounds = state.bounds = getBounds(positions, 2);
            if (state.fill) {
              let pos = [];
              let ids = {};
              let lastId = 0;
              for (let i2 = 0, ptr = 0, l = state.count; i2 < l; i2++) {
                let x = positions[i2 * 2];
                let y = positions[i2 * 2 + 1];
                if (isNaN(x) || isNaN(y) || x == null || y == null) {
                  x = positions[lastId * 2];
                  y = positions[lastId * 2 + 1];
                  ids[i2] = lastId;
                } else {
                  lastId = i2;
                }
                pos[ptr++] = x;
                pos[ptr++] = y;
              }
              if (o.splitNull) {
                if (!(state.count - 1 in ids)) ids[state.count] = state.count - 1;
                let splits = Object.keys(ids).map(Number).sort((a, b) => a - b);
                let split_triangles = [];
                let base = 0;
                let hole_base = state.hole != null ? state.hole[0] : null;
                if (hole_base != null) {
                  let last_id = findIndex(splits, (e) => e >= hole_base);
                  splits = splits.slice(0, last_id);
                  splits.push(hole_base);
                }
                for (let i2 = 0; i2 < splits.length; i2++) {
                  let seg_pos = pos.slice(base * 2, splits[i2] * 2).concat(
                    hole_base ? pos.slice(hole_base * 2) : []
                  );
                  let hole = (state.hole || []).map((e) => e - hole_base + (splits[i2] - base));
                  let triangles = triangulate(seg_pos, hole);
                  triangles = triangles.map(
                    (e) => e + base + (e + base < splits[i2] ? 0 : hole_base - splits[i2])
                  );
                  split_triangles.push(...triangles);
                  base = splits[i2] + 1;
                }
                for (let i2 = 0, l = split_triangles.length; i2 < l; i2++) {
                  if (ids[split_triangles[i2]] != null) split_triangles[i2] = ids[split_triangles[i2]];
                }
                state.triangles = split_triangles;
              } else {
                let triangles = triangulate(pos, state.hole || []);
                for (let i2 = 0, l = triangles.length; i2 < l; i2++) {
                  if (ids[triangles[i2]] != null) triangles[i2] = ids[triangles[i2]];
                }
                state.triangles = triangles;
              }
            }
            let npos = new Float64Array(positions);
            normalize(npos, 2, bounds);
            let positionData = new Float64Array(count * 2 + 6);
            if (state.close) {
              if (positions[0] === positions[count * 2 - 2] && positions[1] === positions[count * 2 - 1]) {
                positionData[0] = npos[count * 2 - 4];
                positionData[1] = npos[count * 2 - 3];
              } else {
                positionData[0] = npos[count * 2 - 2];
                positionData[1] = npos[count * 2 - 1];
              }
            } else {
              positionData[0] = npos[0];
              positionData[1] = npos[1];
            }
            positionData.set(npos, 2);
            if (state.close) {
              if (positions[0] === positions[count * 2 - 2] && positions[1] === positions[count * 2 - 1]) {
                positionData[count * 2 + 2] = npos[2];
                positionData[count * 2 + 3] = npos[3];
                state.count -= 1;
              } else {
                positionData[count * 2 + 2] = npos[0];
                positionData[count * 2 + 3] = npos[1];
                positionData[count * 2 + 4] = npos[2];
                positionData[count * 2 + 5] = npos[3];
              }
            } else {
              positionData[count * 2 + 2] = npos[count * 2 - 2];
              positionData[count * 2 + 3] = npos[count * 2 - 1];
              positionData[count * 2 + 4] = npos[count * 2 - 2];
              positionData[count * 2 + 5] = npos[count * 2 - 1];
            }
            var float_data = float32(positionData);
            state.positionBuffer(float_data);
            var frac_data = fract32(positionData, float_data);
            state.positionFractBuffer(frac_data);
          }
          if (o.range) {
            state.range = o.range;
          } else if (!state.range) {
            state.range = state.bounds;
          }
          if ((o.range || o.positions) && state.count) {
            let bounds = state.bounds;
            let boundsW = bounds[2] - bounds[0], boundsH = bounds[3] - bounds[1];
            let rangeW = state.range[2] - state.range[0], rangeH = state.range[3] - state.range[1];
            state.scale = [
              boundsW / rangeW,
              boundsH / rangeH
            ];
            state.translate = [
              -state.range[0] / rangeW + bounds[0] / rangeW || 0,
              -state.range[1] / rangeH + bounds[1] / rangeH || 0
            ];
            state.scaleFract = fract32(state.scale);
            state.translateFract = fract32(state.translate);
          }
          if (o.dashes) {
            let dashLength = 0, dashData;
            if (!o.dashes || o.dashes.length < 2) {
              dashLength = 1;
              dashData = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]);
            } else {
              dashLength = 0;
              for (let i2 = 0; i2 < o.dashes.length; ++i2) {
                dashLength += o.dashes[i2];
              }
              dashData = new Uint8Array(dashLength * Line2D.dashMult);
              let ptr = 0;
              let fillColor = 255;
              for (let k = 0; k < 2; k++) {
                for (let i2 = 0; i2 < o.dashes.length; ++i2) {
                  for (let j = 0, l = o.dashes[i2] * Line2D.dashMult * 0.5; j < l; ++j) {
                    dashData[ptr++] = fillColor;
                  }
                  fillColor ^= 255;
                }
              }
            }
            state.dashLength = dashLength;
            state.dashTexture({
              channels: 1,
              data: dashData,
              width: dashData.length,
              height: 1,
              mag: "linear",
              min: "linear"
            }, 0, 0);
          }
          if (o.color) {
            let count = state.count;
            let colors = o.color;
            if (!colors) colors = "transparent";
            let colorData = new Uint8Array(count * 4 + 4);
            if (!Array.isArray(colors) || typeof colors[0] === "number") {
              let c = rgba2(colors, "uint8");
              for (let i2 = 0; i2 < count + 1; i2++) {
                colorData.set(c, i2 * 4);
              }
            } else {
              for (let i2 = 0; i2 < count; i2++) {
                let c = rgba2(colors[i2], "uint8");
                colorData.set(c, i2 * 4);
              }
              colorData.set(rgba2(colors[0], "uint8"), count * 4);
            }
            state.colorBuffer({
              usage: "dynamic",
              type: "uint8",
              data: colorData
            });
          }
        });
        if (options.length < this.passes.length) {
          for (let i = options.length; i < this.passes.length; i++) {
            let pass = this.passes[i];
            if (!pass) continue;
            pass.colorBuffer.destroy();
            pass.positionBuffer.destroy();
            pass.dashTexture.destroy();
          }
          this.passes.length = options.length;
        }
        let passes = [];
        for (let i = 0; i < this.passes.length; i++) {
          if (this.passes[i] !== null) passes.push(this.passes[i]);
        }
        this.passes = passes;
        return this;
      };
      Line2D.prototype.destroy = function() {
        this.passes.forEach((pass) => {
          pass.colorBuffer.destroy();
          pass.positionBuffer.destroy();
          pass.dashTexture.destroy();
        });
        this.passes.length = 0;
        return this;
      };
    }
  });

  // node_modules/regl-error2d/index.js
  var require_regl_error2d = __commonJS({
    "node_modules/regl-error2d/index.js"(exports, module) {
      "use strict";
      var getBounds = require_array_bounds();
      var rgba2 = require_color_normalize();
      var updateDiff = require_update_diff();
      var pick = require_pick_by_alias();
      var extend = require_object_assign();
      var flatten = require_flatten_vertex_data();
      var { float32, fract32 } = require_to_float32();
      module.exports = Error2D;
      var WEIGHTS = [
        //direction, lineWidth shift, capSize shift
        // x-error bar
        [1, 0, 0, 1, 0, 0],
        [1, 0, 0, -1, 0, 0],
        [-1, 0, 0, -1, 0, 0],
        [-1, 0, 0, -1, 0, 0],
        [-1, 0, 0, 1, 0, 0],
        [1, 0, 0, 1, 0, 0],
        // x-error right cap
        [1, 0, -1, 0, 0, 1],
        [1, 0, -1, 0, 0, -1],
        [1, 0, 1, 0, 0, -1],
        [1, 0, 1, 0, 0, -1],
        [1, 0, 1, 0, 0, 1],
        [1, 0, -1, 0, 0, 1],
        // x-error left cap
        [-1, 0, -1, 0, 0, 1],
        [-1, 0, -1, 0, 0, -1],
        [-1, 0, 1, 0, 0, -1],
        [-1, 0, 1, 0, 0, -1],
        [-1, 0, 1, 0, 0, 1],
        [-1, 0, -1, 0, 0, 1],
        // y-error bar
        [0, 1, 1, 0, 0, 0],
        [0, 1, -1, 0, 0, 0],
        [0, -1, -1, 0, 0, 0],
        [0, -1, -1, 0, 0, 0],
        [0, 1, 1, 0, 0, 0],
        [0, -1, 1, 0, 0, 0],
        // y-error top cap
        [0, 1, 0, -1, 1, 0],
        [0, 1, 0, -1, -1, 0],
        [0, 1, 0, 1, -1, 0],
        [0, 1, 0, 1, 1, 0],
        [0, 1, 0, -1, 1, 0],
        [0, 1, 0, 1, -1, 0],
        // y-error bottom cap
        [0, -1, 0, -1, 1, 0],
        [0, -1, 0, -1, -1, 0],
        [0, -1, 0, 1, -1, 0],
        [0, -1, 0, 1, 1, 0],
        [0, -1, 0, -1, 1, 0],
        [0, -1, 0, 1, -1, 0]
      ];
      function Error2D(regl, options) {
        if (typeof regl === "function") {
          if (!options) options = {};
          options.regl = regl;
        } else {
          options = regl;
        }
        if (options.length) options.positions = options;
        regl = options.regl;
        if (!regl.hasExtension("ANGLE_instanced_arrays")) {
          throw Error("regl-error2d: `ANGLE_instanced_arrays` extension should be enabled");
        }
        let gl = regl._gl, drawErrors, positionBuffer, positionFractBuffer, colorBuffer, errorBuffer, meshBuffer, defaults = {
          color: "black",
          capSize: 5,
          lineWidth: 1,
          opacity: 1,
          viewport: null,
          range: null,
          offset: 0,
          count: 0,
          bounds: null,
          positions: [],
          errors: []
        }, groups = [];
        colorBuffer = regl.buffer({
          usage: "dynamic",
          type: "uint8",
          data: new Uint8Array(0)
        });
        positionBuffer = regl.buffer({
          usage: "dynamic",
          type: "float",
          data: new Uint8Array(0)
        });
        positionFractBuffer = regl.buffer({
          usage: "dynamic",
          type: "float",
          data: new Uint8Array(0)
        });
        errorBuffer = regl.buffer({
          usage: "dynamic",
          type: "float",
          data: new Uint8Array(0)
        });
        meshBuffer = regl.buffer({
          usage: "static",
          type: "float",
          data: WEIGHTS
        });
        update(options);
        drawErrors = regl({
          vert: `
		precision highp float;

		attribute vec2 position, positionFract;
		attribute vec4 error;
		attribute vec4 color;

		attribute vec2 direction, lineOffset, capOffset;

		uniform vec4 viewport;
		uniform float lineWidth, capSize;
		uniform vec2 scale, scaleFract, translate, translateFract;

		varying vec4 fragColor;

		void main() {
			fragColor = color / 255.;

			vec2 pixelOffset = lineWidth * lineOffset + (capSize + lineWidth) * capOffset;

			vec2 dxy = -step(.5, direction.xy) * error.xz + step(direction.xy, vec2(-.5)) * error.yw;

			vec2 position = position + dxy;

			vec2 pos = (position + translate) * scale
				+ (positionFract + translateFract) * scale
				+ (position + translate) * scaleFract
				+ (positionFract + translateFract) * scaleFract;

			pos += pixelOffset / viewport.zw;

			gl_Position = vec4(pos * 2. - 1., 0, 1);
		}
		`,
          frag: `
		precision highp float;

		varying vec4 fragColor;

		uniform float opacity;

		void main() {
			gl_FragColor = fragColor;
			gl_FragColor.a *= opacity;
		}
		`,
          uniforms: {
            range: regl.prop("range"),
            lineWidth: regl.prop("lineWidth"),
            capSize: regl.prop("capSize"),
            opacity: regl.prop("opacity"),
            scale: regl.prop("scale"),
            translate: regl.prop("translate"),
            scaleFract: regl.prop("scaleFract"),
            translateFract: regl.prop("translateFract"),
            viewport: (ctx, prop) => [prop.viewport.x, prop.viewport.y, ctx.viewportWidth, ctx.viewportHeight]
          },
          attributes: {
            //dynamic attributes
            color: {
              buffer: colorBuffer,
              offset: (ctx, prop) => prop.offset * 4,
              divisor: 1
            },
            position: {
              buffer: positionBuffer,
              offset: (ctx, prop) => prop.offset * 8,
              divisor: 1
            },
            positionFract: {
              buffer: positionFractBuffer,
              offset: (ctx, prop) => prop.offset * 8,
              divisor: 1
            },
            error: {
              buffer: errorBuffer,
              offset: (ctx, prop) => prop.offset * 16,
              divisor: 1
            },
            //static attributes
            direction: {
              buffer: meshBuffer,
              stride: 24,
              offset: 0
            },
            lineOffset: {
              buffer: meshBuffer,
              stride: 24,
              offset: 8
            },
            capOffset: {
              buffer: meshBuffer,
              stride: 24,
              offset: 16
            }
          },
          primitive: "triangles",
          blend: {
            enable: true,
            color: [0, 0, 0, 0],
            equation: {
              rgb: "add",
              alpha: "add"
            },
            func: {
              srcRGB: "src alpha",
              dstRGB: "one minus src alpha",
              srcAlpha: "one minus dst alpha",
              dstAlpha: "one"
            }
          },
          depth: {
            enable: false
          },
          scissor: {
            enable: true,
            box: regl.prop("viewport")
          },
          viewport: regl.prop("viewport"),
          stencil: false,
          instances: regl.prop("count"),
          count: WEIGHTS.length
        });
        extend(error2d, {
          update,
          draw,
          destroy,
          regl,
          gl,
          canvas: gl.canvas,
          groups
        });
        return error2d;
        function error2d(opts) {
          if (opts) {
            update(opts);
          } else if (opts === null) {
            destroy();
          }
          draw();
        }
        function draw(options2) {
          if (typeof options2 === "number") return drawGroup(options2);
          if (options2 && !Array.isArray(options2)) options2 = [options2];
          regl._refresh();
          groups.forEach((s, i) => {
            if (!s) return;
            if (options2) {
              if (!options2[i]) s.draw = false;
              else s.draw = true;
            }
            if (!s.draw) {
              s.draw = true;
              return;
            }
            drawGroup(i);
          });
        }
        function drawGroup(s) {
          if (typeof s === "number") s = groups[s];
          if (s == null) return;
          if (!(s && s.count && s.color && s.opacity && s.positions && s.positions.length > 1)) return;
          s.scaleRatio = [
            s.scale[0] * s.viewport.width,
            s.scale[1] * s.viewport.height
          ];
          drawErrors(s);
          if (s.after) s.after(s);
        }
        function update(options2) {
          if (!options2) return;
          if (options2.length != null) {
            if (typeof options2[0] === "number") options2 = [{ positions: options2 }];
          } else if (!Array.isArray(options2)) options2 = [options2];
          let pointCount = 0, errorCount = 0;
          error2d.groups = groups = options2.map((options3, i) => {
            let group = groups[i];
            if (!options3) return group;
            else if (typeof options3 === "function") options3 = { after: options3 };
            else if (typeof options3[0] === "number") options3 = { positions: options3 };
            options3 = pick(options3, {
              color: "color colors fill",
              capSize: "capSize cap capsize cap-size",
              lineWidth: "lineWidth line-width width line thickness",
              opacity: "opacity alpha",
              range: "range dataBox",
              viewport: "viewport viewBox",
              errors: "errors error",
              positions: "positions position data points"
            });
            if (!group) {
              groups[i] = group = {
                id: i,
                scale: null,
                translate: null,
                scaleFract: null,
                translateFract: null,
                draw: true
              };
              options3 = extend({}, defaults, options3);
            }
            updateDiff(group, options3, [{
              lineWidth: (v) => +v * 0.5,
              capSize: (v) => +v * 0.5,
              opacity: parseFloat,
              errors: (errors) => {
                errors = flatten(errors);
                errorCount += errors.length;
                return errors;
              },
              positions: (positions, state) => {
                positions = flatten(positions, "float64");
                state.count = Math.floor(positions.length / 2);
                state.bounds = getBounds(positions, 2);
                state.offset = pointCount;
                pointCount += state.count;
                return positions;
              }
            }, {
              color: (colors, state) => {
                let count = state.count;
                if (!colors) colors = "transparent";
                if (!Array.isArray(colors) || typeof colors[0] === "number") {
                  let color = colors;
                  colors = Array(count);
                  for (let i2 = 0; i2 < count; i2++) {
                    colors[i2] = color;
                  }
                }
                if (colors.length < count) throw Error("Not enough colors");
                let colorData = new Uint8Array(count * 4);
                for (let i2 = 0; i2 < count; i2++) {
                  let c = rgba2(colors[i2], "uint8");
                  colorData.set(c, i2 * 4);
                }
                return colorData;
              },
              range: (range, state, options4) => {
                let bounds = state.bounds;
                if (!range) range = bounds;
                state.scale = [1 / (range[2] - range[0]), 1 / (range[3] - range[1])];
                state.translate = [-range[0], -range[1]];
                state.scaleFract = fract32(state.scale);
                state.translateFract = fract32(state.translate);
                return range;
              },
              viewport: (vp) => {
                let viewport;
                if (Array.isArray(vp)) {
                  viewport = {
                    x: vp[0],
                    y: vp[1],
                    width: vp[2] - vp[0],
                    height: vp[3] - vp[1]
                  };
                } else if (vp) {
                  viewport = {
                    x: vp.x || vp.left || 0,
                    y: vp.y || vp.top || 0
                  };
                  if (vp.right) viewport.width = vp.right - viewport.x;
                  else viewport.width = vp.w || vp.width || 0;
                  if (vp.bottom) viewport.height = vp.bottom - viewport.y;
                  else viewport.height = vp.h || vp.height || 0;
                } else {
                  viewport = {
                    x: 0,
                    y: 0,
                    width: gl.drawingBufferWidth,
                    height: gl.drawingBufferHeight
                  };
                }
                return viewport;
              }
            }]);
            return group;
          });
          if (pointCount || errorCount) {
            let len = groups.reduce((acc, group, i) => {
              return acc + (group ? group.count : 0);
            }, 0);
            let positionData = new Float64Array(len * 2);
            let colorData = new Uint8Array(len * 4);
            let errorData = new Float32Array(len * 4);
            groups.forEach((group, i) => {
              if (!group) return;
              let { positions, count, offset, color, errors } = group;
              if (!count) return;
              colorData.set(color, offset * 4);
              errorData.set(errors, offset * 4);
              positionData.set(positions, offset * 2);
            });
            var float_data = float32(positionData);
            positionBuffer(float_data);
            var frac_data = fract32(positionData, float_data);
            positionFractBuffer(frac_data);
            colorBuffer(colorData);
            errorBuffer(errorData);
          }
        }
        function destroy() {
          positionBuffer.destroy();
          positionFractBuffer.destroy();
          colorBuffer.destroy();
          errorBuffer.destroy();
          meshBuffer.destroy();
        }
      }
    }
  });

  // node_modules/unquote/index.js
  var require_unquote = __commonJS({
    "node_modules/unquote/index.js"(exports, module) {
      var reg = /[\'\"]/;
      module.exports = function unquote(str) {
        if (!str) {
          return "";
        }
        if (reg.test(str.charAt(0))) {
          str = str.substr(1);
        }
        if (reg.test(str.charAt(str.length - 1))) {
          str = str.substr(0, str.length - 1);
        }
        return str;
      };
    }
  });

  // node_modules/css-global-keywords/index.json
  var require_css_global_keywords = __commonJS({
    "node_modules/css-global-keywords/index.json"() {
    }
  });

  // node_modules/css-system-font-keywords/index.json
  var require_css_system_font_keywords = __commonJS({
    "node_modules/css-system-font-keywords/index.json"() {
    }
  });

  // node_modules/css-font-weight-keywords/index.json
  var require_css_font_weight_keywords = __commonJS({
    "node_modules/css-font-weight-keywords/index.json"() {
    }
  });

  // node_modules/css-font-style-keywords/index.json
  var require_css_font_style_keywords = __commonJS({
    "node_modules/css-font-style-keywords/index.json"() {
    }
  });

  // node_modules/css-font-stretch-keywords/index.json
  var require_css_font_stretch_keywords = __commonJS({
    "node_modules/css-font-stretch-keywords/index.json"() {
    }
  });

  // node_modules/parenthesis/index.js
  var require_parenthesis = __commonJS({
    "node_modules/parenthesis/index.js"(exports, module) {
      "use strict";
      function parse2(str, opts) {
        if (typeof str !== "string") return [str];
        var res = [str];
        if (typeof opts === "string" || Array.isArray(opts)) {
          opts = { brackets: opts };
        } else if (!opts) opts = {};
        var brackets = opts.brackets ? Array.isArray(opts.brackets) ? opts.brackets : [opts.brackets] : ["{}", "[]", "()"];
        var escape = opts.escape || "___";
        var flat = !!opts.flat;
        brackets.forEach(function(bracket) {
          var pRE = new RegExp(["\\", bracket[0], "[^\\", bracket[0], "\\", bracket[1], "]*\\", bracket[1]].join(""));
          var ids = [];
          function replaceToken(token, idx, str2) {
            var refId = res.push(token.slice(bracket[0].length, -bracket[1].length)) - 1;
            ids.push(refId);
            return escape + refId + escape;
          }
          res.forEach(function(str2, i) {
            var prevStr;
            var a = 0;
            while (str2 != prevStr) {
              prevStr = str2;
              str2 = str2.replace(pRE, replaceToken);
              if (a++ > 1e4) throw Error("References have circular dependency. Please, check them.");
            }
            res[i] = str2;
          });
          ids = ids.reverse();
          res = res.map(function(str2) {
            ids.forEach(function(id) {
              str2 = str2.replace(new RegExp("(\\" + escape + id + "\\" + escape + ")", "g"), bracket[0] + "$1" + bracket[1]);
            });
            return str2;
          });
        });
        var re = new RegExp("\\" + escape + "([0-9]+)\\" + escape);
        function nest(str2, refs, escape2) {
          var res2 = [], match;
          var a = 0;
          while (match = re.exec(str2)) {
            if (a++ > 1e4) throw Error("Circular references in parenthesis");
            res2.push(str2.slice(0, match.index));
            res2.push(nest(refs[match[1]], refs));
            str2 = str2.slice(match.index + match[0].length);
          }
          res2.push(str2);
          return res2;
        }
        return flat ? res : nest(res[0], res);
      }
      function stringify(arg, opts) {
        if (opts && opts.flat) {
          var escape = opts && opts.escape || "___";
          var str = arg[0], prevStr;
          if (!str) return "";
          var re = new RegExp("\\" + escape + "([0-9]+)\\" + escape);
          var a = 0;
          while (str != prevStr) {
            if (a++ > 1e4) throw Error("Circular references in " + arg);
            prevStr = str;
            str = str.replace(re, replaceRef);
          }
          return str;
        }
        return arg.reduce(function f(prev, curr) {
          if (Array.isArray(curr)) {
            curr = curr.reduce(f, "");
          }
          return prev + curr;
        }, "");
        function replaceRef(match, idx) {
          if (arg[idx] == null) throw Error("Reference " + idx + "is undefined");
          return arg[idx];
        }
      }
      function parenthesis(arg, opts) {
        if (Array.isArray(arg)) {
          return stringify(arg, opts);
        } else {
          return parse2(arg, opts);
        }
      }
      parenthesis.parse = parse2;
      parenthesis.stringify = stringify;
      module.exports = parenthesis;
    }
  });

  // node_modules/string-split-by/index.js
  var require_string_split_by = __commonJS({
    "node_modules/string-split-by/index.js"(exports, module) {
      "use strict";
      var paren = require_parenthesis();
      module.exports = function splitBy(string, separator, o) {
        if (string == null) throw Error("First argument should be a string");
        if (separator == null) throw Error("Separator should be a string or a RegExp");
        if (!o) o = {};
        else if (typeof o === "string" || Array.isArray(o)) {
          o = { ignore: o };
        }
        if (o.escape == null) o.escape = true;
        if (o.ignore == null) o.ignore = ["[]", "()", "{}", "<>", '""', "''", "``", "\u201C\u201D", "\xAB\xBB"];
        else {
          if (typeof o.ignore === "string") {
            o.ignore = [o.ignore];
          }
          o.ignore = o.ignore.map(function(pair) {
            if (pair.length === 1) pair = pair + pair;
            return pair;
          });
        }
        var tokens = paren.parse(string, { flat: true, brackets: o.ignore });
        var str = tokens[0];
        var parts = str.split(separator);
        if (o.escape) {
          var cleanParts = [];
          for (var i = 0; i < parts.length; i++) {
            var prev = parts[i];
            var part = parts[i + 1];
            if (prev[prev.length - 1] === "\\" && prev[prev.length - 2] !== "\\") {
              cleanParts.push(prev + separator + part);
              i++;
            } else {
              cleanParts.push(prev);
            }
          }
          parts = cleanParts;
        }
        for (var i = 0; i < parts.length; i++) {
          tokens[0] = parts[i];
          parts[i] = paren.stringify(tokens, { flat: true });
        }
        return parts;
      };
    }
  });

  // node_modules/css-font-size-keywords/index.json
  var require_css_font_size_keywords = __commonJS({
    "node_modules/css-font-size-keywords/index.json"() {
    }
  });

  // node_modules/css-font/lib/util.js
  var require_util2 = __commonJS({
    "node_modules/css-font/lib/util.js"(exports, module) {
      "use strict";
      var sizes = require_css_font_size_keywords();
      module.exports = {
        isSize: function isSize(value) {
          return /^[\d\.]/.test(value) || value.indexOf("/") !== -1 || sizes.indexOf(value) !== -1;
        }
      };
    }
  });

  // node_modules/css-font/parse.js
  var require_parse = __commonJS({
    "node_modules/css-font/parse.js"(exports, module) {
      "use strict";
      var unquote = require_unquote();
      var globalKeywords = require_css_global_keywords();
      var systemFontKeywords = require_css_system_font_keywords();
      var fontWeightKeywords = require_css_font_weight_keywords();
      var fontStyleKeywords = require_css_font_style_keywords();
      var fontStretchKeywords = require_css_font_stretch_keywords();
      var splitBy = require_string_split_by();
      var isSize = require_util2().isSize;
      module.exports = parseFont;
      var cache = parseFont.cache = {};
      function parseFont(value) {
        if (typeof value !== "string") throw new Error("Font argument must be a string.");
        if (cache[value]) return cache[value];
        if (value === "") {
          throw new Error("Cannot parse an empty string.");
        }
        if (systemFontKeywords.indexOf(value) !== -1) {
          return cache[value] = { system: value };
        }
        var font = {
          style: "normal",
          variant: "normal",
          weight: "normal",
          stretch: "normal",
          lineHeight: "normal",
          size: "1rem",
          family: ["serif"]
        };
        var tokens = splitBy(value, /\s+/);
        var token;
        while (token = tokens.shift()) {
          if (globalKeywords.indexOf(token) !== -1) {
            ["style", "variant", "weight", "stretch"].forEach(function(prop) {
              font[prop] = token;
            });
            return cache[value] = font;
          }
          if (fontStyleKeywords.indexOf(token) !== -1) {
            font.style = token;
            continue;
          }
          if (token === "normal" || token === "small-caps") {
            font.variant = token;
            continue;
          }
          if (fontStretchKeywords.indexOf(token) !== -1) {
            font.stretch = token;
            continue;
          }
          if (fontWeightKeywords.indexOf(token) !== -1) {
            font.weight = token;
            continue;
          }
          if (isSize(token)) {
            var parts = splitBy(token, "/");
            font.size = parts[0];
            if (parts[1] != null) {
              font.lineHeight = parseLineHeight(parts[1]);
            } else if (tokens[0] === "/") {
              tokens.shift();
              font.lineHeight = parseLineHeight(tokens.shift());
            }
            if (!tokens.length) {
              throw new Error("Missing required font-family.");
            }
            font.family = splitBy(tokens.join(" "), /\s*,\s*/).map(unquote);
            return cache[value] = font;
          }
          throw new Error("Unknown or unsupported font token: " + token);
        }
        throw new Error("Missing required font-size.");
      }
      function parseLineHeight(value) {
        var parsed = parseFloat(value);
        if (parsed.toString() === value) {
          return parsed;
        }
        return value;
      }
    }
  });

  // node_modules/css-font/stringify.js
  var require_stringify = __commonJS({
    "node_modules/css-font/stringify.js"(exports, module) {
      "use strict";
      var pick = require_pick_by_alias();
      var isSize = require_util2().isSize;
      var globals = a2o(require_css_global_keywords());
      var systems = a2o(require_css_system_font_keywords());
      var weights = a2o(require_css_font_weight_keywords());
      var styles = a2o(require_css_font_style_keywords());
      var stretches = a2o(require_css_font_stretch_keywords());
      var variants = { "normal": 1, "small-caps": 1 };
      var fams = {
        "serif": 1,
        "sans-serif": 1,
        "monospace": 1,
        "cursive": 1,
        "fantasy": 1,
        "system-ui": 1
      };
      var defaults = {
        style: "normal",
        variant: "normal",
        weight: "normal",
        stretch: "normal",
        size: "1rem",
        lineHeight: "normal",
        family: "serif"
      };
      module.exports = function stringifyFont(o) {
        o = pick(o, {
          style: "style fontstyle fontStyle font-style slope distinction",
          variant: "variant font-variant fontVariant fontvariant var capitalization",
          weight: "weight w font-weight fontWeight fontweight",
          stretch: "stretch font-stretch fontStretch fontstretch width",
          size: "size s font-size fontSize fontsize height em emSize",
          lineHeight: "lh line-height lineHeight lineheight leading",
          family: "font family fontFamily font-family fontfamily type typeface face",
          system: "system reserved default global"
        });
        if (o.system) {
          if (o.system) verify(o.system, systems);
          return o.system;
        }
        verify(o.style, styles);
        verify(o.variant, variants);
        verify(o.weight, weights);
        verify(o.stretch, stretches);
        if (o.size == null) o.size = defaults.size;
        if (typeof o.size === "number") o.size += "px";
        if (!isSize) throw Error("Bad size value `" + o.size + "`");
        if (!o.family) o.family = defaults.family;
        if (Array.isArray(o.family)) {
          if (!o.family.length) o.family = [defaults.family];
          o.family = o.family.map(function(f) {
            return fams[f] ? f : '"' + f + '"';
          }).join(", ");
        }
        var result = [];
        result.push(o.style);
        if (o.variant !== o.style) result.push(o.variant);
        if (o.weight !== o.variant && o.weight !== o.style) result.push(o.weight);
        if (o.stretch !== o.weight && o.stretch !== o.variant && o.stretch !== o.style) result.push(o.stretch);
        result.push(o.size + (o.lineHeight == null || o.lineHeight === "normal" || o.lineHeight + "" === "1" ? "" : "/" + o.lineHeight));
        result.push(o.family);
        return result.filter(Boolean).join(" ");
      };
      function verify(value, values) {
        if (value && !values[value] && !globals[value]) throw Error("Unknown keyword `" + value + "`");
        return value;
      }
      function a2o(a) {
        var o = {};
        for (var i = 0; i < a.length; i++) {
          o[a[i]] = 1;
        }
        return o;
      }
    }
  });

  // node_modules/css-font/index.js
  var require_css_font = __commonJS({
    "node_modules/css-font/index.js"(exports, module) {
      "use strict";
      module.exports = {
        parse: require_parse(),
        stringify: require_stringify()
      };
    }
  });

  // node_modules/regl/dist/regl.unchecked.js
  var require_regl_unchecked = __commonJS({
    "node_modules/regl/dist/regl.unchecked.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && false ? define(factory) : global2.createREGL = factory();
      })(exports, function() {
        "use strict";
        var extend = function(base, opts) {
          var keys = Object.keys(opts);
          for (var i = 0; i < keys.length; ++i) {
            base[keys[i]] = opts[keys[i]];
          }
          return base;
        };
        var VARIABLE_COUNTER = 0;
        var DYN_FUNC = 0;
        var DYN_CONSTANT = 5;
        var DYN_ARRAY = 6;
        function DynamicVariable(type, data) {
          this.id = VARIABLE_COUNTER++;
          this.type = type;
          this.data = data;
        }
        function escapeStr(str) {
          return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        }
        function splitParts(str) {
          if (str.length === 0) {
            return [];
          }
          var firstChar = str.charAt(0);
          var lastChar = str.charAt(str.length - 1);
          if (str.length > 1 && firstChar === lastChar && (firstChar === '"' || firstChar === "'")) {
            return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"'];
          }
          var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str);
          if (parts) {
            return splitParts(str.substr(0, parts.index)).concat(splitParts(parts[1])).concat(splitParts(str.substr(parts.index + parts[0].length)));
          }
          var subparts = str.split(".");
          if (subparts.length === 1) {
            return ['"' + escapeStr(str) + '"'];
          }
          var result = [];
          for (var i = 0; i < subparts.length; ++i) {
            result = result.concat(splitParts(subparts[i]));
          }
          return result;
        }
        function toAccessorString(str) {
          return "[" + splitParts(str).join("][") + "]";
        }
        function defineDynamic(type, data) {
          return new DynamicVariable(type, toAccessorString(data + ""));
        }
        function isDynamic(x) {
          return typeof x === "function" && !x._reglType || x instanceof DynamicVariable;
        }
        function unbox(x, path) {
          if (typeof x === "function") {
            return new DynamicVariable(DYN_FUNC, x);
          } else if (typeof x === "number" || typeof x === "boolean") {
            return new DynamicVariable(DYN_CONSTANT, x);
          } else if (Array.isArray(x)) {
            return new DynamicVariable(DYN_ARRAY, x.map(function(y, i) {
              return unbox(y, path + "[" + i + "]");
            }));
          } else if (x instanceof DynamicVariable) {
            return x;
          }
        }
        var dynamic = {
          DynamicVariable,
          define: defineDynamic,
          isDynamic,
          unbox,
          accessor: toAccessorString
        };
        var raf = {
          next: typeof requestAnimationFrame === "function" ? function(cb) {
            return requestAnimationFrame(cb);
          } : function(cb) {
            return setTimeout(cb, 16);
          },
          cancel: typeof cancelAnimationFrame === "function" ? function(raf2) {
            return cancelAnimationFrame(raf2);
          } : clearTimeout
        };
        var clock = typeof performance !== "undefined" && performance.now ? function() {
          return performance.now();
        } : function() {
          return +/* @__PURE__ */ new Date();
        };
        function createStringStore() {
          var stringIds = { "": 0 };
          var stringValues = [""];
          return {
            id: function(str) {
              var result = stringIds[str];
              if (result) {
                return result;
              }
              result = stringIds[str] = stringValues.length;
              stringValues.push(str);
              return result;
            },
            str: function(id) {
              return stringValues[id];
            }
          };
        }
        function createCanvas(element, onDone, pixelRatio) {
          var canvas = document.createElement("canvas");
          extend(canvas.style, {
            border: 0,
            margin: 0,
            padding: 0,
            top: 0,
            left: 0,
            width: "100%",
            height: "100%"
          });
          element.appendChild(canvas);
          if (element === document.body) {
            canvas.style.position = "absolute";
            extend(element.style, {
              margin: 0,
              padding: 0
            });
          }
          function resize() {
            var w = window.innerWidth;
            var h = window.innerHeight;
            if (element !== document.body) {
              var bounds = canvas.getBoundingClientRect();
              w = bounds.right - bounds.left;
              h = bounds.bottom - bounds.top;
            }
            canvas.width = pixelRatio * w;
            canvas.height = pixelRatio * h;
          }
          var resizeObserver;
          if (element !== document.body && typeof ResizeObserver === "function") {
            resizeObserver = new ResizeObserver(function() {
              setTimeout(resize);
            });
            resizeObserver.observe(element);
          } else {
            window.addEventListener("resize", resize, false);
          }
          function onDestroy() {
            if (resizeObserver) {
              resizeObserver.disconnect();
            } else {
              window.removeEventListener("resize", resize);
            }
            element.removeChild(canvas);
          }
          resize();
          return {
            canvas,
            onDestroy
          };
        }
        function createContext(canvas, contextAttributes) {
          function get(name) {
            try {
              return canvas.getContext(name, contextAttributes);
            } catch (e) {
              return null;
            }
          }
          return get("webgl") || get("experimental-webgl") || get("webgl-experimental");
        }
        function isHTMLElement(obj) {
          return typeof obj.nodeName === "string" && typeof obj.appendChild === "function" && typeof obj.getBoundingClientRect === "function";
        }
        function isWebGLContext(obj) {
          return typeof obj.drawArrays === "function" || typeof obj.drawElements === "function";
        }
        function parseExtensions(input) {
          if (typeof input === "string") {
            return input.split();
          }
          return input;
        }
        function getElement(desc) {
          if (typeof desc === "string") {
            return document.querySelector(desc);
          }
          return desc;
        }
        function parseArgs(args_) {
          var args = args_ || {};
          var element, container, canvas, gl;
          var contextAttributes = {};
          var extensions = [];
          var optionalExtensions = [];
          var pixelRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio;
          var profile = false;
          var cachedCode = {};
          var onDone = function(err) {
            if (err) {
            }
          };
          var onDestroy = function() {
          };
          if (typeof args === "string") {
            element = document.querySelector(args);
          } else if (typeof args === "object") {
            if (isHTMLElement(args)) {
              element = args;
            } else if (isWebGLContext(args)) {
              gl = args;
              canvas = gl.canvas;
            } else {
              if ("gl" in args) {
                gl = args.gl;
              } else if ("canvas" in args) {
                canvas = getElement(args.canvas);
              } else if ("container" in args) {
                container = getElement(args.container);
              }
              if ("attributes" in args) {
                contextAttributes = args.attributes;
              }
              if ("extensions" in args) {
                extensions = parseExtensions(args.extensions);
              }
              if ("optionalExtensions" in args) {
                optionalExtensions = parseExtensions(args.optionalExtensions);
              }
              if ("onDone" in args) {
                onDone = args.onDone;
              }
              if ("profile" in args) {
                profile = !!args.profile;
              }
              if ("pixelRatio" in args) {
                pixelRatio = +args.pixelRatio;
              }
              if ("cachedCode" in args) {
                cachedCode = args.cachedCode;
              }
            }
          } else {
          }
          if (element) {
            if (element.nodeName.toLowerCase() === "canvas") {
              canvas = element;
            } else {
              container = element;
            }
          }
          if (!gl) {
            if (!canvas) {
              var result = createCanvas(container || document.body, onDone, pixelRatio);
              if (!result) {
                return null;
              }
              canvas = result.canvas;
              onDestroy = result.onDestroy;
            }
            if (contextAttributes.premultipliedAlpha === void 0) contextAttributes.premultipliedAlpha = true;
            gl = createContext(canvas, contextAttributes);
          }
          if (!gl) {
            onDestroy();
            onDone("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org");
            return null;
          }
          return {
            gl,
            canvas,
            container,
            extensions,
            optionalExtensions,
            pixelRatio,
            profile,
            cachedCode,
            onDone,
            onDestroy
          };
        }
        function createExtensionCache(gl, config) {
          var extensions = {};
          function tryLoadExtension(name_) {
            var name2 = name_.toLowerCase();
            var ext;
            try {
              ext = extensions[name2] = gl.getExtension(name2);
            } catch (e) {
            }
            return !!ext;
          }
          for (var i = 0; i < config.extensions.length; ++i) {
            var name = config.extensions[i];
            if (!tryLoadExtension(name)) {
              config.onDestroy();
              config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser');
              return null;
            }
          }
          config.optionalExtensions.forEach(tryLoadExtension);
          return {
            extensions,
            restore: function() {
              Object.keys(extensions).forEach(function(name2) {
                if (extensions[name2] && !tryLoadExtension(name2)) {
                  throw new Error("(regl): error restoring extension " + name2);
                }
              });
            }
          };
        }
        function loop(n, f) {
          var result = Array(n);
          for (var i = 0; i < n; ++i) {
            result[i] = f(i);
          }
          return result;
        }
        var GL_BYTE = 5120;
        var GL_UNSIGNED_BYTE$1 = 5121;
        var GL_SHORT = 5122;
        var GL_UNSIGNED_SHORT = 5123;
        var GL_INT = 5124;
        var GL_UNSIGNED_INT = 5125;
        var GL_FLOAT$1 = 5126;
        function nextPow16(v) {
          for (var i = 16; i <= 1 << 28; i *= 16) {
            if (v <= i) {
              return i;
            }
          }
          return 0;
        }
        function log2(v) {
          var r, shift;
          r = (v > 65535) << 4;
          v >>>= r;
          shift = (v > 255) << 3;
          v >>>= shift;
          r |= shift;
          shift = (v > 15) << 2;
          v >>>= shift;
          r |= shift;
          shift = (v > 3) << 1;
          v >>>= shift;
          r |= shift;
          return r | v >> 1;
        }
        function createPool() {
          var bufferPool = loop(8, function() {
            return [];
          });
          function alloc(n) {
            var sz = nextPow16(n);
            var bin = bufferPool[log2(sz) >> 2];
            if (bin.length > 0) {
              return bin.pop();
            }
            return new ArrayBuffer(sz);
          }
          function free(buf) {
            bufferPool[log2(buf.byteLength) >> 2].push(buf);
          }
          function allocType(type, n) {
            var result = null;
            switch (type) {
              case GL_BYTE:
                result = new Int8Array(alloc(n), 0, n);
                break;
              case GL_UNSIGNED_BYTE$1:
                result = new Uint8Array(alloc(n), 0, n);
                break;
              case GL_SHORT:
                result = new Int16Array(alloc(2 * n), 0, n);
                break;
              case GL_UNSIGNED_SHORT:
                result = new Uint16Array(alloc(2 * n), 0, n);
                break;
              case GL_INT:
                result = new Int32Array(alloc(4 * n), 0, n);
                break;
              case GL_UNSIGNED_INT:
                result = new Uint32Array(alloc(4 * n), 0, n);
                break;
              case GL_FLOAT$1:
                result = new Float32Array(alloc(4 * n), 0, n);
                break;
              default:
                return null;
            }
            if (result.length !== n) {
              return result.subarray(0, n);
            }
            return result;
          }
          function freeType(array) {
            free(array.buffer);
          }
          return {
            alloc,
            free,
            allocType,
            freeType
          };
        }
        var pool = createPool();
        pool.zero = createPool();
        var GL_SUBPIXEL_BITS = 3408;
        var GL_RED_BITS = 3410;
        var GL_GREEN_BITS = 3411;
        var GL_BLUE_BITS = 3412;
        var GL_ALPHA_BITS = 3413;
        var GL_DEPTH_BITS = 3414;
        var GL_STENCIL_BITS = 3415;
        var GL_ALIASED_POINT_SIZE_RANGE = 33901;
        var GL_ALIASED_LINE_WIDTH_RANGE = 33902;
        var GL_MAX_TEXTURE_SIZE = 3379;
        var GL_MAX_VIEWPORT_DIMS = 3386;
        var GL_MAX_VERTEX_ATTRIBS = 34921;
        var GL_MAX_VERTEX_UNIFORM_VECTORS = 36347;
        var GL_MAX_VARYING_VECTORS = 36348;
        var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
        var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
        var GL_MAX_TEXTURE_IMAGE_UNITS = 34930;
        var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
        var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
        var GL_MAX_RENDERBUFFER_SIZE = 34024;
        var GL_VENDOR = 7936;
        var GL_RENDERER = 7937;
        var GL_VERSION = 7938;
        var GL_SHADING_LANGUAGE_VERSION = 35724;
        var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
        var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 36063;
        var GL_MAX_DRAW_BUFFERS_WEBGL = 34852;
        var GL_TEXTURE_2D = 3553;
        var GL_TEXTURE_CUBE_MAP = 34067;
        var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
        var GL_TEXTURE0 = 33984;
        var GL_RGBA = 6408;
        var GL_FLOAT = 5126;
        var GL_UNSIGNED_BYTE = 5121;
        var GL_FRAMEBUFFER = 36160;
        var GL_FRAMEBUFFER_COMPLETE = 36053;
        var GL_COLOR_ATTACHMENT0 = 36064;
        var GL_COLOR_BUFFER_BIT$1 = 16384;
        var wrapLimits = function(gl, extensions) {
          var maxAnisotropic = 1;
          if (extensions.ext_texture_filter_anisotropic) {
            maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          }
          var maxDrawbuffers = 1;
          var maxColorAttachments = 1;
          if (extensions.webgl_draw_buffers) {
            maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);
            maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);
          }
          var readFloat = !!extensions.oes_texture_float;
          if (readFloat) {
            var readFloatTexture = gl.createTexture();
            gl.bindTexture(GL_TEXTURE_2D, readFloatTexture);
            gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT, null);
            var fbo = gl.createFramebuffer();
            gl.bindFramebuffer(GL_FRAMEBUFFER, fbo);
            gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0);
            gl.bindTexture(GL_TEXTURE_2D, null);
            if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false;
            else {
              gl.viewport(0, 0, 1, 1);
              gl.clearColor(1, 0, 0, 1);
              gl.clear(GL_COLOR_BUFFER_BIT$1);
              var pixels = pool.allocType(GL_FLOAT, 4);
              gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT, pixels);
              if (gl.getError()) readFloat = false;
              else {
                gl.deleteFramebuffer(fbo);
                gl.deleteTexture(readFloatTexture);
                readFloat = pixels[0] === 1;
              }
              pool.freeType(pixels);
            }
          }
          var isIE = typeof navigator !== "undefined" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent));
          var npotTextureCube = true;
          if (!isIE) {
            var cubeTexture = gl.createTexture();
            var data = pool.allocType(GL_UNSIGNED_BYTE, 36);
            gl.activeTexture(GL_TEXTURE0);
            gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture);
            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
            pool.freeType(data);
            gl.bindTexture(GL_TEXTURE_CUBE_MAP, null);
            gl.deleteTexture(cubeTexture);
            npotTextureCube = !gl.getError();
          }
          return {
            // drawing buffer bit depth
            colorBits: [
              gl.getParameter(GL_RED_BITS),
              gl.getParameter(GL_GREEN_BITS),
              gl.getParameter(GL_BLUE_BITS),
              gl.getParameter(GL_ALPHA_BITS)
            ],
            depthBits: gl.getParameter(GL_DEPTH_BITS),
            stencilBits: gl.getParameter(GL_STENCIL_BITS),
            subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),
            // supported extensions
            extensions: Object.keys(extensions).filter(function(ext) {
              return !!extensions[ext];
            }),
            // max aniso samples
            maxAnisotropic,
            // max draw buffers
            maxDrawbuffers,
            maxColorAttachments,
            // point and line size ranges
            pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
            lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
            maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
            maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
            maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
            maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
            maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
            maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
            maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
            maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
            maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
            maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),
            // vendor info
            glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
            renderer: gl.getParameter(GL_RENDERER),
            vendor: gl.getParameter(GL_VENDOR),
            version: gl.getParameter(GL_VERSION),
            // quirks
            readFloat,
            npotTextureCube
          };
        };
        var isTypedArray = function(x) {
          return x instanceof Uint8Array || x instanceof Uint16Array || x instanceof Uint32Array || x instanceof Int8Array || x instanceof Int16Array || x instanceof Int32Array || x instanceof Float32Array || x instanceof Float64Array || x instanceof Uint8ClampedArray;
        };
        function isNDArrayLike(obj) {
          return !!obj && typeof obj === "object" && Array.isArray(obj.shape) && Array.isArray(obj.stride) && typeof obj.offset === "number" && obj.shape.length === obj.stride.length && (Array.isArray(obj.data) || isTypedArray(obj.data));
        }
        var values = function(obj) {
          return Object.keys(obj).map(function(key) {
            return obj[key];
          });
        };
        var flattenUtils = {
          shape: arrayShape$1,
          flatten: flattenArray
        };
        function flatten1D(array, nx, out) {
          for (var i = 0; i < nx; ++i) {
            out[i] = array[i];
          }
        }
        function flatten2D(array, nx, ny, out) {
          var ptr = 0;
          for (var i = 0; i < nx; ++i) {
            var row = array[i];
            for (var j = 0; j < ny; ++j) {
              out[ptr++] = row[j];
            }
          }
        }
        function flatten3D(array, nx, ny, nz, out, ptr_) {
          var ptr = ptr_;
          for (var i = 0; i < nx; ++i) {
            var row = array[i];
            for (var j = 0; j < ny; ++j) {
              var col = row[j];
              for (var k = 0; k < nz; ++k) {
                out[ptr++] = col[k];
              }
            }
          }
        }
        function flattenRec(array, shape, level, out, ptr) {
          var stride = 1;
          for (var i = level + 1; i < shape.length; ++i) {
            stride *= shape[i];
          }
          var n = shape[level];
          if (shape.length - level === 4) {
            var nx = shape[level + 1];
            var ny = shape[level + 2];
            var nz = shape[level + 3];
            for (i = 0; i < n; ++i) {
              flatten3D(array[i], nx, ny, nz, out, ptr);
              ptr += stride;
            }
          } else {
            for (i = 0; i < n; ++i) {
              flattenRec(array[i], shape, level + 1, out, ptr);
              ptr += stride;
            }
          }
        }
        function flattenArray(array, shape, type, out_) {
          var sz = 1;
          if (shape.length) {
            for (var i = 0; i < shape.length; ++i) {
              sz *= shape[i];
            }
          } else {
            sz = 0;
          }
          var out = out_ || pool.allocType(type, sz);
          switch (shape.length) {
            case 0:
              break;
            case 1:
              flatten1D(array, shape[0], out);
              break;
            case 2:
              flatten2D(array, shape[0], shape[1], out);
              break;
            case 3:
              flatten3D(array, shape[0], shape[1], shape[2], out, 0);
              break;
            default:
              flattenRec(array, shape, 0, out, 0);
          }
          return out;
        }
        function arrayShape$1(array_) {
          var shape = [];
          for (var array = array_; array.length; array = array[0]) {
            shape.push(array.length);
          }
          return shape;
        }
        var arrayTypes = {
          "[object Int8Array]": 5120,
          "[object Int16Array]": 5122,
          "[object Int32Array]": 5124,
          "[object Uint8Array]": 5121,
          "[object Uint8ClampedArray]": 5121,
          "[object Uint16Array]": 5123,
          "[object Uint32Array]": 5125,
          "[object Float32Array]": 5126,
          "[object Float64Array]": 5121,
          "[object ArrayBuffer]": 5121
        };
        var int8 = 5120;
        var int16 = 5122;
        var int32 = 5124;
        var uint8 = 5121;
        var uint16 = 5123;
        var uint32 = 5125;
        var float = 5126;
        var float32 = 5126;
        var glTypes = {
          int8,
          int16,
          int32,
          uint8,
          uint16,
          uint32,
          float,
          float32
        };
        var dynamic$1 = 35048;
        var stream = 35040;
        var usageTypes = {
          dynamic: dynamic$1,
          stream,
          "static": 35044
        };
        var arrayFlatten = flattenUtils.flatten;
        var arrayShape = flattenUtils.shape;
        var GL_STATIC_DRAW = 35044;
        var GL_STREAM_DRAW = 35040;
        var GL_UNSIGNED_BYTE$2 = 5121;
        var GL_FLOAT$2 = 5126;
        var DTYPES_SIZES = [];
        DTYPES_SIZES[5120] = 1;
        DTYPES_SIZES[5122] = 2;
        DTYPES_SIZES[5124] = 4;
        DTYPES_SIZES[5121] = 1;
        DTYPES_SIZES[5123] = 2;
        DTYPES_SIZES[5125] = 4;
        DTYPES_SIZES[5126] = 4;
        function typedArrayCode(data) {
          return arrayTypes[Object.prototype.toString.call(data)] | 0;
        }
        function copyArray(out, inp) {
          for (var i = 0; i < inp.length; ++i) {
            out[i] = inp[i];
          }
        }
        function transpose(result, data, shapeX, shapeY, strideX, strideY, offset) {
          var ptr = 0;
          for (var i = 0; i < shapeX; ++i) {
            for (var j = 0; j < shapeY; ++j) {
              result[ptr++] = data[strideX * i + strideY * j + offset];
            }
          }
        }
        function wrapBufferState(gl, stats2, config, destroyBuffer) {
          var bufferCount = 0;
          var bufferSet = {};
          function REGLBuffer(type) {
            this.id = bufferCount++;
            this.buffer = gl.createBuffer();
            this.type = type;
            this.usage = GL_STATIC_DRAW;
            this.byteLength = 0;
            this.dimension = 1;
            this.dtype = GL_UNSIGNED_BYTE$2;
            this.persistentData = null;
            if (config.profile) {
              this.stats = { size: 0 };
            }
          }
          REGLBuffer.prototype.bind = function() {
            gl.bindBuffer(this.type, this.buffer);
          };
          REGLBuffer.prototype.destroy = function() {
            destroy(this);
          };
          var streamPool = [];
          function createStream(type, data) {
            var buffer = streamPool.pop();
            if (!buffer) {
              buffer = new REGLBuffer(type);
            }
            buffer.bind();
            initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);
            return buffer;
          }
          function destroyStream(stream$$1) {
            streamPool.push(stream$$1);
          }
          function initBufferFromTypedArray(buffer, data, usage) {
            buffer.byteLength = data.byteLength;
            gl.bufferData(buffer.type, data, usage);
          }
          function initBufferFromData(buffer, data, usage, dtype, dimension, persist) {
            var shape;
            buffer.usage = usage;
            if (Array.isArray(data)) {
              buffer.dtype = dtype || GL_FLOAT$2;
              if (data.length > 0) {
                var flatData;
                if (Array.isArray(data[0])) {
                  shape = arrayShape(data);
                  var dim = 1;
                  for (var i = 1; i < shape.length; ++i) {
                    dim *= shape[i];
                  }
                  buffer.dimension = dim;
                  flatData = arrayFlatten(data, shape, buffer.dtype);
                  initBufferFromTypedArray(buffer, flatData, usage);
                  if (persist) {
                    buffer.persistentData = flatData;
                  } else {
                    pool.freeType(flatData);
                  }
                } else if (typeof data[0] === "number") {
                  buffer.dimension = dimension;
                  var typedData = pool.allocType(buffer.dtype, data.length);
                  copyArray(typedData, data);
                  initBufferFromTypedArray(buffer, typedData, usage);
                  if (persist) {
                    buffer.persistentData = typedData;
                  } else {
                    pool.freeType(typedData);
                  }
                } else if (isTypedArray(data[0])) {
                  buffer.dimension = data[0].length;
                  buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$2;
                  flatData = arrayFlatten(
                    data,
                    [data.length, data[0].length],
                    buffer.dtype
                  );
                  initBufferFromTypedArray(buffer, flatData, usage);
                  if (persist) {
                    buffer.persistentData = flatData;
                  } else {
                    pool.freeType(flatData);
                  }
                } else {
                }
              }
            } else if (isTypedArray(data)) {
              buffer.dtype = dtype || typedArrayCode(data);
              buffer.dimension = dimension;
              initBufferFromTypedArray(buffer, data, usage);
              if (persist) {
                buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));
              }
            } else if (isNDArrayLike(data)) {
              shape = data.shape;
              var stride = data.stride;
              var offset = data.offset;
              var shapeX = 0;
              var shapeY = 0;
              var strideX = 0;
              var strideY = 0;
              if (shape.length === 1) {
                shapeX = shape[0];
                shapeY = 1;
                strideX = stride[0];
                strideY = 0;
              } else if (shape.length === 2) {
                shapeX = shape[0];
                shapeY = shape[1];
                strideX = stride[0];
                strideY = stride[1];
              } else {
              }
              buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$2;
              buffer.dimension = shapeY;
              var transposeData2 = pool.allocType(buffer.dtype, shapeX * shapeY);
              transpose(
                transposeData2,
                data.data,
                shapeX,
                shapeY,
                strideX,
                strideY,
                offset
              );
              initBufferFromTypedArray(buffer, transposeData2, usage);
              if (persist) {
                buffer.persistentData = transposeData2;
              } else {
                pool.freeType(transposeData2);
              }
            } else if (data instanceof ArrayBuffer) {
              buffer.dtype = GL_UNSIGNED_BYTE$2;
              buffer.dimension = dimension;
              initBufferFromTypedArray(buffer, data, usage);
              if (persist) {
                buffer.persistentData = new Uint8Array(new Uint8Array(data));
              }
            } else {
            }
          }
          function destroy(buffer) {
            stats2.bufferCount--;
            destroyBuffer(buffer);
            var handle = buffer.buffer;
            gl.deleteBuffer(handle);
            buffer.buffer = null;
            delete bufferSet[buffer.id];
          }
          function createBuffer(options, type, deferInit, persistent) {
            stats2.bufferCount++;
            var buffer = new REGLBuffer(type);
            bufferSet[buffer.id] = buffer;
            function reglBuffer(options2) {
              var usage = GL_STATIC_DRAW;
              var data = null;
              var byteLength = 0;
              var dtype = 0;
              var dimension = 1;
              if (Array.isArray(options2) || isTypedArray(options2) || isNDArrayLike(options2) || options2 instanceof ArrayBuffer) {
                data = options2;
              } else if (typeof options2 === "number") {
                byteLength = options2 | 0;
              } else if (options2) {
                if ("data" in options2) {
                  data = options2.data;
                }
                if ("usage" in options2) {
                  usage = usageTypes[options2.usage];
                }
                if ("type" in options2) {
                  dtype = glTypes[options2.type];
                }
                if ("dimension" in options2) {
                  dimension = options2.dimension | 0;
                }
                if ("length" in options2) {
                  byteLength = options2.length | 0;
                }
              }
              buffer.bind();
              if (!data) {
                if (byteLength) gl.bufferData(buffer.type, byteLength, usage);
                buffer.dtype = dtype || GL_UNSIGNED_BYTE$2;
                buffer.usage = usage;
                buffer.dimension = dimension;
                buffer.byteLength = byteLength;
              } else {
                initBufferFromData(buffer, data, usage, dtype, dimension, persistent);
              }
              if (config.profile) {
                buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];
              }
              return reglBuffer;
            }
            function setSubData(data, offset) {
              gl.bufferSubData(buffer.type, offset, data);
            }
            function subdata(data, offset_) {
              var offset = (offset_ || 0) | 0;
              var shape;
              buffer.bind();
              if (isTypedArray(data) || data instanceof ArrayBuffer) {
                setSubData(data, offset);
              } else if (Array.isArray(data)) {
                if (data.length > 0) {
                  if (typeof data[0] === "number") {
                    var converted = pool.allocType(buffer.dtype, data.length);
                    copyArray(converted, data);
                    setSubData(converted, offset);
                    pool.freeType(converted);
                  } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
                    shape = arrayShape(data);
                    var flatData = arrayFlatten(data, shape, buffer.dtype);
                    setSubData(flatData, offset);
                    pool.freeType(flatData);
                  } else {
                  }
                }
              } else if (isNDArrayLike(data)) {
                shape = data.shape;
                var stride = data.stride;
                var shapeX = 0;
                var shapeY = 0;
                var strideX = 0;
                var strideY = 0;
                if (shape.length === 1) {
                  shapeX = shape[0];
                  shapeY = 1;
                  strideX = stride[0];
                  strideY = 0;
                } else if (shape.length === 2) {
                  shapeX = shape[0];
                  shapeY = shape[1];
                  strideX = stride[0];
                  strideY = stride[1];
                } else {
                }
                var dtype = Array.isArray(data.data) ? buffer.dtype : typedArrayCode(data.data);
                var transposeData2 = pool.allocType(dtype, shapeX * shapeY);
                transpose(
                  transposeData2,
                  data.data,
                  shapeX,
                  shapeY,
                  strideX,
                  strideY,
                  data.offset
                );
                setSubData(transposeData2, offset);
                pool.freeType(transposeData2);
              } else {
              }
              return reglBuffer;
            }
            if (!deferInit) {
              reglBuffer(options);
            }
            reglBuffer._reglType = "buffer";
            reglBuffer._buffer = buffer;
            reglBuffer.subdata = subdata;
            if (config.profile) {
              reglBuffer.stats = buffer.stats;
            }
            reglBuffer.destroy = function() {
              destroy(buffer);
            };
            return reglBuffer;
          }
          function restoreBuffers() {
            values(bufferSet).forEach(function(buffer) {
              buffer.buffer = gl.createBuffer();
              gl.bindBuffer(buffer.type, buffer.buffer);
              gl.bufferData(
                buffer.type,
                buffer.persistentData || buffer.byteLength,
                buffer.usage
              );
            });
          }
          if (config.profile) {
            stats2.getTotalBufferSize = function() {
              var total = 0;
              Object.keys(bufferSet).forEach(function(key) {
                total += bufferSet[key].stats.size;
              });
              return total;
            };
          }
          return {
            create: createBuffer,
            createStream,
            destroyStream,
            clear: function() {
              values(bufferSet).forEach(destroy);
              streamPool.forEach(destroy);
            },
            getBuffer: function(wrapper) {
              if (wrapper && wrapper._buffer instanceof REGLBuffer) {
                return wrapper._buffer;
              }
              return null;
            },
            restore: restoreBuffers,
            _initBuffer: initBufferFromData
          };
        }
        var points = 0;
        var point = 0;
        var lines = 1;
        var line = 1;
        var triangles = 4;
        var triangle = 4;
        var primTypes = {
          points,
          point,
          lines,
          line,
          triangles,
          triangle,
          "line loop": 2,
          "line strip": 3,
          "triangle strip": 5,
          "triangle fan": 6
        };
        var GL_POINTS = 0;
        var GL_LINES = 1;
        var GL_TRIANGLES = 4;
        var GL_BYTE$1 = 5120;
        var GL_UNSIGNED_BYTE$3 = 5121;
        var GL_SHORT$1 = 5122;
        var GL_UNSIGNED_SHORT$1 = 5123;
        var GL_INT$1 = 5124;
        var GL_UNSIGNED_INT$1 = 5125;
        var GL_ELEMENT_ARRAY_BUFFER = 34963;
        var GL_STREAM_DRAW$1 = 35040;
        var GL_STATIC_DRAW$1 = 35044;
        function wrapElementsState(gl, extensions, bufferState, stats2) {
          var elementSet = {};
          var elementCount = 0;
          var elementTypes = {
            "uint8": GL_UNSIGNED_BYTE$3,
            "uint16": GL_UNSIGNED_SHORT$1
          };
          if (extensions.oes_element_index_uint) {
            elementTypes.uint32 = GL_UNSIGNED_INT$1;
          }
          function REGLElementBuffer(buffer) {
            this.id = elementCount++;
            elementSet[this.id] = this;
            this.buffer = buffer;
            this.primType = GL_TRIANGLES;
            this.vertCount = 0;
            this.type = 0;
          }
          REGLElementBuffer.prototype.bind = function() {
            this.buffer.bind();
          };
          var bufferPool = [];
          function createElementStream(data) {
            var result = bufferPool.pop();
            if (!result) {
              result = new REGLElementBuffer(bufferState.create(
                null,
                GL_ELEMENT_ARRAY_BUFFER,
                true,
                false
              )._buffer);
            }
            initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);
            return result;
          }
          function destroyElementStream(elements) {
            bufferPool.push(elements);
          }
          function initElements(elements, data, usage, prim, count, byteLength, type) {
            elements.buffer.bind();
            var dtype;
            if (data) {
              var predictedType = type;
              if (!type && (!isTypedArray(data) || isNDArrayLike(data) && !isTypedArray(data.data))) {
                predictedType = extensions.oes_element_index_uint ? GL_UNSIGNED_INT$1 : GL_UNSIGNED_SHORT$1;
              }
              bufferState._initBuffer(
                elements.buffer,
                data,
                usage,
                predictedType,
                3
              );
            } else {
              gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);
              elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;
              elements.buffer.usage = usage;
              elements.buffer.dimension = 3;
              elements.buffer.byteLength = byteLength;
            }
            dtype = type;
            if (!type) {
              switch (elements.buffer.dtype) {
                case GL_UNSIGNED_BYTE$3:
                case GL_BYTE$1:
                  dtype = GL_UNSIGNED_BYTE$3;
                  break;
                case GL_UNSIGNED_SHORT$1:
                case GL_SHORT$1:
                  dtype = GL_UNSIGNED_SHORT$1;
                  break;
                case GL_UNSIGNED_INT$1:
                case GL_INT$1:
                  dtype = GL_UNSIGNED_INT$1;
                  break;
                default:
              }
              elements.buffer.dtype = dtype;
            }
            elements.type = dtype;
            var vertCount = count;
            if (vertCount < 0) {
              vertCount = elements.buffer.byteLength;
              if (dtype === GL_UNSIGNED_SHORT$1) {
                vertCount >>= 1;
              } else if (dtype === GL_UNSIGNED_INT$1) {
                vertCount >>= 2;
              }
            }
            elements.vertCount = vertCount;
            var primType = prim;
            if (prim < 0) {
              primType = GL_TRIANGLES;
              var dimension = elements.buffer.dimension;
              if (dimension === 1) primType = GL_POINTS;
              if (dimension === 2) primType = GL_LINES;
              if (dimension === 3) primType = GL_TRIANGLES;
            }
            elements.primType = primType;
          }
          function destroyElements(elements) {
            stats2.elementsCount--;
            delete elementSet[elements.id];
            elements.buffer.destroy();
            elements.buffer = null;
          }
          function createElements(options, persistent) {
            var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);
            var elements = new REGLElementBuffer(buffer._buffer);
            stats2.elementsCount++;
            function reglElements(options2) {
              if (!options2) {
                buffer();
                elements.primType = GL_TRIANGLES;
                elements.vertCount = 0;
                elements.type = GL_UNSIGNED_BYTE$3;
              } else if (typeof options2 === "number") {
                buffer(options2);
                elements.primType = GL_TRIANGLES;
                elements.vertCount = options2 | 0;
                elements.type = GL_UNSIGNED_BYTE$3;
              } else {
                var data = null;
                var usage = GL_STATIC_DRAW$1;
                var primType = -1;
                var vertCount = -1;
                var byteLength = 0;
                var dtype = 0;
                if (Array.isArray(options2) || isTypedArray(options2) || isNDArrayLike(options2)) {
                  data = options2;
                } else {
                  if ("data" in options2) {
                    data = options2.data;
                  }
                  if ("usage" in options2) {
                    usage = usageTypes[options2.usage];
                  }
                  if ("primitive" in options2) {
                    primType = primTypes[options2.primitive];
                  }
                  if ("count" in options2) {
                    vertCount = options2.count | 0;
                  }
                  if ("type" in options2) {
                    dtype = elementTypes[options2.type];
                  }
                  if ("length" in options2) {
                    byteLength = options2.length | 0;
                  } else {
                    byteLength = vertCount;
                    if (dtype === GL_UNSIGNED_SHORT$1 || dtype === GL_SHORT$1) {
                      byteLength *= 2;
                    } else if (dtype === GL_UNSIGNED_INT$1 || dtype === GL_INT$1) {
                      byteLength *= 4;
                    }
                  }
                }
                initElements(
                  elements,
                  data,
                  usage,
                  primType,
                  vertCount,
                  byteLength,
                  dtype
                );
              }
              return reglElements;
            }
            reglElements(options);
            reglElements._reglType = "elements";
            reglElements._elements = elements;
            reglElements.subdata = function(data, offset) {
              buffer.subdata(data, offset);
              return reglElements;
            };
            reglElements.destroy = function() {
              destroyElements(elements);
            };
            return reglElements;
          }
          return {
            create: createElements,
            createStream: createElementStream,
            destroyStream: destroyElementStream,
            getElements: function(elements) {
              if (typeof elements === "function" && elements._elements instanceof REGLElementBuffer) {
                return elements._elements;
              }
              return null;
            },
            clear: function() {
              values(elementSet).forEach(destroyElements);
            }
          };
        }
        var FLOAT = new Float32Array(1);
        var INT = new Uint32Array(FLOAT.buffer);
        var GL_UNSIGNED_SHORT$3 = 5123;
        function convertToHalfFloat(array) {
          var ushorts = pool.allocType(GL_UNSIGNED_SHORT$3, array.length);
          for (var i = 0; i < array.length; ++i) {
            if (isNaN(array[i])) {
              ushorts[i] = 65535;
            } else if (array[i] === Infinity) {
              ushorts[i] = 31744;
            } else if (array[i] === -Infinity) {
              ushorts[i] = 64512;
            } else {
              FLOAT[0] = array[i];
              var x = INT[0];
              var sgn = x >>> 31 << 15;
              var exp = (x << 1 >>> 24) - 127;
              var frac = x >> 13 & (1 << 10) - 1;
              if (exp < -24) {
                ushorts[i] = sgn;
              } else if (exp < -14) {
                var s = -14 - exp;
                ushorts[i] = sgn + (frac + (1 << 10) >> s);
              } else if (exp > 15) {
                ushorts[i] = sgn + 31744;
              } else {
                ushorts[i] = sgn + (exp + 15 << 10) + frac;
              }
            }
          }
          return ushorts;
        }
        function isArrayLike(s) {
          return Array.isArray(s) || isTypedArray(s);
        }
        var GL_COMPRESSED_TEXTURE_FORMATS = 34467;
        var GL_TEXTURE_2D$1 = 3553;
        var GL_TEXTURE_CUBE_MAP$1 = 34067;
        var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 34069;
        var GL_RGBA$1 = 6408;
        var GL_ALPHA = 6406;
        var GL_RGB = 6407;
        var GL_LUMINANCE = 6409;
        var GL_LUMINANCE_ALPHA = 6410;
        var GL_RGBA4 = 32854;
        var GL_RGB5_A1 = 32855;
        var GL_RGB565 = 36194;
        var GL_UNSIGNED_SHORT_4_4_4_4 = 32819;
        var GL_UNSIGNED_SHORT_5_5_5_1 = 32820;
        var GL_UNSIGNED_SHORT_5_6_5 = 33635;
        var GL_UNSIGNED_INT_24_8_WEBGL = 34042;
        var GL_DEPTH_COMPONENT = 6402;
        var GL_DEPTH_STENCIL = 34041;
        var GL_SRGB_EXT = 35904;
        var GL_SRGB_ALPHA_EXT = 35906;
        var GL_HALF_FLOAT_OES = 36193;
        var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
        var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
        var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
        var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
        var GL_COMPRESSED_RGB_ATC_WEBGL = 35986;
        var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987;
        var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798;
        var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
        var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
        var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
        var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
        var GL_COMPRESSED_RGB_ETC1_WEBGL = 36196;
        var GL_UNSIGNED_BYTE$4 = 5121;
        var GL_UNSIGNED_SHORT$2 = 5123;
        var GL_UNSIGNED_INT$2 = 5125;
        var GL_FLOAT$3 = 5126;
        var GL_TEXTURE_WRAP_S = 10242;
        var GL_TEXTURE_WRAP_T = 10243;
        var GL_REPEAT = 10497;
        var GL_CLAMP_TO_EDGE = 33071;
        var GL_MIRRORED_REPEAT = 33648;
        var GL_TEXTURE_MAG_FILTER = 10240;
        var GL_TEXTURE_MIN_FILTER = 10241;
        var GL_NEAREST = 9728;
        var GL_LINEAR = 9729;
        var GL_NEAREST_MIPMAP_NEAREST = 9984;
        var GL_LINEAR_MIPMAP_NEAREST = 9985;
        var GL_NEAREST_MIPMAP_LINEAR = 9986;
        var GL_LINEAR_MIPMAP_LINEAR = 9987;
        var GL_GENERATE_MIPMAP_HINT = 33170;
        var GL_DONT_CARE = 4352;
        var GL_FASTEST = 4353;
        var GL_NICEST = 4354;
        var GL_TEXTURE_MAX_ANISOTROPY_EXT = 34046;
        var GL_UNPACK_ALIGNMENT = 3317;
        var GL_UNPACK_FLIP_Y_WEBGL = 37440;
        var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
        var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
        var GL_BROWSER_DEFAULT_WEBGL = 37444;
        var GL_TEXTURE0$1 = 33984;
        var MIPMAP_FILTERS = [
          GL_NEAREST_MIPMAP_NEAREST,
          GL_NEAREST_MIPMAP_LINEAR,
          GL_LINEAR_MIPMAP_NEAREST,
          GL_LINEAR_MIPMAP_LINEAR
        ];
        var CHANNELS_FORMAT = [
          0,
          GL_LUMINANCE,
          GL_LUMINANCE_ALPHA,
          GL_RGB,
          GL_RGBA$1
        ];
        var FORMAT_CHANNELS = {};
        FORMAT_CHANNELS[GL_LUMINANCE] = FORMAT_CHANNELS[GL_ALPHA] = FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;
        FORMAT_CHANNELS[GL_DEPTH_STENCIL] = FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;
        FORMAT_CHANNELS[GL_RGB] = FORMAT_CHANNELS[GL_SRGB_EXT] = 3;
        FORMAT_CHANNELS[GL_RGBA$1] = FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;
        function objectName(str) {
          return "[object " + str + "]";
        }
        var CANVAS_CLASS = objectName("HTMLCanvasElement");
        var OFFSCREENCANVAS_CLASS = objectName("OffscreenCanvas");
        var CONTEXT2D_CLASS = objectName("CanvasRenderingContext2D");
        var BITMAP_CLASS = objectName("ImageBitmap");
        var IMAGE_CLASS = objectName("HTMLImageElement");
        var VIDEO_CLASS = objectName("HTMLVideoElement");
        var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
          CANVAS_CLASS,
          OFFSCREENCANVAS_CLASS,
          CONTEXT2D_CLASS,
          BITMAP_CLASS,
          IMAGE_CLASS,
          VIDEO_CLASS
        ]);
        var TYPE_SIZES = [];
        TYPE_SIZES[GL_UNSIGNED_BYTE$4] = 1;
        TYPE_SIZES[GL_FLOAT$3] = 4;
        TYPE_SIZES[GL_HALF_FLOAT_OES] = 2;
        TYPE_SIZES[GL_UNSIGNED_SHORT$2] = 2;
        TYPE_SIZES[GL_UNSIGNED_INT$2] = 4;
        var FORMAT_SIZES_SPECIAL = [];
        FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;
        FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;
        FORMAT_SIZES_SPECIAL[GL_RGB565] = 2;
        FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;
        FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;
        function isNumericArray(arr) {
          return Array.isArray(arr) && (arr.length === 0 || typeof arr[0] === "number");
        }
        function isRectArray(arr) {
          if (!Array.isArray(arr)) {
            return false;
          }
          var width = arr.length;
          if (width === 0 || !isArrayLike(arr[0])) {
            return false;
          }
          return true;
        }
        function classString(x) {
          return Object.prototype.toString.call(x);
        }
        function isCanvasElement(object) {
          return classString(object) === CANVAS_CLASS;
        }
        function isOffscreenCanvas(object) {
          return classString(object) === OFFSCREENCANVAS_CLASS;
        }
        function isContext2D(object) {
          return classString(object) === CONTEXT2D_CLASS;
        }
        function isBitmap(object) {
          return classString(object) === BITMAP_CLASS;
        }
        function isImageElement(object) {
          return classString(object) === IMAGE_CLASS;
        }
        function isVideoElement(object) {
          return classString(object) === VIDEO_CLASS;
        }
        function isPixelData(object) {
          if (!object) {
            return false;
          }
          var className = classString(object);
          if (PIXEL_CLASSES.indexOf(className) >= 0) {
            return true;
          }
          return isNumericArray(object) || isRectArray(object) || isNDArrayLike(object);
        }
        function typedArrayCode$1(data) {
          return arrayTypes[Object.prototype.toString.call(data)] | 0;
        }
        function convertData(result, data) {
          var n = data.length;
          switch (result.type) {
            case GL_UNSIGNED_BYTE$4:
            case GL_UNSIGNED_SHORT$2:
            case GL_UNSIGNED_INT$2:
            case GL_FLOAT$3:
              var converted = pool.allocType(result.type, n);
              converted.set(data);
              result.data = converted;
              break;
            case GL_HALF_FLOAT_OES:
              result.data = convertToHalfFloat(data);
              break;
            default:
          }
        }
        function preConvert(image, n) {
          return pool.allocType(
            image.type === GL_HALF_FLOAT_OES ? GL_FLOAT$3 : image.type,
            n
          );
        }
        function postConvert(image, data) {
          if (image.type === GL_HALF_FLOAT_OES) {
            image.data = convertToHalfFloat(data);
            pool.freeType(data);
          } else {
            image.data = data;
          }
        }
        function transposeData(image, array, strideX, strideY, strideC, offset) {
          var w = image.width;
          var h = image.height;
          var c = image.channels;
          var n = w * h * c;
          var data = preConvert(image, n);
          var p = 0;
          for (var i = 0; i < h; ++i) {
            for (var j = 0; j < w; ++j) {
              for (var k = 0; k < c; ++k) {
                data[p++] = array[strideX * j + strideY * i + strideC * k + offset];
              }
            }
          }
          postConvert(image, data);
        }
        function getTextureSize(format, type, width, height, isMipmap, isCube) {
          var s;
          if (typeof FORMAT_SIZES_SPECIAL[format] !== "undefined") {
            s = FORMAT_SIZES_SPECIAL[format];
          } else {
            s = FORMAT_CHANNELS[format] * TYPE_SIZES[type];
          }
          if (isCube) {
            s *= 6;
          }
          if (isMipmap) {
            var total = 0;
            var w = width;
            while (w >= 1) {
              total += s * w * w;
              w /= 2;
            }
            return total;
          } else {
            return s * width * height;
          }
        }
        function createTextureSet(gl, extensions, limits, reglPoll, contextState, stats2, config) {
          var mipmapHint = {
            "don't care": GL_DONT_CARE,
            "dont care": GL_DONT_CARE,
            "nice": GL_NICEST,
            "fast": GL_FASTEST
          };
          var wrapModes = {
            "repeat": GL_REPEAT,
            "clamp": GL_CLAMP_TO_EDGE,
            "mirror": GL_MIRRORED_REPEAT
          };
          var magFilters = {
            "nearest": GL_NEAREST,
            "linear": GL_LINEAR
          };
          var minFilters = extend({
            "mipmap": GL_LINEAR_MIPMAP_LINEAR,
            "nearest mipmap nearest": GL_NEAREST_MIPMAP_NEAREST,
            "linear mipmap nearest": GL_LINEAR_MIPMAP_NEAREST,
            "nearest mipmap linear": GL_NEAREST_MIPMAP_LINEAR,
            "linear mipmap linear": GL_LINEAR_MIPMAP_LINEAR
          }, magFilters);
          var colorSpace = {
            "none": 0,
            "browser": GL_BROWSER_DEFAULT_WEBGL
          };
          var textureTypes = {
            "uint8": GL_UNSIGNED_BYTE$4,
            "rgba4": GL_UNSIGNED_SHORT_4_4_4_4,
            "rgb565": GL_UNSIGNED_SHORT_5_6_5,
            "rgb5 a1": GL_UNSIGNED_SHORT_5_5_5_1
          };
          var textureFormats = {
            "alpha": GL_ALPHA,
            "luminance": GL_LUMINANCE,
            "luminance alpha": GL_LUMINANCE_ALPHA,
            "rgb": GL_RGB,
            "rgba": GL_RGBA$1,
            "rgba4": GL_RGBA4,
            "rgb5 a1": GL_RGB5_A1,
            "rgb565": GL_RGB565
          };
          var compressedTextureFormats = {};
          if (extensions.ext_srgb) {
            textureFormats.srgb = GL_SRGB_EXT;
            textureFormats.srgba = GL_SRGB_ALPHA_EXT;
          }
          if (extensions.oes_texture_float) {
            textureTypes.float32 = textureTypes.float = GL_FLOAT$3;
          }
          if (extensions.oes_texture_half_float) {
            textureTypes["float16"] = textureTypes["half float"] = GL_HALF_FLOAT_OES;
          }
          if (extensions.webgl_depth_texture) {
            extend(textureFormats, {
              "depth": GL_DEPTH_COMPONENT,
              "depth stencil": GL_DEPTH_STENCIL
            });
            extend(textureTypes, {
              "uint16": GL_UNSIGNED_SHORT$2,
              "uint32": GL_UNSIGNED_INT$2,
              "depth stencil": GL_UNSIGNED_INT_24_8_WEBGL
            });
          }
          if (extensions.webgl_compressed_texture_s3tc) {
            extend(compressedTextureFormats, {
              "rgb s3tc dxt1": GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
              "rgba s3tc dxt1": GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
              "rgba s3tc dxt3": GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
              "rgba s3tc dxt5": GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
            });
          }
          if (extensions.webgl_compressed_texture_atc) {
            extend(compressedTextureFormats, {
              "rgb atc": GL_COMPRESSED_RGB_ATC_WEBGL,
              "rgba atc explicit alpha": GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
              "rgba atc interpolated alpha": GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
            });
          }
          if (extensions.webgl_compressed_texture_pvrtc) {
            extend(compressedTextureFormats, {
              "rgb pvrtc 4bppv1": GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
              "rgb pvrtc 2bppv1": GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
              "rgba pvrtc 4bppv1": GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
              "rgba pvrtc 2bppv1": GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            });
          }
          if (extensions.webgl_compressed_texture_etc1) {
            compressedTextureFormats["rgb etc1"] = GL_COMPRESSED_RGB_ETC1_WEBGL;
          }
          var supportedCompressedFormats = Array.prototype.slice.call(
            gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS)
          );
          Object.keys(compressedTextureFormats).forEach(function(name) {
            var format = compressedTextureFormats[name];
            if (supportedCompressedFormats.indexOf(format) >= 0) {
              textureFormats[name] = format;
            }
          });
          var supportedFormats = Object.keys(textureFormats);
          limits.textureFormats = supportedFormats;
          var textureFormatsInvert = [];
          Object.keys(textureFormats).forEach(function(key) {
            var val = textureFormats[key];
            textureFormatsInvert[val] = key;
          });
          var textureTypesInvert = [];
          Object.keys(textureTypes).forEach(function(key) {
            var val = textureTypes[key];
            textureTypesInvert[val] = key;
          });
          var magFiltersInvert = [];
          Object.keys(magFilters).forEach(function(key) {
            var val = magFilters[key];
            magFiltersInvert[val] = key;
          });
          var minFiltersInvert = [];
          Object.keys(minFilters).forEach(function(key) {
            var val = minFilters[key];
            minFiltersInvert[val] = key;
          });
          var wrapModesInvert = [];
          Object.keys(wrapModes).forEach(function(key) {
            var val = wrapModes[key];
            wrapModesInvert[val] = key;
          });
          var colorFormats = supportedFormats.reduce(function(color, key) {
            var glenum = textureFormats[key];
            if (glenum === GL_LUMINANCE || glenum === GL_ALPHA || glenum === GL_LUMINANCE || glenum === GL_LUMINANCE_ALPHA || glenum === GL_DEPTH_COMPONENT || glenum === GL_DEPTH_STENCIL || extensions.ext_srgb && (glenum === GL_SRGB_EXT || glenum === GL_SRGB_ALPHA_EXT)) {
              color[glenum] = glenum;
            } else if (glenum === GL_RGB5_A1 || key.indexOf("rgba") >= 0) {
              color[glenum] = GL_RGBA$1;
            } else {
              color[glenum] = GL_RGB;
            }
            return color;
          }, {});
          function TexFlags() {
            this.internalformat = GL_RGBA$1;
            this.format = GL_RGBA$1;
            this.type = GL_UNSIGNED_BYTE$4;
            this.compressed = false;
            this.premultiplyAlpha = false;
            this.flipY = false;
            this.unpackAlignment = 1;
            this.colorSpace = GL_BROWSER_DEFAULT_WEBGL;
            this.width = 0;
            this.height = 0;
            this.channels = 0;
          }
          function copyFlags(result, other) {
            result.internalformat = other.internalformat;
            result.format = other.format;
            result.type = other.type;
            result.compressed = other.compressed;
            result.premultiplyAlpha = other.premultiplyAlpha;
            result.flipY = other.flipY;
            result.unpackAlignment = other.unpackAlignment;
            result.colorSpace = other.colorSpace;
            result.width = other.width;
            result.height = other.height;
            result.channels = other.channels;
          }
          function parseFlags(flags, options) {
            if (typeof options !== "object" || !options) {
              return;
            }
            if ("premultiplyAlpha" in options) {
              flags.premultiplyAlpha = options.premultiplyAlpha;
            }
            if ("flipY" in options) {
              flags.flipY = options.flipY;
            }
            if ("alignment" in options) {
              flags.unpackAlignment = options.alignment;
            }
            if ("colorSpace" in options) {
              flags.colorSpace = colorSpace[options.colorSpace];
            }
            if ("type" in options) {
              var type = options.type;
              flags.type = textureTypes[type];
            }
            var w = flags.width;
            var h = flags.height;
            var c = flags.channels;
            var hasChannels = false;
            if ("shape" in options) {
              w = options.shape[0];
              h = options.shape[1];
              if (options.shape.length === 3) {
                c = options.shape[2];
                hasChannels = true;
              }
            } else {
              if ("radius" in options) {
                w = h = options.radius;
              }
              if ("width" in options) {
                w = options.width;
              }
              if ("height" in options) {
                h = options.height;
              }
              if ("channels" in options) {
                c = options.channels;
                hasChannels = true;
              }
            }
            flags.width = w | 0;
            flags.height = h | 0;
            flags.channels = c | 0;
            var hasFormat = false;
            if ("format" in options) {
              var formatStr = options.format;
              var internalformat = flags.internalformat = textureFormats[formatStr];
              flags.format = colorFormats[internalformat];
              if (formatStr in textureTypes) {
                if (!("type" in options)) {
                  flags.type = textureTypes[formatStr];
                }
              }
              if (formatStr in compressedTextureFormats) {
                flags.compressed = true;
              }
              hasFormat = true;
            }
            if (!hasChannels && hasFormat) {
              flags.channels = FORMAT_CHANNELS[flags.format];
            } else if (hasChannels && !hasFormat) {
              if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
                flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];
              }
            } else if (hasFormat && hasChannels) {
            }
          }
          function setFlags(flags) {
            gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);
            gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);
            gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);
            gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);
          }
          function TexImage() {
            TexFlags.call(this);
            this.xOffset = 0;
            this.yOffset = 0;
            this.data = null;
            this.needsFree = false;
            this.element = null;
            this.needsCopy = false;
          }
          function parseImage(image, options) {
            var data = null;
            if (isPixelData(options)) {
              data = options;
            } else if (options) {
              parseFlags(image, options);
              if ("x" in options) {
                image.xOffset = options.x | 0;
              }
              if ("y" in options) {
                image.yOffset = options.y | 0;
              }
              if (isPixelData(options.data)) {
                data = options.data;
              }
            }
            if (options.copy) {
              var viewW = contextState.viewportWidth;
              var viewH = contextState.viewportHeight;
              image.width = image.width || viewW - image.xOffset;
              image.height = image.height || viewH - image.yOffset;
              image.needsCopy = true;
            } else if (!data) {
              image.width = image.width || 1;
              image.height = image.height || 1;
              image.channels = image.channels || 4;
            } else if (isTypedArray(data)) {
              image.channels = image.channels || 4;
              image.data = data;
              if (!("type" in options) && image.type === GL_UNSIGNED_BYTE$4) {
                image.type = typedArrayCode$1(data);
              }
            } else if (isNumericArray(data)) {
              image.channels = image.channels || 4;
              convertData(image, data);
              image.alignment = 1;
              image.needsFree = true;
            } else if (isNDArrayLike(data)) {
              var array = data.data;
              if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$4) {
                image.type = typedArrayCode$1(array);
              }
              var shape = data.shape;
              var stride = data.stride;
              var shapeX, shapeY, shapeC, strideX, strideY, strideC;
              if (shape.length === 3) {
                shapeC = shape[2];
                strideC = stride[2];
              } else {
                shapeC = 1;
                strideC = 1;
              }
              shapeX = shape[0];
              shapeY = shape[1];
              strideX = stride[0];
              strideY = stride[1];
              image.alignment = 1;
              image.width = shapeX;
              image.height = shapeY;
              image.channels = shapeC;
              image.format = image.internalformat = CHANNELS_FORMAT[shapeC];
              image.needsFree = true;
              transposeData(image, array, strideX, strideY, strideC, data.offset);
            } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
              if (isCanvasElement(data) || isOffscreenCanvas(data)) {
                image.element = data;
              } else {
                image.element = data.canvas;
              }
              image.width = image.element.width;
              image.height = image.element.height;
              image.channels = 4;
            } else if (isBitmap(data)) {
              image.element = data;
              image.width = data.width;
              image.height = data.height;
              image.channels = 4;
            } else if (isImageElement(data)) {
              image.element = data;
              image.width = data.naturalWidth;
              image.height = data.naturalHeight;
              image.channels = 4;
            } else if (isVideoElement(data)) {
              image.element = data;
              image.width = data.videoWidth;
              image.height = data.videoHeight;
              image.channels = 4;
            } else if (isRectArray(data)) {
              var w = image.width || data[0].length;
              var h = image.height || data.length;
              var c = image.channels;
              if (isArrayLike(data[0][0])) {
                c = c || data[0][0].length;
              } else {
                c = c || 1;
              }
              var arrayShape2 = flattenUtils.shape(data);
              var n = 1;
              for (var dd = 0; dd < arrayShape2.length; ++dd) {
                n *= arrayShape2[dd];
              }
              var allocData = preConvert(image, n);
              flattenUtils.flatten(data, arrayShape2, "", allocData);
              postConvert(image, allocData);
              image.alignment = 1;
              image.width = w;
              image.height = h;
              image.channels = c;
              image.format = image.internalformat = CHANNELS_FORMAT[c];
              image.needsFree = true;
            }
            if (image.type === GL_FLOAT$3) {
            } else if (image.type === GL_HALF_FLOAT_OES) {
            }
          }
          function setImage(info, target, miplevel) {
            var element = info.element;
            var data = info.data;
            var internalformat = info.internalformat;
            var format = info.format;
            var type = info.type;
            var width = info.width;
            var height = info.height;
            setFlags(info);
            if (element) {
              gl.texImage2D(target, miplevel, format, format, type, element);
            } else if (info.compressed) {
              gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);
            } else if (info.needsCopy) {
              reglPoll();
              gl.copyTexImage2D(
                target,
                miplevel,
                format,
                info.xOffset,
                info.yOffset,
                width,
                height,
                0
              );
            } else {
              gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null);
            }
          }
          function setSubImage(info, target, x, y, miplevel) {
            var element = info.element;
            var data = info.data;
            var internalformat = info.internalformat;
            var format = info.format;
            var type = info.type;
            var width = info.width;
            var height = info.height;
            setFlags(info);
            if (element) {
              gl.texSubImage2D(
                target,
                miplevel,
                x,
                y,
                format,
                type,
                element
              );
            } else if (info.compressed) {
              gl.compressedTexSubImage2D(
                target,
                miplevel,
                x,
                y,
                internalformat,
                width,
                height,
                data
              );
            } else if (info.needsCopy) {
              reglPoll();
              gl.copyTexSubImage2D(
                target,
                miplevel,
                x,
                y,
                info.xOffset,
                info.yOffset,
                width,
                height
              );
            } else {
              gl.texSubImage2D(
                target,
                miplevel,
                x,
                y,
                width,
                height,
                format,
                type,
                data
              );
            }
          }
          var imagePool = [];
          function allocImage() {
            return imagePool.pop() || new TexImage();
          }
          function freeImage(image) {
            if (image.needsFree) {
              pool.freeType(image.data);
            }
            TexImage.call(image);
            imagePool.push(image);
          }
          function MipMap() {
            TexFlags.call(this);
            this.genMipmaps = false;
            this.mipmapHint = GL_DONT_CARE;
            this.mipmask = 0;
            this.images = Array(16);
          }
          function parseMipMapFromShape(mipmap, width, height) {
            var img = mipmap.images[0] = allocImage();
            mipmap.mipmask = 1;
            img.width = mipmap.width = width;
            img.height = mipmap.height = height;
            img.channels = mipmap.channels = 4;
          }
          function parseMipMapFromObject(mipmap, options) {
            var imgData = null;
            if (isPixelData(options)) {
              imgData = mipmap.images[0] = allocImage();
              copyFlags(imgData, mipmap);
              parseImage(imgData, options);
              mipmap.mipmask = 1;
            } else {
              parseFlags(mipmap, options);
              if (Array.isArray(options.mipmap)) {
                var mipData = options.mipmap;
                for (var i = 0; i < mipData.length; ++i) {
                  imgData = mipmap.images[i] = allocImage();
                  copyFlags(imgData, mipmap);
                  imgData.width >>= i;
                  imgData.height >>= i;
                  parseImage(imgData, mipData[i]);
                  mipmap.mipmask |= 1 << i;
                }
              } else {
                imgData = mipmap.images[0] = allocImage();
                copyFlags(imgData, mipmap);
                parseImage(imgData, options);
                mipmap.mipmask = 1;
              }
            }
            copyFlags(mipmap, mipmap.images[0]);
            if (mipmap.compressed && (mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT)) {
            }
          }
          function setMipMap(mipmap, target) {
            var images = mipmap.images;
            for (var i = 0; i < images.length; ++i) {
              if (!images[i]) {
                return;
              }
              setImage(images[i], target, i);
            }
          }
          var mipPool = [];
          function allocMipMap() {
            var result = mipPool.pop() || new MipMap();
            TexFlags.call(result);
            result.mipmask = 0;
            for (var i = 0; i < 16; ++i) {
              result.images[i] = null;
            }
            return result;
          }
          function freeMipMap(mipmap) {
            var images = mipmap.images;
            for (var i = 0; i < images.length; ++i) {
              if (images[i]) {
                freeImage(images[i]);
              }
              images[i] = null;
            }
            mipPool.push(mipmap);
          }
          function TexInfo() {
            this.minFilter = GL_NEAREST;
            this.magFilter = GL_NEAREST;
            this.wrapS = GL_CLAMP_TO_EDGE;
            this.wrapT = GL_CLAMP_TO_EDGE;
            this.anisotropic = 1;
            this.genMipmaps = false;
            this.mipmapHint = GL_DONT_CARE;
          }
          function parseTexInfo(info, options) {
            if ("min" in options) {
              var minFilter = options.min;
              info.minFilter = minFilters[minFilter];
              if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !("faces" in options)) {
                info.genMipmaps = true;
              }
            }
            if ("mag" in options) {
              var magFilter = options.mag;
              info.magFilter = magFilters[magFilter];
            }
            var wrapS = info.wrapS;
            var wrapT = info.wrapT;
            if ("wrap" in options) {
              var wrap = options.wrap;
              if (typeof wrap === "string") {
                wrapS = wrapT = wrapModes[wrap];
              } else if (Array.isArray(wrap)) {
                wrapS = wrapModes[wrap[0]];
                wrapT = wrapModes[wrap[1]];
              }
            } else {
              if ("wrapS" in options) {
                var optWrapS = options.wrapS;
                wrapS = wrapModes[optWrapS];
              }
              if ("wrapT" in options) {
                var optWrapT = options.wrapT;
                wrapT = wrapModes[optWrapT];
              }
            }
            info.wrapS = wrapS;
            info.wrapT = wrapT;
            if ("anisotropic" in options) {
              var anisotropic = options.anisotropic;
              info.anisotropic = options.anisotropic;
            }
            if ("mipmap" in options) {
              var hasMipMap = false;
              switch (typeof options.mipmap) {
                case "string":
                  info.mipmapHint = mipmapHint[options.mipmap];
                  info.genMipmaps = true;
                  hasMipMap = true;
                  break;
                case "boolean":
                  hasMipMap = info.genMipmaps = options.mipmap;
                  break;
                case "object":
                  info.genMipmaps = false;
                  hasMipMap = true;
                  break;
                default:
              }
              if (hasMipMap && !("min" in options)) {
                info.minFilter = GL_NEAREST_MIPMAP_NEAREST;
              }
            }
          }
          function setTexInfo(info, target) {
            gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);
            gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);
            gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);
            gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);
            if (extensions.ext_texture_filter_anisotropic) {
              gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);
            }
            if (info.genMipmaps) {
              gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);
              gl.generateMipmap(target);
            }
          }
          var textureCount = 0;
          var textureSet = {};
          var numTexUnits = limits.maxTextureUnits;
          var textureUnits = Array(numTexUnits).map(function() {
            return null;
          });
          function REGLTexture(target) {
            TexFlags.call(this);
            this.mipmask = 0;
            this.internalformat = GL_RGBA$1;
            this.id = textureCount++;
            this.refCount = 1;
            this.target = target;
            this.texture = gl.createTexture();
            this.unit = -1;
            this.bindCount = 0;
            this.texInfo = new TexInfo();
            if (config.profile) {
              this.stats = { size: 0 };
            }
          }
          function tempBind(texture) {
            gl.activeTexture(GL_TEXTURE0$1);
            gl.bindTexture(texture.target, texture.texture);
          }
          function tempRestore() {
            var prev = textureUnits[0];
            if (prev) {
              gl.bindTexture(prev.target, prev.texture);
            } else {
              gl.bindTexture(GL_TEXTURE_2D$1, null);
            }
          }
          function destroy(texture) {
            var handle = texture.texture;
            var unit = texture.unit;
            var target = texture.target;
            if (unit >= 0) {
              gl.activeTexture(GL_TEXTURE0$1 + unit);
              gl.bindTexture(target, null);
              textureUnits[unit] = null;
            }
            gl.deleteTexture(handle);
            texture.texture = null;
            texture.params = null;
            texture.pixels = null;
            texture.refCount = 0;
            delete textureSet[texture.id];
            stats2.textureCount--;
          }
          extend(REGLTexture.prototype, {
            bind: function() {
              var texture = this;
              texture.bindCount += 1;
              var unit = texture.unit;
              if (unit < 0) {
                for (var i = 0; i < numTexUnits; ++i) {
                  var other = textureUnits[i];
                  if (other) {
                    if (other.bindCount > 0) {
                      continue;
                    }
                    other.unit = -1;
                  }
                  textureUnits[i] = texture;
                  unit = i;
                  break;
                }
                if (unit >= numTexUnits) {
                }
                if (config.profile && stats2.maxTextureUnits < unit + 1) {
                  stats2.maxTextureUnits = unit + 1;
                }
                texture.unit = unit;
                gl.activeTexture(GL_TEXTURE0$1 + unit);
                gl.bindTexture(texture.target, texture.texture);
              }
              return unit;
            },
            unbind: function() {
              this.bindCount -= 1;
            },
            decRef: function() {
              if (--this.refCount <= 0) {
                destroy(this);
              }
            }
          });
          function createTexture2D(a, b) {
            var texture = new REGLTexture(GL_TEXTURE_2D$1);
            textureSet[texture.id] = texture;
            stats2.textureCount++;
            function reglTexture2D(a2, b2) {
              var texInfo = texture.texInfo;
              TexInfo.call(texInfo);
              var mipData = allocMipMap();
              if (typeof a2 === "number") {
                if (typeof b2 === "number") {
                  parseMipMapFromShape(mipData, a2 | 0, b2 | 0);
                } else {
                  parseMipMapFromShape(mipData, a2 | 0, a2 | 0);
                }
              } else if (a2) {
                parseTexInfo(texInfo, a2);
                parseMipMapFromObject(mipData, a2);
              } else {
                parseMipMapFromShape(mipData, 1, 1);
              }
              if (texInfo.genMipmaps) {
                mipData.mipmask = (mipData.width << 1) - 1;
              }
              texture.mipmask = mipData.mipmask;
              copyFlags(texture, mipData);
              texture.internalformat = mipData.internalformat;
              reglTexture2D.width = mipData.width;
              reglTexture2D.height = mipData.height;
              tempBind(texture);
              setMipMap(mipData, GL_TEXTURE_2D$1);
              setTexInfo(texInfo, GL_TEXTURE_2D$1);
              tempRestore();
              freeMipMap(mipData);
              if (config.profile) {
                texture.stats.size = getTextureSize(
                  texture.internalformat,
                  texture.type,
                  mipData.width,
                  mipData.height,
                  texInfo.genMipmaps,
                  false
                );
              }
              reglTexture2D.format = textureFormatsInvert[texture.internalformat];
              reglTexture2D.type = textureTypesInvert[texture.type];
              reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];
              reglTexture2D.min = minFiltersInvert[texInfo.minFilter];
              reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];
              reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];
              return reglTexture2D;
            }
            function subimage(image, x_, y_, level_) {
              var x = x_ | 0;
              var y = y_ | 0;
              var level = level_ | 0;
              var imageData = allocImage();
              copyFlags(imageData, texture);
              imageData.width = 0;
              imageData.height = 0;
              parseImage(imageData, image);
              imageData.width = imageData.width || (texture.width >> level) - x;
              imageData.height = imageData.height || (texture.height >> level) - y;
              tempBind(texture);
              setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level);
              tempRestore();
              freeImage(imageData);
              return reglTexture2D;
            }
            function resize(w_, h_) {
              var w = w_ | 0;
              var h = h_ | 0 || w;
              if (w === texture.width && h === texture.height) {
                return reglTexture2D;
              }
              reglTexture2D.width = texture.width = w;
              reglTexture2D.height = texture.height = h;
              tempBind(texture);
              for (var i = 0; texture.mipmask >> i; ++i) {
                var _w = w >> i;
                var _h = h >> i;
                if (!_w || !_h) break;
                gl.texImage2D(
                  GL_TEXTURE_2D$1,
                  i,
                  texture.format,
                  _w,
                  _h,
                  0,
                  texture.format,
                  texture.type,
                  null
                );
              }
              tempRestore();
              if (config.profile) {
                texture.stats.size = getTextureSize(
                  texture.internalformat,
                  texture.type,
                  w,
                  h,
                  false,
                  false
                );
              }
              return reglTexture2D;
            }
            reglTexture2D(a, b);
            reglTexture2D.subimage = subimage;
            reglTexture2D.resize = resize;
            reglTexture2D._reglType = "texture2d";
            reglTexture2D._texture = texture;
            if (config.profile) {
              reglTexture2D.stats = texture.stats;
            }
            reglTexture2D.destroy = function() {
              texture.decRef();
            };
            return reglTexture2D;
          }
          function createTextureCube(a0, a1, a2, a3, a4, a5) {
            var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1);
            textureSet[texture.id] = texture;
            stats2.cubeCount++;
            var faces = new Array(6);
            function reglTextureCube(a02, a12, a22, a32, a42, a52) {
              var i;
              var texInfo = texture.texInfo;
              TexInfo.call(texInfo);
              for (i = 0; i < 6; ++i) {
                faces[i] = allocMipMap();
              }
              if (typeof a02 === "number" || !a02) {
                var s = a02 | 0 || 1;
                for (i = 0; i < 6; ++i) {
                  parseMipMapFromShape(faces[i], s, s);
                }
              } else if (typeof a02 === "object") {
                if (a12) {
                  parseMipMapFromObject(faces[0], a02);
                  parseMipMapFromObject(faces[1], a12);
                  parseMipMapFromObject(faces[2], a22);
                  parseMipMapFromObject(faces[3], a32);
                  parseMipMapFromObject(faces[4], a42);
                  parseMipMapFromObject(faces[5], a52);
                } else {
                  parseTexInfo(texInfo, a02);
                  parseFlags(texture, a02);
                  if ("faces" in a02) {
                    var faceInput = a02.faces;
                    for (i = 0; i < 6; ++i) {
                      copyFlags(faces[i], texture);
                      parseMipMapFromObject(faces[i], faceInput[i]);
                    }
                  } else {
                    for (i = 0; i < 6; ++i) {
                      parseMipMapFromObject(faces[i], a02);
                    }
                  }
                }
              } else {
              }
              copyFlags(texture, faces[0]);
              if (texInfo.genMipmaps) {
                texture.mipmask = (faces[0].width << 1) - 1;
              } else {
                texture.mipmask = faces[0].mipmask;
              }
              texture.internalformat = faces[0].internalformat;
              reglTextureCube.width = faces[0].width;
              reglTextureCube.height = faces[0].height;
              tempBind(texture);
              for (i = 0; i < 6; ++i) {
                setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i);
              }
              setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1);
              tempRestore();
              if (config.profile) {
                texture.stats.size = getTextureSize(
                  texture.internalformat,
                  texture.type,
                  reglTextureCube.width,
                  reglTextureCube.height,
                  texInfo.genMipmaps,
                  true
                );
              }
              reglTextureCube.format = textureFormatsInvert[texture.internalformat];
              reglTextureCube.type = textureTypesInvert[texture.type];
              reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];
              reglTextureCube.min = minFiltersInvert[texInfo.minFilter];
              reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];
              reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];
              for (i = 0; i < 6; ++i) {
                freeMipMap(faces[i]);
              }
              return reglTextureCube;
            }
            function subimage(face, image, x_, y_, level_) {
              var x = x_ | 0;
              var y = y_ | 0;
              var level = level_ | 0;
              var imageData = allocImage();
              copyFlags(imageData, texture);
              imageData.width = 0;
              imageData.height = 0;
              parseImage(imageData, image);
              imageData.width = imageData.width || (texture.width >> level) - x;
              imageData.height = imageData.height || (texture.height >> level) - y;
              tempBind(texture);
              setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level);
              tempRestore();
              freeImage(imageData);
              return reglTextureCube;
            }
            function resize(radius_) {
              var radius = radius_ | 0;
              if (radius === texture.width) {
                return;
              }
              reglTextureCube.width = texture.width = radius;
              reglTextureCube.height = texture.height = radius;
              tempBind(texture);
              for (var i = 0; i < 6; ++i) {
                for (var j = 0; texture.mipmask >> j; ++j) {
                  gl.texImage2D(
                    GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
                    j,
                    texture.format,
                    radius >> j,
                    radius >> j,
                    0,
                    texture.format,
                    texture.type,
                    null
                  );
                }
              }
              tempRestore();
              if (config.profile) {
                texture.stats.size = getTextureSize(
                  texture.internalformat,
                  texture.type,
                  reglTextureCube.width,
                  reglTextureCube.height,
                  false,
                  true
                );
              }
              return reglTextureCube;
            }
            reglTextureCube(a0, a1, a2, a3, a4, a5);
            reglTextureCube.subimage = subimage;
            reglTextureCube.resize = resize;
            reglTextureCube._reglType = "textureCube";
            reglTextureCube._texture = texture;
            if (config.profile) {
              reglTextureCube.stats = texture.stats;
            }
            reglTextureCube.destroy = function() {
              texture.decRef();
            };
            return reglTextureCube;
          }
          function destroyTextures() {
            for (var i = 0; i < numTexUnits; ++i) {
              gl.activeTexture(GL_TEXTURE0$1 + i);
              gl.bindTexture(GL_TEXTURE_2D$1, null);
              textureUnits[i] = null;
            }
            values(textureSet).forEach(destroy);
            stats2.cubeCount = 0;
            stats2.textureCount = 0;
          }
          if (config.profile) {
            stats2.getTotalTextureSize = function() {
              var total = 0;
              Object.keys(textureSet).forEach(function(key) {
                total += textureSet[key].stats.size;
              });
              return total;
            };
          }
          function restoreTextures() {
            for (var i = 0; i < numTexUnits; ++i) {
              var tex = textureUnits[i];
              if (tex) {
                tex.bindCount = 0;
                tex.unit = -1;
                textureUnits[i] = null;
              }
            }
            values(textureSet).forEach(function(texture) {
              texture.texture = gl.createTexture();
              gl.bindTexture(texture.target, texture.texture);
              for (var i2 = 0; i2 < 32; ++i2) {
                if ((texture.mipmask & 1 << i2) === 0) {
                  continue;
                }
                if (texture.target === GL_TEXTURE_2D$1) {
                  gl.texImage2D(
                    GL_TEXTURE_2D$1,
                    i2,
                    texture.internalformat,
                    texture.width >> i2,
                    texture.height >> i2,
                    0,
                    texture.internalformat,
                    texture.type,
                    null
                  );
                } else {
                  for (var j = 0; j < 6; ++j) {
                    gl.texImage2D(
                      GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
                      i2,
                      texture.internalformat,
                      texture.width >> i2,
                      texture.height >> i2,
                      0,
                      texture.internalformat,
                      texture.type,
                      null
                    );
                  }
                }
              }
              setTexInfo(texture.texInfo, texture.target);
            });
          }
          function refreshTextures() {
            for (var i = 0; i < numTexUnits; ++i) {
              var tex = textureUnits[i];
              if (tex) {
                tex.bindCount = 0;
                tex.unit = -1;
                textureUnits[i] = null;
              }
              gl.activeTexture(GL_TEXTURE0$1 + i);
              gl.bindTexture(GL_TEXTURE_2D$1, null);
              gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null);
            }
          }
          return {
            create2D: createTexture2D,
            createCube: createTextureCube,
            clear: destroyTextures,
            getTexture: function(wrapper) {
              return null;
            },
            restore: restoreTextures,
            refresh: refreshTextures
          };
        }
        var GL_RENDERBUFFER = 36161;
        var GL_RGBA4$1 = 32854;
        var GL_RGB5_A1$1 = 32855;
        var GL_RGB565$1 = 36194;
        var GL_DEPTH_COMPONENT16 = 33189;
        var GL_STENCIL_INDEX8 = 36168;
        var GL_DEPTH_STENCIL$1 = 34041;
        var GL_SRGB8_ALPHA8_EXT = 35907;
        var GL_RGBA32F_EXT = 34836;
        var GL_RGBA16F_EXT = 34842;
        var GL_RGB16F_EXT = 34843;
        var FORMAT_SIZES = [];
        FORMAT_SIZES[GL_RGBA4$1] = 2;
        FORMAT_SIZES[GL_RGB5_A1$1] = 2;
        FORMAT_SIZES[GL_RGB565$1] = 2;
        FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;
        FORMAT_SIZES[GL_STENCIL_INDEX8] = 1;
        FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;
        FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;
        FORMAT_SIZES[GL_RGBA32F_EXT] = 16;
        FORMAT_SIZES[GL_RGBA16F_EXT] = 8;
        FORMAT_SIZES[GL_RGB16F_EXT] = 6;
        function getRenderbufferSize(format, width, height) {
          return FORMAT_SIZES[format] * width * height;
        }
        var wrapRenderbuffers = function(gl, extensions, limits, stats2, config) {
          var formatTypes = {
            "rgba4": GL_RGBA4$1,
            "rgb565": GL_RGB565$1,
            "rgb5 a1": GL_RGB5_A1$1,
            "depth": GL_DEPTH_COMPONENT16,
            "stencil": GL_STENCIL_INDEX8,
            "depth stencil": GL_DEPTH_STENCIL$1
          };
          if (extensions.ext_srgb) {
            formatTypes["srgba"] = GL_SRGB8_ALPHA8_EXT;
          }
          if (extensions.ext_color_buffer_half_float) {
            formatTypes["rgba16f"] = GL_RGBA16F_EXT;
            formatTypes["rgb16f"] = GL_RGB16F_EXT;
          }
          if (extensions.webgl_color_buffer_float) {
            formatTypes["rgba32f"] = GL_RGBA32F_EXT;
          }
          var formatTypesInvert = [];
          Object.keys(formatTypes).forEach(function(key) {
            var val = formatTypes[key];
            formatTypesInvert[val] = key;
          });
          var renderbufferCount = 0;
          var renderbufferSet = {};
          function REGLRenderbuffer(renderbuffer) {
            this.id = renderbufferCount++;
            this.refCount = 1;
            this.renderbuffer = renderbuffer;
            this.format = GL_RGBA4$1;
            this.width = 0;
            this.height = 0;
            if (config.profile) {
              this.stats = { size: 0 };
            }
          }
          REGLRenderbuffer.prototype.decRef = function() {
            if (--this.refCount <= 0) {
              destroy(this);
            }
          };
          function destroy(rb) {
            var handle = rb.renderbuffer;
            gl.bindRenderbuffer(GL_RENDERBUFFER, null);
            gl.deleteRenderbuffer(handle);
            rb.renderbuffer = null;
            rb.refCount = 0;
            delete renderbufferSet[rb.id];
            stats2.renderbufferCount--;
          }
          function createRenderbuffer(a, b) {
            var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer());
            renderbufferSet[renderbuffer.id] = renderbuffer;
            stats2.renderbufferCount++;
            function reglRenderbuffer(a2, b2) {
              var w = 0;
              var h = 0;
              var format = GL_RGBA4$1;
              if (typeof a2 === "object" && a2) {
                var options = a2;
                if ("shape" in options) {
                  var shape = options.shape;
                  w = shape[0] | 0;
                  h = shape[1] | 0;
                } else {
                  if ("radius" in options) {
                    w = h = options.radius | 0;
                  }
                  if ("width" in options) {
                    w = options.width | 0;
                  }
                  if ("height" in options) {
                    h = options.height | 0;
                  }
                }
                if ("format" in options) {
                  format = formatTypes[options.format];
                }
              } else if (typeof a2 === "number") {
                w = a2 | 0;
                if (typeof b2 === "number") {
                  h = b2 | 0;
                } else {
                  h = w;
                }
              } else if (!a2) {
                w = h = 1;
              } else {
              }
              if (w === renderbuffer.width && h === renderbuffer.height && format === renderbuffer.format) {
                return;
              }
              reglRenderbuffer.width = renderbuffer.width = w;
              reglRenderbuffer.height = renderbuffer.height = h;
              renderbuffer.format = format;
              gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
              gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h);
              if (config.profile) {
                renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
              }
              reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];
              return reglRenderbuffer;
            }
            function resize(w_, h_) {
              var w = w_ | 0;
              var h = h_ | 0 || w;
              if (w === renderbuffer.width && h === renderbuffer.height) {
                return reglRenderbuffer;
              }
              reglRenderbuffer.width = renderbuffer.width = w;
              reglRenderbuffer.height = renderbuffer.height = h;
              gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
              gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h);
              if (config.profile) {
                renderbuffer.stats.size = getRenderbufferSize(
                  renderbuffer.format,
                  renderbuffer.width,
                  renderbuffer.height
                );
              }
              return reglRenderbuffer;
            }
            reglRenderbuffer(a, b);
            reglRenderbuffer.resize = resize;
            reglRenderbuffer._reglType = "renderbuffer";
            reglRenderbuffer._renderbuffer = renderbuffer;
            if (config.profile) {
              reglRenderbuffer.stats = renderbuffer.stats;
            }
            reglRenderbuffer.destroy = function() {
              renderbuffer.decRef();
            };
            return reglRenderbuffer;
          }
          if (config.profile) {
            stats2.getTotalRenderbufferSize = function() {
              var total = 0;
              Object.keys(renderbufferSet).forEach(function(key) {
                total += renderbufferSet[key].stats.size;
              });
              return total;
            };
          }
          function restoreRenderbuffers() {
            values(renderbufferSet).forEach(function(rb) {
              rb.renderbuffer = gl.createRenderbuffer();
              gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);
              gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);
            });
            gl.bindRenderbuffer(GL_RENDERBUFFER, null);
          }
          return {
            create: createRenderbuffer,
            clear: function() {
              values(renderbufferSet).forEach(destroy);
            },
            restore: restoreRenderbuffers
          };
        };
        var GL_FRAMEBUFFER$1 = 36160;
        var GL_RENDERBUFFER$1 = 36161;
        var GL_TEXTURE_2D$2 = 3553;
        var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 34069;
        var GL_COLOR_ATTACHMENT0$1 = 36064;
        var GL_DEPTH_ATTACHMENT = 36096;
        var GL_STENCIL_ATTACHMENT = 36128;
        var GL_DEPTH_STENCIL_ATTACHMENT = 33306;
        var GL_FRAMEBUFFER_COMPLETE$1 = 36053;
        var GL_HALF_FLOAT_OES$1 = 36193;
        var GL_UNSIGNED_BYTE$5 = 5121;
        var GL_FLOAT$4 = 5126;
        var GL_RGB$1 = 6407;
        var GL_RGBA$2 = 6408;
        var textureFormatChannels = [];
        textureFormatChannels[GL_RGBA$2] = 4;
        textureFormatChannels[GL_RGB$1] = 3;
        var textureTypeSizes = [];
        textureTypeSizes[GL_UNSIGNED_BYTE$5] = 1;
        textureTypeSizes[GL_FLOAT$4] = 4;
        textureTypeSizes[GL_HALF_FLOAT_OES$1] = 2;
        function wrapFBOState(gl, extensions, limits, textureState, renderbufferState, stats2) {
          var framebufferState = {
            cur: null,
            next: null,
            dirty: false,
            setFBO: null
          };
          var colorTextureFormats = ["rgba"];
          var colorRenderbufferFormats = ["rgba4", "rgb565", "rgb5 a1"];
          if (extensions.ext_srgb) {
            colorRenderbufferFormats.push("srgba");
          }
          if (extensions.ext_color_buffer_half_float) {
            colorRenderbufferFormats.push("rgba16f", "rgb16f");
          }
          if (extensions.webgl_color_buffer_float) {
            colorRenderbufferFormats.push("rgba32f");
          }
          var colorTypes = ["uint8"];
          if (extensions.oes_texture_half_float) {
            colorTypes.push("half float", "float16");
          }
          if (extensions.oes_texture_float) {
            colorTypes.push("float", "float32");
          }
          function FramebufferAttachment(target, texture, renderbuffer) {
            this.target = target;
            this.texture = texture;
            this.renderbuffer = renderbuffer;
            var w = 0;
            var h = 0;
            if (texture) {
              w = texture.width;
              h = texture.height;
            } else if (renderbuffer) {
              w = renderbuffer.width;
              h = renderbuffer.height;
            }
            this.width = w;
            this.height = h;
          }
          function decRef(attachment) {
            if (attachment) {
              if (attachment.texture) {
                attachment.texture._texture.decRef();
              }
              if (attachment.renderbuffer) {
                attachment.renderbuffer._renderbuffer.decRef();
              }
            }
          }
          function incRefAndCheckShape(attachment, width, height) {
            if (!attachment) {
              return;
            }
            if (attachment.texture) {
              var texture = attachment.texture._texture;
              var tw = Math.max(1, texture.width);
              var th = Math.max(1, texture.height);
              texture.refCount += 1;
            } else {
              var renderbuffer = attachment.renderbuffer._renderbuffer;
              renderbuffer.refCount += 1;
            }
          }
          function attach(location, attachment) {
            if (attachment) {
              if (attachment.texture) {
                gl.framebufferTexture2D(
                  GL_FRAMEBUFFER$1,
                  location,
                  attachment.target,
                  attachment.texture._texture.texture,
                  0
                );
              } else {
                gl.framebufferRenderbuffer(
                  GL_FRAMEBUFFER$1,
                  location,
                  GL_RENDERBUFFER$1,
                  attachment.renderbuffer._renderbuffer.renderbuffer
                );
              }
            }
          }
          function parseAttachment(attachment) {
            var target = GL_TEXTURE_2D$2;
            var texture = null;
            var renderbuffer = null;
            var data = attachment;
            if (typeof attachment === "object") {
              data = attachment.data;
              if ("target" in attachment) {
                target = attachment.target | 0;
              }
            }
            var type = data._reglType;
            if (type === "texture2d") {
              texture = data;
            } else if (type === "textureCube") {
              texture = data;
            } else if (type === "renderbuffer") {
              renderbuffer = data;
              target = GL_RENDERBUFFER$1;
            } else {
            }
            return new FramebufferAttachment(target, texture, renderbuffer);
          }
          function allocAttachment(width, height, isTexture, format, type) {
            if (isTexture) {
              var texture = textureState.create2D({
                width,
                height,
                format,
                type
              });
              texture._texture.refCount = 0;
              return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null);
            } else {
              var rb = renderbufferState.create({
                width,
                height,
                format
              });
              rb._renderbuffer.refCount = 0;
              return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb);
            }
          }
          function unwrapAttachment(attachment) {
            return attachment && (attachment.texture || attachment.renderbuffer);
          }
          function resizeAttachment(attachment, w, h) {
            if (attachment) {
              if (attachment.texture) {
                attachment.texture.resize(w, h);
              } else if (attachment.renderbuffer) {
                attachment.renderbuffer.resize(w, h);
              }
              attachment.width = w;
              attachment.height = h;
            }
          }
          var framebufferCount = 0;
          var framebufferSet = {};
          function REGLFramebuffer() {
            this.id = framebufferCount++;
            framebufferSet[this.id] = this;
            this.framebuffer = gl.createFramebuffer();
            this.width = 0;
            this.height = 0;
            this.colorAttachments = [];
            this.depthAttachment = null;
            this.stencilAttachment = null;
            this.depthStencilAttachment = null;
          }
          function decFBORefs(framebuffer) {
            framebuffer.colorAttachments.forEach(decRef);
            decRef(framebuffer.depthAttachment);
            decRef(framebuffer.stencilAttachment);
            decRef(framebuffer.depthStencilAttachment);
          }
          function destroy(framebuffer) {
            var handle = framebuffer.framebuffer;
            gl.deleteFramebuffer(handle);
            framebuffer.framebuffer = null;
            stats2.framebufferCount--;
            delete framebufferSet[framebuffer.id];
          }
          function updateFramebuffer(framebuffer) {
            var i;
            gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer);
            var colorAttachments = framebuffer.colorAttachments;
            for (i = 0; i < colorAttachments.length; ++i) {
              attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i]);
            }
            for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
              gl.framebufferTexture2D(
                GL_FRAMEBUFFER$1,
                GL_COLOR_ATTACHMENT0$1 + i,
                GL_TEXTURE_2D$2,
                null,
                0
              );
            }
            gl.framebufferTexture2D(
              GL_FRAMEBUFFER$1,
              GL_DEPTH_STENCIL_ATTACHMENT,
              GL_TEXTURE_2D$2,
              null,
              0
            );
            gl.framebufferTexture2D(
              GL_FRAMEBUFFER$1,
              GL_DEPTH_ATTACHMENT,
              GL_TEXTURE_2D$2,
              null,
              0
            );
            gl.framebufferTexture2D(
              GL_FRAMEBUFFER$1,
              GL_STENCIL_ATTACHMENT,
              GL_TEXTURE_2D$2,
              null,
              0
            );
            attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);
            attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);
            attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment);
            var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1);
            if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
            }
            gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null);
            framebufferState.cur = framebufferState.next;
            gl.getError();
          }
          function createFBO(a0, a1) {
            var framebuffer = new REGLFramebuffer();
            stats2.framebufferCount++;
            function reglFramebuffer(a, b) {
              var i;
              var width = 0;
              var height = 0;
              var needsDepth = true;
              var needsStencil = true;
              var colorBuffer = null;
              var colorTexture = true;
              var colorFormat = "rgba";
              var colorType = "uint8";
              var colorCount = 1;
              var depthBuffer = null;
              var stencilBuffer = null;
              var depthStencilBuffer = null;
              var depthStencilTexture = false;
              if (typeof a === "number") {
                width = a | 0;
                height = b | 0 || width;
              } else if (!a) {
                width = height = 1;
              } else {
                var options = a;
                if ("shape" in options) {
                  var shape = options.shape;
                  width = shape[0];
                  height = shape[1];
                } else {
                  if ("radius" in options) {
                    width = height = options.radius;
                  }
                  if ("width" in options) {
                    width = options.width;
                  }
                  if ("height" in options) {
                    height = options.height;
                  }
                }
                if ("color" in options || "colors" in options) {
                  colorBuffer = options.color || options.colors;
                  if (Array.isArray(colorBuffer)) {
                  }
                }
                if (!colorBuffer) {
                  if ("colorCount" in options) {
                    colorCount = options.colorCount | 0;
                  }
                  if ("colorTexture" in options) {
                    colorTexture = !!options.colorTexture;
                    colorFormat = "rgba4";
                  }
                  if ("colorType" in options) {
                    colorType = options.colorType;
                    if (!colorTexture) {
                      if (colorType === "half float" || colorType === "float16") {
                        colorFormat = "rgba16f";
                      } else if (colorType === "float" || colorType === "float32") {
                        colorFormat = "rgba32f";
                      }
                    } else {
                    }
                  }
                  if ("colorFormat" in options) {
                    colorFormat = options.colorFormat;
                    if (colorTextureFormats.indexOf(colorFormat) >= 0) {
                      colorTexture = true;
                    } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
                      colorTexture = false;
                    } else {
                    }
                  }
                }
                if ("depthTexture" in options || "depthStencilTexture" in options) {
                  depthStencilTexture = !!(options.depthTexture || options.depthStencilTexture);
                }
                if ("depth" in options) {
                  if (typeof options.depth === "boolean") {
                    needsDepth = options.depth;
                  } else {
                    depthBuffer = options.depth;
                    needsStencil = false;
                  }
                }
                if ("stencil" in options) {
                  if (typeof options.stencil === "boolean") {
                    needsStencil = options.stencil;
                  } else {
                    stencilBuffer = options.stencil;
                    needsDepth = false;
                  }
                }
                if ("depthStencil" in options) {
                  if (typeof options.depthStencil === "boolean") {
                    needsDepth = needsStencil = options.depthStencil;
                  } else {
                    depthStencilBuffer = options.depthStencil;
                    needsDepth = false;
                    needsStencil = false;
                  }
                }
              }
              var colorAttachments = null;
              var depthAttachment = null;
              var stencilAttachment = null;
              var depthStencilAttachment = null;
              if (Array.isArray(colorBuffer)) {
                colorAttachments = colorBuffer.map(parseAttachment);
              } else if (colorBuffer) {
                colorAttachments = [parseAttachment(colorBuffer)];
              } else {
                colorAttachments = new Array(colorCount);
                for (i = 0; i < colorCount; ++i) {
                  colorAttachments[i] = allocAttachment(
                    width,
                    height,
                    colorTexture,
                    colorFormat,
                    colorType
                  );
                }
              }
              width = width || colorAttachments[0].width;
              height = height || colorAttachments[0].height;
              if (depthBuffer) {
                depthAttachment = parseAttachment(depthBuffer);
              } else if (needsDepth && !needsStencil) {
                depthAttachment = allocAttachment(
                  width,
                  height,
                  depthStencilTexture,
                  "depth",
                  "uint32"
                );
              }
              if (stencilBuffer) {
                stencilAttachment = parseAttachment(stencilBuffer);
              } else if (needsStencil && !needsDepth) {
                stencilAttachment = allocAttachment(
                  width,
                  height,
                  false,
                  "stencil",
                  "uint8"
                );
              }
              if (depthStencilBuffer) {
                depthStencilAttachment = parseAttachment(depthStencilBuffer);
              } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
                depthStencilAttachment = allocAttachment(
                  width,
                  height,
                  depthStencilTexture,
                  "depth stencil",
                  "depth stencil"
                );
              }
              var commonColorAttachmentSize = null;
              for (i = 0; i < colorAttachments.length; ++i) {
                incRefAndCheckShape(colorAttachments[i], width, height);
                if (colorAttachments[i] && colorAttachments[i].texture) {
                  var colorAttachmentSize = textureFormatChannels[colorAttachments[i].texture._texture.format] * textureTypeSizes[colorAttachments[i].texture._texture.type];
                  if (commonColorAttachmentSize === null) {
                    commonColorAttachmentSize = colorAttachmentSize;
                  } else {
                  }
                }
              }
              incRefAndCheckShape(depthAttachment, width, height);
              incRefAndCheckShape(stencilAttachment, width, height);
              incRefAndCheckShape(depthStencilAttachment, width, height);
              decFBORefs(framebuffer);
              framebuffer.width = width;
              framebuffer.height = height;
              framebuffer.colorAttachments = colorAttachments;
              framebuffer.depthAttachment = depthAttachment;
              framebuffer.stencilAttachment = stencilAttachment;
              framebuffer.depthStencilAttachment = depthStencilAttachment;
              reglFramebuffer.color = colorAttachments.map(unwrapAttachment);
              reglFramebuffer.depth = unwrapAttachment(depthAttachment);
              reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);
              reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);
              reglFramebuffer.width = framebuffer.width;
              reglFramebuffer.height = framebuffer.height;
              updateFramebuffer(framebuffer);
              return reglFramebuffer;
            }
            function resize(w_, h_) {
              var w = Math.max(w_ | 0, 1);
              var h = Math.max(h_ | 0 || w, 1);
              if (w === framebuffer.width && h === framebuffer.height) {
                return reglFramebuffer;
              }
              var colorAttachments = framebuffer.colorAttachments;
              for (var i = 0; i < colorAttachments.length; ++i) {
                resizeAttachment(colorAttachments[i], w, h);
              }
              resizeAttachment(framebuffer.depthAttachment, w, h);
              resizeAttachment(framebuffer.stencilAttachment, w, h);
              resizeAttachment(framebuffer.depthStencilAttachment, w, h);
              framebuffer.width = reglFramebuffer.width = w;
              framebuffer.height = reglFramebuffer.height = h;
              updateFramebuffer(framebuffer);
              return reglFramebuffer;
            }
            reglFramebuffer(a0, a1);
            return extend(reglFramebuffer, {
              resize,
              _reglType: "framebuffer",
              _framebuffer: framebuffer,
              destroy: function() {
                destroy(framebuffer);
                decFBORefs(framebuffer);
              },
              use: function(block) {
                framebufferState.setFBO({
                  framebuffer: reglFramebuffer
                }, block);
              }
            });
          }
          function createCubeFBO(options) {
            var faces = Array(6);
            function reglFramebufferCube(a) {
              var i;
              var params = {
                color: null
              };
              var radius = 0;
              var colorBuffer = null;
              var colorFormat = "rgba";
              var colorType = "uint8";
              var colorCount = 1;
              if (typeof a === "number") {
                radius = a | 0;
              } else if (!a) {
                radius = 1;
              } else {
                var options2 = a;
                if ("shape" in options2) {
                  var shape = options2.shape;
                  radius = shape[0];
                } else {
                  if ("radius" in options2) {
                    radius = options2.radius | 0;
                  }
                  if ("width" in options2) {
                    radius = options2.width | 0;
                    if ("height" in options2) {
                    }
                  } else if ("height" in options2) {
                    radius = options2.height | 0;
                  }
                }
                if ("color" in options2 || "colors" in options2) {
                  colorBuffer = options2.color || options2.colors;
                  if (Array.isArray(colorBuffer)) {
                  }
                }
                if (!colorBuffer) {
                  if ("colorCount" in options2) {
                    colorCount = options2.colorCount | 0;
                  }
                  if ("colorType" in options2) {
                    colorType = options2.colorType;
                  }
                  if ("colorFormat" in options2) {
                    colorFormat = options2.colorFormat;
                  }
                }
                if ("depth" in options2) {
                  params.depth = options2.depth;
                }
                if ("stencil" in options2) {
                  params.stencil = options2.stencil;
                }
                if ("depthStencil" in options2) {
                  params.depthStencil = options2.depthStencil;
                }
              }
              var colorCubes;
              if (colorBuffer) {
                if (Array.isArray(colorBuffer)) {
                  colorCubes = [];
                  for (i = 0; i < colorBuffer.length; ++i) {
                    colorCubes[i] = colorBuffer[i];
                  }
                } else {
                  colorCubes = [colorBuffer];
                }
              } else {
                colorCubes = Array(colorCount);
                var cubeMapParams = {
                  radius,
                  format: colorFormat,
                  type: colorType
                };
                for (i = 0; i < colorCount; ++i) {
                  colorCubes[i] = textureState.createCube(cubeMapParams);
                }
              }
              params.color = Array(colorCubes.length);
              for (i = 0; i < colorCubes.length; ++i) {
                var cube = colorCubes[i];
                radius = radius || cube.width;
                params.color[i] = {
                  target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
                  data: colorCubes[i]
                };
              }
              for (i = 0; i < 6; ++i) {
                for (var j = 0; j < colorCubes.length; ++j) {
                  params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i;
                }
                if (i > 0) {
                  params.depth = faces[0].depth;
                  params.stencil = faces[0].stencil;
                  params.depthStencil = faces[0].depthStencil;
                }
                if (faces[i]) {
                  faces[i](params);
                } else {
                  faces[i] = createFBO(params);
                }
              }
              return extend(reglFramebufferCube, {
                width: radius,
                height: radius,
                color: colorCubes
              });
            }
            function resize(radius_) {
              var i;
              var radius = radius_ | 0;
              if (radius === reglFramebufferCube.width) {
                return reglFramebufferCube;
              }
              var colors = reglFramebufferCube.color;
              for (i = 0; i < colors.length; ++i) {
                colors[i].resize(radius);
              }
              for (i = 0; i < 6; ++i) {
                faces[i].resize(radius);
              }
              reglFramebufferCube.width = reglFramebufferCube.height = radius;
              return reglFramebufferCube;
            }
            reglFramebufferCube(options);
            return extend(reglFramebufferCube, {
              faces,
              resize,
              _reglType: "framebufferCube",
              destroy: function() {
                faces.forEach(function(f) {
                  f.destroy();
                });
              }
            });
          }
          function restoreFramebuffers() {
            framebufferState.cur = null;
            framebufferState.next = null;
            framebufferState.dirty = true;
            values(framebufferSet).forEach(function(fb) {
              fb.framebuffer = gl.createFramebuffer();
              updateFramebuffer(fb);
            });
          }
          return extend(framebufferState, {
            getFramebuffer: function(object) {
              if (typeof object === "function" && object._reglType === "framebuffer") {
                var fbo = object._framebuffer;
                if (fbo instanceof REGLFramebuffer) {
                  return fbo;
                }
              }
              return null;
            },
            create: createFBO,
            createCube: createCubeFBO,
            clear: function() {
              values(framebufferSet).forEach(destroy);
            },
            restore: restoreFramebuffers
          });
        }
        var GL_FLOAT$5 = 5126;
        var GL_ARRAY_BUFFER$1 = 34962;
        var GL_ELEMENT_ARRAY_BUFFER$1 = 34963;
        function AttributeRecord() {
          this.state = 0;
          this.x = 0;
          this.y = 0;
          this.z = 0;
          this.w = 0;
          this.buffer = null;
          this.size = 0;
          this.normalized = false;
          this.type = GL_FLOAT$5;
          this.offset = 0;
          this.stride = 0;
          this.divisor = 0;
        }
        function wrapAttributeState(gl, extensions, limits, stats2, bufferState, elementState, drawState) {
          var NUM_ATTRIBUTES = limits.maxAttributes;
          var attributeBindings = new Array(NUM_ATTRIBUTES);
          for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
            attributeBindings[i] = new AttributeRecord();
          }
          var vaoCount = 0;
          var vaoSet = {};
          var state = {
            Record: AttributeRecord,
            scope: {},
            state: attributeBindings,
            currentVAO: null,
            targetVAO: null,
            restore: extVAO() ? restoreVAO : function() {
            },
            createVAO,
            getVAO,
            destroyBuffer,
            setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
            clear: extVAO() ? destroyVAOEXT : function() {
            }
          };
          function destroyBuffer(buffer) {
            for (var i2 = 0; i2 < attributeBindings.length; ++i2) {
              var record = attributeBindings[i2];
              if (record.buffer === buffer) {
                gl.disableVertexAttribArray(i2);
                record.buffer = null;
              }
            }
          }
          function extVAO() {
            return extensions.oes_vertex_array_object;
          }
          function extInstanced() {
            return extensions.angle_instanced_arrays;
          }
          function getVAO(vao) {
            if (typeof vao === "function" && vao._vao) {
              return vao._vao;
            }
            return null;
          }
          function setVAOEXT(vao) {
            if (vao === state.currentVAO) {
              return;
            }
            var ext = extVAO();
            if (vao) {
              ext.bindVertexArrayOES(vao.vao);
            } else {
              ext.bindVertexArrayOES(null);
            }
            state.currentVAO = vao;
          }
          function setVAOEmulated(vao) {
            if (vao === state.currentVAO) {
              return;
            }
            if (vao) {
              vao.bindAttrs();
            } else {
              var exti = extInstanced();
              for (var i2 = 0; i2 < attributeBindings.length; ++i2) {
                var binding = attributeBindings[i2];
                if (binding.buffer) {
                  gl.enableVertexAttribArray(i2);
                  binding.buffer.bind();
                  gl.vertexAttribPointer(i2, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset);
                  if (exti && binding.divisor) {
                    exti.vertexAttribDivisorANGLE(i2, binding.divisor);
                  }
                } else {
                  gl.disableVertexAttribArray(i2);
                  gl.vertexAttrib4f(i2, binding.x, binding.y, binding.z, binding.w);
                }
              }
              if (drawState.elements) {
                gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, drawState.elements.buffer.buffer);
              } else {
                gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null);
              }
            }
            state.currentVAO = vao;
          }
          function destroyVAOEXT() {
            values(vaoSet).forEach(function(vao) {
              vao.destroy();
            });
          }
          function REGLVAO() {
            this.id = ++vaoCount;
            this.attributes = [];
            this.elements = null;
            this.ownsElements = false;
            this.count = 0;
            this.offset = 0;
            this.instances = -1;
            this.primitive = 4;
            var extension = extVAO();
            if (extension) {
              this.vao = extension.createVertexArrayOES();
            } else {
              this.vao = null;
            }
            vaoSet[this.id] = this;
            this.buffers = [];
          }
          REGLVAO.prototype.bindAttrs = function() {
            var exti = extInstanced();
            var attributes = this.attributes;
            for (var i2 = 0; i2 < attributes.length; ++i2) {
              var attr = attributes[i2];
              if (attr.buffer) {
                gl.enableVertexAttribArray(i2);
                gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer);
                gl.vertexAttribPointer(i2, attr.size, attr.type, attr.normalized, attr.stride, attr.offset);
                if (exti && attr.divisor) {
                  exti.vertexAttribDivisorANGLE(i2, attr.divisor);
                }
              } else {
                gl.disableVertexAttribArray(i2);
                gl.vertexAttrib4f(i2, attr.x, attr.y, attr.z, attr.w);
              }
            }
            for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
              gl.disableVertexAttribArray(j);
            }
            var elements = elementState.getElements(this.elements);
            if (elements) {
              gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, elements.buffer.buffer);
            } else {
              gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null);
            }
          };
          REGLVAO.prototype.refresh = function() {
            var ext = extVAO();
            if (ext) {
              ext.bindVertexArrayOES(this.vao);
              this.bindAttrs();
              state.currentVAO = null;
              ext.bindVertexArrayOES(null);
            }
          };
          REGLVAO.prototype.destroy = function() {
            if (this.vao) {
              var extension = extVAO();
              if (this === state.currentVAO) {
                state.currentVAO = null;
                extension.bindVertexArrayOES(null);
              }
              extension.deleteVertexArrayOES(this.vao);
              this.vao = null;
            }
            if (this.ownsElements) {
              this.elements.destroy();
              this.elements = null;
              this.ownsElements = false;
            }
            if (vaoSet[this.id]) {
              delete vaoSet[this.id];
              stats2.vaoCount -= 1;
            }
          };
          function restoreVAO() {
            var ext = extVAO();
            if (ext) {
              values(vaoSet).forEach(function(vao) {
                vao.refresh();
              });
            }
          }
          function createVAO(_attr) {
            var vao = new REGLVAO();
            stats2.vaoCount += 1;
            function updateVAO(options) {
              var attributes;
              if (Array.isArray(options)) {
                attributes = options;
                if (vao.elements && vao.ownsElements) {
                  vao.elements.destroy();
                }
                vao.elements = null;
                vao.ownsElements = false;
                vao.offset = 0;
                vao.count = 0;
                vao.instances = -1;
                vao.primitive = 4;
              } else {
                if (options.elements) {
                  var elements = options.elements;
                  if (vao.ownsElements) {
                    if (typeof elements === "function" && elements._reglType === "elements") {
                      vao.elements.destroy();
                      vao.ownsElements = false;
                    } else {
                      vao.elements(elements);
                      vao.ownsElements = false;
                    }
                  } else if (elementState.getElements(options.elements)) {
                    vao.elements = options.elements;
                    vao.ownsElements = false;
                  } else {
                    vao.elements = elementState.create(options.elements);
                    vao.ownsElements = true;
                  }
                } else {
                  vao.elements = null;
                  vao.ownsElements = false;
                }
                attributes = options.attributes;
                vao.offset = 0;
                vao.count = -1;
                vao.instances = -1;
                vao.primitive = 4;
                if (vao.elements) {
                  vao.count = vao.elements._elements.vertCount;
                  vao.primitive = vao.elements._elements.primType;
                }
                if ("offset" in options) {
                  vao.offset = options.offset | 0;
                }
                if ("count" in options) {
                  vao.count = options.count | 0;
                }
                if ("instances" in options) {
                  vao.instances = options.instances | 0;
                }
                if ("primitive" in options) {
                  vao.primitive = primTypes[options.primitive];
                }
              }
              var bufUpdated = {};
              var nattributes = vao.attributes;
              nattributes.length = attributes.length;
              for (var i2 = 0; i2 < attributes.length; ++i2) {
                var spec = attributes[i2];
                var rec = nattributes[i2] = new AttributeRecord();
                var data = spec.data || spec;
                if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
                  var buf;
                  if (vao.buffers[i2]) {
                    buf = vao.buffers[i2];
                    if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
                      buf.subdata(data);
                    } else {
                      buf.destroy();
                      vao.buffers[i2] = null;
                    }
                  }
                  if (!vao.buffers[i2]) {
                    buf = vao.buffers[i2] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true);
                  }
                  rec.buffer = bufferState.getBuffer(buf);
                  rec.size = rec.buffer.dimension | 0;
                  rec.normalized = false;
                  rec.type = rec.buffer.dtype;
                  rec.offset = 0;
                  rec.stride = 0;
                  rec.divisor = 0;
                  rec.state = 1;
                  bufUpdated[i2] = 1;
                } else if (bufferState.getBuffer(spec)) {
                  rec.buffer = bufferState.getBuffer(spec);
                  rec.size = rec.buffer.dimension | 0;
                  rec.normalized = false;
                  rec.type = rec.buffer.dtype;
                  rec.offset = 0;
                  rec.stride = 0;
                  rec.divisor = 0;
                  rec.state = 1;
                } else if (bufferState.getBuffer(spec.buffer)) {
                  rec.buffer = bufferState.getBuffer(spec.buffer);
                  rec.size = (+spec.size || rec.buffer.dimension) | 0;
                  rec.normalized = !!spec.normalized || false;
                  if ("type" in spec) {
                    rec.type = glTypes[spec.type];
                  } else {
                    rec.type = rec.buffer.dtype;
                  }
                  rec.offset = (spec.offset || 0) | 0;
                  rec.stride = (spec.stride || 0) | 0;
                  rec.divisor = (spec.divisor || 0) | 0;
                  rec.state = 1;
                } else if ("x" in spec) {
                  rec.x = +spec.x || 0;
                  rec.y = +spec.y || 0;
                  rec.z = +spec.z || 0;
                  rec.w = +spec.w || 0;
                  rec.state = 2;
                } else {
                }
              }
              for (var j = 0; j < vao.buffers.length; ++j) {
                if (!bufUpdated[j] && vao.buffers[j]) {
                  vao.buffers[j].destroy();
                  vao.buffers[j] = null;
                }
              }
              vao.refresh();
              return updateVAO;
            }
            updateVAO.destroy = function() {
              for (var j = 0; j < vao.buffers.length; ++j) {
                if (vao.buffers[j]) {
                  vao.buffers[j].destroy();
                }
              }
              vao.buffers.length = 0;
              if (vao.ownsElements) {
                vao.elements.destroy();
                vao.elements = null;
                vao.ownsElements = false;
              }
              vao.destroy();
            };
            updateVAO._vao = vao;
            updateVAO._reglType = "vao";
            return updateVAO(_attr);
          }
          return state;
        }
        var GL_FRAGMENT_SHADER = 35632;
        var GL_VERTEX_SHADER = 35633;
        var GL_ACTIVE_UNIFORMS = 35718;
        var GL_ACTIVE_ATTRIBUTES = 35721;
        function wrapShaderState(gl, stringStore, stats2, config) {
          var fragShaders = {};
          var vertShaders = {};
          function ActiveInfo(name, id, location, info) {
            this.name = name;
            this.id = id;
            this.location = location;
            this.info = info;
          }
          function insertActiveInfo(list, info) {
            for (var i = 0; i < list.length; ++i) {
              if (list[i].id === info.id) {
                list[i].location = info.location;
                return;
              }
            }
            list.push(info);
          }
          function getShader(type, id, command) {
            var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;
            var shader = cache[id];
            if (!shader) {
              var source = stringStore.str(id);
              shader = gl.createShader(type);
              gl.shaderSource(shader, source);
              gl.compileShader(shader);
              cache[id] = shader;
            }
            return shader;
          }
          var programCache = {};
          var programList = [];
          var PROGRAM_COUNTER = 0;
          function REGLProgram(fragId, vertId) {
            this.id = PROGRAM_COUNTER++;
            this.fragId = fragId;
            this.vertId = vertId;
            this.program = null;
            this.uniforms = [];
            this.attributes = [];
            this.refCount = 1;
            if (config.profile) {
              this.stats = {
                uniformsCount: 0,
                attributesCount: 0
              };
            }
          }
          function linkProgram(desc, command, attributeLocations) {
            var i, info;
            var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);
            var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);
            var program = desc.program = gl.createProgram();
            gl.attachShader(program, fragShader);
            gl.attachShader(program, vertShader);
            if (attributeLocations) {
              for (i = 0; i < attributeLocations.length; ++i) {
                var binding = attributeLocations[i];
                gl.bindAttribLocation(program, binding[0], binding[1]);
              }
            }
            gl.linkProgram(program);
            var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS);
            if (config.profile) {
              desc.stats.uniformsCount = numUniforms;
            }
            var uniforms = desc.uniforms;
            for (i = 0; i < numUniforms; ++i) {
              info = gl.getActiveUniform(program, i);
              if (info) {
                if (info.size > 1) {
                  for (var j = 0; j < info.size; ++j) {
                    var name = info.name.replace("[0]", "[" + j + "]");
                    insertActiveInfo(uniforms, new ActiveInfo(
                      name,
                      stringStore.id(name),
                      gl.getUniformLocation(program, name),
                      info
                    ));
                  }
                } else {
                  insertActiveInfo(uniforms, new ActiveInfo(
                    info.name,
                    stringStore.id(info.name),
                    gl.getUniformLocation(program, info.name),
                    info
                  ));
                }
              }
            }
            var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);
            if (config.profile) {
              desc.stats.attributesCount = numAttributes;
            }
            var attributes = desc.attributes;
            for (i = 0; i < numAttributes; ++i) {
              info = gl.getActiveAttrib(program, i);
              if (info) {
                insertActiveInfo(attributes, new ActiveInfo(
                  info.name,
                  stringStore.id(info.name),
                  gl.getAttribLocation(program, info.name),
                  info
                ));
              }
            }
          }
          if (config.profile) {
            stats2.getMaxUniformsCount = function() {
              var m = 0;
              programList.forEach(function(desc) {
                if (desc.stats.uniformsCount > m) {
                  m = desc.stats.uniformsCount;
                }
              });
              return m;
            };
            stats2.getMaxAttributesCount = function() {
              var m = 0;
              programList.forEach(function(desc) {
                if (desc.stats.attributesCount > m) {
                  m = desc.stats.attributesCount;
                }
              });
              return m;
            };
          }
          function restoreShaders() {
            fragShaders = {};
            vertShaders = {};
            for (var i = 0; i < programList.length; ++i) {
              linkProgram(programList[i], null, programList[i].attributes.map(function(info) {
                return [info.location, info.name];
              }));
            }
          }
          return {
            clear: function() {
              var deleteShader = gl.deleteShader.bind(gl);
              values(fragShaders).forEach(deleteShader);
              fragShaders = {};
              values(vertShaders).forEach(deleteShader);
              vertShaders = {};
              programList.forEach(function(desc) {
                gl.deleteProgram(desc.program);
              });
              programList.length = 0;
              programCache = {};
              stats2.shaderCount = 0;
            },
            program: function(vertId, fragId, command, attribLocations) {
              var cache = programCache[fragId];
              if (!cache) {
                cache = programCache[fragId] = {};
              }
              var prevProgram = cache[vertId];
              if (prevProgram) {
                prevProgram.refCount++;
                if (!attribLocations) {
                  return prevProgram;
                }
              }
              var program = new REGLProgram(fragId, vertId);
              stats2.shaderCount++;
              linkProgram(program, command, attribLocations);
              if (!prevProgram) {
                cache[vertId] = program;
              }
              programList.push(program);
              return extend(program, {
                destroy: function() {
                  program.refCount--;
                  if (program.refCount <= 0) {
                    gl.deleteProgram(program.program);
                    var idx = programList.indexOf(program);
                    programList.splice(idx, 1);
                    stats2.shaderCount--;
                  }
                  if (cache[program.vertId].refCount <= 0) {
                    gl.deleteShader(vertShaders[program.vertId]);
                    delete vertShaders[program.vertId];
                    delete programCache[program.fragId][program.vertId];
                  }
                  if (!Object.keys(programCache[program.fragId]).length) {
                    gl.deleteShader(fragShaders[program.fragId]);
                    delete fragShaders[program.fragId];
                    delete programCache[program.fragId];
                  }
                }
              });
            },
            restore: restoreShaders,
            shader: getShader,
            frag: -1,
            vert: -1
          };
        }
        var GL_RGBA$3 = 6408;
        var GL_UNSIGNED_BYTE$6 = 5121;
        var GL_PACK_ALIGNMENT = 3333;
        var GL_FLOAT$6 = 5126;
        function wrapReadPixels(gl, framebufferState, reglPoll, context, glAttributes, extensions, limits) {
          function readPixelsImpl(input) {
            var type;
            if (framebufferState.next === null) {
              type = GL_UNSIGNED_BYTE$6;
            } else {
              type = framebufferState.next.colorAttachments[0].texture._texture.type;
            }
            var x = 0;
            var y = 0;
            var width = context.framebufferWidth;
            var height = context.framebufferHeight;
            var data = null;
            if (isTypedArray(input)) {
              data = input;
            } else if (input) {
              x = input.x | 0;
              y = input.y | 0;
              width = (input.width || context.framebufferWidth - x) | 0;
              height = (input.height || context.framebufferHeight - y) | 0;
              data = input.data || null;
            }
            if (data) {
              if (type === GL_UNSIGNED_BYTE$6) {
              } else if (type === GL_FLOAT$6) {
              }
            }
            reglPoll();
            var size = width * height * 4;
            if (!data) {
              if (type === GL_UNSIGNED_BYTE$6) {
                data = new Uint8Array(size);
              } else if (type === GL_FLOAT$6) {
                data = data || new Float32Array(size);
              }
            }
            gl.pixelStorei(GL_PACK_ALIGNMENT, 4);
            gl.readPixels(
              x,
              y,
              width,
              height,
              GL_RGBA$3,
              type,
              data
            );
            return data;
          }
          function readPixelsFBO(options) {
            var result;
            framebufferState.setFBO({
              framebuffer: options.framebuffer
            }, function() {
              result = readPixelsImpl(options);
            });
            return result;
          }
          function readPixels(options) {
            if (!options || !("framebuffer" in options)) {
              return readPixelsImpl(options);
            } else {
              return readPixelsFBO(options);
            }
          }
          return readPixels;
        }
        var hexcase = 0;
        var b64pad = "";
        function hex_sha256(s) {
          return rstr2hex(rstr_sha256(str2rstr_utf8(s)));
        }
        function rstr_sha256(s) {
          return binb2rstr(binb_sha256(rstr2binb(s), s.length * 8));
        }
        function rstr_hmac_sha256(key, data) {
          var bkey = rstr2binb(key);
          if (bkey.length > 16) bkey = binb_sha256(bkey, key.length * 8);
          var ipad = Array(16), opad = Array(16);
          for (var i = 0; i < 16; i++) {
            ipad[i] = bkey[i] ^ 909522486;
            opad[i] = bkey[i] ^ 1549556828;
          }
          var hash = binb_sha256(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
          return binb2rstr(binb_sha256(opad.concat(hash), 512 + 256));
        }
        function rstr2hex(input) {
          var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
          var output = "";
          var x;
          for (var i = 0; i < input.length; i++) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt(x >>> 4 & 15) + hex_tab.charAt(x & 15);
          }
          return output;
        }
        function rstr2b64(input) {
          var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          var output = "";
          var len = input.length;
          for (var i = 0; i < len; i += 3) {
            var triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
            for (var j = 0; j < 4; j++) {
              if (i * 8 + j * 6 > input.length * 8) output += b64pad;
              else output += tab.charAt(triplet >>> 6 * (3 - j) & 63);
            }
          }
          return output;
        }
        function rstr2any(input, encoding) {
          var divisor = encoding.length;
          var remainders = Array();
          var i, q, x, quotient;
          var dividend = Array(Math.ceil(input.length / 2));
          for (i = 0; i < dividend.length; i++) {
            dividend[i] = input.charCodeAt(i * 2) << 8 | input.charCodeAt(i * 2 + 1);
          }
          while (dividend.length > 0) {
            quotient = Array();
            x = 0;
            for (i = 0; i < dividend.length; i++) {
              x = (x << 16) + dividend[i];
              q = Math.floor(x / divisor);
              x -= q * divisor;
              if (quotient.length > 0 || q > 0)
                quotient[quotient.length] = q;
            }
            remainders[remainders.length] = x;
            dividend = quotient;
          }
          var output = "";
          for (i = remainders.length - 1; i >= 0; i--)
            output += encoding.charAt(remainders[i]);
          var full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
          for (i = output.length; i < full_length; i++)
            output = encoding[0] + output;
          return output;
        }
        function str2rstr_utf8(input) {
          var output = "";
          var i = -1;
          var x, y;
          while (++i < input.length) {
            x = input.charCodeAt(i);
            y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
            if (55296 <= x && x <= 56319 && 56320 <= y && y <= 57343) {
              x = 65536 + ((x & 1023) << 10) + (y & 1023);
              i++;
            }
            if (x <= 127)
              output += String.fromCharCode(x);
            else if (x <= 2047)
              output += String.fromCharCode(
                192 | x >>> 6 & 31,
                128 | x & 63
              );
            else if (x <= 65535)
              output += String.fromCharCode(
                224 | x >>> 12 & 15,
                128 | x >>> 6 & 63,
                128 | x & 63
              );
            else if (x <= 2097151)
              output += String.fromCharCode(
                240 | x >>> 18 & 7,
                128 | x >>> 12 & 63,
                128 | x >>> 6 & 63,
                128 | x & 63
              );
          }
          return output;
        }
        function rstr2binb(input) {
          var output = Array(input.length >> 2);
          for (var i = 0; i < output.length; i++)
            output[i] = 0;
          for (var i = 0; i < input.length * 8; i += 8)
            output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << 24 - i % 32;
          return output;
        }
        function binb2rstr(input) {
          var output = "";
          for (var i = 0; i < input.length * 32; i += 8)
            output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 255);
          return output;
        }
        function sha256_S(X, n) {
          return X >>> n | X << 32 - n;
        }
        function sha256_R(X, n) {
          return X >>> n;
        }
        function sha256_Ch(x, y, z) {
          return x & y ^ ~x & z;
        }
        function sha256_Maj(x, y, z) {
          return x & y ^ x & z ^ y & z;
        }
        function sha256_Sigma0256(x) {
          return sha256_S(x, 2) ^ sha256_S(x, 13) ^ sha256_S(x, 22);
        }
        function sha256_Sigma1256(x) {
          return sha256_S(x, 6) ^ sha256_S(x, 11) ^ sha256_S(x, 25);
        }
        function sha256_Gamma0256(x) {
          return sha256_S(x, 7) ^ sha256_S(x, 18) ^ sha256_R(x, 3);
        }
        function sha256_Gamma1256(x) {
          return sha256_S(x, 17) ^ sha256_S(x, 19) ^ sha256_R(x, 10);
        }
        var sha256_K = new Array(
          1116352408,
          1899447441,
          -1245643825,
          -373957723,
          961987163,
          1508970993,
          -1841331548,
          -1424204075,
          -670586216,
          310598401,
          607225278,
          1426881987,
          1925078388,
          -2132889090,
          -1680079193,
          -1046744716,
          -459576895,
          -272742522,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          -1740746414,
          -1473132947,
          -1341970488,
          -1084653625,
          -958395405,
          -710438585,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          -2117940946,
          -1838011259,
          -1564481375,
          -1474664885,
          -1035236496,
          -949202525,
          -778901479,
          -694614492,
          -200395387,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          -2067236844,
          -1933114872,
          -1866530822,
          -1538233109,
          -1090935817,
          -965641998
        );
        function binb_sha256(m, l) {
          var HASH = new Array(
            1779033703,
            -1150833019,
            1013904242,
            -1521486534,
            1359893119,
            -1694144372,
            528734635,
            1541459225
          );
          var W = new Array(64);
          var a, b, c, d, e, f, g, h;
          var i, j, T1, T2;
          m[l >> 5] |= 128 << 24 - l % 32;
          m[(l + 64 >> 9 << 4) + 15] = l;
          for (i = 0; i < m.length; i += 16) {
            a = HASH[0];
            b = HASH[1];
            c = HASH[2];
            d = HASH[3];
            e = HASH[4];
            f = HASH[5];
            g = HASH[6];
            h = HASH[7];
            for (j = 0; j < 64; j++) {
              if (j < 16) W[j] = m[j + i];
              else W[j] = safe_add(safe_add(
                safe_add(sha256_Gamma1256(W[j - 2]), W[j - 7]),
                sha256_Gamma0256(W[j - 15])
              ), W[j - 16]);
              T1 = safe_add(safe_add(
                safe_add(safe_add(h, sha256_Sigma1256(e)), sha256_Ch(e, f, g)),
                sha256_K[j]
              ), W[j]);
              T2 = safe_add(sha256_Sigma0256(a), sha256_Maj(a, b, c));
              h = g;
              g = f;
              f = e;
              e = safe_add(d, T1);
              d = c;
              c = b;
              b = a;
              a = safe_add(T1, T2);
            }
            HASH[0] = safe_add(a, HASH[0]);
            HASH[1] = safe_add(b, HASH[1]);
            HASH[2] = safe_add(c, HASH[2]);
            HASH[3] = safe_add(d, HASH[3]);
            HASH[4] = safe_add(e, HASH[4]);
            HASH[5] = safe_add(f, HASH[5]);
            HASH[6] = safe_add(g, HASH[6]);
            HASH[7] = safe_add(h, HASH[7]);
          }
          return HASH;
        }
        function safe_add(x, y) {
          var lsw = (x & 65535) + (y & 65535);
          var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        }
        function slice(x) {
          return Array.prototype.slice.call(x);
        }
        function join(x) {
          return slice(x).join("");
        }
        function createEnvironment(options) {
          var cache = options && options.cache;
          var varCounter = 0;
          var linkedNames = [];
          var linkedValues = [];
          var isStable = [];
          function link(value, options2) {
            var stable = options2 && options2.stable;
            if (!stable) {
              for (var i = 0; i < linkedValues.length; ++i) {
                if (linkedValues[i] === value && !isStable[i]) {
                  return linkedNames[i];
                }
              }
            }
            var name = "g" + varCounter++;
            linkedNames.push(name);
            linkedValues.push(value);
            isStable.push(stable);
            return name;
          }
          function block() {
            var code = [];
            function push() {
              code.push.apply(code, slice(arguments));
            }
            var vars = [];
            function def() {
              var name = "v" + varCounter++;
              vars.push(name);
              if (arguments.length > 0) {
                code.push(name, "=");
                code.push.apply(code, slice(arguments));
                code.push(";");
              }
              return name;
            }
            return extend(push, {
              def,
              toString: function() {
                return join([
                  vars.length > 0 ? "var " + vars.join(",") + ";" : "",
                  join(code)
                ]);
              }
            });
          }
          function scope() {
            var entry = block();
            var exit = block();
            var entryToString = entry.toString;
            var exitToString = exit.toString;
            function save(object, prop) {
              exit(object, prop, "=", entry.def(object, prop), ";");
            }
            return extend(function() {
              entry.apply(entry, slice(arguments));
            }, {
              def: entry.def,
              entry,
              exit,
              save,
              set: function(object, prop, value) {
                save(object, prop);
                entry(object, prop, "=", value, ";");
              },
              toString: function() {
                return entryToString() + exitToString();
              }
            });
          }
          function conditional() {
            var pred = join(arguments);
            var thenBlock = scope();
            var elseBlock = scope();
            var thenToString = thenBlock.toString;
            var elseToString = elseBlock.toString;
            return extend(thenBlock, {
              then: function() {
                thenBlock.apply(thenBlock, slice(arguments));
                return this;
              },
              else: function() {
                elseBlock.apply(elseBlock, slice(arguments));
                return this;
              },
              toString: function() {
                var elseClause = elseToString();
                if (elseClause) {
                  elseClause = "else{" + elseClause + "}";
                }
                return join([
                  "if(",
                  pred,
                  "){",
                  thenToString(),
                  "}",
                  elseClause
                ]);
              }
            });
          }
          var globalBlock = block();
          var procedures = {};
          function proc(name, count) {
            var args = [];
            function arg() {
              var name2 = "a" + args.length;
              args.push(name2);
              return name2;
            }
            count = count || 0;
            for (var i = 0; i < count; ++i) {
              arg();
            }
            var body = scope();
            var bodyToString = body.toString;
            var result = procedures[name] = extend(body, {
              arg,
              toString: function() {
                return join([
                  "function(",
                  args.join(),
                  "){",
                  bodyToString(),
                  "}"
                ]);
              }
            });
            return result;
          }
          function compile() {
            var code = [
              '"use strict";',
              globalBlock,
              "return {"
            ];
            Object.keys(procedures).forEach(function(name) {
              code.push('"', name, '":', procedures[name].toString(), ",");
            });
            code.push("}");
            var src = join(code).replace(/;/g, ";\n").replace(/}/g, "}\n").replace(/{/g, "{\n");
            var key;
            if (cache) {
              key = hex_sha256(src);
              if (cache[key]) {
                return cache[key].apply(null, linkedValues);
              }
            }
            var proc2 = Function.apply(null, linkedNames.concat(src));
            if (cache) {
              cache[key] = proc2;
            }
            return proc2.apply(null, linkedValues);
          }
          return {
            global: globalBlock,
            link,
            block,
            proc,
            scope,
            cond: conditional,
            compile
          };
        }
        var CUTE_COMPONENTS = "xyzw".split("");
        var GL_UNSIGNED_BYTE$7 = 5121;
        var ATTRIB_STATE_POINTER = 1;
        var ATTRIB_STATE_CONSTANT = 2;
        var DYN_FUNC$1 = 0;
        var DYN_PROP$1 = 1;
        var DYN_CONTEXT$1 = 2;
        var DYN_STATE$1 = 3;
        var DYN_THUNK = 4;
        var DYN_CONSTANT$1 = 5;
        var DYN_ARRAY$1 = 6;
        var S_DITHER = "dither";
        var S_BLEND_ENABLE = "blend.enable";
        var S_BLEND_COLOR = "blend.color";
        var S_BLEND_EQUATION = "blend.equation";
        var S_BLEND_FUNC = "blend.func";
        var S_DEPTH_ENABLE = "depth.enable";
        var S_DEPTH_FUNC = "depth.func";
        var S_DEPTH_RANGE = "depth.range";
        var S_DEPTH_MASK = "depth.mask";
        var S_COLOR_MASK = "colorMask";
        var S_CULL_ENABLE = "cull.enable";
        var S_CULL_FACE = "cull.face";
        var S_FRONT_FACE = "frontFace";
        var S_LINE_WIDTH = "lineWidth";
        var S_POLYGON_OFFSET_ENABLE = "polygonOffset.enable";
        var S_POLYGON_OFFSET_OFFSET = "polygonOffset.offset";
        var S_SAMPLE_ALPHA = "sample.alpha";
        var S_SAMPLE_ENABLE = "sample.enable";
        var S_SAMPLE_COVERAGE = "sample.coverage";
        var S_STENCIL_ENABLE = "stencil.enable";
        var S_STENCIL_MASK = "stencil.mask";
        var S_STENCIL_FUNC = "stencil.func";
        var S_STENCIL_OPFRONT = "stencil.opFront";
        var S_STENCIL_OPBACK = "stencil.opBack";
        var S_SCISSOR_ENABLE = "scissor.enable";
        var S_SCISSOR_BOX = "scissor.box";
        var S_VIEWPORT = "viewport";
        var S_PROFILE = "profile";
        var S_FRAMEBUFFER = "framebuffer";
        var S_VERT = "vert";
        var S_FRAG = "frag";
        var S_ELEMENTS = "elements";
        var S_PRIMITIVE = "primitive";
        var S_COUNT = "count";
        var S_OFFSET = "offset";
        var S_INSTANCES = "instances";
        var S_VAO = "vao";
        var SUFFIX_WIDTH = "Width";
        var SUFFIX_HEIGHT = "Height";
        var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;
        var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;
        var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;
        var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;
        var S_DRAWINGBUFFER = "drawingBuffer";
        var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;
        var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;
        var NESTED_OPTIONS = [
          S_BLEND_FUNC,
          S_BLEND_EQUATION,
          S_STENCIL_FUNC,
          S_STENCIL_OPFRONT,
          S_STENCIL_OPBACK,
          S_SAMPLE_COVERAGE,
          S_VIEWPORT,
          S_SCISSOR_BOX,
          S_POLYGON_OFFSET_OFFSET
        ];
        var GL_ARRAY_BUFFER$2 = 34962;
        var GL_ELEMENT_ARRAY_BUFFER$2 = 34963;
        var GL_CULL_FACE = 2884;
        var GL_BLEND = 3042;
        var GL_DITHER = 3024;
        var GL_STENCIL_TEST = 2960;
        var GL_DEPTH_TEST = 2929;
        var GL_SCISSOR_TEST = 3089;
        var GL_POLYGON_OFFSET_FILL = 32823;
        var GL_SAMPLE_ALPHA_TO_COVERAGE = 32926;
        var GL_SAMPLE_COVERAGE = 32928;
        var GL_FLOAT$7 = 5126;
        var GL_FLOAT_VEC2 = 35664;
        var GL_FLOAT_VEC3 = 35665;
        var GL_FLOAT_VEC4 = 35666;
        var GL_INT$2 = 5124;
        var GL_INT_VEC2 = 35667;
        var GL_INT_VEC3 = 35668;
        var GL_INT_VEC4 = 35669;
        var GL_BOOL = 35670;
        var GL_BOOL_VEC2 = 35671;
        var GL_BOOL_VEC3 = 35672;
        var GL_BOOL_VEC4 = 35673;
        var GL_FLOAT_MAT2 = 35674;
        var GL_FLOAT_MAT3 = 35675;
        var GL_FLOAT_MAT4 = 35676;
        var GL_SAMPLER_2D = 35678;
        var GL_SAMPLER_CUBE = 35680;
        var GL_TRIANGLES$1 = 4;
        var GL_FRONT = 1028;
        var GL_BACK = 1029;
        var GL_CW = 2304;
        var GL_CCW = 2305;
        var GL_MIN_EXT = 32775;
        var GL_MAX_EXT = 32776;
        var GL_ALWAYS = 519;
        var GL_KEEP = 7680;
        var GL_ZERO = 0;
        var GL_ONE = 1;
        var GL_FUNC_ADD = 32774;
        var GL_LESS = 513;
        var GL_FRAMEBUFFER$2 = 36160;
        var GL_COLOR_ATTACHMENT0$2 = 36064;
        var blendFuncs = {
          "0": 0,
          "1": 1,
          "zero": 0,
          "one": 1,
          "src color": 768,
          "one minus src color": 769,
          "src alpha": 770,
          "one minus src alpha": 771,
          "dst color": 774,
          "one minus dst color": 775,
          "dst alpha": 772,
          "one minus dst alpha": 773,
          "constant color": 32769,
          "one minus constant color": 32770,
          "constant alpha": 32771,
          "one minus constant alpha": 32772,
          "src alpha saturate": 776
        };
        var compareFuncs = {
          "never": 512,
          "less": 513,
          "<": 513,
          "equal": 514,
          "=": 514,
          "==": 514,
          "===": 514,
          "lequal": 515,
          "<=": 515,
          "greater": 516,
          ">": 516,
          "notequal": 517,
          "!=": 517,
          "!==": 517,
          "gequal": 518,
          ">=": 518,
          "always": 519
        };
        var stencilOps = {
          "0": 0,
          "zero": 0,
          "keep": 7680,
          "replace": 7681,
          "increment": 7682,
          "decrement": 7683,
          "increment wrap": 34055,
          "decrement wrap": 34056,
          "invert": 5386
        };
        var orientationType = {
          "cw": GL_CW,
          "ccw": GL_CCW
        };
        function isBufferArgs(x) {
          return Array.isArray(x) || isTypedArray(x) || isNDArrayLike(x);
        }
        function sortState(state) {
          return state.sort(function(a, b) {
            if (a === S_VIEWPORT) {
              return -1;
            } else if (b === S_VIEWPORT) {
              return 1;
            }
            return a < b ? -1 : 1;
          });
        }
        function Declaration(thisDep, contextDep, propDep, append) {
          this.thisDep = thisDep;
          this.contextDep = contextDep;
          this.propDep = propDep;
          this.append = append;
        }
        function isStatic(decl) {
          return decl && !(decl.thisDep || decl.contextDep || decl.propDep);
        }
        function createStaticDecl(append) {
          return new Declaration(false, false, false, append);
        }
        function createDynamicDecl(dyn, append) {
          var type = dyn.type;
          if (type === DYN_FUNC$1) {
            var numArgs = dyn.data.length;
            return new Declaration(
              true,
              numArgs >= 1,
              numArgs >= 2,
              append
            );
          } else if (type === DYN_THUNK) {
            var data = dyn.data;
            return new Declaration(
              data.thisDep,
              data.contextDep,
              data.propDep,
              append
            );
          } else if (type === DYN_CONSTANT$1) {
            return new Declaration(
              false,
              false,
              false,
              append
            );
          } else if (type === DYN_ARRAY$1) {
            var thisDep = false;
            var contextDep = false;
            var propDep = false;
            for (var i = 0; i < dyn.data.length; ++i) {
              var subDyn = dyn.data[i];
              if (subDyn.type === DYN_PROP$1) {
                propDep = true;
              } else if (subDyn.type === DYN_CONTEXT$1) {
                contextDep = true;
              } else if (subDyn.type === DYN_STATE$1) {
                thisDep = true;
              } else if (subDyn.type === DYN_FUNC$1) {
                thisDep = true;
                var subArgs = subDyn.data;
                if (subArgs >= 1) {
                  contextDep = true;
                }
                if (subArgs >= 2) {
                  propDep = true;
                }
              } else if (subDyn.type === DYN_THUNK) {
                thisDep = thisDep || subDyn.data.thisDep;
                contextDep = contextDep || subDyn.data.contextDep;
                propDep = propDep || subDyn.data.propDep;
              }
            }
            return new Declaration(
              thisDep,
              contextDep,
              propDep,
              append
            );
          } else {
            return new Declaration(
              type === DYN_STATE$1,
              type === DYN_CONTEXT$1,
              type === DYN_PROP$1,
              append
            );
          }
        }
        var SCOPE_DECL = new Declaration(false, false, false, function() {
        });
        function reglCore(gl, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer, cachedCode, config) {
          var AttributeRecord2 = attributeState.Record;
          var blendEquations = {
            "add": 32774,
            "subtract": 32778,
            "reverse subtract": 32779
          };
          if (extensions.ext_blend_minmax) {
            blendEquations.min = GL_MIN_EXT;
            blendEquations.max = GL_MAX_EXT;
          }
          var extInstancing = extensions.angle_instanced_arrays;
          var extDrawBuffers = extensions.webgl_draw_buffers;
          var extVertexArrays = extensions.oes_vertex_array_object;
          var currentState = {
            dirty: true,
            profile: config.profile
          };
          var nextState = {};
          var GL_STATE_NAMES = [];
          var GL_FLAGS = {};
          var GL_VARIABLES = {};
          function propName(name) {
            return name.replace(".", "_");
          }
          function stateFlag(sname, cap, init) {
            var name = propName(sname);
            GL_STATE_NAMES.push(sname);
            nextState[name] = currentState[name] = !!init;
            GL_FLAGS[name] = cap;
          }
          function stateVariable(sname, func, init) {
            var name = propName(sname);
            GL_STATE_NAMES.push(sname);
            if (Array.isArray(init)) {
              currentState[name] = init.slice();
              nextState[name] = init.slice();
            } else {
              currentState[name] = nextState[name] = init;
            }
            GL_VARIABLES[name] = func;
          }
          function hasVariableReference(exp) {
            if (!isNaN(exp)) {
              return false;
            }
            return true;
          }
          stateFlag(S_DITHER, GL_DITHER);
          stateFlag(S_BLEND_ENABLE, GL_BLEND);
          stateVariable(S_BLEND_COLOR, "blendColor", [0, 0, 0, 0]);
          stateVariable(
            S_BLEND_EQUATION,
            "blendEquationSeparate",
            [GL_FUNC_ADD, GL_FUNC_ADD]
          );
          stateVariable(
            S_BLEND_FUNC,
            "blendFuncSeparate",
            [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]
          );
          stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);
          stateVariable(S_DEPTH_FUNC, "depthFunc", GL_LESS);
          stateVariable(S_DEPTH_RANGE, "depthRange", [0, 1]);
          stateVariable(S_DEPTH_MASK, "depthMask", true);
          stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]);
          stateFlag(S_CULL_ENABLE, GL_CULL_FACE);
          stateVariable(S_CULL_FACE, "cullFace", GL_BACK);
          stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW);
          stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1);
          stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);
          stateVariable(S_POLYGON_OFFSET_OFFSET, "polygonOffset", [0, 0]);
          stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);
          stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);
          stateVariable(S_SAMPLE_COVERAGE, "sampleCoverage", [1, false]);
          stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);
          stateVariable(S_STENCIL_MASK, "stencilMask", -1);
          stateVariable(S_STENCIL_FUNC, "stencilFunc", [GL_ALWAYS, 0, -1]);
          stateVariable(
            S_STENCIL_OPFRONT,
            "stencilOpSeparate",
            [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]
          );
          stateVariable(
            S_STENCIL_OPBACK,
            "stencilOpSeparate",
            [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]
          );
          stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);
          stateVariable(
            S_SCISSOR_BOX,
            "scissor",
            [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]
          );
          stateVariable(
            S_VIEWPORT,
            S_VIEWPORT,
            [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]
          );
          var sharedState = {
            gl,
            context: contextState,
            strings: stringStore,
            next: nextState,
            current: currentState,
            draw: drawState,
            elements: elementState,
            buffer: bufferState,
            shader: shaderState,
            attributes: attributeState.state,
            vao: attributeState,
            uniforms: uniformState,
            framebuffer: framebufferState,
            extensions,
            timer,
            isBufferArgs
          };
          var sharedConstants = {
            primTypes,
            compareFuncs,
            blendFuncs,
            blendEquations,
            stencilOps,
            glTypes,
            orientationType
          };
          if (extDrawBuffers) {
            sharedConstants.backBuffer = [GL_BACK];
            sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function(i) {
              if (i === 0) {
                return [0];
              }
              return loop(i, function(j) {
                return GL_COLOR_ATTACHMENT0$2 + j;
              });
            });
          }
          var drawCallCounter = 0;
          function createREGLEnvironment() {
            var env = createEnvironment({ cache: cachedCode });
            var link = env.link;
            var global2 = env.global;
            env.id = drawCallCounter++;
            env.batchId = "0";
            var SHARED = link(sharedState);
            var shared = env.shared = {
              props: "a0"
            };
            Object.keys(sharedState).forEach(function(prop) {
              shared[prop] = global2.def(SHARED, ".", prop);
            });
            var nextVars = env.next = {};
            var currentVars = env.current = {};
            Object.keys(GL_VARIABLES).forEach(function(variable) {
              if (Array.isArray(currentState[variable])) {
                nextVars[variable] = global2.def(shared.next, ".", variable);
                currentVars[variable] = global2.def(shared.current, ".", variable);
              }
            });
            var constants = env.constants = {};
            Object.keys(sharedConstants).forEach(function(name) {
              constants[name] = global2.def(JSON.stringify(sharedConstants[name]));
            });
            env.invoke = function(block, x) {
              switch (x.type) {
                case DYN_FUNC$1:
                  var argList = [
                    "this",
                    shared.context,
                    shared.props,
                    env.batchId
                  ];
                  return block.def(
                    link(x.data),
                    ".call(",
                    argList.slice(0, Math.max(x.data.length + 1, 4)),
                    ")"
                  );
                case DYN_PROP$1:
                  return block.def(shared.props, x.data);
                case DYN_CONTEXT$1:
                  return block.def(shared.context, x.data);
                case DYN_STATE$1:
                  return block.def("this", x.data);
                case DYN_THUNK:
                  x.data.append(env, block);
                  return x.data.ref;
                case DYN_CONSTANT$1:
                  return x.data.toString();
                case DYN_ARRAY$1:
                  return x.data.map(function(y) {
                    return env.invoke(block, y);
                  });
              }
            };
            env.attribCache = {};
            var scopeAttribs = {};
            env.scopeAttrib = function(name) {
              var id = stringStore.id(name);
              if (id in scopeAttribs) {
                return scopeAttribs[id];
              }
              var binding = attributeState.scope[id];
              if (!binding) {
                binding = attributeState.scope[id] = new AttributeRecord2();
              }
              var result = scopeAttribs[id] = link(binding);
              return result;
            };
            return env;
          }
          function parseProfile(options) {
            var staticOptions = options.static;
            var dynamicOptions = options.dynamic;
            var profileEnable;
            if (S_PROFILE in staticOptions) {
              var value = !!staticOptions[S_PROFILE];
              profileEnable = createStaticDecl(function(env, scope) {
                return value;
              });
              profileEnable.enable = value;
            } else if (S_PROFILE in dynamicOptions) {
              var dyn = dynamicOptions[S_PROFILE];
              profileEnable = createDynamicDecl(dyn, function(env, scope) {
                return env.invoke(scope, dyn);
              });
            }
            return profileEnable;
          }
          function parseFramebuffer(options, env) {
            var staticOptions = options.static;
            var dynamicOptions = options.dynamic;
            if (S_FRAMEBUFFER in staticOptions) {
              var framebuffer = staticOptions[S_FRAMEBUFFER];
              if (framebuffer) {
                framebuffer = framebufferState.getFramebuffer(framebuffer);
                return createStaticDecl(function(env2, block) {
                  var FRAMEBUFFER = env2.link(framebuffer);
                  var shared = env2.shared;
                  block.set(
                    shared.framebuffer,
                    ".next",
                    FRAMEBUFFER
                  );
                  var CONTEXT = shared.context;
                  block.set(
                    CONTEXT,
                    "." + S_FRAMEBUFFER_WIDTH,
                    FRAMEBUFFER + ".width"
                  );
                  block.set(
                    CONTEXT,
                    "." + S_FRAMEBUFFER_HEIGHT,
                    FRAMEBUFFER + ".height"
                  );
                  return FRAMEBUFFER;
                });
              } else {
                return createStaticDecl(function(env2, scope) {
                  var shared = env2.shared;
                  scope.set(
                    shared.framebuffer,
                    ".next",
                    "null"
                  );
                  var CONTEXT = shared.context;
                  scope.set(
                    CONTEXT,
                    "." + S_FRAMEBUFFER_WIDTH,
                    CONTEXT + "." + S_DRAWINGBUFFER_WIDTH
                  );
                  scope.set(
                    CONTEXT,
                    "." + S_FRAMEBUFFER_HEIGHT,
                    CONTEXT + "." + S_DRAWINGBUFFER_HEIGHT
                  );
                  return "null";
                });
              }
            } else if (S_FRAMEBUFFER in dynamicOptions) {
              var dyn = dynamicOptions[S_FRAMEBUFFER];
              return createDynamicDecl(dyn, function(env2, scope) {
                var FRAMEBUFFER_FUNC = env2.invoke(scope, dyn);
                var shared = env2.shared;
                var FRAMEBUFFER_STATE = shared.framebuffer;
                var FRAMEBUFFER = scope.def(
                  FRAMEBUFFER_STATE,
                  ".getFramebuffer(",
                  FRAMEBUFFER_FUNC,
                  ")"
                );
                scope.set(
                  FRAMEBUFFER_STATE,
                  ".next",
                  FRAMEBUFFER
                );
                var CONTEXT = shared.context;
                scope.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_WIDTH,
                  FRAMEBUFFER + "?" + FRAMEBUFFER + ".width:" + CONTEXT + "." + S_DRAWINGBUFFER_WIDTH
                );
                scope.set(
                  CONTEXT,
                  "." + S_FRAMEBUFFER_HEIGHT,
                  FRAMEBUFFER + "?" + FRAMEBUFFER + ".height:" + CONTEXT + "." + S_DRAWINGBUFFER_HEIGHT
                );
                return FRAMEBUFFER;
              });
            } else {
              return null;
            }
          }
          function parseViewportScissor(options, framebuffer, env) {
            var staticOptions = options.static;
            var dynamicOptions = options.dynamic;
            function parseBox(param) {
              if (param in staticOptions) {
                var box = staticOptions[param];
                var isStatic2 = true;
                var x = box.x | 0;
                var y = box.y | 0;
                var w, h;
                if ("width" in box) {
                  w = box.width | 0;
                } else {
                  isStatic2 = false;
                }
                if ("height" in box) {
                  h = box.height | 0;
                } else {
                  isStatic2 = false;
                }
                return new Declaration(
                  !isStatic2 && framebuffer && framebuffer.thisDep,
                  !isStatic2 && framebuffer && framebuffer.contextDep,
                  !isStatic2 && framebuffer && framebuffer.propDep,
                  function(env2, scope) {
                    var CONTEXT = env2.shared.context;
                    var BOX_W = w;
                    if (!("width" in box)) {
                      BOX_W = scope.def(CONTEXT, ".", S_FRAMEBUFFER_WIDTH, "-", x);
                    }
                    var BOX_H = h;
                    if (!("height" in box)) {
                      BOX_H = scope.def(CONTEXT, ".", S_FRAMEBUFFER_HEIGHT, "-", y);
                    }
                    return [x, y, BOX_W, BOX_H];
                  }
                );
              } else if (param in dynamicOptions) {
                var dynBox = dynamicOptions[param];
                var result = createDynamicDecl(dynBox, function(env2, scope) {
                  var BOX = env2.invoke(scope, dynBox);
                  var CONTEXT = env2.shared.context;
                  var BOX_X = scope.def(BOX, ".x|0");
                  var BOX_Y = scope.def(BOX, ".y|0");
                  var BOX_W = scope.def(
                    '"width" in ',
                    BOX,
                    "?",
                    BOX,
                    ".width|0:",
                    "(",
                    CONTEXT,
                    ".",
                    S_FRAMEBUFFER_WIDTH,
                    "-",
                    BOX_X,
                    ")"
                  );
                  var BOX_H = scope.def(
                    '"height" in ',
                    BOX,
                    "?",
                    BOX,
                    ".height|0:",
                    "(",
                    CONTEXT,
                    ".",
                    S_FRAMEBUFFER_HEIGHT,
                    "-",
                    BOX_Y,
                    ")"
                  );
                  return [BOX_X, BOX_Y, BOX_W, BOX_H];
                });
                if (framebuffer) {
                  result.thisDep = result.thisDep || framebuffer.thisDep;
                  result.contextDep = result.contextDep || framebuffer.contextDep;
                  result.propDep = result.propDep || framebuffer.propDep;
                }
                return result;
              } else if (framebuffer) {
                return new Declaration(
                  framebuffer.thisDep,
                  framebuffer.contextDep,
                  framebuffer.propDep,
                  function(env2, scope) {
                    var CONTEXT = env2.shared.context;
                    return [
                      0,
                      0,
                      scope.def(CONTEXT, ".", S_FRAMEBUFFER_WIDTH),
                      scope.def(CONTEXT, ".", S_FRAMEBUFFER_HEIGHT)
                    ];
                  }
                );
              } else {
                return null;
              }
            }
            var viewport = parseBox(S_VIEWPORT);
            if (viewport) {
              var prevViewport = viewport;
              viewport = new Declaration(
                viewport.thisDep,
                viewport.contextDep,
                viewport.propDep,
                function(env2, scope) {
                  var VIEWPORT = prevViewport.append(env2, scope);
                  var CONTEXT = env2.shared.context;
                  scope.set(
                    CONTEXT,
                    "." + S_VIEWPORT_WIDTH,
                    VIEWPORT[2]
                  );
                  scope.set(
                    CONTEXT,
                    "." + S_VIEWPORT_HEIGHT,
                    VIEWPORT[3]
                  );
                  return VIEWPORT;
                }
              );
            }
            return {
              viewport,
              scissor_box: parseBox(S_SCISSOR_BOX)
            };
          }
          function parseAttribLocations(options, attributes) {
            var staticOptions = options.static;
            var staticProgram = typeof staticOptions[S_FRAG] === "string" && typeof staticOptions[S_VERT] === "string";
            if (staticProgram) {
              if (Object.keys(attributes.dynamic).length > 0) {
                return null;
              }
              var staticAttributes = attributes.static;
              var sAttributes = Object.keys(staticAttributes);
              if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === "number") {
                var bindings = [];
                for (var i = 0; i < sAttributes.length; ++i) {
                  bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]]);
                }
                return bindings;
              }
            }
            return null;
          }
          function parseProgram(options, env, attribLocations) {
            var staticOptions = options.static;
            var dynamicOptions = options.dynamic;
            function parseShader(name) {
              if (name in staticOptions) {
                var id = stringStore.id(staticOptions[name]);
                var result = createStaticDecl(function() {
                  return id;
                });
                result.id = id;
                return result;
              } else if (name in dynamicOptions) {
                var dyn = dynamicOptions[name];
                return createDynamicDecl(dyn, function(env2, scope) {
                  var str = env2.invoke(scope, dyn);
                  var id2 = scope.def(env2.shared.strings, ".id(", str, ")");
                  return id2;
                });
              }
              return null;
            }
            var frag = parseShader(S_FRAG);
            var vert = parseShader(S_VERT);
            var program = null;
            var progVar;
            if (isStatic(frag) && isStatic(vert)) {
              program = shaderState.program(vert.id, frag.id, null, attribLocations);
              progVar = createStaticDecl(function(env2, scope) {
                return env2.link(program);
              });
            } else {
              progVar = new Declaration(
                frag && frag.thisDep || vert && vert.thisDep,
                frag && frag.contextDep || vert && vert.contextDep,
                frag && frag.propDep || vert && vert.propDep,
                function(env2, scope) {
                  var SHADER_STATE = env2.shared.shader;
                  var fragId;
                  if (frag) {
                    fragId = frag.append(env2, scope);
                  } else {
                    fragId = scope.def(SHADER_STATE, ".", S_FRAG);
                  }
                  var vertId;
                  if (vert) {
                    vertId = vert.append(env2, scope);
                  } else {
                    vertId = scope.def(SHADER_STATE, ".", S_VERT);
                  }
                  var progDef = SHADER_STATE + ".program(" + vertId + "," + fragId;
                  return scope.def(progDef + ")");
                }
              );
            }
            return {
              frag,
              vert,
              progVar,
              program
            };
          }
          function parseDraw(options, env) {
            var staticOptions = options.static;
            var dynamicOptions = options.dynamic;
            var staticDraw = {};
            var vaoActive = false;
            function parseVAO() {
              if (S_VAO in staticOptions) {
                var vao2 = staticOptions[S_VAO];
                if (vao2 !== null && attributeState.getVAO(vao2) === null) {
                  vao2 = attributeState.createVAO(vao2);
                }
                vaoActive = true;
                staticDraw.vao = vao2;
                return createStaticDecl(function(env2) {
                  var vaoRef = attributeState.getVAO(vao2);
                  if (vaoRef) {
                    return env2.link(vaoRef);
                  } else {
                    return "null";
                  }
                });
              } else if (S_VAO in dynamicOptions) {
                vaoActive = true;
                var dyn = dynamicOptions[S_VAO];
                return createDynamicDecl(dyn, function(env2, scope) {
                  var vaoRef = env2.invoke(scope, dyn);
                  return scope.def(env2.shared.vao + ".getVAO(" + vaoRef + ")");
                });
              }
              return null;
            }
            var vao = parseVAO();
            var elementsActive = false;
            function parseElements() {
              if (S_ELEMENTS in staticOptions) {
                var elements2 = staticOptions[S_ELEMENTS];
                staticDraw.elements = elements2;
                if (isBufferArgs(elements2)) {
                  var e = staticDraw.elements = elementState.create(elements2, true);
                  elements2 = elementState.getElements(e);
                  elementsActive = true;
                } else if (elements2) {
                  elements2 = elementState.getElements(elements2);
                  elementsActive = true;
                }
                var result = createStaticDecl(function(env2, scope) {
                  if (elements2) {
                    var result2 = env2.link(elements2);
                    env2.ELEMENTS = result2;
                    return result2;
                  }
                  env2.ELEMENTS = null;
                  return null;
                });
                result.value = elements2;
                return result;
              } else if (S_ELEMENTS in dynamicOptions) {
                elementsActive = true;
                var dyn = dynamicOptions[S_ELEMENTS];
                return createDynamicDecl(dyn, function(env2, scope) {
                  var shared = env2.shared;
                  var IS_BUFFER_ARGS = shared.isBufferArgs;
                  var ELEMENT_STATE = shared.elements;
                  var elementDefn = env2.invoke(scope, dyn);
                  var elements3 = scope.def("null");
                  var elementStream = scope.def(IS_BUFFER_ARGS, "(", elementDefn, ")");
                  var ifte = env2.cond(elementStream).then(elements3, "=", ELEMENT_STATE, ".createStream(", elementDefn, ");").else(elements3, "=", ELEMENT_STATE, ".getElements(", elementDefn, ");");
                  scope.entry(ifte);
                  scope.exit(
                    env2.cond(elementStream).then(ELEMENT_STATE, ".destroyStream(", elements3, ");")
                  );
                  env2.ELEMENTS = elements3;
                  return elements3;
                });
              } else if (vaoActive) {
                return new Declaration(
                  vao.thisDep,
                  vao.contextDep,
                  vao.propDep,
                  function(env2, scope) {
                    return scope.def(env2.shared.vao + ".currentVAO?" + env2.shared.elements + ".getElements(" + env2.shared.vao + ".currentVAO.elements):null");
                  }
                );
              }
              return null;
            }
            var elements = parseElements();
            function parsePrimitive() {
              if (S_PRIMITIVE in staticOptions) {
                var primitive2 = staticOptions[S_PRIMITIVE];
                staticDraw.primitive = primitive2;
                return createStaticDecl(function(env2, scope) {
                  return primTypes[primitive2];
                });
              } else if (S_PRIMITIVE in dynamicOptions) {
                var dynPrimitive = dynamicOptions[S_PRIMITIVE];
                return createDynamicDecl(dynPrimitive, function(env2, scope) {
                  var PRIM_TYPES = env2.constants.primTypes;
                  var prim = env2.invoke(scope, dynPrimitive);
                  return scope.def(PRIM_TYPES, "[", prim, "]");
                });
              } else if (elementsActive) {
                if (isStatic(elements)) {
                  if (elements.value) {
                    return createStaticDecl(function(env2, scope) {
                      return scope.def(env2.ELEMENTS, ".primType");
                    });
                  } else {
                    return createStaticDecl(function() {
                      return GL_TRIANGLES$1;
                    });
                  }
                } else {
                  return new Declaration(
                    elements.thisDep,
                    elements.contextDep,
                    elements.propDep,
                    function(env2, scope) {
                      var elements2 = env2.ELEMENTS;
                      return scope.def(elements2, "?", elements2, ".primType:", GL_TRIANGLES$1);
                    }
                  );
                }
              } else if (vaoActive) {
                return new Declaration(
                  vao.thisDep,
                  vao.contextDep,
                  vao.propDep,
                  function(env2, scope) {
                    return scope.def(env2.shared.vao + ".currentVAO?" + env2.shared.vao + ".currentVAO.primitive:" + GL_TRIANGLES$1);
                  }
                );
              }
              return null;
            }
            function parseParam(param, isOffset) {
              if (param in staticOptions) {
                var value = staticOptions[param] | 0;
                if (isOffset) {
                  staticDraw.offset = value;
                } else {
                  staticDraw.instances = value;
                }
                return createStaticDecl(function(env2, scope) {
                  if (isOffset) {
                    env2.OFFSET = value;
                  }
                  return value;
                });
              } else if (param in dynamicOptions) {
                var dynValue = dynamicOptions[param];
                return createDynamicDecl(dynValue, function(env2, scope) {
                  var result = env2.invoke(scope, dynValue);
                  if (isOffset) {
                    env2.OFFSET = result;
                  }
                  return result;
                });
              } else if (isOffset) {
                if (elementsActive) {
                  return createStaticDecl(function(env2, scope) {
                    env2.OFFSET = 0;
                    return 0;
                  });
                } else if (vaoActive) {
                  return new Declaration(
                    vao.thisDep,
                    vao.contextDep,
                    vao.propDep,
                    function(env2, scope) {
                      return scope.def(env2.shared.vao + ".currentVAO?" + env2.shared.vao + ".currentVAO.offset:0");
                    }
                  );
                }
              } else if (vaoActive) {
                return new Declaration(
                  vao.thisDep,
                  vao.contextDep,
                  vao.propDep,
                  function(env2, scope) {
                    return scope.def(env2.shared.vao + ".currentVAO?" + env2.shared.vao + ".currentVAO.instances:-1");
                  }
                );
              }
              return null;
            }
            var OFFSET = parseParam(S_OFFSET, true);
            function parseVertCount() {
              if (S_COUNT in staticOptions) {
                var count2 = staticOptions[S_COUNT] | 0;
                staticDraw.count = count2;
                return createStaticDecl(function() {
                  return count2;
                });
              } else if (S_COUNT in dynamicOptions) {
                var dynCount = dynamicOptions[S_COUNT];
                return createDynamicDecl(dynCount, function(env2, scope) {
                  var result2 = env2.invoke(scope, dynCount);
                  return result2;
                });
              } else if (elementsActive) {
                if (isStatic(elements)) {
                  if (elements) {
                    if (OFFSET) {
                      return new Declaration(
                        OFFSET.thisDep,
                        OFFSET.contextDep,
                        OFFSET.propDep,
                        function(env2, scope) {
                          var result2 = scope.def(
                            env2.ELEMENTS,
                            ".vertCount-",
                            env2.OFFSET
                          );
                          return result2;
                        }
                      );
                    } else {
                      return createStaticDecl(function(env2, scope) {
                        return scope.def(env2.ELEMENTS, ".vertCount");
                      });
                    }
                  } else {
                    var result = createStaticDecl(function() {
                      return -1;
                    });
                    return result;
                  }
                } else {
                  var variable = new Declaration(
                    elements.thisDep || OFFSET.thisDep,
                    elements.contextDep || OFFSET.contextDep,
                    elements.propDep || OFFSET.propDep,
                    function(env2, scope) {
                      var elements2 = env2.ELEMENTS;
                      if (env2.OFFSET) {
                        return scope.def(
                          elements2,
                          "?",
                          elements2,
                          ".vertCount-",
                          env2.OFFSET,
                          ":-1"
                        );
                      }
                      return scope.def(elements2, "?", elements2, ".vertCount:-1");
                    }
                  );
                  return variable;
                }
              } else if (vaoActive) {
                var countVariable = new Declaration(
                  vao.thisDep,
                  vao.contextDep,
                  vao.propDep,
                  function(env2, scope) {
                    return scope.def(env2.shared.vao, ".currentVAO?", env2.shared.vao, ".currentVAO.count:-1");
                  }
                );
                return countVariable;
              }
              return null;
            }
            var primitive = parsePrimitive();
            var count = parseVertCount();
            var instances = parseParam(S_INSTANCES, false);
            return {
              elements,
              primitive,
              count,
              instances,
              offset: OFFSET,
              vao,
              vaoActive,
              elementsActive,
              // static draw props
              static: staticDraw
            };
          }
          function parseGLState(options, env) {
            var staticOptions = options.static;
            var dynamicOptions = options.dynamic;
            var STATE = {};
            GL_STATE_NAMES.forEach(function(prop) {
              var param = propName(prop);
              function parseParam(parseStatic, parseDynamic) {
                if (prop in staticOptions) {
                  var value = parseStatic(staticOptions[prop]);
                  STATE[param] = createStaticDecl(function() {
                    return value;
                  });
                } else if (prop in dynamicOptions) {
                  var dyn = dynamicOptions[prop];
                  STATE[param] = createDynamicDecl(dyn, function(env2, scope) {
                    return parseDynamic(env2, scope, env2.invoke(scope, dyn));
                  });
                }
              }
              switch (prop) {
                case S_CULL_ENABLE:
                case S_BLEND_ENABLE:
                case S_DITHER:
                case S_STENCIL_ENABLE:
                case S_DEPTH_ENABLE:
                case S_SCISSOR_ENABLE:
                case S_POLYGON_OFFSET_ENABLE:
                case S_SAMPLE_ALPHA:
                case S_SAMPLE_ENABLE:
                case S_DEPTH_MASK:
                  return parseParam(
                    function(value) {
                      return value;
                    },
                    function(env2, scope, value) {
                      return value;
                    }
                  );
                case S_DEPTH_FUNC:
                  return parseParam(
                    function(value) {
                      return compareFuncs[value];
                    },
                    function(env2, scope, value) {
                      var COMPARE_FUNCS = env2.constants.compareFuncs;
                      return scope.def(COMPARE_FUNCS, "[", value, "]");
                    }
                  );
                case S_DEPTH_RANGE:
                  return parseParam(
                    function(value) {
                      return value;
                    },
                    function(env2, scope, value) {
                      var Z_NEAR = scope.def("+", value, "[0]");
                      var Z_FAR = scope.def("+", value, "[1]");
                      return [Z_NEAR, Z_FAR];
                    }
                  );
                case S_BLEND_FUNC:
                  return parseParam(
                    function(value) {
                      var srcRGB = "srcRGB" in value ? value.srcRGB : value.src;
                      var srcAlpha = "srcAlpha" in value ? value.srcAlpha : value.src;
                      var dstRGB = "dstRGB" in value ? value.dstRGB : value.dst;
                      var dstAlpha = "dstAlpha" in value ? value.dstAlpha : value.dst;
                      return [
                        blendFuncs[srcRGB],
                        blendFuncs[dstRGB],
                        blendFuncs[srcAlpha],
                        blendFuncs[dstAlpha]
                      ];
                    },
                    function(env2, scope, value) {
                      var BLEND_FUNCS = env2.constants.blendFuncs;
                      function read(prefix, suffix) {
                        var func = scope.def(
                          '"',
                          prefix,
                          suffix,
                          '" in ',
                          value,
                          "?",
                          value,
                          ".",
                          prefix,
                          suffix,
                          ":",
                          value,
                          ".",
                          prefix
                        );
                        return func;
                      }
                      var srcRGB = read("src", "RGB");
                      var dstRGB = read("dst", "RGB");
                      var SRC_RGB = scope.def(BLEND_FUNCS, "[", srcRGB, "]");
                      var SRC_ALPHA = scope.def(BLEND_FUNCS, "[", read("src", "Alpha"), "]");
                      var DST_RGB = scope.def(BLEND_FUNCS, "[", dstRGB, "]");
                      var DST_ALPHA = scope.def(BLEND_FUNCS, "[", read("dst", "Alpha"), "]");
                      return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA];
                    }
                  );
                case S_BLEND_EQUATION:
                  return parseParam(
                    function(value) {
                      if (typeof value === "string") {
                        return [
                          blendEquations[value],
                          blendEquations[value]
                        ];
                      } else if (typeof value === "object") {
                        return [
                          blendEquations[value.rgb],
                          blendEquations[value.alpha]
                        ];
                      } else {
                      }
                    },
                    function(env2, scope, value) {
                      var BLEND_EQUATIONS = env2.constants.blendEquations;
                      var RGB = scope.def();
                      var ALPHA = scope.def();
                      var ifte = env2.cond("typeof ", value, '==="string"');
                      ifte.then(
                        RGB,
                        "=",
                        ALPHA,
                        "=",
                        BLEND_EQUATIONS,
                        "[",
                        value,
                        "];"
                      );
                      ifte.else(
                        RGB,
                        "=",
                        BLEND_EQUATIONS,
                        "[",
                        value,
                        ".rgb];",
                        ALPHA,
                        "=",
                        BLEND_EQUATIONS,
                        "[",
                        value,
                        ".alpha];"
                      );
                      scope(ifte);
                      return [RGB, ALPHA];
                    }
                  );
                case S_BLEND_COLOR:
                  return parseParam(
                    function(value) {
                      return loop(4, function(i) {
                        return +value[i];
                      });
                    },
                    function(env2, scope, value) {
                      return loop(4, function(i) {
                        return scope.def("+", value, "[", i, "]");
                      });
                    }
                  );
                case S_STENCIL_MASK:
                  return parseParam(
                    function(value) {
                      return value | 0;
                    },
                    function(env2, scope, value) {
                      return scope.def(value, "|0");
                    }
                  );
                case S_STENCIL_FUNC:
                  return parseParam(
                    function(value) {
                      var cmp = value.cmp || "keep";
                      var ref = value.ref || 0;
                      var mask = "mask" in value ? value.mask : -1;
                      return [
                        compareFuncs[cmp],
                        ref,
                        mask
                      ];
                    },
                    function(env2, scope, value) {
                      var COMPARE_FUNCS = env2.constants.compareFuncs;
                      var cmp = scope.def(
                        '"cmp" in ',
                        value,
                        "?",
                        COMPARE_FUNCS,
                        "[",
                        value,
                        ".cmp]",
                        ":",
                        GL_KEEP
                      );
                      var ref = scope.def(value, ".ref|0");
                      var mask = scope.def(
                        '"mask" in ',
                        value,
                        "?",
                        value,
                        ".mask|0:-1"
                      );
                      return [cmp, ref, mask];
                    }
                  );
                case S_STENCIL_OPFRONT:
                case S_STENCIL_OPBACK:
                  return parseParam(
                    function(value) {
                      var fail = value.fail || "keep";
                      var zfail = value.zfail || "keep";
                      var zpass = value.zpass || "keep";
                      return [
                        prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                        stencilOps[fail],
                        stencilOps[zfail],
                        stencilOps[zpass]
                      ];
                    },
                    function(env2, scope, value) {
                      var STENCIL_OPS = env2.constants.stencilOps;
                      function read(name) {
                        return scope.def(
                          '"',
                          name,
                          '" in ',
                          value,
                          "?",
                          STENCIL_OPS,
                          "[",
                          value,
                          ".",
                          name,
                          "]:",
                          GL_KEEP
                        );
                      }
                      return [
                        prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                        read("fail"),
                        read("zfail"),
                        read("zpass")
                      ];
                    }
                  );
                case S_POLYGON_OFFSET_OFFSET:
                  return parseParam(
                    function(value) {
                      var factor = value.factor | 0;
                      var units = value.units | 0;
                      return [factor, units];
                    },
                    function(env2, scope, value) {
                      var FACTOR = scope.def(value, ".factor|0");
                      var UNITS = scope.def(value, ".units|0");
                      return [FACTOR, UNITS];
                    }
                  );
                case S_CULL_FACE:
                  return parseParam(
                    function(value) {
                      var face = 0;
                      if (value === "front") {
                        face = GL_FRONT;
                      } else if (value === "back") {
                        face = GL_BACK;
                      }
                      return face;
                    },
                    function(env2, scope, value) {
                      return scope.def(value, '==="front"?', GL_FRONT, ":", GL_BACK);
                    }
                  );
                case S_LINE_WIDTH:
                  return parseParam(
                    function(value) {
                      return value;
                    },
                    function(env2, scope, value) {
                      return value;
                    }
                  );
                case S_FRONT_FACE:
                  return parseParam(
                    function(value) {
                      return orientationType[value];
                    },
                    function(env2, scope, value) {
                      return scope.def(value + '==="cw"?' + GL_CW + ":" + GL_CCW);
                    }
                  );
                case S_COLOR_MASK:
                  return parseParam(
                    function(value) {
                      return value.map(function(v) {
                        return !!v;
                      });
                    },
                    function(env2, scope, value) {
                      return loop(4, function(i) {
                        return "!!" + value + "[" + i + "]";
                      });
                    }
                  );
                case S_SAMPLE_COVERAGE:
                  return parseParam(
                    function(value) {
                      var sampleValue = "value" in value ? value.value : 1;
                      var sampleInvert = !!value.invert;
                      return [sampleValue, sampleInvert];
                    },
                    function(env2, scope, value) {
                      var VALUE = scope.def(
                        '"value" in ',
                        value,
                        "?+",
                        value,
                        ".value:1"
                      );
                      var INVERT = scope.def("!!", value, ".invert");
                      return [VALUE, INVERT];
                    }
                  );
              }
            });
            return STATE;
          }
          function parseUniforms(uniforms, env) {
            var staticUniforms = uniforms.static;
            var dynamicUniforms = uniforms.dynamic;
            var UNIFORMS = {};
            Object.keys(staticUniforms).forEach(function(name) {
              var value = staticUniforms[name];
              var result;
              if (typeof value === "number" || typeof value === "boolean") {
                result = createStaticDecl(function() {
                  return value;
                });
              } else if (typeof value === "function") {
                var reglType = value._reglType;
                if (reglType === "texture2d" || reglType === "textureCube") {
                  result = createStaticDecl(function(env2) {
                    return env2.link(value);
                  });
                } else if (reglType === "framebuffer" || reglType === "framebufferCube") {
                  result = createStaticDecl(function(env2) {
                    return env2.link(value.color[0]);
                  });
                } else {
                }
              } else if (isArrayLike(value)) {
                result = createStaticDecl(function(env2) {
                  var ITEM = env2.global.def(
                    "[",
                    loop(value.length, function(i) {
                      return value[i];
                    }),
                    "]"
                  );
                  return ITEM;
                });
              } else {
              }
              result.value = value;
              UNIFORMS[name] = result;
            });
            Object.keys(dynamicUniforms).forEach(function(key) {
              var dyn = dynamicUniforms[key];
              UNIFORMS[key] = createDynamicDecl(dyn, function(env2, scope) {
                return env2.invoke(scope, dyn);
              });
            });
            return UNIFORMS;
          }
          function parseAttributes(attributes, env) {
            var staticAttributes = attributes.static;
            var dynamicAttributes = attributes.dynamic;
            var attributeDefs = {};
            Object.keys(staticAttributes).forEach(function(attribute) {
              var value = staticAttributes[attribute];
              var id = stringStore.id(attribute);
              var record = new AttributeRecord2();
              if (isBufferArgs(value)) {
                record.state = ATTRIB_STATE_POINTER;
                record.buffer = bufferState.getBuffer(
                  bufferState.create(value, GL_ARRAY_BUFFER$2, false, true)
                );
                record.type = 0;
              } else {
                var buffer = bufferState.getBuffer(value);
                if (buffer) {
                  record.state = ATTRIB_STATE_POINTER;
                  record.buffer = buffer;
                  record.type = 0;
                } else {
                  if ("constant" in value) {
                    var constant = value.constant;
                    record.buffer = "null";
                    record.state = ATTRIB_STATE_CONSTANT;
                    if (typeof constant === "number") {
                      record.x = constant;
                    } else {
                      CUTE_COMPONENTS.forEach(function(c, i) {
                        if (i < constant.length) {
                          record[c] = constant[i];
                        }
                      });
                    }
                  } else {
                    if (isBufferArgs(value.buffer)) {
                      buffer = bufferState.getBuffer(
                        bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true)
                      );
                    } else {
                      buffer = bufferState.getBuffer(value.buffer);
                    }
                    var offset = value.offset | 0;
                    var stride = value.stride | 0;
                    var size = value.size | 0;
                    var normalized = !!value.normalized;
                    var type = 0;
                    if ("type" in value) {
                      type = glTypes[value.type];
                    }
                    var divisor = value.divisor | 0;
                    record.buffer = buffer;
                    record.state = ATTRIB_STATE_POINTER;
                    record.size = size;
                    record.normalized = normalized;
                    record.type = type || buffer.dtype;
                    record.offset = offset;
                    record.stride = stride;
                    record.divisor = divisor;
                  }
                }
              }
              attributeDefs[attribute] = createStaticDecl(function(env2, scope) {
                var cache = env2.attribCache;
                if (id in cache) {
                  return cache[id];
                }
                var result = {
                  isStream: false
                };
                Object.keys(record).forEach(function(key) {
                  result[key] = record[key];
                });
                if (record.buffer) {
                  result.buffer = env2.link(record.buffer);
                  result.type = result.type || result.buffer + ".dtype";
                }
                cache[id] = result;
                return result;
              });
            });
            Object.keys(dynamicAttributes).forEach(function(attribute) {
              var dyn = dynamicAttributes[attribute];
              function appendAttributeCode(env2, block) {
                var VALUE = env2.invoke(block, dyn);
                var shared = env2.shared;
                var constants = env2.constants;
                var IS_BUFFER_ARGS = shared.isBufferArgs;
                var BUFFER_STATE = shared.buffer;
                var result = {
                  isStream: block.def(false)
                };
                var defaultRecord = new AttributeRecord2();
                defaultRecord.state = ATTRIB_STATE_POINTER;
                Object.keys(defaultRecord).forEach(function(key) {
                  result[key] = block.def("" + defaultRecord[key]);
                });
                var BUFFER = result.buffer;
                var TYPE = result.type;
                block(
                  "if(",
                  IS_BUFFER_ARGS,
                  "(",
                  VALUE,
                  ")){",
                  result.isStream,
                  "=true;",
                  BUFFER,
                  "=",
                  BUFFER_STATE,
                  ".createStream(",
                  GL_ARRAY_BUFFER$2,
                  ",",
                  VALUE,
                  ");",
                  TYPE,
                  "=",
                  BUFFER,
                  ".dtype;",
                  "}else{",
                  BUFFER,
                  "=",
                  BUFFER_STATE,
                  ".getBuffer(",
                  VALUE,
                  ");",
                  "if(",
                  BUFFER,
                  "){",
                  TYPE,
                  "=",
                  BUFFER,
                  ".dtype;",
                  '}else if("constant" in ',
                  VALUE,
                  "){",
                  result.state,
                  "=",
                  ATTRIB_STATE_CONSTANT,
                  ";",
                  "if(typeof " + VALUE + '.constant === "number"){',
                  result[CUTE_COMPONENTS[0]],
                  "=",
                  VALUE,
                  ".constant;",
                  CUTE_COMPONENTS.slice(1).map(function(n) {
                    return result[n];
                  }).join("="),
                  "=0;",
                  "}else{",
                  CUTE_COMPONENTS.map(function(name, i) {
                    return result[name] + "=" + VALUE + ".constant.length>" + i + "?" + VALUE + ".constant[" + i + "]:0;";
                  }).join(""),
                  "}}else{",
                  "if(",
                  IS_BUFFER_ARGS,
                  "(",
                  VALUE,
                  ".buffer)){",
                  BUFFER,
                  "=",
                  BUFFER_STATE,
                  ".createStream(",
                  GL_ARRAY_BUFFER$2,
                  ",",
                  VALUE,
                  ".buffer);",
                  "}else{",
                  BUFFER,
                  "=",
                  BUFFER_STATE,
                  ".getBuffer(",
                  VALUE,
                  ".buffer);",
                  "}",
                  TYPE,
                  '="type" in ',
                  VALUE,
                  "?",
                  constants.glTypes,
                  "[",
                  VALUE,
                  ".type]:",
                  BUFFER,
                  ".dtype;",
                  result.normalized,
                  "=!!",
                  VALUE,
                  ".normalized;"
                );
                function emitReadRecord(name) {
                  block(result[name], "=", VALUE, ".", name, "|0;");
                }
                emitReadRecord("size");
                emitReadRecord("offset");
                emitReadRecord("stride");
                emitReadRecord("divisor");
                block("}}");
                block.exit(
                  "if(",
                  result.isStream,
                  "){",
                  BUFFER_STATE,
                  ".destroyStream(",
                  BUFFER,
                  ");",
                  "}"
                );
                return result;
              }
              attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);
            });
            return attributeDefs;
          }
          function parseContext(context) {
            var staticContext = context.static;
            var dynamicContext = context.dynamic;
            var result = {};
            Object.keys(staticContext).forEach(function(name) {
              var value = staticContext[name];
              result[name] = createStaticDecl(function(env, scope) {
                if (typeof value === "number" || typeof value === "boolean") {
                  return "" + value;
                } else {
                  return env.link(value);
                }
              });
            });
            Object.keys(dynamicContext).forEach(function(name) {
              var dyn = dynamicContext[name];
              result[name] = createDynamicDecl(dyn, function(env, scope) {
                return env.invoke(scope, dyn);
              });
            });
            return result;
          }
          function parseArguments(options, attributes, uniforms, context, env) {
            var staticOptions = options.static;
            var dynamicOptions = options.dynamic;
            var attribLocations = parseAttribLocations(options, attributes);
            var framebuffer = parseFramebuffer(options, env);
            var viewportAndScissor = parseViewportScissor(options, framebuffer, env);
            var draw = parseDraw(options, env);
            var state = parseGLState(options, env);
            var shader = parseProgram(options, env, attribLocations);
            function copyBox(name) {
              var defn = viewportAndScissor[name];
              if (defn) {
                state[name] = defn;
              }
            }
            copyBox(S_VIEWPORT);
            copyBox(propName(S_SCISSOR_BOX));
            var dirty = Object.keys(state).length > 0;
            var result = {
              framebuffer,
              draw,
              shader,
              state,
              dirty,
              scopeVAO: null,
              drawVAO: null,
              useVAO: false,
              attributes: {}
            };
            result.profile = parseProfile(options, env);
            result.uniforms = parseUniforms(uniforms, env);
            result.drawVAO = result.scopeVAO = draw.vao;
            if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays && draw.static.elements) {
              var useVAO = true;
              var staticBindings = shader.program.attributes.map(function(attr) {
                var binding = attributes.static[attr];
                useVAO = useVAO && !!binding;
                return binding;
              });
              if (useVAO && staticBindings.length > 0) {
                var vao = attributeState.getVAO(attributeState.createVAO({
                  attributes: staticBindings,
                  elements: draw.static.elements
                }));
                result.drawVAO = new Declaration(null, null, null, function(env2, scope) {
                  return env2.link(vao);
                });
                result.useVAO = true;
              }
            }
            if (attribLocations) {
              result.useVAO = true;
            } else {
              result.attributes = parseAttributes(attributes, env);
            }
            result.context = parseContext(context, env);
            return result;
          }
          function emitContext(env, scope, context) {
            var shared = env.shared;
            var CONTEXT = shared.context;
            var contextEnter = env.scope();
            Object.keys(context).forEach(function(name) {
              scope.save(CONTEXT, "." + name);
              var defn = context[name];
              var value = defn.append(env, scope);
              if (Array.isArray(value)) {
                contextEnter(CONTEXT, ".", name, "=[", value.join(), "];");
              } else {
                contextEnter(CONTEXT, ".", name, "=", value, ";");
              }
            });
            scope(contextEnter);
          }
          function emitPollFramebuffer(env, scope, framebuffer, skipCheck) {
            var shared = env.shared;
            var GL = shared.gl;
            var FRAMEBUFFER_STATE = shared.framebuffer;
            var EXT_DRAW_BUFFERS;
            if (extDrawBuffers) {
              EXT_DRAW_BUFFERS = scope.def(shared.extensions, ".webgl_draw_buffers");
            }
            var constants = env.constants;
            var DRAW_BUFFERS = constants.drawBuffer;
            var BACK_BUFFER = constants.backBuffer;
            var NEXT;
            if (framebuffer) {
              NEXT = framebuffer.append(env, scope);
            } else {
              NEXT = scope.def(FRAMEBUFFER_STATE, ".next");
            }
            if (!skipCheck) {
              scope("if(", NEXT, "!==", FRAMEBUFFER_STATE, ".cur){");
            }
            scope(
              "if(",
              NEXT,
              "){",
              GL,
              ".bindFramebuffer(",
              GL_FRAMEBUFFER$2,
              ",",
              NEXT,
              ".framebuffer);"
            );
            if (extDrawBuffers) {
              scope(
                EXT_DRAW_BUFFERS,
                ".drawBuffersWEBGL(",
                DRAW_BUFFERS,
                "[",
                NEXT,
                ".colorAttachments.length]);"
              );
            }
            scope(
              "}else{",
              GL,
              ".bindFramebuffer(",
              GL_FRAMEBUFFER$2,
              ",null);"
            );
            if (extDrawBuffers) {
              scope(EXT_DRAW_BUFFERS, ".drawBuffersWEBGL(", BACK_BUFFER, ");");
            }
            scope(
              "}",
              FRAMEBUFFER_STATE,
              ".cur=",
              NEXT,
              ";"
            );
            if (!skipCheck) {
              scope("}");
            }
          }
          function emitPollState(env, scope, args) {
            var shared = env.shared;
            var GL = shared.gl;
            var CURRENT_VARS = env.current;
            var NEXT_VARS = env.next;
            var CURRENT_STATE = shared.current;
            var NEXT_STATE = shared.next;
            var block = env.cond(CURRENT_STATE, ".dirty");
            GL_STATE_NAMES.forEach(function(prop) {
              var param = propName(prop);
              if (param in args.state) {
                return;
              }
              var NEXT, CURRENT;
              if (param in NEXT_VARS) {
                NEXT = NEXT_VARS[param];
                CURRENT = CURRENT_VARS[param];
                var parts = loop(currentState[param].length, function(i) {
                  return block.def(NEXT, "[", i, "]");
                });
                block(env.cond(parts.map(function(p, i) {
                  return p + "!==" + CURRENT + "[" + i + "]";
                }).join("||")).then(
                  GL,
                  ".",
                  GL_VARIABLES[param],
                  "(",
                  parts,
                  ");",
                  parts.map(function(p, i) {
                    return CURRENT + "[" + i + "]=" + p;
                  }).join(";"),
                  ";"
                ));
              } else {
                NEXT = block.def(NEXT_STATE, ".", param);
                var ifte = env.cond(NEXT, "!==", CURRENT_STATE, ".", param);
                block(ifte);
                if (param in GL_FLAGS) {
                  ifte(
                    env.cond(NEXT).then(GL, ".enable(", GL_FLAGS[param], ");").else(GL, ".disable(", GL_FLAGS[param], ");"),
                    CURRENT_STATE,
                    ".",
                    param,
                    "=",
                    NEXT,
                    ";"
                  );
                } else {
                  ifte(
                    GL,
                    ".",
                    GL_VARIABLES[param],
                    "(",
                    NEXT,
                    ");",
                    CURRENT_STATE,
                    ".",
                    param,
                    "=",
                    NEXT,
                    ";"
                  );
                }
              }
            });
            if (Object.keys(args.state).length === 0) {
              block(CURRENT_STATE, ".dirty=false;");
            }
            scope(block);
          }
          function emitSetOptions(env, scope, options, filter) {
            var shared = env.shared;
            var CURRENT_VARS = env.current;
            var CURRENT_STATE = shared.current;
            var GL = shared.gl;
            var VALUE;
            sortState(Object.keys(options)).forEach(function(param) {
              var defn = options[param];
              if (filter && !filter(defn)) {
                return;
              }
              var variable = defn.append(env, scope);
              if (GL_FLAGS[param]) {
                var flag = GL_FLAGS[param];
                if (isStatic(defn)) {
                  VALUE = env.link(variable, { stable: true });
                  scope(env.cond(VALUE).then(GL, ".enable(", flag, ");").else(GL, ".disable(", flag, ");"));
                  scope(CURRENT_STATE, ".", param, "=", VALUE, ";");
                } else {
                  scope(env.cond(variable).then(GL, ".enable(", flag, ");").else(GL, ".disable(", flag, ");"));
                  scope(CURRENT_STATE, ".", param, "=", variable, ";");
                }
              } else if (isArrayLike(variable)) {
                var CURRENT = CURRENT_VARS[param];
                scope(
                  GL,
                  ".",
                  GL_VARIABLES[param],
                  "(",
                  variable,
                  ");",
                  variable.map(function(v, i) {
                    return CURRENT + "[" + i + "]=" + v;
                  }).join(";"),
                  ";"
                );
              } else {
                if (isStatic(defn)) {
                  VALUE = env.link(variable, { stable: true });
                  scope(
                    GL,
                    ".",
                    GL_VARIABLES[param],
                    "(",
                    VALUE,
                    ");",
                    CURRENT_STATE,
                    ".",
                    param,
                    "=",
                    VALUE,
                    ";"
                  );
                } else {
                  scope(
                    GL,
                    ".",
                    GL_VARIABLES[param],
                    "(",
                    variable,
                    ");",
                    CURRENT_STATE,
                    ".",
                    param,
                    "=",
                    variable,
                    ";"
                  );
                }
              }
            });
          }
          function injectExtensions(env, scope) {
            if (extInstancing) {
              env.instancing = scope.def(
                env.shared.extensions,
                ".angle_instanced_arrays"
              );
            }
          }
          function emitProfile(env, scope, args, useScope, incrementCounter) {
            var shared = env.shared;
            var STATS = env.stats;
            var CURRENT_STATE = shared.current;
            var TIMER = shared.timer;
            var profileArg = args.profile;
            function perfCounter() {
              if (typeof performance === "undefined") {
                return "Date.now()";
              } else {
                return "performance.now()";
              }
            }
            var CPU_START, QUERY_COUNTER;
            function emitProfileStart(block) {
              CPU_START = scope.def();
              block(CPU_START, "=", perfCounter(), ";");
              if (typeof incrementCounter === "string") {
                block(STATS, ".count+=", incrementCounter, ";");
              } else {
                block(STATS, ".count++;");
              }
              if (timer) {
                if (useScope) {
                  QUERY_COUNTER = scope.def();
                  block(QUERY_COUNTER, "=", TIMER, ".getNumPendingQueries();");
                } else {
                  block(TIMER, ".beginQuery(", STATS, ");");
                }
              }
            }
            function emitProfileEnd(block) {
              block(STATS, ".cpuTime+=", perfCounter(), "-", CPU_START, ";");
              if (timer) {
                if (useScope) {
                  block(
                    TIMER,
                    ".pushScopeStats(",
                    QUERY_COUNTER,
                    ",",
                    TIMER,
                    ".getNumPendingQueries(),",
                    STATS,
                    ");"
                  );
                } else {
                  block(TIMER, ".endQuery();");
                }
              }
            }
            function scopeProfile(value) {
              var prev = scope.def(CURRENT_STATE, ".profile");
              scope(CURRENT_STATE, ".profile=", value, ";");
              scope.exit(CURRENT_STATE, ".profile=", prev, ";");
            }
            var USE_PROFILE;
            if (profileArg) {
              if (isStatic(profileArg)) {
                if (profileArg.enable) {
                  emitProfileStart(scope);
                  emitProfileEnd(scope.exit);
                  scopeProfile("true");
                } else {
                  scopeProfile("false");
                }
                return;
              }
              USE_PROFILE = profileArg.append(env, scope);
              scopeProfile(USE_PROFILE);
            } else {
              USE_PROFILE = scope.def(CURRENT_STATE, ".profile");
            }
            var start = env.block();
            emitProfileStart(start);
            scope("if(", USE_PROFILE, "){", start, "}");
            var end = env.block();
            emitProfileEnd(end);
            scope.exit("if(", USE_PROFILE, "){", end, "}");
          }
          function emitAttributes(env, scope, args, attributes, filter) {
            var shared = env.shared;
            function typeLength(x) {
              switch (x) {
                case GL_FLOAT_VEC2:
                case GL_INT_VEC2:
                case GL_BOOL_VEC2:
                  return 2;
                case GL_FLOAT_VEC3:
                case GL_INT_VEC3:
                case GL_BOOL_VEC3:
                  return 3;
                case GL_FLOAT_VEC4:
                case GL_INT_VEC4:
                case GL_BOOL_VEC4:
                  return 4;
                default:
                  return 1;
              }
            }
            function emitBindAttribute(ATTRIBUTE, size, record) {
              var GL = shared.gl;
              var LOCATION = scope.def(ATTRIBUTE, ".location");
              var BINDING = scope.def(shared.attributes, "[", LOCATION, "]");
              var STATE = record.state;
              var BUFFER = record.buffer;
              var CONST_COMPONENTS = [
                record.x,
                record.y,
                record.z,
                record.w
              ];
              var COMMON_KEYS = [
                "buffer",
                "normalized",
                "offset",
                "stride"
              ];
              function emitBuffer() {
                scope(
                  "if(!",
                  BINDING,
                  ".buffer){",
                  GL,
                  ".enableVertexAttribArray(",
                  LOCATION,
                  ");}"
                );
                var TYPE = record.type;
                var SIZE;
                if (!record.size) {
                  SIZE = size;
                } else {
                  SIZE = scope.def(record.size, "||", size);
                }
                scope(
                  "if(",
                  BINDING,
                  ".type!==",
                  TYPE,
                  "||",
                  BINDING,
                  ".size!==",
                  SIZE,
                  "||",
                  COMMON_KEYS.map(function(key) {
                    return BINDING + "." + key + "!==" + record[key];
                  }).join("||"),
                  "){",
                  GL,
                  ".bindBuffer(",
                  GL_ARRAY_BUFFER$2,
                  ",",
                  BUFFER,
                  ".buffer);",
                  GL,
                  ".vertexAttribPointer(",
                  [
                    LOCATION,
                    SIZE,
                    TYPE,
                    record.normalized,
                    record.stride,
                    record.offset
                  ],
                  ");",
                  BINDING,
                  ".type=",
                  TYPE,
                  ";",
                  BINDING,
                  ".size=",
                  SIZE,
                  ";",
                  COMMON_KEYS.map(function(key) {
                    return BINDING + "." + key + "=" + record[key] + ";";
                  }).join(""),
                  "}"
                );
                if (extInstancing) {
                  var DIVISOR = record.divisor;
                  scope(
                    "if(",
                    BINDING,
                    ".divisor!==",
                    DIVISOR,
                    "){",
                    env.instancing,
                    ".vertexAttribDivisorANGLE(",
                    [LOCATION, DIVISOR],
                    ");",
                    BINDING,
                    ".divisor=",
                    DIVISOR,
                    ";}"
                  );
                }
              }
              function emitConstant() {
                scope(
                  "if(",
                  BINDING,
                  ".buffer){",
                  GL,
                  ".disableVertexAttribArray(",
                  LOCATION,
                  ");",
                  BINDING,
                  ".buffer=null;",
                  "}if(",
                  CUTE_COMPONENTS.map(function(c, i) {
                    return BINDING + "." + c + "!==" + CONST_COMPONENTS[i];
                  }).join("||"),
                  "){",
                  GL,
                  ".vertexAttrib4f(",
                  LOCATION,
                  ",",
                  CONST_COMPONENTS,
                  ");",
                  CUTE_COMPONENTS.map(function(c, i) {
                    return BINDING + "." + c + "=" + CONST_COMPONENTS[i] + ";";
                  }).join(""),
                  "}"
                );
              }
              if (STATE === ATTRIB_STATE_POINTER) {
                emitBuffer();
              } else if (STATE === ATTRIB_STATE_CONSTANT) {
                emitConstant();
              } else {
                scope("if(", STATE, "===", ATTRIB_STATE_POINTER, "){");
                emitBuffer();
                scope("}else{");
                emitConstant();
                scope("}");
              }
            }
            attributes.forEach(function(attribute) {
              var name = attribute.name;
              var arg = args.attributes[name];
              var record;
              if (arg) {
                if (!filter(arg)) {
                  return;
                }
                record = arg.append(env, scope);
              } else {
                if (!filter(SCOPE_DECL)) {
                  return;
                }
                var scopeAttrib = env.scopeAttrib(name);
                record = {};
                Object.keys(new AttributeRecord2()).forEach(function(key) {
                  record[key] = scope.def(scopeAttrib, ".", key);
                });
              }
              emitBindAttribute(
                env.link(attribute),
                typeLength(attribute.info.type),
                record
              );
            });
          }
          function emitUniforms(env, scope, args, uniforms, filter, isBatchInnerLoop) {
            var shared = env.shared;
            var GL = shared.gl;
            var infix;
            for (var i = 0; i < uniforms.length; ++i) {
              var uniform = uniforms[i];
              var name = uniform.name;
              var type = uniform.info.type;
              var arg = args.uniforms[name];
              var UNIFORM = env.link(uniform);
              var LOCATION = UNIFORM + ".location";
              var VALUE;
              if (arg) {
                if (!filter(arg)) {
                  continue;
                }
                if (isStatic(arg)) {
                  var value = arg.value;
                  if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
                    var TEX_VALUE = env.link(value._texture || value.color[0]._texture);
                    scope(GL, ".uniform1i(", LOCATION, ",", TEX_VALUE + ".bind());");
                    scope.exit(TEX_VALUE, ".unbind();");
                  } else if (type === GL_FLOAT_MAT2 || type === GL_FLOAT_MAT3 || type === GL_FLOAT_MAT4) {
                    var MAT_VALUE = env.global.def("new Float32Array([" + Array.prototype.slice.call(value) + "])");
                    var dim = 2;
                    if (type === GL_FLOAT_MAT3) {
                      dim = 3;
                    } else if (type === GL_FLOAT_MAT4) {
                      dim = 4;
                    }
                    scope(
                      GL,
                      ".uniformMatrix",
                      dim,
                      "fv(",
                      LOCATION,
                      ",false,",
                      MAT_VALUE,
                      ");"
                    );
                  } else {
                    switch (type) {
                      case GL_FLOAT$7:
                        infix = "1f";
                        break;
                      case GL_FLOAT_VEC2:
                        infix = "2f";
                        break;
                      case GL_FLOAT_VEC3:
                        infix = "3f";
                        break;
                      case GL_FLOAT_VEC4:
                        infix = "4f";
                        break;
                      case GL_BOOL:
                        infix = "1i";
                        break;
                      case GL_INT$2:
                        infix = "1i";
                        break;
                      case GL_BOOL_VEC2:
                        infix = "2i";
                        break;
                      case GL_INT_VEC2:
                        infix = "2i";
                        break;
                      case GL_BOOL_VEC3:
                        infix = "3i";
                        break;
                      case GL_INT_VEC3:
                        infix = "3i";
                        break;
                      case GL_BOOL_VEC4:
                        infix = "4i";
                        break;
                      case GL_INT_VEC4:
                        infix = "4i";
                        break;
                    }
                    scope(
                      GL,
                      ".uniform",
                      infix,
                      "(",
                      LOCATION,
                      ",",
                      isArrayLike(value) ? Array.prototype.slice.call(value) : value,
                      ");"
                    );
                  }
                  continue;
                } else {
                  VALUE = arg.append(env, scope);
                }
              } else {
                if (!filter(SCOPE_DECL)) {
                  continue;
                }
                VALUE = scope.def(shared.uniforms, "[", stringStore.id(name), "]");
              }
              if (type === GL_SAMPLER_2D) {
                scope(
                  "if(",
                  VALUE,
                  "&&",
                  VALUE,
                  '._reglType==="framebuffer"){',
                  VALUE,
                  "=",
                  VALUE,
                  ".color[0];",
                  "}"
                );
              } else if (type === GL_SAMPLER_CUBE) {
                scope(
                  "if(",
                  VALUE,
                  "&&",
                  VALUE,
                  '._reglType==="framebufferCube"){',
                  VALUE,
                  "=",
                  VALUE,
                  ".color[0];",
                  "}"
                );
              }
              var unroll = 1;
              switch (type) {
                case GL_SAMPLER_2D:
                case GL_SAMPLER_CUBE:
                  var TEX = scope.def(VALUE, "._texture");
                  scope(GL, ".uniform1i(", LOCATION, ",", TEX, ".bind());");
                  scope.exit(TEX, ".unbind();");
                  continue;
                case GL_INT$2:
                case GL_BOOL:
                  infix = "1i";
                  break;
                case GL_INT_VEC2:
                case GL_BOOL_VEC2:
                  infix = "2i";
                  unroll = 2;
                  break;
                case GL_INT_VEC3:
                case GL_BOOL_VEC3:
                  infix = "3i";
                  unroll = 3;
                  break;
                case GL_INT_VEC4:
                case GL_BOOL_VEC4:
                  infix = "4i";
                  unroll = 4;
                  break;
                case GL_FLOAT$7:
                  infix = "1f";
                  break;
                case GL_FLOAT_VEC2:
                  infix = "2f";
                  unroll = 2;
                  break;
                case GL_FLOAT_VEC3:
                  infix = "3f";
                  unroll = 3;
                  break;
                case GL_FLOAT_VEC4:
                  infix = "4f";
                  unroll = 4;
                  break;
                case GL_FLOAT_MAT2:
                  infix = "Matrix2fv";
                  break;
                case GL_FLOAT_MAT3:
                  infix = "Matrix3fv";
                  break;
                case GL_FLOAT_MAT4:
                  infix = "Matrix4fv";
                  break;
              }
              if (infix.charAt(0) === "M") {
                scope(GL, ".uniform", infix, "(", LOCATION, ",");
                var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);
                var STORAGE = env.global.def("new Float32Array(", matSize, ")");
                if (Array.isArray(VALUE)) {
                  scope(
                    "false,(",
                    loop(matSize, function(i2) {
                      return STORAGE + "[" + i2 + "]=" + VALUE[i2];
                    }),
                    ",",
                    STORAGE,
                    ")"
                  );
                } else {
                  scope(
                    "false,(Array.isArray(",
                    VALUE,
                    ")||",
                    VALUE,
                    " instanceof Float32Array)?",
                    VALUE,
                    ":(",
                    loop(matSize, function(i2) {
                      return STORAGE + "[" + i2 + "]=" + VALUE + "[" + i2 + "]";
                    }),
                    ",",
                    STORAGE,
                    ")"
                  );
                }
                scope(");");
              } else if (unroll > 1) {
                var prev = [];
                var cur = [];
                for (var j = 0; j < unroll; ++j) {
                  if (Array.isArray(VALUE)) {
                    cur.push(VALUE[j]);
                  } else {
                    cur.push(scope.def(VALUE + "[" + j + "]"));
                  }
                  if (isBatchInnerLoop) {
                    prev.push(scope.def());
                  }
                }
                if (isBatchInnerLoop) {
                  scope("if(!", env.batchId, "||", prev.map(function(p, i2) {
                    return p + "!==" + cur[i2];
                  }).join("||"), "){", prev.map(function(p, i2) {
                    return p + "=" + cur[i2] + ";";
                  }).join(""));
                }
                scope(GL, ".uniform", infix, "(", LOCATION, ",", cur.join(","), ");");
                if (isBatchInnerLoop) {
                  scope("}");
                }
              } else {
                if (isBatchInnerLoop) {
                  var prevS = scope.def();
                  scope(
                    "if(!",
                    env.batchId,
                    "||",
                    prevS,
                    "!==",
                    VALUE,
                    "){",
                    prevS,
                    "=",
                    VALUE,
                    ";"
                  );
                }
                scope(GL, ".uniform", infix, "(", LOCATION, ",", VALUE, ");");
                if (isBatchInnerLoop) {
                  scope("}");
                }
              }
            }
          }
          function emitDraw(env, outer, inner, args) {
            var shared = env.shared;
            var GL = shared.gl;
            var DRAW_STATE = shared.draw;
            var drawOptions = args.draw;
            function emitElements() {
              var defn = drawOptions.elements;
              var ELEMENTS2;
              var scope = outer;
              if (defn) {
                if (defn.contextDep && args.contextDynamic || defn.propDep) {
                  scope = inner;
                }
                ELEMENTS2 = defn.append(env, scope);
                if (drawOptions.elementsActive) {
                  scope(
                    "if(" + ELEMENTS2 + ")" + GL + ".bindBuffer(" + GL_ELEMENT_ARRAY_BUFFER$2 + "," + ELEMENTS2 + ".buffer.buffer);"
                  );
                }
              } else {
                ELEMENTS2 = scope.def();
                scope(
                  ELEMENTS2,
                  "=",
                  DRAW_STATE,
                  ".",
                  S_ELEMENTS,
                  ";",
                  "if(",
                  ELEMENTS2,
                  "){",
                  GL,
                  ".bindBuffer(",
                  GL_ELEMENT_ARRAY_BUFFER$2,
                  ",",
                  ELEMENTS2,
                  ".buffer.buffer);}",
                  "else if(",
                  shared.vao,
                  ".currentVAO){",
                  ELEMENTS2,
                  "=",
                  env.shared.elements + ".getElements(" + shared.vao,
                  ".currentVAO.elements);",
                  !extVertexArrays ? "if(" + ELEMENTS2 + ")" + GL + ".bindBuffer(" + GL_ELEMENT_ARRAY_BUFFER$2 + "," + ELEMENTS2 + ".buffer.buffer);" : "",
                  "}"
                );
              }
              return ELEMENTS2;
            }
            function emitCount() {
              var defn = drawOptions.count;
              var COUNT2;
              var scope = outer;
              if (defn) {
                if (defn.contextDep && args.contextDynamic || defn.propDep) {
                  scope = inner;
                }
                COUNT2 = defn.append(env, scope);
              } else {
                COUNT2 = scope.def(DRAW_STATE, ".", S_COUNT);
              }
              return COUNT2;
            }
            var ELEMENTS = emitElements();
            function emitValue(name) {
              var defn = drawOptions[name];
              if (defn) {
                if (defn.contextDep && args.contextDynamic || defn.propDep) {
                  return defn.append(env, inner);
                } else {
                  return defn.append(env, outer);
                }
              } else {
                return outer.def(DRAW_STATE, ".", name);
              }
            }
            var PRIMITIVE = emitValue(S_PRIMITIVE);
            var OFFSET = emitValue(S_OFFSET);
            var COUNT = emitCount();
            if (typeof COUNT === "number") {
              if (COUNT === 0) {
                return;
              }
            } else {
              inner("if(", COUNT, "){");
              inner.exit("}");
            }
            var INSTANCES, EXT_INSTANCING;
            if (extInstancing) {
              INSTANCES = emitValue(S_INSTANCES);
              EXT_INSTANCING = env.instancing;
            }
            var ELEMENT_TYPE = ELEMENTS + ".type";
            var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements) && !drawOptions.vaoActive;
            function emitInstancing() {
              function drawElements() {
                inner(EXT_INSTANCING, ".drawElementsInstancedANGLE(", [
                  PRIMITIVE,
                  COUNT,
                  ELEMENT_TYPE,
                  OFFSET + "<<((" + ELEMENT_TYPE + "-" + GL_UNSIGNED_BYTE$7 + ")>>1)",
                  INSTANCES
                ], ");");
              }
              function drawArrays() {
                inner(
                  EXT_INSTANCING,
                  ".drawArraysInstancedANGLE(",
                  [PRIMITIVE, OFFSET, COUNT, INSTANCES],
                  ");"
                );
              }
              if (ELEMENTS && ELEMENTS !== "null") {
                if (!elementsStatic) {
                  inner("if(", ELEMENTS, "){");
                  drawElements();
                  inner("}else{");
                  drawArrays();
                  inner("}");
                } else {
                  drawElements();
                }
              } else {
                drawArrays();
              }
            }
            function emitRegular() {
              function drawElements() {
                inner(GL + ".drawElements(" + [
                  PRIMITIVE,
                  COUNT,
                  ELEMENT_TYPE,
                  OFFSET + "<<((" + ELEMENT_TYPE + "-" + GL_UNSIGNED_BYTE$7 + ")>>1)"
                ] + ");");
              }
              function drawArrays() {
                inner(GL + ".drawArrays(" + [PRIMITIVE, OFFSET, COUNT] + ");");
              }
              if (ELEMENTS && ELEMENTS !== "null") {
                if (!elementsStatic) {
                  inner("if(", ELEMENTS, "){");
                  drawElements();
                  inner("}else{");
                  drawArrays();
                  inner("}");
                } else {
                  drawElements();
                }
              } else {
                drawArrays();
              }
            }
            if (extInstancing && (typeof INSTANCES !== "number" || INSTANCES >= 0)) {
              if (typeof INSTANCES === "string") {
                inner("if(", INSTANCES, ">0){");
                emitInstancing();
                inner("}else if(", INSTANCES, "<0){");
                emitRegular();
                inner("}");
              } else {
                emitInstancing();
              }
            } else {
              emitRegular();
            }
          }
          function createBody(emitBody, parentEnv, args, program, count) {
            var env = createREGLEnvironment();
            var scope = env.proc("body", count);
            if (extInstancing) {
              env.instancing = scope.def(
                env.shared.extensions,
                ".angle_instanced_arrays"
              );
            }
            emitBody(env, scope, args, program);
            return env.compile().body;
          }
          function emitDrawBody(env, draw, args, program) {
            injectExtensions(env, draw);
            if (args.useVAO) {
              if (args.drawVAO) {
                draw(env.shared.vao, ".setVAO(", args.drawVAO.append(env, draw), ");");
              } else {
                draw(env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
              }
            } else {
              draw(env.shared.vao, ".setVAO(null);");
              emitAttributes(env, draw, args, program.attributes, function() {
                return true;
              });
            }
            emitUniforms(env, draw, args, program.uniforms, function() {
              return true;
            }, false);
            emitDraw(env, draw, draw, args);
          }
          function emitDrawProc(env, args) {
            var draw = env.proc("draw", 1);
            injectExtensions(env, draw);
            emitContext(env, draw, args.context);
            emitPollFramebuffer(env, draw, args.framebuffer);
            emitPollState(env, draw, args);
            emitSetOptions(env, draw, args.state);
            emitProfile(env, draw, args, false, true);
            var program = args.shader.progVar.append(env, draw);
            draw(env.shared.gl, ".useProgram(", program, ".program);");
            if (args.shader.program) {
              emitDrawBody(env, draw, args, args.shader.program);
            } else {
              draw(env.shared.vao, ".setVAO(null);");
              var drawCache = env.global.def("{}");
              var PROG_ID = draw.def(program, ".id");
              var CACHED_PROC = draw.def(drawCache, "[", PROG_ID, "]");
              draw(
                env.cond(CACHED_PROC).then(CACHED_PROC, ".call(this,a0);").else(
                  CACHED_PROC,
                  "=",
                  drawCache,
                  "[",
                  PROG_ID,
                  "]=",
                  env.link(function(program2) {
                    return createBody(emitDrawBody, env, args, program2, 1);
                  }),
                  "(",
                  program,
                  ");",
                  CACHED_PROC,
                  ".call(this,a0);"
                )
              );
            }
            if (Object.keys(args.state).length > 0) {
              draw(env.shared.current, ".dirty=true;");
            }
            if (env.shared.vao) {
              draw(env.shared.vao, ".setVAO(null);");
            }
          }
          function emitBatchDynamicShaderBody(env, scope, args, program) {
            env.batchId = "a1";
            injectExtensions(env, scope);
            function all() {
              return true;
            }
            emitAttributes(env, scope, args, program.attributes, all);
            emitUniforms(env, scope, args, program.uniforms, all, false);
            emitDraw(env, scope, scope, args);
          }
          function emitBatchBody(env, scope, args, program) {
            injectExtensions(env, scope);
            var contextDynamic = args.contextDep;
            var BATCH_ID = scope.def();
            var PROP_LIST = "a0";
            var NUM_PROPS = "a1";
            var PROPS = scope.def();
            env.shared.props = PROPS;
            env.batchId = BATCH_ID;
            var outer = env.scope();
            var inner = env.scope();
            scope(
              outer.entry,
              "for(",
              BATCH_ID,
              "=0;",
              BATCH_ID,
              "<",
              NUM_PROPS,
              ";++",
              BATCH_ID,
              "){",
              PROPS,
              "=",
              PROP_LIST,
              "[",
              BATCH_ID,
              "];",
              inner,
              "}",
              outer.exit
            );
            function isInnerDefn(defn) {
              return defn.contextDep && contextDynamic || defn.propDep;
            }
            function isOuterDefn(defn) {
              return !isInnerDefn(defn);
            }
            if (args.needsContext) {
              emitContext(env, inner, args.context);
            }
            if (args.needsFramebuffer) {
              emitPollFramebuffer(env, inner, args.framebuffer);
            }
            emitSetOptions(env, inner, args.state, isInnerDefn);
            if (args.profile && isInnerDefn(args.profile)) {
              emitProfile(env, inner, args, false, true);
            }
            if (!program) {
              var progCache = env.global.def("{}");
              var PROGRAM = args.shader.progVar.append(env, inner);
              var PROG_ID = inner.def(PROGRAM, ".id");
              var CACHED_PROC = inner.def(progCache, "[", PROG_ID, "]");
              inner(
                env.shared.gl,
                ".useProgram(",
                PROGRAM,
                ".program);",
                "if(!",
                CACHED_PROC,
                "){",
                CACHED_PROC,
                "=",
                progCache,
                "[",
                PROG_ID,
                "]=",
                env.link(function(program2) {
                  return createBody(
                    emitBatchDynamicShaderBody,
                    env,
                    args,
                    program2,
                    2
                  );
                }),
                "(",
                PROGRAM,
                ");}",
                CACHED_PROC,
                ".call(this,a0[",
                BATCH_ID,
                "],",
                BATCH_ID,
                ");"
              );
            } else {
              if (args.useVAO) {
                if (args.drawVAO) {
                  if (isInnerDefn(args.drawVAO)) {
                    inner(env.shared.vao, ".setVAO(", args.drawVAO.append(env, inner), ");");
                  } else {
                    outer(env.shared.vao, ".setVAO(", args.drawVAO.append(env, outer), ");");
                  }
                } else {
                  outer(env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
                }
              } else {
                outer(env.shared.vao, ".setVAO(null);");
                emitAttributes(env, outer, args, program.attributes, isOuterDefn);
                emitAttributes(env, inner, args, program.attributes, isInnerDefn);
              }
              emitUniforms(env, outer, args, program.uniforms, isOuterDefn, false);
              emitUniforms(env, inner, args, program.uniforms, isInnerDefn, true);
              emitDraw(env, outer, inner, args);
            }
          }
          function emitBatchProc(env, args) {
            var batch = env.proc("batch", 2);
            env.batchId = "0";
            injectExtensions(env, batch);
            var contextDynamic = false;
            var needsContext = true;
            Object.keys(args.context).forEach(function(name) {
              contextDynamic = contextDynamic || args.context[name].propDep;
            });
            if (!contextDynamic) {
              emitContext(env, batch, args.context);
              needsContext = false;
            }
            var framebuffer = args.framebuffer;
            var needsFramebuffer = false;
            if (framebuffer) {
              if (framebuffer.propDep) {
                contextDynamic = needsFramebuffer = true;
              } else if (framebuffer.contextDep && contextDynamic) {
                needsFramebuffer = true;
              }
              if (!needsFramebuffer) {
                emitPollFramebuffer(env, batch, framebuffer);
              }
            } else {
              emitPollFramebuffer(env, batch, null);
            }
            if (args.state.viewport && args.state.viewport.propDep) {
              contextDynamic = true;
            }
            function isInnerDefn(defn) {
              return defn.contextDep && contextDynamic || defn.propDep;
            }
            emitPollState(env, batch, args);
            emitSetOptions(env, batch, args.state, function(defn) {
              return !isInnerDefn(defn);
            });
            if (!args.profile || !isInnerDefn(args.profile)) {
              emitProfile(env, batch, args, false, "a1");
            }
            args.contextDep = contextDynamic;
            args.needsContext = needsContext;
            args.needsFramebuffer = needsFramebuffer;
            var progDefn = args.shader.progVar;
            if (progDefn.contextDep && contextDynamic || progDefn.propDep) {
              emitBatchBody(
                env,
                batch,
                args,
                null
              );
            } else {
              var PROGRAM = progDefn.append(env, batch);
              batch(env.shared.gl, ".useProgram(", PROGRAM, ".program);");
              if (args.shader.program) {
                emitBatchBody(
                  env,
                  batch,
                  args,
                  args.shader.program
                );
              } else {
                batch(env.shared.vao, ".setVAO(null);");
                var batchCache = env.global.def("{}");
                var PROG_ID = batch.def(PROGRAM, ".id");
                var CACHED_PROC = batch.def(batchCache, "[", PROG_ID, "]");
                batch(
                  env.cond(CACHED_PROC).then(CACHED_PROC, ".call(this,a0,a1);").else(
                    CACHED_PROC,
                    "=",
                    batchCache,
                    "[",
                    PROG_ID,
                    "]=",
                    env.link(function(program) {
                      return createBody(emitBatchBody, env, args, program, 2);
                    }),
                    "(",
                    PROGRAM,
                    ");",
                    CACHED_PROC,
                    ".call(this,a0,a1);"
                  )
                );
              }
            }
            if (Object.keys(args.state).length > 0) {
              batch(env.shared.current, ".dirty=true;");
            }
            if (env.shared.vao) {
              batch(env.shared.vao, ".setVAO(null);");
            }
          }
          function emitScopeProc(env, args) {
            var scope = env.proc("scope", 3);
            env.batchId = "a2";
            var shared = env.shared;
            var CURRENT_STATE = shared.current;
            emitContext(env, scope, args.context);
            if (args.framebuffer) {
              args.framebuffer.append(env, scope);
            }
            sortState(Object.keys(args.state)).forEach(function(name) {
              var defn = args.state[name];
              var value = defn.append(env, scope);
              if (isArrayLike(value)) {
                value.forEach(function(v, i) {
                  if (hasVariableReference(v)) {
                    scope.set(env.next[name], "[" + i + "]", v);
                  } else {
                    scope.set(env.next[name], "[" + i + "]", env.link(v, { stable: true }));
                  }
                });
              } else {
                if (isStatic(defn)) {
                  scope.set(shared.next, "." + name, env.link(value, { stable: true }));
                } else {
                  scope.set(shared.next, "." + name, value);
                }
              }
            });
            emitProfile(env, scope, args, true, true);
            [S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
              function(opt) {
                var variable = args.draw[opt];
                if (!variable) {
                  return;
                }
                var VARIABLE2 = variable.append(env, scope);
                if (hasVariableReference(VARIABLE2)) {
                  scope.set(shared.draw, "." + opt, VARIABLE2);
                } else {
                  scope.set(shared.draw, "." + opt, env.link(VARIABLE2), { stable: true });
                }
              }
            );
            Object.keys(args.uniforms).forEach(function(opt) {
              var value = args.uniforms[opt].append(env, scope);
              if (Array.isArray(value)) {
                value = "[" + value.map(function(v) {
                  if (hasVariableReference(v)) {
                    return v;
                  } else {
                    return env.link(v, { stable: true });
                  }
                }) + "]";
              }
              scope.set(
                shared.uniforms,
                "[" + env.link(stringStore.id(opt), { stable: true }) + "]",
                value
              );
            });
            Object.keys(args.attributes).forEach(function(name) {
              var record = args.attributes[name].append(env, scope);
              var scopeAttrib = env.scopeAttrib(name);
              Object.keys(new AttributeRecord2()).forEach(function(prop) {
                scope.set(scopeAttrib, "." + prop, record[prop]);
              });
            });
            if (args.scopeVAO) {
              var VARIABLE = args.scopeVAO.append(env, scope);
              if (hasVariableReference(VARIABLE)) {
                scope.set(shared.vao, ".targetVAO", VARIABLE);
              } else {
                scope.set(shared.vao, ".targetVAO", env.link(VARIABLE, { stable: true }));
              }
            }
            function saveShader(name) {
              var shader = args.shader[name];
              if (shader) {
                var VARIABLE2 = shader.append(env, scope);
                if (hasVariableReference(VARIABLE2)) {
                  scope.set(shared.shader, "." + name, VARIABLE2);
                } else {
                  scope.set(shared.shader, "." + name, env.link(VARIABLE2, { stable: true }));
                }
              }
            }
            saveShader(S_VERT);
            saveShader(S_FRAG);
            if (Object.keys(args.state).length > 0) {
              scope(CURRENT_STATE, ".dirty=true;");
              scope.exit(CURRENT_STATE, ".dirty=true;");
            }
            scope("a1(", env.shared.context, ",a0,", env.batchId, ");");
          }
          function isDynamicObject(object) {
            if (typeof object !== "object" || isArrayLike(object)) {
              return;
            }
            var props = Object.keys(object);
            for (var i = 0; i < props.length; ++i) {
              if (dynamic.isDynamic(object[props[i]])) {
                return true;
              }
            }
            return false;
          }
          function splatObject(env, options, name) {
            var object = options.static[name];
            if (!object || !isDynamicObject(object)) {
              return;
            }
            var globals = env.global;
            var keys = Object.keys(object);
            var thisDep = false;
            var contextDep = false;
            var propDep = false;
            var objectRef = env.global.def("{}");
            keys.forEach(function(key) {
              var value = object[key];
              if (dynamic.isDynamic(value)) {
                if (typeof value === "function") {
                  value = object[key] = dynamic.unbox(value);
                }
                var deps = createDynamicDecl(value, null);
                thisDep = thisDep || deps.thisDep;
                propDep = propDep || deps.propDep;
                contextDep = contextDep || deps.contextDep;
              } else {
                globals(objectRef, ".", key, "=");
                switch (typeof value) {
                  case "number":
                    globals(value);
                    break;
                  case "string":
                    globals('"', value, '"');
                    break;
                  case "object":
                    if (Array.isArray(value)) {
                      globals("[", value.join(), "]");
                    }
                    break;
                  default:
                    globals(env.link(value));
                    break;
                }
                globals(";");
              }
            });
            function appendBlock(env2, block) {
              keys.forEach(function(key) {
                var value = object[key];
                if (!dynamic.isDynamic(value)) {
                  return;
                }
                var ref = env2.invoke(block, value);
                block(objectRef, ".", key, "=", ref, ";");
              });
            }
            options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
              thisDep,
              contextDep,
              propDep,
              ref: objectRef,
              append: appendBlock
            });
            delete options.static[name];
          }
          function compileCommand(options, attributes, uniforms, context, stats2) {
            var env = createREGLEnvironment();
            env.stats = env.link(stats2);
            Object.keys(attributes.static).forEach(function(key) {
              splatObject(env, attributes, key);
            });
            NESTED_OPTIONS.forEach(function(name) {
              splatObject(env, options, name);
            });
            var args = parseArguments(options, attributes, uniforms, context, env);
            if (args.shader.program) {
              args.shader.program.attributes.sort(function(a, b) {
                return a.name < b.name ? -1 : 1;
              });
              args.shader.program.uniforms.sort(function(a, b) {
                return a.name < b.name ? -1 : 1;
              });
            }
            emitDrawProc(env, args);
            emitScopeProc(env, args);
            emitBatchProc(env, args);
            return extend(env.compile(), {
              destroy: function() {
                args.shader.program.destroy();
              }
            });
          }
          return {
            next: nextState,
            current: currentState,
            procs: function() {
              var env = createREGLEnvironment();
              var poll = env.proc("poll");
              var refresh = env.proc("refresh");
              var common = env.block();
              poll(common);
              refresh(common);
              var shared = env.shared;
              var GL = shared.gl;
              var NEXT_STATE = shared.next;
              var CURRENT_STATE = shared.current;
              common(CURRENT_STATE, ".dirty=false;");
              emitPollFramebuffer(env, poll);
              emitPollFramebuffer(env, refresh, null, true);
              var INSTANCING;
              if (extInstancing) {
                INSTANCING = env.link(extInstancing);
              }
              if (extensions.oes_vertex_array_object) {
                refresh(env.link(extensions.oes_vertex_array_object), ".bindVertexArrayOES(null);");
              }
              var BINDING = refresh.def(shared.attributes);
              var TEMP_BINDING = refresh.def(0);
              var ifte = env.cond(TEMP_BINDING, ".buffer");
              ifte.then(
                GL,
                ".enableVertexAttribArray(i);",
                GL,
                ".bindBuffer(",
                GL_ARRAY_BUFFER$2,
                ",",
                TEMP_BINDING,
                ".buffer.buffer);",
                GL,
                ".vertexAttribPointer(i,",
                TEMP_BINDING,
                ".size,",
                TEMP_BINDING,
                ".type,",
                TEMP_BINDING,
                ".normalized,",
                TEMP_BINDING,
                ".stride,",
                TEMP_BINDING,
                ".offset);"
              ).else(
                GL,
                ".disableVertexAttribArray(i);",
                GL,
                ".vertexAttrib4f(i,",
                TEMP_BINDING,
                ".x,",
                TEMP_BINDING,
                ".y,",
                TEMP_BINDING,
                ".z,",
                TEMP_BINDING,
                ".w);",
                TEMP_BINDING,
                ".buffer=null;"
              );
              var MAX_ATTRIBUTES = env.link(limits.maxAttributes, { stable: true });
              refresh(
                "for(var i=0;i<",
                MAX_ATTRIBUTES,
                ";++i){",
                TEMP_BINDING,
                "=",
                BINDING,
                "[i];",
                ifte,
                "}"
              );
              if (extInstancing) {
                refresh(
                  "for(var i=0;i<",
                  MAX_ATTRIBUTES,
                  ";++i){",
                  INSTANCING,
                  ".vertexAttribDivisorANGLE(i,",
                  BINDING,
                  "[i].divisor);",
                  "}"
                );
              }
              refresh(
                env.shared.vao,
                ".currentVAO=null;",
                env.shared.vao,
                ".setVAO(",
                env.shared.vao,
                ".targetVAO);"
              );
              Object.keys(GL_FLAGS).forEach(function(flag) {
                var cap = GL_FLAGS[flag];
                var NEXT = common.def(NEXT_STATE, ".", flag);
                var block = env.block();
                block(
                  "if(",
                  NEXT,
                  "){",
                  GL,
                  ".enable(",
                  cap,
                  ")}else{",
                  GL,
                  ".disable(",
                  cap,
                  ")}",
                  CURRENT_STATE,
                  ".",
                  flag,
                  "=",
                  NEXT,
                  ";"
                );
                refresh(block);
                poll(
                  "if(",
                  NEXT,
                  "!==",
                  CURRENT_STATE,
                  ".",
                  flag,
                  "){",
                  block,
                  "}"
                );
              });
              Object.keys(GL_VARIABLES).forEach(function(name) {
                var func = GL_VARIABLES[name];
                var init = currentState[name];
                var NEXT, CURRENT;
                var block = env.block();
                block(GL, ".", func, "(");
                if (isArrayLike(init)) {
                  var n = init.length;
                  NEXT = env.global.def(NEXT_STATE, ".", name);
                  CURRENT = env.global.def(CURRENT_STATE, ".", name);
                  block(
                    loop(n, function(i) {
                      return NEXT + "[" + i + "]";
                    }),
                    ");",
                    loop(n, function(i) {
                      return CURRENT + "[" + i + "]=" + NEXT + "[" + i + "];";
                    }).join("")
                  );
                  poll(
                    "if(",
                    loop(n, function(i) {
                      return NEXT + "[" + i + "]!==" + CURRENT + "[" + i + "]";
                    }).join("||"),
                    "){",
                    block,
                    "}"
                  );
                } else {
                  NEXT = common.def(NEXT_STATE, ".", name);
                  CURRENT = common.def(CURRENT_STATE, ".", name);
                  block(
                    NEXT,
                    ");",
                    CURRENT_STATE,
                    ".",
                    name,
                    "=",
                    NEXT,
                    ";"
                  );
                  poll(
                    "if(",
                    NEXT,
                    "!==",
                    CURRENT,
                    "){",
                    block,
                    "}"
                  );
                }
                refresh(block);
              });
              return env.compile();
            }(),
            compile: compileCommand
          };
        }
        function stats() {
          return {
            vaoCount: 0,
            bufferCount: 0,
            elementsCount: 0,
            framebufferCount: 0,
            shaderCount: 0,
            textureCount: 0,
            cubeCount: 0,
            renderbufferCount: 0,
            maxTextureUnits: 0
          };
        }
        var GL_QUERY_RESULT_EXT = 34918;
        var GL_QUERY_RESULT_AVAILABLE_EXT = 34919;
        var GL_TIME_ELAPSED_EXT = 35007;
        var createTimer = function(gl, extensions) {
          if (!extensions.ext_disjoint_timer_query) {
            return null;
          }
          var queryPool = [];
          function allocQuery() {
            return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT();
          }
          function freeQuery(query) {
            queryPool.push(query);
          }
          var pendingQueries = [];
          function beginQuery(stats2) {
            var query = allocQuery();
            extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);
            pendingQueries.push(query);
            pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats2);
          }
          function endQuery() {
            extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT);
          }
          function PendingStats() {
            this.startQueryIndex = -1;
            this.endQueryIndex = -1;
            this.sum = 0;
            this.stats = null;
          }
          var pendingStatsPool = [];
          function allocPendingStats() {
            return pendingStatsPool.pop() || new PendingStats();
          }
          function freePendingStats(pendingStats2) {
            pendingStatsPool.push(pendingStats2);
          }
          var pendingStats = [];
          function pushScopeStats(start, end, stats2) {
            var ps = allocPendingStats();
            ps.startQueryIndex = start;
            ps.endQueryIndex = end;
            ps.sum = 0;
            ps.stats = stats2;
            pendingStats.push(ps);
          }
          var timeSum = [];
          var queryPtr = [];
          function update() {
            var ptr, i;
            var n = pendingQueries.length;
            if (n === 0) {
              return;
            }
            queryPtr.length = Math.max(queryPtr.length, n + 1);
            timeSum.length = Math.max(timeSum.length, n + 1);
            timeSum[0] = 0;
            queryPtr[0] = 0;
            var queryTime = 0;
            ptr = 0;
            for (i = 0; i < pendingQueries.length; ++i) {
              var query = pendingQueries[i];
              if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
                queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);
                freeQuery(query);
              } else {
                pendingQueries[ptr++] = query;
              }
              timeSum[i + 1] = queryTime;
              queryPtr[i + 1] = ptr;
            }
            pendingQueries.length = ptr;
            ptr = 0;
            for (i = 0; i < pendingStats.length; ++i) {
              var stats2 = pendingStats[i];
              var start = stats2.startQueryIndex;
              var end = stats2.endQueryIndex;
              stats2.sum += timeSum[end] - timeSum[start];
              var startPtr = queryPtr[start];
              var endPtr = queryPtr[end];
              if (endPtr === startPtr) {
                stats2.stats.gpuTime += stats2.sum / 1e6;
                freePendingStats(stats2);
              } else {
                stats2.startQueryIndex = startPtr;
                stats2.endQueryIndex = endPtr;
                pendingStats[ptr++] = stats2;
              }
            }
            pendingStats.length = ptr;
          }
          return {
            beginQuery,
            endQuery,
            pushScopeStats,
            update,
            getNumPendingQueries: function() {
              return pendingQueries.length;
            },
            clear: function() {
              queryPool.push.apply(queryPool, pendingQueries);
              for (var i = 0; i < queryPool.length; i++) {
                extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i]);
              }
              pendingQueries.length = 0;
              queryPool.length = 0;
            },
            restore: function() {
              pendingQueries.length = 0;
              queryPool.length = 0;
            }
          };
        };
        var GL_COLOR_BUFFER_BIT = 16384;
        var GL_DEPTH_BUFFER_BIT = 256;
        var GL_STENCIL_BUFFER_BIT = 1024;
        var GL_ARRAY_BUFFER = 34962;
        var CONTEXT_LOST_EVENT = "webglcontextlost";
        var CONTEXT_RESTORED_EVENT = "webglcontextrestored";
        var DYN_PROP = 1;
        var DYN_CONTEXT = 2;
        var DYN_STATE = 3;
        function find(haystack, needle) {
          for (var i = 0; i < haystack.length; ++i) {
            if (haystack[i] === needle) {
              return i;
            }
          }
          return -1;
        }
        function wrapREGL(args) {
          var config = parseArgs(args);
          if (!config) {
            return null;
          }
          var gl = config.gl;
          var glAttributes = gl.getContextAttributes();
          var contextLost = gl.isContextLost();
          var extensionState = createExtensionCache(gl, config);
          if (!extensionState) {
            return null;
          }
          var stringStore = createStringStore();
          var stats$$1 = stats();
          var cachedCode = config.cachedCode || {};
          var extensions = extensionState.extensions;
          var timer = createTimer(gl, extensions);
          var START_TIME = clock();
          var WIDTH = gl.drawingBufferWidth;
          var HEIGHT = gl.drawingBufferHeight;
          var contextState = {
            tick: 0,
            time: 0,
            viewportWidth: WIDTH,
            viewportHeight: HEIGHT,
            framebufferWidth: WIDTH,
            framebufferHeight: HEIGHT,
            drawingBufferWidth: WIDTH,
            drawingBufferHeight: HEIGHT,
            pixelRatio: config.pixelRatio
          };
          var uniformState = {};
          var drawState = {
            elements: null,
            primitive: 4,
            // GL_TRIANGLES
            count: -1,
            offset: 0,
            instances: -1
          };
          var limits = wrapLimits(gl, extensions);
          var bufferState = wrapBufferState(
            gl,
            stats$$1,
            config,
            destroyBuffer
          );
          var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1);
          var attributeState = wrapAttributeState(
            gl,
            extensions,
            limits,
            stats$$1,
            bufferState,
            elementState,
            drawState
          );
          function destroyBuffer(buffer) {
            return attributeState.destroyBuffer(buffer);
          }
          var shaderState = wrapShaderState(gl, stringStore, stats$$1, config);
          var textureState = createTextureSet(
            gl,
            extensions,
            limits,
            function() {
              core.procs.poll();
            },
            contextState,
            stats$$1,
            config
          );
          var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config);
          var framebufferState = wrapFBOState(
            gl,
            extensions,
            limits,
            textureState,
            renderbufferState,
            stats$$1
          );
          var core = reglCore(
            gl,
            stringStore,
            extensions,
            limits,
            bufferState,
            elementState,
            textureState,
            framebufferState,
            uniformState,
            attributeState,
            shaderState,
            drawState,
            contextState,
            timer,
            cachedCode,
            config
          );
          var readPixels = wrapReadPixels(
            gl,
            framebufferState,
            core.procs.poll,
            contextState,
            glAttributes,
            extensions,
            limits
          );
          var nextState = core.next;
          var canvas = gl.canvas;
          var rafCallbacks = [];
          var lossCallbacks = [];
          var restoreCallbacks = [];
          var destroyCallbacks = [config.onDestroy];
          var activeRAF = null;
          function handleRAF() {
            if (rafCallbacks.length === 0) {
              if (timer) {
                timer.update();
              }
              activeRAF = null;
              return;
            }
            activeRAF = raf.next(handleRAF);
            poll();
            for (var i = rafCallbacks.length - 1; i >= 0; --i) {
              var cb = rafCallbacks[i];
              if (cb) {
                cb(contextState, null, 0);
              }
            }
            gl.flush();
            if (timer) {
              timer.update();
            }
          }
          function startRAF() {
            if (!activeRAF && rafCallbacks.length > 0) {
              activeRAF = raf.next(handleRAF);
            }
          }
          function stopRAF() {
            if (activeRAF) {
              raf.cancel(handleRAF);
              activeRAF = null;
            }
          }
          function handleContextLoss(event) {
            event.preventDefault();
            contextLost = true;
            stopRAF();
            lossCallbacks.forEach(function(cb) {
              cb();
            });
          }
          function handleContextRestored(event) {
            gl.getError();
            contextLost = false;
            extensionState.restore();
            shaderState.restore();
            bufferState.restore();
            textureState.restore();
            renderbufferState.restore();
            framebufferState.restore();
            attributeState.restore();
            if (timer) {
              timer.restore();
            }
            core.procs.refresh();
            startRAF();
            restoreCallbacks.forEach(function(cb) {
              cb();
            });
          }
          if (canvas) {
            canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);
            canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);
          }
          function destroy() {
            rafCallbacks.length = 0;
            stopRAF();
            if (canvas) {
              canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);
              canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);
            }
            shaderState.clear();
            framebufferState.clear();
            renderbufferState.clear();
            attributeState.clear();
            textureState.clear();
            elementState.clear();
            bufferState.clear();
            if (timer) {
              timer.clear();
            }
            destroyCallbacks.forEach(function(cb) {
              cb();
            });
          }
          function compileProcedure(options) {
            function flattenNestedOptions(options2) {
              var result = extend({}, options2);
              delete result.uniforms;
              delete result.attributes;
              delete result.context;
              delete result.vao;
              if ("stencil" in result && result.stencil.op) {
                result.stencil.opBack = result.stencil.opFront = result.stencil.op;
                delete result.stencil.op;
              }
              function merge(name) {
                if (name in result) {
                  var child = result[name];
                  delete result[name];
                  Object.keys(child).forEach(function(prop) {
                    result[name + "." + prop] = child[prop];
                  });
                }
              }
              merge("blend");
              merge("depth");
              merge("cull");
              merge("stencil");
              merge("polygonOffset");
              merge("scissor");
              merge("sample");
              if ("vao" in options2) {
                result.vao = options2.vao;
              }
              return result;
            }
            function separateDynamic(object, useArrays) {
              var staticItems = {};
              var dynamicItems = {};
              Object.keys(object).forEach(function(option) {
                var value = object[option];
                if (dynamic.isDynamic(value)) {
                  dynamicItems[option] = dynamic.unbox(value, option);
                  return;
                } else if (useArrays && Array.isArray(value)) {
                  for (var i = 0; i < value.length; ++i) {
                    if (dynamic.isDynamic(value[i])) {
                      dynamicItems[option] = dynamic.unbox(value, option);
                      return;
                    }
                  }
                }
                staticItems[option] = value;
              });
              return {
                dynamic: dynamicItems,
                static: staticItems
              };
            }
            var context = separateDynamic(options.context || {}, true);
            var uniforms = separateDynamic(options.uniforms || {}, true);
            var attributes = separateDynamic(options.attributes || {}, false);
            var opts = separateDynamic(flattenNestedOptions(options), false);
            var stats$$12 = {
              gpuTime: 0,
              cpuTime: 0,
              count: 0
            };
            var compiled = core.compile(opts, attributes, uniforms, context, stats$$12);
            var draw = compiled.draw;
            var batch = compiled.batch;
            var scope = compiled.scope;
            var EMPTY_ARRAY = [];
            function reserve(count) {
              while (EMPTY_ARRAY.length < count) {
                EMPTY_ARRAY.push(null);
              }
              return EMPTY_ARRAY;
            }
            function REGLCommand(args2, body) {
              var i;
              if (contextLost) {
              }
              if (typeof args2 === "function") {
                return scope.call(this, null, args2, 0);
              } else if (typeof body === "function") {
                if (typeof args2 === "number") {
                  for (i = 0; i < args2; ++i) {
                    scope.call(this, null, body, i);
                  }
                } else if (Array.isArray(args2)) {
                  for (i = 0; i < args2.length; ++i) {
                    scope.call(this, args2[i], body, i);
                  }
                } else {
                  return scope.call(this, args2, body, 0);
                }
              } else if (typeof args2 === "number") {
                if (args2 > 0) {
                  return batch.call(this, reserve(args2 | 0), args2 | 0);
                }
              } else if (Array.isArray(args2)) {
                if (args2.length) {
                  return batch.call(this, args2, args2.length);
                }
              } else {
                return draw.call(this, args2);
              }
            }
            return extend(REGLCommand, {
              stats: stats$$12,
              destroy: function() {
                compiled.destroy();
              }
            });
          }
          var setFBO = framebufferState.setFBO = compileProcedure({
            framebuffer: dynamic.define.call(null, DYN_PROP, "framebuffer")
          });
          function clearImpl(_, options) {
            var clearFlags = 0;
            core.procs.poll();
            var c = options.color;
            if (c) {
              gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0);
              clearFlags |= GL_COLOR_BUFFER_BIT;
            }
            if ("depth" in options) {
              gl.clearDepth(+options.depth);
              clearFlags |= GL_DEPTH_BUFFER_BIT;
            }
            if ("stencil" in options) {
              gl.clearStencil(options.stencil | 0);
              clearFlags |= GL_STENCIL_BUFFER_BIT;
            }
            gl.clear(clearFlags);
          }
          function clear(options) {
            if ("framebuffer" in options) {
              if (options.framebuffer && options.framebuffer_reglType === "framebufferCube") {
                for (var i = 0; i < 6; ++i) {
                  setFBO(extend({
                    framebuffer: options.framebuffer.faces[i]
                  }, options), clearImpl);
                }
              } else {
                setFBO(options, clearImpl);
              }
            } else {
              clearImpl(null, options);
            }
          }
          function frame(cb) {
            rafCallbacks.push(cb);
            function cancel() {
              var i = find(rafCallbacks, cb);
              function pendingCancel() {
                var index = find(rafCallbacks, pendingCancel);
                rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1];
                rafCallbacks.length -= 1;
                if (rafCallbacks.length <= 0) {
                  stopRAF();
                }
              }
              rafCallbacks[i] = pendingCancel;
            }
            startRAF();
            return {
              cancel
            };
          }
          function pollViewport() {
            var viewport = nextState.viewport;
            var scissorBox = nextState.scissor_box;
            viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;
            contextState.viewportWidth = contextState.framebufferWidth = contextState.drawingBufferWidth = viewport[2] = scissorBox[2] = gl.drawingBufferWidth;
            contextState.viewportHeight = contextState.framebufferHeight = contextState.drawingBufferHeight = viewport[3] = scissorBox[3] = gl.drawingBufferHeight;
          }
          function poll() {
            contextState.tick += 1;
            contextState.time = now();
            pollViewport();
            core.procs.poll();
          }
          function refresh() {
            textureState.refresh();
            pollViewport();
            core.procs.refresh();
            if (timer) {
              timer.update();
            }
          }
          function now() {
            return (clock() - START_TIME) / 1e3;
          }
          refresh();
          function addListener(event, callback) {
            var callbacks;
            switch (event) {
              case "frame":
                return frame(callback);
              case "lost":
                callbacks = lossCallbacks;
                break;
              case "restore":
                callbacks = restoreCallbacks;
                break;
              case "destroy":
                callbacks = destroyCallbacks;
                break;
              default:
            }
            callbacks.push(callback);
            return {
              cancel: function() {
                for (var i = 0; i < callbacks.length; ++i) {
                  if (callbacks[i] === callback) {
                    callbacks[i] = callbacks[callbacks.length - 1];
                    callbacks.pop();
                    return;
                  }
                }
              }
            };
          }
          function getCachedCode() {
            return cachedCode;
          }
          function preloadCachedCode(moreCache) {
            Object.entries(moreCache).forEach(function(kv) {
              cachedCode[kv[0]] = kv[1];
            });
          }
          var regl = extend(compileProcedure, {
            // Clear current FBO
            clear,
            // Short cuts for dynamic variables
            prop: dynamic.define.bind(null, DYN_PROP),
            context: dynamic.define.bind(null, DYN_CONTEXT),
            this: dynamic.define.bind(null, DYN_STATE),
            // executes an empty draw command
            draw: compileProcedure({}),
            // Resources
            buffer: function(options) {
              return bufferState.create(options, GL_ARRAY_BUFFER, false, false);
            },
            elements: function(options) {
              return elementState.create(options, false);
            },
            texture: textureState.create2D,
            cube: textureState.createCube,
            renderbuffer: renderbufferState.create,
            framebuffer: framebufferState.create,
            framebufferCube: framebufferState.createCube,
            vao: attributeState.createVAO,
            // Expose context attributes
            attributes: glAttributes,
            // Frame rendering
            frame,
            on: addListener,
            // System limits
            limits,
            hasExtension: function(name) {
              return limits.extensions.indexOf(name.toLowerCase()) >= 0;
            },
            // Read pixels
            read: readPixels,
            // Destroy regl and all associated resources
            destroy,
            // Direct GL state manipulation
            _gl: gl,
            _refresh: refresh,
            poll: function() {
              poll();
              if (timer) {
                timer.update();
              }
            },
            // Current time
            now,
            // regl Statistics Information
            stats: stats$$1,
            // cache generated code
            getCachedCode,
            preloadCachedCode
          });
          config.onDone(null, regl);
          return regl;
        }
        return wrapREGL;
      });
    }
  });

  // node_modules/gl-util/context.js
  var require_context = __commonJS({
    "node_modules/gl-util/context.js"(exports, module) {
      "use strict";
      var pick = require_pick_by_alias();
      module.exports = function setContext(o) {
        if (!o) o = {};
        else if (typeof o === "string") o = { container: o };
        if (isCanvas(o)) {
          o = { container: o };
        } else if (isElement(o)) {
          o = { container: o };
        } else if (isContext(o)) {
          o = { gl: o };
        } else {
          o = pick(o, {
            container: "container target element el canvas holder parent parentNode wrapper use ref root node",
            gl: "gl context webgl glContext",
            attrs: "attributes attrs contextAttributes",
            pixelRatio: "pixelRatio pxRatio px ratio pxratio pixelratio",
            width: "w width",
            height: "h height"
          }, true);
        }
        if (!o.pixelRatio) o.pixelRatio = window.pixelRatio || 1;
        if (o.gl) {
          return o.gl;
        }
        if (o.canvas) {
          o.container = o.canvas.parentNode;
        }
        if (o.container) {
          if (typeof o.container === "string") {
            var c = document.querySelector(o.container);
            if (!c) throw Error("Element " + o.container + " is not found");
            o.container = c;
          }
          if (isCanvas(o.container)) {
            o.canvas = o.container;
            o.container = o.canvas.parentNode;
          } else if (!o.canvas) {
            o.canvas = createCanvas();
            o.container.appendChild(o.canvas);
            resize(o);
          }
        } else if (!o.canvas) {
          if (typeof document !== "undefined") {
            o.container = document.body || document.documentElement;
            o.canvas = createCanvas();
            o.container.appendChild(o.canvas);
            resize(o);
          } else {
            throw Error("Not DOM environment. Use headless-gl.");
          }
        }
        if (!o.gl) {
          ["webgl", "experimental-webgl", "webgl-experimental"].some(function(c2) {
            try {
              o.gl = o.canvas.getContext(c2, o.attrs);
            } catch (e) {
            }
            return o.gl;
          });
        }
        return o.gl;
      };
      function resize(o) {
        if (o.container) {
          if (o.container == document.body) {
            if (!document.body.style.width) o.canvas.width = o.width || o.pixelRatio * window.innerWidth;
            if (!document.body.style.height) o.canvas.height = o.height || o.pixelRatio * window.innerHeight;
          } else {
            var bounds = o.container.getBoundingClientRect();
            o.canvas.width = o.width || bounds.right - bounds.left;
            o.canvas.height = o.height || bounds.bottom - bounds.top;
          }
        }
      }
      function isCanvas(e) {
        return typeof e.getContext === "function" && "width" in e && "height" in e;
      }
      function isElement(e) {
        return typeof e.nodeName === "string" && typeof e.appendChild === "function" && typeof e.getBoundingClientRect === "function";
      }
      function isContext(e) {
        return typeof e.drawArrays === "function" || typeof e.drawElements === "function";
      }
      function createCanvas() {
        var canvas = document.createElement("canvas");
        canvas.style.position = "absolute";
        canvas.style.top = 0;
        canvas.style.left = 0;
        return canvas;
      }
    }
  });

  // node_modules/font-atlas/index.js
  var require_font_atlas = __commonJS({
    "node_modules/font-atlas/index.js"(exports, module) {
      "use strict";
      var stringifyFont = require_stringify();
      var defaultChars = [32, 126];
      module.exports = atlas;
      function atlas(options) {
        options = options || {};
        var shape = options.shape ? options.shape : options.canvas ? [options.canvas.width, options.canvas.height] : [512, 512];
        var canvas = options.canvas || document.createElement("canvas");
        var font = options.font;
        var step = typeof options.step === "number" ? [options.step, options.step] : options.step || [32, 32];
        var chars = options.chars || defaultChars;
        if (font && typeof font !== "string") font = stringifyFont(font);
        if (!Array.isArray(chars)) {
          chars = String(chars).split("");
        } else if (chars.length === 2 && typeof chars[0] === "number" && typeof chars[1] === "number") {
          var newchars = [];
          for (var i = chars[0], j = 0; i <= chars[1]; i++) {
            newchars[j++] = String.fromCharCode(i);
          }
          chars = newchars;
        }
        shape = shape.slice();
        canvas.width = shape[0];
        canvas.height = shape[1];
        var ctx = canvas.getContext("2d");
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = font;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#fff";
        var x = step[0] / 2;
        var y = step[1] / 2;
        for (var i = 0; i < chars.length; i++) {
          ctx.fillText(chars[i], x, y);
          if ((x += step[0]) > shape[0] - step[0] / 2) x = step[0] / 2, y += step[1];
        }
        return canvas;
      }
    }
  });

  // node_modules/bit-twiddle/twiddle.js
  var require_twiddle = __commonJS({
    "node_modules/bit-twiddle/twiddle.js"(exports) {
      "use strict";
      "use restrict";
      var INT_BITS = 32;
      exports.INT_BITS = INT_BITS;
      exports.INT_MAX = 2147483647;
      exports.INT_MIN = -1 << INT_BITS - 1;
      exports.sign = function(v) {
        return (v > 0) - (v < 0);
      };
      exports.abs = function(v) {
        var mask = v >> INT_BITS - 1;
        return (v ^ mask) - mask;
      };
      exports.min = function(x, y) {
        return y ^ (x ^ y) & -(x < y);
      };
      exports.max = function(x, y) {
        return x ^ (x ^ y) & -(x < y);
      };
      exports.isPow2 = function(v) {
        return !(v & v - 1) && !!v;
      };
      exports.log2 = function(v) {
        var r, shift;
        r = (v > 65535) << 4;
        v >>>= r;
        shift = (v > 255) << 3;
        v >>>= shift;
        r |= shift;
        shift = (v > 15) << 2;
        v >>>= shift;
        r |= shift;
        shift = (v > 3) << 1;
        v >>>= shift;
        r |= shift;
        return r | v >> 1;
      };
      exports.log10 = function(v) {
        return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
      };
      exports.popCount = function(v) {
        v = v - (v >>> 1 & 1431655765);
        v = (v & 858993459) + (v >>> 2 & 858993459);
        return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
      };
      function countTrailingZeros(v) {
        var c = 32;
        v &= -v;
        if (v) c--;
        if (v & 65535) c -= 16;
        if (v & 16711935) c -= 8;
        if (v & 252645135) c -= 4;
        if (v & 858993459) c -= 2;
        if (v & 1431655765) c -= 1;
        return c;
      }
      exports.countTrailingZeros = countTrailingZeros;
      exports.nextPow2 = function(v) {
        v += v === 0;
        --v;
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v + 1;
      };
      exports.prevPow2 = function(v) {
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v - (v >>> 1);
      };
      exports.parity = function(v) {
        v ^= v >>> 16;
        v ^= v >>> 8;
        v ^= v >>> 4;
        v &= 15;
        return 27030 >>> v & 1;
      };
      var REVERSE_TABLE = new Array(256);
      (function(tab) {
        for (var i = 0; i < 256; ++i) {
          var v = i, r = i, s = 7;
          for (v >>>= 1; v; v >>>= 1) {
            r <<= 1;
            r |= v & 1;
            --s;
          }
          tab[i] = r << s & 255;
        }
      })(REVERSE_TABLE);
      exports.reverse = function(v) {
        return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
      };
      exports.interleave2 = function(x, y) {
        x &= 65535;
        x = (x | x << 8) & 16711935;
        x = (x | x << 4) & 252645135;
        x = (x | x << 2) & 858993459;
        x = (x | x << 1) & 1431655765;
        y &= 65535;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x | y << 1;
      };
      exports.deinterleave2 = function(v, n) {
        v = v >>> n & 1431655765;
        v = (v | v >>> 1) & 858993459;
        v = (v | v >>> 2) & 252645135;
        v = (v | v >>> 4) & 16711935;
        v = (v | v >>> 16) & 65535;
        return v << 16 >> 16;
      };
      exports.interleave3 = function(x, y, z) {
        x &= 1023;
        x = (x | x << 16) & 4278190335;
        x = (x | x << 8) & 251719695;
        x = (x | x << 4) & 3272356035;
        x = (x | x << 2) & 1227133513;
        y &= 1023;
        y = (y | y << 16) & 4278190335;
        y = (y | y << 8) & 251719695;
        y = (y | y << 4) & 3272356035;
        y = (y | y << 2) & 1227133513;
        x |= y << 1;
        z &= 1023;
        z = (z | z << 16) & 4278190335;
        z = (z | z << 8) & 251719695;
        z = (z | z << 4) & 3272356035;
        z = (z | z << 2) & 1227133513;
        return x | z << 2;
      };
      exports.deinterleave3 = function(v, n) {
        v = v >>> n & 1227133513;
        v = (v | v >>> 2) & 3272356035;
        v = (v | v >>> 4) & 251719695;
        v = (v | v >>> 8) & 4278190335;
        v = (v | v >>> 16) & 1023;
        return v << 22 >> 22;
      };
      exports.nextCombination = function(v) {
        var t = v | v - 1;
        return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
      };
    }
  });

  // node_modules/dup/dup.js
  var require_dup = __commonJS({
    "node_modules/dup/dup.js"(exports, module) {
      "use strict";
      function dupe_array(count, value, i) {
        var c = count[i] | 0;
        if (c <= 0) {
          return [];
        }
        var result = new Array(c), j;
        if (i === count.length - 1) {
          for (j = 0; j < c; ++j) {
            result[j] = value;
          }
        } else {
          for (j = 0; j < c; ++j) {
            result[j] = dupe_array(count, value, i + 1);
          }
        }
        return result;
      }
      function dupe_number(count, value) {
        var result, i;
        result = new Array(count);
        for (i = 0; i < count; ++i) {
          result[i] = value;
        }
        return result;
      }
      function dupe(count, value) {
        if (typeof value === "undefined") {
          value = 0;
        }
        switch (typeof count) {
          case "number":
            if (count > 0) {
              return dupe_number(count | 0, value);
            }
            break;
          case "object":
            if (typeof count.length === "number") {
              return dupe_array(count, value, 0);
            }
            break;
        }
        return [];
      }
      module.exports = dupe;
    }
  });

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1) validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(
            uint8,
            i2,
            i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength
          ));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b) return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
        if (this === b) return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y) return -1;
        if (y < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir) return -1;
          else byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1) foundIndex = i;
              if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found) return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed)) return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len) end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0) start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0) end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length) break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/typedarray-pool/pool.js
  var require_pool = __commonJS({
    "node_modules/typedarray-pool/pool.js"(exports) {
      "use strict";
      var bits = require_twiddle();
      var dup = require_dup();
      var Buffer2 = require_buffer().Buffer;
      if (!window.__TYPEDARRAY_POOL) {
        window.__TYPEDARRAY_POOL = {
          UINT8: dup([32, 0]),
          UINT16: dup([32, 0]),
          UINT32: dup([32, 0]),
          BIGUINT64: dup([32, 0]),
          INT8: dup([32, 0]),
          INT16: dup([32, 0]),
          INT32: dup([32, 0]),
          BIGINT64: dup([32, 0]),
          FLOAT: dup([32, 0]),
          DOUBLE: dup([32, 0]),
          DATA: dup([32, 0]),
          UINT8C: dup([32, 0]),
          BUFFER: dup([32, 0])
        };
      }
      var hasUint8C = typeof Uint8ClampedArray !== "undefined";
      var hasBigUint64 = typeof BigUint64Array !== "undefined";
      var hasBigInt64 = typeof BigInt64Array !== "undefined";
      var POOL = window.__TYPEDARRAY_POOL;
      if (!POOL.UINT8C) {
        POOL.UINT8C = dup([32, 0]);
      }
      if (!POOL.BIGUINT64) {
        POOL.BIGUINT64 = dup([32, 0]);
      }
      if (!POOL.BIGINT64) {
        POOL.BIGINT64 = dup([32, 0]);
      }
      if (!POOL.BUFFER) {
        POOL.BUFFER = dup([32, 0]);
      }
      var DATA = POOL.DATA;
      var BUFFER = POOL.BUFFER;
      exports.free = function free(array) {
        if (Buffer2.isBuffer(array)) {
          BUFFER[bits.log2(array.length)].push(array);
        } else {
          if (Object.prototype.toString.call(array) !== "[object ArrayBuffer]") {
            array = array.buffer;
          }
          if (!array) {
            return;
          }
          var n = array.length || array.byteLength;
          var log_n = bits.log2(n) | 0;
          DATA[log_n].push(array);
        }
      };
      function freeArrayBuffer(buffer) {
        if (!buffer) {
          return;
        }
        var n = buffer.length || buffer.byteLength;
        var log_n = bits.log2(n);
        DATA[log_n].push(buffer);
      }
      function freeTypedArray(array) {
        freeArrayBuffer(array.buffer);
      }
      exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeBigUint64 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeBigInt64 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;
      exports.freeArrayBuffer = freeArrayBuffer;
      exports.freeBuffer = function freeBuffer(array) {
        BUFFER[bits.log2(array.length)].push(array);
      };
      exports.malloc = function malloc(n, dtype) {
        if (dtype === void 0 || dtype === "arraybuffer") {
          return mallocArrayBuffer(n);
        } else {
          switch (dtype) {
            case "uint8":
              return mallocUint8(n);
            case "uint16":
              return mallocUint16(n);
            case "uint32":
              return mallocUint32(n);
            case "int8":
              return mallocInt8(n);
            case "int16":
              return mallocInt16(n);
            case "int32":
              return mallocInt32(n);
            case "float":
            case "float32":
              return mallocFloat(n);
            case "double":
            case "float64":
              return mallocDouble(n);
            case "uint8_clamped":
              return mallocUint8Clamped(n);
            case "bigint64":
              return mallocBigInt64(n);
            case "biguint64":
              return mallocBigUint64(n);
            case "buffer":
              return mallocBuffer(n);
            case "data":
            case "dataview":
              return mallocDataView(n);
            default:
              return null;
          }
        }
        return null;
      };
      function mallocArrayBuffer(n) {
        var n = bits.nextPow2(n);
        var log_n = bits.log2(n);
        var d = DATA[log_n];
        if (d.length > 0) {
          return d.pop();
        }
        return new ArrayBuffer(n);
      }
      exports.mallocArrayBuffer = mallocArrayBuffer;
      function mallocUint8(n) {
        return new Uint8Array(mallocArrayBuffer(n), 0, n);
      }
      exports.mallocUint8 = mallocUint8;
      function mallocUint16(n) {
        return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
      }
      exports.mallocUint16 = mallocUint16;
      function mallocUint32(n) {
        return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
      }
      exports.mallocUint32 = mallocUint32;
      function mallocInt8(n) {
        return new Int8Array(mallocArrayBuffer(n), 0, n);
      }
      exports.mallocInt8 = mallocInt8;
      function mallocInt16(n) {
        return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
      }
      exports.mallocInt16 = mallocInt16;
      function mallocInt32(n) {
        return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
      }
      exports.mallocInt32 = mallocInt32;
      function mallocFloat(n) {
        return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
      }
      exports.mallocFloat32 = exports.mallocFloat = mallocFloat;
      function mallocDouble(n) {
        return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
      }
      exports.mallocFloat64 = exports.mallocDouble = mallocDouble;
      function mallocUint8Clamped(n) {
        if (hasUint8C) {
          return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
        } else {
          return mallocUint8(n);
        }
      }
      exports.mallocUint8Clamped = mallocUint8Clamped;
      function mallocBigUint64(n) {
        if (hasBigUint64) {
          return new BigUint64Array(mallocArrayBuffer(8 * n), 0, n);
        } else {
          return null;
        }
      }
      exports.mallocBigUint64 = mallocBigUint64;
      function mallocBigInt64(n) {
        if (hasBigInt64) {
          return new BigInt64Array(mallocArrayBuffer(8 * n), 0, n);
        } else {
          return null;
        }
      }
      exports.mallocBigInt64 = mallocBigInt64;
      function mallocDataView(n) {
        return new DataView(mallocArrayBuffer(n), 0, n);
      }
      exports.mallocDataView = mallocDataView;
      function mallocBuffer(n) {
        n = bits.nextPow2(n);
        var log_n = bits.log2(n);
        var cache = BUFFER[log_n];
        if (cache.length > 0) {
          return cache.pop();
        }
        return new Buffer2(n);
      }
      exports.mallocBuffer = mallocBuffer;
      exports.clearCache = function clearCache() {
        for (var i = 0; i < 32; ++i) {
          POOL.UINT8[i].length = 0;
          POOL.UINT16[i].length = 0;
          POOL.UINT32[i].length = 0;
          POOL.INT8[i].length = 0;
          POOL.INT16[i].length = 0;
          POOL.INT32[i].length = 0;
          POOL.FLOAT[i].length = 0;
          POOL.DOUBLE[i].length = 0;
          POOL.BIGUINT64[i].length = 0;
          POOL.BIGINT64[i].length = 0;
          POOL.UINT8C[i].length = 0;
          DATA[i].length = 0;
          BUFFER[i].length = 0;
        }
      };
    }
  });

  // node_modules/is-plain-obj/index.js
  var require_is_plain_obj = __commonJS({
    "node_modules/is-plain-obj/index.js"(exports, module) {
      "use strict";
      var toString = Object.prototype.toString;
      module.exports = function(x) {
        var prototype;
        return toString.call(x) === "[object Object]" && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
      };
    }
  });

  // node_modules/parse-unit/index.js
  var require_parse_unit = __commonJS({
    "node_modules/parse-unit/index.js"(exports, module) {
      module.exports = function parseUnit(str, out) {
        if (!out)
          out = [0, ""];
        str = String(str);
        var num = parseFloat(str, 10);
        out[0] = num;
        out[1] = str.match(/[\d.\-\+]*\s*(.*)/)[1] || "";
        return out;
      };
    }
  });

  // node_modules/to-px/topx.js
  var require_topx = __commonJS({
    "node_modules/to-px/topx.js"(exports, module) {
      "use strict";
      var parseUnit = require_parse_unit();
      module.exports = toPX;
      var PIXELS_PER_INCH = 96;
      function getPropertyInPX(element, prop) {
        var parts = parseUnit(getComputedStyle(element).getPropertyValue(prop));
        return parts[0] * toPX(parts[1], element);
      }
      function getSizeBrutal(unit, element) {
        var testDIV = document.createElement("div");
        testDIV.style["font-size"] = "128" + unit;
        element.appendChild(testDIV);
        var size = getPropertyInPX(testDIV, "font-size") / 128;
        element.removeChild(testDIV);
        return size;
      }
      function toPX(str, element) {
        element = element || document.body;
        str = (str || "px").trim().toLowerCase();
        if (element === window || element === document) {
          element = document.body;
        }
        switch (str) {
          case "%":
            return element.clientHeight / 100;
          case "ch":
          case "ex":
            return getSizeBrutal(str, element);
          case "em":
            return getPropertyInPX(element, "font-size");
          case "rem":
            return getPropertyInPX(document.body, "font-size");
          case "vw":
            return window.innerWidth / 100;
          case "vh":
            return window.innerHeight / 100;
          case "vmin":
            return Math.min(window.innerWidth, window.innerHeight) / 100;
          case "vmax":
            return Math.max(window.innerWidth, window.innerHeight) / 100;
          case "in":
            return PIXELS_PER_INCH;
          case "cm":
            return PIXELS_PER_INCH / 2.54;
          case "mm":
            return PIXELS_PER_INCH / 25.4;
          case "pt":
            return PIXELS_PER_INCH / 72;
          case "pc":
            return PIXELS_PER_INCH / 6;
        }
        return 1;
      }
    }
  });

  // node_modules/detect-kerning/index.js
  var require_detect_kerning = __commonJS({
    "node_modules/detect-kerning/index.js"(exports, module) {
      "use strict";
      module.exports = kerning;
      var canvas = kerning.canvas = document.createElement("canvas");
      var ctx = canvas.getContext("2d");
      var asciiPairs = createPairs([32, 126]);
      kerning.createPairs = createPairs;
      kerning.ascii = asciiPairs;
      function kerning(family, o) {
        if (Array.isArray(family)) family = family.join(", ");
        var table = {}, pairs, fs = 16, threshold = 0.05;
        if (o) {
          if (o.length === 2 && typeof o[0] === "number") {
            pairs = createPairs(o);
          } else if (Array.isArray(o)) {
            pairs = o;
          } else {
            if (o.o) pairs = createPairs(o.o);
            else if (o.pairs) pairs = o.pairs;
            if (o.fontSize) fs = o.fontSize;
            if (o.threshold != null) threshold = o.threshold;
          }
        }
        if (!pairs) pairs = asciiPairs;
        ctx.font = fs + "px " + family;
        for (var i = 0; i < pairs.length; i++) {
          var pair = pairs[i];
          var width = ctx.measureText(pair[0]).width + ctx.measureText(pair[1]).width;
          var kerningWidth = ctx.measureText(pair).width;
          if (Math.abs(width - kerningWidth) > fs * threshold) {
            var emWidth = (kerningWidth - width) / fs;
            table[pair] = emWidth * 1e3;
          }
        }
        return table;
      }
      function createPairs(range) {
        var pairs = [];
        for (var i = range[0]; i <= range[1]; i++) {
          var leftChar = String.fromCharCode(i);
          for (var j = range[0]; j < range[1]; j++) {
            var rightChar = String.fromCharCode(j);
            var pair = leftChar + rightChar;
            pairs.push(pair);
          }
        }
        return pairs;
      }
    }
  });

  // node_modules/font-measure/index.js
  var require_font_measure = __commonJS({
    "node_modules/font-measure/index.js"(exports, module) {
      "use strict";
      module.exports = measure;
      measure.canvas = document.createElement("canvas");
      measure.cache = {};
      function measure(font, o) {
        if (!o) o = {};
        if (typeof font === "string" || Array.isArray(font)) {
          o.family = font;
        }
        var family = Array.isArray(o.family) ? o.family.join(", ") : o.family;
        if (!family) throw Error("`family` must be defined");
        var fs = o.size || o.fontSize || o.em || 48;
        var weight = o.weight || o.fontWeight || "";
        var style = o.style || o.fontStyle || "";
        var font = [style, weight, fs].join(" ") + "px " + family;
        var origin = o.origin || "top";
        if (measure.cache[family]) {
          if (fs <= measure.cache[family].em) {
            return applyOrigin(measure.cache[family], origin);
          }
        }
        var canvas = o.canvas || measure.canvas;
        var ctx = canvas.getContext("2d");
        var chars = {
          upper: o.upper !== void 0 ? o.upper : "H",
          lower: o.lower !== void 0 ? o.lower : "x",
          descent: o.descent !== void 0 ? o.descent : "p",
          ascent: o.ascent !== void 0 ? o.ascent : "h",
          tittle: o.tittle !== void 0 ? o.tittle : "i",
          overshoot: o.overshoot !== void 0 ? o.overshoot : "O"
        };
        var l = Math.ceil(fs * 1.5);
        canvas.height = l;
        canvas.width = l * 0.5;
        ctx.font = font;
        var char = "H";
        var result = {
          top: 0
        };
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = "top";
        ctx.fillStyle = "black";
        ctx.fillText(char, 0, 0);
        var topPx = firstTop(ctx.getImageData(0, 0, l, l));
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = "bottom";
        ctx.fillText(char, 0, l);
        var bottomPx = firstTop(ctx.getImageData(0, 0, l, l));
        result.lineHeight = result.bottom = l - bottomPx + topPx;
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = "alphabetic";
        ctx.fillText(char, 0, l);
        var baselinePx = firstTop(ctx.getImageData(0, 0, l, l));
        var baseline = l - baselinePx - 1 + topPx;
        result.baseline = result.alphabetic = baseline;
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = "middle";
        ctx.fillText(char, 0, l * 0.5);
        var medianPx = firstTop(ctx.getImageData(0, 0, l, l));
        result.median = result.middle = l - medianPx - 1 + topPx - l * 0.5;
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = "hanging";
        ctx.fillText(char, 0, l * 0.5);
        var hangingPx = firstTop(ctx.getImageData(0, 0, l, l));
        result.hanging = l - hangingPx - 1 + topPx - l * 0.5;
        ctx.clearRect(0, 0, l, l);
        ctx.textBaseline = "ideographic";
        ctx.fillText(char, 0, l);
        var ideographicPx = firstTop(ctx.getImageData(0, 0, l, l));
        result.ideographic = l - ideographicPx - 1 + topPx;
        if (chars.upper) {
          ctx.clearRect(0, 0, l, l);
          ctx.textBaseline = "top";
          ctx.fillText(chars.upper, 0, 0);
          result.upper = firstTop(ctx.getImageData(0, 0, l, l));
          result.capHeight = result.baseline - result.upper;
        }
        if (chars.lower) {
          ctx.clearRect(0, 0, l, l);
          ctx.textBaseline = "top";
          ctx.fillText(chars.lower, 0, 0);
          result.lower = firstTop(ctx.getImageData(0, 0, l, l));
          result.xHeight = result.baseline - result.lower;
        }
        if (chars.tittle) {
          ctx.clearRect(0, 0, l, l);
          ctx.textBaseline = "top";
          ctx.fillText(chars.tittle, 0, 0);
          result.tittle = firstTop(ctx.getImageData(0, 0, l, l));
        }
        if (chars.ascent) {
          ctx.clearRect(0, 0, l, l);
          ctx.textBaseline = "top";
          ctx.fillText(chars.ascent, 0, 0);
          result.ascent = firstTop(ctx.getImageData(0, 0, l, l));
        }
        if (chars.descent) {
          ctx.clearRect(0, 0, l, l);
          ctx.textBaseline = "top";
          ctx.fillText(chars.descent, 0, 0);
          result.descent = firstBottom(ctx.getImageData(0, 0, l, l));
        }
        if (chars.overshoot) {
          ctx.clearRect(0, 0, l, l);
          ctx.textBaseline = "top";
          ctx.fillText(chars.overshoot, 0, 0);
          var overshootPx = firstBottom(ctx.getImageData(0, 0, l, l));
          result.overshoot = overshootPx - baseline;
        }
        for (var name in result) {
          result[name] /= fs;
        }
        result.em = fs;
        measure.cache[family] = result;
        return applyOrigin(result, origin);
      }
      function applyOrigin(obj, origin) {
        var res = {};
        if (typeof origin === "string") origin = obj[origin];
        for (var name in obj) {
          if (name === "em") continue;
          res[name] = obj[name] - origin;
        }
        return res;
      }
      function firstTop(iData) {
        var l = iData.height;
        var data = iData.data;
        for (var i = 3; i < data.length; i += 4) {
          if (data[i] !== 0) {
            return Math.floor((i - 3) * 0.25 / l);
          }
        }
      }
      function firstBottom(iData) {
        var l = iData.height;
        var data = iData.data;
        for (var i = data.length - 1; i > 0; i -= 4) {
          if (data[i] !== 0) {
            return Math.floor((i - 3) * 0.25 / l);
          }
        }
      }
    }
  });

  // node_modules/gl-text/dist.js
  var require_dist = __commonJS({
    "node_modules/gl-text/dist.js"(exports, module) {
      "use strict";
      var Font = require_css_font();
      var pick = require_pick_by_alias();
      var createRegl = require_regl_unchecked();
      var createGl = require_context();
      var WeakMap2 = require_es6_weak_map();
      var rgba2 = require_color_normalize();
      var fontAtlas = require_font_atlas();
      var pool = require_pool();
      var parseRect = require_parse_rect();
      var isObj = require_is_plain_obj();
      var parseUnit = require_parse_unit();
      var px = require_topx();
      var kerning = require_detect_kerning();
      var extend = require_object_assign();
      var metrics = require_font_measure();
      var flatten = require_flatten_vertex_data();
      var ref = require_twiddle();
      var nextPow2 = ref.nextPow2;
      var shaderCache = new WeakMap2();
      var isStretchSupported = false;
      if (document.body) {
        el = document.body.appendChild(document.createElement("div"));
        el.style.font = "italic small-caps bold condensed 16px/2 cursive";
        if (getComputedStyle(el).fontStretch) {
          isStretchSupported = true;
        }
        document.body.removeChild(el);
      }
      var el;
      var GlText = function GlText2(o) {
        if (isRegl(o)) {
          o = { regl: o };
          this.gl = o.regl._gl;
        } else {
          this.gl = createGl(o);
        }
        this.shader = shaderCache.get(this.gl);
        if (!this.shader) {
          this.regl = o.regl || createRegl({ gl: this.gl });
        } else {
          this.regl = this.shader.regl;
        }
        this.charBuffer = this.regl.buffer({ type: "uint8", usage: "stream" });
        this.sizeBuffer = this.regl.buffer({ type: "float", usage: "stream" });
        if (!this.shader) {
          this.shader = this.createShader();
          shaderCache.set(this.gl, this.shader);
        }
        this.batch = [];
        this.fontSize = [];
        this.font = [];
        this.fontAtlas = [];
        this.draw = this.shader.draw.bind(this);
        this.render = function() {
          this.regl._refresh();
          this.draw(this.batch);
        };
        this.canvas = this.gl.canvas;
        this.update(isObj(o) ? o : {});
      };
      GlText.prototype.createShader = function createShader() {
        var regl = this.regl;
        var draw = regl({
          blend: {
            enable: true,
            color: [0, 0, 0, 1],
            func: {
              srcRGB: "src alpha",
              dstRGB: "one minus src alpha",
              srcAlpha: "one minus dst alpha",
              dstAlpha: "one"
            }
          },
          stencil: { enable: false },
          depth: { enable: false },
          count: regl.prop("count"),
          offset: regl.prop("offset"),
          attributes: {
            charOffset: {
              offset: 4,
              stride: 8,
              buffer: regl.this("sizeBuffer")
            },
            width: {
              offset: 0,
              stride: 8,
              buffer: regl.this("sizeBuffer")
            },
            char: regl.this("charBuffer"),
            position: regl.this("position")
          },
          uniforms: {
            atlasSize: function(c, p) {
              return [p.atlas.width, p.atlas.height];
            },
            atlasDim: function(c, p) {
              return [p.atlas.cols, p.atlas.rows];
            },
            atlas: function(c, p) {
              return p.atlas.texture;
            },
            charStep: function(c, p) {
              return p.atlas.step;
            },
            em: function(c, p) {
              return p.atlas.em;
            },
            color: regl.prop("color"),
            opacity: regl.prop("opacity"),
            viewport: regl.this("viewportArray"),
            scale: regl.this("scale"),
            align: regl.prop("align"),
            baseline: regl.prop("baseline"),
            translate: regl.this("translate"),
            positionOffset: regl.prop("positionOffset")
          },
          primitive: "points",
          viewport: regl.this("viewport"),
          vert: "\n			precision highp float;\n			attribute float width, charOffset, char;\n			attribute vec2 position;\n			uniform float fontSize, charStep, em, align, baseline;\n			uniform vec4 viewport;\n			uniform vec4 color;\n			uniform vec2 atlasSize, atlasDim, scale, translate, positionOffset;\n			varying vec2 charCoord, charId;\n			varying float charWidth;\n			varying vec4 fontColor;\n			void main () {\n				vec2 offset = floor(em * (vec2(align + charOffset, baseline)\n					+ vec2(positionOffset.x, -positionOffset.y)))\n					/ (viewport.zw * scale.xy);\n\n				vec2 position = (position + translate) * scale;\n				position += offset * scale;\n\n				charCoord = position * viewport.zw + viewport.xy;\n\n				gl_Position = vec4(position * 2. - 1., 0, 1);\n\n				gl_PointSize = charStep;\n\n				charId.x = mod(char, atlasDim.x);\n				charId.y = floor(char / atlasDim.x);\n\n				charWidth = width * em;\n\n				fontColor = color / 255.;\n			}",
          frag: "\n			precision highp float;\n			uniform float fontSize, charStep, opacity;\n			uniform vec2 atlasSize;\n			uniform vec4 viewport;\n			uniform sampler2D atlas;\n			varying vec4 fontColor;\n			varying vec2 charCoord, charId;\n			varying float charWidth;\n\n			float lightness(vec4 color) {\n				return color.r * 0.299 + color.g * 0.587 + color.b * 0.114;\n			}\n\n			void main () {\n				vec2 uv = gl_FragCoord.xy - charCoord + charStep * .5;\n				float halfCharStep = floor(charStep * .5 + .5);\n\n				// invert y and shift by 1px (FF expecially needs that)\n				uv.y = charStep - uv.y;\n\n				// ignore points outside of character bounding box\n				float halfCharWidth = ceil(charWidth * .5);\n				if (floor(uv.x) > halfCharStep + halfCharWidth ||\n					floor(uv.x) < halfCharStep - halfCharWidth) return;\n\n				uv += charId * charStep;\n				uv = uv / atlasSize;\n\n				vec4 color = fontColor;\n				vec4 mask = texture2D(atlas, uv);\n\n				float maskY = lightness(mask);\n				// float colorY = lightness(color);\n				color.a *= maskY;\n				color.a *= opacity;\n\n				// color.a += .1;\n\n				// antialiasing, see yiq color space y-channel formula\n				// color.rgb += (1. - color.rgb) * (1. - mask.rgb);\n\n				gl_FragColor = color;\n			}"
        });
        var atlas = {};
        return { regl, draw, atlas };
      };
      GlText.prototype.update = function update(o) {
        var this$1 = this;
        if (typeof o === "string") {
          o = { text: o };
        } else if (!o) {
          return;
        }
        o = pick(o, {
          position: "position positions coord coords coordinates",
          font: "font fontFace fontface typeface cssFont css-font family fontFamily",
          fontSize: "fontSize fontsize size font-size",
          text: "text texts chars characters value values symbols",
          align: "align alignment textAlign textbaseline",
          baseline: "baseline textBaseline textbaseline",
          direction: "dir direction textDirection",
          color: "color colour fill fill-color fillColor textColor textcolor",
          kerning: "kerning kern",
          range: "range dataBox",
          viewport: "vp viewport viewBox viewbox viewPort",
          opacity: "opacity alpha transparency visible visibility opaque",
          offset: "offset positionOffset padding shift indent indentation"
        }, true);
        if (o.opacity != null) {
          if (Array.isArray(o.opacity)) {
            this.opacity = o.opacity.map(function(o2) {
              return parseFloat(o2);
            });
          } else {
            this.opacity = parseFloat(o.opacity);
          }
        }
        if (o.viewport != null) {
          this.viewport = parseRect(o.viewport);
          this.viewportArray = [this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height];
        }
        if (this.viewport == null) {
          this.viewport = {
            x: 0,
            y: 0,
            width: this.gl.drawingBufferWidth,
            height: this.gl.drawingBufferHeight
          };
          this.viewportArray = [this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height];
        }
        if (o.kerning != null) {
          this.kerning = o.kerning;
        }
        if (o.offset != null) {
          if (typeof o.offset === "number") {
            o.offset = [o.offset, 0];
          }
          this.positionOffset = flatten(o.offset);
        }
        if (o.direction) {
          this.direction = o.direction;
        }
        if (o.range) {
          this.range = o.range;
          this.scale = [1 / (o.range[2] - o.range[0]), 1 / (o.range[3] - o.range[1])];
          this.translate = [-o.range[0], -o.range[1]];
        }
        if (o.scale) {
          this.scale = o.scale;
        }
        if (o.translate) {
          this.translate = o.translate;
        }
        if (!this.scale) {
          this.scale = [1 / this.viewport.width, 1 / this.viewport.height];
        }
        if (!this.translate) {
          this.translate = [0, 0];
        }
        if (!this.font.length && !o.font) {
          o.font = GlText.baseFontSize + "px sans-serif";
        }
        var newFont = false, newFontSize = false;
        if (o.font) {
          (Array.isArray(o.font) ? o.font : [o.font]).forEach(function(font2, i2) {
            if (typeof font2 === "string") {
              try {
                font2 = Font.parse(font2);
              } catch (e) {
                font2 = Font.parse(GlText.baseFontSize + "px " + font2);
              }
            } else {
              var fontStyle = font2.style;
              var fontWeight = font2.weight;
              var fontStretch = font2.stretch;
              var fontVariant = font2.variant;
              font2 = Font.parse(Font.stringify(font2));
              if (fontStyle) font2.style = fontStyle;
              if (fontWeight) font2.weight = fontWeight;
              if (fontStretch) font2.stretch = fontStretch;
              if (fontVariant) font2.variant = fontVariant;
            }
            var baseString = Font.stringify({
              size: GlText.baseFontSize,
              family: font2.family,
              stretch: isStretchSupported ? font2.stretch : void 0,
              variant: font2.variant,
              weight: font2.weight,
              style: font2.style
            });
            var unit = parseUnit(font2.size);
            var fs = Math.round(unit[0] * px(unit[1]));
            if (fs !== this$1.fontSize[i2]) {
              newFontSize = true;
              this$1.fontSize[i2] = fs;
            }
            if (!this$1.font[i2] || baseString != this$1.font[i2].baseString) {
              newFont = true;
              this$1.font[i2] = GlText.fonts[baseString];
              if (!this$1.font[i2]) {
                var family = font2.family.join(", ");
                var style = [font2.style];
                if (font2.style != font2.variant) {
                  style.push(font2.variant);
                }
                if (font2.variant != font2.weight) {
                  style.push(font2.weight);
                }
                if (isStretchSupported && font2.weight != font2.stretch) {
                  style.push(font2.stretch);
                }
                this$1.font[i2] = {
                  baseString,
                  // typeface
                  family,
                  weight: font2.weight,
                  stretch: font2.stretch,
                  style: font2.style,
                  variant: font2.variant,
                  // widths of characters
                  width: {},
                  // kernin pairs offsets
                  kerning: {},
                  metrics: metrics(family, {
                    origin: "top",
                    fontSize: GlText.baseFontSize,
                    fontStyle: style.join(" ")
                  })
                };
                GlText.fonts[baseString] = this$1.font[i2];
              }
            }
          });
        }
        if (newFont || newFontSize) {
          this.font.forEach(function(font2, i2) {
            var fontString = Font.stringify({
              size: this$1.fontSize[i2],
              family: font2.family,
              stretch: isStretchSupported ? font2.stretch : void 0,
              variant: font2.variant,
              weight: font2.weight,
              style: font2.style
            });
            this$1.fontAtlas[i2] = this$1.shader.atlas[fontString];
            if (!this$1.fontAtlas[i2]) {
              var metrics2 = font2.metrics;
              this$1.shader.atlas[fontString] = this$1.fontAtlas[i2] = {
                fontString,
                // even step is better for rendered characters
                step: Math.ceil(this$1.fontSize[i2] * metrics2.bottom * 0.5) * 2,
                em: this$1.fontSize[i2],
                cols: 0,
                rows: 0,
                height: 0,
                width: 0,
                chars: [],
                ids: {},
                texture: this$1.regl.texture()
              };
            }
            if (o.text == null) {
              o.text = this$1.text;
            }
          });
        }
        if (typeof o.text === "string" && o.position && o.position.length > 2) {
          var textArray = Array(o.position.length * 0.5);
          for (var i = 0; i < textArray.length; i++) {
            textArray[i] = o.text;
          }
          o.text = textArray;
        }
        var newAtlasChars;
        if (o.text != null || newFont) {
          this.textOffsets = [0];
          if (Array.isArray(o.text)) {
            this.count = o.text[0].length;
            this.counts = [this.count];
            for (var i$1 = 1; i$1 < o.text.length; i$1++) {
              this.textOffsets[i$1] = this.textOffsets[i$1 - 1] + o.text[i$1 - 1].length;
              this.count += o.text[i$1].length;
              this.counts.push(o.text[i$1].length);
            }
            this.text = o.text.join("");
          } else {
            this.text = o.text;
            this.count = this.text.length;
            this.counts = [this.count];
          }
          newAtlasChars = [];
          this.font.forEach(function(font2, idx) {
            GlText.atlasContext.font = font2.baseString;
            var atlas2 = this$1.fontAtlas[idx];
            for (var i2 = 0; i2 < this$1.text.length; i2++) {
              var char2 = this$1.text.charAt(i2);
              if (atlas2.ids[char2] == null) {
                atlas2.ids[char2] = atlas2.chars.length;
                atlas2.chars.push(char2);
                newAtlasChars.push(char2);
              }
              if (font2.width[char2] == null) {
                font2.width[char2] = GlText.atlasContext.measureText(char2).width / GlText.baseFontSize;
                if (this$1.kerning) {
                  var pairs = [];
                  for (var baseChar in font2.width) {
                    pairs.push(baseChar + char2, char2 + baseChar);
                  }
                  extend(font2.kerning, kerning(font2.family, {
                    pairs
                  }));
                }
              }
            }
          });
        }
        if (o.position) {
          if (o.position.length > 2) {
            var flat = !o.position[0].length;
            var positionData = pool.mallocFloat(this.count * 2);
            for (var i$2 = 0, ptr = 0; i$2 < this.counts.length; i$2++) {
              var count = this.counts[i$2];
              if (flat) {
                for (var j = 0; j < count; j++) {
                  positionData[ptr++] = o.position[i$2 * 2];
                  positionData[ptr++] = o.position[i$2 * 2 + 1];
                }
              } else {
                for (var j$1 = 0; j$1 < count; j$1++) {
                  positionData[ptr++] = o.position[i$2][0];
                  positionData[ptr++] = o.position[i$2][1];
                }
              }
            }
            if (this.position.call) {
              this.position({
                type: "float",
                data: positionData
              });
            } else {
              this.position = this.regl.buffer({
                type: "float",
                data: positionData
              });
            }
            pool.freeFloat(positionData);
          } else {
            if (this.position.destroy) {
              this.position.destroy();
            }
            this.position = {
              constant: o.position
            };
          }
        }
        if (o.text || newFont) {
          var charIds = pool.mallocUint8(this.count);
          var sizeData = pool.mallocFloat(this.count * 2);
          this.textWidth = [];
          for (var i$3 = 0, ptr$1 = 0; i$3 < this.counts.length; i$3++) {
            var count$1 = this.counts[i$3];
            var font = this.font[i$3] || this.font[0];
            var atlas = this.fontAtlas[i$3] || this.fontAtlas[0];
            for (var j$2 = 0; j$2 < count$1; j$2++) {
              var char = this.text.charAt(ptr$1);
              var prevChar = this.text.charAt(ptr$1 - 1);
              charIds[ptr$1] = atlas.ids[char];
              sizeData[ptr$1 * 2] = font.width[char];
              if (j$2) {
                var prevWidth = sizeData[ptr$1 * 2 - 2];
                var currWidth = sizeData[ptr$1 * 2];
                var prevOffset = sizeData[ptr$1 * 2 - 1];
                var offset = prevOffset + prevWidth * 0.5 + currWidth * 0.5;
                if (this.kerning) {
                  var kerning$1 = font.kerning[prevChar + char];
                  if (kerning$1) {
                    offset += kerning$1 * 1e-3;
                  }
                }
                sizeData[ptr$1 * 2 + 1] = offset;
              } else {
                sizeData[ptr$1 * 2 + 1] = sizeData[ptr$1 * 2] * 0.5;
              }
              ptr$1++;
            }
            this.textWidth.push(
              !sizeData.length ? 0 : (
                // last offset + half last width
                sizeData[ptr$1 * 2 - 2] * 0.5 + sizeData[ptr$1 * 2 - 1]
              )
            );
          }
          if (!o.align) {
            o.align = this.align;
          }
          this.charBuffer({ data: charIds, type: "uint8", usage: "stream" });
          this.sizeBuffer({ data: sizeData, type: "float", usage: "stream" });
          pool.freeUint8(charIds);
          pool.freeFloat(sizeData);
          if (newAtlasChars.length) {
            this.font.forEach(function(font2, i2) {
              var atlas2 = this$1.fontAtlas[i2];
              var step = atlas2.step;
              var maxCols = Math.floor(GlText.maxAtlasSize / step);
              var cols = Math.min(maxCols, atlas2.chars.length);
              var rows = Math.ceil(atlas2.chars.length / cols);
              var atlasWidth = nextPow2(cols * step);
              var atlasHeight = nextPow2(rows * step);
              atlas2.width = atlasWidth;
              atlas2.height = atlasHeight;
              atlas2.rows = rows;
              atlas2.cols = cols;
              if (!atlas2.em) {
                return;
              }
              atlas2.texture({
                data: fontAtlas({
                  canvas: GlText.atlasCanvas,
                  font: atlas2.fontString,
                  chars: atlas2.chars,
                  shape: [atlasWidth, atlasHeight],
                  step: [step, step]
                })
              });
            });
          }
        }
        if (o.align) {
          this.align = o.align;
          this.alignOffset = this.textWidth.map(function(textWidth, i2) {
            var align = !Array.isArray(this$1.align) ? this$1.align : this$1.align.length > 1 ? this$1.align[i2] : this$1.align[0];
            if (typeof align === "number") {
              return align;
            }
            switch (align) {
              case "right":
              case "end":
                return -textWidth;
              case "center":
              case "centre":
              case "middle":
                return -textWidth * 0.5;
            }
            return 0;
          });
        }
        if (this.baseline == null && o.baseline == null) {
          o.baseline = 0;
        }
        if (o.baseline != null) {
          this.baseline = o.baseline;
          if (!Array.isArray(this.baseline)) {
            this.baseline = [this.baseline];
          }
          this.baselineOffset = this.baseline.map(function(baseline, i2) {
            var m = (this$1.font[i2] || this$1.font[0]).metrics;
            var base = 0;
            base += m.bottom * 0.5;
            if (typeof baseline === "number") {
              base += baseline - m.baseline;
            } else {
              base += -m[baseline];
            }
            base *= -1;
            return base;
          });
        }
        if (o.color != null) {
          if (!o.color) {
            o.color = "transparent";
          }
          if (typeof o.color === "string" || !isNaN(o.color)) {
            this.color = rgba2(o.color, "uint8");
          } else {
            var colorData;
            if (typeof o.color[0] === "number" && o.color.length > this.counts.length) {
              var l = o.color.length;
              colorData = pool.mallocUint8(l);
              var sub = (o.color.subarray || o.color.slice).bind(o.color);
              for (var i$4 = 0; i$4 < l; i$4 += 4) {
                colorData.set(rgba2(sub(i$4, i$4 + 4), "uint8"), i$4);
              }
            } else {
              var l$1 = o.color.length;
              colorData = pool.mallocUint8(l$1 * 4);
              for (var i$5 = 0; i$5 < l$1; i$5++) {
                colorData.set(rgba2(o.color[i$5] || 0, "uint8"), i$5 * 4);
              }
            }
            this.color = colorData;
          }
        }
        if (o.position || o.text || o.color || o.baseline || o.align || o.font || o.offset || o.opacity) {
          var isBatch = this.color.length > 4 || this.baselineOffset.length > 1 || this.align && this.align.length > 1 || this.fontAtlas.length > 1 || this.positionOffset.length > 2;
          if (isBatch) {
            var length = Math.max(
              this.position.length * 0.5 || 0,
              this.color.length * 0.25 || 0,
              this.baselineOffset.length || 0,
              this.alignOffset.length || 0,
              this.font.length || 0,
              this.opacity.length || 0,
              this.positionOffset.length * 0.5 || 0
            );
            this.batch = Array(length);
            for (var i$6 = 0; i$6 < this.batch.length; i$6++) {
              this.batch[i$6] = {
                count: this.counts.length > 1 ? this.counts[i$6] : this.counts[0],
                offset: this.textOffsets.length > 1 ? this.textOffsets[i$6] : this.textOffsets[0],
                color: !this.color ? [0, 0, 0, 255] : this.color.length <= 4 ? this.color : this.color.subarray(i$6 * 4, i$6 * 4 + 4),
                opacity: Array.isArray(this.opacity) ? this.opacity[i$6] : this.opacity,
                baseline: this.baselineOffset[i$6] != null ? this.baselineOffset[i$6] : this.baselineOffset[0],
                align: !this.align ? 0 : this.alignOffset[i$6] != null ? this.alignOffset[i$6] : this.alignOffset[0],
                atlas: this.fontAtlas[i$6] || this.fontAtlas[0],
                positionOffset: this.positionOffset.length > 2 ? this.positionOffset.subarray(i$6 * 2, i$6 * 2 + 2) : this.positionOffset
              };
            }
          } else {
            if (this.count) {
              this.batch = [{
                count: this.count,
                offset: 0,
                color: this.color || [0, 0, 0, 255],
                opacity: Array.isArray(this.opacity) ? this.opacity[0] : this.opacity,
                baseline: this.baselineOffset[0],
                align: this.alignOffset ? this.alignOffset[0] : 0,
                atlas: this.fontAtlas[0],
                positionOffset: this.positionOffset
              }];
            } else {
              this.batch = [];
            }
          }
        }
      };
      GlText.prototype.destroy = function destroy() {
      };
      GlText.prototype.kerning = true;
      GlText.prototype.position = { constant: new Float32Array(2) };
      GlText.prototype.translate = null;
      GlText.prototype.scale = null;
      GlText.prototype.font = null;
      GlText.prototype.text = "";
      GlText.prototype.positionOffset = [0, 0];
      GlText.prototype.opacity = 1;
      GlText.prototype.color = new Uint8Array([0, 0, 0, 255]);
      GlText.prototype.alignOffset = [0, 0];
      GlText.maxAtlasSize = 1024;
      GlText.atlasCanvas = document.createElement("canvas");
      GlText.atlasContext = GlText.atlasCanvas.getContext("2d", { alpha: false });
      GlText.baseFontSize = 64;
      GlText.fonts = {};
      function isRegl(o) {
        return typeof o === "function" && o._gl && o.prop && o.texture && o.buffer;
      }
      module.exports = GlText;
    }
  });

  // src/lib/show_no_webgl_msg.js
  var require_show_no_webgl_msg = __commonJS({
    "src/lib/show_no_webgl_msg.js"(exports, module) {
      "use strict";
      var Color = require_color();
      var noop = function() {
      };
      module.exports = function showNoWebGlMsg(scene) {
        for (var prop in scene) {
          if (typeof scene[prop] === "function") scene[prop] = noop;
        }
        scene.destroy = function() {
          scene.container.parentNode.removeChild(scene.container);
        };
        var div = document.createElement("div");
        div.className = "no-webgl";
        div.style.cursor = "pointer";
        div.style.fontSize = "24px";
        div.style.color = Color.defaults[0];
        div.style.position = "absolute";
        div.style.left = div.style.top = "0px";
        div.style.width = div.style.height = "100%";
        div.style["background-color"] = Color.lightLine;
        div.style["z-index"] = 30;
        var p = document.createElement("p");
        p.textContent = "WebGL is not supported by your browser - visit https://get.webgl.org for more info";
        p.style.position = "relative";
        p.style.top = "50%";
        p.style.left = "50%";
        p.style.height = "30%";
        p.style.width = "50%";
        p.style.margin = "-15% 0 0 -25%";
        div.appendChild(p);
        scene.container.appendChild(div);
        scene.container.style.background = "#FFFFFF";
        scene.container.onclick = function() {
          window.open("https://get.webgl.org");
        };
        return false;
      };
    }
  });

  // src/lib/prepare_regl.js
  var require_prepare_regl = __commonJS({
    "src/lib/prepare_regl.js"(exports, module) {
      "use strict";
      var showNoWebGlMsg = require_show_no_webgl_msg();
      var createRegl = require_regl_unchecked();
      module.exports = function prepareRegl(gd, extensions, reglPrecompiled) {
        var fullLayout = gd._fullLayout;
        var success = true;
        fullLayout._glcanvas.each(function(d) {
          if (d.regl) {
            d.regl.preloadCachedCode(reglPrecompiled);
            return;
          }
          if (d.pick && !fullLayout._has("parcoords")) return;
          try {
            d.regl = createRegl({
              canvas: this,
              attributes: {
                antialias: !d.pick,
                preserveDrawingBuffer: true
              },
              pixelRatio: gd._context.plotGlPixelRatio || window.devicePixelRatio,
              extensions: extensions || [],
              cachedCode: reglPrecompiled || {}
            });
          } catch (e) {
            success = false;
          }
          if (!d.regl) success = false;
          if (success) {
            this.addEventListener("webglcontextlost", function(event) {
              if (gd && gd.emit) {
                gd.emit("plotly_webglcontextlost", {
                  event,
                  layer: d.key
                });
              }
            }, false);
          }
        });
        if (!success) {
          showNoWebGlMsg({ container: fullLayout._glcontainer.node() });
        }
        return success;
      };
    }
  });

  // src/traces/scattergl/plot.js
  var require_plot3 = __commonJS({
    "src/traces/scattergl/plot.js"(exports, module) {
      "use strict";
      var createScatter = require_bundle();
      var createLine = require_regl_line2d();
      var createError = require_regl_error2d();
      var Text = require_dist();
      var Lib = require_lib();
      var selectMode = require_helpers5().selectMode;
      var prepareRegl = require_prepare_regl();
      var subTypes = require_subtypes();
      var linkTraces = require_link_traces();
      var styleTextSelection = require_edit_style().styleTextSelection;
      var reglPrecompiled = {};
      function getViewport(fullLayout, xaxis, yaxis, plotGlPixelRatio) {
        var gs = fullLayout._size;
        var width = fullLayout.width * plotGlPixelRatio;
        var height = fullLayout.height * plotGlPixelRatio;
        var l = gs.l * plotGlPixelRatio;
        var b = gs.b * plotGlPixelRatio;
        var r = gs.r * plotGlPixelRatio;
        var t = gs.t * plotGlPixelRatio;
        var w = gs.w * plotGlPixelRatio;
        var h = gs.h * plotGlPixelRatio;
        return [
          l + xaxis.domain[0] * w,
          b + yaxis.domain[0] * h,
          width - r - (1 - xaxis.domain[1]) * w,
          height - t - (1 - yaxis.domain[1]) * h
        ];
      }
      var exports = module.exports = function plot(gd, subplot, cdata) {
        if (!cdata.length) return;
        var fullLayout = gd._fullLayout;
        var scene = subplot._scene;
        var xaxis = subplot.xaxis;
        var yaxis = subplot.yaxis;
        var i, j;
        if (!scene) return;
        var success = prepareRegl(gd, ["ANGLE_instanced_arrays", "OES_element_index_uint"], reglPrecompiled);
        if (!success) {
          scene.init();
          return;
        }
        var count = scene.count;
        var regl = fullLayout._glcanvas.data()[0].regl;
        linkTraces(gd, subplot, cdata);
        if (scene.dirty) {
          if ((scene.line2d || scene.error2d) && !(scene.scatter2d || scene.fill2d || scene.glText)) {
            regl.clear({});
          }
          if (scene.error2d === true) {
            scene.error2d = createError(regl);
          }
          if (scene.line2d === true) {
            scene.line2d = createLine(regl);
          }
          if (scene.scatter2d === true) {
            scene.scatter2d = createScatter(regl);
          }
          if (scene.fill2d === true) {
            scene.fill2d = createLine(regl);
          }
          if (scene.glText === true) {
            scene.glText = new Array(count);
            for (i = 0; i < count; i++) {
              scene.glText[i] = new Text(regl);
            }
          }
          if (scene.glText) {
            if (count > scene.glText.length) {
              var textsToAdd = count - scene.glText.length;
              for (i = 0; i < textsToAdd; i++) {
                scene.glText.push(new Text(regl));
              }
            } else if (count < scene.glText.length) {
              var textsToRemove = scene.glText.length - count;
              var removedTexts = scene.glText.splice(count, textsToRemove);
              removedTexts.forEach(function(text) {
                text.destroy();
              });
            }
            for (i = 0; i < count; i++) {
              scene.glText[i].update(scene.textOptions[i]);
            }
          }
          if (scene.line2d) {
            scene.line2d.update(scene.lineOptions);
            scene.lineOptions = scene.lineOptions.map(function(lineOptions) {
              if (lineOptions && lineOptions.positions) {
                var srcPos = lineOptions.positions;
                var firstptdef = 0;
                while (firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {
                  firstptdef += 2;
                }
                var lastptdef = srcPos.length - 2;
                while (lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {
                  lastptdef -= 2;
                }
                lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);
              }
              return lineOptions;
            });
            scene.line2d.update(scene.lineOptions);
          }
          if (scene.error2d) {
            var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);
            scene.error2d.update(errorBatch);
          }
          if (scene.scatter2d) {
            scene.scatter2d.update(scene.markerOptions);
          }
          scene.fillOrder = Lib.repeat(null, count);
          if (scene.fill2d) {
            scene.fillOptions = scene.fillOptions.map(function(fillOptions, i2) {
              var cdscatter = cdata[i2];
              if (!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;
              var cd = cdscatter[0];
              var trace2 = cd.trace;
              var stash2 = cd.t;
              var lineOptions = scene.lineOptions[i2];
              var last, j2;
              var fillData = [];
              if (trace2._ownfill) fillData.push(i2);
              if (trace2._nexttrace) fillData.push(i2 + 1);
              if (fillData.length) scene.fillOrder[i2] = fillData;
              var pos = [];
              var srcPos = lineOptions && lineOptions.positions || stash2.positions;
              var firstptdef, lastptdef;
              if (trace2.fill === "tozeroy") {
                firstptdef = 0;
                while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {
                  firstptdef += 2;
                }
                lastptdef = srcPos.length - 2;
                while (lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {
                  lastptdef -= 2;
                }
                if (srcPos[firstptdef + 1] !== 0) {
                  pos = [srcPos[firstptdef], 0];
                }
                pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));
                if (srcPos[lastptdef + 1] !== 0) {
                  pos = pos.concat([srcPos[lastptdef], 0]);
                }
              } else if (trace2.fill === "tozerox") {
                firstptdef = 0;
                while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {
                  firstptdef += 2;
                }
                lastptdef = srcPos.length - 2;
                while (lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {
                  lastptdef -= 2;
                }
                if (srcPos[firstptdef] !== 0) {
                  pos = [0, srcPos[firstptdef + 1]];
                }
                pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));
                if (srcPos[lastptdef] !== 0) {
                  pos = pos.concat([0, srcPos[lastptdef + 1]]);
                }
              } else if (trace2.fill === "toself" || trace2.fill === "tonext") {
                pos = [];
                last = 0;
                fillOptions.splitNull = true;
                for (j2 = 0; j2 < srcPos.length; j2 += 2) {
                  if (isNaN(srcPos[j2]) || isNaN(srcPos[j2 + 1])) {
                    pos = pos.concat(srcPos.slice(last, j2));
                    pos.push(srcPos[last], srcPos[last + 1]);
                    pos.push(null, null);
                    last = j2 + 2;
                  }
                }
                pos = pos.concat(srcPos.slice(last));
                if (last) {
                  pos.push(srcPos[last], srcPos[last + 1]);
                }
              } else {
                var nextTrace = trace2._nexttrace;
                if (nextTrace) {
                  var nextOptions = scene.lineOptions[i2 + 1];
                  if (nextOptions) {
                    var nextPos = nextOptions.positions;
                    if (trace2.fill === "tonexty") {
                      pos = srcPos.slice();
                      for (i2 = Math.floor(nextPos.length / 2); i2--; ) {
                        var xx = nextPos[i2 * 2];
                        var yy = nextPos[i2 * 2 + 1];
                        if (isNaN(xx) || isNaN(yy)) continue;
                        pos.push(xx, yy);
                      }
                      fillOptions.fill = nextTrace.fillcolor;
                    }
                  }
                }
              }
              if (trace2._prevtrace && trace2._prevtrace.fill === "tonext") {
                var prevLinePos = scene.lineOptions[i2 - 1].positions;
                var offset = pos.length / 2;
                last = offset;
                var hole = [last];
                for (j2 = 0; j2 < prevLinePos.length; j2 += 2) {
                  if (isNaN(prevLinePos[j2]) || isNaN(prevLinePos[j2 + 1])) {
                    hole.push(j2 / 2 + offset + 1);
                    last = j2 + 2;
                  }
                }
                pos = pos.concat(prevLinePos);
                fillOptions.hole = hole;
              }
              fillOptions.fillmode = trace2.fill;
              fillOptions.opacity = trace2.opacity;
              fillOptions.positions = pos;
              return fillOptions;
            });
            scene.fill2d.update(scene.fillOptions);
          }
        }
        var dragmode = fullLayout.dragmode;
        var isSelectMode = selectMode(dragmode);
        var clickSelectEnabled = fullLayout.clickmode.indexOf("select") > -1;
        for (i = 0; i < count; i++) {
          var cd0 = cdata[i][0];
          var trace = cd0.trace;
          var stash = cd0.t;
          var index = stash.index;
          var len = trace._length;
          var x = stash.x;
          var y = stash.y;
          if (trace.selectedpoints || isSelectMode || clickSelectEnabled) {
            if (!isSelectMode) isSelectMode = true;
            if (trace.selectedpoints) {
              var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);
              var selDict = {};
              for (j = 0; j < selPts.length; j++) {
                selDict[selPts[j]] = 1;
              }
              var unselPts = [];
              for (j = 0; j < len; j++) {
                if (!selDict[j]) unselPts.push(j);
              }
              scene.unselectBatch[index] = unselPts;
            }
            var xpx = stash.xpx = new Array(len);
            var ypx = stash.ypx = new Array(len);
            for (j = 0; j < len; j++) {
              xpx[j] = xaxis.c2p(x[j]);
              ypx[j] = yaxis.c2p(y[j]);
            }
          } else {
            stash.xpx = stash.ypx = null;
          }
        }
        if (isSelectMode) {
          if (!scene.select2d) {
            scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);
          }
          if (scene.scatter2d) {
            var unselOpts = new Array(count);
            for (i = 0; i < count; i++) {
              unselOpts[i] = scene.selectBatch[i].length || scene.unselectBatch[i].length ? scene.markerUnselectedOptions[i] : {};
            }
            scene.scatter2d.update(unselOpts);
          }
          if (scene.select2d) {
            scene.select2d.update(scene.markerOptions);
            scene.select2d.update(scene.markerSelectedOptions);
          }
          if (scene.glText) {
            cdata.forEach(function(cdscatter) {
              var trace2 = ((cdscatter || [])[0] || {}).trace || {};
              if (subTypes.hasText(trace2)) {
                styleTextSelection(cdscatter);
              }
            });
          }
        } else {
          if (scene.scatter2d) {
            scene.scatter2d.update(scene.markerOptions);
          }
        }
        var vpRange0 = {
          viewport: getViewport(fullLayout, xaxis, yaxis, gd._context.plotGlPixelRatio),
          // TODO do we need those fallbacks?
          range: [
            (xaxis._rl || xaxis.range)[0],
            (yaxis._rl || yaxis.range)[0],
            (xaxis._rl || xaxis.range)[1],
            (yaxis._rl || yaxis.range)[1]
          ]
        };
        var vpRange = Lib.repeat(vpRange0, scene.count);
        if (scene.fill2d) {
          scene.fill2d.update(vpRange);
        }
        if (scene.line2d) {
          scene.line2d.update(vpRange);
        }
        if (scene.error2d) {
          scene.error2d.update(vpRange.concat(vpRange));
        }
        if (scene.scatter2d) {
          scene.scatter2d.update(vpRange);
        }
        if (scene.select2d) {
          scene.select2d.update(vpRange);
        }
        if (scene.glText) {
          scene.glText.forEach(function(text) {
            text.update(vpRange0);
          });
        }
      };
      exports.reglPrecompiled = reglPrecompiled;
    }
  });

  // src/traces/scattergl/index.js
  var require_scattergl = __commonJS({
    "src/traces/scattergl/index.js"(exports, module) {
      "use strict";
      var index = require_base_index();
      index.plot = require_plot3();
      module.exports = index;
    }
  });

  // lib/scattergl.js
  var require_scattergl2 = __commonJS({
    "lib/scattergl.js"(exports, module) {
      "use strict";
      module.exports = require_scattergl();
    }
  });

  // src/traces/splom/attributes.js
  var require_attributes24 = __commonJS({
    "src/traces/splom/attributes.js"(exports, module) {
      "use strict";
      var scatterAttrs = require_attributes12();
      var colorScaleAttrs = require_attributes8();
      var axisHoverFormat = require_axis_format_attributes().axisHoverFormat;
      var hovertemplateAttrs = require_template_attributes().hovertemplateAttrs;
      var scatterGlAttrs = require_attributes23();
      var cartesianIdRegex = require_constants2().idRegex;
      var templatedArray = require_plot_template().templatedArray;
      var extendFlat = require_extend().extendFlat;
      var scatterMarkerAttrs = scatterAttrs.marker;
      var scatterMarkerLineAttrs = scatterMarkerAttrs.line;
      var markerLineAttrs = extendFlat(colorScaleAttrs("marker.line", { editTypeOverride: "calc" }), {
        width: extendFlat({}, scatterMarkerLineAttrs.width, { editType: "calc" }),
        editType: "calc"
      });
      var markerAttrs = extendFlat(colorScaleAttrs("marker"), {
        symbol: scatterMarkerAttrs.symbol,
        angle: scatterMarkerAttrs.angle,
        size: extendFlat({}, scatterMarkerAttrs.size, { editType: "markerSize" }),
        sizeref: scatterMarkerAttrs.sizeref,
        sizemin: scatterMarkerAttrs.sizemin,
        sizemode: scatterMarkerAttrs.sizemode,
        opacity: scatterMarkerAttrs.opacity,
        colorbar: scatterMarkerAttrs.colorbar,
        line: markerLineAttrs,
        editType: "calc"
      });
      markerAttrs.color.editType = markerAttrs.cmin.editType = markerAttrs.cmax.editType = "style";
      function makeAxesValObject(axLetter) {
        return {
          valType: "info_array",
          freeLength: true,
          editType: "calc",
          items: {
            valType: "subplotid",
            regex: cartesianIdRegex[axLetter],
            editType: "plot"
          }
        };
      }
      module.exports = {
        dimensions: templatedArray("dimension", {
          visible: {
            valType: "boolean",
            dflt: true,
            editType: "calc"
          },
          label: {
            valType: "string",
            editType: "calc"
          },
          values: {
            valType: "data_array",
            editType: "calc+clearAxisTypes"
          },
          axis: {
            type: {
              valType: "enumerated",
              values: ["linear", "log", "date", "category"],
              editType: "calc+clearAxisTypes"
            },
            // TODO make 'true' the default in v3?
            matches: {
              valType: "boolean",
              dflt: false,
              editType: "calc"
            },
            editType: "calc+clearAxisTypes"
          },
          // TODO should add an attribute to pin down x only vars and y only vars
          // like https://seaborn.pydata.org/generated/seaborn.pairplot.html
          // x_vars and y_vars
          // maybe more axis defaulting option e.g. `showgrid: false`
          editType: "calc+clearAxisTypes"
        }),
        // mode: {}, (only 'markers' for now)
        text: extendFlat({}, scatterGlAttrs.text, {}),
        hovertext: extendFlat({}, scatterGlAttrs.hovertext, {}),
        hovertemplate: hovertemplateAttrs(),
        xhoverformat: axisHoverFormat("x"),
        yhoverformat: axisHoverFormat("y"),
        marker: markerAttrs,
        xaxes: makeAxesValObject("x"),
        yaxes: makeAxesValObject("y"),
        diagonal: {
          visible: {
            valType: "boolean",
            dflt: true,
            editType: "calc"
          },
          // type: 'scattergl' | 'histogram' | 'box' | 'violin'
          // ...
          // more options
          editType: "calc"
        },
        showupperhalf: {
          valType: "boolean",
          dflt: true,
          editType: "calc"
        },
        showlowerhalf: {
          valType: "boolean",
          dflt: true,
          editType: "calc"
        },
        selected: {
          marker: scatterGlAttrs.selected.marker,
          editType: "calc"
        },
        unselected: {
          marker: scatterGlAttrs.unselected.marker,
          editType: "calc"
        },
        opacity: scatterGlAttrs.opacity
      };
    }
  });

  // src/traces/parcoords/merge_length.js
  var require_merge_length = __commonJS({
    "src/traces/parcoords/merge_length.js"(exports, module) {
      "use strict";
      module.exports = function(traceOut, dimensions, dataAttr, len) {
        if (!len) len = Infinity;
        var i, dimi;
        for (i = 0; i < dimensions.length; i++) {
          dimi = dimensions[i];
          if (dimi.visible) len = Math.min(len, dimi[dataAttr].length);
        }
        if (len === Infinity) len = 0;
        traceOut._length = len;
        for (i = 0; i < dimensions.length; i++) {
          dimi = dimensions[i];
          if (dimi.visible) dimi._length = len;
        }
        return len;
      };
    }
  });

  // src/traces/splom/defaults.js
  var require_defaults20 = __commonJS({
    "src/traces/splom/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var handleArrayContainerDefaults = require_array_container_defaults();
      var attributes = require_attributes24();
      var subTypes = require_subtypes();
      var handleMarkerDefaults = require_marker_defaults();
      var mergeLength = require_merge_length();
      var isOpenSymbol = require_helpers12().isOpenSymbol;
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var dimensions = handleArrayContainerDefaults(traceIn, traceOut, {
          name: "dimensions",
          handleItemDefaults: dimensionDefaults
        });
        var showDiag = coerce("diagonal.visible");
        var showUpper = coerce("showupperhalf");
        var showLower = coerce("showlowerhalf");
        var dimLength = mergeLength(traceOut, dimensions, "values");
        if (!dimLength || !showDiag && !showUpper && !showLower) {
          traceOut.visible = false;
          return;
        }
        coerce("text");
        coerce("hovertext");
        coerce("hovertemplate");
        coerce("xhoverformat");
        coerce("yhoverformat");
        handleMarkerDefaults(traceIn, traceOut, defaultColor, layout, coerce, { noAngleRef: true, noStandOff: true });
        var isOpen = isOpenSymbol(traceOut.marker.symbol);
        var isBubble = subTypes.isBubble(traceOut);
        coerce("marker.line.width", isOpen || isBubble ? 1 : 0);
        handleAxisDefaults(traceIn, traceOut, layout, coerce);
        Lib.coerceSelectionMarkerOpacity(traceOut, coerce);
      };
      function dimensionDefaults(dimIn, dimOut) {
        function coerce(attr, dflt) {
          return Lib.coerce(dimIn, dimOut, attributes.dimensions, attr, dflt);
        }
        coerce("label");
        var values = coerce("values");
        if (!(values && values.length)) dimOut.visible = false;
        else coerce("visible");
        coerce("axis.type");
        coerce("axis.matches");
      }
      function handleAxisDefaults(traceIn, traceOut, layout, coerce) {
        var dimensions = traceOut.dimensions;
        var dimLength = dimensions.length;
        var showUpper = traceOut.showupperhalf;
        var showLower = traceOut.showlowerhalf;
        var showDiag = traceOut.diagonal.visible;
        var i, j;
        var xAxesDflt = new Array(dimLength);
        var yAxesDflt = new Array(dimLength);
        for (i = 0; i < dimLength; i++) {
          var suffix = i ? i + 1 : "";
          xAxesDflt[i] = "x" + suffix;
          yAxesDflt[i] = "y" + suffix;
        }
        var xaxes = coerce("xaxes", xAxesDflt);
        var yaxes = coerce("yaxes", yAxesDflt);
        var diag = traceOut._diag = new Array(dimLength);
        traceOut._xaxes = {};
        traceOut._yaxes = {};
        var xList = [];
        var yList = [];
        function fillAxisStashes(axId, counterAxId, dim2, list) {
          if (!axId) return;
          var axLetter = axId.charAt(0);
          var stash = layout._splomAxes[axLetter];
          traceOut["_" + axLetter + "axes"][axId] = 1;
          list.push(axId);
          if (!(axId in stash)) {
            var s = stash[axId] = {};
            if (dim2) {
              s.label = dim2.label || "";
              if (dim2.visible && dim2.axis) {
                if (dim2.axis.type) s.type = dim2.axis.type;
                if (dim2.axis.matches) s.matches = counterAxId;
              }
            }
          }
        }
        var mustShiftX = !showDiag && !showLower;
        var mustShiftY = !showDiag && !showUpper;
        traceOut._axesDim = {};
        for (i = 0; i < dimLength; i++) {
          var dim = dimensions[i];
          var i0 = i === 0;
          var iN = i === dimLength - 1;
          var xaId = i0 && mustShiftX || iN && mustShiftY ? void 0 : xaxes[i];
          var yaId = i0 && mustShiftY || iN && mustShiftX ? void 0 : yaxes[i];
          fillAxisStashes(xaId, yaId, dim, xList);
          fillAxisStashes(yaId, xaId, dim, yList);
          diag[i] = [xaId, yaId];
          traceOut._axesDim[xaId] = i;
          traceOut._axesDim[yaId] = i;
        }
        for (i = 0; i < xList.length; i++) {
          for (j = 0; j < yList.length; j++) {
            var id = xList[i] + yList[j];
            if (i > j && showUpper) {
              layout._splomSubplots[id] = 1;
            } else if (i < j && showLower) {
              layout._splomSubplots[id] = 1;
            } else if (i === j && (showDiag || !showLower || !showUpper)) {
              layout._splomSubplots[id] = 1;
            }
          }
        }
        if (!showLower || !showDiag && showUpper && showLower) {
          layout._splomGridDflt.xside = "bottom";
          layout._splomGridDflt.yside = "left";
        }
      }
    }
  });

  // src/traces/splom/scene_update.js
  var require_scene_update2 = __commonJS({
    "src/traces/splom/scene_update.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      module.exports = function sceneUpdate(gd, trace) {
        var fullLayout = gd._fullLayout;
        var uid = trace.uid;
        var splomScenes = fullLayout._splomScenes;
        if (!splomScenes) splomScenes = fullLayout._splomScenes = {};
        var reset = {
          dirty: true,
          selectBatch: [],
          unselectBatch: []
        };
        var first = {
          matrix: false,
          selectBatch: [],
          unselectBatch: []
        };
        var scene = splomScenes[trace.uid];
        if (!scene) {
          scene = splomScenes[uid] = Lib.extendFlat({}, reset, first);
          scene.draw = function draw() {
            if (scene.matrix && scene.matrix.draw) {
              if (scene.selectBatch.length || scene.unselectBatch.length) {
                scene.matrix.draw(scene.unselectBatch, scene.selectBatch);
              } else {
                scene.matrix.draw();
              }
            }
            scene.dirty = false;
          };
          scene.destroy = function destroy() {
            if (scene.matrix && scene.matrix.destroy) {
              scene.matrix.destroy();
            }
            scene.matrixOptions = null;
            scene.selectBatch = null;
            scene.unselectBatch = null;
            scene = null;
          };
        }
        if (!scene.dirty) {
          Lib.extendFlat(scene, reset);
        }
        return scene;
      };
    }
  });

  // src/traces/splom/calc.js
  var require_calc6 = __commonJS({
    "src/traces/splom/calc.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var AxisIDs = require_axis_ids();
      var calcMarkerSize = require_calc3().calcMarkerSize;
      var calcAxisExpansion = require_calc3().calcAxisExpansion;
      var calcColorscale = require_colorscale_calc();
      var convertMarkerSelection = require_convert2().markerSelection;
      var convertMarkerStyle = require_convert2().markerStyle;
      var sceneUpdate = require_scene_update2();
      var BADNUM = require_numerical().BADNUM;
      var TOO_MANY_POINTS = require_constants14().TOO_MANY_POINTS;
      module.exports = function calc(gd, trace) {
        var dimensions = trace.dimensions;
        var commonLength = trace._length;
        var opts = {};
        var cdata = opts.cdata = [];
        var ldata = opts.data = [];
        var visibleDims = trace._visibleDims = [];
        var i, k, dim, xa, ya;
        function makeCalcdata(ax, dim2) {
          var ccol = ax.makeCalcdata({
            v: dim2.values,
            vcalendar: trace.calendar
          }, "v");
          for (var j = 0; j < ccol.length; j++) {
            ccol[j] = ccol[j] === BADNUM ? NaN : ccol[j];
          }
          cdata.push(ccol);
          ldata.push(ax.type === "log" ? Lib.simpleMap(ccol, ax.c2l) : ccol);
        }
        for (i = 0; i < dimensions.length; i++) {
          dim = dimensions[i];
          if (dim.visible) {
            xa = AxisIDs.getFromId(gd, trace._diag[i][0]);
            ya = AxisIDs.getFromId(gd, trace._diag[i][1]);
            if (xa && ya && xa.type !== ya.type) {
              Lib.log("Skipping splom dimension " + i + " with conflicting axis types");
              continue;
            }
            if (xa) {
              makeCalcdata(xa, dim);
              if (ya && ya.type === "category") {
                ya._categories = xa._categories.slice();
              }
            } else {
              makeCalcdata(ya, dim);
            }
            visibleDims.push(i);
          }
        }
        calcColorscale(gd, trace);
        Lib.extendFlat(opts, convertMarkerStyle(gd, trace));
        var visibleLength = cdata.length;
        var hasTooManyPoints = visibleLength * commonLength > TOO_MANY_POINTS;
        var ppad;
        if (hasTooManyPoints) {
          ppad = opts.sizeAvg || Math.max(opts.size, 3);
        } else {
          ppad = calcMarkerSize(trace, commonLength);
        }
        for (k = 0; k < visibleDims.length; k++) {
          i = visibleDims[k];
          dim = dimensions[i];
          xa = AxisIDs.getFromId(gd, trace._diag[i][0]) || {};
          ya = AxisIDs.getFromId(gd, trace._diag[i][1]) || {};
          calcAxisExpansion(gd, trace, xa, ya, cdata[k], cdata[k], ppad);
        }
        var scene = sceneUpdate(gd, trace);
        if (!scene.matrix) scene.matrix = true;
        scene.matrixOptions = opts;
        scene.selectedOptions = convertMarkerSelection(gd, trace, trace.selected);
        scene.unselectedOptions = convertMarkerSelection(gd, trace, trace.unselected);
        return [{ x: false, y: false, t: {}, trace }];
      };
    }
  });

  // node_modules/performance-now/lib/performance-now.js
  var require_performance_now = __commonJS({
    "node_modules/performance-now/lib/performance-now.js"(exports, module) {
      (function() {
        var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
        if (typeof performance !== "undefined" && performance !== null && performance.now) {
          module.exports = function() {
            return performance.now();
          };
        } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
          module.exports = function() {
            return (getNanoSeconds() - nodeLoadTime) / 1e6;
          };
          hrtime = process.hrtime;
          getNanoSeconds = function() {
            var hr;
            hr = hrtime();
            return hr[0] * 1e9 + hr[1];
          };
          moduleLoadTime = getNanoSeconds();
          upTime = process.uptime() * 1e9;
          nodeLoadTime = moduleLoadTime - upTime;
        } else if (Date.now) {
          module.exports = function() {
            return Date.now() - loadTime;
          };
          loadTime = Date.now();
        } else {
          module.exports = function() {
            return (/* @__PURE__ */ new Date()).getTime() - loadTime;
          };
          loadTime = (/* @__PURE__ */ new Date()).getTime();
        }
      }).call(exports);
    }
  });

  // node_modules/raf/index.js
  var require_raf = __commonJS({
    "node_modules/raf/index.js"(exports, module) {
      var now = require_performance_now();
      var root = typeof window === "undefined" ? window : window;
      var vendors = ["moz", "webkit"];
      var suffix = "AnimationFrame";
      var raf = root["request" + suffix];
      var caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
      for (i = 0; !raf && i < vendors.length; i++) {
        raf = root[vendors[i] + "Request" + suffix];
        caf = root[vendors[i] + "Cancel" + suffix] || root[vendors[i] + "CancelRequest" + suffix];
      }
      var i;
      if (!raf || !caf) {
        last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
        raf = function(callback) {
          if (queue.length === 0) {
            var _now = now(), next = Math.max(0, frameDuration - (_now - last));
            last = next + _now;
            setTimeout(function() {
              var cp = queue.slice(0);
              queue.length = 0;
              for (var i2 = 0; i2 < cp.length; i2++) {
                if (!cp[i2].cancelled) {
                  try {
                    cp[i2].callback(last);
                  } catch (e) {
                    setTimeout(function() {
                      throw e;
                    }, 0);
                  }
                }
              }
            }, Math.round(next));
          }
          queue.push({
            handle: ++id,
            callback,
            cancelled: false
          });
          return id;
        };
        caf = function(handle) {
          for (var i2 = 0; i2 < queue.length; i2++) {
            if (queue[i2].handle === handle) {
              queue[i2].cancelled = true;
            }
          }
        };
      }
      var last;
      var id;
      var queue;
      var frameDuration;
      module.exports = function(fn) {
        return raf.call(root, fn);
      };
      module.exports.cancel = function() {
        caf.apply(root, arguments);
      };
      module.exports.polyfill = function(object) {
        if (!object) {
          object = root;
        }
        object.requestAnimationFrame = raf;
        object.cancelAnimationFrame = caf;
      };
    }
  });

  // node_modules/array-range/index.js
  var require_array_range = __commonJS({
    "node_modules/array-range/index.js"(exports, module) {
      module.exports = function newArray(start, end) {
        var n0 = typeof start === "number", n1 = typeof end === "number";
        if (n0 && !n1) {
          end = start;
          start = 0;
        } else if (!n0 && !n1) {
          start = 0;
          end = 0;
        }
        start = start | 0;
        end = end | 0;
        var len = end - start;
        if (len < 0)
          throw new Error("array length must be positive");
        var a = new Array(len);
        for (var i = 0, c = start; i < len; i++, c++)
          a[i] = c;
        return a;
      };
    }
  });

  // node_modules/regl-splom/index.js
  var require_regl_splom = __commonJS({
    "node_modules/regl-splom/index.js"(exports, module) {
      "use strict";
      var createScatter = require_bundle();
      var pick = require_pick_by_alias();
      var getBounds = require_array_bounds();
      var raf = require_raf();
      var arrRange = require_array_range();
      var rect = require_parse_rect();
      var flatten = require_flatten_vertex_data();
      module.exports = SPLOM;
      function SPLOM(regl, options) {
        if (!(this instanceof SPLOM)) return new SPLOM(regl, options);
        this.traces = [];
        this.passes = {};
        this.regl = regl;
        this.scatter = createScatter(regl);
        this.canvas = this.scatter.canvas;
      }
      SPLOM.prototype.render = function(...args) {
        if (args.length) {
          this.update(...args);
        }
        if (this.regl.attributes.preserveDrawingBuffer) return this.draw();
        if (this.dirty) {
          if (this.planned == null) {
            this.planned = raf(() => {
              this.draw();
              this.dirty = true;
              this.planned = null;
            });
          }
        } else {
          this.draw();
          this.dirty = true;
          raf(() => {
            this.dirty = false;
          });
        }
        return this;
      };
      SPLOM.prototype.update = function(...args) {
        if (!args.length) return;
        for (let i = 0; i < args.length; i++) {
          this.updateItem(i, args[i]);
        }
        this.traces = this.traces.filter(Boolean);
        let passes = [];
        let offset = 0;
        for (let i = 0; i < this.traces.length; i++) {
          let trace = this.traces[i];
          let tracePasses = this.traces[i].passes;
          for (let j = 0; j < tracePasses.length; j++) {
            passes.push(this.passes[tracePasses[j]]);
          }
          trace.passOffset = offset;
          offset += trace.passes.length;
        }
        this.scatter.update(...passes);
        return this;
      };
      SPLOM.prototype.updateItem = function(i, options) {
        let { regl } = this;
        if (options === null) {
          this.traces[i] = null;
          return this;
        }
        if (!options) return this;
        let o = pick(options, {
          data: "data items columns rows values dimensions samples x",
          snap: "snap cluster",
          size: "sizes size radius",
          color: "colors color fill fill-color fillColor",
          opacity: "opacity alpha transparency opaque",
          borderSize: "borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline",
          borderColor: "borderColors borderColor bordercolor stroke stroke-color strokeColor",
          marker: "markers marker shape",
          range: "range ranges databox dataBox",
          viewport: "viewport viewBox viewbox",
          domain: "domain domains area areas",
          padding: "pad padding paddings pads margin margins",
          transpose: "transpose transposed",
          diagonal: "diagonal diag showDiagonal",
          upper: "upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf",
          lower: "lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower"
        });
        let trace = this.traces[i] || (this.traces[i] = {
          id: i,
          buffer: regl.buffer({
            usage: "dynamic",
            type: "float",
            data: new Uint8Array()
          }),
          color: "black",
          marker: null,
          size: 12,
          borderColor: "transparent",
          borderSize: 1,
          viewport: rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),
          padding: [0, 0, 0, 0],
          opacity: 1,
          diagonal: true,
          upper: true,
          lower: true
        });
        if (o.color != null) {
          trace.color = o.color;
        }
        if (o.size != null) {
          trace.size = o.size;
        }
        if (o.marker != null) {
          trace.marker = o.marker;
        }
        if (o.borderColor != null) {
          trace.borderColor = o.borderColor;
        }
        if (o.borderSize != null) {
          trace.borderSize = o.borderSize;
        }
        if (o.opacity != null) {
          trace.opacity = o.opacity;
        }
        if (o.viewport) {
          trace.viewport = rect(o.viewport);
        }
        if (o.diagonal != null) trace.diagonal = o.diagonal;
        if (o.upper != null) trace.upper = o.upper;
        if (o.lower != null) trace.lower = o.lower;
        if (o.data) {
          trace.buffer(flatten(o.data));
          trace.columns = o.data.length;
          trace.count = o.data[0].length;
          trace.bounds = [];
          for (let i2 = 0; i2 < trace.columns; i2++) {
            trace.bounds[i2] = getBounds(o.data[i2], 1);
          }
        }
        let multirange;
        if (o.range) {
          trace.range = o.range;
          multirange = trace.range && typeof trace.range[0] !== "number";
        }
        if (o.domain) {
          trace.domain = o.domain;
        }
        let multipadding = false;
        if (o.padding != null) {
          if (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === "number") {
            trace.padding = o.padding.map(getPad);
            multipadding = true;
          } else {
            trace.padding = getPad(o.padding);
          }
        }
        let m = trace.columns;
        let n = trace.count;
        let w = trace.viewport.width;
        let h = trace.viewport.height;
        let left = trace.viewport.x;
        let top = trace.viewport.y;
        let iw = w / m;
        let ih = h / m;
        trace.passes = [];
        for (let i2 = 0; i2 < m; i2++) {
          for (let j = 0; j < m; j++) {
            if (!trace.diagonal && j === i2) continue;
            if (!trace.upper && i2 > j) continue;
            if (!trace.lower && i2 < j) continue;
            let key = passId(trace.id, i2, j);
            let pass = this.passes[key] || (this.passes[key] = {});
            if (o.data) {
              if (o.transpose) {
                pass.positions = {
                  x: { buffer: trace.buffer, offset: j, count: n, stride: m },
                  y: { buffer: trace.buffer, offset: i2, count: n, stride: m }
                };
              } else {
                pass.positions = {
                  x: { buffer: trace.buffer, offset: j * n, count: n },
                  y: { buffer: trace.buffer, offset: i2 * n, count: n }
                };
              }
              pass.bounds = getBox(trace.bounds, i2, j);
            }
            if (o.domain || o.viewport || o.data) {
              let pad = multipadding ? getBox(trace.padding, i2, j) : trace.padding;
              if (trace.domain) {
                let [lox, loy, hix, hiy] = getBox(trace.domain, i2, j);
                pass.viewport = [
                  left + lox * w + pad[0],
                  top + loy * h + pad[1],
                  left + hix * w - pad[2],
                  top + hiy * h - pad[3]
                ];
              } else {
                pass.viewport = [
                  left + j * iw + iw * pad[0],
                  top + i2 * ih + ih * pad[1],
                  left + (j + 1) * iw - iw * pad[2],
                  top + (i2 + 1) * ih - ih * pad[3]
                ];
              }
            }
            if (o.color) pass.color = trace.color;
            if (o.size) pass.size = trace.size;
            if (o.marker) pass.marker = trace.marker;
            if (o.borderSize) pass.borderSize = trace.borderSize;
            if (o.borderColor) pass.borderColor = trace.borderColor;
            if (o.opacity) pass.opacity = trace.opacity;
            if (o.range) {
              pass.range = multirange ? getBox(trace.range, i2, j) : trace.range || pass.bounds;
            }
            trace.passes.push(key);
          }
        }
        return this;
      };
      SPLOM.prototype.draw = function(...args) {
        if (!args.length) {
          this.scatter.draw();
        } else {
          let idx = [];
          for (let i = 0; i < args.length; i++) {
            if (typeof args[i] === "number") {
              let { passes, passOffset } = this.traces[args[i]];
              idx.push(...arrRange(passOffset, passOffset + passes.length));
            } else if (args[i].length) {
              let els = args[i];
              let { passes, passOffset } = this.traces[i];
              passes = passes.map((passId2, i2) => {
                idx[passOffset + i2] = els;
              });
            }
          }
          this.scatter.draw(...idx);
        }
        return this;
      };
      SPLOM.prototype.destroy = function() {
        this.traces.forEach((trace) => {
          if (trace.buffer && trace.buffer.destroy) trace.buffer.destroy();
        });
        this.traces = null;
        this.passes = null;
        this.scatter.destroy();
        return this;
      };
      function passId(trace, i, j) {
        let id = trace.id != null ? trace.id : trace;
        let n = i;
        let m = j;
        let key = id << 16 | (n & 255) << 8 | m & 255;
        return key;
      }
      function getBox(items, i, j) {
        let ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy;
        let iitem = items[i], jitem = items[j];
        if (iitem.length > 2) {
          ilox = iitem[0];
          ihix = iitem[2];
          iloy = iitem[1];
          ihiy = iitem[3];
        } else if (iitem.length) {
          ilox = iloy = iitem[0];
          ihix = ihiy = iitem[1];
        } else {
          ilox = iitem.x;
          iloy = iitem.y;
          ihix = iitem.x + iitem.width;
          ihiy = iitem.y + iitem.height;
        }
        if (jitem.length > 2) {
          jlox = jitem[0];
          jhix = jitem[2];
          jloy = jitem[1];
          jhiy = jitem[3];
        } else if (jitem.length) {
          jlox = jloy = jitem[0];
          jhix = jhiy = jitem[1];
        } else {
          jlox = jitem.x;
          jloy = jitem.y;
          jhix = jitem.x + jitem.width;
          jhiy = jitem.y + jitem.height;
        }
        return [jlox, iloy, jhix, ihiy];
      }
      function getPad(arg) {
        if (typeof arg === "number") return [arg, arg, arg, arg];
        else if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]];
        else {
          let box = rect(arg);
          return [box.x, box.y, box.x + box.width, box.y + box.height];
        }
      }
    }
  });

  // src/traces/splom/plot.js
  var require_plot4 = __commonJS({
    "src/traces/splom/plot.js"(exports, module) {
      "use strict";
      var createMatrix = require_regl_splom();
      var Lib = require_lib();
      var AxisIDs = require_axis_ids();
      var selectMode = require_helpers5().selectMode;
      module.exports = function plot(gd, _, splomCalcData) {
        if (!splomCalcData.length) return;
        for (var i = 0; i < splomCalcData.length; i++) {
          plotOne(gd, splomCalcData[i][0]);
        }
      };
      function plotOne(gd, cd0) {
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var trace = cd0.trace;
        var stash = cd0.t;
        var scene = fullLayout._splomScenes[trace.uid];
        var matrixOpts = scene.matrixOptions;
        var cdata = matrixOpts.cdata;
        var regl = fullLayout._glcanvas.data()[0].regl;
        var dragmode = fullLayout.dragmode;
        var xa, ya;
        var i, j, k;
        if (cdata.length === 0) return;
        matrixOpts.lower = trace.showupperhalf;
        matrixOpts.upper = trace.showlowerhalf;
        matrixOpts.diagonal = trace.diagonal.visible;
        var visibleDims = trace._visibleDims;
        var visibleLength = cdata.length;
        var viewOpts = scene.viewOpts = {};
        viewOpts.ranges = new Array(visibleLength);
        viewOpts.domains = new Array(visibleLength);
        for (k = 0; k < visibleDims.length; k++) {
          i = visibleDims[k];
          var rng = viewOpts.ranges[k] = new Array(4);
          var dmn = viewOpts.domains[k] = new Array(4);
          xa = AxisIDs.getFromId(gd, trace._diag[i][0]);
          if (xa) {
            rng[0] = xa._rl[0];
            rng[2] = xa._rl[1];
            dmn[0] = xa.domain[0];
            dmn[2] = xa.domain[1];
          }
          ya = AxisIDs.getFromId(gd, trace._diag[i][1]);
          if (ya) {
            rng[1] = ya._rl[0];
            rng[3] = ya._rl[1];
            dmn[1] = ya.domain[0];
            dmn[3] = ya.domain[1];
          }
        }
        var plotGlPixelRatio = gd._context.plotGlPixelRatio;
        var l = gs.l * plotGlPixelRatio;
        var b = gs.b * plotGlPixelRatio;
        var w = gs.w * plotGlPixelRatio;
        var h = gs.h * plotGlPixelRatio;
        viewOpts.viewport = [l, b, w + l, h + b];
        if (scene.matrix === true) {
          scene.matrix = createMatrix(regl);
        }
        var clickSelectEnabled = fullLayout.clickmode.indexOf("select") > -1;
        var isSelectMode = selectMode(dragmode) || !!trace.selectedpoints || clickSelectEnabled;
        var needsBaseUpdate = true;
        if (isSelectMode) {
          var commonLength = trace._length;
          if (trace.selectedpoints) {
            scene.selectBatch = trace.selectedpoints;
            var selPts = trace.selectedpoints;
            var selDict = {};
            for (i = 0; i < selPts.length; i++) {
              selDict[selPts[i]] = true;
            }
            var unselPts = [];
            for (i = 0; i < commonLength; i++) {
              if (!selDict[i]) unselPts.push(i);
            }
            scene.unselectBatch = unselPts;
          }
          var xpx = stash.xpx = new Array(visibleLength);
          var ypx = stash.ypx = new Array(visibleLength);
          for (k = 0; k < visibleDims.length; k++) {
            i = visibleDims[k];
            xa = AxisIDs.getFromId(gd, trace._diag[i][0]);
            if (xa) {
              xpx[k] = new Array(commonLength);
              for (j = 0; j < commonLength; j++) {
                xpx[k][j] = xa.c2p(cdata[k][j]);
              }
            }
            ya = AxisIDs.getFromId(gd, trace._diag[i][1]);
            if (ya) {
              ypx[k] = new Array(commonLength);
              for (j = 0; j < commonLength; j++) {
                ypx[k][j] = ya.c2p(cdata[k][j]);
              }
            }
          }
          if (scene.selectBatch.length || scene.unselectBatch.length) {
            var unselOpts = Lib.extendFlat({}, matrixOpts, scene.unselectedOptions, viewOpts);
            var selOpts = Lib.extendFlat({}, matrixOpts, scene.selectedOptions, viewOpts);
            scene.matrix.update(unselOpts, selOpts);
            needsBaseUpdate = false;
          }
        } else {
          stash.xpx = stash.ypx = null;
        }
        if (needsBaseUpdate) {
          var opts = Lib.extendFlat({}, matrixOpts, viewOpts);
          scene.matrix.update(opts, null);
        }
      }
    }
  });

  // src/traces/splom/helpers.js
  var require_helpers13 = __commonJS({
    "src/traces/splom/helpers.js"(exports) {
      "use strict";
      exports.getDimIndex = function getDimIndex(trace, ax) {
        var axId = ax._id;
        var axLetter = axId.charAt(0);
        var ind = { x: 0, y: 1 }[axLetter];
        var visibleDims = trace._visibleDims;
        for (var k = 0; k < visibleDims.length; k++) {
          var i = visibleDims[k];
          if (trace._diag[i][ind] === axId) return k;
        }
        return false;
      };
    }
  });

  // src/traces/splom/hover.js
  var require_hover4 = __commonJS({
    "src/traces/splom/hover.js"(exports, module) {
      "use strict";
      var helpers = require_helpers13();
      var calcHover = require_hover3().calcHover;
      var getFromId = require_axes().getFromId;
      var extendFlat = require_extend().extendFlat;
      function hoverPoints(pointData, xval, yval, hovermode, opts) {
        if (!opts) opts = {};
        var hovermodeHasX = (hovermode || "").charAt(0) === "x";
        var hovermodeHasY = (hovermode || "").charAt(0) === "y";
        var points = _hoverPoints(pointData, xval, yval);
        if ((hovermodeHasX || hovermodeHasY) && opts.hoversubplots === "axis" && points[0]) {
          var subplotsWith = (hovermodeHasX ? pointData.xa : pointData.ya)._subplotsWith;
          var gd = opts.gd;
          var _pointData = extendFlat({}, pointData);
          for (var i = 0; i < subplotsWith.length; i++) {
            var spId = subplotsWith[i];
            if (spId === pointData.xa._id + pointData.ya._id) continue;
            if (hovermodeHasY) {
              _pointData.xa = getFromId(gd, spId, "x");
            } else {
              _pointData.ya = getFromId(gd, spId, "y");
            }
            var axisHoversubplots = hovermodeHasX || hovermodeHasY;
            var newPoints = _hoverPoints(_pointData, xval, yval, axisHoversubplots);
            points = points.concat(newPoints);
          }
        }
        return points;
      }
      function _hoverPoints(pointData, xval, yval, axisHoversubplots) {
        var cd = pointData.cd;
        var trace = cd[0].trace;
        var scene = pointData.scene;
        var cdata = scene.matrixOptions.cdata;
        var xa = pointData.xa;
        var ya = pointData.ya;
        var xpx = xa.c2p(xval);
        var ypx = ya.c2p(yval);
        var maxDistance = pointData.distance;
        var xi = helpers.getDimIndex(trace, xa);
        var yi = helpers.getDimIndex(trace, ya);
        if (xi === false || yi === false) return [pointData];
        var x = cdata[xi];
        var y = cdata[yi];
        var id, dxy;
        var minDist = maxDistance;
        for (var i = 0; i < x.length; i++) {
          if (axisHoversubplots && i !== pointData.index) continue;
          var ptx = x[i];
          var pty = y[i];
          var dx = xa.c2p(ptx) - xpx;
          var dy = ya.c2p(pty) - ypx;
          var dist = Math.sqrt(dx * dx + dy * dy);
          if (axisHoversubplots || dist < minDist) {
            minDist = dxy = dist;
            id = i;
          }
        }
        pointData.index = id;
        pointData.distance = minDist;
        pointData.dxy = dxy;
        if (id === void 0) return [pointData];
        return [calcHover(pointData, x, y, trace)];
      }
      module.exports = {
        hoverPoints
      };
    }
  });

  // src/traces/splom/select.js
  var require_select4 = __commonJS({
    "src/traces/splom/select.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var pushUnique = Lib.pushUnique;
      var subTypes = require_subtypes();
      var helpers = require_helpers13();
      module.exports = function select(searchInfo, selectionTester) {
        var cd = searchInfo.cd;
        var trace = cd[0].trace;
        var stash = cd[0].t;
        var scene = searchInfo.scene;
        var cdata = scene.matrixOptions.cdata;
        var xa = searchInfo.xaxis;
        var ya = searchInfo.yaxis;
        var selection = [];
        if (!scene) return selection;
        var hasOnlyLines = !subTypes.hasMarkers(trace) && !subTypes.hasText(trace);
        if (trace.visible !== true || hasOnlyLines) return selection;
        var xi = helpers.getDimIndex(trace, xa);
        var yi = helpers.getDimIndex(trace, ya);
        if (xi === false || yi === false) return selection;
        var xpx = stash.xpx[xi];
        var ypx = stash.ypx[yi];
        var x = cdata[xi];
        var y = cdata[yi];
        var els = (searchInfo.scene.selectBatch || []).slice();
        var unels = [];
        if (selectionTester !== false && !selectionTester.degenerate) {
          for (var i = 0; i < x.length; i++) {
            if (selectionTester.contains([xpx[i], ypx[i]], null, i, searchInfo)) {
              selection.push({
                pointNumber: i,
                x: x[i],
                y: y[i]
              });
              pushUnique(els, i);
            } else if (els.indexOf(i) !== -1) {
              pushUnique(els, i);
            } else {
              unels.push(i);
            }
          }
        }
        var matrixOpts = scene.matrixOptions;
        if (!els.length && !unels.length) {
          scene.matrix.update(matrixOpts, null);
        } else if (!scene.selectBatch.length && !scene.unselectBatch.length) {
          scene.matrix.update(
            scene.unselectedOptions,
            Lib.extendFlat({}, matrixOpts, scene.selectedOptions, scene.viewOpts)
          );
        }
        scene.selectBatch = els;
        scene.unselectBatch = unels;
        return selection;
      };
    }
  });

  // src/traces/splom/edit_style.js
  var require_edit_style2 = __commonJS({
    "src/traces/splom/edit_style.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var calcColorscale = require_colorscale_calc();
      var convertMarkerStyle = require_convert2().markerStyle;
      module.exports = function editStyle(gd, cd0) {
        var trace = cd0.trace;
        var scene = gd._fullLayout._splomScenes[trace.uid];
        if (scene) {
          calcColorscale(gd, trace);
          Lib.extendFlat(scene.matrixOptions, convertMarkerStyle(gd, trace));
          var opts = Lib.extendFlat({}, scene.matrixOptions, scene.viewOpts);
          scene.matrix.update(opts, null);
        }
      };
    }
  });

  // src/traces/splom/base_index.js
  var require_base_index2 = __commonJS({
    "src/traces/splom/base_index.js"(exports, module) {
      "use strict";
      var Registry = require_registry();
      var Grid = require_grid();
      module.exports = {
        moduleType: "trace",
        name: "splom",
        categories: ["gl", "regl", "cartesian", "symbols", "showLegend", "scatter-like"],
        attributes: require_attributes24(),
        supplyDefaults: require_defaults20(),
        colorbar: require_marker_colorbar(),
        calc: require_calc6(),
        plot: require_plot4(),
        hoverPoints: require_hover4().hoverPoints,
        selectPoints: require_select4(),
        editStyle: require_edit_style2(),
        meta: {}
      };
      Registry.register(Grid);
    }
  });

  // src/traces/splom/base_plot.js
  var require_base_plot = __commonJS({
    "src/traces/splom/base_plot.js"(exports, module) {
      "use strict";
      var createLine = require_regl_line2d();
      var Registry = require_registry();
      var prepareRegl = require_prepare_regl();
      var getModuleCalcData = require_get_data().getModuleCalcData;
      var Cartesian = require_cartesian();
      var getFromId = require_axis_ids().getFromId;
      var shouldShowZeroLine = require_axes().shouldShowZeroLine;
      var SPLOM = "splom";
      var reglPrecompiled = {};
      function plot(gd) {
        var fullLayout = gd._fullLayout;
        var _module = Registry.getModule(SPLOM);
        var splomCalcData = getModuleCalcData(gd.calcdata, _module)[0];
        var success = prepareRegl(gd, ["ANGLE_instanced_arrays", "OES_element_index_uint"], reglPrecompiled);
        if (!success) return;
        if (fullLayout._hasOnlyLargeSploms) {
          updateGrid(gd);
        }
        _module.plot(gd, {}, splomCalcData);
      }
      function drag(gd) {
        var cd = gd.calcdata;
        var fullLayout = gd._fullLayout;
        if (fullLayout._hasOnlyLargeSploms) {
          updateGrid(gd);
        }
        for (var i = 0; i < cd.length; i++) {
          var cd0 = cd[i][0];
          var trace = cd0.trace;
          var scene = fullLayout._splomScenes[trace.uid];
          if (trace.type === "splom" && scene && scene.matrix) {
            dragOne(gd, trace, scene);
          }
        }
      }
      function dragOne(gd, trace, scene) {
        var visibleLength = scene.matrixOptions.data.length;
        var visibleDims = trace._visibleDims;
        var ranges = scene.viewOpts.ranges = new Array(visibleLength);
        for (var k = 0; k < visibleDims.length; k++) {
          var i = visibleDims[k];
          var rng = ranges[k] = new Array(4);
          var xa = getFromId(gd, trace._diag[i][0]);
          if (xa) {
            rng[0] = xa.r2l(xa.range[0]);
            rng[2] = xa.r2l(xa.range[1]);
          }
          var ya = getFromId(gd, trace._diag[i][1]);
          if (ya) {
            rng[1] = ya.r2l(ya.range[0]);
            rng[3] = ya.r2l(ya.range[1]);
          }
        }
        if (scene.selectBatch.length || scene.unselectBatch.length) {
          scene.matrix.update({ ranges }, { ranges });
        } else {
          scene.matrix.update({ ranges });
        }
      }
      function updateGrid(gd) {
        var fullLayout = gd._fullLayout;
        var regl = fullLayout._glcanvas.data()[0].regl;
        var splomGrid = fullLayout._splomGrid;
        if (!splomGrid) {
          splomGrid = fullLayout._splomGrid = createLine(regl);
        }
        splomGrid.update(makeGridData(gd));
      }
      function makeGridData(gd) {
        var plotGlPixelRatio = gd._context.plotGlPixelRatio;
        var fullLayout = gd._fullLayout;
        var gs = fullLayout._size;
        var fullView = [
          0,
          0,
          fullLayout.width * plotGlPixelRatio,
          fullLayout.height * plotGlPixelRatio
        ];
        var lookup = {};
        var k;
        function push(prefix, ax, x0, x1, y0, y1) {
          x0 *= plotGlPixelRatio;
          x1 *= plotGlPixelRatio;
          y0 *= plotGlPixelRatio;
          y1 *= plotGlPixelRatio;
          var lcolor = ax[prefix + "color"];
          var lwidth = ax[prefix + "width"];
          var key = String(lcolor + lwidth);
          if (key in lookup) {
            lookup[key].data.push(NaN, NaN, x0, x1, y0, y1);
          } else {
            lookup[key] = {
              data: [x0, x1, y0, y1],
              join: "rect",
              thickness: lwidth * plotGlPixelRatio,
              color: lcolor,
              viewport: fullView,
              range: fullView,
              overlay: false
            };
          }
        }
        for (k in fullLayout._splomSubplots) {
          var sp = fullLayout._plots[k];
          var xa = sp.xaxis;
          var ya = sp.yaxis;
          var xVals = xa._gridVals;
          var yVals = ya._gridVals;
          var xOffset = xa._offset;
          var xLength = xa._length;
          var yLength = ya._length;
          var yOffset = gs.b + ya.domain[0] * gs.h;
          var ym = -ya._m;
          var yb = -ym * ya.r2l(ya.range[0], ya.calendar);
          var x, y;
          if (xa.showgrid) {
            for (k = 0; k < xVals.length; k++) {
              x = xOffset + xa.l2p(xVals[k].x);
              push("grid", xa, x, yOffset, x, yOffset + yLength);
            }
          }
          if (ya.showgrid) {
            for (k = 0; k < yVals.length; k++) {
              y = yOffset + yb + ym * yVals[k].x;
              push("grid", ya, xOffset, y, xOffset + xLength, y);
            }
          }
          if (shouldShowZeroLine(gd, xa, ya)) {
            x = xOffset + xa.l2p(0);
            push("zeroline", xa, x, yOffset, x, yOffset + yLength);
          }
          if (shouldShowZeroLine(gd, ya, xa)) {
            y = yOffset + yb + 0;
            push("zeroline", ya, xOffset, y, xOffset + xLength, y);
          }
        }
        var gridBatches = [];
        for (k in lookup) {
          gridBatches.push(lookup[k]);
        }
        return gridBatches;
      }
      function clean(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var lookup = {};
        var i;
        if (oldFullLayout._splomScenes) {
          for (i = 0; i < newFullData.length; i++) {
            var newTrace = newFullData[i];
            if (newTrace.type === "splom") {
              lookup[newTrace.uid] = 1;
            }
          }
          for (i = 0; i < oldFullData.length; i++) {
            var oldTrace = oldFullData[i];
            if (!lookup[oldTrace.uid]) {
              var scene = oldFullLayout._splomScenes[oldTrace.uid];
              if (scene && scene.destroy) scene.destroy();
              oldFullLayout._splomScenes[oldTrace.uid] = null;
              delete oldFullLayout._splomScenes[oldTrace.uid];
            }
          }
        }
        if (Object.keys(oldFullLayout._splomScenes || {}).length === 0) {
          delete oldFullLayout._splomScenes;
        }
        if (oldFullLayout._splomGrid && (!newFullLayout._hasOnlyLargeSploms && oldFullLayout._hasOnlyLargeSploms)) {
          oldFullLayout._splomGrid.destroy();
          oldFullLayout._splomGrid = null;
          delete oldFullLayout._splomGrid;
        }
        Cartesian.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);
      }
      module.exports = {
        name: SPLOM,
        attr: Cartesian.attr,
        attrRegex: Cartesian.attrRegex,
        layoutAttributes: Cartesian.layoutAttributes,
        supplyLayoutDefaults: Cartesian.supplyLayoutDefaults,
        drawFramework: Cartesian.drawFramework,
        plot,
        drag,
        updateGrid,
        clean,
        updateFx: Cartesian.updateFx,
        toSVG: Cartesian.toSVG,
        reglPrecompiled
      };
    }
  });

  // src/traces/splom/index.js
  var require_splom = __commonJS({
    "src/traces/splom/index.js"(exports, module) {
      "use strict";
      var index = require_base_index2();
      index.basePlotModule = require_base_plot(), module.exports = index;
    }
  });

  // lib/splom.js
  var require_splom2 = __commonJS({
    "lib/splom.js"(exports, module) {
      "use strict";
      module.exports = require_splom();
    }
  });

  // src/traces/parcoords/attributes.js
  var require_attributes25 = __commonJS({
    "src/traces/parcoords/attributes.js"(exports, module) {
      "use strict";
      var colorScaleAttrs = require_attributes8();
      var axesAttrs = require_layout_attributes4();
      var fontAttrs = require_font_attributes();
      var domainAttrs = require_domain().attributes;
      var extendFlat = require_extend().extendFlat;
      var templatedArray = require_plot_template().templatedArray;
      module.exports = {
        domain: domainAttrs({ name: "parcoords", trace: true, editType: "plot" }),
        labelangle: {
          valType: "angle",
          dflt: 0,
          editType: "plot"
        },
        labelside: {
          valType: "enumerated",
          values: ["top", "bottom"],
          dflt: "top",
          editType: "plot"
        },
        labelfont: fontAttrs({
          editType: "plot"
        }),
        tickfont: fontAttrs({
          autoShadowDflt: true,
          editType: "plot"
        }),
        rangefont: fontAttrs({
          editType: "plot"
        }),
        dimensions: templatedArray("dimension", {
          label: {
            valType: "string",
            editType: "plot"
          },
          // TODO: better way to determine ordinal vs continuous axes,
          // so users can use tickvals/ticktext with a continuous axis.
          tickvals: extendFlat({}, axesAttrs.tickvals, {
            editType: "plot"
          }),
          ticktext: extendFlat({}, axesAttrs.ticktext, {
            editType: "plot"
          }),
          tickformat: extendFlat({}, axesAttrs.tickformat, {
            editType: "plot"
          }),
          visible: {
            valType: "boolean",
            dflt: true,
            editType: "plot"
          },
          range: {
            valType: "info_array",
            items: [
              { valType: "number", editType: "plot" },
              { valType: "number", editType: "plot" }
            ],
            editType: "plot"
          },
          constraintrange: {
            valType: "info_array",
            freeLength: true,
            dimensions: "1-2",
            items: [
              { valType: "any", editType: "plot" },
              { valType: "any", editType: "plot" }
            ],
            editType: "plot"
          },
          multiselect: {
            valType: "boolean",
            dflt: true,
            editType: "plot"
          },
          values: {
            valType: "data_array",
            editType: "calc"
          },
          editType: "calc"
        }),
        line: extendFlat(
          { editType: "calc" },
          colorScaleAttrs("line", {
            // the default autocolorscale isn't quite usable for parcoords due to context ambiguity around 0 (grey, off-white)
            // autocolorscale therefore defaults to false too, to avoid being overridden by the blue-white-red autocolor palette
            colorscaleDflt: "Viridis",
            autoColorDflt: false,
            editTypeOverride: "calc"
          })
        ),
        unselected: {
          line: {
            color: {
              valType: "color",
              dflt: "#7f7f7f",
              editType: "plot"
            },
            opacity: {
              valType: "number",
              min: 0,
              max: 1,
              dflt: "auto",
              editType: "plot"
            },
            editType: "plot"
          },
          editType: "plot"
        }
      };
    }
  });

  // src/traces/parcoords/constants.js
  var require_constants15 = __commonJS({
    "src/traces/parcoords/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        maxDimensionCount: 60,
        // this cannot be increased without WebGL code refactoring
        overdrag: 45,
        verticalPadding: 2,
        // otherwise, horizontal lines on top or bottom are of lower width
        tickDistance: 50,
        canvasPixelRatio: 1,
        blockLineCount: 5e3,
        layers: ["contextLineLayer", "focusLineLayer", "pickLineLayer"],
        axisTitleOffset: 28,
        axisExtentOffset: 10,
        bar: {
          width: 4,
          // Visible width of the filter bar
          captureWidth: 10,
          // Mouse-sensitive width for interaction (Fitts law)
          fillColor: "magenta",
          // Color of the filter bar fill
          fillOpacity: 1,
          // Filter bar fill opacity
          snapDuration: 150,
          // tween duration in ms for brush snap for ordinal axes
          snapRatio: 0.25,
          // ratio of bar extension relative to the distance between two adjacent ordinal values
          snapClose: 0.01,
          // fraction of inter-value distance to snap to the closer one, even if you're not over it
          strokeOpacity: 1,
          // Filter bar side stroke opacity
          strokeWidth: 1,
          // Filter bar side stroke width in pixels
          handleHeight: 8,
          // Height of the filter bar vertical resize areas on top and bottom
          handleOpacity: 1,
          // Opacity of the filter bar vertical resize areas on top and bottom
          handleOverlap: 0
          // A larger than 0 value causes overlaps with the filter bar, represented as pixels
        },
        cn: {
          axisExtentText: "axis-extent-text",
          parcoordsLineLayers: "parcoords-line-layers",
          parcoordsLineLayer: "parcoords-lines",
          parcoords: "parcoords",
          parcoordsControlView: "parcoords-control-view",
          yAxis: "y-axis",
          axisOverlays: "axis-overlays",
          axis: "axis",
          axisHeading: "axis-heading",
          axisTitle: "axis-title",
          axisExtent: "axis-extent",
          axisExtentTop: "axis-extent-top",
          axisExtentTopText: "axis-extent-top-text",
          axisExtentBottom: "axis-extent-bottom",
          axisExtentBottomText: "axis-extent-bottom-text",
          axisBrush: "axis-brush"
        },
        id: {
          filterBarPattern: "filter-bar-pattern"
        }
      };
    }
  });

  // src/lib/gup.js
  var require_gup = __commonJS({
    "src/lib/gup.js"(exports, module) {
      "use strict";
      var identity = require_identity2();
      function wrap(d) {
        return [d];
      }
      module.exports = {
        // The D3 data binding concept and the General Update Pattern promotes the idea of
        // traversing into the scenegraph by using the `.data(fun, keyFun)` call.
        // The `fun` is most often a `repeat`, ie. the elements beneath a `<g>` element need
        // access to the same data, or a `descend`, which fans a scenegraph node into a bunch of
        // of elements, e.g. points, lines, rows, requiring an array as input.
        // The role of the `keyFun` is to identify what elements are being entered/exited/updated,
        // otherwise D3 reverts to using a plain index which would screw up `transition`s.
        keyFun: function(d) {
          return d.key;
        },
        repeat: wrap,
        descend: identity,
        // Plotly.js uses a convention of storing the actual contents of the `calcData` as the
        // element zero of a container array. These helpers are just used for clarity as a
        // newcomer to the codebase may not know what the `[0]` is, and whether there can be further
        // elements (not atm).
        wrap,
        unwrap: function(d) {
          return d[0];
        }
      };
    }
  });

  // src/traces/parcoords/axisbrush.js
  var require_axisbrush = __commonJS({
    "src/traces/parcoords/axisbrush.js"(exports, module) {
      "use strict";
      var c = require_constants15();
      var d3 = require_d3();
      var keyFun = require_gup().keyFun;
      var repeat = require_gup().repeat;
      var sortAsc = require_lib().sorterAsc;
      var strTranslate = require_lib().strTranslate;
      var snapRatio = c.bar.snapRatio;
      function snapOvershoot(v, vAdjacent) {
        return v * (1 - snapRatio) + vAdjacent * snapRatio;
      }
      var snapClose = c.bar.snapClose;
      function closeToCovering(v, vAdjacent) {
        return v * (1 - snapClose) + vAdjacent * snapClose;
      }
      function ordinalScaleSnap(isHigh, a, v, existingRanges) {
        if (overlappingExisting(v, existingRanges)) return v;
        var dir = isHigh ? -1 : 1;
        var first = 0;
        var last = a.length - 1;
        if (dir < 0) {
          var tmp = first;
          first = last;
          last = tmp;
        }
        var aHere = a[first];
        var aPrev = aHere;
        for (var i = first; dir * i < dir * last; i += dir) {
          var nextI = i + dir;
          var aNext = a[nextI];
          if (dir * v < dir * closeToCovering(aHere, aNext)) return snapOvershoot(aHere, aPrev);
          if (dir * v < dir * aNext || nextI === last) return snapOvershoot(aNext, aHere);
          aPrev = aHere;
          aHere = aNext;
        }
      }
      function overlappingExisting(v, existingRanges) {
        for (var i = 0; i < existingRanges.length; i++) {
          if (v >= existingRanges[i][0] && v <= existingRanges[i][1]) return true;
        }
        return false;
      }
      function barHorizontalSetup(selection) {
        selection.attr("x", -c.bar.captureWidth / 2).attr("width", c.bar.captureWidth);
      }
      function backgroundBarHorizontalSetup(selection) {
        selection.attr("visibility", "visible").style("visibility", "visible").attr("fill", "yellow").attr("opacity", 0);
      }
      function setHighlight(d) {
        if (!d.brush.filterSpecified) {
          return "0," + d.height;
        }
        var pixelRanges = unitToPx(d.brush.filter.getConsolidated(), d.height);
        var dashArray = [0];
        var p, sectionHeight, iNext;
        var currentGap = pixelRanges.length ? pixelRanges[0][0] : null;
        for (var i = 0; i < pixelRanges.length; i++) {
          p = pixelRanges[i];
          sectionHeight = p[1] - p[0];
          dashArray.push(currentGap);
          dashArray.push(sectionHeight);
          iNext = i + 1;
          if (iNext < pixelRanges.length) {
            currentGap = pixelRanges[iNext][0] - p[1];
          }
        }
        dashArray.push(d.height);
        return dashArray;
      }
      function unitToPx(unitRanges, height) {
        return unitRanges.map(function(pr) {
          return pr.map(function(v) {
            return Math.max(0, v * height);
          }).sort(sortAsc);
        });
      }
      function getRegion(fPix, y) {
        var pad = c.bar.handleHeight;
        if (y > fPix[1] + pad || y < fPix[0] - pad) return;
        if (y >= 0.9 * fPix[1] + 0.1 * fPix[0]) return "n";
        if (y <= 0.9 * fPix[0] + 0.1 * fPix[1]) return "s";
        return "ns";
      }
      function clearCursor() {
        d3.select(document.body).style("cursor", null);
      }
      function styleHighlight(selection) {
        selection.attr("stroke-dasharray", setHighlight);
      }
      function renderHighlight(root, tweenCallback) {
        var bar = d3.select(root).selectAll(".highlight, .highlight-shadow");
        var barToStyle = tweenCallback ? bar.transition().duration(c.bar.snapDuration).each("end", tweenCallback) : bar;
        styleHighlight(barToStyle);
      }
      function getInterval(d, y) {
        var b = d.brush;
        var active = b.filterSpecified;
        var closestInterval = NaN;
        var out = {};
        var i;
        if (active) {
          var height = d.height;
          var intervals = b.filter.getConsolidated();
          var pixIntervals = unitToPx(intervals, height);
          var hoveredInterval = NaN;
          var previousInterval = NaN;
          var nextInterval = NaN;
          for (i = 0; i <= pixIntervals.length; i++) {
            var p = pixIntervals[i];
            if (p && p[0] <= y && y <= p[1]) {
              hoveredInterval = i;
              break;
            } else {
              previousInterval = i ? i - 1 : NaN;
              if (p && p[0] > y) {
                nextInterval = i;
                break;
              }
            }
          }
          closestInterval = hoveredInterval;
          if (isNaN(closestInterval)) {
            if (isNaN(previousInterval) || isNaN(nextInterval)) {
              closestInterval = isNaN(previousInterval) ? nextInterval : previousInterval;
            } else {
              closestInterval = y - pixIntervals[previousInterval][1] < pixIntervals[nextInterval][0] - y ? previousInterval : nextInterval;
            }
          }
          if (!isNaN(closestInterval)) {
            var fPix = pixIntervals[closestInterval];
            var region = getRegion(fPix, y);
            if (region) {
              out.interval = intervals[closestInterval];
              out.intervalPix = fPix;
              out.region = region;
            }
          }
        }
        if (d.ordinal && !out.region) {
          var a = d.unitTickvals;
          var unitLocation = d.unitToPaddedPx.invert(y);
          for (i = 0; i < a.length; i++) {
            var rangei = [
              a[Math.max(i - 1, 0)] * 0.25 + a[i] * 0.75,
              a[Math.min(i + 1, a.length - 1)] * 0.25 + a[i] * 0.75
            ];
            if (unitLocation >= rangei[0] && unitLocation <= rangei[1]) {
              out.clickableOrdinalRange = rangei;
              break;
            }
          }
        }
        return out;
      }
      function dragstart(lThis, d) {
        d3.event.sourceEvent.stopPropagation();
        var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;
        var unitLocation = d.unitToPaddedPx.invert(y);
        var b = d.brush;
        var interval = getInterval(d, y);
        var unitRange = interval.interval;
        var s = b.svgBrush;
        s.wasDragged = false;
        s.grabbingBar = interval.region === "ns";
        if (s.grabbingBar) {
          var pixelRange = unitRange.map(d.unitToPaddedPx);
          s.grabPoint = y - pixelRange[0] - c.verticalPadding;
          s.barLength = pixelRange[1] - pixelRange[0];
        }
        s.clickableOrdinalRange = interval.clickableOrdinalRange;
        s.stayingIntervals = d.multiselect && b.filterSpecified ? b.filter.getConsolidated() : [];
        if (unitRange) {
          s.stayingIntervals = s.stayingIntervals.filter(function(int2) {
            return int2[0] !== unitRange[0] && int2[1] !== unitRange[1];
          });
        }
        s.startExtent = interval.region ? unitRange[interval.region === "s" ? 1 : 0] : unitLocation;
        d.parent.inBrushDrag = true;
        s.brushStartCallback();
      }
      function drag(lThis, d) {
        d3.event.sourceEvent.stopPropagation();
        var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;
        var s = d.brush.svgBrush;
        s.wasDragged = true;
        s._dragging = true;
        if (s.grabbingBar) {
          s.newExtent = [y - s.grabPoint, y + s.barLength - s.grabPoint].map(d.unitToPaddedPx.invert);
        } else {
          s.newExtent = [s.startExtent, d.unitToPaddedPx.invert(y)].sort(sortAsc);
        }
        d.brush.filterSpecified = true;
        s.extent = s.stayingIntervals.concat([s.newExtent]);
        s.brushCallback(d);
        renderHighlight(lThis.parentNode);
      }
      function dragend(lThis, d) {
        var brush = d.brush;
        var filter = brush.filter;
        var s = brush.svgBrush;
        if (!s._dragging) {
          mousemove(lThis, d);
          drag(lThis, d);
          d.brush.svgBrush.wasDragged = false;
        }
        s._dragging = false;
        var e = d3.event;
        e.sourceEvent.stopPropagation();
        var grabbingBar = s.grabbingBar;
        s.grabbingBar = false;
        s.grabLocation = void 0;
        d.parent.inBrushDrag = false;
        clearCursor();
        if (!s.wasDragged) {
          s.wasDragged = void 0;
          if (s.clickableOrdinalRange) {
            if (brush.filterSpecified && d.multiselect) {
              s.extent.push(s.clickableOrdinalRange);
            } else {
              s.extent = [s.clickableOrdinalRange];
              brush.filterSpecified = true;
            }
          } else if (grabbingBar) {
            s.extent = s.stayingIntervals;
            if (s.extent.length === 0) {
              brushClear(brush);
            }
          } else {
            brushClear(brush);
          }
          s.brushCallback(d);
          renderHighlight(lThis.parentNode);
          s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);
          return;
        }
        var mergeIntervals = function() {
          filter.set(filter.getConsolidated());
        };
        if (d.ordinal) {
          var a = d.unitTickvals;
          if (a[a.length - 1] < a[0]) a.reverse();
          s.newExtent = [
            ordinalScaleSnap(0, a, s.newExtent[0], s.stayingIntervals),
            ordinalScaleSnap(1, a, s.newExtent[1], s.stayingIntervals)
          ];
          var hasNewExtent = s.newExtent[1] > s.newExtent[0];
          s.extent = s.stayingIntervals.concat(hasNewExtent ? [s.newExtent] : []);
          if (!s.extent.length) {
            brushClear(brush);
          }
          s.brushCallback(d);
          if (hasNewExtent) {
            renderHighlight(lThis.parentNode, mergeIntervals);
          } else {
            mergeIntervals();
            renderHighlight(lThis.parentNode);
          }
        } else {
          mergeIntervals();
        }
        s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);
      }
      function mousemove(lThis, d) {
        var y = d.height - d3.mouse(lThis)[1] - 2 * c.verticalPadding;
        var interval = getInterval(d, y);
        var cursor = "crosshair";
        if (interval.clickableOrdinalRange) cursor = "pointer";
        else if (interval.region) cursor = interval.region + "-resize";
        d3.select(document.body).style("cursor", cursor);
      }
      function attachDragBehavior(selection) {
        selection.on("mousemove", function(d) {
          d3.event.preventDefault();
          if (!d.parent.inBrushDrag) mousemove(this, d);
        }).on("mouseleave", function(d) {
          if (!d.parent.inBrushDrag) clearCursor();
        }).call(
          d3.behavior.drag().on("dragstart", function(d) {
            dragstart(this, d);
          }).on("drag", function(d) {
            drag(this, d);
          }).on("dragend", function(d) {
            dragend(this, d);
          })
        );
      }
      function startAsc(a, b) {
        return a[0] - b[0];
      }
      function renderAxisBrush(axisBrush, paperColor, gd) {
        var isStatic = gd._context.staticPlot;
        var background = axisBrush.selectAll(".background").data(repeat);
        background.enter().append("rect").classed("background", true).call(barHorizontalSetup).call(backgroundBarHorizontalSetup).style("pointer-events", isStatic ? "none" : "auto").attr("transform", strTranslate(0, c.verticalPadding));
        background.call(attachDragBehavior).attr("height", function(d) {
          return d.height - c.verticalPadding;
        });
        var highlightShadow = axisBrush.selectAll(".highlight-shadow").data(repeat);
        highlightShadow.enter().append("line").classed("highlight-shadow", true).attr("x", -c.bar.width / 2).attr("stroke-width", c.bar.width + c.bar.strokeWidth).attr("stroke", paperColor).attr("opacity", c.bar.strokeOpacity).attr("stroke-linecap", "butt");
        highlightShadow.attr("y1", function(d) {
          return d.height;
        }).call(styleHighlight);
        var highlight = axisBrush.selectAll(".highlight").data(repeat);
        highlight.enter().append("line").classed("highlight", true).attr("x", -c.bar.width / 2).attr("stroke-width", c.bar.width - c.bar.strokeWidth).attr("stroke", c.bar.fillColor).attr("opacity", c.bar.fillOpacity).attr("stroke-linecap", "butt");
        highlight.attr("y1", function(d) {
          return d.height;
        }).call(styleHighlight);
      }
      function ensureAxisBrush(axisOverlays, paperColor, gd) {
        var axisBrush = axisOverlays.selectAll("." + c.cn.axisBrush).data(repeat, keyFun);
        axisBrush.enter().append("g").classed(c.cn.axisBrush, true);
        renderAxisBrush(axisBrush, paperColor, gd);
      }
      function getBrushExtent(brush) {
        return brush.svgBrush.extent.map(function(e) {
          return e.slice();
        });
      }
      function brushClear(brush) {
        brush.filterSpecified = false;
        brush.svgBrush.extent = [[-Infinity, Infinity]];
      }
      function axisBrushMoved(callback) {
        return function axisBrushMoved2(dimension) {
          var brush = dimension.brush;
          var extent = getBrushExtent(brush);
          var newExtent = extent.slice();
          brush.filter.set(newExtent);
          callback();
        };
      }
      function dedupeRealRanges(intervals) {
        var queue = intervals.slice();
        var result = [];
        var currentInterval;
        var current = queue.shift();
        while (current) {
          currentInterval = current.slice();
          while ((current = queue.shift()) && current[0] <= /* right-open interval would need `<` */
          currentInterval[1]) {
            currentInterval[1] = Math.max(currentInterval[1], current[1]);
          }
          result.push(currentInterval);
        }
        if (result.length === 1 && result[0][0] > result[0][1]) {
          result = [];
        }
        return result;
      }
      function makeFilter() {
        var filter = [];
        var consolidated;
        var bounds;
        return {
          set: function(a) {
            filter = a.map(function(d) {
              return d.slice().sort(sortAsc);
            }).sort(startAsc);
            if (filter.length === 1 && filter[0][0] === -Infinity && filter[0][1] === Infinity) {
              filter = [[0, -1]];
            }
            consolidated = dedupeRealRanges(filter);
            bounds = filter.reduce(function(p, n) {
              return [Math.min(p[0], n[0]), Math.max(p[1], n[1])];
            }, [Infinity, -Infinity]);
          },
          get: function() {
            return filter.slice();
          },
          getConsolidated: function() {
            return consolidated;
          },
          getBounds: function() {
            return bounds;
          }
        };
      }
      function makeBrush(state, rangeSpecified, initialRange, brushStartCallback, brushCallback, brushEndCallback) {
        var filter = makeFilter();
        filter.set(initialRange);
        return {
          filter,
          filterSpecified: rangeSpecified,
          // there's a difference between not filtering and filtering a non-proper subset
          svgBrush: {
            extent: [],
            // this is where the svgBrush writes contents into
            brushStartCallback,
            brushCallback: axisBrushMoved(brushCallback),
            brushEndCallback
          }
        };
      }
      function cleanRanges(ranges, dimension) {
        if (Array.isArray(ranges[0])) {
          ranges = ranges.map(function(ri) {
            return ri.sort(sortAsc);
          });
          if (!dimension.multiselect) ranges = [ranges[0]];
          else ranges = dedupeRealRanges(ranges.sort(startAsc));
        } else ranges = [ranges.sort(sortAsc)];
        if (dimension.tickvals) {
          var sortedTickVals = dimension.tickvals.slice().sort(sortAsc);
          ranges = ranges.map(function(ri) {
            var rSnapped = [
              ordinalScaleSnap(0, sortedTickVals, ri[0], []),
              ordinalScaleSnap(1, sortedTickVals, ri[1], [])
            ];
            if (rSnapped[1] > rSnapped[0]) return rSnapped;
          }).filter(function(ri) {
            return ri;
          });
          if (!ranges.length) return;
        }
        return ranges.length > 1 ? ranges : ranges[0];
      }
      module.exports = {
        makeBrush,
        ensureAxisBrush,
        cleanRanges
      };
    }
  });

  // src/traces/parcoords/defaults.js
  var require_defaults21 = __commonJS({
    "src/traces/parcoords/defaults.js"(exports, module) {
      "use strict";
      var Lib = require_lib();
      var hasColorscale = require_helpers().hasColorscale;
      var colorscaleDefaults = require_defaults2();
      var handleDomainDefaults = require_domain().defaults;
      var handleArrayContainerDefaults = require_array_container_defaults();
      var Axes = require_axes();
      var attributes = require_attributes25();
      var axisBrush = require_axisbrush();
      var maxDimensionCount = require_constants15().maxDimensionCount;
      var mergeLength = require_merge_length();
      function handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce) {
        var lineColor = coerce("line.color", defaultColor);
        if (hasColorscale(traceIn, "line") && Lib.isArrayOrTypedArray(lineColor)) {
          if (lineColor.length) {
            coerce("line.colorscale");
            colorscaleDefaults(traceIn, traceOut, layout, coerce, { prefix: "line.", cLetter: "c" });
            return lineColor.length;
          } else {
            traceOut.line.color = defaultColor;
          }
        }
        return Infinity;
      }
      function dimensionDefaults(dimensionIn, dimensionOut, parentOut, opts) {
        function coerce(attr, dflt) {
          return Lib.coerce(dimensionIn, dimensionOut, attributes.dimensions, attr, dflt);
        }
        var values = coerce("values");
        var visible = coerce("visible");
        if (!(values && values.length)) {
          visible = dimensionOut.visible = false;
        }
        if (visible) {
          coerce("label");
          coerce("tickvals");
          coerce("ticktext");
          coerce("tickformat");
          var range = coerce("range");
          dimensionOut._ax = {
            _id: "y",
            type: "linear",
            showexponent: "all",
            exponentformat: "B",
            range
          };
          Axes.setConvert(dimensionOut._ax, opts.layout);
          coerce("multiselect");
          var constraintRange = coerce("constraintrange");
          if (constraintRange) {
            dimensionOut.constraintrange = axisBrush.cleanRanges(constraintRange, dimensionOut);
          }
        }
      }
      module.exports = function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
        function coerce(attr, dflt) {
          return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
        }
        var dimensionsIn = traceIn.dimensions;
        if (Array.isArray(dimensionsIn) && dimensionsIn.length > maxDimensionCount) {
          Lib.log("parcoords traces support up to " + maxDimensionCount + " dimensions at the moment");
          dimensionsIn.splice(maxDimensionCount);
        }
        var dimensions = handleArrayContainerDefaults(traceIn, traceOut, {
          name: "dimensions",
          layout,
          handleItemDefaults: dimensionDefaults
        });
        var len = handleLineDefaults(traceIn, traceOut, defaultColor, layout, coerce);
        handleDomainDefaults(traceOut, layout, coerce);
        if (!Array.isArray(dimensions) || !dimensions.length) {
          traceOut.visible = false;
        }
        mergeLength(traceOut, dimensions, "values", len);
        var fontDflt = Lib.extendFlat({}, layout.font, {
          size: Math.round(layout.font.size / 1.2)
        });
        Lib.coerceFont(coerce, "labelfont", fontDflt);
        Lib.coerceFont(coerce, "tickfont", fontDflt, { autoShadowDflt: true });
        Lib.coerceFont(coerce, "rangefont", fontDflt);
        coerce("labelangle");
        coerce("labelside");
        coerce("unselected.line.color");
        coerce("unselected.line.opacity");
      };
    }
  });

  // src/traces/parcoords/calc.js
  var require_calc7 = __commonJS({
    "src/traces/parcoords/calc.js"(exports, module) {
      "use strict";
      var isArrayOrTypedArray = require_lib().isArrayOrTypedArray;
      var Colorscale = require_colorscale();
      var wrap = require_gup().wrap;
      module.exports = function calc(gd, trace) {
        var lineColor;
        var cscale;
        if (Colorscale.hasColorscale(trace, "line") && isArrayOrTypedArray(trace.line.color)) {
          lineColor = trace.line.color;
          cscale = Colorscale.extractOpts(trace.line).colorscale;
          Colorscale.calc(gd, trace, {
            vals: lineColor,
            containerStr: "line",
            cLetter: "c"
          });
        } else {
          lineColor = constHalf(trace._length);
          cscale = [[0, trace.line.color], [1, trace.line.color]];
        }
        return wrap({ lineColor, cscale });
      };
      function constHalf(len) {
        var out = new Array(len);
        for (var i = 0; i < len; i++) {
          out[i] = 0.5;
        }
        return out;
      }
    }
  });

  // node_modules/color-parse/index.js
  function parse(cstr) {
    var _a, _b;
    var m, parts = [], alpha = 1, space;
    if (typeof cstr === "number") {
      return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
    }
    if (typeof cstr === "number") return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
    cstr = String(cstr).toLowerCase();
    if (import_color_name.default[cstr]) {
      parts = import_color_name.default[cstr].slice();
      space = "rgb";
    } else if (cstr === "transparent") {
      alpha = 0;
      space = "rgb";
      parts = [0, 0, 0];
    } else if (cstr[0] === "#") {
      var base = cstr.slice(1);
      var size = base.length;
      var isShort = size <= 4;
      alpha = 1;
      if (isShort) {
        parts = [
          parseInt(base[0] + base[0], 16),
          parseInt(base[1] + base[1], 16),
          parseInt(base[2] + base[2], 16)
        ];
        if (size === 4) {
          alpha = parseInt(base[3] + base[3], 16) / 255;
        }
      } else {
        parts = [
          parseInt(base[0] + base[1], 16),
          parseInt(base[2] + base[3], 16),
          parseInt(base[4] + base[5], 16)
        ];
        if (size === 8) {
          alpha = parseInt(base[6] + base[7], 16) / 255;
        }
      }
      if (!parts[0]) parts[0] = 0;
      if (!parts[1]) parts[1] = 0;
      if (!parts[2]) parts[2] = 0;
      space = "rgb";
    } else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
      var name = m[1];
      space = name.replace(/a$/, "");
      var dims = space === "cmyk" ? 4 : space === "gray" ? 1 : 3;
      parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);
      if (space === "color") space = parts.shift();
      parts = parts.map(function(x, i) {
        if (x[x.length - 1] === "%") {
          x = parseFloat(x) / 100;
          if (i === 3) return x;
          if (space === "rgb") return x * 255;
          if (space[0] === "h") return x * 100;
          if (space[0] === "l" && !i) return x * 100;
          if (space === "lab") return x * 125;
          if (space === "lch") return i < 2 ? x * 150 : x * 360;
          if (space[0] === "o" && !i) return x;
          if (space === "oklab") return x * 0.4;
          if (space === "oklch") return i < 2 ? x * 0.4 : x * 360;
          return x;
        }
        if (space[i] === "h" || i === 2 && space[space.length - 1] === "h") {
          if (baseHues[x] !== void 0) return baseHues[x];
          if (x.endsWith("deg")) return parseFloat(x);
          if (x.endsWith("turn")) return parseFloat(x) * 360;
          if (x.endsWith("grad")) return parseFloat(x) * 360 / 400;
          if (x.endsWith("rad")) return parseFloat(x) * 180 / Math.PI;
        }
        if (x === "none") return 0;
        return parseFloat(x);
      });
      alpha = parts.length > dims ? parts.pop() : 1;
    } else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
      parts = cstr.match(/([0-9]+)/g).map(function(value) {
        return parseFloat(value);
      });
      space = ((_b = (_a = cstr.match(/([a-z])/ig)) == null ? void 0 : _a.join("")) == null ? void 0 : _b.toLowerCase()) || "rgb";
    }
    return {
      space,
      values: parts,
      alpha
    };
  }
  var import_color_name, color_parse_default, baseHues;
  var init_color_parse = __esm({
    "node_modules/color-parse/index.js"() {
      import_color_name = __toESM(require_color_name(), 1);
      color_parse_default = parse;
      baseHues = {
        red: 0,
        orange: 60,
        yellow: 120,
        green: 180,
        blue: 240,
        purple: 300
      };
    }
  });

  // node_modules/color-space/rgb.js
  var rgb_default;
  var init_rgb = __esm({
    "node_modules/color-space/rgb.js"() {
      rgb_default = {
        name: "rgb",
        min: [0, 0, 0],
        max: [255, 255, 255],
        channel: ["red", "green", "blue"],
        alias: ["RGB"]
      };
    }
  });

  // node_modules/color-space/hsl.js
  var hsl_default;
  var init_hsl = __esm({
    "node_modules/color-space/hsl.js"() {
      init_rgb();
      hsl_default = {
        name: "hsl",
        min: [0, 0, 0],
        max: [360, 100, 100],
        channel: ["hue", "saturation", "lightness"],
        alias: ["HSL"],
        rgb: function(hsl) {
          var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val, i = 0;
          if (s === 0) return val = l * 255, [val, val, val];
          t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
          t1 = 2 * l - t2;
          rgb = [0, 0, 0];
          for (; i < 3; ) {
            t3 = h + 1 / 3 * -(i - 1);
            t3 < 0 ? t3++ : t3 > 1 && t3--;
            val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
            rgb[i++] = val * 255;
          }
          return rgb;
        }
      };
      rgb_default.hsl = function(rgb) {
        var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
        if (max === min) {
          h = 0;
        } else if (r === max) {
          h = (g - b) / delta;
        } else if (g === max) {
          h = 2 + (b - r) / delta;
        } else if (b === max) {
          h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        l = (min + max) / 2;
        if (max === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max + min);
        } else {
          s = delta / (2 - max - min);
        }
        return [h, s * 100, l * 100];
      };
    }
  });

  // node_modules/color-rgba/index.js
  var color_rgba_exports = {};
  __export(color_rgba_exports, {
    default: () => rgba
  });
  function rgba(color) {
    if (Array.isArray(color) && color.raw) color = String.raw(...arguments);
    if (color instanceof Number) color = +color;
    var values, i, l;
    var parsed = color_parse_default(color);
    if (!parsed.space) return [];
    const min = parsed.space[0] === "h" ? hsl_default.min : rgb_default.min;
    const max = parsed.space[0] === "h" ? hsl_default.max : rgb_default.max;
    values = Array(3);
    values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
    values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
    values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);
    if (parsed.space[0] === "h") {
      values = hsl_default.rgb(values);
    }
    values.push(Math.min(Math.max(parsed.alpha, 0), 1));
    return values;
  }
  var init_color_rgba = __esm({
    "node_modules/color-rgba/index.js"() {
      init_color_parse();
      init_rgb();
      init_hsl();
    }
  });

  // src/traces/parcoords/helpers.js
  var require_helpers14 = __commonJS({
    "src/traces/parcoords/helpers.js"(exports) {
      "use strict";
      var isTypedArray = require_lib().isTypedArray;
      exports.convertTypedArray = function(a) {
        return isTypedArray(a) ? Array.prototype.slice.call(a) : a;
      };
      exports.isOrdinal = function(dimension) {
        return !!dimension.tickvals;
      };
      exports.isVisible = function(dimension) {
        return dimension.visible || !("visible" in dimension);
      };
    }
  });

  // src/traces/parcoords/lines.js
  var require_lines = __commonJS({
    "src/traces/parcoords/lines.js"(exports, module) {
      "use strict";
      var vertexShaderSource = [
        "precision highp float;",
        "",
        "varying vec4 fragColor;",
        "",
        "attribute vec4 p01_04, p05_08, p09_12, p13_16,",
        "               p17_20, p21_24, p25_28, p29_32,",
        "               p33_36, p37_40, p41_44, p45_48,",
        "               p49_52, p53_56, p57_60, colors;",
        "",
        "uniform mat4 dim0A, dim1A, dim0B, dim1B, dim0C, dim1C, dim0D, dim1D,",
        "             loA, hiA, loB, hiB, loC, hiC, loD, hiD;",
        "",
        "uniform vec2 resolution, viewBoxPos, viewBoxSize;",
        "uniform float maskHeight;",
        "uniform float drwLayer; // 0: context, 1: focus, 2: pick",
        "uniform vec4 contextColor;",
        "uniform sampler2D maskTexture, palette;",
        "",
        "bool isPick    = (drwLayer > 1.5);",
        "bool isContext = (drwLayer < 0.5);",
        "",
        "const vec4 ZEROS = vec4(0.0, 0.0, 0.0, 0.0);",
        "const vec4 UNITS = vec4(1.0, 1.0, 1.0, 1.0);",
        "",
        "float val(mat4 p, mat4 v) {",
        "    return dot(matrixCompMult(p, v) * UNITS, UNITS);",
        "}",
        "",
        "float axisY(float ratio, mat4 A, mat4 B, mat4 C, mat4 D) {",
        "    float y1 = val(A, dim0A) + val(B, dim0B) + val(C, dim0C) + val(D, dim0D);",
        "    float y2 = val(A, dim1A) + val(B, dim1B) + val(C, dim1C) + val(D, dim1D);",
        "    return y1 * (1.0 - ratio) + y2 * ratio;",
        "}",
        "",
        "int iMod(int a, int b) {",
        "    return a - b * (a / b);",
        "}",
        "",
        "bool fOutside(float p, float lo, float hi) {",
        "    return (lo < hi) && (lo > p || p > hi);",
        "}",
        "",
        "bool vOutside(vec4 p, vec4 lo, vec4 hi) {",
        "    return (",
        "        fOutside(p[0], lo[0], hi[0]) ||",
        "        fOutside(p[1], lo[1], hi[1]) ||",
        "        fOutside(p[2], lo[2], hi[2]) ||",
        "        fOutside(p[3], lo[3], hi[3])",
        "    );",
        "}",
        "",
        "bool mOutside(mat4 p, mat4 lo, mat4 hi) {",
        "    return (",
        "        vOutside(p[0], lo[0], hi[0]) ||",
        "        vOutside(p[1], lo[1], hi[1]) ||",
        "        vOutside(p[2], lo[2], hi[2]) ||",
        "        vOutside(p[3], lo[3], hi[3])",
        "    );",
        "}",
        "",
        "bool outsideBoundingBox(mat4 A, mat4 B, mat4 C, mat4 D) {",
        "    return mOutside(A, loA, hiA) ||",
        "           mOutside(B, loB, hiB) ||",
        "           mOutside(C, loC, hiC) ||",
        "           mOutside(D, loD, hiD);",
        "}",
        "",
        "bool outsideRasterMask(mat4 A, mat4 B, mat4 C, mat4 D) {",
        "    mat4 pnts[4];",
        "    pnts[0] = A;",
        "    pnts[1] = B;",
        "    pnts[2] = C;",
        "    pnts[3] = D;",
        "",
        "    for(int i = 0; i < 4; ++i) {",
        "        for(int j = 0; j < 4; ++j) {",
        "            for(int k = 0; k < 4; ++k) {",
        "                if(0 == iMod(",
        "                    int(255.0 * texture2D(maskTexture,",
        "                        vec2(",
        "                            (float(i * 2 + j / 2) + 0.5) / 8.0,",
        "                            (pnts[i][j][k] * (maskHeight - 1.0) + 1.0) / maskHeight",
        "                        ))[3]",
        "                    ) / int(pow(2.0, float(iMod(j * 4 + k, 8)))),",
        "                    2",
        "                )) return true;",
        "            }",
        "        }",
        "    }",
        "    return false;",
        "}",
        "",
        "vec4 position(bool isContext, float v, mat4 A, mat4 B, mat4 C, mat4 D) {",
        "    float x = 0.5 * sign(v) + 0.5;",
        "    float y = axisY(x, A, B, C, D);",
        "    float z = 1.0 - abs(v);",
        "",
        "    z += isContext ? 0.0 : 2.0 * float(",
        "        outsideBoundingBox(A, B, C, D) ||",
        "        outsideRasterMask(A, B, C, D)",
        "    );",
        "",
        "    return vec4(",
        "        2.0 * (vec2(x, y) * viewBoxSize + viewBoxPos) / resolution - 1.0,",
        "        z,",
        "        1.0",
        "    );",
        "}",
        "",
        "void main() {",
        "    mat4 A = mat4(p01_04, p05_08, p09_12, p13_16);",
        "    mat4 B = mat4(p17_20, p21_24, p25_28, p29_32);",
        "    mat4 C = mat4(p33_36, p37_40, p41_44, p45_48);",
        "    mat4 D = mat4(p49_52, p53_56, p57_60, ZEROS);",
        "",
        "    float v = colors[3];",
        "",
        "    gl_Position = position(isContext, v, A, B, C, D);",
        "",
        "    fragColor =",
        "        isContext ? vec4(contextColor) :",
        "        isPick ? vec4(colors.rgb, 1.0) : texture2D(palette, vec2(abs(v), 0.5));",
        "}"
      ].join("\n");
      var fragmentShaderSource = [
        "precision highp float;",
        "",
        "varying vec4 fragColor;",
        "",
        "void main() {",
        "    gl_FragColor = fragColor;",
        "}"
      ].join("\n");
      var maxDim = require_constants15().maxDimensionCount;
      var Lib = require_lib();
      var depthLimitEpsilon = 1e-6;
      var maskHeight = 2048;
      var dummyPixel = new Uint8Array(4);
      var dataPixel = new Uint8Array(4);
      var paletteTextureConfig = {
        shape: [256, 1],
        format: "rgba",
        type: "uint8",
        mag: "nearest",
        min: "nearest"
      };
      function ensureDraw(regl) {
        regl.read({
          x: 0,
          y: 0,
          width: 1,
          height: 1,
          data: dummyPixel
        });
      }
      function clear(regl, x, y, width, height) {
        var gl = regl._gl;
        gl.enable(gl.SCISSOR_TEST);
        gl.scissor(x, y, width, height);
        regl.clear({ color: [0, 0, 0, 0], depth: 1 });
      }
      function renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item) {
        var rafKey = item.key;
        function render(blockNumber) {
          var count = Math.min(blockLineCount, sampleCount - blockNumber * blockLineCount);
          if (blockNumber === 0) {
            window.cancelAnimationFrame(renderState.currentRafs[rafKey]);
            delete renderState.currentRafs[rafKey];
            clear(regl, item.scissorX, item.scissorY, item.scissorWidth, item.viewBoxSize[1]);
          }
          if (renderState.clearOnly) {
            return;
          }
          item.count = 2 * count;
          item.offset = 2 * blockNumber * blockLineCount;
          glAes(item);
          if (blockNumber * blockLineCount + count < sampleCount) {
            renderState.currentRafs[rafKey] = window.requestAnimationFrame(function() {
              render(blockNumber + 1);
            });
          }
          renderState.drawCompleted = false;
        }
        if (!renderState.drawCompleted) {
          ensureDraw(regl);
          renderState.drawCompleted = true;
        }
        render(0);
      }
      function adjustDepth(d) {
        return Math.max(depthLimitEpsilon, Math.min(1 - depthLimitEpsilon, d));
      }
      function palette(unitToColor, opacity) {
        var result = new Array(256);
        for (var i = 0; i < 256; i++) {
          result[i] = unitToColor(i / 255).concat(opacity);
        }
        return result;
      }
      function calcPickColor(i, rgbIndex) {
        return (i >>> 8 * rgbIndex) % 256 / 255;
      }
      function makePoints(sampleCount, dims, color) {
        var points = new Array(sampleCount * (maxDim + 4));
        var n = 0;
        for (var i = 0; i < sampleCount; i++) {
          for (var k = 0; k < maxDim; k++) {
            points[n++] = k < dims.length ? dims[k].paddedUnitValues[i] : 0.5;
          }
          points[n++] = calcPickColor(i, 2);
          points[n++] = calcPickColor(i, 1);
          points[n++] = calcPickColor(i, 0);
          points[n++] = adjustDepth(color[i]);
        }
        return points;
      }
      function makeVecAttr(vecIndex, sampleCount, points) {
        var pointPairs = new Array(sampleCount * 8);
        var n = 0;
        for (var i = 0; i < sampleCount; i++) {
          for (var j = 0; j < 2; j++) {
            for (var k = 0; k < 4; k++) {
              var q = vecIndex * 4 + k;
              var v = points[i * 64 + q];
              if (q === 63 && j === 0) {
                v *= -1;
              }
              pointPairs[n++] = v;
            }
          }
        }
        return pointPairs;
      }
      function pad2(num) {
        var s = "0" + num;
        return s.substr(s.length - 2);
      }
      function getAttrName(i) {
        return i < maxDim ? "p" + pad2(i + 1) + "_" + pad2(i + 4) : "colors";
      }
      function setAttributes(attributes, sampleCount, points) {
        for (var i = 0; i <= maxDim; i += 4) {
          attributes[getAttrName(i)](makeVecAttr(i / 4, sampleCount, points));
        }
      }
      function emptyAttributes(regl) {
        var attributes = {};
        for (var i = 0; i <= maxDim; i += 4) {
          attributes[getAttrName(i)] = regl.buffer({ usage: "dynamic", type: "float", data: new Uint8Array(0) });
        }
        return attributes;
      }
      function makeItem(model, leftmost, rightmost, itemNumber, i0, i1, x, y, panelSizeX, panelSizeY, crossfilterDimensionIndex, drwLayer, constraints, plotGlPixelRatio) {
        var dims = [[], []];
        for (var k = 0; k < 64; k++) {
          dims[0][k] = k === i0 ? 1 : 0;
          dims[1][k] = k === i1 ? 1 : 0;
        }
        x *= plotGlPixelRatio;
        y *= plotGlPixelRatio;
        panelSizeX *= plotGlPixelRatio;
        panelSizeY *= plotGlPixelRatio;
        var overdrag = model.lines.canvasOverdrag * plotGlPixelRatio;
        var domain = model.domain;
        var canvasWidth = model.canvasWidth * plotGlPixelRatio;
        var canvasHeight = model.canvasHeight * plotGlPixelRatio;
        var padL = model.pad.l * plotGlPixelRatio;
        var padB = model.pad.b * plotGlPixelRatio;
        var layoutHeight = model.layoutHeight * plotGlPixelRatio;
        var layoutWidth = model.layoutWidth * plotGlPixelRatio;
        var deselectedLinesColor = model.deselectedLines.color;
        var deselectedLinesOpacity = model.deselectedLines.opacity;
        var itemModel = Lib.extendFlat({
          key: crossfilterDimensionIndex,
          resolution: [canvasWidth, canvasHeight],
          viewBoxPos: [x + overdrag, y],
          viewBoxSize: [panelSizeX, panelSizeY],
          i0,
          i1,
          dim0A: dims[0].slice(0, 16),
          dim0B: dims[0].slice(16, 32),
          dim0C: dims[0].slice(32, 48),
          dim0D: dims[0].slice(48, 64),
          dim1A: dims[1].slice(0, 16),
          dim1B: dims[1].slice(16, 32),
          dim1C: dims[1].slice(32, 48),
          dim1D: dims[1].slice(48, 64),
          drwLayer,
          contextColor: [
            deselectedLinesColor[0] / 255,
            deselectedLinesColor[1] / 255,
            deselectedLinesColor[2] / 255,
            deselectedLinesOpacity !== "auto" ? deselectedLinesColor[3] * deselectedLinesOpacity : Math.max(1 / 255, Math.pow(1 / model.lines.color.length, 1 / 3))
          ],
          scissorX: (itemNumber === leftmost ? 0 : x + overdrag) + (padL - overdrag) + layoutWidth * domain.x[0],
          scissorWidth: (itemNumber === rightmost ? canvasWidth - x + overdrag : panelSizeX + 0.5) + (itemNumber === leftmost ? x + overdrag : 0),
          scissorY: y + padB + layoutHeight * domain.y[0],
          scissorHeight: panelSizeY,
          viewportX: padL - overdrag + layoutWidth * domain.x[0],
          viewportY: padB + layoutHeight * domain.y[0],
          viewportWidth: canvasWidth,
          viewportHeight: canvasHeight
        }, constraints);
        return itemModel;
      }
      function expandedPixelRange(bounds) {
        var dh = maskHeight - 1;
        var a = Math.max(0, Math.floor(bounds[0] * dh), 0);
        var b = Math.min(dh, Math.ceil(bounds[1] * dh), dh);
        return [
          Math.min(a, b),
          Math.max(a, b)
        ];
      }
      module.exports = function(canvasGL, d) {
        var isContext = d.context;
        var isPick = d.pick;
        var regl = d.regl;
        var gl = regl._gl;
        var supportedLineWidth = gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE);
        var plotGlPixelRatio = Math.max(
          supportedLineWidth[0],
          Math.min(
            supportedLineWidth[1],
            d.viewModel.plotGlPixelRatio
          )
        );
        var renderState = {
          currentRafs: {},
          drawCompleted: true,
          clearOnly: false
        };
        var model;
        var vm;
        var initialDims;
        var sampleCount;
        var attributes = emptyAttributes(regl);
        var maskTexture;
        var paletteTexture = regl.texture(paletteTextureConfig);
        var prevAxisOrder = [];
        update(d);
        var glAes = regl({
          profile: false,
          blend: {
            enable: isContext,
            func: {
              srcRGB: "src alpha",
              dstRGB: "one minus src alpha",
              srcAlpha: 1,
              dstAlpha: 1
              // 'one minus src alpha'
            },
            equation: {
              rgb: "add",
              alpha: "add"
            },
            color: [0, 0, 0, 0]
          },
          depth: {
            enable: !isContext,
            mask: true,
            func: "less",
            range: [0, 1]
          },
          // for polygons
          cull: {
            enable: true,
            face: "back"
          },
          scissor: {
            enable: true,
            box: {
              x: regl.prop("scissorX"),
              y: regl.prop("scissorY"),
              width: regl.prop("scissorWidth"),
              height: regl.prop("scissorHeight")
            }
          },
          viewport: {
            x: regl.prop("viewportX"),
            y: regl.prop("viewportY"),
            width: regl.prop("viewportWidth"),
            height: regl.prop("viewportHeight")
          },
          dither: false,
          vert: vertexShaderSource,
          frag: fragmentShaderSource,
          primitive: "lines",
          lineWidth: plotGlPixelRatio,
          attributes,
          uniforms: {
            resolution: regl.prop("resolution"),
            viewBoxPos: regl.prop("viewBoxPos"),
            viewBoxSize: regl.prop("viewBoxSize"),
            dim0A: regl.prop("dim0A"),
            dim1A: regl.prop("dim1A"),
            dim0B: regl.prop("dim0B"),
            dim1B: regl.prop("dim1B"),
            dim0C: regl.prop("dim0C"),
            dim1C: regl.prop("dim1C"),
            dim0D: regl.prop("dim0D"),
            dim1D: regl.prop("dim1D"),
            loA: regl.prop("loA"),
            hiA: regl.prop("hiA"),
            loB: regl.prop("loB"),
            hiB: regl.prop("hiB"),
            loC: regl.prop("loC"),
            hiC: regl.prop("hiC"),
            loD: regl.prop("loD"),
            hiD: regl.prop("hiD"),
            palette: paletteTexture,
            contextColor: regl.prop("contextColor"),
            maskTexture: regl.prop("maskTexture"),
            drwLayer: regl.prop("drwLayer"),
            maskHeight: regl.prop("maskHeight")
          },
          offset: regl.prop("offset"),
          count: regl.prop("count")
        });
        function update(dNew) {
          model = dNew.model;
          vm = dNew.viewModel;
          initialDims = vm.dimensions.slice();
          sampleCount = initialDims[0] ? initialDims[0].values.length : 0;
          var lines = model.lines;
          var color = isPick ? lines.color.map(function(_, i) {
            return i / lines.color.length;
          }) : lines.color;
          var points = makePoints(sampleCount, initialDims, color);
          setAttributes(attributes, sampleCount, points);
          if (!isContext && !isPick) {
            paletteTexture = regl.texture(Lib.extendFlat({
              data: palette(model.unitToColor, 255)
            }, paletteTextureConfig));
          }
        }
        function makeConstraints(isContext2) {
          var i, j, k;
          var limits = [[], []];
          for (k = 0; k < 64; k++) {
            var p = !isContext2 && k < initialDims.length ? initialDims[k].brush.filter.getBounds() : [-Infinity, Infinity];
            limits[0][k] = p[0];
            limits[1][k] = p[1];
          }
          var len = maskHeight * 8;
          var mask = new Array(len);
          for (i = 0; i < len; i++) {
            mask[i] = 255;
          }
          if (!isContext2) {
            for (i = 0; i < initialDims.length; i++) {
              var u = i % 8;
              var v = (i - u) / 8;
              var bitMask = Math.pow(2, u);
              var dim = initialDims[i];
              var ranges = dim.brush.filter.get();
              if (ranges.length < 2) continue;
              var prevEnd = expandedPixelRange(ranges[0])[1];
              for (j = 1; j < ranges.length; j++) {
                var nextRange = expandedPixelRange(ranges[j]);
                for (k = prevEnd + 1; k < nextRange[0]; k++) {
                  mask[k * 8 + v] &= ~bitMask;
                }
                prevEnd = Math.max(prevEnd, nextRange[1]);
              }
            }
          }
          var textureData = {
            // 8 units x 8 bits = 64 bits, just sufficient for the almost 64 dimensions we support
            shape: [8, maskHeight],
            format: "alpha",
            type: "uint8",
            mag: "nearest",
            min: "nearest",
            data: mask
          };
          if (maskTexture) maskTexture(textureData);
          else maskTexture = regl.texture(textureData);
          return {
            maskTexture,
            maskHeight,
            loA: limits[0].slice(0, 16),
            loB: limits[0].slice(16, 32),
            loC: limits[0].slice(32, 48),
            loD: limits[0].slice(48, 64),
            hiA: limits[1].slice(0, 16),
            hiB: limits[1].slice(16, 32),
            hiC: limits[1].slice(32, 48),
            hiD: limits[1].slice(48, 64)
          };
        }
        function renderGLParcoords(panels, setChanged, clearOnly) {
          var panelCount = panels.length;
          var i;
          var leftmost;
          var rightmost;
          var lowestX = Infinity;
          var highestX = -Infinity;
          for (i = 0; i < panelCount; i++) {
            if (panels[i].dim0.canvasX < lowestX) {
              lowestX = panels[i].dim0.canvasX;
              leftmost = i;
            }
            if (panels[i].dim1.canvasX > highestX) {
              highestX = panels[i].dim1.canvasX;
              rightmost = i;
            }
          }
          if (panelCount === 0) {
            clear(regl, 0, 0, model.canvasWidth, model.canvasHeight);
          }
          var constraints = makeConstraints(isContext);
          for (i = 0; i < panelCount; i++) {
            var p = panels[i];
            var i0 = p.dim0.crossfilterDimensionIndex;
            var i1 = p.dim1.crossfilterDimensionIndex;
            var x = p.canvasX;
            var y = p.canvasY;
            var nextX = x + p.panelSizeX;
            var plotGlPixelRatio2 = p.plotGlPixelRatio;
            if (setChanged || !prevAxisOrder[i0] || prevAxisOrder[i0][0] !== x || prevAxisOrder[i0][1] !== nextX) {
              prevAxisOrder[i0] = [x, nextX];
              var item = makeItem(
                model,
                leftmost,
                rightmost,
                i,
                i0,
                i1,
                x,
                y,
                p.panelSizeX,
                p.panelSizeY,
                p.dim0.crossfilterDimensionIndex,
                isContext ? 0 : isPick ? 2 : 1,
                constraints,
                plotGlPixelRatio2
              );
              renderState.clearOnly = clearOnly;
              var blockLineCount = setChanged ? model.lines.blockLineCount : sampleCount;
              renderBlock(
                regl,
                glAes,
                renderState,
                blockLineCount,
                sampleCount,
                item
              );
            }
          }
        }
        function readPixel(canvasX, canvasY) {
          regl.read({
            x: canvasX,
            y: canvasY,
            width: 1,
            height: 1,
            data: dataPixel
          });
          return dataPixel;
        }
        function readPixels(canvasX, canvasY, width, height) {
          var pixelArray = new Uint8Array(4 * width * height);
          regl.read({
            x: canvasX,
            y: canvasY,
            width,
            height,
            data: pixelArray
          });
          return pixelArray;
        }
        function destroy() {
          canvasGL.style["pointer-events"] = "none";
          paletteTexture.destroy();
          if (maskTexture) maskTexture.destroy();
          for (var k in attributes) attributes[k].destroy();
        }
        return {
          render: renderGLParcoords,
          readPixel,
          readPixels,
          destroy,
          update
        };
      };
    }
  });

  // src/traces/parcoords/parcoords.js
  var require_parcoords = __commonJS({
    "src/traces/parcoords/parcoords.js"(exports, module) {
      "use strict";
      var d3 = require_d3();
      var Lib = require_lib();
      var isArrayOrTypedArray = Lib.isArrayOrTypedArray;
      var numberFormat = Lib.numberFormat;
      var rgba2 = (init_color_rgba(), __toCommonJS(color_rgba_exports)).default;
      var Axes = require_axes();
      var strRotate = Lib.strRotate;
      var strTranslate = Lib.strTranslate;
      var svgTextUtils = require_svg_text_utils();
      var Drawing = require_drawing();
      var Colorscale = require_colorscale();
      var gup = require_gup();
      var keyFun = gup.keyFun;
      var repeat = gup.repeat;
      var unwrap = gup.unwrap;
      var helpers = require_helpers14();
      var c = require_constants15();
      var brush = require_axisbrush();
      var lineLayerMaker = require_lines();
      function findExtreme(fn, values, len) {
        return Lib.aggNums(fn, null, values, len);
      }
      function findExtremes(values, len) {
        return fixExtremes(
          findExtreme(Math.min, values, len),
          findExtreme(Math.max, values, len)
        );
      }
      function dimensionExtent(dimension) {
        var range = dimension.range;
        return range ? fixExtremes(range[0], range[1]) : findExtremes(dimension.values, dimension._length);
      }
      function fixExtremes(lo, hi) {
        if (isNaN(lo) || !isFinite(lo)) {
          lo = 0;
        }
        if (isNaN(hi) || !isFinite(hi)) {
          hi = 0;
        }
        if (lo === hi) {
          if (lo === 0) {
            lo -= 1;
            hi += 1;
          } else {
            lo *= 0.9;
            hi *= 1.1;
          }
        }
        return [lo, hi];
      }
      function toText(formatter, texts) {
        if (texts) {
          return function(v, i) {
            var text = texts[i];
            if (text === null || text === void 0) return formatter(v);
            return text;
          };
        }
        return formatter;
      }
      function domainScale(height, padding, dimension, tickvals, ticktext) {
        var extent = dimensionExtent(dimension);
        if (tickvals) {
          return d3.scale.ordinal().domain(tickvals.map(toText(numberFormat(dimension.tickformat), ticktext))).range(
            tickvals.map(function(d) {
              var unitVal = (d - extent[0]) / (extent[1] - extent[0]);
              return height - padding + unitVal * (2 * padding - height);
            })
          );
        }
        return d3.scale.linear().domain(extent).range([height - padding, padding]);
      }
      function unitToPaddedPx(height, padding) {
        return d3.scale.linear().range([padding, height - padding]);
      }
      function domainToPaddedUnitScale(dimension, padFraction) {
        return d3.scale.linear().domain(dimensionExtent(dimension)).range([padFraction, 1 - padFraction]);
      }
      function ordinalScale(dimension) {
        if (!dimension.tickvals) return;
        var extent = dimensionExtent(dimension);
        return d3.scale.ordinal().domain(dimension.tickvals).range(dimension.tickvals.map(function(d) {
          return (d - extent[0]) / (extent[1] - extent[0]);
        }));
      }
      function unitToColorScale(cscale) {
        var colorStops = cscale.map(function(d) {
          return d[0];
        });
        var colorTuples = cscale.map(function(d) {
          var RGBA = rgba2(d[1]);
          return d3.rgb("rgb(" + RGBA[0] + "," + RGBA[1] + "," + RGBA[2] + ")");
        });
        var prop = function(n) {
          return function(o) {
            return o[n];
          };
        };
        var polylinearUnitScales = "rgb".split("").map(function(key) {
          return d3.scale.linear().clamp(true).domain(colorStops).range(colorTuples.map(prop(key)));
        });
        return function(d) {
          return polylinearUnitScales.map(function(s) {
            return s(d);
          });
        };
      }
      function someFiltersActive(view) {
        return view.dimensions.some(function(p) {
          return p.brush.filterSpecified;
        });
      }
      function model(layout, d, i) {
        var cd0 = unwrap(d);
        var trace = cd0.trace;
        var lineColor = helpers.convertTypedArray(cd0.lineColor);
        var line = trace.line;
        var deselectedLines = {
          color: rgba2(trace.unselected.line.color),
          opacity: trace.unselected.line.opacity
        };
        var cOpts = Colorscale.extractOpts(line);
        var cscale = cOpts.reversescale ? Colorscale.flipScale(cd0.cscale) : cd0.cscale;
        var domain = trace.domain;
        var dimensions = trace.dimensions;
        var width = layout.width;
        var labelAngle = trace.labelangle;
        var labelSide = trace.labelside;
        var labelFont = trace.labelfont;
        var tickFont = trace.tickfont;
        var rangeFont = trace.rangefont;
        var lines = Lib.extendDeepNoArrays({}, line, {
          color: lineColor.map(d3.scale.linear().domain(
            dimensionExtent({
              values: lineColor,
              range: [cOpts.min, cOpts.max],
              _length: trace._length
            })
          )),
          blockLineCount: c.blockLineCount,
          canvasOverdrag: c.overdrag * c.canvasPixelRatio
        });
        var groupWidth = Math.floor(width * (domain.x[1] - domain.x[0]));
        var groupHeight = Math.floor(layout.height * (domain.y[1] - domain.y[0]));
        var pad = layout.margin || { l: 80, r: 80, t: 100, b: 80 };
        var rowContentWidth = groupWidth;
        var rowHeight = groupHeight;
        return {
          key: i,
          colCount: dimensions.filter(helpers.isVisible).length,
          dimensions,
          tickDistance: c.tickDistance,
          unitToColor: unitToColorScale(cscale),
          lines,
          deselectedLines,
          labelAngle,
          labelSide,
          labelFont,
          tickFont,
          rangeFont,
          layoutWidth: width,
          layoutHeight: layout.height,
          domain,
          translateX: domain.x[0] * width,
          translateY: layout.height - domain.y[1] * layout.height,
          pad,
          canvasWidth: rowContentWidth * c.canvasPixelRatio + 2 * lines.canvasOverdrag,
          canvasHeight: rowHeight * c.canvasPixelRatio,
          width: rowContentWidth,
          height: rowHeight,
          canvasPixelRatio: c.canvasPixelRatio
        };
      }
      function viewModel(state, callbacks, model2) {
        var width = model2.width;
        var height = model2.height;
        var dimensions = model2.dimensions;
        var canvasPixelRatio = model2.canvasPixelRatio;
        var xScale = function(d) {
          return width * d / Math.max(1, model2.colCount - 1);
        };
        var unitPad = c.verticalPadding / height;
        var _unitToPaddedPx = unitToPaddedPx(height, c.verticalPadding);
        var vm = {
          key: model2.key,
          xScale,
          model: model2,
          inBrushDrag: false
          // consider factoring it out and putting it in a centralized global-ish gesture state object
        };
        var uniqueKeys = {};
        vm.dimensions = dimensions.filter(helpers.isVisible).map(function(dimension, i) {
          var domainToPaddedUnit = domainToPaddedUnitScale(dimension, unitPad);
          var foundKey = uniqueKeys[dimension.label];
          uniqueKeys[dimension.label] = (foundKey || 0) + 1;
          var key = dimension.label + (foundKey ? "__" + foundKey : "");
          var specifiedConstraint = dimension.constraintrange;
          var filterRangeSpecified = specifiedConstraint && specifiedConstraint.length;
          if (filterRangeSpecified && !isArrayOrTypedArray(specifiedConstraint[0])) {
            specifiedConstraint = [specifiedConstraint];
          }
          var filterRange = filterRangeSpecified ? specifiedConstraint.map(function(d) {
            return d.map(domainToPaddedUnit);
          }) : [[-Infinity, Infinity]];
          var brushMove = function() {
            var p = vm;
            p.focusLayer && p.focusLayer.render(p.panels, true);
            var filtersActive = someFiltersActive(p);
            if (!state.contextShown() && filtersActive) {
              p.contextLayer && p.contextLayer.render(p.panels, true);
              state.contextShown(true);
            } else if (state.contextShown() && !filtersActive) {
              p.contextLayer && p.contextLayer.render(p.panels, true, true);
              state.contextShown(false);
            }
          };
          var truncatedValues = dimension.values;
          if (truncatedValues.length > dimension._length) {
            truncatedValues = truncatedValues.slice(0, dimension._length);
          }
          var tickvals = dimension.tickvals;
          var ticktext;
          function makeTickItem(v, i2) {
            return { val: v, text: ticktext[i2] };
          }
          function sortTickItem(a, b) {
            return a.val - b.val;
          }
          if (isArrayOrTypedArray(tickvals) && tickvals.length) {
            if (Lib.isTypedArray(tickvals)) tickvals = Array.from(tickvals);
            ticktext = dimension.ticktext;
            if (!isArrayOrTypedArray(ticktext) || !ticktext.length) {
              ticktext = tickvals.map(numberFormat(dimension.tickformat));
            } else if (ticktext.length > tickvals.length) {
              ticktext = ticktext.slice(0, tickvals.length);
            } else if (tickvals.length > ticktext.length) {
              tickvals = tickvals.slice(0, ticktext.length);
            }
            for (var j = 1; j < tickvals.length; j++) {
              if (tickvals[j] < tickvals[j - 1]) {
                var tickItems = tickvals.map(makeTickItem).sort(sortTickItem);
                for (var k = 0; k < tickvals.length; k++) {
                  tickvals[k] = tickItems[k].val;
                  ticktext[k] = tickItems[k].text;
                }
                break;
              }
            }
          } else tickvals = void 0;
          truncatedValues = helpers.convertTypedArray(truncatedValues);
          return {
            key,
            label: dimension.label,
            tickFormat: dimension.tickformat,
            tickvals,
            ticktext,
            ordinal: helpers.isOrdinal(dimension),
            multiselect: dimension.multiselect,
            xIndex: i,
            crossfilterDimensionIndex: i,
            visibleIndex: dimension._index,
            height,
            values: truncatedValues,
            paddedUnitValues: truncatedValues.map(domainToPaddedUnit),
            unitTickvals: tickvals && tickvals.map(domainToPaddedUnit),
            xScale,
            x: xScale(i),
            canvasX: xScale(i) * canvasPixelRatio,
            unitToPaddedPx: _unitToPaddedPx,
            domainScale: domainScale(height, c.verticalPadding, dimension, tickvals, ticktext),
            ordinalScale: ordinalScale(dimension),
            parent: vm,
            model: model2,
            brush: brush.makeBrush(
              state,
              filterRangeSpecified,
              filterRange,
              function() {
                state.linePickActive(false);
              },
              brushMove,
              function(f) {
                vm.focusLayer.render(vm.panels, true);
                vm.pickLayer && vm.pickLayer.render(vm.panels, true);
                state.linePickActive(true);
                if (callbacks && callbacks.filterChanged) {
                  var invScale = domainToPaddedUnit.invert;
                  var newRanges = f.map(function(r) {
                    return r.map(invScale).sort(Lib.sorterAsc);
                  }).sort(function(a, b) {
                    return a[0] - b[0];
                  });
                  callbacks.filterChanged(vm.key, dimension._index, newRanges);
                }
              }
            )
          };
        });
        return vm;
      }
      function styleExtentTexts(selection) {
        selection.classed(c.cn.axisExtentText, true).attr("text-anchor", "middle").style("cursor", "default");
      }
      function parcoordsInteractionState() {
        var linePickActive = true;
        var contextShown = false;
        return {
          linePickActive: function(val) {
            return arguments.length ? linePickActive = !!val : linePickActive;
          },
          contextShown: function(val) {
            return arguments.length ? contextShown = !!val : contextShown;
          }
        };
      }
      function calcTilt(angle, position) {
        var dir = position === "top" ? 1 : -1;
        var radians = angle * Math.PI / 180;
        var dx = Math.sin(radians);
        var dy = Math.cos(radians);
        return {
          dir,
          dx,
          dy,
          degrees: angle
        };
      }
      function updatePanelLayout(yAxis, vm, plotGlPixelRatio) {
        var panels = vm.panels || (vm.panels = []);
        var data = yAxis.data();
        for (var i = 0; i < data.length - 1; i++) {
          var p = panels[i] || (panels[i] = {});
          var dim0 = data[i];
          var dim1 = data[i + 1];
          p.dim0 = dim0;
          p.dim1 = dim1;
          p.canvasX = dim0.canvasX;
          p.panelSizeX = dim1.canvasX - dim0.canvasX;
          p.panelSizeY = vm.model.canvasHeight;
          p.y = 0;
          p.canvasY = 0;
          p.plotGlPixelRatio = plotGlPixelRatio;
        }
      }
      function calcAllTicks(cd) {
        for (var i = 0; i < cd.length; i++) {
          for (var j = 0; j < cd[i].length; j++) {
            var trace = cd[i][j].trace;
            var dimensions = trace.dimensions;
            for (var k = 0; k < dimensions.length; k++) {
              var values = dimensions[k].values;
              var dim = dimensions[k]._ax;
              if (dim) {
                if (!dim.range) {
                  dim.range = findExtremes(values, trace._length);
                } else {
                  dim.range = fixExtremes(dim.range[0], dim.range[1]);
                }
                if (!dim.dtick) {
                  dim.dtick = 0.01 * (Math.abs(dim.range[1] - dim.range[0]) || 1);
                }
                dim.tickformat = dimensions[k].tickformat;
                Axes.calcTicks(dim);
                dim.cleanRange();
              }
            }
          }
        }
      }
      function linearFormat(dim, v) {
        return Axes.tickText(dim._ax, v, false).text;
      }
      function extremeText(d, isTop) {
        if (d.ordinal) return "";
        var domain = d.domainScale.domain();
        var v = domain[isTop ? domain.length - 1 : 0];
        return linearFormat(d.model.dimensions[d.visibleIndex], v);
      }
      module.exports = function parcoords(gd, cdModule, layout, callbacks) {
        var isStatic = gd._context.staticPlot;
        var fullLayout = gd._fullLayout;
        var svg = fullLayout._toppaper;
        var glContainer = fullLayout._glcontainer;
        var plotGlPixelRatio = gd._context.plotGlPixelRatio;
        var paperColor = gd._fullLayout.paper_bgcolor;
        calcAllTicks(cdModule);
        var state = parcoordsInteractionState();
        var vm = cdModule.filter(function(d) {
          return unwrap(d).trace.visible;
        }).map(model.bind(0, layout)).map(viewModel.bind(0, state, callbacks));
        glContainer.each(function(d, i) {
          return Lib.extendFlat(d, vm[i]);
        });
        var glLayers = glContainer.selectAll(".gl-canvas").each(function(d) {
          d.viewModel = vm[0];
          d.viewModel.plotGlPixelRatio = plotGlPixelRatio;
          d.viewModel.paperColor = paperColor;
          d.model = d.viewModel ? d.viewModel.model : null;
        });
        var lastHovered = null;
        var pickLayer = glLayers.filter(function(d) {
          return d.pick;
        });
        pickLayer.style("pointer-events", isStatic ? "none" : "auto").on("mousemove", function(d) {
          if (state.linePickActive() && d.lineLayer && callbacks && callbacks.hover) {
            var event = d3.event;
            var cw = this.width;
            var ch = this.height;
            var pointer = d3.mouse(this);
            var x = pointer[0];
            var y = pointer[1];
            if (x < 0 || y < 0 || x >= cw || y >= ch) {
              return;
            }
            var pixel = d.lineLayer.readPixel(x, ch - 1 - y);
            var found = pixel[3] !== 0;
            var curveNumber = found ? pixel[2] + 256 * (pixel[1] + 256 * pixel[0]) : null;
            var eventData = {
              x,
              y,
              clientX: event.clientX,
              clientY: event.clientY,
              dataIndex: d.model.key,
              curveNumber
            };
            if (curveNumber !== lastHovered) {
              if (found) {
                callbacks.hover(eventData);
              } else if (callbacks.unhover) {
                callbacks.unhover(eventData);
              }
              lastHovered = curveNumber;
            }
          }
        });
        glLayers.style("opacity", function(d) {
          return d.pick ? 0 : 1;
        });
        svg.style("background", "rgba(255, 255, 255, 0)");
        var controlOverlay = svg.selectAll("." + c.cn.parcoords).data(vm, keyFun);
        controlOverlay.exit().remove();
        controlOverlay.enter().append("g").classed(c.cn.parcoords, true).style("shape-rendering", "crispEdges").style("pointer-events", "none");
        controlOverlay.attr("transform", function(d) {
          return strTranslate(d.model.translateX, d.model.translateY);
        });
        var parcoordsControlView = controlOverlay.selectAll("." + c.cn.parcoordsControlView).data(repeat, keyFun);
        parcoordsControlView.enter().append("g").classed(c.cn.parcoordsControlView, true);
        parcoordsControlView.attr("transform", function(d) {
          return strTranslate(d.model.pad.l, d.model.pad.t);
        });
        var yAxis = parcoordsControlView.selectAll("." + c.cn.yAxis).data(function(p) {
          return p.dimensions;
        }, keyFun);
        yAxis.enter().append("g").classed(c.cn.yAxis, true);
        parcoordsControlView.each(function(p) {
          updatePanelLayout(yAxis, p, plotGlPixelRatio);
        });
        glLayers.each(function(d) {
          if (d.viewModel) {
            if (!d.lineLayer || callbacks) {
              d.lineLayer = lineLayerMaker(this, d);
            } else d.lineLayer.update(d);
            if (d.key || d.key === 0) d.viewModel[d.key] = d.lineLayer;
            var setChanged = !d.context || // don't update background
            callbacks;
            d.lineLayer.render(d.viewModel.panels, setChanged);
          }
        });
        yAxis.attr("transform", function(d) {
          return strTranslate(d.xScale(d.xIndex), 0);
        });
        yAxis.call(
          d3.behavior.drag().origin(function(d) {
            return d;
          }).on("drag", function(d) {
            var p = d.parent;
            state.linePickActive(false);
            d.x = Math.max(-c.overdrag, Math.min(d.model.width + c.overdrag, d3.event.x));
            d.canvasX = d.x * d.model.canvasPixelRatio;
            yAxis.sort(function(a, b) {
              return a.x - b.x;
            }).each(function(e, i) {
              e.xIndex = i;
              e.x = d === e ? e.x : e.xScale(e.xIndex);
              e.canvasX = e.x * e.model.canvasPixelRatio;
            });
            updatePanelLayout(yAxis, p, plotGlPixelRatio);
            yAxis.filter(function(e) {
              return Math.abs(d.xIndex - e.xIndex) !== 0;
            }).attr("transform", function(d2) {
              return strTranslate(d2.xScale(d2.xIndex), 0);
            });
            d3.select(this).attr("transform", strTranslate(d.x, 0));
            yAxis.each(function(e, i0, i1) {
              if (i1 === d.parent.key) p.dimensions[i0] = e;
            });
            p.contextLayer && p.contextLayer.render(p.panels, false, !someFiltersActive(p));
            p.focusLayer.render && p.focusLayer.render(p.panels);
          }).on("dragend", function(d) {
            var p = d.parent;
            d.x = d.xScale(d.xIndex);
            d.canvasX = d.x * d.model.canvasPixelRatio;
            updatePanelLayout(yAxis, p, plotGlPixelRatio);
            d3.select(this).attr("transform", function(d2) {
              return strTranslate(d2.x, 0);
            });
            p.contextLayer && p.contextLayer.render(p.panels, false, !someFiltersActive(p));
            p.focusLayer && p.focusLayer.render(p.panels);
            p.pickLayer && p.pickLayer.render(p.panels, true);
            state.linePickActive(true);
            if (callbacks && callbacks.axesMoved) {
              callbacks.axesMoved(p.key, p.dimensions.map(function(e) {
                return e.crossfilterDimensionIndex;
              }));
            }
          })
        );
        yAxis.exit().remove();
        var axisOverlays = yAxis.selectAll("." + c.cn.axisOverlays).data(repeat, keyFun);
        axisOverlays.enter().append("g").classed(c.cn.axisOverlays, true);
        axisOverlays.selectAll("." + c.cn.axis).remove();
        var axis = axisOverlays.selectAll("." + c.cn.axis).data(repeat, keyFun);
        axis.enter().append("g").classed(c.cn.axis, true);
        axis.each(function(d) {
          var wantedTickCount = d.model.height / d.model.tickDistance;
          var scale = d.domainScale;
          var sdom = scale.domain();
          d3.select(this).call(d3.svg.axis().orient("left").tickSize(4).outerTickSize(2).ticks(wantedTickCount, d.tickFormat).tickValues(d.ordinal ? (
            // and this works for ordinal scales
            sdom
          ) : null).tickFormat(function(v) {
            return helpers.isOrdinal(d) ? v : linearFormat(d.model.dimensions[d.visibleIndex], v);
          }).scale(scale));
          Drawing.font(axis.selectAll("text"), d.model.tickFont);
        });
        axis.selectAll(".domain, .tick>line").attr("fill", "none").attr("stroke", "black").attr("stroke-opacity", 0.25).attr("stroke-width", "1px");
        axis.selectAll("text").style("cursor", "default");
        var axisHeading = axisOverlays.selectAll("." + c.cn.axisHeading).data(repeat, keyFun);
        axisHeading.enter().append("g").classed(c.cn.axisHeading, true);
        var axisTitle = axisHeading.selectAll("." + c.cn.axisTitle).data(repeat, keyFun);
        axisTitle.enter().append("text").classed(c.cn.axisTitle, true).attr("text-anchor", "middle").style("cursor", "ew-resize").style("pointer-events", isStatic ? "none" : "auto");
        axisTitle.text(function(d) {
          return d.label;
        }).each(function(d) {
          var e = d3.select(this);
          Drawing.font(e, d.model.labelFont);
          svgTextUtils.convertToTspans(e, gd);
        }).attr("transform", function(d) {
          var tilt = calcTilt(d.model.labelAngle, d.model.labelSide);
          var r = c.axisTitleOffset;
          return (tilt.dir > 0 ? "" : strTranslate(0, 2 * r + d.model.height)) + strRotate(tilt.degrees) + strTranslate(-r * tilt.dx, -r * tilt.dy);
        }).attr("text-anchor", function(d) {
          var tilt = calcTilt(d.model.labelAngle, d.model.labelSide);
          var adx = Math.abs(tilt.dx);
          var ady = Math.abs(tilt.dy);
          if (2 * adx > ady) {
            return tilt.dir * tilt.dx < 0 ? "start" : "end";
          } else {
            return "middle";
          }
        });
        var axisExtent = axisOverlays.selectAll("." + c.cn.axisExtent).data(repeat, keyFun);
        axisExtent.enter().append("g").classed(c.cn.axisExtent, true);
        var axisExtentTop = axisExtent.selectAll("." + c.cn.axisExtentTop).data(repeat, keyFun);
        axisExtentTop.enter().append("g").classed(c.cn.axisExtentTop, true);
        axisExtentTop.attr("transform", strTranslate(0, -c.axisExtentOffset));
        var axisExtentTopText = axisExtentTop.selectAll("." + c.cn.axisExtentTopText).data(repeat, keyFun);
        axisExtentTopText.enter().append("text").classed(c.cn.axisExtentTopText, true).call(styleExtentTexts);
        axisExtentTopText.text(function(d) {
          return extremeText(d, true);
        }).each(function(d) {
          Drawing.font(d3.select(this), d.model.rangeFont);
        });
        var axisExtentBottom = axisExtent.selectAll("." + c.cn.axisExtentBottom).data(repeat, keyFun);
        axisExtentBottom.enter().append("g").classed(c.cn.axisExtentBottom, true);
        axisExtentBottom.attr("transform", function(d) {
          return strTranslate(0, d.model.height + c.axisExtentOffset);
        });
        var axisExtentBottomText = axisExtentBottom.selectAll("." + c.cn.axisExtentBottomText).data(repeat, keyFun);
        axisExtentBottomText.enter().append("text").classed(c.cn.axisExtentBottomText, true).attr("dy", "0.75em").call(styleExtentTexts);
        axisExtentBottomText.text(function(d) {
          return extremeText(d, false);
        }).each(function(d) {
          Drawing.font(d3.select(this), d.model.rangeFont);
        });
        brush.ensureAxisBrush(axisOverlays, paperColor, gd);
      };
    }
  });

  // src/traces/parcoords/plot.js
  var require_plot5 = __commonJS({
    "src/traces/parcoords/plot.js"(exports, module) {
      "use strict";
      var parcoords = require_parcoords();
      var prepareRegl = require_prepare_regl();
      var isVisible = require_helpers14().isVisible;
      var reglPrecompiled = {};
      function newIndex(visibleIndices, orig, dim) {
        var origIndex = orig.indexOf(dim);
        var currentIndex = visibleIndices.indexOf(origIndex);
        if (currentIndex === -1) {
          currentIndex += orig.length;
        }
        return currentIndex;
      }
      function sorter(visibleIndices, orig) {
        return function sorter2(d1, d2) {
          return newIndex(visibleIndices, orig, d1) - newIndex(visibleIndices, orig, d2);
        };
      }
      var exports = module.exports = function plot(gd, cdModule) {
        var fullLayout = gd._fullLayout;
        var success = prepareRegl(gd, [], reglPrecompiled);
        if (!success) return;
        var currentDims = {};
        var initialDims = {};
        var fullIndices = {};
        var inputIndices = {};
        var size = fullLayout._size;
        cdModule.forEach(function(d, i) {
          var trace = d[0].trace;
          fullIndices[i] = trace.index;
          var iIn = inputIndices[i] = trace.index;
          currentDims[i] = gd.data[iIn].dimensions;
          initialDims[i] = gd.data[iIn].dimensions.slice();
        });
        var filterChanged = function(i, initialDimIndex, newRanges) {
          var dim = initialDims[i][initialDimIndex];
          var newConstraints = newRanges.map(function(r) {
            return r.slice();
          });
          var aStr = "dimensions[" + initialDimIndex + "].constraintrange";
          var preGUI = fullLayout._tracePreGUI[gd._fullData[fullIndices[i]]._fullInput.uid];
          if (preGUI[aStr] === void 0) {
            var initialVal = dim.constraintrange;
            preGUI[aStr] = initialVal || null;
          }
          var fullDimension = gd._fullData[fullIndices[i]].dimensions[initialDimIndex];
          if (!newConstraints.length) {
            delete dim.constraintrange;
            delete fullDimension.constraintrange;
            newConstraints = null;
          } else {
            if (newConstraints.length === 1) newConstraints = newConstraints[0];
            dim.constraintrange = newConstraints;
            fullDimension.constraintrange = newConstraints.slice();
            newConstraints = [newConstraints];
          }
          var restyleData = {};
          restyleData[aStr] = newConstraints;
          gd.emit("plotly_restyle", [restyleData, [inputIndices[i]]]);
        };
        var hover = function(eventData) {
          gd.emit("plotly_hover", eventData);
        };
        var unhover = function(eventData) {
          gd.emit("plotly_unhover", eventData);
        };
        var axesMoved = function(i, visibleIndices) {
          var orig = sorter(visibleIndices, initialDims[i].filter(isVisible));
          currentDims[i].sort(orig);
          initialDims[i].filter(function(d) {
            return !isVisible(d);
          }).sort(function(d) {
            return initialDims[i].indexOf(d);
          }).forEach(function(d) {
            currentDims[i].splice(currentDims[i].indexOf(d), 1);
            currentDims[i].splice(initialDims[i].indexOf(d), 0, d);
          });
          gd.emit("plotly_restyle", [{ dimensions: [currentDims[i]] }, [inputIndices[i]]]);
        };
        parcoords(
          gd,
          cdModule,
          {
            // layout
            width: size.w,
            height: size.h,
            margin: {
              t: size.t,
              r: size.r,
              b: size.b,
              l: size.l
            }
          },
          {
            // callbacks
            filterChanged,
            hover,
            unhover,
            axesMoved
          }
        );
      };
      exports.reglPrecompiled = reglPrecompiled;
    }
  });

  // src/traces/parcoords/base_plot.js
  var require_base_plot2 = __commonJS({
    "src/traces/parcoords/base_plot.js"(exports) {
      "use strict";
      var d3 = require_d3();
      var getModuleCalcData = require_get_data().getModuleCalcData;
      var parcoordsPlot = require_plot5();
      var xmlnsNamespaces = require_xmlns_namespaces();
      exports.name = "parcoords";
      exports.plot = function(gd) {
        var calcData = getModuleCalcData(gd.calcdata, "parcoords")[0];
        if (calcData.length) parcoordsPlot(gd, calcData);
      };
      exports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
        var hadParcoords = oldFullLayout._has && oldFullLayout._has("parcoords");
        var hasParcoords = newFullLayout._has && newFullLayout._has("parcoords");
        if (hadParcoords && !hasParcoords) {
          oldFullLayout._paperdiv.selectAll(".parcoords").remove();
          oldFullLayout._glimages.selectAll("*").remove();
        }
      };
      exports.toSVG = function(gd) {
        var imageRoot = gd._fullLayout._glimages;
        var root = d3.select(gd).selectAll(".svg-container");
        var canvases = root.filter(function(d, i) {
          return i === root.size() - 1;
        }).selectAll(".gl-canvas-context, .gl-canvas-focus");
        function canvasToImage() {
          var canvas = this;
          var imageData = canvas.toDataURL("image/png");
          var image = imageRoot.append("svg:image");
          image.attr({
            xmlns: xmlnsNamespaces.svg,
            "xlink:href": imageData,
            preserveAspectRatio: "none",
            x: 0,
            y: 0,
            width: canvas.style.width,
            height: canvas.style.height
          });
        }
        canvases.each(canvasToImage);
        window.setTimeout(function() {
          d3.selectAll("#filterBarPattern").attr("id", "filterBarPattern");
        }, 60);
      };
    }
  });

  // src/traces/parcoords/base_index.js
  var require_base_index3 = __commonJS({
    "src/traces/parcoords/base_index.js"(exports, module) {
      "use strict";
      module.exports = {
        attributes: require_attributes25(),
        supplyDefaults: require_defaults21(),
        calc: require_calc7(),
        colorbar: {
          container: "line",
          min: "cmin",
          max: "cmax"
        },
        moduleType: "trace",
        name: "parcoords",
        basePlotModule: require_base_plot2(),
        categories: ["gl", "regl", "noOpacity", "noHover"],
        meta: {}
      };
    }
  });

  // src/traces/parcoords/index.js
  var require_parcoords2 = __commonJS({
    "src/traces/parcoords/index.js"(exports, module) {
      "use strict";
      var index = require_base_index3();
      index.plot = require_plot5();
      module.exports = index;
    }
  });

  // lib/parcoords.js
  var require_parcoords3 = __commonJS({
    "lib/parcoords.js"(exports, module) {
      "use strict";
      module.exports = require_parcoords2();
    }
  });

  // node_modules/world-calendars/dist/main.js
  var require_main = __commonJS({
    "node_modules/world-calendars/dist/main.js"(exports, module) {
      var assign = require_object_assign();
      function Calendars() {
        this.regionalOptions = [];
        this.regionalOptions[""] = {
          invalidCalendar: "Calendar {0} not found",
          invalidDate: "Invalid {0} date",
          invalidMonth: "Invalid {0} month",
          invalidYear: "Invalid {0} year",
          differentCalendars: "Cannot mix {0} and {1} dates"
        };
        this.local = this.regionalOptions[""];
        this.calendars = {};
        this._localCals = {};
      }
      assign(Calendars.prototype, {
        /** Obtain a calendar implementation and localisation.
            @memberof Calendars
            @param [name='gregorian'] {string} The name of the calendar, e.g. 'gregorian', 'persian', 'islamic'.
            @param [language=''] {string} The language code to use for localisation (default is English).
            @return {Calendar} The calendar and localisation.
            @throws Error if calendar not found. */
        instance: function(name, language) {
          name = (name || "gregorian").toLowerCase();
          language = language || "";
          var cal = this._localCals[name + "-" + language];
          if (!cal && this.calendars[name]) {
            cal = new this.calendars[name](language);
            this._localCals[name + "-" + language] = cal;
          }
          if (!cal) {
            throw (this.local.invalidCalendar || this.regionalOptions[""].invalidCalendar).replace(/\{0\}/, name);
          }
          return cal;
        },
        /** Create a new date - for today if no other parameters given.
            @memberof Calendars
            @param year {CDate|number} The date to copy or the year for the date.
            @param [month] {number} The month for the date.
            @param [day] {number} The day for the date.
            @param [calendar='gregorian'] {BaseCalendar|string} The underlying calendar or the name of the calendar.
            @param [language=''] {string} The language to use for localisation (default English).
            @return {CDate} The new date.
            @throws Error if an invalid date. */
        newDate: function(year, month, day, calendar, language) {
          calendar = (year != null && year.year ? year.calendar() : typeof calendar === "string" ? this.instance(calendar, language) : calendar) || this.instance();
          return calendar.newDate(year, month, day);
        },
        /** A simple digit substitution function for localising numbers via the Calendar digits option.
            @member Calendars
            @param digits {string[]} The substitute digits, for 0 through 9.
            @return {function} The substitution function. */
        substituteDigits: function(digits) {
          return function(value) {
            return (value + "").replace(/[0-9]/g, function(digit) {
              return digits[digit];
            });
          };
        },
        /** Digit substitution function for localising Chinese style numbers via the Calendar digits option.
            @member Calendars
            @param digits {string[]} The substitute digits, for 0 through 9.
            @param powers {string[]} The characters denoting powers of 10, i.e. 1, 10, 100, 1000.
            @return {function} The substitution function. */
        substituteChineseDigits: function(digits, powers) {
          return function(value) {
            var localNumber = "";
            var power = 0;
            while (value > 0) {
              var units = value % 10;
              localNumber = (units === 0 ? "" : digits[units] + powers[power]) + localNumber;
              power++;
              value = Math.floor(value / 10);
            }
            if (localNumber.indexOf(digits[1] + powers[1]) === 0) {
              localNumber = localNumber.substr(1);
            }
            return localNumber || digits[0];
          };
        }
      });
      function CDate(calendar, year, month, day) {
        this._calendar = calendar;
        this._year = year;
        this._month = month;
        this._day = day;
        if (this._calendar._validateLevel === 0 && !this._calendar.isValid(this._year, this._month, this._day)) {
          throw (_exports.local.invalidDate || _exports.regionalOptions[""].invalidDate).replace(/\{0\}/, this._calendar.local.name);
        }
      }
      function pad(value, length) {
        value = "" + value;
        return "000000".substring(0, length - value.length) + value;
      }
      assign(CDate.prototype, {
        /** Create a new date.
            @memberof CDate
            @param [year] {CDate|number} The date to copy or the year for the date (default this date).
            @param [month] {number} The month for the date.
            @param [day] {number} The day for the date.
            @return {CDate} The new date.
            @throws Error if an invalid date. */
        newDate: function(year, month, day) {
          return this._calendar.newDate(year == null ? this : year, month, day);
        },
        /** Set or retrieve the year for this date.
            @memberof CDate
            @param [year] {number} The year for the date.
            @return {number|CDate} The date's year (if no parameter) or the updated date.
            @throws Error if an invalid date. */
        year: function(year) {
          return arguments.length === 0 ? this._year : this.set(year, "y");
        },
        /** Set or retrieve the month for this date.
            @memberof CDate
            @param [month] {number} The month for the date.
            @return {number|CDate} The date's month (if no parameter) or the updated date.
            @throws Error if an invalid date. */
        month: function(month) {
          return arguments.length === 0 ? this._month : this.set(month, "m");
        },
        /** Set or retrieve the day for this date.
            @memberof CDate
            @param [day] {number} The day for the date.
            @return {number|CData} The date's day (if no parameter) or the updated date.
            @throws Error if an invalid date. */
        day: function(day) {
          return arguments.length === 0 ? this._day : this.set(day, "d");
        },
        /** Set new values for this date.
            @memberof CDate
            @param year {number} The year for the date.
            @param month {number} The month for the date.
            @param day {number} The day for the date.
            @return {CDate} The updated date.
            @throws Error if an invalid date. */
        date: function(year, month, day) {
          if (!this._calendar.isValid(year, month, day)) {
            throw (_exports.local.invalidDate || _exports.regionalOptions[""].invalidDate).replace(/\{0\}/, this._calendar.local.name);
          }
          this._year = year;
          this._month = month;
          this._day = day;
          return this;
        },
        /** Determine whether this date is in a leap year.
            @memberof CDate
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not. */
        leapYear: function() {
          return this._calendar.leapYear(this);
        },
        /** Retrieve the epoch designator for this date, e.g. BCE or CE.
            @memberof CDate
            @return {string} The current epoch. */
        epoch: function() {
          return this._calendar.epoch(this);
        },
        /** Format the year, if not a simple sequential number.
            @memberof CDate
            @return {string} The formatted year. */
        formatYear: function() {
          return this._calendar.formatYear(this);
        },
        /** Retrieve the month of the year for this date,
            i.e. the month's position within a numbered year.
            @memberof CDate
            @return {number} The month of the year: <code>minMonth</code> to months per year. */
        monthOfYear: function() {
          return this._calendar.monthOfYear(this);
        },
        /** Retrieve the week of the year for this date.
            @memberof CDate
            @return {number} The week of the year: 1 to weeks per year. */
        weekOfYear: function() {
          return this._calendar.weekOfYear(this);
        },
        /** Retrieve the number of days in the year for this date.
            @memberof CDate
            @return {number} The number of days in this year. */
        daysInYear: function() {
          return this._calendar.daysInYear(this);
        },
        /** Retrieve the day of the year for this date.
            @memberof CDate
            @return {number} The day of the year: 1 to days per year. */
        dayOfYear: function() {
          return this._calendar.dayOfYear(this);
        },
        /** Retrieve the number of days in the month for this date.
            @memberof CDate
            @return {number} The number of days. */
        daysInMonth: function() {
          return this._calendar.daysInMonth(this);
        },
        /** Retrieve the day of the week for this date.
            @memberof CDate
            @return {number} The day of the week: 0 to number of days - 1. */
        dayOfWeek: function() {
          return this._calendar.dayOfWeek(this);
        },
        /** Determine whether this date is a week day.
            @memberof CDate
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not. */
        weekDay: function() {
          return this._calendar.weekDay(this);
        },
        /** Retrieve additional information about this date.
            @memberof CDate
            @return {object} Additional information - contents depends on calendar. */
        extraInfo: function() {
          return this._calendar.extraInfo(this);
        },
        /** Add period(s) to a date.
            @memberof CDate
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date. */
        add: function(offset, period) {
          return this._calendar.add(this, offset, period);
        },
        /** Set a portion of the date.
            @memberof CDate
            @param value {number} The new value for the period.
            @param period {string} One of 'y' for year, 'm' for month, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if not a valid date. */
        set: function(value, period) {
          return this._calendar.set(this, value, period);
        },
        /** Compare this date to another date.
            @memberof CDate
            @param date {CDate} The other date.
            @return {number} -1 if this date is before the other date,
                    0 if they are equal, or +1 if this date is after the other date. */
        compareTo: function(date) {
          if (this._calendar.name !== date._calendar.name) {
            throw (_exports.local.differentCalendars || _exports.regionalOptions[""].differentCalendars).replace(/\{0\}/, this._calendar.local.name).replace(/\{1\}/, date._calendar.local.name);
          }
          var c = this._year !== date._year ? this._year - date._year : this._month !== date._month ? this.monthOfYear() - date.monthOfYear() : this._day - date._day;
          return c === 0 ? 0 : c < 0 ? -1 : 1;
        },
        /** Retrieve the calendar backing this date.
            @memberof CDate
            @return {BaseCalendar} The calendar implementation. */
        calendar: function() {
          return this._calendar;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof CDate
            @return {number} The equivalent Julian date. */
        toJD: function() {
          return this._calendar.toJD(this);
        },
        /** Create a new date from a Julian date.
            @memberof CDate
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          return this._calendar.fromJD(jd);
        },
        /** Convert this date to a standard (Gregorian) JavaScript Date.
            @memberof CDate
            @return {Date} The equivalent JavaScript date. */
        toJSDate: function() {
          return this._calendar.toJSDate(this);
        },
        /** Create a new date from a standard (Gregorian) JavaScript Date.
            @memberof CDate
            @param jsd {Date} The JavaScript date to convert.
            @return {CDate} The equivalent date. */
        fromJSDate: function(jsd) {
          return this._calendar.fromJSDate(jsd);
        },
        /** Convert to a string for display.
            @memberof CDate
            @return {string} This date as a string. */
        toString: function() {
          return (this.year() < 0 ? "-" : "") + pad(Math.abs(this.year()), 4) + "-" + pad(this.month(), 2) + "-" + pad(this.day(), 2);
        }
      });
      function BaseCalendar() {
        this.shortYearCutoff = "+10";
      }
      assign(BaseCalendar.prototype, {
        _validateLevel: 0,
        // "Stack" to turn validation on/off
        /** Create a new date within this calendar - today if no parameters given.
            @memberof BaseCalendar
            @param year {CDate|number} The date to duplicate or the year for the date.
            @param [month] {number} The month for the date.
            @param [day] {number} The day for the date.
            @return {CDate} The new date.
            @throws Error if not a valid date or a different calendar used. */
        newDate: function(year, month, day) {
          if (year == null) {
            return this.today();
          }
          if (year.year) {
            this._validate(
              year,
              month,
              day,
              _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
            );
            day = year.day();
            month = year.month();
            year = year.year();
          }
          return new CDate(this, year, month, day);
        },
        /** Create a new date for today.
            @memberof BaseCalendar
            @return {CDate} Today's date. */
        today: function() {
          return this.fromJSDate(/* @__PURE__ */ new Date());
        },
        /** Retrieve the epoch designator for this date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {string} The current epoch.
            @throws Error if an invalid year or a different calendar used. */
        epoch: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return date.year() < 0 ? this.local.epochs[0] : this.local.epochs[1];
        },
        /** Format the year, if not a simple sequential number
            @memberof BaseCalendar
            @param year {CDate|number} The date to format or the year to format.
            @return {string} The formatted year.
            @throws Error if an invalid year or a different calendar used. */
        formatYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return (date.year() < 0 ? "-" : "") + pad(Math.abs(date.year()), 4);
        },
        /** Retrieve the number of months in a year.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return 12;
        },
        /** Calculate the month's ordinal position within the year -
            for those calendars that don't start at month 1!
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param month {number} The month to examine.
            @return {number} The ordinal position, starting from <code>minMonth</code>.
            @throws Error if an invalid year/month or a different calendar used. */
        monthOfYear: function(year, month) {
          var date = this._validate(
            year,
            month,
            this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[""].invalidMonth
          );
          return (date.month() + this.monthsInYear(date) - this.firstMonth) % this.monthsInYear(date) + this.minMonth;
        },
        /** Calculate actual month from ordinal position, starting from minMonth.
            @memberof BaseCalendar
            @param year {number} The year to examine.
            @param ord {number} The month's ordinal position.
            @return {number} The month's number.
            @throws Error if an invalid year/month. */
        fromMonthOfYear: function(year, ord) {
          var m = (ord + this.firstMonth - 2 * this.minMonth) % this.monthsInYear(year) + this.minMonth;
          this._validate(
            year,
            m,
            this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[""].invalidMonth
          );
          return m;
        },
        /** Retrieve the number of days in a year.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          return this.leapYear(date) ? 366 : 365;
        },
        /** Retrieve the day of the year for a date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The day of the year.
            @throws Error if an invalid date or a different calendar used. */
        dayOfYear: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return date.toJD() - this.newDate(
            date.year(),
            this.fromMonthOfYear(date.year(), this.minMonth),
            this.minDay
          ).toJD() + 1;
        },
        /** Retrieve the number of days in a week.
            @memberof BaseCalendar
            @return {number} The number of days. */
        daysInWeek: function() {
          return 7;
        },
        /** Retrieve the day of the week for a date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The day of the week: 0 to number of days - 1.
            @throws Error if an invalid date or a different calendar used. */
        dayOfWeek: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return (Math.floor(this.toJD(date)) + 2) % this.daysInWeek();
        },
        /** Retrieve additional information about a date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return {};
        },
        /** Add period(s) to a date.
            Cater for no year zero.
            @memberof BaseCalendar
            @param date {CDate} The starting date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if a different calendar used. */
        add: function(date, offset, period) {
          this._validate(
            date,
            this.minMonth,
            this.minDay,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return this._correctAdd(date, this._add(date, offset, period), offset, period);
        },
        /** Add period(s) to a date.
            @memberof BaseCalendar
            @private
            @param date {CDate} The starting date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date. */
        _add: function(date, offset, period) {
          this._validateLevel++;
          if (period === "d" || period === "w") {
            var jd = date.toJD() + offset * (period === "w" ? this.daysInWeek() : 1);
            var d = date.calendar().fromJD(jd);
            this._validateLevel--;
            return [d.year(), d.month(), d.day()];
          }
          try {
            var y = date.year() + (period === "y" ? offset : 0);
            var m = date.monthOfYear() + (period === "m" ? offset : 0);
            var d = date.day();
            var resyncYearMonth = function(calendar) {
              while (m < calendar.minMonth) {
                y--;
                m += calendar.monthsInYear(y);
              }
              var yearMonths = calendar.monthsInYear(y);
              while (m > yearMonths - 1 + calendar.minMonth) {
                y++;
                m -= yearMonths;
                yearMonths = calendar.monthsInYear(y);
              }
            };
            if (period === "y") {
              if (date.month() !== this.fromMonthOfYear(y, m)) {
                m = this.newDate(y, date.month(), this.minDay).monthOfYear();
              }
              m = Math.min(m, this.monthsInYear(y));
              d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
            } else if (period === "m") {
              resyncYearMonth(this);
              d = Math.min(d, this.daysInMonth(y, this.fromMonthOfYear(y, m)));
            }
            var ymd = [y, this.fromMonthOfYear(y, m), d];
            this._validateLevel--;
            return ymd;
          } catch (e) {
            this._validateLevel--;
            throw e;
          }
        },
        /** Correct a candidate date after adding period(s) to a date.
            Handle no year zero if necessary.
            @memberof BaseCalendar
            @private
            @param date {CDate} The starting date.
            @param ymd {number[]} The added date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date. */
        _correctAdd: function(date, ymd, offset, period) {
          if (!this.hasYearZero && (period === "y" || period === "m")) {
            if (ymd[0] === 0 || // In year zero
            date.year() > 0 !== ymd[0] > 0) {
              var adj = {
                y: [1, 1, "y"],
                m: [1, this.monthsInYear(-1), "m"],
                w: [this.daysInWeek(), this.daysInYear(-1), "d"],
                d: [1, this.daysInYear(-1), "d"]
              }[period];
              var dir = offset < 0 ? -1 : 1;
              ymd = this._add(date, offset * adj[0] + dir * adj[1], adj[2]);
            }
          }
          return date.date(ymd[0], ymd[1], ymd[2]);
        },
        /** Set a portion of the date.
            @memberof BaseCalendar
            @param date {CDate} The starting date.
            @param value {number} The new value for the period.
            @param period {string} One of 'y' for year, 'm' for month, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if an invalid date or a different calendar used. */
        set: function(date, value, period) {
          this._validate(
            date,
            this.minMonth,
            this.minDay,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          var y = period === "y" ? value : date.year();
          var m = period === "m" ? value : date.month();
          var d = period === "d" ? value : date.day();
          if (period === "y" || period === "m") {
            d = Math.min(d, this.daysInMonth(y, m));
          }
          return date.date(y, m, d);
        },
        /** Determine whether a date is valid for this calendar.
            @memberof BaseCalendar
            @param year {number} The year to examine.
            @param month {number} The month to examine.
            @param day {number} The day to examine.
            @return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
        isValid: function(year, month, day) {
          this._validateLevel++;
          var valid = this.hasYearZero || year !== 0;
          if (valid) {
            var date = this.newDate(year, month, this.minDay);
            valid = month >= this.minMonth && month - this.minMonth < this.monthsInYear(date) && (day >= this.minDay && day - this.minDay < this.daysInMonth(date));
          }
          this._validateLevel--;
          return valid;
        },
        /** Convert the date to a standard (Gregorian) JavaScript Date.
            @memberof BaseCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {Date} The equivalent JavaScript date.
            @throws Error if an invalid date or a different calendar used. */
        toJSDate: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          return _exports.instance().fromJD(this.toJD(date)).toJSDate();
        },
        /** Convert the date from a standard (Gregorian) JavaScript Date.
            @memberof BaseCalendar
            @param jsd {Date} The JavaScript date.
            @return {CDate} The equivalent calendar date. */
        fromJSDate: function(jsd) {
          return this.fromJD(_exports.instance().fromJSDate(jsd).toJD());
        },
        /** Check that a candidate date is from the same calendar and is valid.
            @memberof BaseCalendar
            @private
            @param year {CDate|number} The date to validate or the year to validate.
            @param [month] {number} The month to validate.
            @param [day] {number} The day to validate.
            @param error {string} Rrror message if invalid.
            @throws Error if different calendars used or invalid date. */
        _validate: function(year, month, day, error) {
          if (year.year) {
            if (this._validateLevel === 0 && this.name !== year.calendar().name) {
              throw (_exports.local.differentCalendars || _exports.regionalOptions[""].differentCalendars).replace(/\{0\}/, this.local.name).replace(/\{1\}/, year.calendar().local.name);
            }
            return year;
          }
          try {
            this._validateLevel++;
            if (this._validateLevel === 1 && !this.isValid(year, month, day)) {
              throw error.replace(/\{0\}/, this.local.name);
            }
            var date = this.newDate(year, month, day);
            this._validateLevel--;
            return date;
          } catch (e) {
            this._validateLevel--;
            throw e;
          }
        }
      });
      function GregorianCalendar(language) {
        this.local = this.regionalOptions[language] || this.regionalOptions[""];
      }
      GregorianCalendar.prototype = new BaseCalendar();
      assign(GregorianCalendar.prototype, {
        /** The calendar name.
            @memberof GregorianCalendar */
        name: "Gregorian",
        /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
           @memberof GregorianCalendar */
        jdEpoch: 17214255e-1,
        /** Days per month in a common year.
           @memberof GregorianCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
           @memberof GregorianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof GregorianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof GregorianCalendar */
        firstMonth: 1,
        /** The minimum day number.
           @memberof GregorianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof GregorianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Gregorian",
            epochs: ["BCE", "CE"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "mm/dd/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            _exports.local.invalidYear || _exports.regionalOptions[""].invalidYear
          );
          var year = date.year() + (date.year() < 0 ? 1 : 0);
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year, starting from 1.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(4 - (checkDate.dayOfWeek() || 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(
            year,
            month,
            this.minDay,
            _exports.local.invalidMonth || _exports.regionalOptions[""].invalidMonth
          );
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          year = date.year();
          month = date.month();
          day = date.day();
          if (year < 0) {
            year++;
          }
          if (month < 3) {
            month += 12;
            year--;
          }
          var a = Math.floor(year / 100);
          var b = 2 - a + Math.floor(a / 4);
          return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + b - 1524.5;
        },
        /** Create a new date from a Julian date.
            @memberof GregorianCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var z = Math.floor(jd + 0.5);
          var a = Math.floor((z - 186721625e-2) / 36524.25);
          a = z + 1 + a - Math.floor(a / 4);
          var b = a + 1524;
          var c = Math.floor((b - 122.1) / 365.25);
          var d = Math.floor(365.25 * c);
          var e = Math.floor((b - d) / 30.6001);
          var day = b - d - Math.floor(e * 30.6001);
          var month = e - (e > 13.5 ? 13 : 1);
          var year = c - (month > 2.5 ? 4716 : 4715);
          if (year <= 0) {
            year--;
          }
          return this.newDate(year, month, day);
        },
        /** Convert this date to a standard (Gregorian) JavaScript Date.
            @memberof GregorianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {Date} The equivalent JavaScript date.
            @throws Error if an invalid date or a different calendar used. */
        toJSDate: function(year, month, day) {
          var date = this._validate(
            year,
            month,
            day,
            _exports.local.invalidDate || _exports.regionalOptions[""].invalidDate
          );
          var jsd = new Date(date.year(), date.month() - 1, date.day());
          jsd.setHours(0);
          jsd.setMinutes(0);
          jsd.setSeconds(0);
          jsd.setMilliseconds(0);
          jsd.setHours(jsd.getHours() > 12 ? jsd.getHours() + 2 : 0);
          return jsd;
        },
        /** Create a new date from a standard (Gregorian) JavaScript Date.
            @memberof GregorianCalendar
            @param jsd {Date} The JavaScript date to convert.
            @return {CDate} The equivalent date. */
        fromJSDate: function(jsd) {
          return this.newDate(jsd.getFullYear(), jsd.getMonth() + 1, jsd.getDate());
        }
      });
      var _exports = module.exports = new Calendars();
      _exports.cdate = CDate;
      _exports.baseCalendar = BaseCalendar;
      _exports.calendars.gregorian = GregorianCalendar;
    }
  });

  // node_modules/world-calendars/dist/plus.js
  var require_plus = __commonJS({
    "node_modules/world-calendars/dist/plus.js"() {
      var assign = require_object_assign();
      var main = require_main();
      assign(main.regionalOptions[""], {
        invalidArguments: "Invalid arguments",
        invalidFormat: "Cannot format a date from another calendar",
        missingNumberAt: "Missing number at position {0}",
        unknownNameAt: "Unknown name at position {0}",
        unexpectedLiteralAt: "Unexpected literal at position {0}",
        unexpectedText: "Additional text found at end"
      });
      main.local = main.regionalOptions[""];
      assign(main.cdate.prototype, {
        /** Format this date.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof CDate
            @param [format] {string} The date format to use (see <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a>).
            @param [settings] {object} Options for the <code>formatDate</code> function.
            @return {string} The formatted date. */
        formatDate: function(format, settings) {
          if (typeof format !== "string") {
            settings = format;
            format = "";
          }
          return this._calendar.formatDate(format || "", this, settings);
        }
      });
      assign(main.baseCalendar.prototype, {
        UNIX_EPOCH: main.instance().newDate(1970, 1, 1).toJD(),
        SECS_PER_DAY: 24 * 60 * 60,
        TICKS_EPOCH: main.instance().jdEpoch,
        // 1 January 0001 CE
        TICKS_PER_DAY: 24 * 60 * 60 * 1e7,
        /** Date form for ATOM (RFC 3339/ISO 8601).
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        ATOM: "yyyy-mm-dd",
        /** Date form for cookies.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        COOKIE: "D, dd M yyyy",
        /** Date form for full date.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        FULL: "DD, MM d, yyyy",
        /** Date form for ISO 8601.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        ISO_8601: "yyyy-mm-dd",
        /** Date form for Julian date.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        JULIAN: "J",
        /** Date form for RFC 822.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_822: "D, d M yy",
        /** Date form for RFC 850.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_850: "DD, dd-M-yy",
        /** Date form for RFC 1036.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_1036: "D, d M yy",
        /** Date form for RFC 1123.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_1123: "D, d M yyyy",
        /** Date form for RFC 2822.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RFC_2822: "D, d M yyyy",
        /** Date form for RSS (RFC 822).
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        RSS: "D, d M yy",
        /** Date form for Windows ticks.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        TICKS: "!",
        /** Date form for Unix timestamp.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        TIMESTAMP: "@",
        /** Date form for W3c (ISO 8601).
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar */
        W3C: "yyyy-mm-dd",
        /** Format a date object into a string value.
            The format can be combinations of the following:
            <ul>
            <li>d  - day of month (no leading zero)</li>
            <li>dd - day of month (two digit)</li>
            <li>o  - day of year (no leading zeros)</li>
            <li>oo - day of year (three digit)</li>
            <li>D  - day name short</li>
            <li>DD - day name long</li>
            <li>w  - week of year (no leading zero)</li>
            <li>ww - week of year (two digit)</li>
            <li>m  - month of year (no leading zero)</li>
            <li>mm - month of year (two digit)</li>
            <li>M  - month name short</li>
            <li>MM - month name long</li>
            <li>yy - year (two digit)</li>
            <li>yyyy - year (four digit)</li>
            <li>YYYY - formatted year</li>
            <li>J  - Julian date (days since January 1, 4713 BCE Greenwich noon)</li>
            <li>@  - Unix timestamp (s since 01/01/1970)</li>
            <li>!  - Windows ticks (100ns since 01/01/0001)</li>
            <li>'...' - literal text</li>
            <li>'' - single quote</li>
            </ul>
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar
            @param [format] {string} The desired format of the date (defaults to calendar format).
            @param date {CDate} The date value to format.
            @param [settings] {object} Addition options, whose attributes include:
            @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
            @property [dayNames] {string[]} Names of the days from Sunday.
            @property [monthNamesShort] {string[]} Abbreviated names of the months.
            @property [monthNames] {string[]} Names of the months.
            @property [calculateWeek] {CalendarsPickerCalculateWeek} Function that determines week of the year.
            @property [localNumbers=false] {boolean} <code>true</code> to localise numbers (if available),
                      <code>false</code> to use normal Arabic numerals.
            @return {string} The date in the above format.
            @throws Errors if the date is from a different calendar. */
        formatDate: function(format, date, settings) {
          if (typeof format !== "string") {
            settings = date;
            date = format;
            format = "";
          }
          if (!date) {
            return "";
          }
          if (date.calendar() !== this) {
            throw main.local.invalidFormat || main.regionalOptions[""].invalidFormat;
          }
          format = format || this.local.dateFormat;
          settings = settings || {};
          var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
          var dayNames = settings.dayNames || this.local.dayNames;
          var monthNumbers = settings.monthNumbers || this.local.monthNumbers;
          var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
          var monthNames = settings.monthNames || this.local.monthNames;
          var calculateWeek = settings.calculateWeek || this.local.calculateWeek;
          var doubled = function(match, step) {
            var matches = 1;
            while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
              matches++;
            }
            iFormat += matches - 1;
            return Math.floor(matches / (step || 1)) > 1;
          };
          var formatNumber = function(match, value, len, step) {
            var num = "" + value;
            if (doubled(match, step)) {
              while (num.length < len) {
                num = "0" + num;
              }
            }
            return num;
          };
          var formatName = function(match, value, shortNames, longNames) {
            return doubled(match) ? longNames[value] : shortNames[value];
          };
          var calendar = this;
          var formatMonth = function(date2) {
            return typeof monthNumbers === "function" ? monthNumbers.call(calendar, date2, doubled("m")) : localiseNumbers(formatNumber("m", date2.month(), 2));
          };
          var formatMonthName = function(date2, useLongName) {
            if (useLongName) {
              return typeof monthNames === "function" ? monthNames.call(calendar, date2) : monthNames[date2.month() - calendar.minMonth];
            } else {
              return typeof monthNamesShort === "function" ? monthNamesShort.call(calendar, date2) : monthNamesShort[date2.month() - calendar.minMonth];
            }
          };
          var digits = this.local.digits;
          var localiseNumbers = function(value) {
            return settings.localNumbers && digits ? digits(value) : value;
          };
          var output = "";
          var literal = false;
          for (var iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
              if (format.charAt(iFormat) === "'" && !doubled("'")) {
                literal = false;
              } else {
                output += format.charAt(iFormat);
              }
            } else {
              switch (format.charAt(iFormat)) {
                case "d":
                  output += localiseNumbers(formatNumber("d", date.day(), 2));
                  break;
                case "D":
                  output += formatName(
                    "D",
                    date.dayOfWeek(),
                    dayNamesShort,
                    dayNames
                  );
                  break;
                case "o":
                  output += formatNumber("o", date.dayOfYear(), 3);
                  break;
                case "w":
                  output += formatNumber("w", date.weekOfYear(), 2);
                  break;
                case "m":
                  output += formatMonth(date);
                  break;
                case "M":
                  output += formatMonthName(date, doubled("M"));
                  break;
                case "y":
                  output += doubled("y", 2) ? date.year() : (date.year() % 100 < 10 ? "0" : "") + date.year() % 100;
                  break;
                case "Y":
                  doubled("Y", 2);
                  output += date.formatYear();
                  break;
                case "J":
                  output += date.toJD();
                  break;
                case "@":
                  output += (date.toJD() - this.UNIX_EPOCH) * this.SECS_PER_DAY;
                  break;
                case "!":
                  output += (date.toJD() - this.TICKS_EPOCH) * this.TICKS_PER_DAY;
                  break;
                case "'":
                  if (doubled("'")) {
                    output += "'";
                  } else {
                    literal = true;
                  }
                  break;
                default:
                  output += format.charAt(iFormat);
              }
            }
          }
          return output;
        },
        /** Parse a string value into a date object.
            See <a href="#formatDate"><code>formatDate</code></a> for the possible formats, plus:
            <ul>
            <li>* - ignore rest of string</li>
            </ul>
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar
            @param format {string} The expected format of the date ('' for default calendar format).
            @param value {string} The date in the above format.
            @param [settings] {object} Additional options whose attributes include:
            @property [shortYearCutoff] {number} The cutoff year for determining the century.
            @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
            @property [dayNames] {string[]} Names of the days from Sunday.
            @property [monthNamesShort] {string[]} Abbreviated names of the months.
            @property [monthNames] {string[]} Names of the months.
            @return {CDate} The extracted date value or <code>null</code> if value is blank.
            @throws Errors if the format and/or value are missing,
                    if the value doesn't match the format, or if the date is invalid. */
        parseDate: function(format, value, settings) {
          if (value == null) {
            throw main.local.invalidArguments || main.regionalOptions[""].invalidArguments;
          }
          value = typeof value === "object" ? value.toString() : value + "";
          if (value === "") {
            return null;
          }
          format = format || this.local.dateFormat;
          settings = settings || {};
          var shortYearCutoff = settings.shortYearCutoff || this.shortYearCutoff;
          shortYearCutoff = typeof shortYearCutoff !== "string" ? shortYearCutoff : this.today().year() % 100 + parseInt(shortYearCutoff, 10);
          var dayNamesShort = settings.dayNamesShort || this.local.dayNamesShort;
          var dayNames = settings.dayNames || this.local.dayNames;
          var parseMonth = settings.parseMonth || this.local.parseMonth;
          var monthNumbers = settings.monthNumbers || this.local.monthNumbers;
          var monthNamesShort = settings.monthNamesShort || this.local.monthNamesShort;
          var monthNames = settings.monthNames || this.local.monthNames;
          var jd = -1;
          var year = -1;
          var month = -1;
          var day = -1;
          var doy = -1;
          var shortYear = false;
          var literal = false;
          var doubled = function(match, step) {
            var matches = 1;
            while (iFormat + matches < format.length && format.charAt(iFormat + matches) === match) {
              matches++;
            }
            iFormat += matches - 1;
            return Math.floor(matches / (step || 1)) > 1;
          };
          var getNumber = function(match, step) {
            var isDoubled = doubled(match, step);
            var size = [2, 3, isDoubled ? 4 : 2, isDoubled ? 4 : 2, 10, 11, 20]["oyYJ@!".indexOf(match) + 1];
            var digits = new RegExp("^-?\\d{1," + size + "}");
            var num = value.substring(iValue).match(digits);
            if (!num) {
              throw (main.local.missingNumberAt || main.regionalOptions[""].missingNumberAt).replace(/\{0\}/, iValue);
            }
            iValue += num[0].length;
            return parseInt(num[0], 10);
          };
          var calendar = this;
          var getMonthNumber = function() {
            if (typeof monthNumbers === "function") {
              doubled("m");
              var month2 = monthNumbers.call(calendar, value.substring(iValue));
              iValue += month2.length;
              return month2;
            }
            return getNumber("m");
          };
          var getName = function(match, shortNames, longNames, step) {
            var names2 = doubled(match, step) ? longNames : shortNames;
            for (var i = 0; i < names2.length; i++) {
              if (value.substr(iValue, names2[i].length).toLowerCase() === names2[i].toLowerCase()) {
                iValue += names2[i].length;
                return i + calendar.minMonth;
              }
            }
            throw (main.local.unknownNameAt || main.regionalOptions[""].unknownNameAt).replace(/\{0\}/, iValue);
          };
          var getMonthName = function() {
            if (typeof monthNames === "function") {
              var month2 = doubled("M") ? monthNames.call(calendar, value.substring(iValue)) : monthNamesShort.call(calendar, value.substring(iValue));
              iValue += month2.length;
              return month2;
            }
            return getName("M", monthNamesShort, monthNames);
          };
          var checkLiteral = function() {
            if (value.charAt(iValue) !== format.charAt(iFormat)) {
              throw (main.local.unexpectedLiteralAt || main.regionalOptions[""].unexpectedLiteralAt).replace(/\{0\}/, iValue);
            }
            iValue++;
          };
          var iValue = 0;
          for (var iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
              if (format.charAt(iFormat) === "'" && !doubled("'")) {
                literal = false;
              } else {
                checkLiteral();
              }
            } else {
              switch (format.charAt(iFormat)) {
                case "d":
                  day = getNumber("d");
                  break;
                case "D":
                  getName("D", dayNamesShort, dayNames);
                  break;
                case "o":
                  doy = getNumber("o");
                  break;
                case "w":
                  getNumber("w");
                  break;
                case "m":
                  month = getMonthNumber();
                  break;
                case "M":
                  month = getMonthName();
                  break;
                case "y":
                  var iSave = iFormat;
                  shortYear = !doubled("y", 2);
                  iFormat = iSave;
                  year = getNumber("y", 2);
                  break;
                case "Y":
                  year = getNumber("Y", 2);
                  break;
                case "J":
                  jd = getNumber("J") + 0.5;
                  if (value.charAt(iValue) === ".") {
                    iValue++;
                    getNumber("J");
                  }
                  break;
                case "@":
                  jd = getNumber("@") / this.SECS_PER_DAY + this.UNIX_EPOCH;
                  break;
                case "!":
                  jd = getNumber("!") / this.TICKS_PER_DAY + this.TICKS_EPOCH;
                  break;
                case "*":
                  iValue = value.length;
                  break;
                case "'":
                  if (doubled("'")) {
                    checkLiteral();
                  } else {
                    literal = true;
                  }
                  break;
                default:
                  checkLiteral();
              }
            }
          }
          if (iValue < value.length) {
            throw main.local.unexpectedText || main.regionalOptions[""].unexpectedText;
          }
          if (year === -1) {
            year = this.today().year();
          } else if (year < 100 && shortYear) {
            year += shortYearCutoff === -1 ? 1900 : this.today().year() - this.today().year() % 100 - (year <= shortYearCutoff ? 0 : 100);
          }
          if (typeof month === "string") {
            month = parseMonth.call(this, year, month);
          }
          if (doy > -1) {
            month = 1;
            day = doy;
            for (var dim = this.daysInMonth(year, month); day > dim; dim = this.daysInMonth(year, month)) {
              month++;
              day -= dim;
            }
          }
          return jd > -1 ? this.fromJD(jd) : this.newDate(year, month, day);
        },
        /** A date may be specified as an exact value or a relative one.
            Found in the <code>jquery.calendars.plus.js</code> module.
            @memberof BaseCalendar
            @param dateSpec {CDate|number|string} The date as an object or string in the given format or
                    an offset - numeric days from today, or string amounts and periods, e.g. '+1m +2w'.
            @param defaultDate {CDate} The date to use if no other supplied, may be <code>null</code>.
            @param currentDate {CDate} The current date as a possible basis for relative dates,
                    if <code>null</code> today is used (optional)
            @param [dateFormat] {string} The expected date format - see <a href="#formatDate"><code>formatDate</code></a>.
            @param [settings] {object} Additional options whose attributes include:
            @property [shortYearCutoff] {number} The cutoff year for determining the century.
            @property [dayNamesShort] {string[]} Abbreviated names of the days from Sunday.
            @property [dayNames] {string[]} Names of the days from Sunday.
            @property [monthNamesShort] {string[]} Abbreviated names of the months.
            @property [monthNames] {string[]} Names of the months.
            @return {CDate} The decoded date. */
        determineDate: function(dateSpec, defaultDate, currentDate, dateFormat, settings) {
          if (currentDate && typeof currentDate !== "object") {
            settings = dateFormat;
            dateFormat = currentDate;
            currentDate = null;
          }
          if (typeof dateFormat !== "string") {
            settings = dateFormat;
            dateFormat = "";
          }
          var calendar = this;
          var offsetString = function(offset) {
            try {
              return calendar.parseDate(dateFormat, offset, settings);
            } catch (e) {
            }
            offset = offset.toLowerCase();
            var date = (offset.match(/^c/) && currentDate ? currentDate.newDate() : null) || calendar.today();
            var pattern = /([+-]?[0-9]+)\s*(d|w|m|y)?/g;
            var matches = pattern.exec(offset);
            while (matches) {
              date.add(parseInt(matches[1], 10), matches[2] || "d");
              matches = pattern.exec(offset);
            }
            return date;
          };
          defaultDate = defaultDate ? defaultDate.newDate() : null;
          dateSpec = dateSpec == null ? defaultDate : typeof dateSpec === "string" ? offsetString(dateSpec) : typeof dateSpec === "number" ? isNaN(dateSpec) || dateSpec === Infinity || dateSpec === -Infinity ? defaultDate : calendar.today().add(dateSpec, "d") : calendar.newDate(dateSpec);
          return dateSpec;
        }
      });
    }
  });

  // node_modules/world-calendars/dist/calendars/chinese.js
  var require_chinese = __commonJS({
    "node_modules/world-calendars/dist/calendars/chinese.js"() {
      var main = require_main();
      var assign = require_object_assign();
      var gregorianCalendar = main.instance();
      function ChineseCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      ChineseCalendar.prototype = new main.baseCalendar();
      assign(ChineseCalendar.prototype, {
        /** The calendar name.
            @memberof ChineseCalendar */
        name: "Chinese",
        /** Julian date of start of Gregorian epoch: 1 January 0001 CE.
           @memberof GregorianCalendar */
        jdEpoch: 17214255e-1,
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof ChineseCalendar */
        hasYearZero: false,
        /** The minimum month number.
            This calendar uses month indices to account for intercalary months. 
            @memberof ChineseCalendar */
        minMonth: 0,
        /** The first month in the year.
            This calendar uses month indices to account for intercalary months. 
            @memberof ChineseCalendar */
        firstMonth: 0,
        /** The minimum day number.
            @memberof ChineseCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof ChineseCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Chinese",
            epochs: ["BEC", "EC"],
            monthNumbers: function(date, padded) {
              if (typeof date === "string") {
                var match = date.match(MONTH_NUMBER_REGEXP);
                return match ? match[0] : "";
              }
              var year = this._validateYear(date);
              var monthIndex = date.month();
              var month = "" + this.toChineseMonth(year, monthIndex);
              if (padded && month.length < 2) {
                month = "0" + month;
              }
              if (this.isIntercalaryMonth(year, monthIndex)) {
                month += "i";
              }
              return month;
            },
            monthNames: function(date) {
              if (typeof date === "string") {
                var match = date.match(MONTH_NAME_REGEXP);
                return match ? match[0] : "";
              }
              var year = this._validateYear(date);
              var monthIndex = date.month();
              var month = this.toChineseMonth(year, monthIndex);
              var monthName = [
                "\u4E00\u6708",
                "\u4E8C\u6708",
                "\u4E09\u6708",
                "\u56DB\u6708",
                "\u4E94\u6708",
                "\u516D\u6708",
                "\u4E03\u6708",
                "\u516B\u6708",
                "\u4E5D\u6708",
                "\u5341\u6708",
                "\u5341\u4E00\u6708",
                "\u5341\u4E8C\u6708"
              ][month - 1];
              if (this.isIntercalaryMonth(year, monthIndex)) {
                monthName = "\u95F0" + monthName;
              }
              return monthName;
            },
            monthNamesShort: function(date) {
              if (typeof date === "string") {
                var match = date.match(MONTH_SHORT_NAME_REGEXP);
                return match ? match[0] : "";
              }
              var year = this._validateYear(date);
              var monthIndex = date.month();
              var month = this.toChineseMonth(year, monthIndex);
              var monthName = [
                "\u4E00",
                "\u4E8C",
                "\u4E09",
                "\u56DB",
                "\u4E94",
                "\u516D",
                "\u4E03",
                "\u516B",
                "\u4E5D",
                "\u5341",
                "\u5341\u4E00",
                "\u5341\u4E8C"
              ][month - 1];
              if (this.isIntercalaryMonth(year, monthIndex)) {
                monthName = "\u95F0" + monthName;
              }
              return monthName;
            },
            parseMonth: function(year, monthString) {
              year = this._validateYear(year);
              var month = parseInt(monthString);
              var isIntercalary;
              if (!isNaN(month)) {
                var i = monthString[monthString.length - 1];
                isIntercalary = i === "i" || i === "I";
              } else {
                if (monthString[0] === "\u95F0") {
                  isIntercalary = true;
                  monthString = monthString.substring(1);
                }
                if (monthString[monthString.length - 1] === "\u6708") {
                  monthString = monthString.substring(0, monthString.length - 1);
                }
                month = 1 + [
                  "\u4E00",
                  "\u4E8C",
                  "\u4E09",
                  "\u56DB",
                  "\u4E94",
                  "\u516D",
                  "\u4E03",
                  "\u516B",
                  "\u4E5D",
                  "\u5341",
                  "\u5341\u4E00",
                  "\u5341\u4E8C"
                ].indexOf(monthString);
              }
              var monthIndex = this.toMonthIndex(year, month, isIntercalary);
              return monthIndex;
            },
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 1,
            isRTL: false
          }
        },
        /** Check that a candidate date is from the same calendar and is valid.
            @memberof BaseCalendar
            @private
            @param year {CDate|number} The date or the year to validate.
            @param error {string} Error message if invalid.
            @return {number} The year.
            @throws Error if year out of range. */
        _validateYear: function(year, error) {
          if (year.year) {
            year = year.year();
          }
          if (typeof year !== "number" || year < 1888 || year > 2111) {
            throw error.replace(/\{0\}/, this.local.name);
          }
          return year;
        },
        /** Retrieve the month index (i.e. accounting for intercalary months).
            @memberof ChineseCalendar
            @param year {number} The year.
            @param month {number} The month (1 for first month).
            @param [isIntercalary=false] {boolean} If month is intercalary.
            @return {number} The month index (0 for first month).
            @throws Error if an invalid month/year or a different calendar used. */
        toMonthIndex: function(year, month, isIntercalary) {
          var intercalaryMonth = this.intercalaryMonth(year);
          var invalidIntercalaryMonth = isIntercalary && month !== intercalaryMonth;
          if (invalidIntercalaryMonth || month < 1 || month > 12) {
            throw main.local.invalidMonth.replace(/\{0\}/, this.local.name);
          }
          var monthIndex;
          if (!intercalaryMonth) {
            monthIndex = month - 1;
          } else if (!isIntercalary && month <= intercalaryMonth) {
            monthIndex = month - 1;
          } else {
            monthIndex = month;
          }
          return monthIndex;
        },
        /** Retrieve the month (i.e. accounting for intercalary months).
            @memberof ChineseCalendar
            @param year {CDate|number} The date or the year to examine.
            @param monthIndex {number} The month index (0 for first month).
            @return {number} The month (1 for first month).
            @throws Error if an invalid month/year or a different calendar used. */
        toChineseMonth: function(year, monthIndex) {
          if (year.year) {
            year = year.year();
            monthIndex = year.month();
          }
          var intercalaryMonth = this.intercalaryMonth(year);
          var maxMonthIndex = intercalaryMonth ? 12 : 11;
          if (monthIndex < 0 || monthIndex > maxMonthIndex) {
            throw main.local.invalidMonth.replace(/\{0\}/, this.local.name);
          }
          var month;
          if (!intercalaryMonth) {
            month = monthIndex + 1;
          } else if (monthIndex < intercalaryMonth) {
            month = monthIndex + 1;
          } else {
            month = monthIndex;
          }
          return month;
        },
        /** Determine the intercalary month of a year (if any).
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The intercalary month number, or 0 if none.
            @throws Error if an invalid year or a different calendar used. */
        intercalaryMonth: function(year) {
          year = this._validateYear(year);
          var monthDaysTable = LUNAR_MONTH_DAYS[year - LUNAR_MONTH_DAYS[0]];
          var intercalaryMonth = monthDaysTable >> 13;
          return intercalaryMonth;
        },
        /** Determine whether this date is an intercalary month.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [monthIndex] {number} The month index to examine.
            @return {boolean} <code>true</code> if this is an intercalary month, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        isIntercalaryMonth: function(year, monthIndex) {
          if (year.year) {
            year = year.year();
            monthIndex = year.month();
          }
          var intercalaryMonth = this.intercalaryMonth(year);
          return !!intercalaryMonth && intercalaryMonth === monthIndex;
        },
        /** Determine whether this date is in a leap year.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          return this.intercalaryMonth(year) !== 0;
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [monthIndex] {number} The month index to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, monthIndex, day) {
          var validatedYear = this._validateYear(year, main.local.invalidyear);
          var packedDate = CHINESE_NEW_YEAR[validatedYear - CHINESE_NEW_YEAR[0]];
          var y = packedDate >> 9 & 4095;
          var m = packedDate >> 5 & 15;
          var d = packedDate & 31;
          var firstThursday;
          firstThursday = gregorianCalendar.newDate(y, m, d);
          firstThursday.add(4 - (firstThursday.dayOfWeek() || 7), "d");
          var offset = this.toJD(year, monthIndex, day) - firstThursday.toJD();
          return 1 + Math.floor(offset / 7);
        },
        /** Retrieve the number of months in a year.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          return this.leapYear(year) ? 13 : 12;
        },
        /** Retrieve the number of days in a month.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [monthIndex] {number} The month index.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, monthIndex) {
          if (year.year) {
            monthIndex = year.month();
            year = year.year();
          }
          year = this._validateYear(year);
          var monthDaysTable = LUNAR_MONTH_DAYS[year - LUNAR_MONTH_DAYS[0]];
          var intercalaryMonth = monthDaysTable >> 13;
          var maxMonthIndex = intercalaryMonth ? 12 : 11;
          if (monthIndex > maxMonthIndex) {
            throw main.local.invalidMonth.replace(/\{0\}/, this.local.name);
          }
          var daysInMonth = monthDaysTable & 1 << 12 - monthIndex ? 30 : 29;
          return daysInMonth;
        },
        /** Determine whether this date is a week day.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [monthIndex] {number} The month index to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, monthIndex, day) {
          return (this.dayOfWeek(year, monthIndex, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof ChineseCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [monthIndex] {number} The month index to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, monthIndex, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = this._validateYear(date.year());
          monthIndex = date.month();
          day = date.day();
          var isIntercalary = this.isIntercalaryMonth(year, monthIndex);
          var month = this.toChineseMonth(year, monthIndex);
          var solar = toSolar(year, month, day, isIntercalary);
          return gregorianCalendar.toJD(solar.year, solar.month, solar.day);
        },
        /** Create a new date from a Julian date.
            @memberof ChineseCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var date = gregorianCalendar.fromJD(jd);
          var lunar = toLunar(date.year(), date.month(), date.day());
          var monthIndex = this.toMonthIndex(
            lunar.year,
            lunar.month,
            lunar.isIntercalary
          );
          return this.newDate(lunar.year, monthIndex, lunar.day);
        },
        /** Create a new date from a string.
            @memberof ChineseCalendar
            @param dateString {string} String representing a Chinese date
            @return {CDate} The new date.
            @throws Error if an invalid date. */
        fromString: function(dateString) {
          var match = dateString.match(DATE_REGEXP);
          var year = this._validateYear(+match[1]);
          var month = +match[2];
          var isIntercalary = !!match[3];
          var monthIndex = this.toMonthIndex(year, month, isIntercalary);
          var day = +match[4];
          return this.newDate(year, monthIndex, day);
        },
        /** Add period(s) to a date.
            Cater for no year zero.
            @memberof ChineseCalendar
            @param date {CDate} The starting date.
            @param offset {number} The number of periods to adjust by.
            @param period {string} One of 'y' for year, 'm' for month, 'w' for week, 'd' for day.
            @return {CDate} The updated date.
            @throws Error if a different calendar used. */
        add: function(date, offset, period) {
          var year = date.year();
          var monthIndex = date.month();
          var isIntercalary = this.isIntercalaryMonth(year, monthIndex);
          var month = this.toChineseMonth(year, monthIndex);
          var cdate = Object.getPrototypeOf(ChineseCalendar.prototype).add.call(this, date, offset, period);
          if (period === "y") {
            var resultYear = cdate.year();
            var resultMonthIndex = cdate.month();
            var resultCanBeIntercalaryMonth = this.isIntercalaryMonth(resultYear, month);
            var correctedMonthIndex = isIntercalary && resultCanBeIntercalaryMonth ? this.toMonthIndex(resultYear, month, true) : this.toMonthIndex(resultYear, month, false);
            if (correctedMonthIndex !== resultMonthIndex) {
              cdate.month(correctedMonthIndex);
            }
          }
          return cdate;
        }
      });
      var DATE_REGEXP = /^\s*(-?\d\d\d\d|\d\d)[-/](\d?\d)([iI]?)[-/](\d?\d)/m;
      var MONTH_NUMBER_REGEXP = /^\d?\d[iI]?/m;
      var MONTH_NAME_REGEXP = /^闰?十?[一二三四五六七八九]?月/m;
      var MONTH_SHORT_NAME_REGEXP = /^闰?十?[一二三四五六七八九]?/m;
      main.calendars.chinese = ChineseCalendar;
      var LUNAR_MONTH_DAYS = [
        1887,
        5780,
        5802,
        19157,
        2742,
        50359,
        1198,
        2646,
        46378,
        7466,
        3412,
        30122,
        5482,
        67949,
        2396,
        5294,
        43597,
        6732,
        6954,
        36181,
        2772,
        4954,
        18781,
        2396,
        54427,
        5274,
        6730,
        47781,
        5800,
        6868,
        21210,
        4790,
        59703,
        2350,
        5270,
        46667,
        3402,
        3496,
        38325,
        1388,
        4782,
        18735,
        2350,
        52374,
        6804,
        7498,
        44457,
        2906,
        1388,
        29294,
        4700,
        63789,
        6442,
        6804,
        56138,
        5802,
        2772,
        38235,
        1210,
        4698,
        22827,
        5418,
        63125,
        3476,
        5802,
        43701,
        2484,
        5302,
        27223,
        2646,
        70954,
        7466,
        3412,
        54698,
        5482,
        2412,
        38062,
        5294,
        2636,
        32038,
        6954,
        60245,
        2772,
        4826,
        43357,
        2394,
        5274,
        39501,
        6730,
        72357,
        5800,
        5844,
        53978,
        4790,
        2358,
        38039,
        5270,
        87627,
        3402,
        3496,
        54708,
        5484,
        4782,
        43311,
        2350,
        3222,
        27978,
        7498,
        68965,
        2904,
        5484,
        45677,
        4700,
        6444,
        39573,
        6804,
        6986,
        19285,
        2772,
        62811,
        1210,
        4698,
        47403,
        5418,
        5780,
        38570,
        5546,
        76469,
        2420,
        5302,
        51799,
        2646,
        5414,
        36501,
        3412,
        5546,
        18869,
        2412,
        54446,
        5276,
        6732,
        48422,
        6822,
        2900,
        28010,
        4826,
        92509,
        2394,
        5274,
        55883,
        6730,
        6820,
        47956,
        5812,
        2778,
        18779,
        2358,
        62615,
        5270,
        5450,
        46757,
        3492,
        5556,
        27318,
        4718,
        67887,
        2350,
        3222,
        52554,
        7498,
        3428,
        38252,
        5468,
        4700,
        31022,
        6444,
        64149,
        6804,
        6986,
        43861,
        2772,
        5338,
        35421,
        2650,
        70955,
        5418,
        5780,
        54954,
        5546,
        2740,
        38074,
        5302,
        2646,
        29991,
        3366,
        61011,
        3412,
        5546,
        43445,
        2412,
        5294,
        35406,
        6732,
        72998,
        6820,
        6996,
        52586,
        2778,
        2396,
        38045,
        5274,
        6698,
        23333,
        6820,
        64338,
        5812,
        2746,
        43355,
        2358,
        5270,
        39499,
        5450,
        79525,
        3492,
        5548
      ];
      var CHINESE_NEW_YEAR = [
        1887,
        966732,
        967231,
        967733,
        968265,
        968766,
        969297,
        969798,
        970298,
        970829,
        971330,
        971830,
        972362,
        972863,
        973395,
        973896,
        974397,
        974928,
        975428,
        975929,
        976461,
        976962,
        977462,
        977994,
        978494,
        979026,
        979526,
        980026,
        980558,
        981059,
        981559,
        982091,
        982593,
        983124,
        983624,
        984124,
        984656,
        985157,
        985656,
        986189,
        986690,
        987191,
        987722,
        988222,
        988753,
        989254,
        989754,
        990286,
        990788,
        991288,
        991819,
        992319,
        992851,
        993352,
        993851,
        994383,
        994885,
        995385,
        995917,
        996418,
        996918,
        997450,
        997949,
        998481,
        998982,
        999483,
        1000014,
        1000515,
        1001016,
        1001548,
        1002047,
        1002578,
        1003080,
        1003580,
        1004111,
        1004613,
        1005113,
        1005645,
        1006146,
        1006645,
        1007177,
        1007678,
        1008209,
        1008710,
        1009211,
        1009743,
        1010243,
        1010743,
        1011275,
        1011775,
        1012306,
        1012807,
        1013308,
        1013840,
        1014341,
        1014841,
        1015373,
        1015874,
        1016404,
        1016905,
        1017405,
        1017937,
        1018438,
        1018939,
        1019471,
        1019972,
        1020471,
        1021002,
        1021503,
        1022035,
        1022535,
        1023036,
        1023568,
        1024069,
        1024568,
        1025100,
        1025601,
        1026102,
        1026633,
        1027133,
        1027666,
        1028167,
        1028666,
        1029198,
        1029699,
        1030199,
        1030730,
        1031231,
        1031763,
        1032264,
        1032764,
        1033296,
        1033797,
        1034297,
        1034828,
        1035329,
        1035830,
        1036362,
        1036861,
        1037393,
        1037894,
        1038394,
        1038925,
        1039427,
        1039927,
        1040459,
        1040959,
        1041491,
        1041992,
        1042492,
        1043023,
        1043524,
        1044024,
        1044556,
        1045057,
        1045558,
        1046090,
        1046590,
        1047121,
        1047622,
        1048122,
        1048654,
        1049154,
        1049655,
        1050187,
        1050689,
        1051219,
        1051720,
        1052220,
        1052751,
        1053252,
        1053752,
        1054284,
        1054786,
        1055285,
        1055817,
        1056317,
        1056849,
        1057349,
        1057850,
        1058382,
        1058883,
        1059383,
        1059915,
        1060415,
        1060947,
        1061447,
        1061947,
        1062479,
        1062981,
        1063480,
        1064012,
        1064514,
        1065014,
        1065545,
        1066045,
        1066577,
        1067078,
        1067578,
        1068110,
        1068611,
        1069112,
        1069642,
        1070142,
        1070674,
        1071175,
        1071675,
        1072207,
        1072709,
        1073209,
        1073740,
        1074241,
        1074741,
        1075273,
        1075773,
        1076305,
        1076807,
        1077308,
        1077839,
        1078340,
        1078840,
        1079372,
        1079871,
        1080403,
        1080904
      ];
      function toLunar(yearOrDate, monthOrResult, day, result) {
        var solarDate;
        var lunarDate;
        if (typeof yearOrDate === "object") {
          solarDate = yearOrDate;
          lunarDate = monthOrResult || {};
        } else {
          var isValidYear = typeof yearOrDate === "number" && yearOrDate >= 1888 && yearOrDate <= 2111;
          if (!isValidYear)
            throw new Error("Solar year outside range 1888-2111");
          var isValidMonth = typeof monthOrResult === "number" && monthOrResult >= 1 && monthOrResult <= 12;
          if (!isValidMonth)
            throw new Error("Solar month outside range 1 - 12");
          var isValidDay = typeof day === "number" && day >= 1 && day <= 31;
          if (!isValidDay)
            throw new Error("Solar day outside range 1 - 31");
          solarDate = {
            year: yearOrDate,
            month: monthOrResult,
            day
          };
          lunarDate = result || {};
        }
        var chineseNewYearPackedDate = CHINESE_NEW_YEAR[solarDate.year - CHINESE_NEW_YEAR[0]];
        var packedDate = solarDate.year << 9 | solarDate.month << 5 | solarDate.day;
        lunarDate.year = packedDate >= chineseNewYearPackedDate ? solarDate.year : solarDate.year - 1;
        chineseNewYearPackedDate = CHINESE_NEW_YEAR[lunarDate.year - CHINESE_NEW_YEAR[0]];
        var y = chineseNewYearPackedDate >> 9 & 4095;
        var m = chineseNewYearPackedDate >> 5 & 15;
        var d = chineseNewYearPackedDate & 31;
        var daysFromNewYear;
        var chineseNewYearJSDate = new Date(y, m - 1, d);
        var jsDate = new Date(solarDate.year, solarDate.month - 1, solarDate.day);
        daysFromNewYear = Math.round(
          (jsDate - chineseNewYearJSDate) / (24 * 3600 * 1e3)
        );
        var monthDaysTable = LUNAR_MONTH_DAYS[lunarDate.year - LUNAR_MONTH_DAYS[0]];
        var i;
        for (i = 0; i < 13; i++) {
          var daysInMonth = monthDaysTable & 1 << 12 - i ? 30 : 29;
          if (daysFromNewYear < daysInMonth) {
            break;
          }
          daysFromNewYear -= daysInMonth;
        }
        var intercalaryMonth = monthDaysTable >> 13;
        if (!intercalaryMonth || i < intercalaryMonth) {
          lunarDate.isIntercalary = false;
          lunarDate.month = 1 + i;
        } else if (i === intercalaryMonth) {
          lunarDate.isIntercalary = true;
          lunarDate.month = i;
        } else {
          lunarDate.isIntercalary = false;
          lunarDate.month = i;
        }
        lunarDate.day = 1 + daysFromNewYear;
        return lunarDate;
      }
      function toSolar(yearOrDate, monthOrResult, day, isIntercalaryOrResult, result) {
        var solarDate;
        var lunarDate;
        if (typeof yearOrDate === "object") {
          lunarDate = yearOrDate;
          solarDate = monthOrResult || {};
        } else {
          var isValidYear = typeof yearOrDate === "number" && yearOrDate >= 1888 && yearOrDate <= 2111;
          if (!isValidYear)
            throw new Error("Lunar year outside range 1888-2111");
          var isValidMonth = typeof monthOrResult === "number" && monthOrResult >= 1 && monthOrResult <= 12;
          if (!isValidMonth)
            throw new Error("Lunar month outside range 1 - 12");
          var isValidDay = typeof day === "number" && day >= 1 && day <= 30;
          if (!isValidDay)
            throw new Error("Lunar day outside range 1 - 30");
          var isIntercalary;
          if (typeof isIntercalaryOrResult === "object") {
            isIntercalary = false;
            solarDate = isIntercalaryOrResult;
          } else {
            isIntercalary = !!isIntercalaryOrResult;
            solarDate = result || {};
          }
          lunarDate = {
            year: yearOrDate,
            month: monthOrResult,
            day,
            isIntercalary
          };
        }
        var daysFromNewYear;
        daysFromNewYear = lunarDate.day - 1;
        var monthDaysTable = LUNAR_MONTH_DAYS[lunarDate.year - LUNAR_MONTH_DAYS[0]];
        var intercalaryMonth = monthDaysTable >> 13;
        var monthsFromNewYear;
        if (!intercalaryMonth) {
          monthsFromNewYear = lunarDate.month - 1;
        } else if (lunarDate.month > intercalaryMonth) {
          monthsFromNewYear = lunarDate.month;
        } else if (lunarDate.isIntercalary) {
          monthsFromNewYear = lunarDate.month;
        } else {
          monthsFromNewYear = lunarDate.month - 1;
        }
        for (var i = 0; i < monthsFromNewYear; i++) {
          var daysInMonth = monthDaysTable & 1 << 12 - i ? 30 : 29;
          daysFromNewYear += daysInMonth;
        }
        var packedDate = CHINESE_NEW_YEAR[lunarDate.year - CHINESE_NEW_YEAR[0]];
        var y = packedDate >> 9 & 4095;
        var m = packedDate >> 5 & 15;
        var d = packedDate & 31;
        var jsDate = new Date(y, m - 1, d + daysFromNewYear);
        solarDate.year = jsDate.getFullYear();
        solarDate.month = 1 + jsDate.getMonth();
        solarDate.day = jsDate.getDate();
        return solarDate;
      }
    }
  });

  // node_modules/world-calendars/dist/calendars/coptic.js
  var require_coptic = __commonJS({
    "node_modules/world-calendars/dist/calendars/coptic.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function CopticCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      CopticCalendar.prototype = new main.baseCalendar();
      assign(CopticCalendar.prototype, {
        /** The calendar name.
            @memberof CopticCalendar */
        name: "Coptic",
        /** Julian date of start of Coptic epoch: 29 August 284 CE (Gregorian).
            @memberof CopticCalendar */
        jdEpoch: 18250295e-1,
        /** Days per month in a common year.
            @memberof CopticCalendar */
        daysPerMonth: [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 5],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof CopticCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof CopticCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof CopticCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof CopticCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof CopticCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Coptic",
            epochs: ["BAM", "AM"],
            monthNames: [
              "Thout",
              "Paopi",
              "Hathor",
              "Koiak",
              "Tobi",
              "Meshir",
              "Paremhat",
              "Paremoude",
              "Pashons",
              "Paoni",
              "Epip",
              "Mesori",
              "Pi Kogi Enavot"
            ],
            monthNamesShort: [
              "Tho",
              "Pao",
              "Hath",
              "Koi",
              "Tob",
              "Mesh",
              "Pat",
              "Pad",
              "Pash",
              "Pao",
              "Epi",
              "Meso",
              "PiK"
            ],
            dayNames: ["Tkyriaka", "Pesnau", "Pshoment", "Peftoou", "Ptiou", "Psoou", "Psabbaton"],
            dayNamesShort: ["Tky", "Pes", "Psh", "Pef", "Pti", "Pso", "Psa"],
            dayNamesMin: ["Tk", "Pes", "Psh", "Pef", "Pt", "Pso", "Psa"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = date.year() + (date.year() < 0 ? 1 : 0);
          return year % 4 === 3 || year % 4 === -1;
        },
        /** Retrieve the number of months in a year.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(
            year,
            this.minMonth,
            this.minDay,
            main.local.invalidYear || main.regionalOptions[""].invalidYear
          );
          return 13;
        },
        /** Determine the week of the year for a date.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number) the month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 13 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof CopticCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param month {number} The month to examine.
            @param day {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof CopticCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number) the month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          if (year < 0) {
            year++;
          }
          return date.day() + (date.month() - 1) * 30 + (year - 1) * 365 + Math.floor(year / 4) + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof CopticCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var c = Math.floor(jd) + 0.5 - this.jdEpoch;
          var year = Math.floor((c - Math.floor((c + 366) / 1461)) / 365) + 1;
          if (year <= 0) {
            year--;
          }
          c = Math.floor(jd) + 0.5 - this.newDate(year, 1, 1).toJD();
          var month = Math.floor(c / 30) + 1;
          var day = c - (month - 1) * 30 + 1;
          return this.newDate(year, month, day);
        }
      });
      main.calendars.coptic = CopticCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/discworld.js
  var require_discworld = __commonJS({
    "node_modules/world-calendars/dist/calendars/discworld.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function DiscworldCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      DiscworldCalendar.prototype = new main.baseCalendar();
      assign(DiscworldCalendar.prototype, {
        /** The calendar name.
            @memberof DiscworldCalendar */
        name: "Discworld",
        /** Julian date of start of Discworld epoch: 1 January 0001 CE.
            @memberof DiscworldCalendar */
        jdEpoch: 17214255e-1,
        /** Days per month in a common year.
            @memberof DiscworldCalendar */
        daysPerMonth: [16, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof DiscworldCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof DiscworldCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof DiscworldCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof DiscworldCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof DiscworldCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Discworld",
            epochs: ["BUC", "UC"],
            monthNames: [
              "Ick",
              "Offle",
              "February",
              "March",
              "April",
              "May",
              "June",
              "Grune",
              "August",
              "Spune",
              "Sektober",
              "Ember",
              "December"
            ],
            monthNamesShort: ["Ick", "Off", "Feb", "Mar", "Apr", "May", "Jun", "Gru", "Aug", "Spu", "Sek", "Emb", "Dec"],
            dayNames: ["Sunday", "Octeday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Oct", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Oc", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 2,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return false;
        },
        /** Retrieve the number of months in a year.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 13;
        },
        /** Retrieve the number of days in a year.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 400;
        },
        /** Determine the week of the year for a date.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 8) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1];
        },
        /** Retrieve the number of days in a week.
            @memberof DiscworldCalendar
            @return {number} The number of days. */
        daysInWeek: function() {
          return 8;
        },
        /** Retrieve the day of the week for a date.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The day of the week: 0 to number of days - 1.
            @throws Error if an invalid date or a different calendar used. */
        dayOfWeek: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return (date.day() + 1) % 8;
        },
        /** Determine whether this date is a week day.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          var dow = this.dayOfWeek(year, month, day);
          return dow >= 2 && dow <= 6;
        },
        /** Retrieve additional information about a date.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return { century: centuries[Math.floor((date.year() - 1) / 100) + 1] || "" };
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof DiscworldCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year() + (date.year() < 0 ? 1 : 0);
          month = date.month();
          day = date.day();
          return day + (month > 1 ? 16 : 0) + (month > 2 ? (month - 2) * 32 : 0) + (year - 1) * 400 + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof DiscworldCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd + 0.5) - Math.floor(this.jdEpoch) - 1;
          var year = Math.floor(jd / 400) + 1;
          jd -= (year - 1) * 400;
          jd += jd > 15 ? 16 : 0;
          var month = Math.floor(jd / 32) + 1;
          var day = jd - (month - 1) * 32 + 1;
          return this.newDate(year <= 0 ? year - 1 : year, month, day);
        }
      });
      var centuries = {
        20: "Fruitbat",
        21: "Anchovy"
      };
      main.calendars.discworld = DiscworldCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/ethiopian.js
  var require_ethiopian = __commonJS({
    "node_modules/world-calendars/dist/calendars/ethiopian.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function EthiopianCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      EthiopianCalendar.prototype = new main.baseCalendar();
      assign(EthiopianCalendar.prototype, {
        /** The calendar name.
            @memberof EthiopianCalendar */
        name: "Ethiopian",
        /** Julian date of start of Ethiopian epoch: 27 August 8 CE (Gregorian).
            @memberof EthiopianCalendar */
        jdEpoch: 17242205e-1,
        /** Days per month in a common year.
            @memberof EthiopianCalendar */
        daysPerMonth: [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 5],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof EthiopianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof EthiopianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof EthiopianCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof EthiopianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof EthiopianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Ethiopian",
            epochs: ["BEE", "EE"],
            monthNames: [
              "Meskerem",
              "Tikemet",
              "Hidar",
              "Tahesas",
              "Tir",
              "Yekatit",
              "Megabit",
              "Miazia",
              "Genbot",
              "Sene",
              "Hamle",
              "Nehase",
              "Pagume"
            ],
            monthNamesShort: [
              "Mes",
              "Tik",
              "Hid",
              "Tah",
              "Tir",
              "Yek",
              "Meg",
              "Mia",
              "Gen",
              "Sen",
              "Ham",
              "Neh",
              "Pag"
            ],
            dayNames: ["Ehud", "Segno", "Maksegno", "Irob", "Hamus", "Arb", "Kidame"],
            dayNamesShort: ["Ehu", "Seg", "Mak", "Iro", "Ham", "Arb", "Kid"],
            dayNamesMin: ["Eh", "Se", "Ma", "Ir", "Ha", "Ar", "Ki"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = date.year() + (date.year() < 0 ? 1 : 0);
          return year % 4 === 3 || year % 4 === -1;
        },
        /** Retrieve the number of months in a year.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(
            year,
            this.minMonth,
            this.minDay,
            main.local.invalidYear || main.regionalOptions[""].invalidYear
          );
          return 13;
        },
        /** Determine the week of the year for a date.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 13 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof EthiopianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          if (year < 0) {
            year++;
          }
          return date.day() + (date.month() - 1) * 30 + (year - 1) * 365 + Math.floor(year / 4) + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof EthiopianCalendar
            @param jd {number} the Julian date to convert.
            @return {CDate} the equivalent date. */
        fromJD: function(jd) {
          var c = Math.floor(jd) + 0.5 - this.jdEpoch;
          var year = Math.floor((c - Math.floor((c + 366) / 1461)) / 365) + 1;
          if (year <= 0) {
            year--;
          }
          c = Math.floor(jd) + 0.5 - this.newDate(year, 1, 1).toJD();
          var month = Math.floor(c / 30) + 1;
          var day = c - (month - 1) * 30 + 1;
          return this.newDate(year, month, day);
        }
      });
      main.calendars.ethiopian = EthiopianCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/hebrew.js
  var require_hebrew = __commonJS({
    "node_modules/world-calendars/dist/calendars/hebrew.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function HebrewCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      HebrewCalendar.prototype = new main.baseCalendar();
      assign(HebrewCalendar.prototype, {
        /** The calendar name.
            @memberof HebrewCalendar */
        name: "Hebrew",
        /** Julian date of start of Hebrew epoch: 7 October 3761 BCE.
            @memberof HebrewCalendar */
        jdEpoch: 347995.5,
        /** Days per month in a common year.
            @memberof HebrewCalendar */
        daysPerMonth: [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 29],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof HebrewCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof HebrewCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof HebrewCalendar */
        firstMonth: 7,
        /** The minimum day number.
            @memberof HebrewCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof HebrewCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Hebrew",
            epochs: ["BAM", "AM"],
            monthNames: [
              "Nisan",
              "Iyar",
              "Sivan",
              "Tammuz",
              "Av",
              "Elul",
              "Tishrei",
              "Cheshvan",
              "Kislev",
              "Tevet",
              "Shevat",
              "Adar",
              "Adar II"
            ],
            monthNamesShort: ["Nis", "Iya", "Siv", "Tam", "Av", "Elu", "Tis", "Che", "Kis", "Tev", "She", "Ada", "Ad2"],
            dayNames: ["Yom Rishon", "Yom Sheni", "Yom Shlishi", "Yom Revi'i", "Yom Chamishi", "Yom Shishi", "Yom Shabbat"],
            dayNamesShort: ["Ris", "She", "Shl", "Rev", "Cha", "Shi", "Sha"],
            dayNamesMin: ["Ri", "She", "Shl", "Re", "Ch", "Shi", "Sha"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return this._leapYear(date.year());
        },
        /** Determine whether this date is in a leap year.
            @memberof HebrewCalendar
            @private
            @param year {number} The year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        _leapYear: function(year) {
          year = year < 0 ? year + 1 : year;
          return mod(year * 7 + 1, 19) < 7;
        },
        /** Retrieve the number of months in a year.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return this._leapYear(year.year ? year.year() : year) ? 13 : 12;
        },
        /** Determine the week of the year for a date.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          year = date.year();
          return this.toJD(year === -1 ? 1 : year + 1, 7, 1) - this.toJD(year, 7, 1);
        },
        /** Retrieve the number of days in a month.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          if (year.year) {
            month = year.month();
            year = year.year();
          }
          this._validate(year, month, this.minDay, main.local.invalidMonth);
          return month === 12 && this.leapYear(year) ? 30 : (
            // Adar I
            month === 8 && mod(this.daysInYear(year), 10) === 5 ? 30 : (
              // Cheshvan in shlemah year
              month === 9 && mod(this.daysInYear(year), 10) === 3 ? 29 : (
                // Kislev in chaserah year
                this.daysPerMonth[month - 1]
              )
            )
          );
        },
        /** Determine whether this date is a week day.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 6;
        },
        /** Retrieve additional information about a date - year type.
            @memberof HebrewCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return { yearType: (this.leapYear(date) ? "embolismic" : "common") + " " + ["deficient", "regular", "complete"][this.daysInYear(date) % 10 - 3] };
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof HebrewCalendar
            @param year {CDate)|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          var adjYear = year <= 0 ? year + 1 : year;
          var jd = this.jdEpoch + this._delay1(adjYear) + this._delay2(adjYear) + day + 1;
          if (month < 7) {
            for (var m = 7; m <= this.monthsInYear(year); m++) {
              jd += this.daysInMonth(year, m);
            }
            for (var m = 1; m < month; m++) {
              jd += this.daysInMonth(year, m);
            }
          } else {
            for (var m = 7; m < month; m++) {
              jd += this.daysInMonth(year, m);
            }
          }
          return jd;
        },
        /** Test for delay of start of new year and to avoid
            Sunday, Wednesday, or Friday as start of the new year.
            @memberof HebrewCalendar
            @private
            @param year {number} The year to examine.
            @return {number} The days to offset by. */
        _delay1: function(year) {
          var months = Math.floor((235 * year - 234) / 19);
          var parts = 12084 + 13753 * months;
          var day = months * 29 + Math.floor(parts / 25920);
          if (mod(3 * (day + 1), 7) < 3) {
            day++;
          }
          return day;
        },
        /** Check for delay in start of new year due to length of adjacent years.
            @memberof HebrewCalendar
            @private
            @param year {number} The year to examine.
            @return {number} The days to offset by. */
        _delay2: function(year) {
          var last = this._delay1(year - 1);
          var present = this._delay1(year);
          var next = this._delay1(year + 1);
          return next - present === 356 ? 2 : present - last === 382 ? 1 : 0;
        },
        /** Create a new date from a Julian date.
            @memberof HebrewCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5;
          var year = Math.floor((jd - this.jdEpoch) * 98496 / 35975351) - 1;
          while (jd >= this.toJD(year === -1 ? 1 : year + 1, 7, 1)) {
            year++;
          }
          var month = jd < this.toJD(year, 1, 1) ? 7 : 1;
          while (jd > this.toJD(year, month, this.daysInMonth(year, month))) {
            month++;
          }
          var day = jd - this.toJD(year, month, 1) + 1;
          return this.newDate(year, month, day);
        }
      });
      function mod(a, b) {
        return a - b * Math.floor(a / b);
      }
      main.calendars.hebrew = HebrewCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/islamic.js
  var require_islamic = __commonJS({
    "node_modules/world-calendars/dist/calendars/islamic.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function IslamicCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      IslamicCalendar.prototype = new main.baseCalendar();
      assign(IslamicCalendar.prototype, {
        /** The calendar name.
            @memberof IslamicCalendar */
        name: "Islamic",
        /** Julian date of start of Islamic epoch: 16 July 622 CE.
            @memberof IslamicCalendar */
        jdEpoch: 19484395e-1,
        /** Days per month in a common year.
            @memberof IslamicCalendar */
        daysPerMonth: [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof IslamicCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof IslamicCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof IslamicCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof IslamicCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof IslamicCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Islamic",
            epochs: ["BH", "AH"],
            monthNames: [
              "Muharram",
              "Safar",
              "Rabi' al-awwal",
              "Rabi' al-thani",
              "Jumada al-awwal",
              "Jumada al-thani",
              "Rajab",
              "Sha'aban",
              "Ramadan",
              "Shawwal",
              "Dhu al-Qi'dah",
              "Dhu al-Hijjah"
            ],
            monthNamesShort: ["Muh", "Saf", "Rab1", "Rab2", "Jum1", "Jum2", "Raj", "Sha'", "Ram", "Shaw", "DhuQ", "DhuH"],
            dayNames: [
              "Yawm al-ahad",
              "Yawm al-ithnayn",
              "Yawm ath-thulaathaa'",
              "Yawm al-arbi'aa'",
              "Yawm al-kham\u012Bs",
              "Yawm al-jum'a",
              "Yawm as-sabt"
            ],
            dayNamesShort: ["Aha", "Ith", "Thu", "Arb", "Kha", "Jum", "Sab"],
            dayNamesMin: ["Ah", "It", "Th", "Ar", "Kh", "Ju", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 6,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return (date.year() * 11 + 14) % 30 < 11;
        },
        /** Determine the week of the year for a date.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          return this.leapYear(year) ? 355 : 354;
        },
        /** Retrieve the number of days in a month.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 5;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof IslamicCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          year = year <= 0 ? year + 1 : year;
          return day + Math.ceil(29.5 * (month - 1)) + (year - 1) * 354 + Math.floor((3 + 11 * year) / 30) + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof IslamicCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5;
          var year = Math.floor((30 * (jd - this.jdEpoch) + 10646) / 10631);
          year = year <= 0 ? year - 1 : year;
          var month = Math.min(12, Math.ceil((jd - 29 - this.toJD(year, 1, 1)) / 29.5) + 1);
          var day = jd - this.toJD(year, month, 1) + 1;
          return this.newDate(year, month, day);
        }
      });
      main.calendars.islamic = IslamicCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/julian.js
  var require_julian = __commonJS({
    "node_modules/world-calendars/dist/calendars/julian.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function JulianCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      JulianCalendar.prototype = new main.baseCalendar();
      assign(JulianCalendar.prototype, {
        /** The calendar name.
            @memberof JulianCalendar */
        name: "Julian",
        /** Julian date of start of Julian epoch: 1 January 0001 AD = 30 December 0001 BCE.
            @memberof JulianCalendar */
        jdEpoch: 17214235e-1,
        /** Days per month in a common year.
            @memberof JulianCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof JulianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof JulianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof JulianCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof JulianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof JulianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Julian",
            epochs: ["BC", "AD"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "mm/dd/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = date.year() < 0 ? date.year() + 1 : date.year();
          return year % 4 === 0;
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(4 - (checkDate.dayOfWeek() || 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof JulianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} True if a week day, false if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof JulianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          if (year < 0) {
            year++;
          }
          if (month <= 2) {
            year--;
            month += 12;
          }
          return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day - 1524.5;
        },
        /** Create a new date from a Julian date.
            @memberof JulianCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var a = Math.floor(jd + 0.5);
          var b = a + 1524;
          var c = Math.floor((b - 122.1) / 365.25);
          var d = Math.floor(365.25 * c);
          var e = Math.floor((b - d) / 30.6001);
          var month = e - Math.floor(e < 14 ? 1 : 13);
          var year = c - Math.floor(month > 2 ? 4716 : 4715);
          var day = b - d - Math.floor(30.6001 * e);
          if (year <= 0) {
            year--;
          }
          return this.newDate(year, month, day);
        }
      });
      main.calendars.julian = JulianCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/mayan.js
  var require_mayan = __commonJS({
    "node_modules/world-calendars/dist/calendars/mayan.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function MayanCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      MayanCalendar.prototype = new main.baseCalendar();
      assign(MayanCalendar.prototype, {
        /** The calendar name.
            @memberof MayanCalendar */
        name: "Mayan",
        /** Julian date of start of Mayan epoch: 11 August 3114 BCE.
            @memberof MayanCalendar */
        jdEpoch: 584282.5,
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof MayanCalendar */
        hasYearZero: true,
        /** The minimum month number.
            @memberof MayanCalendar */
        minMonth: 0,
        /** The first month in the year.
            @memberof MayanCalendar */
        firstMonth: 0,
        /** The minimum day number.
            @memberof MayanCalendar */
        minDay: 0,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof MayanCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left.
            @property haabMonths {string[]} The names of the Haab months.
            @property tzolkinMonths {string[]} The names of the Tzolkin months. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Mayan",
            epochs: ["", ""],
            monthNames: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17"
            ],
            monthNamesShort: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17"
            ],
            dayNames: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17",
              "18",
              "19"
            ],
            dayNamesShort: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17",
              "18",
              "19"
            ],
            dayNamesMin: [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "10",
              "11",
              "12",
              "13",
              "14",
              "15",
              "16",
              "17",
              "18",
              "19"
            ],
            digits: null,
            dateFormat: "YYYY.m.d",
            firstDay: 0,
            isRTL: false,
            haabMonths: [
              "Pop",
              "Uo",
              "Zip",
              "Zotz",
              "Tzec",
              "Xul",
              "Yaxkin",
              "Mol",
              "Chen",
              "Yax",
              "Zac",
              "Ceh",
              "Mac",
              "Kankin",
              "Muan",
              "Pax",
              "Kayab",
              "Cumku",
              "Uayeb"
            ],
            tzolkinMonths: [
              "Imix",
              "Ik",
              "Akbal",
              "Kan",
              "Chicchan",
              "Cimi",
              "Manik",
              "Lamat",
              "Muluc",
              "Oc",
              "Chuen",
              "Eb",
              "Ben",
              "Ix",
              "Men",
              "Cib",
              "Caban",
              "Etznab",
              "Cauac",
              "Ahau"
            ]
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return false;
        },
        /** Format the year, if not a simple sequential number.
            @memberof MayanCalendar
            @param year {CDate|number} The date to format or the year to format.
            @return {string} The formatted year.
            @throws Error if an invalid year or a different calendar used. */
        formatYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          year = date.year();
          var baktun = Math.floor(year / 400);
          year = year % 400;
          year += year < 0 ? 400 : 0;
          var katun = Math.floor(year / 20);
          return baktun + "." + katun + "." + year % 20;
        },
        /** Convert from the formatted year back to a single number.
            @memberof MayanCalendar
            @param years {string} The year as n.n.n.
            @return {number} The sequential year.
            @throws Error if an invalid value is supplied. */
        forYear: function(years) {
          years = years.split(".");
          if (years.length < 3) {
            throw "Invalid Mayan year";
          }
          var year = 0;
          for (var i = 0; i < years.length; i++) {
            var y = parseInt(years[i], 10);
            if (Math.abs(y) > 19 || i > 0 && y < 0) {
              throw "Invalid Mayan year";
            }
            year = year * 20 + y;
          }
          return year;
        },
        /** Retrieve the number of months in a year.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of months.
            @throws Error if an invalid year or a different calendar used. */
        monthsInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 18;
        },
        /** Determine the week of the year for a date.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          this._validate(year, month, day, main.local.invalidDate);
          return 0;
        },
        /** Retrieve the number of days in a year.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return 360;
        },
        /** Retrieve the number of days in a month.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          this._validate(year, month, this.minDay, main.local.invalidMonth);
          return 20;
        },
        /** Retrieve the number of days in a week.
            @memberof MayanCalendar
            @return {number} The number of days. */
        daysInWeek: function() {
          return 5;
        },
        /** Retrieve the day of the week for a date.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The day of the week: 0 to number of days - 1.
            @throws Error if an invalid date or a different calendar used. */
        dayOfWeek: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return date.day();
        },
        /** Determine whether this date is a week day.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          this._validate(year, month, day, main.local.invalidDate);
          return true;
        },
        /** Retrieve additional information about a date - Haab and Tzolkin equivalents.
            @memberof MayanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {object} Additional information - contents depends on calendar.
            @throws Error if an invalid date or a different calendar used. */
        extraInfo: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var jd = date.toJD();
          var haab = this._toHaab(jd);
          var tzolkin = this._toTzolkin(jd);
          return {
            haabMonthName: this.local.haabMonths[haab[0] - 1],
            haabMonth: haab[0],
            haabDay: haab[1],
            tzolkinDayName: this.local.tzolkinMonths[tzolkin[0] - 1],
            tzolkinDay: tzolkin[0],
            tzolkinTrecena: tzolkin[1]
          };
        },
        /** Retrieve Haab date from a Julian date.
            @memberof MayanCalendar
            @private
            @param jd  {number} The Julian date.
            @return {number[]} Corresponding Haab month and day. */
        _toHaab: function(jd) {
          jd -= this.jdEpoch;
          var day = mod(jd + 8 + (18 - 1) * 20, 365);
          return [Math.floor(day / 20) + 1, mod(day, 20)];
        },
        /** Retrieve Tzolkin date from a Julian date.
            @memberof MayanCalendar
            @private
            @param jd {number} The Julian date.
            @return {number[]} Corresponding Tzolkin day and trecena. */
        _toTzolkin: function(jd) {
          jd -= this.jdEpoch;
          return [amod(jd + 20, 20), amod(jd + 4, 13)];
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof MayanCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          return date.day() + date.month() * 20 + date.year() * 360 + this.jdEpoch;
        },
        /** Create a new date from a Julian date.
            @memberof MayanCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5 - this.jdEpoch;
          var year = Math.floor(jd / 360);
          jd = jd % 360;
          jd += jd < 0 ? 360 : 0;
          var month = Math.floor(jd / 20);
          var day = jd % 20;
          return this.newDate(year, month, day);
        }
      });
      function mod(a, b) {
        return a - b * Math.floor(a / b);
      }
      function amod(a, b) {
        return mod(a - 1, b) + 1;
      }
      main.calendars.mayan = MayanCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/nanakshahi.js
  var require_nanakshahi = __commonJS({
    "node_modules/world-calendars/dist/calendars/nanakshahi.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function NanakshahiCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      NanakshahiCalendar.prototype = new main.baseCalendar();
      var gregorian = main.instance("gregorian");
      assign(NanakshahiCalendar.prototype, {
        /** The calendar name.
            @memberof NanakshahiCalendar */
        name: "Nanakshahi",
        /** Julian date of start of Nanakshahi epoch: 14 March 1469 CE.
            @memberof NanakshahiCalendar */
        jdEpoch: 22576735e-1,
        /** Days per month in a common year.
            @memberof NanakshahiCalendar */
        daysPerMonth: [31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 30, 30],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof NanakshahiCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof NanakshahiCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof NanakshahiCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof NanakshahiCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof NanakshahiCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Nanakshahi",
            epochs: ["BN", "AN"],
            monthNames: [
              "Chet",
              "Vaisakh",
              "Jeth",
              "Harh",
              "Sawan",
              "Bhadon",
              "Assu",
              "Katak",
              "Maghar",
              "Poh",
              "Magh",
              "Phagun"
            ],
            monthNamesShort: ["Che", "Vai", "Jet", "Har", "Saw", "Bha", "Ass", "Kat", "Mgr", "Poh", "Mgh", "Pha"],
            dayNames: ["Somvaar", "Mangalvar", "Budhvaar", "Veervaar", "Shukarvaar", "Sanicharvaar", "Etvaar"],
            dayNamesShort: ["Som", "Mangal", "Budh", "Veer", "Shukar", "Sanichar", "Et"],
            dayNamesMin: ["So", "Ma", "Bu", "Ve", "Sh", "Sa", "Et"],
            digits: null,
            dateFormat: "dd-mm-yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(
            year,
            this.minMonth,
            this.minDay,
            main.local.invalidYear || main.regionalOptions[""].invalidYear
          );
          return gregorian.leapYear(date.year() + (date.year() < 1 ? 1 : 0) + 1469);
        },
        /** Determine the week of the year for a date.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(1 - (checkDate.dayOfWeek() || 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof NanakshahiCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidMonth);
          var year = date.year();
          if (year < 0) {
            year++;
          }
          var doy = date.day();
          for (var m = 1; m < date.month(); m++) {
            doy += this.daysPerMonth[m - 1];
          }
          return doy + gregorian.toJD(year + 1468, 3, 13);
        },
        /** Create a new date from a Julian date.
            @memberof NanakshahiCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd + 0.5);
          var year = Math.floor((jd - (this.jdEpoch - 1)) / 366);
          while (jd >= this.toJD(year + 1, 1, 1)) {
            year++;
          }
          var day = jd - Math.floor(this.toJD(year, 1, 1) + 0.5) + 1;
          var month = 1;
          while (day > this.daysInMonth(year, month)) {
            day -= this.daysInMonth(year, month);
            month++;
          }
          return this.newDate(year, month, day);
        }
      });
      main.calendars.nanakshahi = NanakshahiCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/nepali.js
  var require_nepali = __commonJS({
    "node_modules/world-calendars/dist/calendars/nepali.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function NepaliCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      NepaliCalendar.prototype = new main.baseCalendar();
      assign(NepaliCalendar.prototype, {
        /** The calendar name.
            @memberof NepaliCalendar */
        name: "Nepali",
        /** Julian date of start of Nepali epoch: 14 April 57 BCE.
            @memberof NepaliCalendar */
        jdEpoch: 17007095e-1,
        /** Days per month in a common year.
            @memberof NepaliCalendar */
        daysPerMonth: [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof NepaliCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof NepaliCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof NepaliCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof NepaliCalendar */
        minDay: 1,
        /** The number of days in the year.
            @memberof NepaliCalendar */
        daysPerYear: 365,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof NepaliCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Nepali",
            epochs: ["BBS", "ABS"],
            monthNames: [
              "Baisakh",
              "Jestha",
              "Ashadh",
              "Shrawan",
              "Bhadra",
              "Ashwin",
              "Kartik",
              "Mangsir",
              "Paush",
              "Mangh",
              "Falgun",
              "Chaitra"
            ],
            monthNamesShort: ["Bai", "Je", "As", "Shra", "Bha", "Ash", "Kar", "Mang", "Pau", "Ma", "Fal", "Chai"],
            dayNames: ["Aaitabaar", "Sombaar", "Manglbaar", "Budhabaar", "Bihibaar", "Shukrabaar", "Shanibaar"],
            dayNamesShort: ["Aaita", "Som", "Mangl", "Budha", "Bihi", "Shukra", "Shani"],
            dayNamesMin: ["Aai", "So", "Man", "Bu", "Bi", "Shu", "Sha"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 1,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          return this.daysInYear(year) !== this.daysPerYear;
        },
        /** Determine the week of the year for a date.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          year = date.year();
          if (typeof this.NEPALI_CALENDAR_DATA[year] === "undefined") {
            return this.daysPerYear;
          }
          var daysPerYear = 0;
          for (var month_number = this.minMonth; month_number <= 12; month_number++) {
            daysPerYear += this.NEPALI_CALENDAR_DATA[year][month_number];
          }
          return daysPerYear;
        },
        /** Retrieve the number of days in a month.
            @memberof NepaliCalendar
            @param year {CDate|number| The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          if (year.year) {
            month = year.month();
            year = year.year();
          }
          this._validate(year, month, this.minDay, main.local.invalidMonth);
          return typeof this.NEPALI_CALENDAR_DATA[year] === "undefined" ? this.daysPerMonth[month - 1] : this.NEPALI_CALENDAR_DATA[year][month];
        },
        /** Determine whether this date is a week day.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof NepaliCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(nepaliYear, nepaliMonth, nepaliDay) {
          var date = this._validate(nepaliYear, nepaliMonth, nepaliDay, main.local.invalidDate);
          nepaliYear = date.year();
          nepaliMonth = date.month();
          nepaliDay = date.day();
          var gregorianCalendar = main.instance();
          var gregorianDayOfYear = 0;
          var nepaliMonthToCheck = nepaliMonth;
          var nepaliYearToCheck = nepaliYear;
          this._createMissingCalendarData(nepaliYear);
          var gregorianYear = nepaliYear - (nepaliMonthToCheck > 9 || nepaliMonthToCheck === 9 && nepaliDay >= this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0] ? 56 : 57);
          if (nepaliMonth !== 9) {
            gregorianDayOfYear = nepaliDay;
            nepaliMonthToCheck--;
          }
          while (nepaliMonthToCheck !== 9) {
            if (nepaliMonthToCheck <= 0) {
              nepaliMonthToCheck = 12;
              nepaliYearToCheck--;
            }
            gregorianDayOfYear += this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][nepaliMonthToCheck];
            nepaliMonthToCheck--;
          }
          if (nepaliMonth === 9) {
            gregorianDayOfYear += nepaliDay - this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0];
            if (gregorianDayOfYear < 0) {
              gregorianDayOfYear += gregorianCalendar.daysInYear(gregorianYear);
            }
          } else {
            gregorianDayOfYear += this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][9] - this.NEPALI_CALENDAR_DATA[nepaliYearToCheck][0];
          }
          return gregorianCalendar.newDate(gregorianYear, 1, 1).add(gregorianDayOfYear, "d").toJD();
        },
        /** Create a new date from a Julian date.
            @memberof NepaliCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var gregorianCalendar = main.instance();
          var gregorianDate = gregorianCalendar.fromJD(jd);
          var gregorianYear = gregorianDate.year();
          var gregorianDayOfYear = gregorianDate.dayOfYear();
          var nepaliYear = gregorianYear + 56;
          this._createMissingCalendarData(nepaliYear);
          var nepaliMonth = 9;
          var dayOfFirstJanInPaush = this.NEPALI_CALENDAR_DATA[nepaliYear][0];
          var daysSinceJanFirstToEndOfNepaliMonth = this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth] - dayOfFirstJanInPaush + 1;
          while (gregorianDayOfYear > daysSinceJanFirstToEndOfNepaliMonth) {
            nepaliMonth++;
            if (nepaliMonth > 12) {
              nepaliMonth = 1;
              nepaliYear++;
            }
            daysSinceJanFirstToEndOfNepaliMonth += this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth];
          }
          var nepaliDayOfMonth = this.NEPALI_CALENDAR_DATA[nepaliYear][nepaliMonth] - (daysSinceJanFirstToEndOfNepaliMonth - gregorianDayOfYear);
          return this.newDate(nepaliYear, nepaliMonth, nepaliDayOfMonth);
        },
        /** Creates missing data in the NEPALI_CALENDAR_DATA table.
            This data will not be correct but just give an estimated result. Mostly -/+ 1 day
            @private
            @param nepaliYear {number} The missing year number. */
        _createMissingCalendarData: function(nepaliYear) {
          var tmp_calendar_data = this.daysPerMonth.slice(0);
          tmp_calendar_data.unshift(17);
          for (var nepaliYearToCreate = nepaliYear - 1; nepaliYearToCreate < nepaliYear + 2; nepaliYearToCreate++) {
            if (typeof this.NEPALI_CALENDAR_DATA[nepaliYearToCreate] === "undefined") {
              this.NEPALI_CALENDAR_DATA[nepaliYearToCreate] = tmp_calendar_data;
            }
          }
        },
        NEPALI_CALENDAR_DATA: {
          // These data are from http://www.ashesh.com.np
          1970: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1971: [18, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
          1972: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          1973: [19, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          1974: [19, 31, 31, 32, 30, 31, 31, 30, 29, 30, 29, 30, 30],
          1975: [18, 31, 31, 32, 32, 30, 31, 30, 29, 30, 29, 30, 30],
          1976: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1977: [18, 31, 32, 31, 32, 31, 31, 29, 30, 29, 30, 29, 31],
          1978: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1979: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          1980: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1981: [18, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          1982: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1983: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          1984: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1985: [18, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          1986: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1987: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          1988: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          1989: [18, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          1990: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1991: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          // These data are from http://nepalicalendar.rat32.com/index.php
          1992: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          1993: [18, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          1994: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1995: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          1996: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          1997: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1998: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          1999: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2e3: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2001: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2002: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2003: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2004: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2005: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2006: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2007: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2008: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
          2009: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2010: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2011: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2012: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2013: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2014: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2015: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2016: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2017: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2018: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2019: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2020: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2021: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2022: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2023: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2024: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2025: [18, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2026: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2027: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2028: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2029: [18, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
          2030: [17, 31, 32, 31, 32, 31, 30, 30, 30, 30, 30, 30, 31],
          2031: [17, 31, 32, 31, 32, 31, 31, 31, 31, 31, 31, 31, 31],
          2032: [17, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32],
          2033: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2034: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2035: [17, 30, 32, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
          2036: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2037: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2038: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2039: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2040: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2041: [18, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2042: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2043: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2044: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2045: [18, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2046: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2047: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2048: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2049: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2050: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2051: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2052: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2053: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2054: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2055: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 30, 29, 30],
          2056: [17, 31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30],
          2057: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2058: [17, 30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2059: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2060: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2061: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2062: [17, 30, 32, 31, 32, 31, 31, 29, 30, 29, 30, 29, 31],
          2063: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2064: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2065: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2066: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31],
          2067: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2068: [17, 31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2069: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2070: [17, 31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30],
          2071: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2072: [17, 31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2073: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31],
          2074: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2075: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2076: [16, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          2077: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31],
          2078: [17, 31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30],
          2079: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30],
          2080: [16, 31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30],
          // These data are from http://www.ashesh.com.np/nepali-calendar/
          2081: [17, 31, 31, 32, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2082: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2083: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
          2084: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
          2085: [17, 31, 32, 31, 32, 31, 31, 30, 30, 29, 30, 30, 30],
          2086: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2087: [16, 31, 31, 32, 31, 31, 31, 30, 30, 29, 30, 30, 30],
          2088: [16, 30, 31, 32, 32, 30, 31, 30, 30, 29, 30, 30, 30],
          2089: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2090: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2091: [16, 31, 31, 32, 31, 31, 31, 30, 30, 29, 30, 30, 30],
          2092: [16, 31, 31, 32, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2093: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2094: [17, 31, 31, 32, 31, 31, 30, 30, 30, 29, 30, 30, 30],
          2095: [17, 31, 31, 32, 31, 31, 31, 30, 29, 30, 30, 30, 30],
          2096: [17, 30, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30],
          2097: [17, 31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 30, 30],
          2098: [17, 31, 31, 32, 31, 31, 31, 29, 30, 29, 30, 30, 31],
          2099: [17, 31, 31, 32, 31, 31, 31, 30, 29, 29, 30, 30, 30],
          2100: [17, 31, 32, 31, 32, 30, 31, 30, 29, 30, 29, 30, 30]
        }
      });
      main.calendars.nepali = NepaliCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/persian.js
  var require_persian = __commonJS({
    "node_modules/world-calendars/dist/calendars/persian.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function PersianCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      PersianCalendar.prototype = new main.baseCalendar();
      assign(PersianCalendar.prototype, {
        /** The calendar name.
            @memberof PersianCalendar */
        name: "Persian",
        /** Julian date of start of Persian epoch: 19 March 622 CE.
            @memberof PersianCalendar */
        jdEpoch: 19483205e-1,
        /** Days per month in a common year.
            @memberof PersianCalendar */
        daysPerMonth: [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof PersianCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof PersianCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof PersianCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof PersianCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof PersianCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Persian",
            epochs: ["BP", "AP"],
            monthNames: [
              "Farvardin",
              "Ordibehesht",
              "Khordad",
              "Tir",
              "Mordad",
              "Shahrivar",
              "Mehr",
              "Aban",
              "Azar",
              "Day",
              "Bahman",
              "Esfand"
            ],
            monthNamesShort: ["Far", "Ord", "Kho", "Tir", "Mor", "Sha", "Meh", "Aba", "Aza", "Day", "Bah", "Esf"],
            dayNames: ["Yekshambe", "Doshambe", "Seshambe", "Ch\xE6harshambe", "Panjshambe", "Jom'e", "Shambe"],
            dayNamesShort: ["Yek", "Do", "Se", "Ch\xE6", "Panj", "Jom", "Sha"],
            dayNamesMin: ["Ye", "Do", "Se", "Ch", "Pa", "Jo", "Sh"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 6,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return ((date.year() - (date.year() > 0 ? 474 : 473)) % 2820 + 474 + 38) * 682 % 2816 < 682;
        },
        /** Determine the week of the year for a date.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-((checkDate.dayOfWeek() + 1) % 7), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a month.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 12 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof PersianCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 5;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof PersianCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          year = date.year();
          month = date.month();
          day = date.day();
          var epBase = year - (year >= 0 ? 474 : 473);
          var epYear = 474 + mod(epBase, 2820);
          return day + (month <= 7 ? (month - 1) * 31 : (month - 1) * 30 + 6) + Math.floor((epYear * 682 - 110) / 2816) + (epYear - 1) * 365 + Math.floor(epBase / 2820) * 1029983 + this.jdEpoch - 1;
        },
        /** Create a new date from a Julian date.
            @memberof PersianCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          jd = Math.floor(jd) + 0.5;
          var depoch = jd - this.toJD(475, 1, 1);
          var cycle = Math.floor(depoch / 1029983);
          var cyear = mod(depoch, 1029983);
          var ycycle = 2820;
          if (cyear !== 1029982) {
            var aux1 = Math.floor(cyear / 366);
            var aux2 = mod(cyear, 366);
            ycycle = Math.floor((2134 * aux1 + 2816 * aux2 + 2815) / 1028522) + aux1 + 1;
          }
          var year = ycycle + 2820 * cycle + 474;
          year = year <= 0 ? year - 1 : year;
          var yday = jd - this.toJD(year, 1, 1) + 1;
          var month = yday <= 186 ? Math.ceil(yday / 31) : Math.ceil((yday - 6) / 30);
          var day = jd - this.toJD(year, month, 1) + 1;
          return this.newDate(year, month, day);
        }
      });
      function mod(a, b) {
        return a - b * Math.floor(a / b);
      }
      main.calendars.persian = PersianCalendar;
      main.calendars.jalali = PersianCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/taiwan.js
  var require_taiwan = __commonJS({
    "node_modules/world-calendars/dist/calendars/taiwan.js"() {
      var main = require_main();
      var assign = require_object_assign();
      var gregorianCalendar = main.instance();
      function TaiwanCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      TaiwanCalendar.prototype = new main.baseCalendar();
      assign(TaiwanCalendar.prototype, {
        /** The calendar name.
            @memberof TaiwanCalendar */
        name: "Taiwan",
        /** Julian date of start of Taiwan epoch: 1 January 1912 CE (Gregorian).
            @memberof TaiwanCalendar */
        jdEpoch: 24194025e-1,
        /** Difference in years between Taiwan and Gregorian calendars.
            @memberof TaiwanCalendar */
        yearsOffset: 1911,
        /** Days per month in a common year.
            @memberof TaiwanCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof TaiwanCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof TaiwanCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof TaiwanCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof TaiwanCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof TaiwanCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Taiwan",
            epochs: ["BROC", "ROC"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 1,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.leapYear(year);
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.weekOfYear(year, date.month(), date.day());
        },
        /** Retrieve the number of days in a month.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof TaiwanCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.toJD(year, date.month(), date.day());
        },
        /** Create a new date from a Julian date.
            @memberof TaiwanCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var date = gregorianCalendar.fromJD(jd);
          var year = this._g2tYear(date.year());
          return this.newDate(year, date.month(), date.day());
        },
        /** Convert Taiwanese to Gregorian year.
            @memberof TaiwanCalendar
            @private
            @param year {number} The Taiwanese year.
            @return {number} The corresponding Gregorian year. */
        _t2gYear: function(year) {
          return year + this.yearsOffset + (year >= -this.yearsOffset && year <= -1 ? 1 : 0);
        },
        /** Convert Gregorian to Taiwanese year.
            @memberof TaiwanCalendar
            @private
            @param year {number} The Gregorian year.
            @return {number} The corresponding Taiwanese year. */
        _g2tYear: function(year) {
          return year - this.yearsOffset - (year >= 1 && year <= this.yearsOffset ? 1 : 0);
        }
      });
      main.calendars.taiwan = TaiwanCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/thai.js
  var require_thai = __commonJS({
    "node_modules/world-calendars/dist/calendars/thai.js"() {
      var main = require_main();
      var assign = require_object_assign();
      var gregorianCalendar = main.instance();
      function ThaiCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      ThaiCalendar.prototype = new main.baseCalendar();
      assign(ThaiCalendar.prototype, {
        /** The calendar name.
            @memberof ThaiCalendar */
        name: "Thai",
        /** Julian date of start of Thai epoch: 1 January 543 BCE (Gregorian).
            @memberof ThaiCalendar */
        jdEpoch: 15230985e-1,
        /** Difference in years between Thai and Gregorian calendars.
            @memberof ThaiCalendar */
        yearsOffset: 543,
        /** Days per month in a common year.
            @memberof ThaiCalendar */
        daysPerMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof ThaiCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof ThaiCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof ThaiCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof ThaiCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof ThaiCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Thai",
            epochs: ["BBE", "BE"],
            monthNames: [
              "January",
              "February",
              "March",
              "April",
              "May",
              "June",
              "July",
              "August",
              "September",
              "October",
              "November",
              "December"
            ],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            digits: null,
            dateFormat: "dd/mm/yyyy",
            firstDay: 0,
            isRTL: false
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.leapYear(year);
        },
        /** Determine the week of the year for a date - ISO 8601.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.weekOfYear(year, date.month(), date.day());
        },
        /** Retrieve the number of days in a month.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          return this.daysPerMonth[date.month() - 1] + (date.month() === 2 && this.leapYear(date.year()) ? 1 : 0);
        },
        /** Determine whether this date is a week day.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return (this.dayOfWeek(year, month, day) || 7) < 6;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof ThaiCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var year = this._t2gYear(date.year());
          return gregorianCalendar.toJD(year, date.month(), date.day());
        },
        /** Create a new date from a Julian date.
            @memberof ThaiCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var date = gregorianCalendar.fromJD(jd);
          var year = this._g2tYear(date.year());
          return this.newDate(year, date.month(), date.day());
        },
        /** Convert Thai to Gregorian year.
            @memberof ThaiCalendar
            @private
            @param year {number} The Thai year.
            @return {number} The corresponding Gregorian year. */
        _t2gYear: function(year) {
          return year - this.yearsOffset - (year >= 1 && year <= this.yearsOffset ? 1 : 0);
        },
        /** Convert Gregorian to Thai year.
            @memberof ThaiCalendar
            @private
            @param year {number} The Gregorian year.
            @return {number} The corresponding Thai year. */
        _g2tYear: function(year) {
          return year + this.yearsOffset + (year >= -this.yearsOffset && year <= -1 ? 1 : 0);
        }
      });
      main.calendars.thai = ThaiCalendar;
    }
  });

  // node_modules/world-calendars/dist/calendars/ummalqura.js
  var require_ummalqura = __commonJS({
    "node_modules/world-calendars/dist/calendars/ummalqura.js"() {
      var main = require_main();
      var assign = require_object_assign();
      function UmmAlQuraCalendar(language) {
        this.local = this.regionalOptions[language || ""] || this.regionalOptions[""];
      }
      UmmAlQuraCalendar.prototype = new main.baseCalendar();
      assign(UmmAlQuraCalendar.prototype, {
        /** The calendar name.
            @memberof UmmAlQuraCalendar */
        name: "UmmAlQura",
        //jdEpoch: 1948440, // Julian date of start of UmmAlQura epoch: 14 March 1937 CE
        //daysPerMonth: // Days per month in a common year, replaced by a method.
        /** <code>true</code> if has a year zero, <code>false</code> if not.
            @memberof UmmAlQuraCalendar */
        hasYearZero: false,
        /** The minimum month number.
            @memberof UmmAlQuraCalendar */
        minMonth: 1,
        /** The first month in the year.
            @memberof UmmAlQuraCalendar */
        firstMonth: 1,
        /** The minimum day number.
            @memberof UmmAlQuraCalendar */
        minDay: 1,
        /** Localisations for the plugin.
            Entries are objects indexed by the language code ('' being the default US/English).
            Each object has the following attributes.
            @memberof UmmAlQuraCalendar
            @property name {string} The calendar name.
            @property epochs {string[]} The epoch names.
            @property monthNames {string[]} The long names of the months of the year.
            @property monthNamesShort {string[]} The short names of the months of the year.
            @property dayNames {string[]} The long names of the days of the week.
            @property dayNamesShort {string[]} The short names of the days of the week.
            @property dayNamesMin {string[]} The minimal names of the days of the week.
            @property dateFormat {string} The date format for this calendar.
                    See the options on <a href="BaseCalendar.html#formatDate"><code>formatDate</code></a> for details.
            @property firstDay {number} The number of the first day of the week, starting at 0.
            @property isRTL {number} <code>true</code> if this localisation reads right-to-left. */
        regionalOptions: {
          // Localisations
          "": {
            name: "Umm al-Qura",
            epochs: ["BH", "AH"],
            monthNames: [
              "Al-Muharram",
              "Safar",
              "Rabi' al-awwal",
              "Rabi' Al-Thani",
              "Jumada Al-Awwal",
              "Jumada Al-Thani",
              "Rajab",
              "Sha'aban",
              "Ramadan",
              "Shawwal",
              "Dhu al-Qi'dah",
              "Dhu al-Hijjah"
            ],
            monthNamesShort: ["Muh", "Saf", "Rab1", "Rab2", "Jum1", "Jum2", "Raj", "Sha'", "Ram", "Shaw", "DhuQ", "DhuH"],
            dayNames: ["Yawm al-Ahad", "Yawm al-Ithnain", "Yawm al-Thal\u0101th\u0101\u2019", "Yawm al-Arba\u2018\u0101\u2019", "Yawm al-Kham\u012Bs", "Yawm al-Jum\u2018a", "Yawm al-Sabt"],
            dayNamesMin: ["Ah", "Ith", "Th", "Ar", "Kh", "Ju", "Sa"],
            digits: null,
            dateFormat: "yyyy/mm/dd",
            firstDay: 6,
            isRTL: true
          }
        },
        /** Determine whether this date is in a leap year.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {boolean} <code>true</code> if this is a leap year, <code>false</code> if not.
            @throws Error if an invalid year or a different calendar used. */
        leapYear: function(year) {
          var date = this._validate(year, this.minMonth, this.minDay, main.local.invalidYear);
          return this.daysInYear(date.year()) === 355;
        },
        /** Determine the week of the year for a date.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {number} The week of the year.
            @throws Error if an invalid date or a different calendar used. */
        weekOfYear: function(year, month, day) {
          var checkDate = this.newDate(year, month, day);
          checkDate.add(-checkDate.dayOfWeek(), "d");
          return Math.floor((checkDate.dayOfYear() - 1) / 7) + 1;
        },
        /** Retrieve the number of days in a year.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @return {number} The number of days.
            @throws Error if an invalid year or a different calendar used. */
        daysInYear: function(year) {
          var daysCount = 0;
          for (var i = 1; i <= 12; i++) {
            daysCount += this.daysInMonth(year, i);
          }
          return daysCount;
        },
        /** Retrieve the number of days in a month.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year of the month.
            @param [month] {number} The month.
            @return {number} The number of days in this month.
            @throws Error if an invalid month/year or a different calendar used. */
        daysInMonth: function(year, month) {
          var date = this._validate(year, month, this.minDay, main.local.invalidMonth);
          var mcjdn = date.toJD() - 24e5 + 0.5;
          var index = 0;
          for (var i = 0; i < ummalqura_dat.length; i++) {
            if (ummalqura_dat[i] > mcjdn) {
              return ummalqura_dat[index] - ummalqura_dat[index - 1];
            }
            index++;
          }
          return 30;
        },
        /** Determine whether this date is a week day.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to examine or the year to examine.
            @param [month] {number} The month to examine.
            @param [day] {number} The day to examine.
            @return {boolean} <code>true</code> if a week day, <code>false</code> if not.
            @throws Error if an invalid date or a different calendar used. */
        weekDay: function(year, month, day) {
          return this.dayOfWeek(year, month, day) !== 5;
        },
        /** Retrieve the Julian date equivalent for this date,
            i.e. days since January 1, 4713 BCE Greenwich noon.
            @memberof UmmAlQuraCalendar
            @param year {CDate|number} The date to convert or the year to convert.
            @param [month] {number} The month to convert.
            @param [day] {number} The day to convert.
            @return {number} The equivalent Julian date.
            @throws Error if an invalid date or a different calendar used. */
        toJD: function(year, month, day) {
          var date = this._validate(year, month, day, main.local.invalidDate);
          var index = 12 * (date.year() - 1) + date.month() - 15292;
          var mcjdn = date.day() + ummalqura_dat[index - 1] - 1;
          return mcjdn + 24e5 - 0.5;
        },
        /** Create a new date from a Julian date.
            @memberof UmmAlQuraCalendar
            @param jd {number} The Julian date to convert.
            @return {CDate} The equivalent date. */
        fromJD: function(jd) {
          var mcjdn = jd - 24e5 + 0.5;
          var index = 0;
          for (var i = 0; i < ummalqura_dat.length; i++) {
            if (ummalqura_dat[i] > mcjdn) break;
            index++;
          }
          var lunation = index + 15292;
          var ii = Math.floor((lunation - 1) / 12);
          var year = ii + 1;
          var month = lunation - 12 * ii;
          var day = mcjdn - ummalqura_dat[index - 1] + 1;
          return this.newDate(year, month, day);
        },
        /** Determine whether a date is valid for this calendar.
            @memberof UmmAlQuraCalendar
            @param year {number} The year to examine.
            @param month {number} The month to examine.
            @param day {number} The day to examine.
            @return {boolean} <code>true</code> if a valid date, <code>false</code> if not. */
        isValid: function(year, month, day) {
          var valid = main.baseCalendar.prototype.isValid.apply(this, arguments);
          if (valid) {
            year = year.year != null ? year.year : year;
            valid = year >= 1276 && year <= 1500;
          }
          return valid;
        },
        /** Check that a candidate date is from the same calendar and is valid.
            @memberof UmmAlQuraCalendar
            @private
            @param year {CDate|number} The date to validate or the year to validate.
            @param month {number} The month to validate.
            @param day {number} The day to validate.
            @param error {string} Error message if invalid.
            @throws Error if different calendars used or invalid date. */
        _validate: function(year, month, day, error) {
          var date = main.baseCalendar.prototype._validate.apply(this, arguments);
          if (date.year < 1276 || date.year > 1500) {
            throw error.replace(/\{0\}/, this.local.name);
          }
          return date;
        }
      });
      main.calendars.ummalqura = UmmAlQuraCalendar;
      var ummalqura_dat = [
        20,
        50,
        79,
        109,
        138,
        168,
        197,
        227,
        256,
        286,
        315,
        345,
        374,
        404,
        433,
        463,
        492,
        522,
        551,
        581,
        611,
        641,
        670,
        700,
        729,
        759,
        788,
        818,
        847,
        877,
        906,
        936,
        965,
        995,
        1024,
        1054,
        1083,
        1113,
        1142,
        1172,
        1201,
        1231,
        1260,
        1290,
        1320,
        1350,
        1379,
        1409,
        1438,
        1468,
        1497,
        1527,
        1556,
        1586,
        1615,
        1645,
        1674,
        1704,
        1733,
        1763,
        1792,
        1822,
        1851,
        1881,
        1910,
        1940,
        1969,
        1999,
        2028,
        2058,
        2087,
        2117,
        2146,
        2176,
        2205,
        2235,
        2264,
        2294,
        2323,
        2353,
        2383,
        2413,
        2442,
        2472,
        2501,
        2531,
        2560,
        2590,
        2619,
        2649,
        2678,
        2708,
        2737,
        2767,
        2796,
        2826,
        2855,
        2885,
        2914,
        2944,
        2973,
        3003,
        3032,
        3062,
        3091,
        3121,
        3150,
        3180,
        3209,
        3239,
        3268,
        3298,
        3327,
        3357,
        3386,
        3416,
        3446,
        3476,
        3505,
        3535,
        3564,
        3594,
        3623,
        3653,
        3682,
        3712,
        3741,
        3771,
        3800,
        3830,
        3859,
        3889,
        3918,
        3948,
        3977,
        4007,
        4036,
        4066,
        4095,
        4125,
        4155,
        4185,
        4214,
        4244,
        4273,
        4303,
        4332,
        4362,
        4391,
        4421,
        4450,
        4480,
        4509,
        4539,
        4568,
        4598,
        4627,
        4657,
        4686,
        4716,
        4745,
        4775,
        4804,
        4834,
        4863,
        4893,
        4922,
        4952,
        4981,
        5011,
        5040,
        5070,
        5099,
        5129,
        5158,
        5188,
        5218,
        5248,
        5277,
        5307,
        5336,
        5366,
        5395,
        5425,
        5454,
        5484,
        5513,
        5543,
        5572,
        5602,
        5631,
        5661,
        5690,
        5720,
        5749,
        5779,
        5808,
        5838,
        5867,
        5897,
        5926,
        5956,
        5985,
        6015,
        6044,
        6074,
        6103,
        6133,
        6162,
        6192,
        6221,
        6251,
        6281,
        6311,
        6340,
        6370,
        6399,
        6429,
        6458,
        6488,
        6517,
        6547,
        6576,
        6606,
        6635,
        6665,
        6694,
        6724,
        6753,
        6783,
        6812,
        6842,
        6871,
        6901,
        6930,
        6960,
        6989,
        7019,
        7048,
        7078,
        7107,
        7137,
        7166,
        7196,
        7225,
        7255,
        7284,
        7314,
        7344,
        7374,
        7403,
        7433,
        7462,
        7492,
        7521,
        7551,
        7580,
        7610,
        7639,
        7669,
        7698,
        7728,
        7757,
        7787,
        7816,
        7846,
        7875,
        7905,
        7934,
        7964,
        7993,
        8023,
        8053,
        8083,
        8112,
        8142,
        8171,
        8201,
        8230,
        8260,
        8289,
        8319,
        8348,
        8378,
        8407,
        8437,
        8466,
        8496,
        8525,
        8555,
        8584,
        8614,
        8643,
        8673,
        8702,
        8732,
        8761,
        8791,
        8821,
        8850,
        8880,
        8909,
        8938,
        8968,
        8997,
        9027,
        9056,
        9086,
        9115,
        9145,
        9175,
        9205,
        9234,
        9264,
        9293,
        9322,
        9352,
        9381,
        9410,
        9440,
        9470,
        9499,
        9529,
        9559,
        9589,
        9618,
        9648,
        9677,
        9706,
        9736,
        9765,
        9794,
        9824,
        9853,
        9883,
        9913,
        9943,
        9972,
        10002,
        10032,
        10061,
        10090,
        10120,
        10149,
        10178,
        10208,
        10237,
        10267,
        10297,
        10326,
        10356,
        10386,
        10415,
        10445,
        10474,
        10504,
        10533,
        10562,
        10592,
        10621,
        10651,
        10680,
        10710,
        10740,
        10770,
        10799,
        10829,
        10858,
        10888,
        10917,
        10947,
        10976,
        11005,
        11035,
        11064,
        11094,
        11124,
        11153,
        11183,
        11213,
        11242,
        11272,
        11301,
        11331,
        11360,
        11389,
        11419,
        11448,
        11478,
        11507,
        11537,
        11567,
        11596,
        11626,
        11655,
        11685,
        11715,
        11744,
        11774,
        11803,
        11832,
        11862,
        11891,
        11921,
        11950,
        11980,
        12010,
        12039,
        12069,
        12099,
        12128,
        12158,
        12187,
        12216,
        12246,
        12275,
        12304,
        12334,
        12364,
        12393,
        12423,
        12453,
        12483,
        12512,
        12542,
        12571,
        12600,
        12630,
        12659,
        12688,
        12718,
        12747,
        12777,
        12807,
        12837,
        12866,
        12896,
        12926,
        12955,
        12984,
        13014,
        13043,
        13072,
        13102,
        13131,
        13161,
        13191,
        13220,
        13250,
        13280,
        13310,
        13339,
        13368,
        13398,
        13427,
        13456,
        13486,
        13515,
        13545,
        13574,
        13604,
        13634,
        13664,
        13693,
        13723,
        13752,
        13782,
        13811,
        13840,
        13870,
        13899,
        13929,
        13958,
        13988,
        14018,
        14047,
        14077,
        14107,
        14136,
        14166,
        14195,
        14224,
        14254,
        14283,
        14313,
        14342,
        14372,
        14401,
        14431,
        14461,
        14490,
        14520,
        14550,
        14579,
        14609,
        14638,
        14667,
        14697,
        14726,
        14756,
        14785,
        14815,
        14844,
        14874,
        14904,
        14933,
        14963,
        14993,
        15021,
        15051,
        15081,
        15110,
        15140,
        15169,
        15199,
        15228,
        15258,
        15287,
        15317,
        15347,
        15377,
        15406,
        15436,
        15465,
        15494,
        15524,
        15553,
        15582,
        15612,
        15641,
        15671,
        15701,
        15731,
        15760,
        15790,
        15820,
        15849,
        15878,
        15908,
        15937,
        15966,
        15996,
        16025,
        16055,
        16085,
        16114,
        16144,
        16174,
        16204,
        16233,
        16262,
        16292,
        16321,
        16350,
        16380,
        16409,
        16439,
        16468,
        16498,
        16528,
        16558,
        16587,
        16617,
        16646,
        16676,
        16705,
        16734,
        16764,
        16793,
        16823,
        16852,
        16882,
        16912,
        16941,
        16971,
        17001,
        17030,
        17060,
        17089,
        17118,
        17148,
        17177,
        17207,
        17236,
        17266,
        17295,
        17325,
        17355,
        17384,
        17414,
        17444,
        17473,
        17502,
        17532,
        17561,
        17591,
        17620,
        17650,
        17679,
        17709,
        17738,
        17768,
        17798,
        17827,
        17857,
        17886,
        17916,
        17945,
        17975,
        18004,
        18034,
        18063,
        18093,
        18122,
        18152,
        18181,
        18211,
        18241,
        18270,
        18300,
        18330,
        18359,
        18388,
        18418,
        18447,
        18476,
        18506,
        18535,
        18565,
        18595,
        18625,
        18654,
        18684,
        18714,
        18743,
        18772,
        18802,
        18831,
        18860,
        18890,
        18919,
        18949,
        18979,
        19008,
        19038,
        19068,
        19098,
        19127,
        19156,
        19186,
        19215,
        19244,
        19274,
        19303,
        19333,
        19362,
        19392,
        19422,
        19452,
        19481,
        19511,
        19540,
        19570,
        19599,
        19628,
        19658,
        19687,
        19717,
        19746,
        19776,
        19806,
        19836,
        19865,
        19895,
        19924,
        19954,
        19983,
        20012,
        20042,
        20071,
        20101,
        20130,
        20160,
        20190,
        20219,
        20249,
        20279,
        20308,
        20338,
        20367,
        20396,
        20426,
        20455,
        20485,
        20514,
        20544,
        20573,
        20603,
        20633,
        20662,
        20692,
        20721,
        20751,
        20780,
        20810,
        20839,
        20869,
        20898,
        20928,
        20957,
        20987,
        21016,
        21046,
        21076,
        21105,
        21135,
        21164,
        21194,
        21223,
        21253,
        21282,
        21312,
        21341,
        21371,
        21400,
        21430,
        21459,
        21489,
        21519,
        21548,
        21578,
        21607,
        21637,
        21666,
        21696,
        21725,
        21754,
        21784,
        21813,
        21843,
        21873,
        21902,
        21932,
        21962,
        21991,
        22021,
        22050,
        22080,
        22109,
        22138,
        22168,
        22197,
        22227,
        22256,
        22286,
        22316,
        22346,
        22375,
        22405,
        22434,
        22464,
        22493,
        22522,
        22552,
        22581,
        22611,
        22640,
        22670,
        22700,
        22730,
        22759,
        22789,
        22818,
        22848,
        22877,
        22906,
        22936,
        22965,
        22994,
        23024,
        23054,
        23083,
        23113,
        23143,
        23173,
        23202,
        23232,
        23261,
        23290,
        23320,
        23349,
        23379,
        23408,
        23438,
        23467,
        23497,
        23527,
        23556,
        23586,
        23616,
        23645,
        23674,
        23704,
        23733,
        23763,
        23792,
        23822,
        23851,
        23881,
        23910,
        23940,
        23970,
        23999,
        24029,
        24058,
        24088,
        24117,
        24147,
        24176,
        24206,
        24235,
        24265,
        24294,
        24324,
        24353,
        24383,
        24413,
        24442,
        24472,
        24501,
        24531,
        24560,
        24590,
        24619,
        24648,
        24678,
        24707,
        24737,
        24767,
        24796,
        24826,
        24856,
        24885,
        24915,
        24944,
        24974,
        25003,
        25032,
        25062,
        25091,
        25121,
        25150,
        25180,
        25210,
        25240,
        25269,
        25299,
        25328,
        25358,
        25387,
        25416,
        25446,
        25475,
        25505,
        25534,
        25564,
        25594,
        25624,
        25653,
        25683,
        25712,
        25742,
        25771,
        25800,
        25830,
        25859,
        25888,
        25918,
        25948,
        25977,
        26007,
        26037,
        26067,
        26096,
        26126,
        26155,
        26184,
        26214,
        26243,
        26272,
        26302,
        26332,
        26361,
        26391,
        26421,
        26451,
        26480,
        26510,
        26539,
        26568,
        26598,
        26627,
        26656,
        26686,
        26715,
        26745,
        26775,
        26805,
        26834,
        26864,
        26893,
        26923,
        26952,
        26982,
        27011,
        27041,
        27070,
        27099,
        27129,
        27159,
        27188,
        27218,
        27248,
        27277,
        27307,
        27336,
        27366,
        27395,
        27425,
        27454,
        27484,
        27513,
        27542,
        27572,
        27602,
        27631,
        27661,
        27691,
        27720,
        27750,
        27779,
        27809,
        27838,
        27868,
        27897,
        27926,
        27956,
        27985,
        28015,
        28045,
        28074,
        28104,
        28134,
        28163,
        28193,
        28222,
        28252,
        28281,
        28310,
        28340,
        28369,
        28399,
        28428,
        28458,
        28488,
        28517,
        28547,
        28577,
        // From 1356
        28607,
        28636,
        28665,
        28695,
        28724,
        28754,
        28783,
        28813,
        28843,
        28872,
        28901,
        28931,
        28960,
        28990,
        29019,
        29049,
        29078,
        29108,
        29137,
        29167,
        29196,
        29226,
        29255,
        29285,
        29315,
        29345,
        29375,
        29404,
        29434,
        29463,
        29492,
        29522,
        29551,
        29580,
        29610,
        29640,
        29669,
        29699,
        29729,
        29759,
        29788,
        29818,
        29847,
        29876,
        29906,
        29935,
        29964,
        29994,
        30023,
        30053,
        30082,
        30112,
        30141,
        30171,
        30200,
        30230,
        30259,
        30289,
        30318,
        30348,
        30378,
        30408,
        30437,
        30467,
        30496,
        30526,
        30555,
        30585,
        30614,
        30644,
        30673,
        30703,
        30732,
        30762,
        30791,
        30821,
        30850,
        30880,
        30909,
        30939,
        30968,
        30998,
        31027,
        31057,
        31086,
        31116,
        31145,
        31175,
        31204,
        31234,
        31263,
        31293,
        31322,
        31352,
        31381,
        31411,
        31441,
        31471,
        31500,
        31530,
        31559,
        31589,
        31618,
        31648,
        31676,
        31706,
        31736,
        31766,
        31795,
        31825,
        31854,
        31884,
        31913,
        31943,
        31972,
        32002,
        32031,
        32061,
        32090,
        32120,
        32150,
        32180,
        32209,
        32239,
        32268,
        32298,
        32327,
        32357,
        32386,
        32416,
        32445,
        32475,
        32504,
        32534,
        32563,
        32593,
        32622,
        32652,
        32681,
        32711,
        32740,
        32770,
        32799,
        32829,
        32858,
        32888,
        32917,
        32947,
        32976,
        33006,
        33035,
        33065,
        33094,
        33124,
        33153,
        33183,
        33213,
        33243,
        33272,
        33302,
        33331,
        33361,
        33390,
        33420,
        33450,
        33479,
        33509,
        33539,
        33568,
        33598,
        33627,
        33657,
        33686,
        33716,
        33745,
        33775,
        33804,
        33834,
        33863,
        33893,
        33922,
        33952,
        33981,
        34011,
        34040,
        34069,
        34099,
        34128,
        34158,
        34187,
        34217,
        34247,
        34277,
        34306,
        34336,
        34365,
        34395,
        34424,
        34454,
        34483,
        34512,
        34542,
        34571,
        34601,
        34631,
        34660,
        34690,
        34719,
        34749,
        34778,
        34808,
        34837,
        34867,
        34896,
        34926,
        34955,
        34985,
        35015,
        35044,
        35074,
        35103,
        35133,
        35162,
        35192,
        35222,
        35251,
        35280,
        35310,
        35340,
        35370,
        35399,
        35429,
        35458,
        35488,
        35517,
        35547,
        35576,
        35605,
        35635,
        35665,
        35694,
        35723,
        35753,
        35782,
        35811,
        35841,
        35871,
        35901,
        35930,
        35960,
        35989,
        36019,
        36048,
        36078,
        36107,
        36136,
        36166,
        36195,
        36225,
        36254,
        36284,
        36314,
        36343,
        36373,
        36403,
        36433,
        36462,
        36492,
        36521,
        36551,
        36580,
        36610,
        36639,
        36669,
        36698,
        36728,
        36757,
        36786,
        36816,
        36845,
        36875,
        36904,
        36934,
        36963,
        36993,
        37022,
        37052,
        37081,
        37111,
        37141,
        37170,
        37200,
        37229,
        37259,
        37288,
        37318,
        37347,
        37377,
        37406,
        37436,
        37465,
        37495,
        37524,
        37554,
        37584,
        37613,
        37643,
        37672,
        37701,
        37731,
        37760,
        37790,
        37819,
        37849,
        37878,
        37908,
        37938,
        37967,
        37997,
        38027,
        38056,
        38085,
        38115,
        38144,
        38174,
        38203,
        38233,
        38262,
        38292,
        38322,
        38351,
        38381,
        38410,
        38440,
        38469,
        38499,
        38528,
        38558,
        38587,
        38617,
        38646,
        38676,
        38705,
        38735,
        38764,
        38794,
        38823,
        38853,
        38882,
        38912,
        38941,
        38971,
        39001,
        39030,
        39059,
        39089,
        39118,
        39148,
        39178,
        39208,
        39237,
        39267,
        39297,
        39326,
        39355,
        39385,
        39414,
        39444,
        39473,
        39503,
        39532,
        39562,
        39592,
        39621,
        39650,
        39680,
        39709,
        39739,
        39768,
        39798,
        39827,
        39857,
        39886,
        39916,
        39946,
        39975,
        40005,
        40035,
        40064,
        40094,
        40123,
        40153,
        40182,
        40212,
        40241,
        40271,
        40300,
        40330,
        40359,
        40389,
        40418,
        40448,
        40477,
        40507,
        40536,
        40566,
        40595,
        40625,
        40655,
        40685,
        40714,
        40744,
        40773,
        40803,
        40832,
        40862,
        40892,
        40921,
        40951,
        40980,
        41009,
        41039,
        41068,
        41098,
        41127,
        41157,
        41186,
        41216,
        41245,
        41275,
        41304,
        41334,
        41364,
        41393,
        41422,
        41452,
        41481,
        41511,
        41540,
        41570,
        41599,
        41629,
        41658,
        41688,
        41718,
        41748,
        41777,
        41807,
        41836,
        41865,
        41894,
        41924,
        41953,
        41983,
        42012,
        42042,
        42072,
        42102,
        42131,
        42161,
        42190,
        42220,
        42249,
        42279,
        42308,
        42337,
        42367,
        42397,
        42426,
        42456,
        42485,
        42515,
        42545,
        42574,
        42604,
        42633,
        42662,
        42692,
        42721,
        42751,
        42780,
        42810,
        42839,
        42869,
        42899,
        42929,
        42958,
        42988,
        43017,
        43046,
        43076,
        43105,
        43135,
        43164,
        43194,
        43223,
        43253,
        43283,
        43312,
        43342,
        43371,
        43401,
        43430,
        43460,
        43489,
        43519,
        43548,
        43578,
        43607,
        43637,
        43666,
        43696,
        43726,
        43755,
        43785,
        43814,
        43844,
        43873,
        43903,
        43932,
        43962,
        43991,
        44021,
        44050,
        44080,
        44109,
        44139,
        44169,
        44198,
        44228,
        44258,
        44287,
        44317,
        44346,
        44375,
        44405,
        44434,
        44464,
        44493,
        44523,
        44553,
        44582,
        44612,
        44641,
        44671,
        44700,
        44730,
        44759,
        44788,
        44818,
        44847,
        44877,
        44906,
        44936,
        44966,
        44996,
        45025,
        45055,
        45084,
        45114,
        45143,
        45172,
        45202,
        45231,
        45261,
        45290,
        45320,
        45350,
        45380,
        45409,
        45439,
        45468,
        45498,
        45527,
        45556,
        45586,
        45615,
        45644,
        45674,
        45704,
        45733,
        45763,
        45793,
        45823,
        45852,
        45882,
        45911,
        45940,
        45970,
        45999,
        46028,
        46058,
        46088,
        46117,
        46147,
        46177,
        46206,
        46236,
        46265,
        46295,
        46324,
        46354,
        46383,
        46413,
        46442,
        46472,
        46501,
        46531,
        46560,
        46590,
        46620,
        46649,
        46679,
        46708,
        46738,
        46767,
        46797,
        46826,
        46856,
        46885,
        46915,
        46944,
        46974,
        47003,
        47033,
        47063,
        47092,
        47122,
        47151,
        47181,
        47210,
        47240,
        47269,
        47298,
        47328,
        47357,
        47387,
        47417,
        47446,
        47476,
        47506,
        47535,
        47565,
        47594,
        47624,
        47653,
        47682,
        47712,
        47741,
        47771,
        47800,
        47830,
        47860,
        47890,
        47919,
        47949,
        47978,
        48008,
        48037,
        48066,
        48096,
        48125,
        48155,
        48184,
        48214,
        48244,
        48273,
        48303,
        48333,
        48362,
        48392,
        48421,
        48450,
        48480,
        48509,
        48538,
        48568,
        48598,
        48627,
        48657,
        48687,
        48717,
        48746,
        48776,
        48805,
        48834,
        48864,
        48893,
        48922,
        48952,
        48982,
        49011,
        49041,
        49071,
        49100,
        49130,
        49160,
        49189,
        49218,
        49248,
        49277,
        49306,
        49336,
        49365,
        49395,
        49425,
        49455,
        49484,
        49514,
        49543,
        49573,
        49602,
        49632,
        49661,
        49690,
        49720,
        49749,
        49779,
        49809,
        49838,
        49868,
        49898,
        49927,
        49957,
        49986,
        50016,
        50045,
        50075,
        50104,
        50133,
        50163,
        50192,
        50222,
        50252,
        50281,
        50311,
        50340,
        50370,
        50400,
        50429,
        50459,
        50488,
        50518,
        50547,
        50576,
        50606,
        50635,
        50665,
        50694,
        50724,
        50754,
        50784,
        50813,
        50843,
        50872,
        50902,
        50931,
        50960,
        50990,
        51019,
        51049,
        51078,
        51108,
        51138,
        51167,
        51197,
        51227,
        51256,
        51286,
        51315,
        51345,
        51374,
        51403,
        51433,
        51462,
        51492,
        51522,
        51552,
        51582,
        51611,
        51641,
        51670,
        51699,
        51729,
        51758,
        51787,
        51816,
        51846,
        51876,
        51906,
        51936,
        51965,
        51995,
        52025,
        52054,
        52083,
        52113,
        52142,
        52171,
        52200,
        52230,
        52260,
        52290,
        52319,
        52349,
        52379,
        52408,
        52438,
        52467,
        52497,
        52526,
        52555,
        52585,
        52614,
        52644,
        52673,
        52703,
        52733,
        52762,
        52792,
        52822,
        52851,
        52881,
        52910,
        52939,
        52969,
        52998,
        53028,
        53057,
        53087,
        53116,
        53146,
        53176,
        53205,
        53235,
        53264,
        53294,
        53324,
        53353,
        53383,
        53412,
        53441,
        53471,
        53500,
        53530,
        53559,
        53589,
        53619,
        53648,
        53678,
        53708,
        53737,
        53767,
        53796,
        53825,
        53855,
        53884,
        53913,
        53943,
        53973,
        54003,
        54032,
        54062,
        54092,
        54121,
        54151,
        54180,
        54209,
        54239,
        54268,
        54297,
        54327,
        54357,
        54387,
        54416,
        54446,
        54476,
        54505,
        54535,
        54564,
        54593,
        54623,
        54652,
        54681,
        54711,
        54741,
        54770,
        54800,
        54830,
        54859,
        54889,
        54919,
        54948,
        54977,
        55007,
        55036,
        55066,
        55095,
        55125,
        55154,
        55184,
        55213,
        55243,
        55273,
        55302,
        55332,
        55361,
        55391,
        55420,
        55450,
        55479,
        55508,
        55538,
        55567,
        55597,
        55627,
        55657,
        55686,
        55716,
        55745,
        55775,
        55804,
        55834,
        55863,
        55892,
        55922,
        55951,
        55981,
        56011,
        56040,
        56070,
        56100,
        56129,
        56159,
        56188,
        56218,
        56247,
        56276,
        56306,
        56335,
        56365,
        56394,
        56424,
        56454,
        56483,
        56513,
        56543,
        56572,
        56601,
        56631,
        56660,
        56690,
        56719,
        56749,
        56778,
        56808,
        56837,
        56867,
        56897,
        56926,
        56956,
        56985,
        57015,
        57044,
        57074,
        57103,
        57133,
        57162,
        57192,
        57221,
        57251,
        57280,
        57310,
        57340,
        57369,
        57399,
        57429,
        57458,
        57487,
        57517,
        57546,
        57576,
        57605,
        57634,
        57664,
        57694,
        57723,
        57753,
        57783,
        57813,
        57842,
        57871,
        57901,
        57930,
        57959,
        57989,
        58018,
        58048,
        58077,
        58107,
        58137,
        58167,
        58196,
        58226,
        58255,
        58285,
        58314,
        58343,
        58373,
        58402,
        58432,
        58461,
        58491,
        58521,
        58551,
        58580,
        58610,
        58639,
        58669,
        58698,
        58727,
        58757,
        58786,
        58816,
        58845,
        58875,
        58905,
        58934,
        58964,
        58994,
        59023,
        59053,
        59082,
        59111,
        59141,
        59170,
        59200,
        59229,
        59259,
        59288,
        59318,
        59348,
        59377,
        59407,
        59436,
        59466,
        59495,
        59525,
        59554,
        59584,
        59613,
        59643,
        59672,
        59702,
        59731,
        59761,
        59791,
        59820,
        59850,
        59879,
        59909,
        59939,
        59968,
        59997,
        60027,
        60056,
        60086,
        60115,
        60145,
        60174,
        60204,
        60234,
        60264,
        60293,
        60323,
        60352,
        60381,
        60411,
        60440,
        60469,
        60499,
        60528,
        60558,
        60588,
        60618,
        60648,
        60677,
        60707,
        60736,
        60765,
        60795,
        60824,
        60853,
        60883,
        60912,
        60942,
        60972,
        61002,
        61031,
        61061,
        61090,
        61120,
        61149,
        61179,
        61208,
        61237,
        61267,
        61296,
        61326,
        61356,
        61385,
        61415,
        61445,
        61474,
        61504,
        61533,
        61563,
        61592,
        61621,
        61651,
        61680,
        61710,
        61739,
        61769,
        61799,
        61828,
        61858,
        61888,
        61917,
        61947,
        61976,
        62006,
        62035,
        62064,
        62094,
        62123,
        62153,
        62182,
        62212,
        62242,
        62271,
        62301,
        62331,
        62360,
        62390,
        62419,
        62448,
        62478,
        62507,
        62537,
        62566,
        62596,
        62625,
        62655,
        62685,
        62715,
        62744,
        62774,
        62803,
        62832,
        62862,
        62891,
        62921,
        62950,
        62980,
        63009,
        63039,
        63069,
        63099,
        63128,
        63157,
        63187,
        63216,
        63246,
        63275,
        63305,
        63334,
        63363,
        63393,
        63423,
        63453,
        63482,
        63512,
        63541,
        63571,
        63600,
        63630,
        63659,
        63689,
        63718,
        63747,
        63777,
        63807,
        63836,
        63866,
        63895,
        63925,
        63955,
        63984,
        64014,
        64043,
        64073,
        64102,
        64131,
        64161,
        64190,
        64220,
        64249,
        64279,
        64309,
        64339,
        64368,
        64398,
        64427,
        64457,
        64486,
        64515,
        64545,
        64574,
        64603,
        64633,
        64663,
        64692,
        64722,
        64752,
        64782,
        64811,
        64841,
        64870,
        64899,
        64929,
        64958,
        64987,
        65017,
        65047,
        65076,
        65106,
        65136,
        65166,
        65195,
        65225,
        65254,
        65283,
        65313,
        65342,
        65371,
        65401,
        65431,
        65460,
        65490,
        65520,
        65549,
        65579,
        65608,
        65638,
        65667,
        65697,
        65726,
        65755,
        65785,
        65815,
        65844,
        65874,
        65903,
        65933,
        65963,
        65992,
        66022,
        66051,
        66081,
        66110,
        66140,
        66169,
        66199,
        66228,
        66258,
        66287,
        66317,
        66346,
        66376,
        66405,
        66435,
        66465,
        66494,
        66524,
        66553,
        66583,
        66612,
        66641,
        66671,
        66700,
        66730,
        66760,
        66789,
        66819,
        66849,
        66878,
        66908,
        66937,
        66967,
        66996,
        67025,
        67055,
        67084,
        67114,
        67143,
        67173,
        67203,
        67233,
        67262,
        67292,
        67321,
        67351,
        67380,
        67409,
        67439,
        67468,
        67497,
        67527,
        67557,
        67587,
        67617,
        67646,
        67676,
        67705,
        67735,
        67764,
        67793,
        67823,
        67852,
        67882,
        67911,
        67941,
        67971,
        68e3,
        68030,
        68060,
        68089,
        68119,
        68148,
        68177,
        68207,
        68236,
        68266,
        68295,
        68325,
        68354,
        68384,
        68414,
        68443,
        68473,
        68502,
        68532,
        68561,
        68591,
        68620,
        68650,
        68679,
        68708,
        68738,
        68768,
        68797,
        68827,
        68857,
        68886,
        68916,
        68946,
        68975,
        69004,
        69034,
        69063,
        69092,
        69122,
        69152,
        69181,
        69211,
        69240,
        69270,
        69300,
        69330,
        69359,
        69388,
        69418,
        69447,
        69476,
        69506,
        69535,
        69565,
        69595,
        69624,
        69654,
        69684,
        69713,
        69743,
        69772,
        69802,
        69831,
        69861,
        69890,
        69919,
        69949,
        69978,
        70008,
        70038,
        70067,
        70097,
        70126,
        70156,
        70186,
        70215,
        70245,
        70274,
        70303,
        70333,
        70362,
        70392,
        70421,
        70451,
        70481,
        70510,
        70540,
        70570,
        70599,
        70629,
        70658,
        70687,
        70717,
        70746,
        70776,
        70805,
        70835,
        70864,
        70894,
        70924,
        70954,
        70983,
        71013,
        71042,
        71071,
        71101,
        71130,
        71159,
        71189,
        71218,
        71248,
        71278,
        71308,
        71337,
        71367,
        71397,
        71426,
        71455,
        71485,
        71514,
        71543,
        71573,
        71602,
        71632,
        71662,
        71691,
        71721,
        71751,
        71781,
        71810,
        71839,
        71869,
        71898,
        71927,
        71957,
        71986,
        72016,
        72046,
        72075,
        72105,
        72135,
        72164,
        72194,
        72223,
        72253,
        72282,
        72311,
        72341,
        72370,
        72400,
        72429,
        72459,
        72489,
        72518,
        72548,
        72577,
        72607,
        72637,
        72666,
        72695,
        72725,
        72754,
        72784,
        72813,
        72843,
        72872,
        72902,
        72931,
        72961,
        72991,
        73020,
        73050,
        73080,
        73109,
        73139,
        73168,
        73197,
        73227,
        73256,
        73286,
        73315,
        73345,
        73375,
        73404,
        73434,
        73464,
        73493,
        73523,
        73552,
        73581,
        73611,
        73640,
        73669,
        73699,
        73729,
        73758,
        73788,
        73818,
        73848,
        73877,
        73907,
        73936,
        73965,
        73995,
        74024,
        74053,
        74083,
        74113,
        74142,
        74172,
        74202,
        74231,
        74261,
        74291,
        74320,
        74349,
        74379,
        74408,
        74437,
        74467,
        74497,
        74526,
        74556,
        74586,
        74615,
        74645,
        74675,
        74704,
        74733,
        74763,
        74792,
        74822,
        74851,
        74881,
        74910,
        74940,
        74969,
        74999,
        75029,
        75058,
        75088,
        75117,
        75147,
        75176,
        75206,
        75235,
        75264,
        75294,
        75323,
        75353,
        75383,
        75412,
        75442,
        75472,
        75501,
        75531,
        75560,
        75590,
        75619,
        75648,
        75678,
        75707,
        75737,
        75766,
        75796,
        75826,
        75856,
        75885,
        75915,
        75944,
        75974,
        76003,
        76032,
        76062,
        76091,
        76121,
        76150,
        76180,
        76210,
        76239,
        76269,
        76299,
        76328,
        76358,
        76387,
        76416,
        76446,
        76475,
        76505,
        76534,
        76564,
        76593,
        76623,
        76653,
        76682,
        76712,
        76741,
        76771,
        76801,
        76830,
        76859,
        76889,
        76918,
        76948,
        76977,
        77007,
        77036,
        77066,
        77096,
        77125,
        77155,
        77185,
        77214,
        77243,
        77273,
        77302,
        77332,
        77361,
        77390,
        77420,
        77450,
        77479,
        77509,
        77539,
        77569,
        77598,
        77627,
        77657,
        77686,
        77715,
        77745,
        77774,
        77804,
        77833,
        77863,
        77893,
        77923,
        77952,
        77982,
        78011,
        78041,
        78070,
        78099,
        78129,
        78158,
        78188,
        78217,
        78247,
        78277,
        78307,
        78336,
        78366,
        78395,
        78425,
        78454,
        78483,
        78513,
        78542,
        78572,
        78601,
        78631,
        78661,
        78690,
        78720,
        78750,
        78779,
        78808,
        78838,
        78867,
        78897,
        78926,
        78956,
        78985,
        79015,
        79044,
        79074,
        79104,
        79133,
        79163,
        79192,
        79222,
        79251,
        79281,
        79310,
        79340,
        79369,
        79399,
        79428,
        79458,
        79487,
        79517,
        79546,
        79576,
        79606,
        79635,
        79665,
        79695,
        79724,
        79753,
        79783,
        79812,
        79841,
        79871,
        79900,
        79930,
        79960,
        79990
      ];
    }
  });

  // src/components/calendars/calendars.js
  var require_calendars = __commonJS({
    "src/components/calendars/calendars.js"(exports, module) {
      "use strict";
      module.exports = require_main();
      require_plus();
      require_chinese();
      require_coptic();
      require_discworld();
      require_ethiopian();
      require_hebrew();
      require_islamic();
      require_julian();
      require_mayan();
      require_nanakshahi();
      require_nepali();
      require_persian();
      require_taiwan();
      require_thai();
      require_ummalqura();
    }
  });

  // src/components/calendars/index.js
  var require_calendars2 = __commonJS({
    "src/components/calendars/index.js"(exports, module) {
      "use strict";
      var calendars = require_calendars();
      var Lib = require_lib();
      var constants = require_numerical();
      var EPOCHJD = constants.EPOCHJD;
      var ONEDAY = constants.ONEDAY;
      var attributes = {
        valType: "enumerated",
        values: Lib.sortObjectKeys(calendars.calendars),
        editType: "calc",
        dflt: "gregorian"
      };
      var handleDefaults = function(contIn, contOut, attr, dflt) {
        var attrs = {};
        attrs[attr] = attributes;
        return Lib.coerce(contIn, contOut, attrs, attr, dflt);
      };
      var handleTraceDefaults = function(traceIn, traceOut, coords, layout) {
        for (var i = 0; i < coords.length; i++) {
          handleDefaults(traceIn, traceOut, coords[i] + "calendar", layout.calendar);
        }
      };
      var CANONICAL_TICK = {
        chinese: "2000-01-01",
        coptic: "2000-01-01",
        discworld: "2000-01-01",
        ethiopian: "2000-01-01",
        hebrew: "5000-01-01",
        islamic: "1000-01-01",
        julian: "2000-01-01",
        mayan: "5000-01-01",
        nanakshahi: "1000-01-01",
        nepali: "2000-01-01",
        persian: "1000-01-01",
        jalali: "1000-01-01",
        taiwan: "1000-01-01",
        thai: "2000-01-01",
        ummalqura: "1400-01-01"
      };
      var CANONICAL_SUNDAY = {
        chinese: "2000-01-02",
        coptic: "2000-01-03",
        discworld: "2000-01-03",
        ethiopian: "2000-01-05",
        hebrew: "5000-01-01",
        islamic: "1000-01-02",
        julian: "2000-01-03",
        mayan: "5000-01-01",
        nanakshahi: "1000-01-05",
        nepali: "2000-01-05",
        persian: "1000-01-01",
        jalali: "1000-01-01",
        taiwan: "1000-01-04",
        thai: "2000-01-04",
        ummalqura: "1400-01-06"
      };
      var DFLTRANGE = {
        chinese: ["2000-01-01", "2001-01-01"],
        coptic: ["1700-01-01", "1701-01-01"],
        discworld: ["1800-01-01", "1801-01-01"],
        ethiopian: ["2000-01-01", "2001-01-01"],
        hebrew: ["5700-01-01", "5701-01-01"],
        islamic: ["1400-01-01", "1401-01-01"],
        julian: ["2000-01-01", "2001-01-01"],
        mayan: ["5200-01-01", "5201-01-01"],
        nanakshahi: ["0500-01-01", "0501-01-01"],
        nepali: ["2000-01-01", "2001-01-01"],
        persian: ["1400-01-01", "1401-01-01"],
        jalali: ["1400-01-01", "1401-01-01"],
        taiwan: ["0100-01-01", "0101-01-01"],
        thai: ["2500-01-01", "2501-01-01"],
        ummalqura: ["1400-01-01", "1401-01-01"]
      };
      var UNKNOWN = "##";
      var d3ToWorldCalendars = {
        d: { 0: "dd", "-": "d" },
        // 2-digit or unpadded day of month
        e: { 0: "d", "-": "d" },
        // alternate, always unpadded day of month
        a: { 0: "D", "-": "D" },
        // short weekday name
        A: { 0: "DD", "-": "DD" },
        // full weekday name
        j: { 0: "oo", "-": "o" },
        // 3-digit or unpadded day of the year
        W: { 0: "ww", "-": "w" },
        // 2-digit or unpadded week of the year (Monday first)
        m: { 0: "mm", "-": "m" },
        // 2-digit or unpadded month number
        b: { 0: "M", "-": "M" },
        // short month name
        B: { 0: "MM", "-": "MM" },
        // full month name
        y: { 0: "yy", "-": "yy" },
        // 2-digit year (map unpadded to zero-padded)
        Y: { 0: "yyyy", "-": "yyyy" },
        // 4-digit year (map unpadded to zero-padded)
        U: UNKNOWN,
        // Sunday-first week of the year
        w: UNKNOWN,
        // day of the week [0(sunday),6]
        // combined format, we replace the date part with the world-calendar version
        // and the %X stays there for d3 to handle with time parts
        c: { 0: "D M d %X yyyy", "-": "D M d %X yyyy" },
        x: { 0: "mm/dd/yyyy", "-": "mm/dd/yyyy" }
      };
      function worldCalFmt(fmt, x, calendar) {
        var dateJD = Math.floor((x + 0.05) / ONEDAY) + EPOCHJD;
        var cDate = getCal(calendar).fromJD(dateJD);
        var i = 0;
        var modifier, directive, directiveLen, directiveObj, replacementPart;
        while ((i = fmt.indexOf("%", i)) !== -1) {
          modifier = fmt.charAt(i + 1);
          if (modifier === "0" || modifier === "-" || modifier === "_") {
            directiveLen = 3;
            directive = fmt.charAt(i + 2);
            if (modifier === "_") modifier = "-";
          } else {
            directive = modifier;
            modifier = "0";
            directiveLen = 2;
          }
          directiveObj = d3ToWorldCalendars[directive];
          if (!directiveObj) {
            i += directiveLen;
          } else {
            if (directiveObj === UNKNOWN) replacementPart = UNKNOWN;
            else replacementPart = cDate.formatDate(directiveObj[modifier]);
            fmt = fmt.substr(0, i) + replacementPart + fmt.substr(i + directiveLen);
            i += replacementPart.length;
          }
        }
        return fmt;
      }
      var allCals = {};
      function getCal(calendar) {
        var calendarObj = allCals[calendar];
        if (calendarObj) return calendarObj;
        calendarObj = allCals[calendar] = calendars.instance(calendar);
        return calendarObj;
      }
      function makeAttrs(description) {
        return Lib.extendFlat({}, attributes, { description });
      }
      function makeTraceAttrsDescription(coord) {
        return "Sets the calendar system to use with `" + coord + "` date data.";
      }
      var xAttrs = {
        xcalendar: makeAttrs(makeTraceAttrsDescription("x"))
      };
      var xyAttrs = Lib.extendFlat({}, xAttrs, {
        ycalendar: makeAttrs(makeTraceAttrsDescription("y"))
      });
      var xyzAttrs = Lib.extendFlat({}, xyAttrs, {
        zcalendar: makeAttrs(makeTraceAttrsDescription("z"))
      });
      var axisAttrs = makeAttrs([
        "Sets the calendar system to use for `range` and `tick0`",
        "if this is a date axis. This does not set the calendar for",
        "interpreting data on this axis, that's specified in the trace",
        "or via the global `layout.calendar`"
      ].join(" "));
      module.exports = {
        moduleType: "component",
        name: "calendars",
        schema: {
          traces: {
            scatter: xyAttrs,
            bar: xyAttrs,
            box: xyAttrs,
            heatmap: xyAttrs,
            contour: xyAttrs,
            histogram: xyAttrs,
            histogram2d: xyAttrs,
            histogram2dcontour: xyAttrs,
            scatter3d: xyzAttrs,
            surface: xyzAttrs,
            mesh3d: xyzAttrs,
            scattergl: xyAttrs,
            ohlc: xAttrs,
            candlestick: xAttrs
          },
          layout: {
            calendar: makeAttrs([
              "Sets the default calendar system to use for interpreting and",
              "displaying dates throughout the plot."
            ].join(" "))
          },
          subplots: {
            xaxis: { calendar: axisAttrs },
            yaxis: { calendar: axisAttrs },
            scene: {
              xaxis: { calendar: axisAttrs },
              // TODO: it's actually redundant to include yaxis and zaxis here
              // because in the scene attributes these are the same object so merging
              // into one merges into them all. However, I left them in for parity with
              // cartesian, where yaxis is unused until we Plotschema.get() when we
              // use its presence or absence to determine whether to delete attributes
              // from yaxis if they only apply to x (rangeselector/rangeslider)
              yaxis: { calendar: axisAttrs },
              zaxis: { calendar: axisAttrs }
            },
            polar: {
              radialaxis: { calendar: axisAttrs }
            }
          }
        },
        layoutAttributes: attributes,
        handleDefaults,
        handleTraceDefaults,
        CANONICAL_SUNDAY,
        CANONICAL_TICK,
        DFLTRANGE,
        getCal,
        worldCalFmt
      };
    }
  });

  // lib/calendars.js
  var require_calendars3 = __commonJS({
    "lib/calendars.js"(exports, module) {
      "use strict";
      module.exports = require_calendars2();
    }
  });

  // lib/index-gl2d.js
  var require_index_gl2d = __commonJS({
    "lib/index-gl2d.js"(exports, module) {
      var Plotly = require_core2();
      Plotly.register([
        // traces
        require_scattergl2(),
        require_splom2(),
        require_parcoords3(),
        // components
        require_calendars3()
      ]);
      module.exports = Plotly;
    }
  });
  return require_index_gl2d();
})();
/*! Bundled license information:

native-promise-only/lib/npo.src.js:
  (*! Native Promise Only
      v0.8.1 (c) Kyle Simpson
      MIT License: http://getify.mit-license.org
  *)

polybooljs/index.js:
  (*
   * @copyright 2016 Sean Connelly (@voidqk), http://syntheti.cc
   * @license MIT
   * @preserve Project Home: https://github.com/voidqk/polybooljs
   *)

assert/build/internal/util/comparisons.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

window.Plotly = Plotly;
return Plotly;
}));