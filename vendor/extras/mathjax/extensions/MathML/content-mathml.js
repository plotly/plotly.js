/*
 *  /MathJax/extensions/MathML/content-mathml.js
 *
 *  Copyright (c) 2009-2013 The MathJax Consortium
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

MathJax.Extension["MathML/content-mathml"]={version:"2.3"};MathJax.Hub.Register.StartupHook("MathML Jax Ready",function(){var c=MathJax.InputJax.MathML,e=c.Parse.prototype;c.prefilterHooks.Add(function(h){if(!c.ctopXSLT){return}if(!c.ParseXML){c.ParseXML=c.createParser()}var i=c.ParseXML(e.preProcessMath(h.math));var g=c.ctopXSLT.transformToDocument(i);if((typeof g)==="string"){h.math=g}else{if(window.XMLSerializer){var f=new XMLSerializer();h.math=f.serializeToString(g.documentElement,i)}}});var a='<x:stylesheet version="1.0" xmlns:x="http://www.w3.org/1999/XSL/Transform" xmlns="http://www.w3.org/1998/Math/MathML" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:e="http://exslt.org/strings"  xmlns:c="http://exslt.org/common" exclude-result-prefixes="m e c">  <!--  Copyright David Carlisle 2001, 2002, 2008, 2009.  Use and distribution of this code are permitted under the terms of the<a href="http://www.w3.org/Consortium/Legal/copyright-software-19980720" >W3C Software Notice and License</a>. 2001-2002 MathML2 version 2008-2009     Updates for MathML3 --> <x:output method="xml" /> <x:template match="/"><x:apply-templates/></x:template> <x:template match="*"><x:copy><x:copy-of select="@*"/><x:apply-templates/></x:copy></x:template>    <x:template match="m:cn"><mn><x:apply-templates/></mn></x:template> <x:template match="m:cn[@type=\'complex-cartesian\']"><mrow><mn><x:apply-templates select="text()[1]"/></mn><mo>+</mo><mn><x:apply-templates select="text()[2]"/></mn><mo>&#8290;</mo><mi>i</mi></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'complex_cartesian\']]"><mrow><mn><x:apply-templates select="*[2]"/></mn><mo>+</mo><mn><x:apply-templates select="*[3]"/></mn><mo>&#8290;</mo><mi>i</mi></mrow></x:template> <x:template match="m:cn[@type=\'rational\']"><mrow><mn><x:apply-templates select="text()[1]"/></mn><mo>/</mo><mn><x:apply-templates select="text()[2]"/></mn></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'rational\']]"><mrow><mn><x:apply-templates select="*[2]"/></mn><mo>/</mo><mn><x:apply-templates select="*[3]"/></mn></mrow></x:template> <x:template match="m:cn[not(@type) or @type=\'integer\']"><x:choose><x:when test="not(@base) or @base=10"><mn><x:apply-templates/></mn></x:when><x:otherwise><msub><mn><x:apply-templates/></mn><mn><x:value-of select="@base"/></mn></msub></x:otherwise></x:choose></x:template> <x:template match="m:cn[@type=\'complex-polar\']"><mrow><mn><x:apply-templates select="text()[1]"/></mn><mo>&#8290;</mo><msup><mi>e</mi><mrow><mi>i</mi><mo>&#8290;</mo><mn><x:apply-templates select="text()[2]"/></mn></mrow></msup></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'complex_polar\']]"><mrow><x:apply-templates select="*[2]"/><mo>&#8290;</mo><msup><mi>e</mi><mrow><mi>i</mi><mo>&#8290;</mo><x:apply-templates select="*[3]"/></mrow></msup></mrow></x:template> <x:template match="m:cn[@type=\'e-notation\']"><mn><x:apply-templates select="m:sep/preceding-sibling::node()"/><x:text>E</x:text><x:apply-templates select="m:sep/following-sibling::node()"/></mn></x:template> <x:template match="m:cn[@type=\'hexdouble\']"><mn><x:text>0x</x:text><x:apply-templates/></mn></x:template>   <x:template match="m:ci/text()"><mi><x:value-of select="."/></mi></x:template> <x:template match="m:ci"><mrow><x:apply-templates/></mrow></x:template>   <x:template match="m:csymbol/text()"><mi><x:value-of select="."/></mi></x:template> <x:template match="m:csymbol"><mrow><x:apply-templates/></mrow></x:template>   <x:template match="m:apply|m:reln"><mrow><x:choose><x:when test="*[1]/*/*"><mfenced separators="">    <x:apply-templates select="*[1]">       <x:with-param name="p" select="10"/>    </x:apply-templates></mfenced></x:when><x:otherwise><x:apply-templates select="*[1]">   <x:with-param name="p" select="10"/></x:apply-templates></x:otherwise></x:choose><mo>&#8289;</mo><mfenced open="(" close=")" separators=","><x:apply-templates select="*[position()>1]"/></mfenced></mrow></x:template>  <x:template match="m:bind"><mrow><x:choose><x:when test="*[1]/*/*"><mfenced separators="">     <x:apply-templates select="*[1]">       <x:with-param name="p" select="10"/>    </x:apply-templates></mfenced></x:when><x:otherwise><x:apply-templates select="*[1]">   <x:with-param name="p" select="10"/></x:apply-templates></x:otherwise></x:choose><x:apply-templates select="bvar/*"/><mo>.</mo><x:apply-templates select="*[position()>1][not(self::m:bvar)]"/></mrow></x:template>  <x:template match="m:fn"><mrow><x:apply-templates/></mrow></x:template>  <x:template match="m:interval[*[2]]"><mfenced open="[" close="]"><x:apply-templates/></mfenced></x:template><x:template match="m:interval[*[2]][@closure=\'open\']" priority="2"><mfenced open="(" close=")"><x:apply-templates/></mfenced></x:template><x:template match="m:interval[*[2]][@closure=\'open-closed\']" priority="2"><mfenced open="(" close="]"><x:apply-templates/></mfenced></x:template><x:template match="m:interval[*[2]][@closure=\'closed-open\']" priority="2"><mfenced open="[" close=")"><x:apply-templates/></mfenced></x:template> <x:template match="m:interval"><mfenced open="{{" close="}}"><x:apply-templates/></mfenced></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'integer_interval\']]"><mfenced open="[" close="]"><x:apply-templates select="*[position()!=1]"/></mfenced></x:template><x:template match="m:apply[*[1][self::m:csymbol=\'interval\']]"><mfenced open="[" close="]"><x:apply-templates select="*[position()!=1]"/></mfenced></x:template><x:template match="m:apply[*[1][self::m:csymbol=\'interval-cc\']]"><mfenced open="[" close="]"><x:apply-templates select="*[position()!=1]"/></mfenced></x:template><x:template match="m:apply[*[1][self::m:csymbol=\'interval-oo\']]"><mfenced open="(" close=")"><x:apply-templates select="*[position()!=1]"/></mfenced></x:template><x:template match="m:apply[*[1][self::m:csymbol=\'oriented_interval\']]"><mfenced open="(" close=")"><x:apply-templates select="*[position()!=1]"/></mfenced></x:template>   <x:template match="m:apply[*[1][self::m:inverse]]                        |m:apply[*[1][self::m:csymbol=\'inverse\']]"><msup><x:apply-templates select="*[2]"/><mrow><mo>(</mo><mn>-1</mn><mo>)</mo></mrow></msup></x:template>    <x:template match="m:condition"><mrow><x:apply-templates/></mrow></x:template>  <x:template match="m:declare"/>  <x:template match="m:lambda                             |m:apply[*[1][self::m:csymbol=\'lambda\']]                              |m:bind[*[1][self::m:csymbol=\'lambda\']]"><mrow><mi>&#955;</mi><mrow><x:apply-templates select="m:bvar/*"/></mrow><mo>.</mo><mfenced><x:apply-templates select="*[last()]"/></mfenced></mrow></x:template>   <x:template match="m:apply[*[1][self::m:compose]]                        |m:apply[*[1][self::m:csymbol=\'left_compose\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8728;</mo></x:with-param></x:call-template></x:template>   <x:template match="m:ident"><mi>id</mi></x:template>  <x:template match="m:domain"><mi>domain</mi></x:template>  <x:template match="m:codomain"><mi>codomain</mi></x:template>  <x:template match="m:image"><mi>image</mi></x:template>  <x:template match="m:domainofapplication"><merror><mtext>unexpected domainofapplication</mtext></merror></x:template> <x:template match="m:apply[*[2][self::m:bvar]][m:domainofapplication]" priority="0.4"><mrow><munder><x:apply-templates select="*[1]"/><mrow><x:apply-templates select="m:bvar/*"/><mo>&#8712;</mo><x:apply-templates select="m:domainofapplication/*"/></mrow></munder><mfenced><x:apply-templates select="m:domainofapplication/following-sibling::*"/></mfenced></mrow></x:template> <x:template match="m:apply[m:domainofapplication]" priority="0.3"><mrow><mrow><mi>restriction</mi><mfenced><x:apply-templates select="*[1]"/><x:apply-templates select="m:domainofapplication/*"/></mfenced></mrow><mfenced><x:apply-templates select="m:domainofapplication/following-sibling::*"/></mfenced></mrow></x:template>  <x:template match="m:piecewise"><mrow><mo>{</mo><mtable><x:for-each select="m:piece|m:otherwise">   <mtr>   <mtd><x:apply-templates select="*[1]"/></mtd>   <x:choose>      <x:when  test="self::m:piece">  <mtd columnalign="left"><mtext>&#160; if &#160;</mtext></mtd>   <mtd><x:apply-templates select="*[2]"/></mtd>   </x:when>       <x:otherwise>   <mtd colspan="2" columnalign="left"><mtext>&#160; otherwise</mtext></mtd>       </x:otherwise>  </x:choose>     </mtr></x:for-each></mtable></mrow></x:template>   <x:template match="m:apply[*[1][self::m:quotient]]                        |m:apply[*[1][self::m:csymbol=\'quotient\']]"><mrow><mo>&#8970;</mo><x:apply-templates select="*[2]"/><mo>/</mo><x:apply-templates select="*[3]"/><mo>&#8971;</mo></mrow></x:template>    <x:template match="m:apply[*[1][self::m:factorial]]                              |m:apply[*[1][self::m:csymbol=\'factorial\']]"><mrow><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates><mo>!</mo></mrow></x:template>   <x:template match="m:apply[*[1][self::m:divide]]                          |m:apply[*[1][self::m:csymbol=\'divide\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>/</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:max]]                           |m:apply[*[1][self::m:csymbol=\'max\']]"><mrow><mi>max</mi><x:call-template name="set"/></mrow></x:template> <x:template match="m:apply[*[1][self::m:min]]|m:reln[*[1][self::m:min]]"><mrow><mi>min</mi><x:call-template name="set"/></mrow></x:template>  <x:template match="m:apply[*[1][self::m:minus] and count(*)=2]                               |m:apply[*[1][self::m:csymbol=\'unary_minus\']]"><mrow><mo>&#8722;</mo><x:apply-templates select="*[2]"><x:with-param name="p" select="5"/></x:apply-templates></mrow></x:template> <x:template match="m:apply[*[1][self::m:minus] and count(*)&gt;2]                           |m:apply[*[1][self::m:csymbol=\'minus\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>&#8722;</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="2"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:plus]]                              |m:apply[*[1][self::m:csymbol=\'plus\']]"><x:param name="p" select="0"/><mrow><x:if test="$p &gt; 2"><mo>(</mo></x:if><x:for-each select="*[position()&gt;1]"><x:if test="position() &gt; 1"><mo><x:choose><x:when test="self::m:apply[*[1][self::m:times] and       *[2][self::m:apply/*[1][self::m:minus] or self::m:cn[not(m:sep) and       (number(.) &lt; 0)]]]">&#8722;</x:when><x:otherwise>+</x:otherwise></x:choose></mo></x:if><x:choose><x:when test="self::m:apply[*[1][self::m:times] and       *[2][self::m:cn[not(m:sep) and (number(.) &lt;0)]]]"><mrow><mn><x:value-of select="-(*[2])"/></mn><mo>&#8290;</mo><x:apply-templates select="."><x:with-param name="first" select="2"/><x:with-param name="p" select="2"/></x:apply-templates></mrow></x:when><x:when test="self::m:apply[*[1][self::m:times] and       *[2][self::m:apply/*[1][self::m:minus]]]"><mrow><x:apply-templates select="./*[2]/*[2]"/><x:apply-templates select="."><x:with-param name="first" select="2"/><x:with-param name="p" select="2"/></x:apply-templates></mrow></x:when><x:otherwise><x:apply-templates select="."><x:with-param name="p" select="2"/></x:apply-templates></x:otherwise></x:choose></x:for-each><x:if test="$p &gt; 2"><mo>)</mo></x:if></mrow></x:template>   <x:template match="m:apply[*[1][self::m:power]]                                |m:apply[*[1][self::m:csymbol=\'power\']]"><msup><x:apply-templates select="*[2]"><x:with-param name="p" select="5"/></x:apply-templates><x:apply-templates select="*[3]"><x:with-param name="p" select="5"/></x:apply-templates></msup></x:template>  <x:template match="m:apply[*[1][self::m:rem]]                        |m:apply[*[1][self::m:csymbol=\'rem\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>mod</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:times]]                               |m:apply[*[1][self::m:csymbol=\'times\']]"            name="times"><x:param name="p" select="0"/><x:param name="first" select="1"/><mrow><x:if test="$p &gt; 3"><mo>(</mo></x:if><x:for-each select="*[position()&gt;1]"><x:if test="position() &gt; 1"><mo><x:choose><x:when test="self::m:cn">&#215;</x:when><x:otherwise>&#8290;</x:otherwise></x:choose></mo></x:if><x:if test="position()&gt;= $first"><x:apply-templates select="."><x:with-param name="p" select="3"/></x:apply-templates></x:if></x:for-each><x:if test="$p &gt; 3"><mo>)</mo></x:if></mrow></x:template>   <x:template match="m:apply[*[1][self::m:root] and not(m:degree) or m:degree=2]" priority="4"><msqrt><x:apply-templates select="*[position()&gt;1]"/></msqrt></x:template> <x:template match="m:apply[*[1][self::m:root]]"><mroot><x:apply-templates select="*[position()&gt;1 and not(self::m:degree)]"/><mrow><x:apply-templates select="m:degree/*"/></mrow></mroot></x:template>  <x:template match="m:apply[*[1][self::m:csymbol=\'root\']]"><mroot><x:apply-templates select="*[position()!=1]"/></mroot></x:template>  <x:template match="m:gcd"><mi>gcd</mi></x:template>  <x:template match="m:apply[*[1][self::m:and]]                             |m:reln[*[1][self::m:and]]                              |m:apply[*[1][self::m:csymbol=\'and\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8743;</mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:or]]                        |m:apply[*[1][self::m:csymbol=\'or\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="3"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8744;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:xor]]                        |m:apply[*[1][self::m:csymbol=\'xor\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="3"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>xor</mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:not]]                        |m:apply[*[1][self::m:csymbol=\'not\']]"><mrow><mo>&#172;</mo><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates></mrow></x:template>     <x:template match="m:apply[*[1][self::m:implies]]                          |m:reln[*[1][self::m:implies]]                          |m:apply[*[1][self::m:csymbol=\'implies\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>&#8658;</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:forall]]                        |m:apply[*[1][self::m:csymbol=\'forall\']]                        |m:bind[*[1][self::m:forall]]                        |m:bind[*[1][self::m:csymbol=\'forall\']]"><mrow><mo>&#8704;</mo><mrow><x:apply-templates select="m:bvar[not(current()/m:condition)]/*|m:condition/*"/></mrow><mo>.</mo><mfenced><x:apply-templates select="*[last()]"/></mfenced></mrow></x:template>    <x:template match="m:apply[*[1][self::m:exists]]                        |m:apply[*[1][self::m:csymbol=\'exists\']]                        |m:bind[*[1][self::m:exists]]                        |m:bind[*[1][self::m:csymbol=\'exists\']]"><mrow><mo>&#8707;</mo><mrow><x:apply-templates select="m:bvar[not(current()/m:condition)]/*|m:condition/*"/></mrow><mo>.</mo><mfenced separators=""><x:choose><x:when test="m:condition"><x:apply-templates select="m:condition/*"/><mo>&#8743;</mo></x:when><x:when test="m:domainofapplication"><mrow><mrow>        <x:for-each select="m:bvar">    <x:apply-templates/>    <x:if test="position()!=last()">        <mo>,</mo>      </x:if> </x:for-each></mrow><mo>&#8712;</mo><x:apply-templates select="m:domainofapplication/*"/></mrow><mo>&#8743;</mo></x:when></x:choose><x:apply-templates select="*[last()]"/></mfenced></mrow></x:template>    <x:template match="m:apply[*[1][self::m:abs]]                        |m:apply[*[1][self::m:csymbol=\'abs\']]"><mrow><mo>|</mo><x:apply-templates select="*[2]"/><mo>|</mo></mrow></x:template>    <x:template match="m:apply[*[1][self::m:conjugate]]                        |m:apply[*[1][self::m:csymbol=\'conjugate\']]"><mover><x:apply-templates select="*[2]"/><mo>&#175;</mo></mover></x:template>  <x:template match="m:arg"><mi>arg</mi></x:template>   <x:template match="m:real|m:csymbol[.=\'real\']"><mo>&#8475;</mo></x:template>  <x:template match="m:imaginary|m:csymbol[.=\'imaginary\']"><mo>&#8465;</mo></x:template>  <x:template match="m:lcm"><mi>lcm</mi></x:template>   <x:template match="m:apply[*[1][self::m:floor]]                        |m:apply[*[1][self::m:csymbol=\'floor\']]"><mrow><mo>&#8970;</mo><x:apply-templates select="*[2]"/><mo>&#8971;</mo></mrow></x:template>   <x:template match="m:apply[*[1][self::m:ceiling]]                        |m:apply[*[1][self::m:csymbol=\'ceiling\']]"><mrow><mo>&#8968;</mo><x:apply-templates select="*[2]"/><mo>&#8969;</mo></mrow></x:template>  <x:template match="m:apply[*[1][self::m:eq]]                                 |m:reln[*[1][self::m:eq]]                               |m:apply[*[1][self::m:csymbol=\'eq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>=</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:neq]]                        |m:apply[*[1][self::m:csymbol=\'neq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8800;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:gt]]                            |m:reln[*[1][self::m:gt]]                               |m:apply[*[1][self::m:csymbol=\'gt\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&gt;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:lt]]                               |m:reln[*[1][self::m:lt]]                               |m:apply[*[1][self::m:csymbol=\'lt\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&lt;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:geq]]                              |m:apply[*[1][self::m:csymbol=\'geq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8805;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:leq]]                        |m:apply[*[1][self::m:csymbol=\'leq\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8804;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:equivalent]]                        |m:apply[*[1][self::m:csymbol=\'equivalent\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8801;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:approx]]                        |m:apply[*[1][self::m:csymbol=\'approx\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="1"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8771;</mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:factorof]]                        |m:apply[*[1][self::m:csymbol=\'factorof\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>|</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:int]]                        |m:apply[*[1][self::m:csymbol=\'int\']]                        |m:bind[*[1][self::m:int]]                        |m:bind[*[1][self::m:csymbol=\'int\']]"><mrow><msubsup><mi>&#8747;</mi><mrow><x:apply-templates select="m:lowlimit/*|m:interval/*[1]|m:condition/*|m:domainofapplication/*"/></mrow><mrow><x:apply-templates select="m:uplimit/*|m:interval/*[2]"/></mrow></msubsup><x:apply-templates select="*[last()]"/><x:if test="m:bvar"><mi>d</mi><x:apply-templates select="m:bvar"/></x:if></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'defint\']]"><mrow><munder><mi>&#8747;</mi><x:apply-templates select="*[2]"/></munder><x:apply-templates select="*[last()]"/></mrow></x:template>  <x:template match="m:apply[*[1][self::m:diff] and not(m:bvar)]|                           m:apply[*[1][self::m:csymbol=\'diff\']]" priority="2"><msup><mrow><x:apply-templates select="*[2]"/></mrow><mo>&#8242;</mo></msup></x:template> <x:template match="m:apply[*[1][self::m:diff]]" priority="1"><mfrac><x:choose><x:when test="m:bvar/m:degree"><mrow><msup><mi>d</mi><x:apply-templates select="m:bvar/m:degree/node()"/></msup><x:apply-templates  select="*[last()]"/></mrow><mrow><mi>d</mi><msup><x:apply-templates  select="m:bvar/node()"/><x:apply-templates  select="m:bvar/m:degree/node()"/></msup></mrow></x:when><x:otherwise><mrow><mi>d</mi><x:apply-templates select="*[last()]"/></mrow><mrow><mi>d</mi><x:apply-templates select="m:bvar"/></mrow></x:otherwise></x:choose></mfrac></x:template>   <x:template match="m:apply[*[1][self::m:partialdiff] and m:list and m:ci and count(*)=3]" priority="2"><mrow><msub><mi>D</mi><mrow><x:for-each select="m:list[1]/*"><x:apply-templates select="."/><x:if test="position()&lt;last()"><mo>,</mo></x:if></x:for-each></mrow></msub><mrow><x:apply-templates select="*[3]"/></mrow></mrow></x:template> <x:template match="m:apply[*[1][self::m:partialdiff]]" priority="1"><mfrac><mrow><x:choose>      <x:when test="not(m:bvar/m:degree) and not(m:bvar[2])"> <mo>&#8706;</mo>        </x:when>       <x:otherwise>   <msup><mo>&#8706;</mo>  <mrow>  <x:choose>      <x:when test="m:degree">                <x:apply-templates select="m:degree/node()"/>   </x:when>       <x:when test="m:bvar/m:degree[string(number(.))=\'NaN\']">              <x:for-each select="m:bvar/m:degree">           <x:apply-templates select="node()"/>            <x:if test="position()&lt;last()"><mo>+</mo></x:if>             </x:for-each>           <x:if test="count(m:bvar[not(m:degree)])&gt;0">         <mo>+</mo><mn><x:value-of select="count(m:bvar[not(m:degree)])"/></mn>          </x:if> </x:when>       <x:otherwise>           <mn><x:value-of select="number(sum(m:bvar/m:degree))+count(m:bvar[not(m:degree)])"/></mn>       </x:otherwise>  </x:choose>     </mrow> </msup> </x:otherwise></x:choose><x:apply-templates  select="*[last()]"/></mrow><mrow><x:for-each select="m:bvar">      <mrow>  <mo>&#8706;</mo><msup><x:apply-templates select="node()"/>      <mrow><x:apply-templates select="m:degree/node()"/></mrow>      </msup> </mrow></x:for-each></mrow></mfrac></x:template>  <x:template match="m:apply[*[1][self::m:csymbol=\'partialdiffdegree\']]"><mrow><msub><mo>&#8706;</mo><mrow><x:apply-templates select="*[2]"/></mrow></msub><mfenced><x:apply-templates select="*[4]"/></mfenced></mrow></x:template>   <x:template match="m:lowlimit"/>  <x:template match="m:uplimit"/>  <x:template match="m:bvar"><mi><x:apply-templates/></mi><x:if test="following-sibling::m:bvar"><mo>,</mo></x:if></x:template>  <x:template match="m:degree"/>  <x:template match="m:divergence"><mi>div</mi></x:template> <x:template match="m:apply[*[1][self::m:divergence]and m:bvar and m:vector]"><x:variable name="v" select="m:bvar"/><mrow><mi>div</mi><mo>&#8289;</mo><mo>(</mo><mtable><x:for-each select="m:vector/*"><x:variable name="p" select="position()"/><mtr><mtd><x:apply-templates select="$v[$p]/*"/><mo>&#x21a6;</mo><x:apply-templates select="."/></mtd></mtr></x:for-each></mtable><mo>)</mo></mrow></x:template>  <x:template match="m:grad"><mi>grad</mi></x:template> <x:template match="m:apply[*[1][self::m:grad]and m:bvar]"><mrow><mi>grad</mi><mo>&#8289;</mo><mrow><mo>(</mo><mfenced><x:apply-templates select="m:bvar/*"/></mfenced><mo>&#x21a6;</mo><x:apply-templates select="*[position()!=1][not(self::m:bvar)]"/><mo>)</mo></mrow></mrow></x:template>  <x:template match="m:curl"><mi>curl</mi></x:template>   <x:template match="m:laplacian"><msup><mo>&#8711;</mo><mn>2</mn></msup></x:template> <x:template match="m:apply[*[1][self::m:laplacian]and m:bvar]"><mrow><x:apply-templates select="*[1]"/><mo>&#8289;</mo><mrow><mo>(</mo><mfenced><x:apply-templates select="m:bvar/*"/></mfenced><mo>&#x21a6;</mo><x:apply-templates select="*[position()!=1][not(self::m:bvar)]"/><mo>)</mo></mrow></mrow></x:template>   <x:template match="m:set"><x:call-template name="set"/></x:template> <x:template  match="m:apply[*[1][self::m:csymbol=\'set\']]"><mfenced open="{{" close="}}" separators=","><x:apply-templates select="*[position()!=1]"/></mfenced></x:template>   <x:template match="m:list"><x:call-template name="set"><x:with-param name="o" select="\'(\'"/><x:with-param name="c" select="\')\'"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:csymbol=\'list\']]"><mfenced open="(" close=")" separators=","><x:apply-templates select="*[position()!=1]"/></mfenced></x:template>  <x:template match="m:apply[*[1][self::m:union]]                        |m:apply[*[1][self::m:csymbol=\'union\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8746;</mo></x:with-param></x:call-template></x:template> <x:template match="m:apply[*[1][self::m:union]][m:bvar]                                 |m:apply[*[1][self::m:csymbol=\'union\']][m:bvar]"            priority="2" ><x:call-template name="sum"><x:with-param name="mo"><mo>&#x22C3;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:intersect]]                        |m:apply[*[1][self::m:csymbol=\'intersect\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="3"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8745;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:intersect]][m:bvar]                          |m:apply[*[1][self::m:csymbol=\'intersect\']][m:bvar]"        priority="2" ><x:call-template name="sum"><x:with-param name="mo"><mo>&#x22C2;</mo></x:with-param></x:call-template></x:template>    <x:template match="m:apply[*[1][self::m:in]]                        |m:apply[*[1][self::m:csymbol=\'in\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>&#8712;</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:notin]]|m:reln[*[1][self::m:notin]]                        |m:apply[*[1][self::m:csymbol=\'notin\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="mo"><mo>&#8713;</mo></x:with-param><x:with-param name="p" select="$p"/><x:with-param name="this-p" select="3"/></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:subset]]                        |m:apply[*[1][self::m:csymbol=\'subset\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8838;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:prsubset]]                        |m:apply[*[1][self::m:csymbol=\'prsubset\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8834;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:notsubset]]                        |m:apply[*[1][self::m:csymbol=\'notsubset\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8840;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:notprsubset]]                        |m:apply[*[1][self::m:csymbol=\'notprsubset\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8836;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:setdiff]]                        |m:apply[*[1][self::m:csymbol=\'setdiff\']]"><x:param name="p" select="0"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#8726;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:card]]                        |m:apply[*[1][self::m:csymbol=\'card\']]"><mrow><mo>|</mo><x:apply-templates select="*[2]"/><mo>|</mo></mrow></x:template>  <x:template match="m:apply[*[1][self::m:cartesianproduct or self::m:vectorproduct]]                               |m:apply[*[1][self::m:csymbol[.=\'cartesian_product\' or . = \'vectorproduct\']]]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#215;</mo></x:with-param></x:call-template></x:template> <x:template match="m:apply[*[1][self::m:cartesianproduct][count(following-sibling::m:reals)=count(following-sibling::*)]]" priority="2"><msup><x:apply-templates select="*[2]"><x:with-param name="p" select="5"/></x:apply-templates><mn><x:value-of select="count(*)-1"/></mn></msup></x:template>   <x:template name="sum" match="m:apply[*[1][self::m:sum]]"><x:param name="mo"><mo>&#8721;</mo></x:param><mrow><munderover><x:copy-of select="$mo"/><mrow><x:apply-templates select="m:lowlimit|m:interval/*[1]|m:condition/*|m:domainofapplication/*"/></mrow><mrow><x:apply-templates select="m:uplimit/*|m:interval/*[2]"/></mrow></munderover><x:apply-templates select="*[last()]"/></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'sum\']]"><mrow><munder><mo>&#8721;</mo><x:apply-templates select="*[2]"/></munder><x:apply-templates select="*[last()]"/></mrow></x:template> <x:template match="m:apply/m:lowlimit" priority="3"><mrow><x:if test="../m:bvar"><x:apply-templates select="../m:bvar/node()"/><mo>=</mo></x:if><x:apply-templates/></mrow></x:template>  <x:template match="m:apply[*[1][self::m:product]]"><x:call-template name="sum"><x:with-param name="mo"><mo>&#8719;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:apply[*[1][self::m:csymbol=\'product\']]"><mrow><munder><mo>&#8719;</mo><x:apply-templates select="*[2]"/></munder><x:apply-templates select="*[last()]"/></mrow></x:template>  <x:template match="m:apply[*[1][self::m:limit]]"><mrow><munder><mi>lim</mi><mrow><x:apply-templates select="m:lowlimit|m:condition/*"/></mrow></munder><x:apply-templates select="*[last()]"/></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'limit\']][m:bind]"><mrow><munder><mi>lim</mi><mrow><x:apply-templates select="m:bind/m:bvar/*"/><mo><x:choose>   <x:when test="*[3]=\'above\'">&#8600;</x:when>  <x:when test="*[3]=\'below\'">&#8599;</x:when>  <x:otherwise>&#8594;</x:otherwise></x:choose></mo><x:apply-templates select="*[2]"/></mrow></munder><x:apply-templates select="m:bind/*[last()]"/></mrow></x:template>   <x:template match="m:apply[m:limit]/m:lowlimit" priority="4"><mrow><x:apply-templates select="../m:bvar/node()"/><mo>&#8594;</mo><x:apply-templates/></mrow></x:template>   <x:template match="m:apply[*[1][self::m:tendsto]]|m:reln[*[1][self::m:tendsto]]"><x:param name="p"/><x:call-template name="binary"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo><x:choose><x:when test="@type=\'above\'">&#8600;</x:when><x:when test="@type=\'below\'">&#8599;</x:when><x:when test="@type=\'two-sided\'">&#8594;</x:when><x:otherwise>&#8594;</x:otherwise></x:choose></mo></x:with-param></x:call-template></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'tendsto\']]"><mrow><x:apply-templates select="*[3]"/><mo><x:choose>       <x:when test="*[1][self::above]">&#8600;</x:when>       <x:when test="*[1][self::below]">&#8599;</x:when>       <x:when test="*[1][self::two-sided]">&#8594;</x:when>   <x:otherwise>&#8594;</x:otherwise></x:choose></mo><x:apply-templates select="*[4]"/></mrow></x:template> <x:template match="m:apply[*[1][self::m:semantics/m:ci=\'tendsto\']]"><mrow><x:apply-templates select="*[2]"/><mo>&#8594;</mo><x:apply-templates select="*[3]"/></mrow></x:template> <x:template match="m:tendsto"><mi>tendsto</mi></x:template>  <x:template match="m:apply[*[1][  self::m:sin or self::m:cos or self::m:tan or self::m:sec or  self::m:csc or self::m:cot or self::m:sinh or self::m:cosh or  self::m:tanh or self::m:sech or self::m:csch or self::m:coth or  self::m:arcsin or self::m:arccos or self::m:arctan or self::m:arccosh  or self::m:arccot or self::m:arccoth or self::m:arccsc or  self::m:arccsch or self::m:arcsec or self::m:arcsech or  self::m:arcsinh or self::m:arctanh or self::m:ln]]"><mrow><mi><x:value-of select="local-name(*[1])"/></mi><mo>&#8289;</mo><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates></mrow></x:template>  <x:template match="  m:sin | m:cos | m:tan | m:sec |  m:csc | m:cot | m:sinh | m:cosh |  m:tanh | m:sech | m:csch | m:coth |  m:arcsin | m:arccos | m:arctan | m:arccosh  | m:arccot | m:arccoth | m:arccsc |  m:arccsch | m:arcsec | m:arcsech |  m:arcsinh | m:arctanh | m:ln|m:mean|  m:plus|m:minus"><mi><x:value-of select="local-name()"/></mi></x:template>     <x:template match="m:apply[*[1][self::m:exp]]                        |m:apply[*[1][self::m:csymbol=\'exp\']]"><msup><mi>e</mi><mrow><x:apply-templates select="*[2]"/></mrow></msup></x:template>     <x:template match="m:apply[*[1][self::m:log]]                        |m:apply[*[1][self::m:csymbol=\'log\']]"><mrow><x:choose><x:when test="not(m:logbase) or m:logbase=10"><mi>log</mi></x:when><x:otherwise><msub><mi>log</mi><mrow><x:apply-templates select="m:logbase/node()"/></mrow></msub></x:otherwise></x:choose><mo>&#8289;</mo><x:apply-templates select="*[last()]"><x:with-param name="p" select="7"/></x:apply-templates></mrow></x:template>   <x:template match="m:apply[*[1][self::m:mean]]                        |m:apply[*[1][self::m:csymbol=\'mean\']]"><mrow><mo>&#9001;</mo><x:for-each select="*[position()&gt;1]"><x:apply-templates select="."/><x:if test="position() !=last()"><mo>,</mo></x:if></x:for-each><mo>&#9002;</mo></mrow></x:template>   <x:template match="m:sdev|m:csymbol[.=\'sdev\']"><mo>&#963;</mo></x:template>  <x:template match="m:apply[*[1][self::m:variance]]                        |m:apply[*[1][self::m:csymbol=\'variance\']]"><msup><mrow><mo>&#963;</mo><mo>&#8289;</mo><mfenced><x:apply-templates select="*[position()!=1]"/></mfenced></mrow><mn>2</mn></msup></x:template>   <x:template match="m:median"><mi>median</mi></x:template>   <x:template match="m:mode"><mi>mode</mi></x:template>  <x:template match="m:apply[*[1][self::m:moment]]"><mrow><mo>&#9001;</mo><msup><x:variable name="data"                     select="*[not(position()=1)]                            [not(self::m:degree or self::m:momentabout)]"/><x:choose>   <x:when test="$data[2]">        <mfenced>       <x:apply-templates select="$data"/>     </mfenced>      </x:when>       <x:otherwise>   <x:apply-templates select="$data"/>     </x:otherwise></x:choose><mrow><x:apply-templates select="m:degree/node()"/></mrow></msup><mo>&#9002;</mo></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'moment\']]"><msub><mrow><mo>&#9001;</mo><msup> <x:apply-templates select="*[4]"/>      <x:apply-templates select="*[2]"/></msup><mo>&#9002;</mo></mrow><x:apply-templates select="*[3]"/>       </msub></x:template>  <x:template match="m:momentabout"/> <x:template match="m:apply[*[1][self::m:moment]][m:momentabout]" priority="2"><msub><mrow><mo>&#9001;</mo><msup>     <x:variable name="data"                       select="*[not(position()=1)]                            [not(self::m:degree or self::m:momentabout)]"/>   <x:choose>      <x:when test="$data[2]">        <mfenced>       <x:apply-templates select="$data"/>     </mfenced>      </x:when>       <x:otherwise>   <x:apply-templates select="$data"/>     </x:otherwise>  </x:choose>     <mrow><x:apply-templates select="m:degree/node()"/></mrow></msup><mo>&#9002;</mo></mrow><mrow><x:apply-templates select="m:momentabout/*"/></mrow></msub></x:template>  <x:template match="m:vector"><mrow><mo>(</mo><mtable><x:for-each select="*"><mtr><mtd><x:apply-templates select="."/></mtd></mtr></x:for-each></mtable><mo>)</mo></mrow></x:template>  <x:template match="m:vector[m:condition]"><mrow><mo>[</mo><x:apply-templates select="*[last()]"/><mo>|</mo><x:apply-templates select="m:condition"/><mo>]</mo></mrow></x:template> <x:template match="m:vector[m:domainofapplication]"><mrow><mo>[</mo><x:apply-templates select="*[last()]"/><mo>|</mo><x:apply-templates select="m:bvar/*"/><mo>&#x2208;</mo><x:apply-templates select="m:domainofapplication/*"/><mo>]</mo></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'vector\']]"><mrow><mo>(</mo><mtable><x:for-each select="*[position()!=1]"><mtr><mtd><x:apply-templates select="."/></mtd></mtr></x:for-each></mtable><mo>)</mo></mrow></x:template>  <x:template match="m:matrix"><mrow><mo>(</mo><mtable><x:apply-templates/></mtable><mo>)</mo></mrow></x:template> <x:template match="m:matrix[m:condition]"><mrow><mo>[</mo><msub><mi>m</mi><mrow>      <x:for-each select="m:bvar">    <x:apply-templates/>    <x:if test="position()!=last()"><mo>,</mo></x:if>       </x:for-each></mrow></msub><mo>|</mo><mrow><msub>       <mi>m</mi>      <mrow>  <x:for-each select="m:bvar">    <x:apply-templates/>    <x:if test="position()!=last()"><mo>,</mo></x:if>       </x:for-each>   </mrow></msub><mo>=</mo><x:apply-templates select="*[last()]"/></mrow><mo>;</mo><x:apply-templates select="m:condition"/><mo>]</mo></mrow></x:template> <x:template match="m:apply[*[1][self::m:csymbol=\'matrix\']]"><mrow><mo>(</mo><mtable><x:apply-templates select="*[position()!=1]"/></mtable><mo>)</mo></mrow></x:template>   <x:template match="m:matrix/m:matrixrow"><mtr><x:for-each select="*"><mtd><x:apply-templates select="."/></mtd></x:for-each></mtr></x:template> <x:template match="m:matrixrow"><mtable><mtr><x:for-each select="*"><mtd><x:apply-templates select="."/></mtd></x:for-each></mtr></mtable></x:template> <x:template match="m:apply[*[1][self::m:csymbol.=\'matrixrow\']]"><mtr><x:for-each select="*[position()!=1]"><mtd><x:apply-templates select="."/></mtd></x:for-each></mtr></x:template>  <x:template match="m:apply[*[1][self::m:determinant]]                        |m:apply[*[1][self::m:csymbol=\'determinant\']]"><mrow><mi>det</mi><mo>&#8289;</mo><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates></mrow></x:template> <x:template match="m:apply[*[1][self::m:determinant]][*[2][self::m:matrix]]" priority="2"><mrow><mo>|</mo><mtable><x:apply-templates select="m:matrix/*"/></mtable><mo>|</mo></mrow></x:template>  <x:template match="m:apply[*[1][self::m:transpose]]                        |m:apply[*[1][self::m:csymbol=\'transpose\']]"><msup><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates><mi>T</mi></msup></x:template>  <x:template match="m:apply[*[1][self::m:selector]]                        |m:apply[*[1][self::m:csymbol=\'selector\']]"><msub><x:apply-templates select="*[2]"><x:with-param name="p" select="7"/></x:apply-templates><mrow><x:for-each select="*[position()&gt;2]"><x:apply-templates select="."/><x:if test="position() !=last()"><mo>,</mo></x:if></x:for-each></mrow></msub></x:template>      <x:template match="m:apply[*[1][self::m:scalarproduct]]                        |m:apply[*[1][self::m:csymbol=\'scalarproduct\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>.</mo></x:with-param></x:call-template></x:template>   <x:template match="m:apply[*[1][self::m:outerproduct]]                        |m:apply[*[1][self::m:csymbol=\'outerproduct\']]"><x:param name="p" select="0"/><x:call-template name="infix"><x:with-param name="this-p" select="2"/><x:with-param name="p" select="$p"/><x:with-param name="mo"><mo>&#x2297;</mo></x:with-param></x:call-template></x:template>  <x:template match="m:semantics"><x:apply-templates select="*[1]"/></x:template><x:template match="m:semantics[m:annotation-xml/@encoding=\'MathML-Presentation\']"><x:apply-templates select="m:annotation-xml[@encoding=\'MathML-Presentation\']/node()"/></x:template>  <x:template match="m:integers"><mi mathvariant="double-struck">Z</mi></x:template>  <x:template match="m:reals"><mi mathvariant="double-struck">R</mi></x:template>  <x:template match="m:rationals"><mi mathvariant="double-struck">Q</mi></x:template>  <x:template match="m:naturalnumbers"><mi mathvariant="double-struck">N</mi></x:template>  <x:template match="m:complexes"><mi mathvariant="double-struck">C</mi></x:template>  <x:template match="m:primes"><mi mathvariant="double-struck">P</mi></x:template>  <x:template match="m:exponentiale"><mi>e</mi></x:template>  <x:template match="m:imaginaryi"><mi>i</mi></x:template>  <x:template match="m:notanumber"><mi>NaN</mi></x:template>  <x:template match="m:true"><mi>true</mi></x:template>  <x:template match="m:false"><mi>false</mi></x:template>  <x:template match="m:emptyset|m:csymbol[.=\'emptyset\']"><mi>&#8709;</mi></x:template>   <x:template match="m:pi|m:csymbol[.=\'pi\']"><mi>&#960;</mi></x:template>  <x:template match="m:eulergamma|m:csymbol[.=\'gamma\']"><mi>&#947;</mi></x:template>  <x:template match="m:infinity|m:csymbol[.=\'infinity\']"><mi>&#8734;</mi></x:template>   <x:template name="infix" ><x:param name="mo"/><x:param name="p" select="0"/><x:param name="this-p" select="0"/><x:variable name="dmo"><x:choose><x:when test="m:domainofapplication"><munder><x:copy-of select="$mo"/><mrow>  <x:apply-templates select="m:domainofapplication/*"/></mrow></munder></x:when><x:otherwise><x:copy-of select="$mo"/></x:otherwise></x:choose></x:variable><mrow><x:if test="$this-p &lt; $p"><mo>(</mo></x:if><x:for-each select="*[not(self::m:domainofapplication)][position()&gt;1]"><x:if test="position() &gt; 1"><x:copy-of select="$dmo"/></x:if><x:apply-templates select="."><x:with-param name="p" select="$this-p"/></x:apply-templates></x:for-each><x:if test="$this-p &lt; $p"><mo>)</mo></x:if></mrow></x:template> <x:template name="binary" ><x:param name="mo"/><x:param name="p" select="0"/><x:param name="this-p" select="0"/><mrow><x:if test="$this-p &lt; $p"><mo>(</mo></x:if><x:apply-templates select="*[2]"><x:with-param name="p" select="$this-p"/></x:apply-templates><x:copy-of select="$mo"/><x:apply-templates select="*[3]"><x:with-param name="p" select="$this-p"/></x:apply-templates><x:if test="$this-p &lt; $p"><mo>)</mo></x:if></mrow></x:template> <x:template name="set" ><x:param name="o" select="\'{\'"/><x:param name="c" select="\'}\'"/><mrow><mo><x:value-of select="$o"/></mo><x:choose><x:when test="m:condition"><mrow><x:apply-templates select="m:condition/following-sibling::*"/></mrow><mo>|</mo><mrow><x:apply-templates select="m:condition/node()"/></mrow></x:when><x:when test="m:domainofapplication"><mrow><x:apply-templates select="m:domainofapplication/following-sibling::*"/></mrow><mo>|</mo><mrow><x:apply-templates select="m:bvar/node()"/></mrow><mo>&#8712;</mo><mrow><x:apply-templates select="m:domainofapplication/node()"/></mrow></x:when><x:otherwise><x:for-each select="*[not(position()=1 and parent::m:apply)]"><x:apply-templates select="."/><x:if test="position() !=last()"><mo>,</mo></x:if></x:for-each></x:otherwise></x:choose><mo><x:value-of select="$c"/></mo></mrow></x:template>    <x:template match="m:cs"><ms><x:value-of select="                     translate(.,                    \'&#9;&#10;&#13;&#32;\',                        \'&#160;&#160;&#160;&#160;\')"/></ms></x:template> <x:template match="m:cbytes"><mrow/></x:template> <x:template match="m:cerror"><merror><x:apply-templates/></merror></x:template> <x:template match="m:share" priority="4"><mi href="{@href}">share<x:value-of select="substring-after(@href,\'#\')"/></mi></x:template>   <x:output indent="yes" omit-xml-declaration="yes"/> <x:template match="*"><x:copy><x:copy-of select="@*"/><x:apply-templates/></x:copy></x:template> <x:template match="*[@dir=\'rtl\']"  priority="10"><!--starting rtl<x:value-of select="name()"/>.--><x:apply-templates mode="rtl" select="."/></x:template> <x:template match="@*" mode="rtl"><x:copy-of select="."/></x:template><x:template match="*" mode="rtl"><x:copy><x:apply-templates select="@*" mode="rtl"/><x:for-each select="node()"><x:sort data-type="number" order="descending" select="position()"/><x:text></x:text><x:apply-templates mode="rtl" select="."/></x:for-each></x:copy></x:template> <x:template match="@open" mode="rtl"><x:attribute name="close"><x:value-of select="."/></x:attribute></x:template> <x:template match="@open[.=\'(\']" mode="rtl"><x:attribute name="close">)</x:attribute></x:template> <x:template match="@open[.=\')\']" mode="rtl"><x:attribute name="close">(</x:attribute></x:template>  <x:template match="@open[.=\'[\']" mode="rtl"><x:attribute name="close">]</x:attribute></x:template>  <x:template match="@open[.=\']\']" mode="rtl"><x:attribute name="close">[</x:attribute></x:template>  <x:template match="@open[.=\'{\']" mode="rtl"><x:attribute name="close">}</x:attribute></x:template>  <x:template match="@open[.=\'}\']" mode="rtl"><x:attribute name="close">{</x:attribute></x:template>  <x:template match="@close" mode="rtl"><x:attribute name="open"><x:value-of select="."/></x:attribute></x:template> <x:template match="@close[.=\'(\']" mode="rtl"><x:attribute name="open">)</x:attribute></x:template> <x:template match="@close[.=\')\']" mode="rtl"><x:attribute name="open">(</x:attribute></x:template>  <x:template match="@close[.=\'[\']" mode="rtl"><x:attribute name="open">]</x:attribute></x:template>  <x:template match="@close[.=\']\']" mode="rtl"><x:attribute name="open">[</x:attribute></x:template>  <x:template match="@close[.=\'{\']" mode="rtl"><x:attribute name="open">}</x:attribute></x:template>  <x:template match="@close[.=\'}\']" mode="rtl"><x:attribute name="open">{</x:attribute></x:template> <x:template match="m:mfrac[@bevelled=\'true\']" mode="rtl"><mrow><msub><mi></mi><x:apply-templates select="*[2]" mode="rtl"/></msub><mo>&#x5c;</mo><msup><mi></mi><x:apply-templates select="*[1]" mode="rtl"/></msup></mrow></x:template> <x:template match="m:mfrac" mode="rtl"><x:copy><x:apply-templates mode="rtl" select="@*|*"/></x:copy></x:template>   <x:template match="m:mroot" mode="rtl"><msup><menclose notation="top right"><x:apply-templates mode="rtl" select="@*|*[1]"/></menclose><x:apply-templates mode="rtl" select="*[2]"/></msup></x:template>  <x:template match="m:msqrt" mode="rtl"><menclose notation="top right"><x:apply-templates mode="rtl" select="@*|*[1]"/></menclose></x:template> <x:template match="m:mtable|m:munder|m:mover|m:munderover" mode="rtl" priority="2"><x:copy><x:apply-templates select="@*" mode="rtl"/><x:apply-templates mode="rtl"></x:apply-templates></x:copy></x:template><x:template match="m:msup" mode="rtl" priority="2"><mmultiscripts><x:apply-templates select="*[1]" mode="rtl"/><mprescripts/><none/><x:apply-templates select="*[2]" mode="rtl"/></mmultiscripts></x:template><x:template match="m:msub" mode="rtl" priority="2"><mmultiscripts><x:apply-templates select="*[1]" mode="rtl"/><mprescripts/><x:apply-templates select="*[2]" mode="rtl"/><none/></mmultiscripts></x:template><x:template match="m:msubsup" mode="rtl" priority="2"><mmultiscripts><x:apply-templates select="*[1]" mode="rtl"/><mprescripts/><x:apply-templates select="*[2]" mode="rtl"/><x:apply-templates select="*[3]" mode="rtl"/></mmultiscripts></x:template><x:template match="m:mmultiscripts" mode="rtl" priority="2"><mmultiscripts><x:apply-templates select="*[1]" mode="rtl"/><x:for-each  select="m:mprescripts/following-sibling::*[position() mod 2 = 1]"><x:sort data-type="number" order="descending" select="position()"/><x:apply-templates select="."  mode="rtl"/><x:apply-templates select="following-sibling::*[1]"  mode="rtl"/></x:for-each><mprescripts/><x:for-each  select="m:mprescripts/preceding-sibling::*[position()!=last()][position() mod 2 = 0]"><x:sort data-type="number" order="descending" select="position()"/><x:apply-templates select="."  mode="rtl"/><x:apply-templates select="following-sibling::*[1]"  mode="rtl"/></x:for-each></mmultiscripts></x:template><x:template match="m:mmultiscripts[not(m:mprescripts)]" mode="rtl" priority="3"><mmultiscripts><x:apply-templates select="*[1]" mode="rtl"/><mprescripts/><x:for-each  select="*[position() mod 2 = 0]"><x:sort data-type="number" order="descending" select="position()"/><x:apply-templates select="."  mode="rtl"/><x:apply-templates select="following-sibling::*[1]"  mode="rtl"/></x:for-each></mmultiscripts></x:template><x:template match="text()[.=\'(\']" mode="rtl">)</x:template><x:template match="text()[.=\')\']" mode="rtl">(</x:template><x:template match="text()[.=\'{\']" mode="rtl">}</x:template><x:template match="text()[.=\'}\']" mode="rtl">{</x:template><x:template match="text()[.=\'&lt;\']" mode="rtl">&gt;</x:template><x:template match="text()[.=\'&gt;\']" mode="rtl">&lt;</x:template><x:template match="text()[.=\'&#x2208;\']" mode="rtl">&#x220b;</x:template><x:template match="text()[.=\'&#x220b;\']" mode="rtl">&#x2208;</x:template><x:template match="text()[.=\'&#x2211;\']|text()[.=\'&#x222b;\']" mode="rtl"><svg width="20" height="20" version="1.1" xmlns="http://www.w3.org/2000/svg"><g transform="matrix(-1 0 0 1 0 0 )"><text id="TextElement" x="-20" y="15" ><x:value-of select="."/></text></g></svg></x:template> <x:template match="@notation[.=\'radical\']" mode="rtl"><x:attribute name="notation">top right</x:attribute></x:template>   <x:template name="mml2attrib"><!-- <x:copy-of select="@*[not(local-name()=\'href\')]"/> --><x:copy-of select="@*[not(local-name()=\'href\')]"/><x:attribute name="style"><x:if test="@style"><x:value-of select="@style"/>;</x:if><x:if test="@mathcolor">color:<x:value-of select="@mathcolor"/>;</x:if><x:if test="@mathbackground">background-color:<x:value-of select="@mathbackground"/>;</x:if></x:attribute></x:template>  <!-- <x:template match="*[@href]" priority="3"><a xmlns="http://www.w3.org/1999/xhtml" style="text-decoration: none" href="{@href}"><x:copy><x:call-template name="mml2attrib"/><x:attribute name="class"><x:text>mmlhref</x:text><x:value-of select="@class"/></x:attribute><x:apply-templates/></x:copy></a></x:template>--><x:template match="*[@mathcolor|@mathbackground]"><x:copy><x:call-template name="mml2attrib"/><x:apply-templates/></x:copy></x:template>   <x:param name="hascolspan" select="true()"/> <x:template match="m:mstack"><mtable columnspacing="0em"><x:variable name="t"><x:apply-templates select="*" mode="mstack1"><x:with-param name="p" select="0"/></x:apply-templates></x:variable><x:variable name="maxl"><x:for-each select="c:node-set($t)/*/@l"><x:sort data-type="number" order="descending"/><x:if test="position()=1"><x:value-of select="."/></x:if></x:for-each></x:variable><x:for-each select="c:node-set($t)/*[not(@class=\'mscarries\') or following-sibling::*[1]/@class=\'mscarries\']"><x:variable name="c" select="preceding-sibling::*[1][@class=\'mscarries\']"/><x:text>&#10;</x:text><mtr><x:variable name="offset" select="$maxl - @l"/><x:choose><x:when test="$hascolspan and @class=\'msline\' and (string(*[1]/@columnspan)=\'\' or string(*[1]/@columnspan)=\'0\')"><mtd columnspan="{$maxl}"><x:copy-of select="*/@style"/></mtd></x:when><x:when test="@class=\'msline\' and @l=\'*\'"><x:variable name="msl" select="*[1]"/><x:for-each select="(//node())[position()&lt;=$maxl]"><x:copy-of select="$msl"/></x:for-each></x:when><x:when test="$c"><x:variable name="ldiff" select="$c/@l - @l"/><x:variable name="loffset" select="$maxl - $c/@l"/><x:for-each select="(//*)[position()&lt;= $offset]"><x:variable name="pn" select="position()"/><x:variable name="cy" select="$c/*[position()=$pn - $loffset]"/>      <mtd>   <x:if test="$cy/*"/>    <mover><mphantom><mn>0</mn></mphantom><mpadded width="0em" lspace="-0.5width"><x:copy-of select="$cy/*/*"/></mpadded></mover>   </mtd></x:for-each><x:for-each select="*"><x:variable name="pn" select="position()"/><x:variable name="cy" select="$c/*[position()=$pn + $ldiff]"/><x:copy>     <x:copy-of select="@*"/>        <x:variable name="b">   <x:choose>      <x:when test="not(string($cy/@crossout) or $cy/@crossout=\'none\')"><x:copy-of select="*"/></x:when>    <x:otherwise>   <menclose notation="{$cy/@crossout}"><x:copy-of select="*"/></menclose> </x:otherwise>  </x:choose>     </x:variable>   <x:choose>      <x:when test="$cy/*/m:none or not($cy/*/*)"><x:copy-of select="$b"/></x:when>   <x:when test="not(string($cy/@location)) or $cy/@location=\'n\'">       <mover><x:copy-of select="$b"/><mpadded width="0em" lspace="-0.5width"><x:copy-of select="$cy/*/*"/></mpadded></mover>  </x:when>       <x:when test="$cy/@location=\'nw\'">    <mmultiscripts><x:copy-of select="$b"/><mprescripts/><none/><mpadded lspace="-1width" width="0em"><x:copy-of select="$cy/*/*"/></mpadded></mmultiscripts>       </x:when>       <x:when test="$cy/@location=\'s\'">     <munder><x:copy-of select="$b"/><mpadded width="0em" lspace="-0.5width"><x:copy-of select="$cy/*/*"/></mpadded></munder>        </x:when>       <x:when test="$cy/@location=\'sw\'">    <mmultiscripts><x:copy-of select="$b"/><mprescripts/><mpadded lspace="-1width" width="0em"><x:copy-of select="$cy/*/*"/></mpadded><none/></mmultiscripts>       </x:when>       <x:when test="$cy/@location=\'ne\'">    <msup><x:copy-of select="$b"/><mpadded width="0em"><x:copy-of select="$cy/*/*"/></mpadded></msup>       </x:when>       <x:when test="$cy/@location=\'se\'">    <msub><x:copy-of select="$b"/><mpadded width="0em"><x:copy-of select="$cy/*/*"/></mpadded></msub>       </x:when>       <x:when test="$cy/@location=\'w\'">     <msup><mrow/><mpadded lspace="-1width" width="0em"><x:copy-of select="$cy/*/*"/></mpadded></msup>       <x:copy-of select="$b"/>        </x:when>       <x:when test="$cy/@location=\'e\'">     <x:copy-of select="$b"/>        <msup><mrow/><mpadded width="0em"><x:copy-of select="$cy/*/*"/></mpadded></msup>        </x:when>       <x:otherwise>   <x:copy-of select="$b"/>        </x:otherwise>  </x:choose></x:copy></x:for-each></x:when><x:otherwise><x:for-each select="(//*)[position()&lt;= $offset]"><mtd/></x:for-each><x:copy-of select="*"/></x:otherwise></x:choose></mtr></x:for-each></mtable></x:template> <x:template mode="mstack1" match="*"><x:param name="p"/><x:param name="maxl" select="0"/><mtr l="{1 + $p}"><x:if test="ancestor::mstack[1]/@stackalign=\'left\'"><x:attribute name="l"><x:value-of  select="$p"/></x:attribute></x:if><mtd><x:apply-templates select="."/></mtd></mtr></x:template>  <x:template mode="mstack1" match="m:msrow"><x:param name="p"/><x:param name="maxl" select="0"/><x:variable  name="align1" select="ancestor::m:mstack[1]/@stackalign"/><x:variable name="align"><x:choose><x:when test="string($align1)=\'\'">decimalpoint</x:when><x:otherwise><x:value-of select="$align1"/></x:otherwise></x:choose></x:variable><x:variable name="row"><x:apply-templates mode="mstack1" select="*"><x:with-param name="p" select="0"/></x:apply-templates></x:variable><x:text>&#10;</x:text><x:variable name="l1"><x:choose><x:when test="$align=\'decimalpoint\' and m:mn"><x:for-each select="c:node-set($row)/m:mtr[m:mtd/m:mn][1]"><x:value-of select="number(sum(@l))+count(preceding-sibling::*/@l)"/></x:for-each></x:when><x:when test="$align=\'right\' or $align=\'decimalpoint\'"><x:value-of select="count(c:node-set($row)/m:mtr/m:mtd)"/></x:when><x:otherwise><x:value-of select="0"/></x:otherwise></x:choose></x:variable><mtr class="msrow" l="{number($l1) + number(sum(@position)) +$p}"><x:copy-of select="c:node-set($row)/m:mtr/*"/></mtr></x:template> <x:template mode="mstack1" match="m:mn"><x:param name="p"/><x:variable name="align1" select="ancestor::m:mstack[1]/@stackalign"/><x:variable name="dp1" select="ancestor::*[@decimalpoint][1]/@decimalpoint"/><x:variable name="align"><x:choose><x:when test="string($align1)=\'\'">decimalpoint</x:when><x:otherwise><x:value-of select="$align1"/></x:otherwise></x:choose></x:variable><x:variable name="dp"><x:choose><x:when test="string($dp1)=\'\'">.</x:when><x:otherwise><x:value-of select="$dp1"/></x:otherwise></x:choose></x:variable><mtr l="$p"><x:variable name="mn" select="normalize-space(.)"/><x:variable name="len" select="string-length($mn)"/><x:choose><x:when test="$align=\'right\' or ($align=\'decimalpoint\' and not(contains($mn,$dp)))"><x:attribute name="l"><x:value-of select="$p + $len"/></x:attribute></x:when><x:when test="$align=\'decimalpoint\'"><x:attribute name="l"><x:value-of select="$p + string-length(substring-before($mn,$dp))"/></x:attribute></x:when></x:choose> <x:for-each select="(//node())[position() &lt;=$len]"><x:variable name="pos" select="position()"/><mtd><mn><x:value-of select="substring($mn,$pos,1)"/></mn></mtd></x:for-each></mtr></x:template>  <x:template match="m:msgroup" mode="mstack1"><x:param name="p"/><x:variable name="s" select="number(sum(@shift))"/><x:variable name="thisp" select="number(sum(@position))"/><x:for-each select="*"><x:apply-templates mode="mstack1" select="."><x:with-param name="p" select="number($p)+$thisp+(position()-1)*$s"/></x:apply-templates></x:for-each></x:template>    <x:template match="m:msline" mode="mstack1"><x:param name="p"/><x:variable  name="align1" select="ancestor::m:mstack[1]/@stackalign"/><x:variable name="align"><x:choose><x:when test="string($align1)=\'\'">decimalpoint</x:when><x:otherwise><x:value-of select="$align1"/></x:otherwise></x:choose></x:variable><mtr class="msline"><x:attribute name="l"><x:choose><x:when test="not(string(@length)) or @length=0">*</x:when><x:when test="string($align)=\'right\' or string($align)=\'decimalpoint\' "><x:value-of select="$p+ @length"/></x:when><x:otherwise><x:value-of select="$p"/></x:otherwise></x:choose></x:attribute><x:variable name="w"><x:choose><x:when test="@mslinethickness=\'thin\'">0.1em</x:when><x:when test="@mslinethickness=\'medium\'">0.15em</x:when><x:when test="@mslinethickness=\'thick\'">0.2em</x:when><x:when test="@mslinethickness"><x:value-of select="@mslinethickness"/></x:when><x:otherwise>0.15em</x:otherwise></x:choose></x:variable><x:choose><x:when test="$hascolspan"><mtd class="msline" columnspan="{@length}"><x:copy-of select="@position"/><x:attribute name="style"><x:value-of select="concat(\'border-style: solid; border-width: 0 0 \',$w,\' 0\')"/></x:attribute></mtd></x:when><x:when test="not(string(@length)) or @length=0"><mtd class="mslinemax"><mpadded lspace="-0.5em" width="0em" height="0em"><mfrac linethickness="{$w}"><mspace width="1em"/><mrow/></mfrac></mpadded></mtd></x:when><x:otherwise><x:variable name="l" select="@length"/><x:for-each select="(//node())[position()&lt;=$l]"><mtd class="msline"><mpadded lspace="-0.5em" width="0em" height="0em"><mfrac linethickness="{$w}">    <mspace width="1em"/>   <mrow/></mfrac></mpadded></mtd></x:for-each></x:otherwise></x:choose></mtr></x:template>  <x:template match="m:mscarries" mode="mstack1"><x:param name="p"/><x:variable  name="align1" select="ancestor::m:mstack[1]/@stackalign"/><x:variable name="l1"><x:choose><x:when test="string($align1)=\'left\'">0</x:when><x:otherwise><x:value-of select="count(*)"/></x:otherwise></x:choose></x:variable><mtr class="mscarries" l="{$p + $l1 + sum(@position)}"><x:apply-templates select="*" mode="msc"/></mtr></x:template> <x:template match="*" mode="msc"><mtd><x:copy-of select="../@location|../@crossout"/><mstyle mathsize="70%"><x:apply-templates select="."/></mstyle></mtd></x:template> <x:template match="m:mscarry" mode="msc"><mtd><x:copy-of select="@location|@crossout"/><mstyle mathsize="70%"><x:apply-templates select="*"/></mstyle></mtd></x:template>  <x:template match="m:mlongdiv"><x:variable name="ms"><mstack><x:copy-of select="(ancestor-or-self::*/@decimalpoint)[last()]"/><x:choose><x:when test="@longdivstyle=\'left/\right\'"><msrow><mrow><x:copy-of select="*[1]"/></mrow><mo>/</mo><x:copy-of select="*[3]"/><mo></mo><x:copy-of select="*[2]"/></msrow></x:when><x:when test="@longdivstyle=\'left)(right\'"><msrow><mrow><x:copy-of select="*[1]"/></mrow><mo>)</mo><x:copy-of select="*[3]"/><mo>(</mo><x:copy-of select="*[2]"/></msrow></x:when><x:when test="@longdivstyle=\':right=right\'"><msrow><x:copy-of select="*[3]"/><mo>:</mo><x:copy-of select="*[1]"/><mo>=</mo><x:copy-of select="*[2]"/></msrow></x:when><x:otherwise><x:copy-of select="*[2]"/><msline length="{string-length(*[3])}"/><msrow><mrow><x:copy-of select="*[1]"/></mrow><mo>)</mo><x:copy-of select="*[3]"/></msrow></x:otherwise></x:choose><x:copy-of select="*[position()&gt;3]"/></mstack></x:variable><x:apply-templates select="c:node-set($ms)"/></x:template>    <x:template match="m:menclose[@notation=\'madruwb\']" mode="rtl"><menclose notation="bottom right"><x:apply-templates mode="rtl"/></menclose></x:template> </x:stylesheet>';var d;if(window.XSLTProcessor){if(!c.ParseXML){c.ParseXML=c.createParser()}c.ctopXSLT=new XSLTProcessor();c.ctopXSLT.importStylesheet(c.ParseXML(a))}else{if(MathJax.Hub.Browser.isMSIE){if(MathJax.Hub.Browser.versionAtLeast("9.0")){d=new ActiveXObject("Msxml2.FreeThreadedDOMDocument");d.loadXML(a);var b=new ActiveXObject("Msxml2.XSLTemplate");b.stylesheet=d;c.ctopXSLT={ctop:b.createProcessor(),transformToDocument:function(f){this.ctop.input=f;this.ctop.transform();return this.ctop.output}}}else{d=c.createMSParser();d.async=false;d.loadXML(a);c.ctopXSLT={ctop:d,transformToDocument:function(f){return f.documentElement.transformNode(this.ctop)}}}}else{c.ctopXSLT=null}}MathJax.Hub.Startup.signal.Post("MathML content-mathml Ready")});MathJax.Ajax.loadComplete("[MathJax]/extensions/MathML/content-mathml.js");
